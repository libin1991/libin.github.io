<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="promise,es6," />










<meta name="description" content="一、前言传统的解决代码单线程执行的方案是回调函数和事件。这是个解决问题的方案，但是会造成回调地狱。 异步编程是优化代码逻辑提高代码易读性的关键。 目前通用的异步编程方法有三种：  Promise generator+co async+await  这三种方法我都经常在用，但是对它们的原理却一知半解。于是想炒个冷饭从头到尾理一遍，梳理一下它们之间的关系。 二、Promise2.1 原理Promise">
<meta name="keywords" content="promise,es6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6之promise、generator+co、async+await手写promise">
<meta property="og:url" content="http://yoursite.com/2018/10/20/ES6之promise、generator-co、async-await手写promise/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="一、前言传统的解决代码单线程执行的方案是回调函数和事件。这是个解决问题的方案，但是会造成回调地狱。 异步编程是优化代码逻辑提高代码易读性的关键。 目前通用的异步编程方法有三种：  Promise generator+co async+await  这三种方法我都经常在用，但是对它们的原理却一知半解。于是想炒个冷饭从头到尾理一遍，梳理一下它们之间的关系。 二、Promise2.1 原理Promise">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="598"></svg>">
<meta property="og:updated_time" content="2018-10-20T04:07:19.693Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6之promise、generator+co、async+await手写promise">
<meta name="twitter:description" content="一、前言传统的解决代码单线程执行的方案是回调函数和事件。这是个解决问题的方案，但是会造成回调地狱。 异步编程是优化代码逻辑提高代码易读性的关键。 目前通用的异步编程方法有三种：  Promise generator+co async+await  这三种方法我都经常在用，但是对它们的原理却一知半解。于是想炒个冷饭从头到尾理一遍，梳理一下它们之间的关系。 二、Promise2.1 原理Promise">
<meta name="twitter:image" content="data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="598"></svg>">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/20/ES6之promise、generator-co、async-await手写promise/"/>





  <title>ES6之promise、generator+co、async+await手写promise | LuckDay</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/20/ES6之promise、generator-co、async-await手写promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ES6之promise、generator+co、async+await手写promise</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-20T12:06:32+08:00">
                2018-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>传统的解决代码单线程执行的方案是<code>回调函数和事件</code>。这是个解决问题的方案，但是会造成回调地狱。</p>
<p>异步编程是优化代码逻辑提高代码易读性的关键。</p>
<p>目前通用的异步编程方法有三种：</p>
<ol>
<li>Promise</li>
<li>generator+co</li>
<li>async+await</li>
</ol>
<p>这三种方法我都经常在用，但是对它们的原理却一知半解。于是想炒个冷饭从头到尾理一遍，梳理一下它们之间的关系。</p>
<h4 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h4><h5 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h5><p>Promise对象是一个构造函数，用来生成Promise实例。</p>
<p>Promise对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。</p>
<p>Promise函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是Promise中定义的两个函数，在运行自定义函数时返回。</p>
<p><code>resolve</code>函数将Promise对象的状态从 <code>pending</code> 变为<code>resolved</code>,<code>reject</code>将Promise对象的状态从 <code>pending</code> 变为<code>rejected</code></p>
<p>Promise的原型链上定义了then方法，提供两个回调函数分别捕获resolve、reject返回的值。</p>
<h5 id="2-2-静态方法"><a href="#2-2-静态方法" class="headerlink" title="2.2 静态方法"></a>2.2 静态方法</h5><p>方法描述Promise.resolve(promise);返回 promise（仅当 promise.constructor == Promise 时）Promise.resolve(thenable);从 thenable 中生成一个新 promise。thenable 是具有 <code>then()</code> 方法的类似于 promise 的对象。Promise.resolve(obj);在此情况下，生成一个 promise 并在执行时返回 obj。Promise.reject(obj);生成一个 promise 并在拒绝时返回 obj。为保持一致和调试之目的（例如堆叠追踪）， obj 应为 instanceof Error。Promise.all(array);生成一个 promise，该 promise 在数组中各项执行时执行，在任意一项拒绝时拒绝。Promise.race(array);生成一个 Promise，该 Promise 在任意项执行时执行，或在任意项拒绝时拒绝，以最先发生的为准。<br>sample 1</p>
<pre><code>let p1 = new Promise((resolve,reject)=&gt;{
    console.log(&apos;hello&apos;)
    setTimeout(function () {
        reject(&apos;1212&apos;)
    },1000)
})

p1.then(data=&gt; {
    console.log(&apos;success&apos;+data)
},err=&gt;{
    console.log(&apos;err&apos;+err)
})

p1.then(data=&gt; {
    console.log(&apos;success&apos;+data)
},err=&gt;{
    console.log(&apos;err&apos;+err)
})
复制代码
</code></pre><p>terminal:</p>
<pre><code>hello
err1212
err1212
复制代码
</code></pre><p>sample 1 中新建了一个Promise实例，定时1S后使用reject方法，将Promise实例的状态从pending变成rejected，触发then的err捕捉回调函数。</p>
<p>在sample 1 中调用then方法，并不会马上执行回调。是等待实例中状态改变后才会执行。这一点和<code>发布订阅</code>模式很类似。</p>
<p>sample 2</p>
<pre><code>let fs = require(&apos;fs&apos;)

let event = {
    arr:[],
    result:[],
    on(fn){
        this.arr.push(fn)
    },
    emit(data){
        this.result.push(data)
        this.arr.forEach(fn=&gt;fn(this.result))
    }
}

event.on(function (data) {
    if(data.length === 2){
        console.log(data)
    }
})

fs.readFile(&apos;1.txt&apos;,&apos;utf8&apos;,function (err,data) {
    event.emit(data)
})
fs.readFile(&apos;2.txt&apos;,&apos;utf8&apos;,function (err,data) {
    event.emit(data)
})
复制代码
</code></pre><p>smaple2 中将结果data放入暂存数组中，在执行接听函数的时候返回。</p>
<h5 id="2-3-简写Promise源码"><a href="#2-3-简写Promise源码" class="headerlink" title="2.3 简写Promise源码"></a>2.3 简写Promise源码</h5><p>通过之前的例子和对发布订阅模式的理解，我们可以大概写出Promise实例的基本功能：</p>
<p>code 1：</p>
<pre><code>function Promise(executor) {
    let self = this
    self.value = undefined
    self.reason = undefined
    self.status = &apos;pending&apos;
    self.onResovedCallbacks = []
    self.onRejectedCallbacks = []
    function resolve(data) {
        if(self.status === &apos;pending&apos;){
            self.value = data
            self.status = &apos;resolved&apos;
            self.onResovedCallbacks.forEach(fn=&gt;fn())
        }
    }
    function reject(reason) {
        if(self.status === &apos;pending&apos;) {
            self.reason = reason
            self.status = &apos;reject&apos;
            self.onRejectedCallbacks.forEach(fn=&gt;fn())
        }
    }
    //如果函数执行时发生异常
    try{
        executor(resolve,reject)
    }catch (e){
        reject(e)
    }
}

Promise.prototype.then = function (onFulfilled,onRejected) {
    let self = this
    if(self.status === &apos;pending&apos;){
        self.onResovedCallbacks.push(()=&gt;{
            onFulfilled(self.value)
        })
        self.onRejectedCallbacks.push(()=&gt;{
            onRejected(self.reason)
        })
    }elseif(self.status === &apos;resolved&apos;){
        onFulfilled(self.value)
    }elseif(self.status === &apos;reject&apos;){
        onRejected(self.reason)
    }

}

module.exports = Promise
复制代码
</code></pre><ul>
<li><p>函数内部变量</p>
</li>
<li><p>status：储存Promise的状态</p>
</li>
<li>onResovedCallbacks：储存Promise pending状态下成功回调函数</li>
<li>onRejectedCallbacks：储存Promise pending状态下失败回调函数</li>
<li>resolve函数</li>
<li><p>reject函数</p>
</li>
<li><p>Promise.prototype.then</p>
</li>
<li><p>根据实例状态执行响应的回调</p>
</li>
<li>status == pending使用发布订阅模式储存回调函数。</li>
</ul>
<h5 id="2-4-Promise用法简述"><a href="#2-4-Promise用法简述" class="headerlink" title="2.4 Promise用法简述"></a>2.4 Promise用法简述</h5><ol>
<li><p>如果一个promise执行完后,返回的还是一个Promise对象,会把这个promise的执行结果,传递给下一个then中。</p>
<p> let fs = require(‘fs’)</p>
<p> functionread(filePath,encoding) {</p>
<pre><code>return new Promise((resolve,reject)=&gt;{
    fs.readFile(filePath,encoding,(err,data)=&gt; {
        if(err) reject(err)
        resolve(data)
    })
})
</code></pre><p> }</p>
<p> read(‘1.txt’,’utf8’).then(</p>
<pre><code>f1=&gt;read(f1,&apos;utf8&apos;) // 1
</code></pre><p> ).then(</p>
<pre><code>data=&gt; console.log(&apos;resolved:&apos;,comments)
err=&gt; console.log(&apos;rejected: &apos;,err)
</code></pre><p> )<br> 复制代码</p>
</li>
<li><p>如果then中返回的不是promise，是一个普通值,会将这个普通值作为下一个then的返回结果。</p>
<p>  ……</p>
<p> read(‘1.txt’,’utf8’).then(</p>
<pre><code>f1=&gt;read(f1,&apos;utf8&apos;)
</code></pre><p> ).then(</p>
<pre><code>return 123 //2
</code></pre><p> ).then(</p>
<pre><code>data=&gt; console.log(&apos;resolved:&apos;,comments)
err=&gt; console.log(&apos;rejected: &apos;,err)
</code></pre><p> )<br> 复制代码</p>
</li>
<li><p>如果当前then中失败了会走下一个then的失败。</p>
<p>  ……</p>
<p> read(‘1.txt’,’utf8’).then(</p>
<pre><code>f1=&gt;read(f1,&apos;utf8&apos;)
</code></pre><p> ).then(</p>
<pre><code>return 123
</code></pre><p> ).then(</p>
<pre><code>throw new Error(&apos;出错&apos;) //3
</code></pre><p> ).then(</p>
<pre><code>data=&gt; console.log(&apos;resolved:&apos;,comments)
err=&gt; console.log(&apos;rejected: &apos;,err)
</code></pre><p> )<br> 复制代码</p>
</li>
<li><p>如果返回的是undefined不管当前是失败还是成功，都会走下一次成功。</p>
</li>
<li>catch是错误没有处理的情况下会走。</li>
<li><p>then中可以不写。</p>
<p>  ……</p>
<p> read(‘1.txt’,’utf8’).then(</p>
<pre><code>f1=&gt;read(f1,&apos;utf8&apos;)
</code></pre><p> ).then(</p>
<pre><code>return 123
</code></pre><p> ).then(</p>
<pre><code>throw new Error(&apos;出错&apos;) 
</code></pre><p> ).then() //6<br>  .then(</p>
<pre><code>data=&gt; console.log(&apos;resolved:&apos;,comments)
err=&gt; console.log(&apos;rejected: &apos;,err)
</code></pre><p> )<br> 复制代码</p>
</li>
</ol>
<p>这些用法中最重要的是promise的then链式调用。<br>可以大致猜到，旧Promise的then方法返回的是一个新的Promise对象。</p>
<p>参考<a href="https://link.juejin.im?target=https%3A%2F%2Fpromisesaplus.com%2F" target="_blank" rel="noopener">Promises/A+规范</a>，可以完善手写的Promise源码使其支持promise的静态方法和调用规则。</p>
<p>code 2：</p>
<pre><code>function Promise(executor) {
    let self = this
    self.value = undefined
    self.reason = undefined
    self.status = &apos;pending&apos;
    self.onResovedCallbacks = []
    self.onRejectedCallbacks = []
    function resolve(value) {
        if (self.status === &apos;pending&apos;) {
            self.value = value
            self.status = &apos;resolved&apos;
            self.onResovedCallbacks.forEach(fn=&gt;fn())
        }
    }

    function reject(reason) {
        if (self.status === &apos;pending&apos;) {
            self.reason = reason
            self.status = &apos;rejected&apos;
            self.onRejectedCallbacks.forEach(fn=&gt;fn())
        }
    }

    //如果函数执行时发生异常
    try {
        executor(resolve, reject)
    } catch (e) {
        reject(e)
    }
}


function resolvePromise(promise2, x, resolve, reject) {
    //If promise and x refer to the same object, reject promise with a TypeError as the reason.
    if (promise2 === x) {
        return reject(new TypeError(&apos;chaining cycle&apos;))
    }
    let called
    //2.3.3.Otherwise, if x is an object or function,
    if (x !== null &amp;&amp; (typeof x == &apos;object&apos; || typeof x === &apos;function&apos;)) {
        try {
            letthen = x.then
            //2.3.3.3.If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:
            //2.3.3.3.3.If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.
            if (typeof then === &apos;function&apos;) {
                then.call(x, y=&gt; {
                    if (called) return;
                    called = true;
                    //递归直到解析成普通值为止
                    //2.3.3.1.If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).
                    resolvePromise(promise2, y, resolve, reject)
                }, err=&gt; {
                    if (called) return;
                    called = true;
                    reject(err)
                })
            } else {
                resolve(x)
            }
        } catch (e) {
            if (called) return;
            called = true;
            //2.3.3.3.If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.
            reject(e)
        }
    } else {
        //If x is not an object or function, fulfill promise with x.
        resolve(x)
    }
}
//then调用的时候 都是异步调用 (原生的then的成功或者失败 是一个微任务)
Promise.prototype.then = function (onFulfilled, onRejected) {
    //成功和失败的函数 是可选参数
    onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val=&gt;val;
    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : (e)=&gt; {throw e};
    let self = this
    let promise2;
    promise2 = new Promise((resolve, reject)=&gt; {
        if (self.status === &apos;resolved&apos;) {
            setTimeout(()=&gt; {
                try {
                    let x = onFulfilled(self.value)
                    resolvePromise(promise2, x, resolve, reject)
                } catch (e) {
                    reject(e)
                }
            }, 0)
        } elseif (self.status === &apos;rejected&apos;) {
            setTimeout(()=&gt; {
                try {
                    let x = onRejected(self.reason)
                    resolvePromise(promise2, x, resolve, reject)
                } catch (e) {
                    reject(e)
                }
            }, 0)
        } elseif (self.status === &apos;pending&apos;) {
            self.onResovedCallbacks.push(()=&gt; {
                setTimeout(()=&gt; {
                    try {
                        let x = onFulfilled(self.value)
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (e) {
                        //当执行成功回调的时候,可能会出现异常,那就用这个异常作为promise2的错误结果
                        reject(e)
                    }
                }, 0)
            })
            self.onRejectedCallbacks.push(()=&gt; {
                setTimeout(()=&gt; {
                    try {
                        let x = onRejected(self.reason)
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (e) {
                        reject(e)
                    }
                }, 0)
            })
        }
    })
    return promise2
}
//setTimeout (规范要求)

Promise.reject = function (reason) {
    return new Promise((resolve,reject)=&gt;{
        reject(reason)
    })
}

Promise.resolve = function (value) {
    return new Promise((resolve,reject)=&gt;{
        resolve(value)
    })
}

Promise.prototype.catch = function (onReject) {
    return this.then(null,onReject)
}

Promise.defer = Promise.deferred = function () {
    let dfd = {}
    dfd.promise = new Promise((resolve, reject)=&gt; {
        dfd.resolve = resolve
        dfd.reject = reject
    })
    return dfd;
}

module.exports = Promise
复制代码
</code></pre><ol>
<li><p>为了支持then的链式调用，Promise.then.prototype中返回一个新的Promise对象</p>
<p> return p2 = new Promise()<br> 复制代码</p>
</li>
</ol>
<p>2.增加resolvePromise方法，处理旧Promise的回调函数的结果x，根据x的类型，分别调用新promise对象的resolve/reject方法。</p>
<ul>
<li>是普通值用resolve方法返回</li>
<li>是函数或者对象就继续用resolvePromise方法迭代（解决回调函数是Promise对象）</li>
<li>出错就用reject方法返回</li>
</ul>
<h4 id="三、bluebird"><a href="#三、bluebird" class="headerlink" title="三、bluebird"></a>三、bluebird</h4><p>1: NodeJS 中的 fs.readFile 方法的基本使用方式</p>
<pre><code>const fs = require(&apos;fs&apos;),path = require(&apos;path&apos;);

fs.readFile(path.join(__dirname, &apos;1.txt&apos;), &apos;utf-8&apos;, (err, data) =&gt; {
 if (err) {
   console.error(err);
 } else {
   console.log(data);
 }
});
复制代码
</code></pre><p>2：使用Promise封装</p>
<pre><code>let fs = require(&apos;fs&apos;)

functionread(filePath, encoding) {
    return new Promise((resolve, reject)=&gt; {
        fs.readFile(filePath, encoding, (err, data)=&gt; {
            if (err) reject(err)
            resolve(data)
        })
    })
}

read(&apos;1.txt&apos;, &apos;utf8&apos;).then( data=&gt; data)
复制代码
</code></pre><p>把fs.readFile方法用Promise封装一下就能使用Promise api。但是每次手动封装比较麻烦，bluebird可以帮我们简化这个步骤。</p>
<p>3：在 NodeJS 环境中，通过 const bluebird = require(‘bluebird’) 就可以开始使用 Bluebird 提供的 Promise 对象。</p>
<p>Promise.promisify 将单个方法转换成Promise对象。</p>
<pre><code>const bluebird = require(&apos;bluebird&apos;) 
letread = bluebird.promisify(fs.readFile)
read(&apos;1.txt&apos;, &apos;utf-8&apos;).then(data=&gt; {
    console.log(&apos;data promisify&apos;, data)
})
复制代码
</code></pre><p>使用<code>bluebird.promisify</code>方法，就能将fs.readFile直接封装成一个promise对象，它的原理很简单，return new Promise<br>是它的核心：</p>
<pre><code>function promisify(fn) {
    returnfunction () {
        return new Promise((resolve, reject)=&gt; {
            fn(...arguments, function (err, data) {
                if (err) reject(err)
                resolve(data)
            })
        })
    }
}
复制代码
</code></pre><p>4.使用 Promise.promisifyAll 把一个对象的所有方法都自动转换成使用 Promise。</p>
<pre><code>const bluebird = require(&apos;bluebird&apos;),
  fs = require(&apos;fs&apos;),
  path = require(&apos;path&apos;);
Promise.promisifyAll(fs);

fs.readFileAsync(path.join(__dirname, &apos;sample.txt&apos;), &apos;utf-8&apos;)
  .then(data =&gt; console.log(data))
  .catch(err =&gt; console.error(err));
复制代码
</code></pre><p>promisifyAll核心是遍历对象，生成些新创建方法的名称在已有方法的名称后加上”Async”后缀。</p>
<pre><code>function promisifyAll(obj) {
    Object.keys(obj).forEach(key=&gt;{
        if(typeof obj[key] === &apos;function&apos;){
            obj[key+&apos;Async&apos;] = promisify(obj[key])
        }
    })
}
复制代码
</code></pre><h4 id="四、generator-co"><a href="#四、generator-co" class="headerlink" title="四、generator+co"></a>四、generator+co</h4><h5 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h5><p>generator函数最大的特点是可以用<code>yield</code>暂停执行，为了区别普通函数在函数名前加*号。</p>
<pre><code>function *say() {
    let a = yield &quot;test1&quot;let b = yield &quot;test2&quot;
}

let it = say();

console.log(1, it.next()) //1 { value: &apos;test1&apos;, done: false }
console.log(2, it.next()) //2 { value: &apos;test2&apos;, done: false }
console.log(3, it.next()) //3 { value: undefined, done: true }
复制代码
</code></pre><p>执行say()方法返回的是指针对象，不会返回函数执行结果。it 就是iterator 迭代器</p>
<p>需要调用指针对象的next()方法，让函数指针不断移动并返回一个对象。（{value:xxx,done:xxx}）</p>
<p>value是yield后面的值，done表示函数是否执行完成。</p>
<p>我们可以用generator函数实现结果的产出，但是也需要它支持输入。</p>
<p>generator函数的运行顺序如下：<br><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;598&quot;&gt;&lt;/svg&gt;" alt=""><br>使用it.next()执行函数，结果并不会返回给定义的变量a。next方法可以接受参数，这是向 Generator 函数体内输入数据。<br>第二个next的时候传入参数，就能被变量a接收到。</p>
<p>terminal 返回：</p>
<pre><code>1 { value: &apos;test1&apos;, done: false }
aaa
2 { value: &apos;test2&apos;, done: false }
bbb
3 { value: undefined, done: true }
复制代码
</code></pre><p>4.2 使用</p>
<p>example：使用generator异步执行函数，使函数的返回作为下一个函数的入参执行。</p>
<pre><code>let bluebird = require(&apos;bluebird&apos;)
let fs = require(&apos;fs&apos;)
letread = bluebird.promisify(fs.readFile)

function *r() {
    let r1 = yield read(&apos;1.txt&apos;, &apos;utf-8&apos;)
    console.log(&apos;r1&apos;,r1); // r1 2.txt
    let r2 = yield read(r1, &apos;utf-8&apos;)
    console.log(&apos;r2&apos;,r2); // r2 3.txt
    let r3 = yield read(r2, &apos;utf-8&apos;)
    console.log(&apos;r3&apos;,r3); // r3 hello
    return r3
}
复制代码
</code></pre><p>拿读取文件的例子：使用bluebird将fs.readFile变成promise对象，将读取到的文件内容作为入参传入下一个要执行的函数。</p>
<p>突然发现，要拿到结果会是个复杂的过程，但还是硬着头皮下下去：</p>
<pre><code>const it_r = r()
it_r.next().value.then(d1=&gt;{
    return it_r.next(d1).value
}).then(d2=&gt;{
    return it_r.next(d2).value
}).then(d3=&gt;{
    return it_r.next(d3).value
}).then(data=&gt;{
    console.log(data) // hello
})
复制代码
</code></pre><p>it.next().value 返回的是一个promise，使用then方法，拿到它成功回调的值，并传入下一个next。</p>
<p>这样能成功拿到我们要的值，但是太麻烦了。于是就有了generator+co的组合！</p>
<p>安装：</p>
<pre><code>$ npm install co
复制代码
</code></pre><p>使用:</p>
<pre><code>co(r()).then(data=&gt; {
    console.log(data)
})
复制代码
</code></pre><p>co会迭代执行it.next()方法，直到done的布尔值为true就返回generator函数的运行结果。</p>
<p>大致执行代码如下：</p>
<pre><code>function co(it) {
    return new Promise((resolve, reject)=&gt; {
        function next(data) {
            let {value, done} = it.next(data)
            if(done){
                resolve(value)
            }else{
                value.then(data=&gt; {
                    next(data)
                },reject)
            }
        }
        next()
    })
}
复制代码
</code></pre><h4 id="五、async-await"><a href="#五、async-await" class="headerlink" title="五、async+await"></a>五、async+await</h4><p>async 函数是Generator 函数的语法糖。</p>
<p>比Generator函数用起来简单</p>
<ol>
<li>可以让代码像同步</li>
<li>可以try+catch</li>
<li><p>可以使用promise api</p>
<p> async functionr() {</p>
<pre><code>try{
     let r1 = await read(&apos;1.txt&apos;,&apos;utf8&apos;)
     let r2 = await read(r1,&apos;utf8&apos;)
     let r3 = await read(r2,&apos;utf8&apos;)
     return r3
 }catch(e){
     console.log(&apos;e&apos;,e)
 }
</code></pre><p> }</p>
<p> r().then(data=&gt; {</p>
<pre><code>console.log(data)
</code></pre><p> },err=&gt;{</p>
<pre><code>console.log(&apos;err&apos;,err)
</code></pre><p> })<br> 复制代码</p>
</li>
</ol>
<p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。遇到await就会先返回，等待函数执行。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.ibm.com%2Fdeveloperworks%2Fcn%2Fweb%2Fwa-lo-use-bluebird-implements-power-promise%2Findex.html" target="_blank" rel="noopener">使用 bluebird 实现更强大的 Promise</a></p>
</li>
<li><p><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F04%2Fgenerator.html" target="_blank" rel="noopener">Generator 函数的含义与用法
</a></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/promise/" rel="tag"># promise</a>
          
            <a href="/tags/es6/" rel="tag"># es6</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/10/KOA2-compose-串联中间件实现（洋葱模型）/" rel="next" title="KOA2 compose 串联中间件实现（洋葱模型）">
                <i class="fa fa-chevron-left"></i> KOA2 compose 串联中间件实现（洋葱模型）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、前言"><span class="nav-number">1.</span> <span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、Promise"><span class="nav-number">2.</span> <span class="nav-text">二、Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-原理"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-静态方法"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-简写Promise源码"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 简写Promise源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-Promise用法简述"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 Promise用法简述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、bluebird"><span class="nav-number">3.</span> <span class="nav-text">三、bluebird</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、generator-co"><span class="nav-number">4.</span> <span class="nav-text">四、generator+co</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-简介"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 简介</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、async-await"><span class="nav-number">5.</span> <span class="nav-text">五、async+await</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


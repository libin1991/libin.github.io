<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="intersectionObserver," />










<meta name="description" content="参考文章：IntersectionObserver API 使用教程Intersection Observer【译】使用 Intersection Observer 实现图片延迟加载intersectionObserver解决什么问题？ intersectionObserver解决目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”， 比如在web网页开发中，常常需要了解某个元素是否">
<meta name="keywords" content="intersectionObserver">
<meta property="og:type" content="article">
<meta property="og:title" content="交叉观察器(intersectionObserver) Vue实战">
<meta property="og:url" content="http://yoursite.com/2018/08/13/交叉观察器-intersectionObserver-Vue实战/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="参考文章：IntersectionObserver API 使用教程Intersection Observer【译】使用 Intersection Observer 实现图片延迟加载intersectionObserver解决什么问题？ intersectionObserver解决目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”， 比如在web网页开发中，常常需要了解某个元素是否">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic4.zhimg.com/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_b.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/v2-83bcd2ce4df13a07da99e0c051e9fcaa_b.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-83bcd2ce4df13a07da99e0c051e9fcaa_hd.jpg">
<meta property="og:updated_time" content="2018-10-02T15:05:14.553Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="交叉观察器(intersectionObserver) Vue实战">
<meta name="twitter:description" content="参考文章：IntersectionObserver API 使用教程Intersection Observer【译】使用 Intersection Observer 实现图片延迟加载intersectionObserver解决什么问题？ intersectionObserver解决目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”， 比如在web网页开发中，常常需要了解某个元素是否">
<meta name="twitter:image" content="https://pic4.zhimg.com/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_b.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/13/交叉观察器-intersectionObserver-Vue实战/"/>





  <title>交叉观察器(intersectionObserver) Vue实战 | LuckDay</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/交叉观察器-intersectionObserver-Vue实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">交叉观察器(intersectionObserver) Vue实战</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T23:04:27+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="参考文章：IntersectionObserver-API-使用教程"><a href="#参考文章：IntersectionObserver-API-使用教程" class="headerlink" title="参考文章：IntersectionObserver API 使用教程"></a>参考文章：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">IntersectionObserver API 使用教程</a></h2><h2 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener">Intersection Observer</a></h2><h2 id="【译】使用-Intersection-Observer-实现图片延迟加载"><a href="#【译】使用-Intersection-Observer-实现图片延迟加载" class="headerlink" title="【译】使用 Intersection Observer 实现图片延迟加载"></a><a href="https://link.zhihu.com/?target=https%3A//c7sky.com/lazy-loading-images-using-intersection-observer.html" target="_blank" rel="noopener">【译】使用 Intersection Observer 实现图片延迟加载</a></h2><p>intersectionObserver解决什么问题？</p>
<p>intersectionObserver解决目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”，</p>
<p>比如在web网页开发中，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。</p>
<p>传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">getBoundingClientRect()</a>方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">性能问题</a>。</p>
<p>目前有一个新的 <a href="https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/" target="_blank" rel="noopener">IntersectionObserver API</a>，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p>
<blockquote>
<p>IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，<code>IntersectionObserver</code>的实现，应该采用<code>requestIdleCallback()</code>，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p>
</blockquote>
<p>IntersectionObserverEntry 对象</p>
<p><code>IntersectionObserverEntry</code>对象提供目标元素的信息，一共有六个属性。</p>
<pre><code>{
  time: 3893.92,
  rootBounds: ClientRect {
    bottom: 920,
    height: 1024,
    left: 0,
    right: 1024,
    top: 0,
    width: 920 },
  boundingClientRect: ClientRect {  // ...
 },
  intersectionRect: ClientRect {  // ...
 },
  intersectionRatio: 0.54,
  target: element
} 
</code></pre><p>每个属性的含义如下。</p>
<ul>
<li><code>time</code>：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li>
<li><code>target</code>：被观察的目标元素，是一个 DOM 节点对象</li>
<li><code>rootBounds</code>：根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回<code>null</code></li>
<li><code>boundingClientRect</code>：目标元素的矩形区域的信息</li>
<li><code>intersectionRect</code>：目标元素与视口（或根元素）的交叉区域的信息</li>
<li><code>intersectionRatio</code>：目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全可见时为<code>1</code>，完全不可见时小于等于<code>0</code></li>
</ul>
<p>现在我们已经创建了一个 Intersection Observer 并且正在观察页面上的图片，我们现在来了解 intersection 事件，它将在元素进入视区时触发。</p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>此时此刻，你也许想知道关于这项特性的浏览器支持情况。Intersection Observer 现在已被 <a href="https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dintersectionobserver" target="_blank" rel="noopener">Edge、Firefox、Chrome 和 Opera</a> 支持，这是一个好消息。</p>
<p>然而，为了确保我们的代码不会在不支持它的浏览器中造成破坏，我们可以使用特性检测来确定我们应该如何来加载图片。让我们看看下面的代码。</p>
<pre><code>// If we don&apos;t have support for intersection observer, load the images immediately
if (!(&apos;IntersectionObserver&apos; in window)) {
  Array.from(images).forEach(image =&gt; preloadImage(image));
} else {
  // It is supported, load the images
  observer = new IntersectionObserver(onIntersection, config);
  images.forEach(image =&gt; {

   observer.observe(image);
  });
}
view raw
</code></pre><p>Vue:</p>
<pre><code>&lt;template&gt;
    &lt;img :src=&quot;lazysrc&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
    import Bus from &apos;../bus&apos;;
    import nonepng from &apos;../../assets/img/none.png&apos;;

    export default {
        name: &apos;lazyimg&apos;,
        data: function() {
            return {
                isShow: false,
                lazysrc: nonepng
            }
        },
        mounted() {
            if(!this.needlazy) {
                this.lazysrc = this.src;
            } else {
                if(!(&apos;IntersectionObserver&apos; in window)) {
                    //TODO
                } else {
                    var io = new IntersectionObserver(
                        entries =&gt; {
                            entries.forEach(i =&gt; {
                                if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发
                                    i.target.setAttribute(&quot;src&quot;, this.src)
                                }
                            });
                        }, {
                            threshold: [0, 0.25, 0.5, 0.75, 1],
                        }
                    );
                    io.observe(this.$el);
                }
            }
        },
        props: {
            needlazy: {
                type: Boolean,
                default: false,
            },
            src: {
                type: String,
                default: &apos;&apos;,
            },
        }
    };
&lt;/script&gt;
</code></pre><blockquote>
<p>通常都是通过判断intersectionRatio来做某些事，比如当intersectionRatio大于多少的时候做什么事，加载图片等！</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_hd.jpg" alt=""><br>   灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的<code>intersectionRatio</code>图中都已经注明。</p>
<p>DEMO：  <a href="https://zhuanlan.zhihu.com/p/25455672" target="_blank" rel="noopener">延迟加载(Lazyload)三种实现方式</a></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
        &lt;title&gt; &lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            * {
                padding: 0px;
                margin: 0px;
                outline: none;
            }

            body {}

            #main {
                margin: 0 auto;
                width: 600px;
                height: 300px;
                overflow: scroll;
            }

            #con {
                width: 1200px;
                height: 300px;
            }

            .cc {
                width: 300px;
                height: 300px;
                float: left;
                background-size: cover;
            }

            #a {
                background-color: red;
            }

            #b {
                background-color: black;
            }

            #c {
                background-color: blue;
            }

            #d {
                background-color: green;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;
            &lt;div id=&quot;con&quot;&gt;
                &lt;div id=&quot;a&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;b&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;c&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;d&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var io = new IntersectionObserver(
            entries =&gt; {
                console.log(&apos;********************************&apos;);
                console.log(entries);
                console.log(&apos;********************************&apos;);
                entries.forEach(i =&gt; {
                    console.log(&apos;================================&apos;);
                    console.log(&apos;Time: &apos; + i.time);
                    console.log(&apos;Target: &apos; + i.target.nodeName);
                    console.log(&apos;IntersectionRatio: &apos; + i.intersectionRatio);
                    console.log(&apos;rootBounds: &apos; + i.rootBounds);
                    console.log(i.boundingClientRect);
                    console.log(i.intersectionRect);
                    console.log(&apos;================================&apos;);

                    if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发
                        console.log(&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&apos;);
                        i.target.style.backgroundImage = &quot;url(&quot; + &apos;http://pic35.photophoto.cn/20150528/0020032932102307_b.jpg&apos; + &quot;)&quot;
                    }

                });
            }, {
                /* Using default options. Details below */
                threshold: [0, 0.25, 0.5, 0.75, 1],   //会执行5次
            }
        );
        // Start observing an element
        io.observe(document.querySelector(&apos;#d&apos;));
        io.observe(document.querySelector(&apos;#c&apos;));
    &lt;/script&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic1.zhimg.com/v2-83bcd2ce4df13a07da99e0c051e9fcaa_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-83bcd2ce4df13a07da99e0c051e9fcaa_hd.jpg" alt=""></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Lazyload 3&lt;/title&gt;
    &lt;style&gt;
        img {
        display: block;
        margin-bottom: 50px;
        width: 800px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/1.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/2.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/3.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/4.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/5.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/6.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/7.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/8.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/9.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/10.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/11.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/12.png&quot;&gt;
    &lt;script&gt;
    function query(selector) {
        return Array.from(document.querySelectorAll(selector));
    }
    var io = new IntersectionObserver(function(items) {
        items.forEach(function(item) {
        var target = item.target;
        if(target.getAttribute(&apos;src&apos;) == &apos;images/loading.gif&apos;) {
            target.src = target.getAttribute(&apos;data-src&apos;);
        }
        })
    });
    query(&apos;img&apos;).forEach(function(item) {
        io.observe(item);
    });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>IntersectionObserver 传入一个回调函数，当其观察到元素集合出现时候，则会执行该函数。</li>
<li>io.observe 即要观察的元素，要一个个添加才可以。</li>
<li>io 管理的是一个数组，当元素出现或消失的时候，数组添加或删除该元素，并且执行该回调函数。</li>
</ol>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><p>它的用法非常简单。</p>
<pre><code>var io = new IntersectionObserver(callback, option); 
</code></pre><p>上面代码中，<code>IntersectionObserver</code>是浏览器原生提供的构造函数，接受两个参数：<code>callback</code>是可见性变化时的回调函数，<code>option</code>是配置对象（该参数可选）。</p>
<p>构造函数的返回值是一个观察器实例。实例的<code>observe</code>方法可以指定观察哪个 DOM 节点。</p>
<pre><code>// 开始观察
io.observe(document.getElementById(&apos;example&apos;)); 
// 停止观察
io.unobserve(element); 
// 关闭观察器
io.disconnect(); 
</code></pre><p>上面代码中，<code>observe</code>的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p>
<pre><code>io.observe(elementA);
io.observe(elementB); 
</code></pre><h2 id="二、callback-参数"><a href="#二、callback-参数" class="headerlink" title="二、callback 参数"></a>二、callback 参数</h2><p>目标元素的可见性变化时，就会调用观察器的回调函数<code>callback</code>。</p>
<p><code>callback</code>一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p>
<pre><code>var io = new IntersectionObserver(
  entries =&gt; {
    console.log(entries); } 
); 
</code></pre><p>上面代码中，回调函数采用的是<a href="https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/function%23%25E7%25AE%25AD%25E5%25A4%25B4%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">箭头函数</a>的写法。<code>callback</code>函数的参数（<code>entries</code>）是一个数组，每个成员都是一个<code>[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)</code>对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code>数组就会有两个成员。</p>
<h2 id="三、Option-对象"><a href="#三、Option-对象" class="headerlink" title="三、Option 对象"></a>三、Option 对象</h2><p>IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p>
<p><code>[IntersectionObserver.root](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/root)</code> 只读所监听对象的具体祖先元素(<code>[element](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Element)</code>)。如果未传入任何值或值为null，则默认使用viewport。</p>
<p><code>[IntersectionObserver.rootMargin](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/rootMargin)</code> 只读计算交叉时添加到根(root)边界盒<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Glossary/bounding_box" target="_blank" rel="noopener">bounding box</a>的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。此属性返回的值可能与调用构造函数时指定的值不同，因此可能需要更改该值，以匹配内部要求。所有的偏移量均可用像素(pixel)(px)或百分比(percentage)(%)来表达, 默认值为”0px 0px 0px 0px”。</p>
<p><code>[IntersectionObserver.thresholds](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/thresholds)</code> 只读一个包含阈值的list, 升序排列, list中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会生成一个通知(Notification)。如果构造器未传入值, 则默认值为0.</p>
<p>threshold 属性</p>
<p><code>threshold</code>属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为<code>[0]</code>，即交叉比例（<code>intersectionRatio</code>）达到<code>0</code>时触发回调函数。</p>
<pre><code>new IntersectionObserver(
  entries =&gt; {/* ... */}, {
    threshold: [0, 0.25, 0.5, 0.75, 1] } ); 
</code></pre><p>用户可以自定义这个数组。比如，<code>[0, 0.25, 0.5, 0.75, 1]</code>就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p>
<p>root 属性，rootMargin 属性</p>
<p>很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在<code>iframe</code>窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。</p>
<p>IntersectionObserver API 支持容器内滚动。<code>root</code>属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p>
<pre><code>var opts = { 
  root: document.querySelector(&apos;.container&apos;),
  rootMargin: &quot;500px 0px&quot; 
}; 

var observer = new IntersectionObserver(
  callback,
  opts
); 
</code></pre><p>上面代码中，除了<code>root</code>属性，还有<code>[rootMargin](https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/%23dom-intersectionobserverinit-rootmargin)</code>属性。后者定义根元素的<code>margin</code>，用来扩展或缩小<code>rootBounds</code>这个矩形的大小，从而影响<code>intersectionRect</code>交叉区域的大小。它使用CSS的定义方法，比如<code>10px 20px 30px 40px</code>，表示 top、right、bottom 和 left 四个方向的值。</p>
<pre><code>//离视窗还有top=500px 或者 bottom=500 触发加载
rootMargin = `500px 0px`  
//离视窗还有top=-500px 或者 bottom=-500 触发加载 （惰性加载）
rootMargin = `-500px 0px` 
</code></pre><p>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p>
<h2 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h2><p><code>[IntersectionObserver.disconnect](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/disconnect)</code>使IntersectionObserver对象停止监听工作。</p>
<p><code>[IntersectionObserver.observe](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/observe)使IntersectionObserver开始监听一个目标元素。</code></p>
<p><code>[IntersectionObserver.takeRecords](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/takeRecords)</code>为所有监听目标返回一个<code>[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry)</code>对象数组并且停止监听这些目标。</p>
<p><code>[IntersectionObserver.unobserve](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/unobserve)使IntersectionObserver停止监听特定目标元素。</code></p>
<h2 id="五、Vue（xunleif2e-vue-lazy-component）"><a href="#五、Vue（xunleif2e-vue-lazy-component）" class="headerlink" title="五、Vue（xunleif2e/vue-lazy-component）"></a>五、Vue（<a href="https://link.zhihu.com/?target=https%3A//github.com/xunleif2e/vue-lazy-component" target="_blank" rel="noopener">xunleif2e/vue-lazy-component</a>）</h2><p>核心 VueLazyComponent.vue</p>
<pre><code>&lt;template&gt;
  &lt;transition-group :tag=&quot;tagName&quot; name=&quot;lazy-component&quot; style=&quot;position: relative;&quot;
    @before-enter=&quot;(el) =&gt; $emit(&apos;before-enter&apos;, el)&quot;
    @before-leave=&quot;(el) =&gt; $emit(&apos;before-leave&apos;, el)&quot;
    @after-enter=&quot;(el) =&gt; $emit(&apos;after-enter&apos;, el)&quot;
    @after-leave=&quot;(el) =&gt; $emit(&apos;after-leave&apos;, el)&quot;
  &gt;
    &lt;div v-if=&quot;isInit&quot; key=&quot;component&quot;&gt;
      &lt;slot :loading=&quot;loading&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div v-else-if=&quot;$slots.skeleton&quot; key=&quot;skeleton&quot;&gt;
      &lt;slot name=&quot;skeleton&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div v-else key=&quot;loading&quot;&gt;
    &lt;/div&gt;
  &lt;/transition-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: &apos;VueLazyComponent&apos;,

    props: {
      timeout: {
        type: Number
      },
      tagName: {
        type: String,
        default: &apos;div&apos;
      },
      viewport: {
        type: typeof window !== &apos;undefined&apos; ? window.HTMLElement : Object,
        default: () =&gt; null
      },
      threshold: {
        type: String,
        default: &apos;0px&apos;
      },
      direction: {
        type: String,
        default: &apos;vertical&apos;
      },
      maxWaitingTime: {
        type: Number,
        default: 50
      }
    },

    data () {
      return {
        isInit: false,
        timer: null,
        io: null,
        loading: false
      }
    },

    created () {
      // 如果指定timeout则无论可见与否都是在timeout之后初始化
      if (this.timeout) {
        this.timer = setTimeout(() =&gt; {
          this.init()
        }, this.timeout)
      }
    },

    mounted () {
      if (!this.timeout) {
        // 根据滚动方向来构造视口外边距，用于提前加载
        let rootMargin
        switch (this.direction) {
          case &apos;vertical&apos;:
            rootMargin = `${this.threshold} 0px`
            break
          case &apos;horizontal&apos;:
            rootMargin = `0px ${this.threshold}`
            break
        }

        // 观察视口与组件容器的交叉情况
        this.io = new window.IntersectionObserver(this.intersectionHandler, {
          rootMargin,
          root: this.viewport,
          threshold: [ 0, Number.MIN_VALUE, 0.01]
        })
        this.io.observe(this.$el)
      }
    },

    beforeDestroy () {
      // 在组件销毁前取消观察
      if (this.io) {
        this.io.unobserve(this.$el)
      }
    },

    methods: {
      // 交叉情况变化处理函数
      intersectionHandler (entries) {
        if (
          // 正在交叉
          entries[0].isIntersecting ||
          // 交叉率大于0
          entries[0].intersectionRatio
        ) {
          this.init()
          this.io.unobserve(this.$el)
        }
      },

      // 处理组件和骨架组件的切换
      init () {
        // 此时说明骨架组件即将被切换
        this.$emit(&apos;beforeInit&apos;)
        this.$emit(&apos;before-init&apos;)

        // 此时可以准备加载懒加载组件的资源
        this.loading = true

        // 由于函数会在主线程中执行，加载懒加载组件非常耗时，容易卡顿
        // 所以在requestAnimationFrame回调中延后执行
        this.requestAnimationFrame(() =&gt; {
          this.isInit = true
          this.$emit(&apos;init&apos;)
        })
      },

      requestAnimationFrame (callback) {
        // 防止等待太久没有执行回调
        // 设置最大等待时间
        setTimeout(() =&gt; {
          if (this.isInit) return
          callback()
        }, this.maxWaitingTime)

        // 兼容不支持requestAnimationFrame 的浏览器
        return (window.requestAnimationFrame || ((callback) =&gt; setTimeout(callback, 1000 / 60)))(callback)
      }
    }
  }
&lt;/script&gt;
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/intersectionObserver/" rel="tag"># intersectionObserver</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/11/Raect-异步加载组件/" rel="next" title="Raect 异步加载组件">
                <i class="fa fa-chevron-left"></i> Raect 异步加载组件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/20/ES6之promise、generator-co、async-await手写promise/" rel="prev" title="ES6之promise、generator+co、async+await手写promise">
                ES6之promise、generator+co、async+await手写promise <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">65</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文章：IntersectionObserver-API-使用教程"><span class="nav-number">1.</span> <span class="nav-text">参考文章：IntersectionObserver API 使用教程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Intersection-Observer"><span class="nav-number">2.</span> <span class="nav-text">Intersection Observer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【译】使用-Intersection-Observer-实现图片延迟加载"><span class="nav-number">3.</span> <span class="nav-text">【译】使用 Intersection Observer 实现图片延迟加载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器支持"><span class="nav-number">4.</span> <span class="nav-text">浏览器支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一、API"><span class="nav-number">5.</span> <span class="nav-text">一、API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、callback-参数"><span class="nav-number">6.</span> <span class="nav-text">二、callback 参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、Option-对象"><span class="nav-number">7.</span> <span class="nav-text">三、Option 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、方法"><span class="nav-number">8.</span> <span class="nav-text">四、方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、Vue（xunleif2e-vue-lazy-component）"><span class="nav-number">9.</span> <span class="nav-text">五、Vue（xunleif2e/vue-lazy-component）</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


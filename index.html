<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LuckDay</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/04/JavaScript核武库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/04/JavaScript核武库/" itemprop="url">JavaScript核武库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-04T16:24:04+08:00">
                2018-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下是个人总结，也有一些是copy大神的，现在放到一起，方便以后查阅（有不对的地方，还望大家能够提出，我会尽快加以改正）。</p>
<h2 id="强制转boolean"><a href="#强制转boolean" class="headerlink" title="!!强制转boolean"></a>!!强制转<code>boolean</code></h2><p>根据真值，假值 判断，返回<code>true</code>，<code>false</code>假值：  0     “”  null   undefined  false NaN</p>
<pre><code>例如：
var nu=null;
var nul=&quot;&quot;;
var str=&quot;abcd&quot;;

console.log(!!nu)     // false;
console.log(!!nul)    // false;
console.log(!!str)    // true;
</code></pre><h2 id="obj-强制转Number"><a href="#obj-强制转Number" class="headerlink" title="+obj 强制转Number"></a>+obj 强制转<code>Number</code></h2><p> 将对象强制转<code>number</code>,如果是纯数字的“88”字符串，可转为<code>number</code></p>
<pre><code>var a=&quot;88&quot;;
console.log(+a)   =&gt;88
//但是如果是混合类型的字符串，则会转为NaN
var b=&quot;1606e&quot;;
console.log(+b)  =&gt; NaN
</code></pre><h2 id="强制取整"><a href="#强制取整" class="headerlink" title="~~ 强制取整"></a>~~ 强制取整</h2><pre><code>~~ 12.34
 12
~~ 12.88
 12
</code></pre><h2 id="不可靠的undefined-可靠的void-0"><a href="#不可靠的undefined-可靠的void-0" class="headerlink" title="不可靠的undefined 可靠的void 0"></a>不可靠的<code>undefined</code> 可靠的<code>void 0</code></h2><p>在<code>JavaScript</code>中，假设我们想判断一个是否是 <code>undefined</code>，那么我们通常会这样写：</p>
<pre><code>if(a === undefined){
  dosomething
}
</code></pre><p>//但是在<code>javascript</code>中，<code>undefined</code>是不可靠的</p>
<p>例如：<br>当undefined在函数内，并且是在局部变量是可以赋上值</p>
<pre><code>function foo2(){
 var undefined=1;
 console.log(undefined)
}
foo2();  =&gt;1;
</code></pre><p>但是当在函数内定义一个全局变量，并不能给赋上值</p>
<pre><code>var undefined;
function foo2(){
undefined=1;
 console.log(undefined)
}
foo2()  // undefined
void 0或者 void (0)：
</code></pre><p>最常见的用法是通过<code>void 0</code> 运算来获得 <code>undefined</code>，表达式为 0 时的运算开销最小：<br>那在以后需要判断值为<code>undefined</code>的时候，可以直接用<code>void 0</code>或者<code>void (0)</code></p>
<h2 id="字符串也是有length属性的！"><a href="#字符串也是有length属性的！" class="headerlink" title="字符串也是有length属性的！"></a>字符串也是有<code>length</code>属性的！</h2><p>我们知道所有的<code>array</code>都是有<code>length</code>,属性，就算事空数组，<code>length</code> 是0，那么字符串有没有呢？接下来我们来验证一下：</p>
<pre><code>var str=&quot;sdfsd5565s6dfsd65sd6+d5fd5&quot;;
console.log(str.length)      // 26
</code></pre><p>结果是有的，所以我们在判断类型时，不能单纯拿有没有<code>length</code>属性来判断是不是数组了，我们可以用下面的方法：</p>
<pre><code>var obj=[1,2] ;
console.log(toString.call(obj) === &apos;[object Array]&apos;);
</code></pre><h2 id="生成一个随机数组-创建数组，sort排序"><a href="#生成一个随机数组-创建数组，sort排序" class="headerlink" title="生成一个随机数组(创建数组，sort排序)"></a>生成一个随机数组(创建数组，<code>sort</code>排序)</h2><p>在项目中有时候我们需要一个随机打乱的数组，那么下面我们来实现以下：<br>先来创建一个数组：</p>
<pre><code>var arr=[];
for(var i=0;i&lt;10;i++){
   arr.push(i)
}
console.log(arr)    //  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p>接下来我们来打乱它：</p>
<pre><code>arr.sort(()=&gt;{
 return Math.random() - 0.5
})                 // [1, 0, 2, 3, 4, 6, 8, 5, 7, 9] 
</code></pre><p>第二种打乱方法：</p>
<pre><code>arr.sort((a,b)=&gt;{
　　　return a&gt;Math.random()*10;
})               //  [1, 2, 0, 6, 4, 3, 8, 9, 7, 5]
</code></pre><p>我们以前的正常排序是这样的：</p>
<pre><code>arr.sort(function(a,b){
   return b-a
});
</code></pre><p>解析：<br>先说正常的排序：<br>a,b表示数组中的任意两个元素，若<code>return &gt; 0</code> b前a后；<code>reutrn &lt; 0</code> a前b后；<code>a=b</code>时存在浏览器兼容 ，<br><code>a-b</code>输出从小到大排序，<code>b-a</code>输出从大到小排序。<br>然后再说我们打乱的方法：<br>创建数组不用说，接下来就是用js的sort方法 来实现，<code>Math.random()</code>实现一个随机<code>0-1</code>之间的小数 然后再减去<code>0.5</code>，这时就会根据return比较后得到的值排，所以说就会生成不是正常从大到小或者从小到大的排序。</p>
<p>第二个打乱的方法同样是遵循<code>sort</code>的方法，将<code>a,b</code>传进去 然后和随机数做比较，关于比较的方法不太清楚。</p>
<h2 id="去除前后、前、后-所有空格"><a href="#去除前后、前、后-所有空格" class="headerlink" title="去除前后、前、后 所有空格"></a>去除前后、前、后 所有空格</h2><p> 这是专门为去除空格写的一套方法，适用于各种情况，所有空格,前后空格，前空格，后空格。</p>
<p>var strr=”    1 ad dertasdf sdfASDFDF DFG SDFG    “<br>//  type 1-所有空格  2-前后空格  3-前空格 4-后空格</p>
<pre><code>function trim(str,type){
    switch (type){
        case 1:return str.replace(/\s+/g,&quot;&quot;);
        case 2:return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
        case 3:return str.replace(/(^\s*)/g, &quot;&quot;);
        case 4:return str.replace(/(\s*$)/g, &quot;&quot;);
        default:return str;
    }
}
console.log( trim(strr,1))      //  &quot;1addertasdfsdfASDFDFDFGSDFG&quot;
</code></pre><p>解析：<br>  这个方法用的是正则的匹配格式,后面我会把正则单独拿出来总结一个系列，敬请期待！！！</p>
<pre><code>\s ： 空格符，Tab,换页符，换行符
  \S ： 非\s的所有内容
  /g :  全局匹配
  ^  :  匹配在行首
  $  :  匹配在行尾
  +  ： 重复次数&gt;0
  *  ： 重复次数&gt;=0
  |  :  或者
</code></pre><p><code>replace(a,b)</code>： 方法用于在字符创中用一些字符替换另一些字符, 会传入两个值，将逗号前面的值<code>a</code>替换成逗号后面的值<code>b</code></p>
<h2 id="字母大小写切换（正则匹配，replace）"><a href="#字母大小写切换（正则匹配，replace）" class="headerlink" title="字母大小写切换（正则匹配，replace）"></a>字母大小写切换（正则匹配，<code>replace</code>）</h2><p>这个方法主要是给一些需要大小写转换提供的方法，主要有首字母大写，首字母小写，大小写转换，全部转大写和全部转小写。</p>
<pre><code>type：
　　1:首字母大写
　　2：首页母小写
　　3：大小写转换
　　4：全部大写
　　5：全部小写
</code></pre><p>原始字符串：</p>
<pre><code>var str=&quot;sdfwwerasfddffddeerAasdgFegqer&quot;;

function changeCase(str,type) {

   //这个函数是第三个大小写转换的方法
    function ToggleCase(str) {
        var itemText = &quot;&quot;
        str.split(&quot;&quot;).forEach(
                function (item) {
                 // 判断循环字符串中每个字符是否以a-z之间开头的并且重复大于0次
                    if (/^([a-z]+)/.test(item)) {
                    //  如果是小写，转换成大写
                        itemText += item.toUpperCase();
                    }
                //  判断循环字符串中每个字符是否以A-Z之间开头的并且重复大于0次
                    else if (/^([A-Z]+)/.test(item)) {
                   //   如果是大写，转换成小写
                        itemText += item.toLowerCase();
                    }
                    else{
                  //  如果都不符合，返回其本身
                        itemText += item;
                    }
                });
        return itemText;
    }
  //下面主要根据传入的type值来匹配各个场景
    switch (type) {
         //当匹配
        case 1:
            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {
                 //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer
                return v1.toUpperCase() + v2.toLowerCase();
            });
        case 2:
            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {
                //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer
                return v1.toLowerCase() + v2.toUpperCase();
            });
        case 3:
            return ToggleCase(str);
        case 4:
            return str.toUpperCase();
        case 5:
            return str.toLowerCase();
        default:
            return str;
    }

}

 console.log(changeCase(str,1)) =&gt;SdfwwerasfddffddeerAasdgFegqer
</code></pre><p>解析：</p>
<pre><code>split：用于把一个字符串分割成字符串数组
\w: 数字0-9或字母a-z及A-Z,或下划线
\W: 非\w，除以上的特殊符号等   
toUpperCase：转大写
toLowerCase：转小写
replace第二个参数可以是函数，函数的参数中，第一个是本身，第二个是正则匹配内容，第三个匹配剩下的内容
</code></pre><p>下面我们就通过小实验来验证一下：<br>网上有说replace是可以有4个参数的，但是我并没有验证到第四个代表的意义，前三个已经验证，第一个参数为验证本身，第二个正则匹配结果，第三为第二个匹配完剩下的值。</p>
<h2 id="循环n次传入的字符串str为传入随意字符串，count为循环的次数"><a href="#循环n次传入的字符串str为传入随意字符串，count为循环的次数" class="headerlink" title="循环n次传入的字符串str为传入随意字符串，count为循环的次数"></a>循环n次传入的字符串<code>str</code>为传入随意字符串，<code>count</code>为循环的次数</h2><pre><code>var str=&quot;abc&quot;;
 var number=555;

function repeatStr(str, count) {
    //声明一个空字符串，用来保存生成后的新字符串
    var text = &apos;&apos;;
    //循环传入的count值，即循环的次数
    for (var i = 0; i &lt; count; i++) {
       //循环一次就把字符串+到我们事先准备好的空字符串上
        text += str;
    }
    return text;
}

  console.log(repeatStr(str, 3))         // &quot;abcabcabc&quot;

  console.log(repeatStr(number, 3))      // &quot;555555555&quot;
</code></pre><p>解析：根据count循环的次数，在循环体内复制，return 返回+=后的值</p>
<h2 id="查找字符串的A内容替换成B内容"><a href="#查找字符串的A内容替换成B内容" class="headerlink" title="查找字符串的A内容替换成B内容"></a>查找字符串的A内容替换成B内容</h2><pre><code>let str=&quot;abacdasdfsd&quot; function replaceAll(str,AFindText,ARepText){
   raRegExp = new RegExp(AFindText,&quot;g&quot;);
   return str.replace(raRegExp,ARepText);
}
console.log(replaceAll(str,&quot;a&quot;,&quot;x&quot;))  // xbxcdxsdfsd
str：需要编辑的字符串本身
AFindText:需要替换的内容
ARepText:被替换成的内容
</code></pre><p>解析：创建正则，匹配内容，替换</p>
<h2 id="检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"><a href="#检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证" class="headerlink" title="检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"></a>检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证</h2><pre><code>function checkType (str, type) {
    switch (type) {
        case &apos;email&apos;:
            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);
        case &apos;phone&apos;:
            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);
        case &apos;tel&apos;:
            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);
        case &apos;number&apos;:
            return /^[0-9]$/.test(str);
        case &apos;english&apos;:
            return /^[a-zA-Z]+$/.test(str);
        case &apos;chinese&apos;:
            return /^[\u4E00-\u9FA5]+$/.test(str);
        case &apos;lower&apos;:
            return /^[a-z]+$/.test(str);
        case &apos;upper&apos;:
            return /^[A-Z]+$/.test(str);
        default :
            return true;
    }
}
console.log(checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;))   //false
</code></pre><p>解析：</p>
<pre><code>checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;)&apos;需要验证的字符串&apos;，&apos;匹配的格式&apos;
email：验证邮箱
phone：验证手机号
tel：验证座机号
number：验证数字
english：验证英文字母
chinese：验证中文字
lower：验证小写
upper：验证大写
</code></pre><p>JS返回浏览器历史第一页：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.xiejiahe.com/detail/5a18f8f5c7431c02ef43bca9" target="_blank" rel="noopener">JS返回浏览器历史第一页</a></p>
<p>我在浏览器控制台敲了 window.history 其实我想看看还有哪些API，他输出了以下信息，我看到length 这个属性让我眼前一亮，其他2个我不关心。</p>
<pre><code>{
    length: 2,
    scrollRestoration: &quot;auto&quot;,
    state: null
}
</code></pre><p>我尝试用length 去回退， 不成功！</p>
<pre><code>window.history.go(-2);
</code></pre><p>我再尝试用length去减1, 成功了， 我猜应该是跟新标签页有关吧。 那我不管了，我已经有答案了</p>
<pre><code>window.history.go(-1);
</code></pre><p>最后代码</p>
<pre><code>var historyLen = window.history;
window.history.go(-(historyLen - 1));
</code></pre><p>测试了3个浏览器， 都是第一次打开浏览器测试</p>
<pre><code>Chrome 会直接返回到新标签页
Safari 我这里测试是返回到百度，可能是我的设置问题
Firefox 直接关闭浏览器 
</code></pre><p>作为战斗在业务一线的前端，要想少加班，就要想办法提高工作效率。这里提一个小点，我们在业务开发过程中，经常会重复用到<code>日期格式化</code>、<code>url参数转对象</code>、<code>浏览器类型判断</code>、<code>节流函数</code>等一类函数，这些工具类函数，基本上在每个项目都会用到，为避免不同项目多次复制粘贴的麻烦，我们可以统一封装，发布到<code>npm</code>，以提高开发效率。</p>
<p>这里，笔者已经封装并发布了自己的武器库 <a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener">outils</a>，如果你对本项目感兴趣，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。当然你也可以在本项目的基础上封装自己的武器库。</p>
<p>常用函数汇总</p>
<h2 id="这里先分类整理下，之前项目中多次用到的工具函数。"><a href="#这里先分类整理下，之前项目中多次用到的工具函数。" class="headerlink" title="这里先分类整理下，之前项目中多次用到的工具函数。"></a>这里先分类整理下，之前项目中多次用到的工具函数。</h2><h2 id="1-Array"><a href="#1-Array" class="headerlink" title="1.Array"></a>1.Array</h2><h2 id="1-1-arrayEqual"><a href="#1-1-arrayEqual" class="headerlink" title="1.1 arrayEqual"></a>1.1 arrayEqual</h2><pre><code>/**
 * 
 * @desc 判断两个数组是否相等
 * @param {Array} arr1 
 * @param {Array} arr2 
 * @return {Boolean}
 */ function arrayEqual(arr1, arr2) {
    if (arr1 === arr2) return true;
    if (arr1.length != arr2.length) return false;
    for (var i = 0; i &lt; arr1.length; ++i) {
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
</code></pre><h2 id="2-Class"><a href="#2-Class" class="headerlink" title="2.Class"></a>2.Class</h2><h2 id="2-1-addClass"><a href="#2-1-addClass" class="headerlink" title="2.1 addClass"></a>2.1 addClass</h2><pre><code>/**
 * 
 * @desc   为元素添加class
 * @param  {HTMLElement} ele 
 * @param  {String} cls 
 */ 
var hasClass = require(&apos;./hasClass&apos;);
function addClass(ele, cls) {
    if (!hasClass(ele, cls)) {
        ele.className += &apos; &apos; + cls;
    }
}
</code></pre><p>2.2 hasClass</p>
<pre><code>/**
 * 
 * @desc 判断元素是否有某个class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 * @return {Boolean}
 */ 
function hasClass(ele, cls) {
    return (new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;)).test(ele.className);
}
</code></pre><p>2.3 removeClass</p>
<pre><code>/**
 * 
 * @desc 为元素移除class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 */ 
var hasClass = require(&apos;./hasClass&apos;);
function removeClass(ele, cls) {
    if (hasClass(ele, cls)) {
        var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;);
        ele.className = ele.className.replace(reg, &apos; &apos;);
    }
}
</code></pre><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h2><h2 id="3-1-getCookie"><a href="#3-1-getCookie" class="headerlink" title="3.1 getCookie"></a>3.1 getCookie</h2><pre><code>/**
 * 
 * @desc 根据name读取cookie
 * @param  {String} name 
 * @return {String}
 */ 
function getCookie(name) {
    var arr = document.cookie.replace(/\s/g, &quot;&quot;).split(&apos;;&apos;);
    for (var i = 0; i &lt; arr.length; i++) {
        var tempArr = arr[i].split(&apos;=&apos;);
        if (tempArr[0] == name) {
            return decodeURIComponent(tempArr[1]);
        }
    }
    return &apos;&apos;;
}
</code></pre><p>3.2 removeCookie</p>
<pre><code>var setCookie = require(&apos;./setCookie&apos;);
/**
 * 
 * @desc 根据name删除cookie
 * @param  {String} name 
 */
 function removeCookie(name) {
    // 设置已过期，系统会立刻删除cookie
    setCookie(name, &apos;1&apos;, -1);
}
</code></pre><p>3.3 setCookie</p>
<pre><code>/**
 * 
 * @desc  设置Cookie
 * @param {String} name 
 * @param {String} value 
 * @param {Number} days 
 */ 
function setCookie(name, value, days) {
    var date = new Date();
    date.setDate(date.getDate() + days);
    document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + date;
}
</code></pre><h2 id="4-Device"><a href="#4-Device" class="headerlink" title="4.Device"></a>4.Device</h2><h2 id="4-1-getExplore"><a href="#4-1-getExplore" class="headerlink" title="4.1 getExplore"></a>4.1 getExplore</h2><pre><code>/**
 * 
 * @desc 获取浏览器类型和版本
 * @return {String} 
 */ 
function getExplore() {
    var sys = {},
        ua = navigator.userAgent.toLowerCase(),
        s;
    (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:
        (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :
        (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :
        (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :
        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :
        (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :
        (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;
    // 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie)
    if (sys.edge) return (&apos;EDGE: &apos; + sys.edge)
    if (sys.firefox) return (&apos;Firefox: &apos; + sys.firefox)
    if (sys.chrome) return (&apos;Chrome: &apos; + sys.chrome)
    if (sys.opera) return (&apos;Opera: &apos; + sys.opera)
    if (sys.safari) return (&apos;Safari: &apos; + sys.safari)
    return &apos;Unkonwn&apos;
}
</code></pre><p>4.2 getOS</p>
<pre><code>/**
 * 
 * @desc 获取操作系统类型
 * @return {String} 
 */ 
function getOS() {
    var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;;
    var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;;
    var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;;

    if (/mac/i.test(appVersion)) return &apos;MacOSX&apos; if (/win/i.test(appVersion)) return &apos;windows&apos; if (/linux/i.test(appVersion)) return &apos;linux&apos; if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos; if (/android/i.test(userAgent)) return &apos;android&apos; if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos;
}
</code></pre><h2 id="5-Dom"><a href="#5-Dom" class="headerlink" title="5.Dom"></a>5.Dom</h2><h2 id="5-1-getScrollTop"><a href="#5-1-getScrollTop" class="headerlink" title="5.1 getScrollTop"></a>5.1 getScrollTop</h2><pre><code>/**
 * 
 * @desc 获取滚动条距顶部的距离
 */ 
function getScrollTop() {
    return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;
}
</code></pre><p>5.2 offset</p>
<pre><code>/**
 * 
 * @desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()
 * @param {HTMLElement} ele 
 * @returns { {left: number, top: number} }
 */ 
function offset(ele) {
    var pos = {
        left: 0,
        top: 0
    };
    while (ele) {
        pos.left += ele.offsetLeft;
        pos.top += ele.offsetTop;
        ele = ele.offsetParent;
    };
    return pos;
}
</code></pre><h2 id="5-3-scrollTo"><a href="#5-3-scrollTo" class="headerlink" title="5.3 scrollTo"></a>5.3 scrollTo</h2><pre><code>var getScrollTop = require(&apos;./getScrollTop&apos;);
var setScrollTop = require(&apos;./setScrollTop&apos;);
var requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 60);
        };
})();
/**
 * 
 * @desc  在${duration}时间内，滚动条平滑滚动到${to}指定位置
 * @param {Number} to 
 * @param {Number} duration 
 */ 
function scrollTo(to, duration) {
    if (duration &lt; 0) {
        setScrollTop(to);
        return
    }
    var diff = to - getScrollTop();
    if (diff === 0) return var step = diff / duration * 10;
    requestAnimationFrame(
        function () {
            if (Math.abs(step) &gt; Math.abs(diff)) {
                setScrollTop(getScrollTop() + diff);
                return;
            }
            setScrollTop(getScrollTop() + step);
            if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) {
                return;
            }
            scrollTo(to, duration - 16);
        });
}
</code></pre><h2 id="5-4-setScrollTop"><a href="#5-4-setScrollTop" class="headerlink" title="5.4 setScrollTop"></a>5.4 setScrollTop</h2><pre><code>/**
 * 
 * @desc 设置滚动条距顶部的距离
 */ 
function setScrollTop(value) {
    window.scrollTo(0, value);
    return value;
}
</code></pre><h2 id="6-Keycode"><a href="#6-Keycode" class="headerlink" title="6.Keycode"></a>6.Keycode</h2><h2 id="6-1-getKeyName"><a href="#6-1-getKeyName" class="headerlink" title="6.1 getKeyName"></a>6.1 getKeyName</h2><pre><code>var keyCodeMap = {
    8: &apos;Backspace&apos;,
    9: &apos;Tab&apos;,
    13: &apos;Enter&apos;,
    16: &apos;Shift&apos;,
    17: &apos;Ctrl&apos;,
    18: &apos;Alt&apos;,
    19: &apos;Pause&apos;,
    20: &apos;Caps Lock&apos;,
    27: &apos;Escape&apos;,
    32: &apos;Space&apos;,
    33: &apos;Page Up&apos;,
    34: &apos;Page Down&apos;,
    35: &apos;End&apos;,
    36: &apos;Home&apos;,
    37: &apos;Left&apos;,
    38: &apos;Up&apos;,
    39: &apos;Right&apos;,
    40: &apos;Down&apos;,
    42: &apos;Print Screen&apos;,
    45: &apos;Insert&apos;,
    46: &apos;Delete&apos;,

    48: &apos;0&apos;,
    49: &apos;1&apos;,
    50: &apos;2&apos;,
    51: &apos;3&apos;,
    52: &apos;4&apos;,
    53: &apos;5&apos;,
    54: &apos;6&apos;,
    55: &apos;7&apos;,
    56: &apos;8&apos;,
    57: &apos;9&apos;,

    65: &apos;A&apos;,
    66: &apos;B&apos;,
    67: &apos;C&apos;,
    68: &apos;D&apos;,
    69: &apos;E&apos;,
    70: &apos;F&apos;,
    71: &apos;G&apos;,
    72: &apos;H&apos;,
    73: &apos;I&apos;,
    74: &apos;J&apos;,
    75: &apos;K&apos;,
    76: &apos;L&apos;,
    77: &apos;M&apos;,
    78: &apos;N&apos;,
    79: &apos;O&apos;,
    80: &apos;P&apos;,
    81: &apos;Q&apos;,
    82: &apos;R&apos;,
    83: &apos;S&apos;,
    84: &apos;T&apos;,
    85: &apos;U&apos;,
    86: &apos;V&apos;,
    87: &apos;W&apos;,
    88: &apos;X&apos;,
    89: &apos;Y&apos;,
    90: &apos;Z&apos;,

    91: &apos;Windows&apos;,
    93: &apos;Right Click&apos;,

    96: &apos;Numpad 0&apos;,
    97: &apos;Numpad 1&apos;,
    98: &apos;Numpad 2&apos;,
    99: &apos;Numpad 3&apos;,
    100: &apos;Numpad 4&apos;,
    101: &apos;Numpad 5&apos;,
    102: &apos;Numpad 6&apos;,
    103: &apos;Numpad 7&apos;,
    104: &apos;Numpad 8&apos;,
    105: &apos;Numpad 9&apos;,
    106: &apos;Numpad *&apos;,
    107: &apos;Numpad +&apos;,
    109: &apos;Numpad -&apos;,
    110: &apos;Numpad .&apos;,
    111: &apos;Numpad /&apos;,

    112: &apos;F1&apos;,
    113: &apos;F2&apos;,
    114: &apos;F3&apos;,
    115: &apos;F4&apos;,
    116: &apos;F5&apos;,
    117: &apos;F6&apos;,
    118: &apos;F7&apos;,
    119: &apos;F8&apos;,
    120: &apos;F9&apos;,
    121: &apos;F10&apos;,
    122: &apos;F11&apos;,
    123: &apos;F12&apos;,

    144: &apos;Num Lock&apos;,
    145: &apos;Scroll Lock&apos;,
    182: &apos;My Computer&apos;,
    183: &apos;My Calculator&apos;,
    186: &apos;;&apos;,
    187: &apos;=&apos;,
    188: &apos;,&apos;,
    189: &apos;-&apos;,
    190: &apos;.&apos;,
    191: &apos;/&apos;,
    192: &apos;`&apos;,
    219: &apos;[&apos;,
    220: &apos;\\&apos;,
    221: &apos;]&apos;,
    222: &apos;\&apos;&apos;
};
/**
 * @desc 根据keycode获得键名
 * @param  {Number} keycode 
 * @return {String}
 */ 
function getKeyName(keycode) {
    if (keyCodeMap[keycode]) {
        return keyCodeMap[keycode];
    } else {
        console.log(&apos;Unknow Key(Key Code:&apos; + keycode + &apos;)&apos;);
        return &apos;&apos;;
    }
};
</code></pre><h2 id="7-Object"><a href="#7-Object" class="headerlink" title="7.Object"></a>7.Object</h2><h2 id="7-1-deepClone"><a href="#7-1-deepClone" class="headerlink" title="7.1 deepClone"></a>7.1 deepClone</h2><pre><code>/**
 * @desc 深拷贝，支持常见类型
 * @param {Any} values
 */ 
function deepClone(values) {
    var copy;

    // Handle the 3 simple types, and null or undefined if (null == values || &quot;object&quot; != typeof values) return values;

    // Handle Date if (values instanceof Date) {
        copy = new Date();
        copy.setTime(values.getTime());
        return copy;
    }

    // Handle Array if (values instanceof Array) {
        copy = [];
        for (var i = 0, len = values.length; i &lt; len; i++) {
            copy[i] = deepClone(values[i]);
        }
        return copy;
    }

    // Handle Object if (values instanceof Object) {
        copy = {};
        for (var attr in values) {
            if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);
        }
        return copy;
    }

    throw new Error(&quot;Unable to copy values! Its type isn&apos;t supported.&quot;);
}
</code></pre><h2 id="7-2-isEmptyObject"><a href="#7-2-isEmptyObject" class="headerlink" title="7.2 isEmptyObject"></a>7.2 isEmptyObject</h2><pre><code>/**
 * 
 * @desc   判断`obj`是否为空
 * @param  {Object} obj
 * @return {Boolean}
 */ 
function isEmptyObject(obj) {
    if (!obj || typeof obj !== &apos;object&apos; || Array.isArray(obj))
        return false return !Object.keys(obj).length
}
</code></pre><h2 id="8-Random"><a href="#8-Random" class="headerlink" title="8.Random"></a>8.Random</h2><h2 id="8-1-randomColor"><a href="#8-1-randomColor" class="headerlink" title="8.1 randomColor"></a>8.1 randomColor</h2><pre><code>/**
 * 
 * @desc 随机生成颜色
 * @return {String} 
 */ 
function randomColor() {
    return &apos;#&apos; + (&apos;00000&apos; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);
}
</code></pre><h2 id="8-2-randomNum"><a href="#8-2-randomNum" class="headerlink" title="8.2 randomNum"></a>8.2 randomNum</h2><pre><code>/**
 * 
 * @desc 生成指定范围随机数
 * @param  {Number} min 
 * @param  {Number} max 
 * @return {Number} 
 */ 
function randomNum(min, max) {
    return Math.floor(min + Math.random() * (max - min));
}
</code></pre><h2 id="9-Regexp"><a href="#9-Regexp" class="headerlink" title="9.Regexp"></a>9.Regexp</h2><h2 id="9-1-isEmail"><a href="#9-1-isEmail" class="headerlink" title="9.1 isEmail"></a>9.1 isEmail</h2><pre><code>/**
 * 
 * @desc   判断是否为邮箱地址
 * @param  {String}  str
 * @return {Boolean} 
 */ 
function isEmail(str) {
    return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str);
}
</code></pre><h2 id="9-2-isIdCard"><a href="#9-2-isIdCard" class="headerlink" title="9.2 isIdCard"></a>9.2 isIdCard</h2><pre><code>/**
 * 
 * @desc  判断是否为身份证号
 * @param  {String|Number} str 
 * @return {Boolean}
 */ 
function isIdCard(str) {
    return /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/.test(str)
}
</code></pre><h2 id="9-3-isPhoneNum"><a href="#9-3-isPhoneNum" class="headerlink" title="9.3 isPhoneNum"></a>9.3 isPhoneNum</h2><pre><code>/**
 * 
 * @desc   判断是否为手机号
 * @param  {String|Number} str 
 * @return {Boolean} 
 */
 function isPhoneNum(str) {
    return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/.test(str)
}
</code></pre><h2 id="9-4-isUrl"><a href="#9-4-isUrl" class="headerlink" title="9.4 isUrl"></a>9.4 isUrl</h2><pre><code>/**
 * 
 * @desc   判断是否为URL地址
 * @param  {String} str 
 * @return {Boolean}
 */ 
function isUrl(str) {
    return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str);
}
</code></pre><h2 id="10-String"><a href="#10-String" class="headerlink" title="10.String"></a>10.String</h2><h2 id="10-1-digitUppercase"><a href="#10-1-digitUppercase" class="headerlink" title="10.1 digitUppercase"></a>10.1 digitUppercase</h2><pre><code>/**
 * 
 * @desc   现金额转大写
 * @param  {Number} n 
 * @return {String}
 */
 function digitUppercase(n) {
    var fraction = [&apos;角&apos;, &apos;分&apos;];
    var digit = [
        &apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;,
        &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos;
    ];
    var unit = [
        [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;],
        [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;]
    ];
    var head = n &lt; 0 ? &apos;欠&apos; : &apos;&apos;;
    n = Math.abs(n);
    var s = &apos;&apos;;
    for (var i = 0; i &lt; fraction.length; i++) {
        s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;);
    }
    s = s || &apos;整&apos;;
    n = Math.floor(n);
    for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) {
        var p = &apos;&apos;;
        for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) {
            p = digit[n % 10] + unit[1][j] + p;
            n = Math.floor(n / 10);
        }
        s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s;
    }
    return head + s.replace(/(零.)*零元/, &apos;元&apos;)
        .replace(/(零.)+/g, &apos;零&apos;)
        .replace(/^整$/, &apos;零元整&apos;);
};
</code></pre><h2 id="11-Support"><a href="#11-Support" class="headerlink" title="11.Support"></a>11.Support</h2><h2 id="11-1-isSupportWebP"><a href="#11-1-isSupportWebP" class="headerlink" title="11.1 isSupportWebP"></a>11.1 isSupportWebP</h2><pre><code>/**
 * 
 * @desc 判断浏览器是否支持webP格式图片
 * @return {Boolean} 
 */ 
function isSupportWebP() {
    return !![].map &amp;&amp; document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0;
}
</code></pre><h2 id="12-Time"><a href="#12-Time" class="headerlink" title="12.Time"></a>12.Time</h2><h2 id="12-1-formatPassTime"><a href="#12-1-formatPassTime" class="headerlink" title="12.1 formatPassTime"></a>12.1 formatPassTime</h2><pre><code>/**
 * @desc   格式化${startTime}距现在的已过时间
 * @param  {Date} startTime 
 * @return {String}
 */ 
function formatPassTime(startTime) {
    var currentTime = Date.parse(new Date()),
        time = currentTime - startTime,
        day = parseInt(time / (1000 * 60 * 60 * 24)),
        hour = parseInt(time / (1000 * 60 * 60)),
        min = parseInt(time / (1000 * 60)),
        month = parseInt(day / 30),
        year = parseInt(month / 12);
    if (year) return year + &quot;年前&quot; if (month) return month + &quot;个月前&quot; if (day) return day + &quot;天前&quot; if (hour) return hour + &quot;小时前&quot; if (min) return min + &quot;分钟前&quot; else return &apos;刚刚&apos;
}
</code></pre><h2 id="12-2-formatRemainTime"><a href="#12-2-formatRemainTime" class="headerlink" title="12.2 formatRemainTime"></a>12.2 formatRemainTime</h2><pre><code>/**
 * 
 * @desc   格式化现在距${endTime}的剩余时间
 * @param  {Date} endTime  
 * @return {String}
 */ function formatRemainTime(endTime) {
    var startDate = new Date(); //开始时间 var endDate = new Date(endTime); //结束时间 var t = endDate.getTime() - startDate.getTime(); //时间差 var d = 0,
        h = 0,
        m = 0,
        s = 0;
    if (t &gt;= 0) {
        d = Math.floor(t / 1000 / 3600 / 24);
        h = Math.floor(t / 1000 / 60 / 60 % 24);
        m = Math.floor(t / 1000 / 60 % 60);
        s = Math.floor(t / 1000 % 60);
    }
    return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;;
}
</code></pre><h2 id="13-Url"><a href="#13-Url" class="headerlink" title="13.Url"></a>13.Url</h2><h2 id="13-1-parseQueryString"><a href="#13-1-parseQueryString" class="headerlink" title="13.1 parseQueryString"></a>13.1 parseQueryString</h2><pre><code>/**
 * 
 * @desc   url参数转对象
 * @param  {String} url  default: window.location.href
 * @return {Object} 
 */ 
function parseQueryString(url) {
    url = url == null ? window.location.href : url
    var search = url.substring(url.lastIndexOf(&apos;?&apos;) + 1)
    if (!search) {
        return {}
    }
    return JSON.parse(&apos;{&quot;&apos; + decodeURIComponent(search).replace(/&quot;/g, &apos;\\&quot;&apos;).replace(/&amp;/g, &apos;&quot;,&quot;&apos;).replace(/=/g, &apos;&quot;:&quot;&apos;) + &apos;&quot;}&apos;)
}
</code></pre><h2 id="13-2-stringfyQueryString"><a href="#13-2-stringfyQueryString" class="headerlink" title="13.2 stringfyQueryString"></a>13.2 stringfyQueryString</h2><pre><code>/**
 * 
 * @desc   对象序列化
 * @param  {Object} obj 
 * @return {String}
 */ function stringfyQueryString(obj) {
    if (!obj) return &apos;&apos;;
    var pairs = [];

    for (var key in obj) {
        var value = obj[key];

        if (value instanceof Array) {
            for (var i = 0; i &lt; value.length; ++i) {
                pairs.push(encodeURIComponent(key + &apos;[&apos; + i + &apos;]&apos;) + &apos;=&apos; + encodeURIComponent(value[i]));
            }
            continue;
        }

        pairs.push(encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(obj[key]));
    }

    return pairs.join(&apos;&amp;&apos;);
}
</code></pre><h2 id="14-Function"><a href="#14-Function" class="headerlink" title="14.Function"></a>14.Function</h2><h2 id="14-1-throttle"><a href="#14-1-throttle" class="headerlink" title="14.1 throttle"></a>14.1 throttle</h2><pre><code>/**
 * @desc   函数节流。
 * 适用于限制`resize`和`scroll`等函数的调用频率
 *
 * @param  {Number}    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}   noTrailing     可选，默认为false。
 *                                    如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。
 *                                    如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次.
 *                                    （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位）
 * @param  {Function}  callback       延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                    执行去节流功能时，调用`callback`。
 * @param  {Boolean}   debounceMode   如果`debounceMode`为true，`clear`在`delay`ms后执行。
 *                                    如果debounceMode是false，`callback`在`delay` ms之后执行。
 *
 * @return {Function}  新的节流函数
 */ function throttle(delay, noTrailing, callback, debounceMode) {

    // After wrapper has stopped being called, this timeout ensures that // `callback` is executed at the proper times in `throttle` and `end` // debounce modes. var timeoutID;

    // Keep track of the last time `callback` was executed. var lastExec = 0;

    // `noTrailing` defaults to falsy. if (typeof noTrailing !== &apos;boolean&apos;) {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing // functionality and when executed will limit the rate at which `callback` // is executed. function wrapper() {

        var self = this;
        var elapsed = Number(new Date()) - lastExec;
        var args = arguments;

        // Execute `callback` and update the `lastExec` timestamp. function exec() {
            lastExec = Number(new Date());
            callback.apply(self, args);
        }

        // If `debounceMode` is true (at begin) this is used to clear the flag // to allow future `callback` executions. function clear() {
            timeoutID = undefined;
        }

        if (debounceMode &amp;&amp; !timeoutID) {
            // Since `wrapper` is being called for the first time and // `debounceMode` is true (at begin), execute `callback`.
            exec();
        }

        // Clear any existing timeout. if (timeoutID) {
            clearTimeout(timeoutID);
        }

        if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) {
            // In throttle mode, if `delay` time has been exceeded, execute // `callback`.
            exec();

        } else if (noTrailing !== true) {
            // In trailing throttle mode, since `delay` time has not been // exceeded, schedule `callback` to execute `delay` ms after most // recent execution. // // If `debounceMode` is true (at begin), schedule `clear` to execute // after `delay` ms. // // If `debounceMode` is false (at end), schedule `callback` to // execute after `delay` ms.
            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
        }

    }

    // Return the wrapper function. return wrapper;

};
</code></pre><h2 id="14-2-debounce"><a href="#14-2-debounce" class="headerlink" title="14.2 debounce"></a>14.2 debounce</h2><pre><code>/**
 * @desc 函数防抖 
 * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次，
 * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。
 * @example 适用场景：如在线编辑的自动存储防抖。
 * @param  {Number}   delay         0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}  atBegin       可选，默认为false。
 *                                  如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。
                                    如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行
 * @param  {Function} callback      延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                  执行去抖动功能时，，调用`callback`。
 *
 * @return {Function} 新的防抖函数。
 */ 
var throttle = require(&apos;./throttle&apos;);
function debounce(delay, atBegin, callback) {
    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
};
</code></pre><p>封装</p>
<p>除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用<code>webpack</code>统一打包成<code>UMD</code> 通用模块规范，支持<code>webpack</code>、<code>RequireJS</code>、<code>SeaJS</code>等模块加载器，亦或直接通过<code>&lt;script&gt;</code>标签引入。</p>
<p>但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持按需引入吧</p>
<p>1.目录结构说明</p>
<pre><code>│  .babelrc
│  .gitignore
│  .travis.yml
│  LICENSE
│  package.json
│  README.md
│  setCookie.js  // 拷贝到根路径的函数模块，方便按需加载
│  setScrollTop.js
│  stringfyQueryString.js
│   ...
│   ...
│  
├─min
│      outils.min.js  // 所有函数统一打包生成的全量压缩包
│      
├─script  // 本项目开发脚本目录
│      build.js  // 打包构建脚本
│      test.js  // 测试脚本
│      webpack.conf.js  // webpack打包配置文件
│      
├─src // 源码目录
│  │  index.js  // webpack入口文件
│  │  
│  ├─array
│  │      
│  ├─class
│  │      
│  ├─cookie
│  │      
│  ├─device
│  │      
│  ├─dom
│  │      
│  ├─keycode
│  │      
│  ├─object
│  │      
│  ├─random
│  │      
│  ├─regexp
│  │      
│  ├─string
│  │      
│  ├─support
│  │      
│  ├─time
│  │      
│  └─url
│          
└─test // 测试用例目录
    │  array.test.js
    │  class.test.js
    │  cookie.test.js
    │  device.test.js
    │  dom.test.js
    │  index.html
    │  keycode.test.js
    │  object.test.js
    │  random.test.js
    │  regexp.test.js
    │  string.test.js
    │  support.test.js
    │  time.test.js
    │  url.test.js
    │  
    └─_lib // 测试所用到的第三方库
            mocha.css
            mocha.js
            power-assert.js
</code></pre><p>2.构建脚本</p>
<p>这里主要说明一下项目中<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fbuild.js" target="_blank" rel="noopener"> build.js </a>的构建过程<br>第一步，构建全量压缩包，先删除<code>min</code>目录中之前的<code>outils.min.js</code>，后通过<code>webpack</code>打包并保存新的压缩包至<code>min</code>目录中：</p>
<pre><code>......
 ......
 // 删除旧的全量压缩包
 rm(path.resolve(rootPath, &apos;min&apos;, `${pkg.name}.min.js`), err =&gt; {
     if (err) throw (err)
     webpack(config, function (err, stats) {
         if (err) throw (err)
         building.stop()
         process.stdout.write(stats.toString({
             colors: true,
             modules: false,
             children: false,
             chunks: false,
             chunkModules: false
         }) + &apos;\n\n&apos;)
         resolve()
         console.log(chalk.cyan(&apos;  Build complete.\n&apos;))
     })
 })
 ......
 ......
</code></pre><p>第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝<code>src</code>下面一层目录的所有<code>js</code>文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接<code>require(&#39;outils/&lt;方法名&gt;&#39;)</code>即可，缩短引入的路径，也算是提高点效率。</p>
<pre><code>// 替换模块文件
    ......
    ......
    // 先删除根目录中之前的函数模块
    rm(&apos;*.js&apos;, err =&gt; {
        if (err) throw (err)
        let folderList = fs.readdirSync(path.resolve(rootPath, &apos;src&apos;))
        folderList.forEach((item, index) =&gt; {
            // 拷贝`src`下面一层目录的所有`js`文件至根目录
            copy(`src/${item}/*.js`, rootPath, function (err, files) {
                if (err) throw err;
                if (index === folderList.length - 1) {
                    console.log(chalk.cyan(&apos;  Copy complete.\n&apos;))
                    copying.stop()
                }
            })
        })
    })
    ......
    ......
</code></pre><p>3.书写测试用例</p>
<p>俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。</p>
<p>但是因为时间关系，本项目暂时通过项目中的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Ftest.js" target="_blank" rel="noopener"> test.js </a>，启动了一个<code>koa</code>静态服务器，来加载<code>mocha</code>网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。<br>但是后续将使用<code>travis-ci</code>配合<code>Github</code>来做持续化构建，自动发布到<code>npm</code>。改用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>做单元测试，使用<code>Coverage</code>测试覆盖率。这一部分，后续更新。</p>
<p>这里给大家推荐一个好用的断言库<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252Fpackage%252Fpower-assert" target="_blank" rel="noopener"> power-assert </a>，这个库记住<code>assert(value, [message])</code>一个API就基本无敌，从此再也不用担心记不住断言库的API。</p>
<p>本项目的所有测试用例都在<code>test</code>目录下，大家可以作一定参考。</p>
<p>更新：单元测试，已使用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>，使用<code>Coverage</code>测试覆盖率，并集成<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Ftravis-ci.org%252F" target="_blank" rel="noopener"> travis-ci </a>配合<code>Github</code>来做持续化构建，可以参考本项目的<code>travis</code>配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252F.travis.yml" target="_blank" rel="noopener"> .travis.yml </a>和<code>karma</code>的配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fkarma.conf.js" target="_blank" rel="noopener"> karma.conf.js </a>。</p>
<blockquote>
<p>发布</p>
</blockquote>
<p>首先放到<code>Github</code>托管一下，当然你也可以直接<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252F" target="_blank" rel="noopener">fork</a>本项目，然后再加入你自己的函数。<br>以笔者项目，举个栗子:</p>
<p>1.添加自己的函数</p>
<p>在<code>src</code>目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。</p>
<pre><code>/**
 * 
 * @desc   判断是否NaN
 * @param  {Any} value 
 * @return {Boolean}
 */ 
function isNaN(value) {    
    return value !== value;
};

modules.export = isNaN
</code></pre><p>然后记得在src/index.js文件中暴露isNaN函数</p>
<p>2.单元测试</p>
<p>在<code>test</code>文件新建测试用例</p>
<pre><code>describe(&apos;#isNaN()&apos;, function () {
    it(`outils.isNaN(NaN) should return true`, function () {
        assert(outils.isNaN(NaN))
    })
    it(`outils.isNaN(&apos;value&apos;) should return false`, function () {
        assert.notEqual(outils.isNaN(NaN))
    })
})
</code></pre><p>然后记得在<code>test/index.html</code>中引入之前创建的测试用例脚本。</p>
<p>3.测试并打包</p>
<p>执行<code>npm run test</code>，看所有的测试用例是否通过。如果没有问题，执行<code>npm run build</code>构建，之后提交到个人的 github 仓库即可。</p>
<p>4.发布到<code>npm</code></p>
<p>在<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>注册账号，修改本地<code>package.json</code>中的<code>name</code>、<code>version</code>、<code>author</code>等信息，最后<code>npm publish</code>就大功告成了。<br>注意：向<code>npm</code>发包，要把镜像源切到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>，使用<code>cnpm</code>等第三方镜像源会报错。</p>
<p>使用</p>
<p>1.浏览器</p>
<p>直接下载<code>min</code>目录下的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fmin%252Foutils.min.js" target="_blank" rel="noopener"> outils.min.js </a>，通过<code>&lt;script&gt;</code>标签引入。</p>
<pre><code>&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var OS = outils.getOS()
  &lt;/script&gt;
</code></pre><p>注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Freleases" target="_blank" rel="noopener"> github Release </a>页面下载对应版本号的代码。</p>
<p>2.Webpack、RequireJS、SeaJS等模块加载器</p>
<p>先使用<code>npm</code>安装<code>outils</code>。</p>
<pre><code>$ npm install --save-dev outils
// 完整引入 const outils = require(&apos;outils&apos;)
const OS = outils.getOS()
推荐使用方法 
// 按需引入require(&apos;outils/&lt;方法名&gt;&apos;) const getOS = require(&apos;outils/getOS&apos;)
const OS = getOS()
</code></pre><p>当然，你的开发环境有<code>babel</code>编译<code>ES6</code>语法的话，也可以这样使用：</p>
<pre><code>import getOS from &apos;outils/getOS&apos; // 或 import { getOS } from &quot;outils&quot;;
</code></pre><p>总结</p>
<p>这里只是简单封装，发布到<code>npm</code>上，省去下次复制粘贴的功夫，或者直接Goole的时间。如果笔者的库中，没有你常用的函数，或者你有更好的建议，欢迎来本项目的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fissues" target="_blank" rel="noopener"> Github Issues </a>交流，如果觉得不错，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。</p>
<p>当然，更好的建议是<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> fork </a>本项目，或者直接新建自己的项目，添加自己 想要的 、常用的 、记不住的 函数，甚至是可以抽象出来的功能，封装成自己顺手、熟悉的库。 这样才能打造出你自己的武器库，瞬间提高你的单兵作战（开发）能力。</p>
<h2 id="libraries-：https-github-com-wuxianqiang-libraries"><a href="#libraries-：https-github-com-wuxianqiang-libraries" class="headerlink" title="libraries ：https://github.com/wuxianqiang/libraries"></a>libraries ：<a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries" target="_blank" rel="noopener">https://github.com/wuxianqiang/libraries</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectcreate%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.create()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADstringtrim%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中String.trim()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarrayreduce%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.reduce()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectkeys%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.keys()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADfunctionbind%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Function.bind()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarraymap%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.map()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFmathmax%25E6%2596%25B9%25E6%25B3%2595%25E4%25B8%258D%25E5%25AE%259A%25E5%25AE%259E%25E5%258F%2582%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿Math.max()方法实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFstringmatch%25E6%2596%25B9%25E6%25B3%2595%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">仿String.match()方法实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFhtml5%25E7%259A%2584classlist%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">仿HTML5的classList属性实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2587%25BD%25E6%2595%25B0%25E7%259A%2584%25E5%2590%258D%25E5%25AD%2597" target="_blank" rel="noopener">仿Function.name属性实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E5%25B1%2582%25E7%25A5%2596%25E5%2585%2588%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n层祖先元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%2585%2584%25E5%25BC%259F%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个兄弟元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%25AD%2590%25E4%25BB%25A3%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个子代元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB1" target="_blank" rel="noopener">原生JS实现CSS动画之震动</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB2" target="_blank" rel="noopener">原生JS实现CSS动画之隐藏</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E6%2595%25B0%25E7%25BB%2584%25E4%25B8%25AD%25E6%259F%25A5%25E6%2589%25BE%25E6%2589%2580%25E6%259C%2589%25E5%2587%25BA%25E7%258E%25B0%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E6%2596%25B9%25E6%25B3%2595" target="_blank" rel="noopener">在数组中查找所有出现的元素方法</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E6%258D%25AE%25E7%25B1%25BB%25E5%259E%258B%25E6%25A3%2580%25E6%25B5%258B%25E7%2589%25B9%25E6%25AE%258A%25E6%2583%2585%25E5%2586%25B5%25E7%2589%25B9%25E6%25AE%258A%25E5%25A4%2584%25E7%2590%2586" target="_blank" rel="noopener">数据类型检测之特殊情况特殊处理</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0outerhtml%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">使用innerHTML实现outerHTML属性</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258F%2592%25E5%2585%25A5%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">插入节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2580%2592%25E5%25BA%258F%25E6%258E%2592%25E5%2588%2597%25E5%25AD%2590%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">倒序排列子节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E6%25BB%259A%25E5%258A%25A8%25E6%259D%25A1%25E7%259A%2584%25E4%25BD%258D%25E7%25BD%25AE" target="_blank" rel="noopener">查询窗口滚动条的位置</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E7%259A%2584%25E8%25A7%2586%25E5%258F%25A3%25E5%25B0%25BA%25E5%25AF%25B8" target="_blank" rel="noopener">查询窗口的视口尺寸</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25A1%25A8%25E6%25A0%25BC%25E7%259A%2584%25E8%25A1%258C%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">表格的行排序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E7%2594%259F%25E6%2588%2590%25E7%259B%25AE%25E5%25BD%2595%25E8%25A1%25A8" target="_blank" rel="noopener">生成目录表</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E7%25BB%2584%25E5%258E%25BB%25E9%2587%258D" target="_blank" rel="noopener">数组去重</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">冒泡排序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%258Eurl%25E8%25A7%25A3%25E6%259E%2590%25E5%258F%2582%25E6%2595%25B0" target="_blank" rel="noopener">从URL解析参数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%258E%25B7%25E5%258F%2596%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">获取纯文本的元素内容</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2589%258B%25E5%2586%2599%25E4%25B8%2580%25E4%25B8%25AAjsonp%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">手写一个JSONP实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E5%25BD%25A2%25E5%25BC%258F%25E7%259A%2584%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">查询纯文本形式的内容</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E6%2589%25BE%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E5%2590%258E%25E4%25BB%25A3%25E4%25B8%25AD%25E8%258A%2582%25E7%2582%25B9%25E4%25B8%25AD%25E7%259A%2584%25E6%2589%2580%25E6%259C%2589text%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">查找元素的后代中节点中的所有Text节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0insertadjacenthtml" target="_blank" rel="noopener">使用innerHTML实现insertAdjacentHTML</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258B%2596%25E6%258B%25BD" target="_blank" rel="noopener">拖拽</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E8%25B0%25B7%25E6%25AD%258C%25E5%259C%25B0%25E5%259B%25BE%25E4%25B8%258A%25E6%2598%25BE%25E7%25A4%25BA%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E4%25BF%25A1%25E6%2581%25AF" target="_blank" rel="noopener">在谷歌地图上显示地理位置信息</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8%25E6%2589%2580%25E6%259C%2589%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E7%2589%25B9%25E6%2580%25A7" target="_blank" rel="noopener">使用所有地理位置特性</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BC%2598%25E9%259B%2585%25E7%259A%2584%25E5%259B%25BE%25E7%2589%2587%25E7%25BF%25BB%25E8%25BD%25AC%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">优雅的图片翻转实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E5%25A4%259A%25E8%25BE%25B9%25E5%25BD%25A2" target="_blank" rel="noopener">使用canvas绘制多边形</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E9%259B%25AA%25E8%258A%25B1" target="_blank" rel="noopener">使用canvas绘制雪花</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8web-worker%25E4%25B8%25AD%25E5%258F%2591%25E8%25B5%25B7%25E5%2590%258C%25E6%25AD%25A5xmlhtttprequest" target="_blank" rel="noopener">在Web Worker中发起同步XMLHtttpRequest</a></li>
</ul>
<h2 id="仿ECMAScript5中Object-create-函数"><a href="#仿ECMAScript5中Object-create-函数" class="headerlink" title="仿ECMAScript5中Object.create()函数"></a>仿ECMAScript5中Object.create()函数</h2><pre><code>function inherit(obj) {
            if (obj === null) throw TypeError();
            if (Object.create) return Object.create(obj);
            var t = typeof obj;
            if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) throw TypeError();
            function Fn() {};
            Fn.prototype = obj;
            return new Fn();
        }
</code></pre><h2 id="仿ECMAScript5中String-trim-函数"><a href="#仿ECMAScript5中String-trim-函数" class="headerlink" title="仿ECMAScript5中String.trim()函数"></a>仿ECMAScript5中String.trim()函数</h2><pre><code>String.prototype.mytrim = function () {
            String.prototype.trim || function () {
                if (!this) return this; //空字符串不做处理
                return this.replace(/^\s+|\s+$/g, &quot;&quot;) //使用正则表达式经行空格替换
            }
        }
</code></pre><h2 id="仿ECMAScript5中Array-reduce-函数"><a href="#仿ECMAScript5中Array-reduce-函数" class="headerlink" title="仿ECMAScript5中Array.reduce()函数"></a>仿ECMAScript5中Array.reduce()函数</h2><pre><code>var reduce = Array.prototype.reduce ? function (ary, fn, initial) {
            if (arguments.length &gt; 2) { //如果reduce()方法存在的话
                return ary.reduce(fn, initial); //如果传入了一个初始值
            } else {
                return ary.reduce(fn); //否则初始值
            }
        } : function (ary, fn, initial) { //以特定的初始值开始，否则第一个值取自ary
            var i = 0,
                len = ary.length,
                accumulator;
            if (arguments.length &gt; 2) {
                accumulator = initial;
            } else { //找到数组中第一个已经定义的索引
                if (len == 0) throw TypeError();
                while (i &lt; len) {
                    if (i in ary) {
                        accumulator = ary[i++];
                        break;
                    } else {
                        i++;
                    }
                }
                if (i == len) throw TypeError();
            }
            while (i &lt; len) { //对于数组中剩下的元素依次调用fn
                if (i in ary) {
                    accumulator = fn.call(undefined, accumulator, ary[i], i, ary)
                }
                i++;
            }
            return accumulator;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在数组中查找所有出现的元素方法"><a href="#在数组中查找所有出现的元素方法" class="headerlink" title="在数组中查找所有出现的元素方法"></a>在数组中查找所有出现的元素方法</h2><pre><code>function findAll(ary, ele) {
            var results = [],
                len = ary.length,
                pos = 0;
            while (pos &lt; len) {
                pos = ary.indexOf(ele, pos);
                if (pos === -1) break;
                results.push(pos);
                pos++;
            }
            return results;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="数据类型检测，特殊情况特殊处理"><a href="#数据类型检测，特殊情况特殊处理" class="headerlink" title="数据类型检测，特殊情况特殊处理"></a>数据类型检测，特殊情况特殊处理</h2><pre><code>function classOf(obj) {
            if (obj === null) return &quot;Null&quot;;
            if (obj === undefined) return &apos;Undefined&apos;;
            return Object.prototype.toString.call(obj).slice(8, -1);
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Object-keys-函数"><a href="#仿ECMAScript5中Object-keys-函数" class="headerlink" title="仿ECMAScript5中Object.keys()函数"></a>仿ECMAScript5中Object.keys()函数</h2><pre><code>function keys(obj) {
            if (typeof obj !== &quot;object&quot;) {
                throw TypeError();
            }
            var result = [];
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    result.push(prop);
                }
            }
            return result;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿Math-max方法（不定实参函数）"><a href="#仿Math-max方法（不定实参函数）" class="headerlink" title="仿Math.max方法（不定实参函数）"></a>仿Math.max方法（不定实参函数）</h2><pre><code>function max() {
            var max = Number.NEGATIVE_INFINITY;
            for (var i = 0; i &lt; arguments.length; i++) {
                if (arguments[i] &gt; max) max = arguments[i];
            }
            return max;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Function-bind-函数"><a href="#仿ECMAScript5中Function-bind-函数" class="headerlink" title="仿ECMAScript5中Function.bind()函数"></a>仿ECMAScript5中Function.bind()函数</h2><pre><code>if (!Function.prototype.bind) {
            Function.prototype.bind = function (obj) {
                var self = this,
                    boundArgs = arguments;
                return function () {
                    var args = [],
                        i;
                    for (i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);
                    for (i = 1; i &lt; arguments.length; i++) args.push(arguments[i]);
                    return self.apply(obj, args);
                }
            }
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Array-map-函数"><a href="#仿ECMAScript5中Array-map-函数" class="headerlink" title="仿ECMAScript5中Array.map()函数"></a>仿ECMAScript5中Array.map()函数</h2><pre><code>var map = Array.prototype.map ? function (ary, fn) {
            return ary.map(fn);
        } : function (ary, fn) {
            var results = [];
            for (var i = 0, len = ary.length; i &lt; len; i++) {
                if (i in ary) {
                    results[i] = fn.call(null, ary[i], i, ary);
                }
            }
            return results;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code>Array.prototype.unique = function unique() {
            var obj = {};
            for (var i = 0; i &lt; this.length; i++) {
                var current = this[i];
                if (obj[current] === current) {
                    current = this[this.length - 1];
                    this.length--;
                    i--;
                    continue;
                }
                obj[current] = current
            }
            obj = null;
            return this;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>Array.prototype.bubbleSort = function bubbleSort() {
            var temp = null;
            for (var i = 0; i &lt; this.length - 1; i++) {
                for (var k = 0; k &lt; this.length - 1 - i; k++) {
                    if (this[k] &gt; this[k + 1]) {
                        temp = this[k];
                        this[k] = this[k + 1];
                        this[k + 1] = temp;
                    }
                }
            }
            return this;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿String-match-方法实现"><a href="#仿String-match-方法实现" class="headerlink" title="仿String.match()方法实现"></a>仿String.match()方法实现</h2><pre><code>String.prototype.mymatch = function (reg) {
         var ary = [];
         var res = reg.exec(this);
         while (res) {
            ary.push(res[0]);
            res = reg.exec(this);
         }
         return ary;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n层祖先元素"><a href="#返回元素的第n层祖先元素" class="headerlink" title="返回元素的第n层祖先元素"></a>返回元素的第n层祖先元素</h2><pre><code>/**
        *返回元素ele的第n层祖先元素，如果不存在此类祖先或祖先不是Element，
        *（例如Document或者DocumentFragment）则返回null
        *如果n为0，则返回e本身。如果n为1（或省略），则返回其父元素
        *如果n为2，则返回其祖父元素，依次类推
        */
        function parent(ele, n) {
            if (n === nudefined) n = 1;
            while (n-- &amp;&amp; ele) {
                ele = ele.parentNode;
            }
            if (!ele || ele.nodeTope !== 1) return null;
            return ele;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n个兄弟元素"><a href="#返回元素的第n个兄弟元素" class="headerlink" title="返回元素的第n个兄弟元素"></a>返回元素的第n个兄弟元素</h2><pre><code>/**
 *返回元素ele的第n个兄弟元素
 *如果n为正，返回后续的第n个兄弟元素
 *如果n为负，返回前面的第n个兄弟元素
 *如果n为零，返回ele本身
 */
function sibling(ele, n) {
    while (ele &amp;&amp; n !== 0) { //如果ele未定义，即刻返回它
        if (n &gt; 0) { //查找后续的兄弟元素
            if (ele.nextElementSibling) {
                ele = ele.nextElementSibling;
            } else {
                for (ele = ele.nextSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;
            }
            n--;
        } else { //查找前面的兄弟元素
            if (ele.previousElementSibing) {
                ele = ele.previousElementSibling;
            } else {
                for (ele = ele.previousSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;
            }
            n++;
        }
    }
    return ele;
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n个子代元素"><a href="#返回元素的第n个子代元素" class="headerlink" title="返回元素的第n个子代元素"></a>返回元素的第n个子代元素</h2><pre><code>/**
 *返回元素ele的第n代子元素，如果不存在则为null
 *负值n代表从后往前计数。0表示第一个子元素，而-1代表最后一个，-2代表倒数第二个，依次类推
 */
function child(ele, n) {
    if (ele.children) { //如果children数组存在
        if (n &lt; 0) n += ele.children.length; //转换负的n为数组索引
        if (n &lt; 0) return null; //如果它仍然为负，说明没有子元素
        return ele.children[n]; //返回指定的子元素
    }
    //如果e没有children数组，找到第一个子元素并向前数，或找到最后一个子元素并往回数
    if (n &gt;= 0) { //n非负：从第一个子元素向前数
        //找到元素e的第一个子元素
        if (ele.firstElementChild) {
            ele = ele.firstElementChild;
        } else {
            for (ele = ele.firstChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;
        }
        return sibling(ele, n); //返回第一个子元素的第n个兄弟元素
    } else { //n为负：从最后一个子元素往回数
        if (ele.lastElementChild) {
            ele = ele.lastElementChild;
        } else {
            for (ele = ele.lastChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;
        }
        return sibling(ele, n + 1); //+1来转化最后1个子元素为最后1个兄弟元素
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="表格的行排序"><a href="#表格的行排序" class="headerlink" title="表格的行排序"></a>表格的行排序</h2><pre><code>//根据指定表格每行第n个单元格的值，对第一个＜tbody＞中的行进行排序
//如果存在comparator函数则使用它，否则按字母表顺序比较
function sortrows(table, n, comparator) {
    var tbody = table.tBodies[0]; //第一个＜tbody＞，可能是隐式创建的
    var rows = tbody.getElementsByTagName(&quot;tr&quot;); //tbody中的所有行
    rows = Array.prototype.slice.call(rows, 0); //真实数组中的快照
    //基于第n个＜td＞元素的值对行排序
    rows.sort(function (row1, row2) {
        var cell1 = row1.getElementsByTagName(&quot;td&quot;)[n]; //获得第n个单元格
        var cell2 = row2.getElementsByTagName(&quot;td&quot;)[n]; //两行都是
        var val1 = cell1.textContent || cell1.innerText; //获得文本内容
        var val2 = cell2.textContent || cell2.innerText; //两单元格都是
        if (comparator) return comparator(val1, val2); //进行比较
        if (val1 &lt; val2) {
            return -1;
        } else if (val1 &gt; val2) {
            return 1;
        } else {
            return 0;
        }
    }); //在tbody中按它们的顺序把行添加到最后
    //这将自动把它们从当前位置移走，故没必要预先删除它们
    //如果＜tbody＞还包含了除了＜tr＞的任何其他元素，这些节点将会悬浮到顶部位置
    for (var i = 0; i &lt; rows.length; i++) tbody.appendChild(rows[i]);
}
//查找表格的＜th＞元素（假设只有一行），让它们可单击，
//以便单击列标题，按该列对行排序
function makeSortable(table) {
    var headers = table.getElementsByTagName(&quot;th&quot;);
    for (var i = 0; i &lt; headers.length; i++) {
        (function (n) { //嵌套函数来创建本地作用域
            headers[i].onclick = function () {
                sortrows(table, n);
            };
        }(i)); //将i的值赋给局部变量n
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="生成目录表"><a href="#生成目录表" class="headerlink" title="生成目录表"></a>生成目录表</h2><pre><code>/**
 *
 *这个模块注册一个可在页面加载完成后自动运行的匿名函数。当执行这个函数时会去文档中查找
 *id为&quot;TOC&quot;的元素。如果这个元素不存在，就创建一个元素
 *
 *生成的TOC目录应当具有自己的CSS样式。整个目录区域的样式className设置为&quot;TOCEntry&quot;
 *同样我们为不同层级的目录标题定义不同的样式。＜h1＞标签生成的标题
 *className为&quot;TOCLevel1&quot;，＜h2＞标签生成的标题className为&quot;TOCLevel2&quot;，以此类推
 *段编号的样式为&quot;TOCSectNum&quot;
 *
 *完整的CSS样式代码如下:
 *
 *#TOC{border:solid black 1px;margin:10px;padding:10px;}
 *.TOCEntry{font-family:sans-serif;}
 *.TOCEntry a{text-decoration:none;}
 *.TOCLevel1{font-size:16pt;font-weight:bold;}
 *.TOCLevel2{font-size:12pt;margin-left:.5in;}
 *.TOCSectNum:after{content:&quot;:&quot;;}
 *
 *这段代码的最后一行表示每个段编号之后都有一个冒号和空格符。要想隐藏段编号，
 *请使用这行代码：
 *.TOCSectNum{display:none}
 *
 **/
(function () { //匿名函数定义了一个局部作用域
    //查找TOC容器元素
    //如果不存在，则在文档开头处创建一个
    var toc = document.getElementById(&quot;TOC&quot;);
    if (!toc) {
        toc = document.createElement(&quot;div&quot;);
        toc.id = &quot;TOC&quot;;
        document.body.insertBefore(toc, document.body.firstChild);
    }
    //查找所有的标题元素
    var headings;
    if (document.querySelectorAll) //我们是否能用这个简单的方法？
        headings = document.querySelectorAll(&quot;h1,h2,h3,h4,h5,h6&quot;);
    else //否则，查找方法稍微麻烦一些
        headings = findHeadings(document.body, []); //递归遍历document的body，查找标题元素
    function findHeadings(root, sects) {
        for (var c = root.firstChild; c != null; c = c.nextSibling) {
            if (c.nodeType !== 1) continue;
            if (c.tagName.length == 2 &amp;&amp; c.tagName.charAt(0) == &quot;H&quot;)
                sects.push(c);
            else
                findHeadings(c, sects);
        }
        return sects;
    }
    //初始化一个数组来保持跟踪章节号
    var sectionNumbers = [0, 0, 0, 0, 0, 0]; //现在，循环已找到的标题元素
    for (var h = 0; h &lt; headings.length; h++) {
        var heading = headings[h]; //跳过在TOC容器中的标题元素
        if (heading.parentNode == toc) continue; //判定标题的级别
        var level = parseInt(heading.tagName.charAt(1));
        if (isNaN(level) || level &lt; 1 || level &gt; 6) continue; //对于该标题级别增加sectionNumbers对应的数字
        //重置所有标题比它级别低的数字为零
        sectionNumbers[level - 1]++;
        for (var i = level; i &lt; 6; i++) sectionNumbers[i] = 0; //现在，将所有标题级别的章节号组合产生一个章节号， 如2 .3 .1
        var sectionNumber = sectionNumbers.slice(0, level).join(&quot;.&quot;) //为标题级别增加章节号
        //把数字放在＜span＞中，使得其可以用样式修饰
        var span = document.createElement(&quot;span&quot;);
        span.className = &quot;TOCSectNum&quot;;
        span.innerHTML = sectionNumber;
        heading.insertBefore(span, heading.firstChild); //用命名的锚点将标题包起来，以便为它增加链接
        var anchor = document.createElement(&quot;a&quot;);
        anchor.name = &quot;TOC&quot; + sectionNumber;
        heading.parentNode.insertBefore(anchor, heading);
        anchor.appendChild(heading); //现在为该节创建一个链接
        var link = document.createElement(&quot;a&quot;);
        link.href = &quot;#TOC&quot; + sectionNumber; //链接的目标地址
        link.innerHTML = heading.innerHTML; //链接文本与实际标题一致
        //将链接放在一个div中，div用基于级别名字的样式修饰
        var entry = document.createElement(&quot;div&quot;);
        entry.className = &quot;TOCEntry TOCLevel&quot; + level;
        entry.appendChild(link); //该div添加到TOC容器中
        toc.appendChild(entry);
    }
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="从URL解析参数"><a href="#从URL解析参数" class="headerlink" title="从URL解析参数"></a>从URL解析参数</h2><pre><code>/*
 *这个函数用来解析来自URL的查询串中的name=value参数对
 *它将name=value对存储在一个对象的属性中，并返回该对象
 *这样来使用它
 *
 *var args=urlArgs();//从URL中解析参数
 *var q=args.q||&quot;&quot;;//如果参数定义了的话就使用参数；否则使用一个默认值
 *var n=args.n?parseInt(args.n):10;
 */
function urlArgs() {
    var args = {}; //定义一个空对象
    var query = location.search.substring(1); //查找到查询串，并去掉&apos;?&apos;
    var pairs = query.split(&quot;&amp;&quot;); //根据&quot;&amp;&quot;符号将查询字符串分隔开
    for (var i = 0; i &lt; pairs.length; i++) { //对于每个片段
        var pos = pairs[i].indexOf(&apos;=&apos;); //查找&quot;name=value&quot;
        if (pos == -1) continue; //如果没有找到的话，就跳过
        var name = pairs[i].substring(0, pos); //提取name
        var value = pairs[i].substring(pos + 1); //提取value
        value = decodeURIComponent(value); //对value进行解码
        args[name] = value; //存储为属性
    }
    return args; //返回解析后的参数
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="获取纯文本的元素内容"><a href="#获取纯文本的元素内容" class="headerlink" title="获取纯文本的元素内容"></a>获取纯文本的元素内容</h2><pre><code>/**
 *一个参数，返回元素的textContent或innerText
 *两个参数，用value参数的值设置元素的textContent或innerText
 */
function textContent(element, value) {
    var content = element.textContent; //检测textContent是否有定义
    if (value === undefined) { //没传递value，因此返回当前文本
        if (content !== undefined) {
            return content;
        } else {
            return element.innerText;
        }
    } else { //传递了value，因此设置文本
        if (content !== undefined) {
            element.textContent = value;
        } else {
            element.innerText = value;
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="手写一个JSONP实现"><a href="#手写一个JSONP实现" class="headerlink" title="手写一个JSONP实现"></a>手写一个JSONP实现</h2><pre><code>//根据指定的URL发送一个JSONP请求
//然后把解析得到的响应数据传递给回调函数
//在URL中添加一个名为jsonp的查询参数，用于指定该请求的回调函数的名称
function getJSONP(url, callback) { //为本次请求创建一个唯一的回调函数名称
    var cbnum = &quot;cb&quot; + getJSONP.counter++; //每次自增计数器
    var cbname = &quot;getJSONP.&quot; + cbnum; //作为JSONP函数的属性
    //将回调函数名称以表单编码的形式添加到URL的查询部分中
    //使用jsonp作为参数名，一些支持JSONP的服务
    //可能使用其他的参数名，比如callback
    if (url.indexOf(&quot;?&quot;) === -1) //URL没有查询部分
        url += &quot;?jsonp=&quot; + cbname; //作为查询部分添加参数
    else //否则
        url += &quot;＆jsonp=&quot; + cbname; //作为新的参数添加它
    //创建script元素用于发送请求
    var script = document.createElement(&quot;script&quot;); //定义将被脚本执行的回调函数
    getJSONP[cbnum] = function (response) {
        try {
            callback(response); //处理响应数据
        } finally { //即使回调函数或响应抛出错误
            delete getJSONP[cbnum]; //删除该函数
            script.parentNode.removeChild(script); //移除script元素
        }
    }; //立即触发HTTP请求
    script.src = url; //设置脚本的URL
    document.body.appendChild(script); //把它添加到文档中
}
getJSONP.counter = 0; //用于创建唯一回调函数名称的计数器
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><pre><code>//将child节点插入到parent中，使其成为第n个子节点
function insertAt(parent, child, n) {
    if (n &lt; 0 || n &gt; parent.childNodes.length) {
        throw new Error(&quot;invalid index&quot;);
    } else if (n == parent.childNodes.length) {
        parent.appendChild(child);
    } else {
        parent.insertBefore(child, parent.childNodes[n]);
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用innerHTML实现outerHTML属性"><a href="#使用innerHTML实现outerHTML属性" class="headerlink" title="使用innerHTML实现outerHTML属性"></a>使用innerHTML实现outerHTML属性</h2><pre><code>//为那些不支持它的浏览器实现outerHTML属性
//假设浏览器确实支持innerHTML，并有个可扩展的Element.prototype，
//并且可以定义getter和setter
(function () { //如果outerHTML存在，则直接返回
    if (document.createElement(&quot;div&quot;).outerHTML) return; //返回this所引用元素的外部HTML
    function outerHTMLGetter() {
        var container = document.createElement(&quot;div&quot;); //虚拟元素
        container.appendChild(this.cloneNode(true)); //复制到该虚拟节点
        return container.innerHTML; //返回虚拟节点的innerHTML
    }
    //用指定的值设置元素的外部HTML
    function outerHTMLSetter(value) { //创建一个虚拟元素，设置其内容为指定的值
        var container = document.createElement(&quot;div&quot;);
        container.innerHTML = value; //将虚拟元素中的节点全部移动到文档中
        while (container.firstChild) //循环，直到container没有子节点为止
            this.parentNode.insertBefore(container.firstChild, this); //删除所被取代的节点
        this.parentNode.removeChild(this);
    }
    //现在使用这两个函数作为所有Element对象的outerHTML属性的getter和setter
    //如果它存在则使用ES5的Object.defineProperty()方法，
    //否则，退而求其次，使用__defineGetter__()和__defineSetter__()
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, &quot;outerHTML&quot;, {
            get: outerHTMLGetter,
            set: outerHTMLSetter,
            enumerable: false,
            configurable: true
        });
    } else {
        Element.prototype.__defineGetter__(&quot;outerHTML&quot;, outerHTMLGetter);
        Element.prototype.__defineSetter__(&quot;outerHTML&quot;, outerHTMLSetter);
    }
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="倒序排列子节点"><a href="#倒序排列子节点" class="headerlink" title="倒序排列子节点"></a>倒序排列子节点</h2><pre><code>//倒序排列节点n的子节点
function reverse(n) { //创建一个DocumentFragment作为临时容器
    var f = document.createDocumentFragment(); //从后至前循环子节点，将每一个子节点移动到文档片段中
    //n的最后一个节点变成f的第一个节点，反之亦然
    //注意，给f添加一个节点，该节点自动地会从n中删除
    while (n.lastChild) f.appendChild(n.lastChild); //最后，把f的所有子节点一次性全部移回n中
    n.appendChild(f);
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询窗口滚动条的位置"><a href="#查询窗口滚动条的位置" class="headerlink" title="查询窗口滚动条的位置"></a>查询窗口滚动条的位置</h2><pre><code>//以一个对象的x和y属性的方式返回滚动条的偏移量
function getScrollOffsets(w) { //使用指定的窗口，如果不带参数则使用当前窗口
    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用
    if (w.pageXOffset != null) return {
        x: w.pageXOffset,
        y: w.pageYOffset
    }; //对标准模式下的IE（或任何浏览器）
    var d = w.document;
    if (document.compatMode == &quot;CSS1Compat&quot;)
        return {
            x: d.documentElement.scrollLeft,
            y: d.documentElement.scrollTop
        }; //对怪异模式下的浏览器
    return {
        x: d.body.scrollLeft,
        y: d.body.scrollTop
    };
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询窗口的视口尺寸"><a href="#查询窗口的视口尺寸" class="headerlink" title="查询窗口的视口尺寸"></a>查询窗口的视口尺寸</h2><pre><code>//作为一个对象的w和h属性返回视口的尺寸
function getViewportSize(w) { //使用指定的窗口，如果不带参数则使用当前窗口
    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用
    if (w.innerWidth != null) return {
        w: w.innerWidth,
        h: w.innerHeight
    }; //对标准模式下的IE（或任何浏览器）
    var d = w.document;
    if (document.compatMode == &quot;CSS1Compat&quot;)
        return {
            w: d.documentElement.clientWidth,
            h: d.documentElement.clientHeight
        }; //对怪异模式下的浏览器
    return {
        w: d.body.clientWidth,
        h: d.body.clientWidth
    };
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回函数的名字"><a href="#返回函数的名字" class="headerlink" title="返回函数的名字"></a>返回函数的名字</h2><pre><code>Function.prototype.getName = function () {
    return this.name || this.toString().match(/function\s*(\w*)\s*\(/)[1];
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="原生JS实现CSS动画1"><a href="#原生JS实现CSS动画1" class="headerlink" title="原生JS实现CSS动画1"></a>原生JS实现CSS动画1</h2><pre><code>//将e转化为相对定位的元素，使之左右&quot;震动&quot;
//第一个参数可以是元素对象或者元素的id
//如果第二个参数是函数，以e为参数，它将在动画结束时调用
//第三个参数指定e震动的距离，默认是5像素
//第四个参数指定震动多久，默认是500毫秒
function shake(e, oncomplete, distance, time) { //句柄参数
    if (typeof e === &quot;string&quot;) e = document.getElementById(e);
    if (!time) time = 500;
    if (!distance) distance = 5;
    var originalStyle = e.style.cssText; //保存e的原始style
    e.style.position = &quot;relative&quot;; //使e相对定位
    var start = (new Date()).getTime(); //注意，动画的开始时间
    animate(); //动画开始
    //函数检查消耗的时间，并更新e的位置
    //如果动画完成，它将e还原为原始状态
    //否则，它更新e的位置，安排它自身重新运行
    function animate() {
        var now = (new Date()).getTime(); //得到当前时间
        var elapsed = now - start; //从开始以来消耗了多长时间？
        var fraction = elapsed / time; //是总时间的几分之几？
        if (fraction &lt; 1) { //如果动画未完成
            //作为动画完成比例的函数，计算e的x位置
            //使用正弦函数将完成比例乘以4pi
            //所以，它来回往复两次
            var x = distance * Math.sin(fraction * 4 * Math.PI);
            e.style.left = x + &quot;px&quot;; //在25毫秒后或在总时间的最后尝试再次运行函数
            //目的是为了产生每秒40帧的动画
            setTimeout(animate, Math.min(25, time - elapsed));
        } else { //否则，动画完成
            e.style.cssText = originalStyle //恢复原始样式
            if (oncomplete) oncomplete(e); //调用完成后的回调函数
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="原生JS实现CSS动画2"><a href="#原生JS实现CSS动画2" class="headerlink" title="原生JS实现CSS动画2"></a>原生JS实现CSS动画2</h2><pre><code>function fadeOut(e, oncomplete, time) {
    if (typeof e === &quot;string&quot;) e = document.getElementById(e);
    if (!time) time = 500; //使用Math.sqrt作为一个简单的“缓动函数”来创建动画
    //精巧的非线性：一开始淡出得比较快，然后缓慢了一些
    var ease = Math.sqrt;
    var start = (new Date()).getTime(); //注意：动画开始的时间
    animate(); //动画开始
    function animate() {
        var elapsed = (new Date()).getTime() - start; //消耗的时间
        var fraction = elapsed / time; //总时间的几分之几？
        if (fraction &lt; 1) { //如果动画未完成
            var opacity = 1 - ease(fraction); //计算元素的不透明度
            e.style.opacity = String(opacity); //设置在e上
            setTimeout(animate, //调度下一帧
                Math.min(25, time - elapsed));
        } else { //否则，动画完成
            e.style.opacity = &quot;0&quot;; //使e完全透明
            if (oncomplete) oncomplete(e); //调用完成后的回调函数
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿HTML5的classList属性"><a href="#仿HTML5的classList属性" class="headerlink" title="仿HTML5的classList属性"></a>仿HTML5的classList属性</h2><pre><code>/*
 *如果e有classList属性则返回它。否则，返回一个为e模拟DOMTokenList API的对象
 *返回的对象有contains()、add()、remove()、toggle()和toString()等方法
 *来检测和修改元素e的类集合。如果classList属性是原生支持的，
 *返回的类数组对象有length和数组索引属性。模拟DOMTokenList不是类数组对象，
 *但是它有一个toArray()方法来返回一个含元素类名的纯数组快照
 */
function classList(e) {
    if (e.classList) return e.classList; //如果e.classList存在，则返回它
    else return new CSSClassList(e); //否则，就伪造一个
}
//CSSClassList是一个模拟DOMTokenList的JavaScript类
function CSSClassList(e) {
    this.e = e;
} //如果e.className包含类名c则返回true否则返回false
CSSClassList.prototype.contains = function (c) { //检查c是否是合法的类名
    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)
        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //首先是常规检查
    var classes = this.e.className;
    if (!classes) return false; //e不含类名
    if (classes === c) return true; //e有一个完全匹配的类名
    //否则，把c自身看做一个单词，利用正则表达式搜索c
    //\b在正则表达式里代表单词的边界
    return classes.search(&quot;\\b&quot; + c + &quot;\\b&quot;) != -1;
}; //如果c不存在，将c添加到e.className中
CSSClassList.prototype.add = function (c) {
    if (this.contains(c)) return; //如果存在，什么都不做
    var classes = this.e.className;
    if (classes &amp;&amp; classes[classes.length - 1] != &quot;&quot;)
        c = &quot;&quot; + c; //如果需要加一个空格
    this.e.className += c; //将c添加到className中
}; //将在e.className中出现的所有c都删除
CSSClassList.prototype.remove = function (c) { //检查c是否是合法的类名
    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)
        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //将所有作为单词的c和多余的尾随空格全部删除
    var pattern = new RegExp(&quot;\\b&quot; + c + &quot;\\b\\s*&quot;, &quot;g&quot;);
    this.e.className = this.e.className.replace(pattern, &quot;&quot;);
}; //如果c不存在，将c添加到e.className中，并返回true
//否则，将在e.className中出现的所有c都删除，并返回false
CSSClassList.prototype.toggle = function (c) {
    if (this.contains(c)) { //如果e.className包含c
        this.remove(c); //删除它
        return false;
    } else { //否则
        this.add(c); //添加它
        return true;
    }
}; //返回e.className本身
CSSClassList.prototype.toString = function () {
    return this.e.className;
}; //返回在e.className中的类名
CSSClassList.prototype.toArray = function () {
    return this.e.className.match(/\b\w+\b/g) || [];
};
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询纯文本形式的内容"><a href="#查询纯文本形式的内容" class="headerlink" title="查询纯文本形式的内容"></a>查询纯文本形式的内容</h2><pre><code>/**
 *一个参数，返回元素的textContent或innerText
 *两个参数，用value参数的值设置元素的textContent或innerText
 */
function textContent(element, value) {
    var content = element.textContent; //检测textContent是否有定义
    if (value === undefined) { //没传递value，因此返回当前文本
        if (content !== undefined) return content;
        else return element.innerText;
    } else { //传递了value，因此设置文本
        if (content !== undefined) element.textContent = value;
        else element.innerText = value;
    }
}
</code></pre><p>textContent属性在除了IE的所有当前的浏览器中都支持。在IE中，可以用Element的innerText属性来代替。 <a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查找元素的后代中节点中的所有Text节点"><a href="#查找元素的后代中节点中的所有Text节点" class="headerlink" title="查找元素的后代中节点中的所有Text节点"></a>查找元素的后代中节点中的所有Text节点</h2><pre><code>//返回元素e的纯文本内容，递归进入其子元素
//该方法的效果类似于textContent属性
function textContent(e) {
    var child, type, s = &quot;&quot;; //s保存所有子节点的文本
    for (child = e.firstChild; child != null; child = child.nextSibling) {
        type = child.nodeType;
        if (type === 3 || type === 4) //Text和CDATASection节点
            s += child.nodeValue;
        else if (type === 1) //递归Element节点
            s += textContent(child);
    }
    return s;
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用innerHTML实现insertAdjacentHTML"><a href="#使用innerHTML实现insertAdjacentHTML" class="headerlink" title="使用innerHTML实现insertAdjacentHTML()"></a>使用innerHTML实现insertAdjacentHTML()</h2><pre><code>//本模块为不支持它的浏览器定义了Element.insertAdjacentHTML
//还定义了一些可移植的HTML插入函数，它们的名字比insertAdjacentHTML更符合逻辑：
//Insert.before()、Insert.after()、Insert.atStart()和Insert.atEnd()
var Insert = (function () { //如果元素有原生的insertAdjacentHTML，
    //在4个函数名更明了的HTML插入函数中使用它
    if (document.createElement(&quot;div&quot;).insertAdjacentHTML) {
        return {
            before: function (e, h) {
                e.insertAdjacentHTML(&quot;beforebegin&quot;, h);
            },
            after: function (e, h) {
                e.insertAdjacentHTML(&quot;afterend&quot;, h);
            },
            atStart: function (e, h) {
                e.insertAdjacentHTML(&quot;afterbegin&quot;, h);
            },
            atEnd: function (e, h) {
                e.insertAdjacentHTML(&quot;beforeend&quot;, h);
            }
        };
    }
    //否则，无原生的insertAdjacentHTML
    //实现同样的4个插入函数，并使用它们来定义insertAdjacentHTML
    //首先，定义一个工具函数，传入HTML字符串，返回一个DocumentFragment，
    //它包含了解析后的HTML的表示
    function fragment(html) {
        var elt = document.createElement(&quot;div&quot;); //创建空元素
        var frag = document.createDocumentFragment(); //创建空文档片段
        elt.innerHTML = html; //设置元素内容
        while (elt.firstChild) //移动所有的节点
            frag.appendChild(elt.firstChild); //从elt到frag
        return frag; //然后返回frag
    }
    var Insert = {
        before: function (elt, html) {
            elt.parentNode.insertBefore(fragment(html), elt);
        },
        after: function (elt, html) {
            elt.parentNode.insertBefore(fragment(html), elt.nextSibling);
        },
        atStart: function (elt, html) {
            elt.insertBefore(fragment(html), elt.firstChild);
        },
        atEnd: function (elt, html) {
            elt.appendChild(fragment(html));
        }
    }; //基于以上函数实现insertAdjacentHTML
    Element.prototype.insertAdjacentHTML = function (pos, html) {
        switch (pos.toLowerCase()) {
            case &quot;beforebegin&quot;:
                return Insert.before(this, html);
            case &quot;afterend&quot;:
                return Insert.after(this, html);
            case &quot;afterbegin&quot;:
                return Insert.atStart(this, html);
            case &quot;beforeend&quot;:
                return Insert.atEnd(this, html);
        }
    };
    return Insert; //最后返回4个插入函数
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><pre><code>/**
 *Drag.js：拖动绝对定位的HTML元素
 *
 *这个模块定义了一个drag()函数，它用于mousedown事件处理程序的调用
 *随后的mousemove事件将移动指定元素，mouseup事件将终止拖动
 *这些实现能同标准和IE两种事件模型一起工作
 *
 *参数：
 *
 *elementToDrag：接收mousedown事件的元素或某些包含元素
 *它必须是定位的元素,元素的样式必须是行内样式
 *它的style.left和style.top值将随着用户的拖动而改变
 *
 *event：mousedown事件对象
 **/
function drag(elementToDrag, event) { //初始鼠标位置，转换为文档坐标
    var startX = event.clientX;
    var startY = event.clientY; //在文档坐标下，待拖动元素的初始位置
    //因为elementToDrag是绝对定位的，
    //所以我们可以假设它的offsetParent就是文档的body元素
    var origX = parseFloat(elementToDrag.style.left);
    var origY = parseFloat(elementToDrag.style.top); //计算mousedown事件和元素左上角之间的距离
    //我们将它另存为鼠标移动的距离
    if (document.addEventListener) { //标准事件模型
        //在document对象上注册捕获事件处理程序
        document.addEventListener(&quot;mousemove&quot;, moveHandler, true);
        document.addEventListener(&quot;mouseup&quot;, upHandler, true);
    } else if (document.attachEvent) { //用于IE5～8的IE事件模型
        //在IE事件模型中，
        //捕获事件是通过调用元素上的setCapture()捕获它们
        elementToDrag.setCapture();
        elementToDrag.attachEvent(&quot;onmousemove&quot;, moveHandler);
        elementToDrag.attachEvent(&quot;onmouseup&quot;, upHandler); //作为mouseup事件看待鼠标捕获的丢失
        elementToDrag.attachEvent(&quot;onlosecapture&quot;, upHandler);
    }
    //我们处理了这个事件，不让任何其他元素看到它
    if (event.stopPropagation) event.stopPropagation(); //标准模型
    else event.cancelBubble = true; //IE
    //现在阻止任何默认操作
    if (event.preventDefault) event.preventDefault(); //标准模型
    else event.returnValue = false; //IE
    /**
     * 当元素正在被拖动时， 这就是捕获mousemove事件的处理程序
     *它用于移动这个元素 
     **/
    function moveHandler(e) {
        if (!e) e = window.event; //IE事件模型
        //移动这个元素到当前鼠标位置，
        //通过滚动条的位置和初始单击的偏移量来调整
        var targetLeft = e.clientX - startX + origX;
        var targetTop = e.clientY - startY + origY;
        var minLeft = 0;
        var minTop = 0;
        var maxLeft = (document.documentElement.clientWidth || document.body.clientWidth) - elementToDrag.offsetWidth;
        var maxTop = (document.documentElement.clientHeight || document.body.clientHeight) - elementToDrag.offsetHeight;
        targetLeft = targetLeft &gt; maxLeft ? maxLeft : (targetLeft &lt; minLeft ? minLeft : targetLeft);
        targetTop = targetTop &gt; maxTop ? maxTop : (targetTop &lt; minTop ? minTop : targetTop);
        elementToDrag.style.left = targetLeft + &quot;px&quot;;
        elementToDrag.style.top = targetTop + &quot;px&quot;;
        if (e.stopPropagation) e.stopPropagation(); //标准
        else e.cancelBubble = true; //IE
    }
    /**
     *这是捕获在拖动结束时发生的最终mouseup事件的处理程序
     **/
    function upHandler(e) {
        if (!e) e = window.event; //IE事件模型
        //注销捕获事件处理程序
        if (document.removeEventListener) { //DOM事件模型
            document.removeEventListener(&quot;mouseup&quot;, upHandler, true);
            document.removeEventListener(&quot;mousemove&quot;, moveHandler, true);
        } else if (document.detachEvent) { //IE 5+事件模型
            elementToDrag.detachEvent(&quot;onlosecapture&quot;, upHandler);
            elementToDrag.detachEvent(&quot;onmouseup&quot;, upHandler);
            elementToDrag.detachEvent(&quot;onmousemove&quot;, moveHandler);
            elementToDrag.releaseCapture();
        }
        //并且不让事件进一步传播
        if (e.stopPropagation) e.stopPropagation(); //标准模型
        else e.cancelBubble = true; //IE
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在谷歌地图上显示地理位置信息"><a href="#在谷歌地图上显示地理位置信息" class="headerlink" title="在谷歌地图上显示地理位置信息"></a>在谷歌地图上显示地理位置信息</h2><pre><code>//获取当前位置然后通过Google地图显示
//如果当前浏览器不支持地理位置API，则抛出一个错误
function getmap() { //检查是否支持地理位置API
    if (!navigator.geolocation) throw &quot;Geolocation not supported&quot;; //开始请求地理位置信息，
    navigator.geolocation.getCurrentPosition(setMapURL);
    function setMapURL(pos) { //从参数对象（pos）中获取位置信息
        var latitude = pos.coords.latitude; //经度
        var longitude = pos.coords.longitude; //纬度
        var accuracy = pos.coords.accuracy; //米
        var scale = 10; //比例
        //构造一个URL，用于跳转到Google地图
        var url = &quot;https://www.google.com/maps/@&quot; + latitude + &quot;,&quot; + longitude + &quot;,&quot; + scale + &quot;z&quot;; //设置一个大致的缩放级别
        location = url;
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用所有地理位置特性"><a href="#使用所有地理位置特性" class="headerlink" title="使用所有地理位置特性"></a>使用所有地理位置特性</h2><pre><code>//异步的获取我的位置，并在指定的元素中展示出来
function whereami(elt) { //将此对象作为第三个参数传递给getCurrentPosition()方法
    var options = { //设置为true，表示如果可以的话
        //获取高精度的位置信息（例如，通过GPS获取）
        //但是，要注意的是，这会影响电池寿命
        enableHighAccuracy: false, //可以近似：这是默认值
        //如果获取缓存过的位置信息就足够的话，可以设置此属性
        //默认值为0,表示强制检查新的位置信息
        maximumAge: 300000, //5分钟左后
        //愿意等待多长时间来获取位置信息？
        //默认值为无限长 [2] ，getCurrentPosition()方法永不超时
        timeout: 15000 //不要超过15秒
    };
    if (navigator.geolocation) //如果支持的话，就获取位置信息
        navigator.geolocation.getCurrentPosition(success, error, options);
    else
        elt.innerHTMl = &quot;Geolocation not supported in this browser&quot;; //当获取位置信息失败的时候，会调用此函数

    function error(e) { //error对象包含一些数字编码和文本消息，如下所示：
        //1:用户不允许分享他/她的位置信息
        //2:浏览器无法确定位置
        //3:发生超时
        elt.innerHTML = &quot;Geolocation error&quot; + e.code + &quot;:&quot; + e.message;
    }
    //当获取位置信息成功的时候，会调用此函数
    function success(pos) { //总是可以获取如下这些字段
        //但是要注意的是时间戳信息在outer对象中，而不在inner、coords对象中
        var msg = &quot;时间是&quot; +
            new Date(pos.timestamp).toLocaleString() + &quot;地理位置是&quot; +
            pos.coords.accuracy + &quot;米范围内经度是&quot; +
            pos.coords.latitude + &quot;纬度是&quot; +
            pos.coords.longitude + &quot;.&quot;; //如果设备还返回了海拔信息，则将其添加进去
        if (pos.coords.altitude) {
            msg += &quot;海拔是&quot; + pos.coords.altitude + &quot;±&quot; +
                pos.coords.altitudeAccuracy + &quot;千米.&quot;;
        }
        //如果设备还返回了速度和航向信息，也将它们添加进去
        if (pos.coords.speed) {
            msg += &quot;速度是&quot; +
                pos.coords.speed + &quot;m/s方向是&quot; +
                pos.coords.heading + &quot;.&quot;;
        }
        elt.innerHTML = msg; //显示所有的位置信息
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="优雅的图片翻转实现"><a href="#优雅的图片翻转实现" class="headerlink" title="优雅的图片翻转实现"></a>优雅的图片翻转实现</h2><pre><code>/**
 *优雅的图片翻转实现方式
 *
 *要创建图片翻转效果，将此模块引入到HTML文件中
 *然后在任意＜img＞元素上使用data-rollover属性来指定翻转图片的URL即可
 *如下所示:
 *
 *&lt;img src=&quot;normal_image.png &quot;data-rollover=&quot;rollover_image.png&quot;&gt;
 *
 */
function changeImage() { //所有处理逻辑都在一个匿名函数中:不定义任何符号
    //遍历所有的图片，查找data-rollover属性
    for (var i = 0; i &lt; document.images.length; i++) {
        var img = document.images[i];
        var rollover = img.getAttribute(&quot;data-rollover&quot;);
        if (!rollover) continue; //跳过没有data-rollover属性的图片
        //确保将翻转的图片缓存起来
        (new Image()).src = rollover; //定义一个属性来标识默认的图片URL
        img.setAttribute(&quot;data-rollout&quot;, img.src); //注册事件处理函数来创建翻转效果
        img.onmouseover = function () {
            this.src = this.getAttribute(&quot;data-rollover&quot;);
        };
        img.onmouseout = function () {
            this.src = this.getAttribute(&quot;data-rollout&quot;);
        };
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用canvas绘制多边形"><a href="#使用canvas绘制多边形" class="headerlink" title="使用canvas绘制多边形"></a>使用canvas绘制多边形</h2><pre><code>//定义一个以(x,y)为中心，半径为r的规则n边形,c可以通过调用画布getContext()方法得到
//每个顶点都是均匀分布在圆周上
//将第一个顶点放置在最上面，或者指定一定角度
//除非最后一个参数是true，否则顺时针旋转
function polygon(c, n, x, y, r, angle, counterclockwise) {
    angle = angle || 0;
    counterclockwise = counterclockwise || false;
    c.moveTo(x + r * Math.sin(angle), //从第一个顶点开始一条新的子路径
        y - r * Math.cos(angle)); //使用三角法计算位置
    var delta = 2 * Math.PI / n; //两个顶点之间的夹角
    for (var i = 1; i &lt; n; i++) { //循环剩余的每个顶点
        angle += counterclockwise ? -delta : delta; //调整角度
        c.lineTo(x + r * Math.sin(angle), //以下个顶点为端点添加线段
            y - r * Math.cos(angle));
    }
    c.closePath(); //将最后一个顶点和起点连接起来
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用canvas绘制雪花"><a href="#使用canvas绘制雪花" class="headerlink" title="使用canvas绘制雪花"></a>使用canvas绘制雪花</h2><pre><code>var deg = Math.PI / 180; //用于角度制到弧度制的转换
//在画布的上下文c中，以左下角的点(x,y)和边长len，绘制一个n级别的科赫雪花分形
function snowflake(c, n, x, y, len) {
    c.save(); //保存当前变换
    c.translate(x, y); //变换原点为起始点
    c.moveTo(0, 0); //从新的原点开始一条新的子路径
    leg(n); //绘制雪花的第一条边
    c.rotate(-120 * deg); //现在沿着逆时针方向旋转120 o
    leg(n); //绘制第二条边
    c.rotate(-120 * deg); //再次旋转
    leg(n); //画最后一条边
    c.closePath(); //闭合子路径
    c.restore(); //恢复初始的变换
    //绘制n级别的科赫雪花的一条边
    //此函数在画完一条边的时候就离开当前点，
    //然后通过坐标系变换将当前点又转换成(0,0,)
    //这意味着画完一条边之后可以很简单地调用rotate()进行旋转
    function leg(n) {
        c.save(); //保存当前坐标系变换
        if (n == 0) { //不需要递归的情况下:
            c.lineTo(len, 0); //就绘制一条水平线段
        } else { //递归情况下：绘制4条子边，类似这个样子： - \/ -
            c.scale(1 / 3, 1 / 3); //子边长度为原边长的1/3
            leg(n - 1); //递归第一条子边
            c.rotate(60 * deg); //顺时针旋转60 o
            leg(n - 1); //第二条子边
            c.rotate(-120 * deg); //逆时针旋转120 o
            leg(n - 1); //第三条子边
            c.rotate(60 * deg); //通过旋转回到初始状态
            leg(n - 1); //最后一条边
        }
        c.restore(); //恢复坐标系变换
        c.translate(len, 0); //但是通过转换使得边的结束点为(0,0)
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在Web-Worker中发起同步XMLHtttpRequest"><a href="#在Web-Worker中发起同步XMLHtttpRequest" class="headerlink" title="在Web Worker中发起同步XMLHtttpRequest"></a>在Web Worker中发起同步XMLHtttpRequest</h2><pre><code>//此文件会通过一个新的Worker()来载入，因此，它是运行在独立的线程中的，
//可以放心地使用同步XMLHttpRequest API
//消息是URL数组的形式。以字符串形式同步获取每个URL指定的内容，
//并将这些字符串数组传递回去。
onmessage = function (e) {
    var urls = e.data; //输入：要获取的URL
    var contents = []; //输出：URL指定的内容
    for (var i = 0; i &lt; urls.length; i++) {
        var url = urls[i]; //每个URL
        var xhr = new XMLHttpRequest(); //开始一个HTTP请求
        xhr.open(&quot;GET&quot;, url, false); //false则表示进行同步请求
        xhr.send(); //阻塞住，一直到响应完成
        if (xhr.status !== 200) //如果请求失败则抛出错误
            throw Error(xhr.status + &quot; &quot; + xhr.statusText + &quot;: &quot; + url);
        contents.push(xhr.responseText); //否则，存储通过URL获取得到的内容
    }
    //最后，将这些URL内容以数组的形式传递回主线程
    postMessage(contents);
}
</code></pre><p>善于利用JS中的小技巧，不仅可以使代码更加简洁，而且逼格更高。</p>
<h2 id="使用-模拟Boolean-函数"><a href="#使用-模拟Boolean-函数" class="headerlink" title="使用!!模拟Boolean()函数"></a>使用!!模拟Boolean()函数</h2><p>原理：逻辑非操作一个数据对象时，会先将数据对象转换为布尔值，然后取反，两个!!重复取反，就实现了转换为布尔值的效果。</p>
<h2 id="使用一元加-模拟Number-函数"><a href="#使用一元加-模拟Number-函数" class="headerlink" title="使用一元加(+)模拟Number()函数"></a>使用一元加(+)模拟Number()函数</h2><p>原理：对非数值类型的数据使用一元加(+)，会起到与Number()函数相同的效果。</p>
<p>null转换为0</p>
<p>undefined转换为NaN</p>
<p>false转换为0，true转换为1</p>
<p>对于字符串： </p>
<p>空字串转换为0</p>
<p>含有数字或者浮点数或者十六进制格式的数据(11, 0.3, 0xfe等)，转换为相应的数值</p>
<p>含有其他格式字符，无法转换为数值的字符串，转换为NaN</p>
<p>对于对象，先调用valueOf()方法，在转换，若结果为NaN，那么再调用toString()方法，之后再转换</p>
<h2 id="使用逻辑与-amp-amp-进行短路操作"><a href="#使用逻辑与-amp-amp-进行短路操作" class="headerlink" title="使用逻辑与(&amp;&amp;)进行短路操作"></a>使用逻辑与(&amp;&amp;)进行短路操作</h2><pre><code>if(connected){
    login();
}
</code></pre><p>以上代码可以简写为:</p>
<p><code>connected &amp;&amp; login();</code></p>
<p>也可用这种方法来检查对象中是否拥有某个属性</p>
<pre><code>user &amp;&amp; user.name
</code></pre><p>原理：逻辑与(&amp;&amp;)会首先对第一个操作数进行求值，只有求值结果为true时才会对第二个操作数求值。connected &amp;&amp; login()中，若判断connected不为true,则不再进行下一步操作。<br>所谓的短路操作即第一个操作数可以决定结果，则不再对第二个操作数进行求值。</p>
<h2 id="使用逻辑或-设置默认值"><a href="#使用逻辑或-设置默认值" class="headerlink" title="使用逻辑或(||)设置默认值"></a>使用逻辑或(||)设置默认值</h2><p>逻辑或(||)也属于短路操作，即当第一个操作数可以决定结果时，不再对第二个操作数进行求值。利用这个特点，我们可以给赋值语句设置默认值。只有当第一个操作数为null或者undefined时，才会把第二个操作数赋值给目标。</p>
<pre><code>function User(name, age){
    this.name = name || &quot;Liming&quot;;
}
</code></pre><p>上述代码中，如果函数中没有传入name参数，name的值为undefined，那么就会给this.name赋值为”Liming”。<br>ES6中可以为函数设置默认值，所以这种方法可能要成为过去式，但是其他地方还是很有用的。<br>ES6 写法 简洁了许多</p>
<pre><code>let User = (name=&quot;Liming&quot;, age) =&gt; { }
</code></pre><h2 id="获取数组最后n个元素"><a href="#获取数组最后n个元素" class="headerlink" title="获取数组最后n个元素"></a>获取数组最后n个元素</h2><p>可以使用以下代码获取数组中最后n个元素</p>
<pre><code>var array = [1, 2, 3, 4, 5, 6];
console.log(array.slice(-1));  //[6]
console.log(array.slice(-2));  //[5, 6]
</code></pre><p>原理:Array.prototype.slice(begin,end)可以用来裁剪数组，第二个参数的默认值是数组的长度值。若值传入一个参数，则会返回从指定索引开始到数组结尾的所有值。<br>而slice()方法还可以接收负值，当传入负值时，会自动加上数组的长度值使其转换为正值，于是便得到了最后的n个值。</p>
<h2 id="合并大数组"><a href="#合并大数组" class="headerlink" title="合并大数组"></a>合并大数组</h2><p>常用的合并数组的方式是使用Array.concat()函数。该函数会创建一个新数组，将两个数组连接起来存储到新数组中，这会大量消耗内存。可以使用Array.push.apply(arr1, arr2)，它不会创建新数组，而是将第二个数组合并到第一个数组中，以减少内存的消耗。</p>
<pre><code>var a = [1,2];
var b = [3,4];
console.log(a.push.apply(a, b));      // [1,2,3,4]
//或者
Array.prototype.push.apply(a, b);      // a变成了[1,2,3,4]
console.log(a); //[1,2,3,4]
</code></pre><p>原理: Array.push()是在数组的末尾增加元素，但是如果使用a.push(b)会把整个数组b当作一个元素添加到数组a中。<br>而apply()方法，则允许将某个方法的参数以数组的形式传入，所以起到了将数组b中的元素追加到数组a中的效果。</p>
<h2 id="NodeList转换为数组"><a href="#NodeList转换为数组" class="headerlink" title="NodeList转换为数组"></a>NodeList转换为数组</h2><p>使用document.querySelectorAll(‘div’)返回的是NodeList对象，虽然它很像数组，但是并不能使用诸如sort()，filter()等方法。你可以将其转换为真正的数组。</p>
<pre><code>var eles = document.querySelectorAll(&apos;p&apos;);  //NodeList
var arrayElements = [].slice.call(eles);       //转化为数组
// 或者
var arrayElements = Array.prototype.slice.call(eles);
// 或者
var arrayElements = Array.from(eles); 
</code></pre><p>原理:</p>
<p>[].slice.call(eles):<br>首先创建了一个空数组[]，然后调用他的slice()方法，但是在slice()方法的执行中，把this对象指向了eles,所以会对eles进行裁减，由于对slice()方法没有传入参数，所以相当于slice(0,eles.length),会按照元长度返回一个数组。</p>
<p>Array.prototype.slice.call(eles): 原理与上面相似，只不过这次没有创建空数组，而是直接使用了原型中的方法 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/JavaScript进阶提高必读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/JavaScript进阶提高必读/" itemprop="url">JavaScript进阶提高必读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T22:40:40+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="冴羽写博客的地方"><a href="#冴羽写博客的地方" class="headerlink" title="冴羽写博客的地方"></a><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">冴羽写博客的地方</a></h2><p><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/17" target="_blank" rel="noopener">JavaScript深入系列15篇正式完结！</a></p>
<h2 id="深入系列目录"><a href="#深入系列目录" class="headerlink" title="深入系列目录"></a>深入系列目录</h2><ol>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScirpt深入之从原型到原型链</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript深入之执行上下文栈</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript深入之变量对象</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">JavaScript深入之作用域链</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">JavaScript深入之从ECMAScript规范解读this</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">JavaScript深入之执行上下文</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">JavaScript深入之闭包</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/10" target="_blank" rel="noopener">JavaScript深入之参数按值传递</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">JavaScript深入之类数组对象与arguments</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/15" target="_blank" rel="noopener">JavaScript深入之创建对象的多种方式以及优缺点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">JavaScript深入之继承的多种方式以及优缺点</a></li>
</ol>
<h2 id="专题系列目录"><a href="#专题系列目录" class="headerlink" title="专题系列目录"></a>专题系列目录</h2><ol>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">JavaScript专题之跟着underscore学防抖</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">JavaScript专题之跟着underscore学节流</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/27" target="_blank" rel="noopener">JavaScript专题之数组去重</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">JavaScript专题之类型判断(上)</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/30" target="_blank" rel="noopener">JavaScript专题之类型判断(下)</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener">JavaScript专题之深浅拷贝</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/33" target="_blank" rel="noopener">JavaScript专题之从零实现jQuery的extend</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/35" target="_blank" rel="noopener">JavaScript专题之如何求数组的最大值和最小值</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/36" target="_blank" rel="noopener">JavaScript专题之数组扁平化</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/37" target="_blank" rel="noopener">JavaScript专题之学underscore在数组中查找指定元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/40" target="_blank" rel="noopener">JavaScript专题之jQuery通用遍历方法each的实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/41" target="_blank" rel="noopener">JavaScript专题之如何判断两个对象相等</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript专题之函数柯里化</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/43" target="_blank" rel="noopener">JavaScript专题之偏函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/44" target="_blank" rel="noopener">JavaScript专题之惰性函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/45" target="_blank" rel="noopener">JavaScript专题之函数组合</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/46" target="_blank" rel="noopener">JavaScript专题之函数记忆</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/49" target="_blank" rel="noopener">JavaScript专题之递归</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/51" target="_blank" rel="noopener">JavaScript专题之乱序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/52" target="_blank" rel="noopener">JavaScript专题之解读 v8 排序源码</a></li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>深入系列文章部分是有先后顺序的，按照目录结构顺序阅读效果最好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/浅谈-instanceof-和-typeof-的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/浅谈-instanceof-和-typeof-的实现原理/" itemprop="url">浅谈 instanceof 和 typeof 的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T13:17:32+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="typeof-实现原理"><a href="#typeof-实现原理" class="headerlink" title="typeof 实现原理"></a>typeof 实现原理</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number</code>, <code>string</code>, <code>object</code>, <code>boolean</code>, <code>function</code>, <code>undefined</code>,<code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code> 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如👉</p>
<pre><code>let s =newString(&apos;abc&apos;);
typeof s ===&apos;object&apos;// true
s instanceofString// true
</code></pre><p>要想判断一个数据具体是哪一种 object 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p>
<p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p>
<p>其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">000：对象</span><br><span class="line"></span><br><span class="line">010：浮点数</span><br><span class="line"></span><br><span class="line">100：字符串</span><br><span class="line"></span><br><span class="line">110：布尔</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1：整数</li>
</ul>
<p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p>
<p><code>null</code>：所有机器码均为0</p>
<p><code>undefined</code>：用 −2^30 整数来表示</p>
<p>所以，<code>typeof</code> 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为0，因此直接被当做了对象来看待。</p>
<p>然而用 <code>instanceof</code> 来判断的话👉</p>
<pre><code>nullinstanceofnull// TypeError: Right-hand side of &apos;instanceof&apos; is not an object
</code></pre><p><code>null</code> 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。</p>
<p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括<code>symbol</code>），避免对 null 的判断。</p>
<p>还有一个不错的判断类型的方法，就是<strong><font color="#dd0000">Object.prototype.toString</font></strong>，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p>
<pre><code>Object.prototype.toString.call(1)// &quot;[object Number]&quot;
Object.prototype.toString.call(&apos;hi&apos;)// &quot;[object String]&quot;
Object.prototype.toString.call({a:&apos;hi&apos;})// &quot;[object Object]&quot;
Object.prototype.toString.call([1,&apos;a&apos;])// &quot;[object Array]&quot;
Object.prototype.toString.call(true)// &quot;[object Boolean]&quot;
Object.prototype.toString.call(()=&gt;{})// &quot;[object Function]&quot;
Object.prototype.toString.call(null)// &quot;[object Null]&quot;
Object.prototype.toString.call(undefined)// &quot;[object Undefined]&quot;
Object.prototype.toString.call(Symbol(1))// &quot;[object Symbol]&quot;
</code></pre><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 <code>instanceof</code> 来判断对象的具体类型，其实 <code>instanceof</code> 主要的作用就是判断一个实例是否属于某种类型</p>
<pre><code>let person =function(){
}
let nicole =new person()
nicole instanceof person // true
</code></pre><p>当然，<code>instanceof</code> 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p>
<pre><code>let person =function(){
}
let programmer =function(){
}
programmer.prototype =new person()
let nicole =new programmer()
nicole instanceof person // true
nicole instanceof programmer // true
</code></pre><p>这是 <code>instanceof</code> 的用法，但是 <code>instanceof</code> 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p>
<pre><code>function new_instance_of(leftVaule, rightVaule){
    let rightProto = rightVaule.prototype;// 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__;// 取左表达式的__proto__值
    while(true){
        if(leftVaule ===null){
            returnfalse;    
        }
        if(leftVaule === rightProto){
            returntrue;    
        }
        leftVaule = leftVaule.__proto__ 
    }
}
</code></pre><p><font color="#dd0000">其实 <code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。<br></font><br><br>看几个很有趣的例子</p>
<pre><code>functionFoo(){
}
Object instanceof Object// true
Function instanceof Function// true
Function instanceof Object// true
Foo instanceof Foo// false
Foo instanceof Object// true
Foo instanceof Function// true
</code></pre><p>要想全部理解 <code>instanceof</code> 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。</p>
<p>关于原型继承的原理，我简单用一张图来表示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/meG6Vo0MevjCzDE6dwt2qtltaDsSluC9M8KmmeZsLSJnFTgdTtcCRToR3zWJFYicViaUlvyAGdfwEzADj8Jk8kzQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""><br>我们知道每个 JavaScript 对象均有一个隐式的 <code>__proto__</code> 原型属性，而显式的原型属性是 <code>prototype</code>，只有 <code>Object.prototype.__proto__</code> 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 <code>instanceof</code> 使用的例子。</p>
<p><code>Object instanceof Object</code></p>
<p>由图可知，Object 的 <code>prototype</code> 属性是 <code>Object.prototype</code>, 而由于 Object 本身是一个函数，由 Function 所创建，所以 <code>Object.__proto__</code> 的值是 <code>Function.prototype</code>，而 <code>Function.prototype</code> 的 <code>__proto__</code> 属性是 <code>Object.prototype</code>，所以我们可以判断出，<code>Object instanceof Object</code> 的结果是 true 。用代码简单的表示一下</p>
<pre><code>leftValue =Object.__proto__ =Function.prototype;
rightValue =Object.prototype;
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true
</code></pre><p><code>Function instanceof Function</code> 和 <code>Function instanceof Object</code> 的运行过程与 <code>Object instanceof Object</code> 类似，故不再详说。</p>
<p><code>Foo instanceof Foo</code></p>
<p>Foo 函数的 <code>prototype</code> 属性是 <code>Foo.prototype</code>，而 Foo 的 <code>__proto__</code> 属性是 <code>Function.prototype</code>，由图可知，Foo 的原型链上并没有 <code>Foo.prototype</code> ，因此 <code>Foo instanceof Foo</code> 也就返回 false 。</p>
<p>我们用代码简单的表示一下</p>
<pre><code>leftValue =Foo, rightValue =Foo
leftValue =Foo.__proto =Function.prototype
rightValue =Foo.prototype
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue != rightValue
leftValue =Object.prototype =null
// 第三次判断
leftValue ===null
// 返回 false
</code></pre><p><code>Foo instanceof Object</code></p>
<pre><code>leftValue =Foo, rightValue =Object
leftValue =Foo.__proto__ =Function.prototype
rightValue =Object.prototype
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true 
</code></pre><p><code>Foo instanceof Function</code></p>
<pre><code>leftValue =Foo, rightValue =Function
leftValue =Foo.__proto__ =Function.prototype
rightValue =Function.prototype
// 第一次判断
leftValue === rightValue
// 返回 true 
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 <code>null</code> 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/你可能会忽略的vue-router技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/你可能会忽略的vue-router技巧/" itemprop="url">你可能会忽略的vue-router技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T12:50:52+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="说到Vue权限控制，你可能会第一个想到"><a href="#说到Vue权限控制，你可能会第一个想到" class="headerlink" title="说到Vue权限控制，你可能会第一个想到"></a>说到Vue权限控制，你可能会第一个想到</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by superman on 17/2/16.</span><br><span class="line"> * http配置</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import store from &apos;./store/store&apos;</span><br><span class="line">import * as types from &apos;./store/types&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">// axios 配置</span><br><span class="line">axios.defaults.timeout = 5000;</span><br><span class="line">axios.defaults.baseURL = &apos;https://api.github.com&apos;;</span><br><span class="line"></span><br><span class="line">// http request 拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        if (store.state.token) &#123;</span><br><span class="line">            config.headers.Authorization = `token $&#123;store.state.token&#125;`;</span><br><span class="line">        &#125;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">// http response 拦截器</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        if (error.response) &#123;</span><br><span class="line">            switch (error.response.status) &#123;</span><br><span class="line">                case 401:</span><br><span class="line">                    // 401 清除token信息并跳转到登录页面</span><br><span class="line">                    store.commit(types.LOGOUT);</span><br><span class="line">                    router.replace(&#123;</span><br><span class="line">                        path: &apos;login&apos;,</span><br><span class="line">                        query: &#123;redirect: router.currentRoute.fullPath&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // console.log(JSON.stringify(error));//console : Error: Request failed with status code 402</span><br><span class="line">        return Promise.reject(error.response.data)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">export default axios;</span><br></pre></td></tr></table></figure>
<h3 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    if (to.path == &apos;/login&apos;) &#123;</span><br><span class="line">         //清除token</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">    let token = get(&apos;token&apos;);   //获取token</span><br><span class="line">    if (!token &amp;&amp; to.path != &apos;/login&apos;) &#123;</span><br><span class="line">        next(&#123; path: &apos;/login&apos; &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="但上面的只能对登录拦截-跳转拦截，不能控制user权限，最好的方式是动态注入路由addRoutes"><a href="#但上面的只能对登录拦截-跳转拦截，不能控制user权限，最好的方式是动态注入路由addRoutes" class="headerlink" title="但上面的只能对登录拦截,跳转拦截，不能控制user权限，最好的方式是动态注入路由addRoutes"></a>但上面的只能对登录拦截,跳转拦截，不能控制user权限，最好的方式是动态注入路由<strong><font color="#dd0000">addRoutes</font></strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import router from &apos;./router&apos;</span><br><span class="line">router.addRoutes(routes)</span><br><span class="line">或者</span><br><span class="line">this.$router.addRoutes(routers)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/Vue手势库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/Vue手势库/" itemprop="url">Vue手势库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T12:48:23+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">function vueTouch(el, binding, type) &#123;</span><br><span class="line">	var _this = this;</span><br><span class="line">	this.obj = el;</span><br><span class="line">	this.binding = binding;</span><br><span class="line">	this.touchType = type;</span><br><span class="line">	this.vueTouches = &#123;</span><br><span class="line">		x: 0,</span><br><span class="line">		y: 0</span><br><span class="line">	&#125;;</span><br><span class="line">	this.vueMoves = true;</span><br><span class="line">	this.vueLeave = true;</span><br><span class="line">	this.longTouch = true;</span><br><span class="line"></span><br><span class="line">	this.vueCallBack = typeof(binding.value) == &quot;object&quot; ? binding.value.fn : binding.value;</span><br><span class="line"></span><br><span class="line">	this.obj.addEventListener(&quot;touchstart&quot;, function(e) &#123;</span><br><span class="line">		_this.start(e);</span><br><span class="line">	&#125;, false);</span><br><span class="line"></span><br><span class="line">	this.obj.addEventListener(&quot;touchmove&quot;, function(e) &#123;</span><br><span class="line">		_this.move(e);</span><br><span class="line">	&#125;, false);</span><br><span class="line"></span><br><span class="line">	this.obj.addEventListener(&quot;touchend&quot;, function(e) &#123;</span><br><span class="line">		_this.end(e);</span><br><span class="line">	&#125;, false);</span><br><span class="line">&#125;;</span><br><span class="line">vueTouch.prototype = &#123;</span><br><span class="line">	start(e) &#123;</span><br><span class="line">		this.vueMoves = true;</span><br><span class="line">		this.vueLeave = true;</span><br><span class="line">		this.longTouch = true;</span><br><span class="line">		this.vueTouches = &#123;</span><br><span class="line">			x: e.changedTouches[0].pageX,</span><br><span class="line">			y: e.changedTouches[0].pageY</span><br><span class="line">		&#125;;</span><br><span class="line">		this.time = setTimeout(function() &#123;</span><br><span class="line">			if(this.vueLeave &amp;&amp; this.vueMoves) &#123;</span><br><span class="line">				this.touchType == &quot;longtap&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">				this.longTouch = false;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;.bind(this), 1000);</span><br><span class="line">	&#125;,</span><br><span class="line">	end(e) &#123;</span><br><span class="line">		var disX = e.changedTouches[0].pageX - this.vueTouches.x;</span><br><span class="line">		var disY = e.changedTouches[0].pageY - this.vueTouches.y;</span><br><span class="line">		clearTimeout(this.time);</span><br><span class="line">		if(Math.abs(disX) &gt; 10 || Math.abs(disY) &gt; 100) &#123;</span><br><span class="line">			this.touchType == &quot;swipe&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">			if(Math.abs(disX) &gt; Math.abs(disY)) &#123;</span><br><span class="line">				if(disX &gt; 10) &#123;</span><br><span class="line">					this.touchType == &quot;swiperight&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">				&#125;;</span><br><span class="line">				if(disX &lt; -10) &#123;</span><br><span class="line">					this.touchType == &quot;swipeleft&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				if(disY &gt; 10) &#123;</span><br><span class="line">					this.touchType == &quot;swipedown&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">				&#125;;</span><br><span class="line">				if(disY &lt; -10) &#123;</span><br><span class="line">					this.touchType == &quot;swipeup&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if(this.longTouch &amp;&amp; this.vueMoves) &#123;</span><br><span class="line">				this.touchType == &quot;tap&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">				this.vueLeave = false</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;,</span><br><span class="line">	move(e) &#123;</span><br><span class="line">		this.vueMoves = false;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.directive(&quot;tap&quot;, &#123;</span><br><span class="line">	bind: function(el, binding) &#123;</span><br><span class="line">		new vueTouch(el, binding, &quot;tap&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swipe&quot;, &#123;</span><br><span class="line">	bind: function(el, binding) &#123;</span><br><span class="line">		new vueTouch(el, binding, &quot;swipe&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swipeleft&quot;, &#123;</span><br><span class="line">	bind: function(el, binding) &#123;</span><br><span class="line">		new vueTouch(el, binding, &quot;swipeleft&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swiperight&quot;, &#123;</span><br><span class="line">	bind: function(el, binding) &#123;</span><br><span class="line">		new vueTouch(el, binding, &quot;swiperight&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swipedown&quot;, &#123;</span><br><span class="line">	bind: function(el, binding) &#123;</span><br><span class="line">		new vueTouch(el, binding, &quot;swipedown&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swipeup&quot;, &#123;</span><br><span class="line">	bind: function(el, binding) &#123;</span><br><span class="line">		new vueTouch(el, binding, &quot;swipeup&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;longtap&quot;, &#123;</span><br><span class="line">	bind: function(el, binding) &#123;</span><br><span class="line">		new vueTouch(el, binding, &quot;longtap&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html id=&quot;html&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">		&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;style&gt;</span><br><span class="line">			.box &#123;</span><br><span class="line">				width: 250px;</span><br><span class="line">				height: 250px;</span><br><span class="line">				background-color: red;</span><br><span class="line">				color: #FFFFFF;</span><br><span class="line">				text-align: center;</span><br><span class="line">				line-height: 250px;</span><br><span class="line">				font-size: 30px;</span><br><span class="line">				position: absolute;</span><br><span class="line">				margin: auto;</span><br><span class="line">				left: 0;</span><br><span class="line">				right: 0;</span><br><span class="line">				top: 0;</span><br><span class="line">				bottom: 0;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">		&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue-touch.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;app&quot; class=&quot;box&quot; v-tap=&quot;&#123;fn:vuetap,name:&apos;点击&apos;&#125;&quot; v-longtap=&quot;&#123;fn:vuetap,name:&apos;长按&apos;&#125;&quot; v-swipeleft=&quot;&#123;fn:vuetap,name:&apos;左滑&apos;&#125;&quot; v-swiperight=&quot;&#123;fn:vuetap,name:&apos;右滑&apos;&#125;&quot; v-swipeup=&quot;&#123;fn:vuetap,name:&apos;上滑&apos;&#125;&quot; v-swipedown=&quot;&#123;fn:vuetap,name:&apos;下滑&apos;&#125;&quot;&gt;</span><br><span class="line">			&#123;&#123; name &#125;&#125;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;!--</span><br><span class="line">	vuetouch为函数名，如没有参数，可直接写函数名,比如：v-tap=&quot;vuetap&quot;</span><br><span class="line">	如果有参数以对象形式传，fn 为函数名</span><br><span class="line">--&gt;</span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			kim = new Vue(&#123;</span><br><span class="line">				el: &quot;#app&quot;,</span><br><span class="line">				data: &#123;</span><br><span class="line">					name: &quot;开始&quot;</span><br><span class="line">				&#125;,</span><br><span class="line">				methods: &#123;</span><br><span class="line">					vuetap: function(s, e) &#123;</span><br><span class="line">						console.log(e)</span><br><span class="line">						this.name = s.name;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/async-await-小技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/async-await-小技巧/" itemprop="url">async/await 小技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T11:58:49+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="async-await-小技巧"><a href="#async-await-小技巧" class="headerlink" title="async/await 小技巧"></a>async/await 小技巧</h1><h2 id="sleep-函数"><a href="#sleep-函数" class="headerlink" title="sleep 函数"></a>sleep 函数</h2><p>以前只接使用 <code>setTimeout</code> 和回调函数实现一个 <code>sleep</code> 会有很多的副作用，用起来很不方便。</p>
<p>所以让 <code>setTimeout</code> 搭配使用 <code>async/await</code></p>
<pre><code>constsleep=delay=&gt; {
  returnnewPromise(resolve=&gt; {
    setTimeout(resolve, delay)
  })
}

constfn=async_=&gt; {
  console.log(&apos;starting....&apos;)
  awaitsleep(1000)
  console.log(&apos;after sleeping for 1 second&apos;)
}
</code></pre><h2 id="搭配-map-函数"><a href="#搭配-map-函数" class="headerlink" title="搭配 map() 函数"></a>搭配 map() 函数</h2><p>在 <code>map</code> 中引入异步处理:</p>
<pre><code>constarr= [1,2,3,4,5]
constasyncFn=data=&gt; {
  // 异步处理函数
}

constresults=arr.map(asyncnum=&gt; {
  awaitasyncFn(num)
  return++num
})

console.log(results)
</code></pre><p>代码执行后的结果 <code>[Promise, Promise, Promise, Promise, Promise]</code> 而且 <code>map</code> 函数并不会等异步函数 <code>asyncFn</code> 执行完毕后再返回结果</p>
<p>既然 <code>async</code> 执行后会返回一个 <code>Promise</code> 对象，所以可以通过 <code>Promise.all</code> 的状态来判断异步函数的状态:</p>
<pre><code>constarr= [1,2,3,4,5]
constasyncFn=data=&gt; {
  // 异步处理函数
}
constp=arr.map(asyncnum=&gt; {
  awaitasyncFn(num)
  return++num
})

Promise.all(p).then(results=&gt; {
  console.log(results)
})
</code></pre><p>这样就能正常返回结果 <code>[2, 3, 4, 5, 6]</code></p>
<h2 id="使用-await-代替-then-函数"><a href="#使用-await-代替-then-函数" class="headerlink" title="使用 await 代替 then() 函数"></a>使用 await 代替 then() 函数</h2><p>上面的例子最后使用了 <code>Promise.all</code>  还是回到了使用回调函数的方式</p>
<p>这个也很好解决，只需要在外层再加一个 <code>async</code> 函数</p>
<pre><code>constmain=async_=&gt; {
  constresults=awaitPromise.all(arr.map(num=&gt; {
    awaitasyncFn()
    return++num
  }))
  console.log(results)
}

main()
</code></pre><h2 id="搭配-reduce-函数"><a href="#搭配-reduce-函数" class="headerlink" title="搭配 reduce() 函数"></a>搭配 reduce() 函数</h2><p>通过引入 <code>async/await</code> 可以把 <code>reduce</code> 扩展成一个按顺序执行异步函数的工具</p>
<p><code>reduce</code> 用起来很简单:</p>
<pre><code>constarr= [1,2,3,4,5]
constresult=arr.reduce((prev, next) =&gt; {
  return prev+next
}, 0)

console.log(result)
</code></pre><p>像 <code>map</code> 函数一样引入 <code>async/await</code> :</p>
<pre><code>constarr= [1,2,3,4,5]
constmain=async_=&gt; {
  constresult=awaitarr.reduce(async (prev, next) =&gt; {
    consttmp=await prev
    return tmp + next
  }, Promise.resolve(0))

  console.log(result)
}

main()
</code></pre><p>而且还可以在 <code>reduce</code> 内部加入异步函数:</p>
<pre><code>constarr= [1,2,3,4,5]
constmain=async_=&gt; {
  constresult=awaitarr.reduce(async (prev, next) =&gt; {
    consttmp=await prev

    // 异步处理 暂停1sawaitsleep(1000)
    console.log(tmp + next)

    return tmp + next
  }, Promise.resolve(0))
}

main()
</code></pre><p>上述代码会每隔一秒依次打出 1 3 6 10 15</p>
<p>参考自</p>
<blockquote>
<p><a href="http://2ality.com/2016/10/async-function-tips.html" target="_blank" rel="noopener">http://2ality.com/2016/10/async-function-tips.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/Event-Loop-必知必会（六道题）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/Event-Loop-必知必会（六道题）/" itemprop="url">Event Loop 必知必会（六道题）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T11:48:09+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直想写一篇关于 Event Loop 的文章，前不久发现 CNode 上有位同学写了一篇原理分析的<a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/5a9108d78d6e16e56bb80882%235a98d9a2ce1c90bc44c445af" target="_blank" rel="noopener">文章</a>很详细，这里我就不献丑了。本文就拿出六道题来补充一下，放出一张我认为非常直观的图。<br><img src="https://pic4.zhimg.com/v2-3a59c624e6ff95a7e8c5a23c979f5abe_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3a59c624e6ff95a7e8c5a23c979f5abe_hd.jpg" alt=""><br>绿色小块是 macrotask（宏任务），macrotask 中间的粉红箭头是 microtask（微任务）。</p>
<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><pre><code>setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate
setTimeout
</code></pre><p>或者：</p>
<pre><code>setTimeout
setImmediate
</code></pre><p>为什么结果不确定呢？</p>
<p>解释：setTimeout/setInterval 的第二个参数取值范围是：[1, 2^31 - 1]，如果超过这个范围则会初始化为 1，即 setTimeout(fn, 0) === setTimeout(fn, 1)。我们知道 setTimeout 的回调函数在 timer 阶段执行，setImmediate 的回调函数在 check 阶段执行，event loop 的开始会先检查 timer 阶段，但是在开始之前到 timer 阶段会消耗一定时间，所以就会出现两种情况：</p>
<ol>
<li>timer 前的准备时间超过 1ms，满足  loop-&gt;time &gt;= 1，则执行 timer 阶段（setTimeout）的回调函数</li>
<li>timer 前的准备时间小于 1ms，则先执行 check 阶段（setImmediate）的回调函数，下一次 event loop 执行 timer 阶段（setTimeout）的回调函数</li>
</ol>
<p>再看个例子：</p>
<pre><code>setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})conststart=Date.now()while(Date.now()-start&lt;10);
</code></pre><p>运行结果一定是：</p>
<pre><code>setTimeout
setImmediate
</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><pre><code>constfs=require(&apos;fs&apos;)fs.readFile(__filename,()=&gt;{setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate
setTimeout
</code></pre><p>解释：fs.readFile 的回调函数执行完后：</p>
<ol>
<li>注册 setTimeout 的回调函数到 timer 阶段</li>
<li>注册 setImmediate 的回调函数到 check 阶段</li>
<li>event loop 从 pool 阶段出来继续往下一个阶段执行，恰好是 check 阶段，所以 setImmediate 的回调函数先执行</li>
<li>本次 event loop 结束后，进入下一次 event loop，执行 setTimeout 的回调函数</li>
</ol>
<p>所以，在 I/O Callbacks 中注册的 setTimeout 和 setImmediate，永远都是 setImmediate 先执行。</p>
<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><pre><code>setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)process.nextTick(functiontick(){process.nextTick(tick)})
</code></pre><p>运行结果：setInterval 永远不会打印出来。</p>
<p>解释：process.nextTick 会无限循环，将 event loop 阻塞在 microtask 阶段，导致 event loop 上其他 macrotask 阶段的回调函数没有机会执行。</p>
<p>解决方法通常是用 setImmediate 替代 process.nextTick，如下：</p>
<pre><code>setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)setImmediate(functionimmediate(){setImmediate(immediate)})
</code></pre><p>运行结果：每 100ms 打印一次 setInterval。</p>
<p>解释：process.nextTick 内执行 process.nextTick 仍然将 tick 函数注册到当前 microtask 的尾部，所以导致 microtask 永远执行不完； setImmediate 内执行 setImmediate 会将 immediate 函数注册到下一次 event loop 的 check 阶段，而不是当前正在执行的 check 阶段，所以给了 event loop 上其他 macrotask 执行的机会。</p>
<p>再看个例子：</p>
<pre><code>setImmediate(()=&gt;{console.log(&apos;setImmediate1&apos;)setImmediate(()=&gt;{console.log(&apos;setImmediate2&apos;)})process.nextTick(()=&gt;{console.log(&apos;nextTick&apos;)})})setImmediate(()=&gt;{console.log(&apos;setImmediate3&apos;)})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate1
setImmediate3
nextTick
setImmediate2
</code></pre><p>注意：并不是说 setImmediate 可以完全替代 process.nextTick，process.nextTick 在特定场景下还是无法被替代的，比如我们就想将一些操作放到最近的 microtask 里执行。</p>
<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><pre><code>constpromise=Promise.resolve().then(()=&gt;{returnpromise})promise.catch(console.error)
</code></pre><p>运行结果：</p>
<pre><code>TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
    at &lt;anonymous&gt;
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3
</code></pre><p>解释：promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码会导致死循环，类似前面提到的：</p>
<pre><code>process.nextTick(functiontick(){process.nextTick(tick)})
</code></pre><p>再看个例子：</p>
<pre><code>constpromise=Promise.resolve()
promise.then(()=&gt;{
  console.log(&apos;promise&apos;)})
  process.nextTick(()=&gt;{
      console.log(&apos;nextTick&apos;)
  })
</code></pre><p>运行结果：</p>
<pre><code>nextTick
promise
</code></pre><p>解释：promise.then 虽然和 process.nextTick 一样，都将回调函数注册到 microtask，但优先级不一样。process.nextTick 的 microtask queue 总是优先于 promise 的 microtask queue 执行。</p>
<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><pre><code>setTimeout(()=&gt;{
    console.log(1)
},0)
newPromise((resolve,reject)=&gt;{
   console.log(2)
   for(leti=0;i&lt;10000;i++){
     i===9999&amp;&amp;resolve()
   }
   console.log(3)
}).then(()=&gt;{
   console.log(4)
})
console.log(5)
</code></pre><p>运行结果：</p>
<p>解释：Promise 构造函数是同步执行的，所以先打印 2、3，然后打印 5，接下来 event loop 进入执行 microtask 阶段，执行 promise.then 的回调函数打印出 4，然后执行下一个 macrotask，恰好是 timer 阶段的 setTimeout 的回调函数，打印出 1。</p>
<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><pre><code>setImmediate(()=&gt;{
    console.log(1)
    setTimeout(()=&gt;{
       console.log(2)
    },100)
    setImmediate(()=&gt;{
       console.log(3)
    })
    process.nextTick(
       ()=&gt;{console.log(4)})
     })
     process.nextTick(()=&gt;{
       console.log(5)
       setTimeout(()=&gt;{
        console.log(6)},100)
        setImmediate(()=&gt;{
        console.log(7)})
        process.nextTick(
        ()=&gt;{console.log(8)})
        })console.log(9)
</code></pre><p>运行结果：</p>
<p>process.nextTick、setTimeout 和 setImmediate 的组合，请读者自己推理吧。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c" target="_blank" rel="noopener">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">https://cnodejs.org/topic/57d68794cb6f605d360105bf</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/你不知道的-Promise-对象黑科技/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/你不知道的-Promise-对象黑科技/" itemprop="url">你不知道的 Promise 对象黑科技</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T11:10:58+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Promise-必知必会（十道题）"><a href="#Promise-必知必会（十道题）" class="headerlink" title="Promise 必知必会（十道题）"></a><a href="https://libin1991.github.io/2018/09/25/Promise-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></h2><h2 id="一、resolve-后的执行情况"><a href="#一、resolve-后的执行情况" class="headerlink" title="一、resolve 后的执行情况"></a>一、resolve 后的执行情况</h2><p>无论是 resolve, reject，都会将函数剩余的代码执行完</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
    console.log(&apos;mark 1&apos;);
    resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);
    console.log(&apos;mark 2&apos;);
});

promise.then(result =&gt; {
    console.log(result);
}).catch(err =&gt; {
    console.log(err);
});
</code></pre><p>相当于：</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
    console.log(&apos;mark 1&apos;);
    console.log(&apos;mark 2&apos;);
    resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);
});

promise.then(result =&gt; {
    console.log(result);
}).catch(err =&gt; {
    console.log(err);
});
</code></pre><p>如果你不想在 resolve 或 reject 后执行剩下的代码段，可以在 resolve 后将其返回<br><img src="https://pic4.zhimg.com/v2-f5b865c8a9df8ce752d057fe177c855e_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-f5b865c8a9df8ce752d057fe177c855e_hd.jpg" alt=""></p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
    console.log(&apos;mark 1&apos;);
    return resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);
    console.log(&apos;mark 2&apos;);             // never be here
});

promise.then(result =&gt; {
    console.log(result);
}).catch(err =&gt; {
    console.log(err);
});
</code></pre><h2 id="二、串行执行和并行执行："><a href="#二、串行执行和并行执行：" class="headerlink" title="二、串行执行和并行执行："></a>二、串行执行和并行执行：</h2><ol>
<li>串行执行：有一堆 Promise 对象，它们的执行顺序是固定的，前一个 promise 执行完后，后一个 promise 才开始执行，比如数据库查询，它们往往有前后的因果关系。</li>
<li>并行执行：有一堆 Promise 对象，它们的执行顺序是不固定的，没有前后因果关系，可以并发地去执行。</li>
</ol>
<p>并行执行很好解决，在 Promise中有 all 这个函数支持, Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。当多个 Promise 实例执行完后才去执行最后新的 Promise 实例。</p>
<pre><code>const datum = [];
for(let i = 0; i &lt; 10; i++) {
    datum.push(i);
}

Promise.all(datum.map(i =&gt; {
    return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        console.log(i * 200 + &quot; ms 后执行结束&quot;);
        resolve(&quot;第 &quot; + (i + 1) + &quot; 个 Promise 执行结束&quot;);
    }, i * 200);
    })
})).then((data) =&gt; {
    console.log(data);
});
</code></pre><p>如果不使用 Promise.all 这个方法的话，你也可以使用像 ES7 的 async/await</p>
<pre><code>const asyncFun = async () =&gt; {
    const datum = []
    for(let i = 0; i &lt; 10; i++) {
        datum.push(new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                console.log(i * 200 + &apos;ms 后执行结束&apos;)
                resolve(&apos;第 &apos; + (i + 1) + &apos; 个 Promise 执行结束&apos;)
            }, i * 200)
        }))
    }
    const result = []
    for(let promise of datum) {
        result.push(await promise)
    }
    console.log(result)
}
asyncFun()
</code></pre><p>串行执行：这里提供两种方式</p>
<pre><code>const datum = [];
for(let i = 0; i &lt; 10; i++) {
    datum.push(i);
}

let serial = Promise.resolve();

for(let i of datum) {
    serial = serial.then(data =&gt; {
        console.log(data);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
        console.log(i * 200 + &quot; ms 后执行结束&quot;);
        resolve(&quot;第 &quot; + (i + 1) + &quot; 个 Promise 执行结束&quot;);
        }, i * 200);
    })    
    });
}
</code></pre><p>另外可以使用 reduce 来串行：</p>
<pre><code>const datum = [];
for(let i = 0; i &lt; 10; i++) {
    datum.push(i);
}

datum.reduce((prev, cur) =&gt; {
    return prev.then(data =&gt; {
    console.log(data);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
        console.log(cur * 200 + &quot; ms 后执行结束&quot;);
        resolve(&quot;第 &quot; + (cur + 1) + &quot; 个 Promise 执行结束&quot;);
        }, cur * 200);
    })    
    })
}, Promise.resolve(true));
</code></pre><h2 id="三、值穿透问题："><a href="#三、值穿透问题：" class="headerlink" title="三、值穿透问题："></a>三、值穿透问题：</h2><pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&apos;Hello World!&apos;);
    }, 1000)
});

promise.then(&apos;呵呵哒&apos;).then((data) =&gt; {
    console.log(data);           // Hello World
})
</code></pre><p>这是一种值穿透的情况，一般有下面两种情况：<br>promise 已经是 FULFILLED/REJECTED 时，通过 return this 实现的值穿透：<br><img src="https://pic3.zhimg.com/v2-99374235673349f56d708c28511c27d2_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-99374235673349f56d708c28511c27d2_hd.jpg" alt=""></p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&apos;Hello World!&apos;);
    }, 1000)
});

promise.then(() =&gt; {
    promise.then().then(null).then(&apos;呵呵哒&apos;).then((res) =&gt; {
        console.log(res)
    })
    promise.catch().catch(null).then(&apos;呵呵哒&apos;).then((res) =&gt; {
        console.log(res) 
    })
})
</code></pre><p>promise 是 PENDING 时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态和值。如：<br><img src="https://pic2.zhimg.com/v2-7d3d3728e3b1f90d905d4f4782c1f97a_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7d3d3728e3b1f90d905d4f4782c1f97a_hd.jpg" alt=""></p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&apos;Hello World!&apos;);
    }, 1000)
});

let a = promise.then(&apos;呵呵哒&apos;);
a.then(res =&gt; {
    console.log(res);
});

let b = promise.catch(&apos;呵呵哒&apos;);
b.then(res =&gt; {
    console.log(res);
})
</code></pre><p>总而言之，当你给 then() 传递一个非函数（比如一个 promise ）值的时候，它实际上会解释为 then(null) ，这会导致之前的 promise 的结果丢失。例如:<br><img src="https://pic1.zhimg.com/v2-14fe675c00c5bc8154d161e3afed0f41_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-14fe675c00c5bc8154d161e3afed0f41_hd.jpg" alt=""></p>
<pre><code>Promise.resolve(&apos;First Value&apos;).then(Promise.resolve(&apos;Second Value&apos;)).then(null).then((value) =&gt; {
    console.log(value)    // First Value
})
</code></pre><h2 id="四、不要在异步回调函数中使用-throw-Error"><a href="#四、不要在异步回调函数中使用-throw-Error" class="headerlink" title="四、不要在异步回调函数中使用 throw Error"></a>四、不要在异步回调函数中使用 throw Error</h2><p>不仅 reject，抛出的异常也会被作为拒绝状态被 Promise 捕获</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    reject(&apos;This is an error&apos;);
});

promise.then(result =&gt; {
    console.log(result);
}).catch(error =&gt; {
    console.log(&apos;handle error: &apos;, error);  //handle error:  Error: This is an error
})
</code></pre><p>但是，永远不要在回调队列中抛出异常，因为回调队列脱离了运行上下文环境，异常无法被当前作用域捕获。</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        throw Error(&apos;This is an error&apos;);
    });
});

promise.then(result =&gt; {
    console.log(result);
}).catch(error =&gt; {
    console.log(&apos;handle error: &apos;, error);  // Error: This is an error
});
</code></pre><p>简单说来，回调队列指的是 JS 事件循环中的 macrotask 队列，比如 setTimeout setInterval 会插入到 macrotask 中。如果要在回调函数中捕获异常，请使用 reject，永远不要使用 Error。<br>上述的代码应改成：</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        reject(&apos;This is an error&apos;);
    });
});

promise.then(result =&gt; {
    console.log(result);
}).catch(error =&gt; {
    console.log(&apos;handle error: &apos;, error);  // Error: This is an error
});
</code></pre><h2 id="五、then-的第二个参数跟-catch-的区别-【面试常问】"><a href="#五、then-的第二个参数跟-catch-的区别-【面试常问】" class="headerlink" title="五、then 的第二个参数跟 catch 的区别 【面试常问】"></a>五、then 的第二个参数跟 catch 的区别 【面试常问】</h2><p>我们都知道 then 的第二参数跟 catch 用法很像，都是用来进行错误处理的，比如下面这段代码：</p>
<pre><code>let promise1 = new Promise((resolve, reject) =&gt; {
    reject(&apos;this is an error&apos;);
});

promise1.then(data =&gt; {
    console.log(data);
}, err =&gt; {
    console.log(&apos;handle err:&apos;, err);    // handle err: this is an error
});

let promise2 = new Promise((resolve, reject) =&gt; {
    reject(&apos;this is an error&apos;);
});
promise2.then(data =&gt; {
    console.log(data);
}).catch(err =&gt; {
    console.log(&apos;handle err:&apos;, err);    // handle err: this is an error
});
</code></pre><p>当时这两者还是区别的，区别于 then 的第二参数无法处理第一参数函数中的错误。</p>
<pre><code>let promise1 = Promise.resolve();
promise1.then(() =&gt; {
    throw Error(&apos;this is a error&apos;);   //UnhandledPromiseRejectionWarning: Unhandled promise rejection
}, err =&gt; {
    console.log(err);
})

let promise2 = Promise.resolve();

promise2.then(() =&gt; {
    throw Error(&apos;this is a error&apos;);  
}).catch(err =&gt; {
    console.log(&apos;handle err:&apos;, err);    //handle err: Error: this is a error
})
</code></pre><blockquote>
<p>当你使用then( resolveHandler, rejectHandler)格式，如果 resolveHandler 自己抛出一个错误 rejectHandler 并不能捕获。第一个 Promise 对象无法处理同级 then 中的函数抛出的异常，所以在一般情况下，最后直接使用 catch 来进行异常捕获比较保险。</p>
</blockquote>
<h2 id="六、处理最后-catch-函数中的异常"><a href="#六、处理最后-catch-函数中的异常" class="headerlink" title="六、处理最后 catch 函数中的异常"></a>六、处理最后 catch 函数中的异常</h2><p>一般我们用 catch 来捕捉前面抛出的异常，但是如果试想一下如果最后一个 catch 函数也抛出了异常，应该怎么处理呢?</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    reject(&apos;Hello World&apos;)
});

promise.catch((err) =&gt; {
    throw(&apos;Unexpected Error&apos;);   // Uncaught (in promise) Unexpected Error
})
</code></pre><p>面对这样的错误，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）这里提供两种思路：</p>
<ul>
<li><p>拓展 Promise.prototype 的方法，添加一个 done 函数，将错误抛向全局。</p>
<p>  window.onerror = (err) =&gt; {</p>
<pre><code>console.log(err);
</code></pre><p>  }<br>  Promise.prototype.done = function (onFulfilled, onRejected) {</p>
<pre><code>this.then(onFulfilled, onRejected)
  .catch(function (reason) {
    // 抛出一个全局错误
    setTimeout(() =&gt; { throw reason }, 0);
  });
</code></pre><p>  };<br>  let promise = new Promise((resolve, reject) =&gt; {</p>
<pre><code>reject(&apos;Hello World&apos;)
</code></pre><p>  });</p>
<p>  promise.catch((err) =&gt; {</p>
<pre><code>throw(&apos;Unexpected Error&apos;);     // Uncaught Unexpected Error
</code></pre><p>  }).done()</p>
</li>
</ul>
<ul>
<li>在全局添加 unhandledrejection 事件捕获 Promise 异常。</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-b512c7648df6d0d6fefb64d01009c175_b.jpg" alt=""></p>
<pre><code>window.addEventListener(&quot;unhandledrejection&quot;, (e) =&gt;{
    console.log(e.reason)
})    

let promise = new Promise((resolve, reject) =&gt; {
    reject(&apos;Hello World&apos;)
});

promise.catch((err) =&gt; {
    throw(&apos;Unexpected Error&apos;);     // Unexpected Error
})
</code></pre><h2 id="七、未捕获的错误可以被恢复"><a href="#七、未捕获的错误可以被恢复" class="headerlink" title="七、未捕获的错误可以被恢复"></a>七、未捕获的错误可以被恢复</h2><pre><code>let promise = new Promise((resolve, reject) =&gt; [
    reject(&apos;Hello world&apos;)
]).then(() =&gt; {
    console.log(&apos;resolve&apos;)
})

setTimeout(() =&gt; {
    promise.catch((e) =&gt; {
        console.log(e)
    }).then(() =&gt; {
        console.log(&apos;catch resolve&apos;)
    })
}, 1000)
</code></pre><h2 id="八、resolved-状态的-Promise-不会立即执行"><a href="#八、resolved-状态的-Promise-不会立即执行" class="headerlink" title="八、resolved 状态的 Promise 不会立即执行"></a>八、resolved 状态的 Promise 不会立即执行</h2><pre><code>let i = 0;
Promise.resolve(&apos;resolved promise&apos;).then(() =&gt; {
    i += 2
})
console.log(i)  // 0
</code></pre><p>即使是 resolve 的 Promise 调用 then 方法也是异步执行。</p>
<h2 id="九、结合-async-await-编写同步代码"><a href="#九、结合-async-await-编写同步代码" class="headerlink" title="九、结合 async/await 编写同步代码"></a>九、结合 async/await 编写同步代码</h2><ol>
<li>async/await 函数可以帮助我们彻底摆脱回调地狱的烦恼，用一种同步的方式来编写异步函数。</li>
<li>await 后面可以接数值，如果是异步请求的话可以接 Thunk 函数和 Promise 对象。</li>
</ol>
<p><img src="https://pic4.zhimg.com/v2-3ca5e16c6ba1743725cc92a7a8e5a7e2_b.jpg" alt=""></p>
<pre><code>const timeout = (ms) =&gt; {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve(ms + &apos; passed&apos;)
        }, ms)
    })
}

const asyncFunc =  async () =&gt; {
    const value1 = await timeout(2000)
    console.log(value1)
    const value2 = await timeout(2000)
    console.log(value2)
}

asyncFunc()
console.log(&apos;now&apos;)
</code></pre><h2 id="十、调用-then-方法返回新的-Promise-对象"><a href="#十、调用-then-方法返回新的-Promise-对象" class="headerlink" title="十、调用 then 方法返回新的 Promise 对象"></a>十、调用 then 方法返回新的 Promise 对象</h2><pre><code>let promise1 = new Promise((resolve) =&gt; {
    resolve(&apos;Hello world&apos;)
})

let promise2 = promise1.then()

console.log(promise1 === promise2)    // false
console.log(promise1 instanceof Promise)  // true
console.log(promise2 instanceof Promise)  // true
</code></pre><p>每次调用 then 方法后都会返回一个新的 Promise 对象，并不是返回原本的 Promise 对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/我也来实现一把MVVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/我也来实现一把MVVM/" itemprop="url">我也来实现一把MVVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T00:20:32+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大家都知道，vue是个MVVM框架，能够实现view和model的双向绑定，不像backbone那样，model改变需要手动去通知view更新，而vue实现的原理就是通过Object.defineProperty实现数据挟持，定义setter，然后数据改变的时候通知视图更新。</p>
<p>下面是网上vue的实现原理图：</p>
<p> <img src="https://user-gold-cdn.xitu.io/2018/4/10/162ad3d5be3e5105?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653b294cd1b80e3?imageslim" alt=""></p>
<h4 id="1、MVVM"><a href="#1、MVVM" class="headerlink" title="1、MVVM"></a>1、MVVM</h4><p>入口文件，在这里对vue当中的$el、methods、$data进行初始化，调用observer遍历$data的数据并进行挟持，调用compile遍历$el下的所有节点，解析指令和取值操作。遍历$data的数据，通过Object.defineProperty的getter和setter实现对$data的代理。</p>
<h4 id="2、Observer"><a href="#2、Observer" class="headerlink" title="2、Observer"></a>2、Observer</h4><p>遍历data，通过Object.defineProperty设置getter和setter，在setter知道数据发生了改变，然后通知Wacher去更新view。</p>
<h4 id="3、Compile"><a href="#3、Compile" class="headerlink" title="3、Compile"></a>3、Compile</h4><p>遍历$el下的所有节点，解析指令和取值操作等，为每个节点绑定更新函数（为什么在compile这里绑定呢？因为这里刚好是遍历的节点☺），绑定事件和method的关系，同时也添加订阅者，当接受到视图更新的订阅消息后，调用更新函数，实现视图更新。同时在添加订阅者的时候，初始化渲染视图。</p>
<h4 id="4、Watcher"><a href="#4、Watcher" class="headerlink" title="4、Watcher"></a>4、Watcher</h4><p>Watcher作为订阅者，充当Observer和Compile的中间桥梁，包含update方法，update方法调用Compile中绑定的事件更新函数，实现对视图的初始化和更新操作。</p>
<h3 id="MVVM的实现"><a href="#MVVM的实现" class="headerlink" title="MVVM的实现"></a>MVVM的实现</h3><p>MVVM完成初始化操作，并且调用observer和compile。对$data进行代理，如此便可以通过this.attribute来代理this.$data.attribute。因为一个属性可能对应多个指令，所以需要一个_binding属性来存放属性对应的所有订阅者，这样属性一改变，就可以取出所有的订阅者去更新视图。</p>
<pre><code>function MVVM(options) {
  // 初始化
  this.$data = options.data;
  this.$methods = options.methods;
  this.$el = options.el;
  // 保存data的每个属性对应的所有watcher
  this._binding  = {};
  // 调用observer和compile
  this._observer(options.data);
  this._compile();
  // this.xxx 代理this.$data.xxx
  this.proxyAttribute();
}
</code></pre><h3 id="Observer的实现"><a href="#Observer的实现" class="headerlink" title="Observer的实现"></a>Observer的实现</h3><p>Observer遍历$data，通过Object.defineProperty的setter的挟持数据改变，监听到数据改变后取出所有该属性对应的订阅者，然后通知更新函数更新视图。</p>
<p>注意：这里有循环，且闭包（getter和setter）里面需要依赖循环项（value和key），所以用立即执行函数解决循环项获取不对的问题。</p>
<pre><code>MVVM.prototype._observer = function(data) {
  var self = this;
  for(var key in this.$data) {
    if (this.$data.hasOwnProperty(key)) {
      // 初始化属性对应的订阅者容器（数组）
      this._binding[key] = {
        _directives: [],
        _texts: []
      };

      if(typeof this.$data[key] === &quot;object&quot;) {
        return this._observer(this.$data[key]);
      }
      var val = data[key];
      // 立即执行函数获取正确的循环项
      (function(value, key) {
        Object.defineProperty(self.$data, key, {
          enumerable: true,
          configurable: true,
          get: function() {
            return value;
          },
          set(newval) {
            if(newval === value) {
              return;
            }
            value = newval;
            // 监听到数据改变后取出所有该属性对应的订阅者，通知view更新-属性
            if(self._binding[key]._directives) {
              self._binding[key]._directives.forEach(function(watcher) {
                watcher.update();
              }, self);
            }
            // 监听到数据改变后取出所有该属性对应的订阅者，通知view更新-文本
            if(self._binding[key]._texts) {
              self._binding[key]._texts.forEach(function(watcher) {
                watcher.update();
              }, self);
            }
          }
        });
      })(val, key);
    }
  }
}
</code></pre><h3 id="Compile的实现"><a href="#Compile的实现" class="headerlink" title="Compile的实现"></a>Compile的实现</h3><p>Compile遍历所有的节点，解析指令，为每个节点绑定更新函数，且添加订阅者，当订阅者通知view更新的时候，调用更新函数，实现对视图的更新。</p>
<p>这里同样需要使用立即执行函数来解决闭包依赖的循环项问题。</p>
<p>还有一点需要解决的是，如果节点的innerText依赖多个属性的话，如何做到只替换改变属性对应的文本问题。</p>
<p>比如：已经被编译解析成“欢迎： 鸣人”，如果message改变为“你好”，怎么让使得“欢迎：鸣人”改为“你好：鸣人”。</p>
<pre><code>MVVM.prototype._compile = function() {
  var dom = document.querySelector(this.$el);
  var children = dom.children;
  var self = this;
  var i = 0, j = 0;
  // 更新函数，但observer中model的数据改变的时候，通过Watcher的update调用更新函数，从而更新dom
  var updater = null;
  for(; i &lt; children.length; i++) {
    var node = children[i];
    (function(node) {
      // 解析{{}}里面的内容
      // 保存指令原始内容，不然数据更新时无法完成替换
      var text = node.innerText;
      var matches = text.match(/{{([^{}]+)}}/g);
      if(matches &amp;&amp; matches.length &gt; 0) {
        // 保存和node绑定的所有属性
        node.bindingAttributes = [];
        for(j = 0; j &lt; matches.length; j++) {
          // data某个属性
          var attr = matches[j].match(/{{([^{}]+)}}/)[1];
          // 将和该node绑定的data属性保存起来
          node.bindingAttributes.push(attr);
          (function(attr) {
            updater = function() {
              // 改变的属性值对应的文本进行替换
              var innerText = text.replace(new RegExp(&quot;{{" + attr + "}}&quot;, &quot;g&quot;), self.$data[attr]);
              // 如果该node绑定多个属性 eg:&lt;div&gt;{{title}}{{description}}&lt;/div&gt;
              for(var k = 0; k &lt; node.bindingAttributes.length; k++) {
                if(node.bindingAttributes[k] !== attr) {
                  // 恢复原来没改变的属性对应的文本
                  innerText = innerText.replace(&quot;{{" + node.bindingAttributes[k] + "}}&quot;, self.$data[node.bindingAttributes[k]]);
                }
              }
              node.innerText = innerText;
            }
            self._binding[attr]._texts.push(new Watcher(self, attr, updater));
          })(attr);
        }
      }

      // 解析vue指令
      var attributes = node.getAttributeNames();
      for(j = 0; j &lt; attributes.length; j++) {
        // vue指令
        var attribute = attributes[j];
        // DOM attribute
        var domAttr = null;
        // 绑定的data属性
        var vmDataAttr = node.getAttribute(attribute);

        if(/v-bind:([^=]+)/.test(attribute)) {
          // 解析v-bind
          domAttr = RegExp.$1;
          // 更新函数
          updater = function(val) {
            node[domAttr] = val;
          }
          // data属性绑定多个watcher
          self._binding[vmDataAttr]._directives.push(
            new Watcher(self, vmDataAttr, updater)
          )
        } elseif(attribute === &quot;v-model&quot; &amp;&amp; (node.tagName = &apos;INPUT&apos; || node.tagName == &apos;TEXTAREA&apos;)) {
          // 解析v-model
          // 更新函数
          updater = function(val) {
            node.value = val;
          }
          // data属性绑定多个watcher
          self._binding[vmDataAttr]._directives.push(
            new Watcher(self, vmDataAttr, updater)
          )
          // 监听input/textarea的数据变化，同步到model去，实现双向绑定
          node.addEventListener(&quot;input&quot;, function(evt) {
            var $el = evt.currentTarget;
            self.$data[vmDataAttr] = $el.value;
          });
        } elseif(/v-on:([^=]+)/.test(attribute)) {
          // 解析v-on
          var event = RegExp.$1;
          var method = vmDataAttr;
          node.addEventListener(event, function(evt) {
            self.$methods[method] &amp;&amp; self.$methods[method].call(self, evt);
          });
        }
      }
    })(node);
  }

}
</code></pre><h3 id="Watcher的实现"><a href="#Watcher的实现" class="headerlink" title="Watcher的实现"></a>Watcher的实现</h3><p>Watcher充当订阅者的角色，架起了Observer和Compile的桥梁，Observer监听到数据变化后，通知Wathcer更新视图(调用Wathcer的update方法)，Watcher再告诉Compile去调用更新函数，实现dom的更新。同时页面的初始化渲染也交给了Watcher（当然也可以放到Compile进行）。</p>
<pre><code>function Watcher(vm, attr, cb) {
  this.vm = vm; // viewmodel
  this.attr = attr; // data的属性，一个watcher订阅一个data属性
  this.cb = cb; // 更新函数，在compile那边定义
  // 初始化渲染视图
  this.update();
}

Watcher.prototype.update = function() {
  // 通知comile中的更新函数更新dom 
  this.cb(this.vm.$data[this.attr]);
}
</code></pre><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><p>git地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FVikiLee%2FMVVM.git" target="_blank" rel="noopener">github.com/VikiLee/MVV…</a></p>
<p>鸣谢：<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5acc17cb51882555745a03f8" target="_blank" rel="noopener">juejin.im/post/5acc17…</a></p>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;view&quot;&gt;
    &lt;div v-bind:id=&quot;id&quot;&gt;
      {{message}}:{{name}}
    &lt;/div&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;
    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;js/MVVM.js&quot;type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  var vue = new MVVM({
    el: &quot;#view&quot;,
    data: {
      message: &quot;欢迎光临&quot;,
      name: &quot;鸣人&quot;,
      id: &quot;id&quot;
    },
    methods: {
      handleClick: function() {
        alert(this.message + &quot;:&quot; + this.name + &quot;, 点击确定路飞会出来&quot;);
        this.name = &apos;路飞&apos;;
      }
    }
  })

  setTimeout(function() {
    vue.message = &quot;你好&quot;;
  }, 1000);
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Promise-必知必会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/02/Promise-必知必会/" itemprop="url">Promise 必知必会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T23:18:00+08:00">
                2018-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="你不知道的-Promise-对象黑科技"><a href="#你不知道的-Promise-对象黑科技" class="headerlink" title="你不知道的 Promise 对象黑科技"></a><a href="https://zhuanlan.zhihu.com/p/30735250" target="_blank" rel="noopener">你不知道的 Promise 对象黑科技</a></h2><p>Promise 想必大家都十分熟悉，想想就那么几个 api，可是你真的了解 Promise 吗？本文根据 Promise 的一些知识点总结了十道题，看看你能做对几道。</p>
<p>以下 promise 均指代 Promise 实例，环境是 Node.js。</p>
<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {
  console.log(1)
  resolve()
  console.log(2)
})
promise.then(() =&gt; {
  console.log(3)
})
console.log(4)
</code></pre><p>运行结果：</p>
<pre><code>1
2
4
3
</code></pre><p>解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。</p>
<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&apos;success&apos;)
  }, 1000)
})
console.log(promise)
promise
  .then(() =&gt; {
    console.log(promise)
    throw new Error(&apos;error!!!&apos;)
  })
  .catch(err =&gt; {
    console.log(promise)
  })
</code></pre><p>运行结果：</p>
<pre><code>Promise { &lt;pending&gt; }
Promise { &apos;success&apos; }
Promise { &apos;success&apos; }
</code></pre><p>解释：promise 有 3 种状态：pending、fulfilled 和 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。</p>
<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {
  resolve(&apos;success1&apos;)
  reject(&apos;error&apos;)
  resolve(&apos;success2&apos;)
})

promise
  .then((res) =&gt; {
    console.log(&apos;then: &apos;, res)
  })
  .catch((err) =&gt; {
    console.log(&apos;catch: &apos;, err)
  })
</code></pre><p>运行结果：</p>
<pre><code>then: success1
</code></pre><p>解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。</p>
<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><pre><code>Promise.resolve(1)
  .then((res) =&gt; {
    console.log(res)
    return 2
  })
  .catch((err) =&gt; {
    return 3
  })
  .then((res) =&gt; {
    console.log(res)
  })
</code></pre><p>运行结果：</p>
<pre><code>1
2
</code></pre><p>解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。</p>
<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    console.log(&apos;once&apos;)
    resolve(&apos;success&apos;)
  }, 1000)
})

const start = Date.now()
promise.then((res) =&gt; {
  console.log(res, Date.now() - start)
})
promise.then((res) =&gt; {
  console.log(res, Date.now() - start)
})
</code></pre><p>运行结果：</p>
<pre><code>once
success 1005
success 1007
</code></pre><p>解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</p>
<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><pre><code>Promise.resolve()
  .then(() =&gt; {
    return new Error(&apos;error!!!&apos;)
  })
  .then((res) =&gt; {
    console.log(&apos;then: &apos;, res)
  })
  .catch((err) =&gt; {
    console.log(&apos;catch: &apos;, err)
  })
</code></pre><p>运行结果：</p>
<pre><code>then: Error: error!!!
    at Promise.resolve.then (...)
    at ...
</code></pre><p>解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：</p>
<ol>
<li>return Promise.reject(new Error(‘error!!!’))</li>
<li>throw new Error(‘error!!!’)</li>
</ol>
<p>因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。</p>
<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><pre><code>const promise = Promise.resolve()
  .then(() =&gt; {
    return promise
  })
promise.catch(console.error)
</code></pre><p>运行结果：</p>
<pre><code>TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
    at &lt;anonymous&gt;
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3
</code></pre><p>解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：</p>
<pre><code>process.nextTick(function tick () {
  console.log(&apos;tick&apos;)
  process.nextTick(tick)
})
</code></pre><h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre><p>运行结果：</p>
<pre><code>1
</code></pre><p>解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</p>
<h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><pre><code>Promise.resolve()
  .then(function success (res) {
    throw new Error(&apos;error&apos;)
  }, function fail1 (e) {
    console.error(&apos;fail1: &apos;, e)
  })
  .catch(function fail2 (e) {
    console.error(&apos;fail2: &apos;, e)
  })
</code></pre><p>运行结果：</p>
<pre><code>fail2: Error: error
    at success (...)
    at ...
</code></pre><p>解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以：</p>
<pre><code>Promise.resolve()
  .then(function success1 (res) {
    throw new Error(&apos;error&apos;)
  }, function fail1 (e) {
    console.error(&apos;fail1: &apos;, e)
  })
  .then(function success2 (res) {
  }, function fail2 (e) {
    console.error(&apos;fail2: &apos;, e)
  })
</code></pre><h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><pre><code>process.nextTick(() =&gt; {
  console.log(&apos;nextTick&apos;)
})
Promise.resolve()
  .then(() =&gt; {
    console.log(&apos;then&apos;)
  })
setImmediate(() =&gt; {
  console.log(&apos;setImmediate&apos;)
})
console.log(&apos;end&apos;)
</code></pre><p>运行结果：</p>
<pre><code>end
nextTick
then
setImmediate
</code></pre><p>解释：process.nextTick 和 promise.then 都属于 microtasks，而 setImmediate 属于 macrotasks，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotasks）之间都会执行 microtasks，事件循环的开始会先执行一次 microtasks。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="舞动乾坤">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="舞动乾坤">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="舞动乾坤">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>舞动乾坤 - 星光不问赶路人 岁月不负有心人</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
    	<div id="sky">
				<div id="background" class="container">
			<!-- svg file -->
			<svg id="svgout" height="100%" width="100%" viewbox="0 0 550 400">
				<defs>
					<g id="bottomShadow">
						<path fill="#000000" stroke="none" d="
		M 270.5 225.95
		L 127.35 316.65 266.8 400 409.6 309.25 270.5 225.95 Z"/>
					</g>
					<g id="Layer52_0_FILL">
						<path class="topGrass" fill="#B9D668" stroke="none" d="
	M 397.85 229.3
	L 397.85 225.6 269.85 152 135.75 228.6 135.75 233.65 262.1 306.55 397.85 229.3 Z"/>
					</g>
					<g id="Layer51_0_FILL">
						<path class="leftSideGrass" fill="#6E9E4F" stroke="none" d="
	M 135.1 229.95
	L 135.1 256.85 262.1 328.4 262.1 301.85 135.1 229.95 Z"/>
					</g>
					<g id="Layer50_0_FILL">
						<path class="rightGrassTop" fill="#8CB154" stroke="none" d="
	M 397.85 225.95
	L 395.8 225.95 261.75 301.55 261.75 328.4 397.85 251.15 397.85 225.95 Z"/>
					</g>
					<g id="Layer48_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.45 282.4
	L 135.75 298.15 262.1 372.1 261.75 355.65 135.45 282.4 Z"/>
					</g>
					<g id="Layer47_0_FILL">
						<path class="middleLeftCrust" fill="#C77E61" stroke="none" d="
	M 135.1 270.3
	L 135.1 283.05 275.9 364.35 271.85 348.9 135.1 270.3 Z"/>
					</g>
					<g id="Layer46_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.1 255.15
	L 135.1 270.3 262.1 343.55 262.1 328.05 135.1 255.15 Z"/>
					</g>
					<g id="Layer45_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 294.5
	L 397.5 277 261.75 355.3 261.75 372.75 397.5 294.5 Z"/>
					</g>
					<g id="Layer44_0_FILL">
						<path class="middleRightCrust" fill="#C89451" stroke="none" d="
	M 397.5 269.95
	L 397.15 266.6 262.1 343.2 262.1 355.95 397.5 279.7 397.5 269.95 Z"/>
					</g>
					<g id="Layer43_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 266.6
	L 397.5 250.45 261.75 328.4 261.75 343.85 397.5 266.6 Z"/>
					</g>
					<g id="Layer41_0_FILL">
						<path class="greyRoad" fill="#B2B2B1" stroke="none" d="
	M 295.05 283.05
	Q 299.05 280.35 308.45 275.3 317.85 269.95 323.6 266.9
	L 268.8 233.65 338.05 191.35 309.15 174.55 177.75 254.5
	Q 191.55 262.2 198.25 266.25 204.65 269.95 209.7 271.95
	L 241.6 250.45 295.05 283.05 Z"/>
					</g>
					<g id="Layer40_0_FILL">
						<path fill="#FFFFFF" stroke="none" d="
	M 199.95 256.85
	Q 194.55 261.2 191.9 262.2
	L 194.9 263.9 200.95 259.2 199.95 256.85
	M 225.8 243.75
	L 224.8 241.75 211.05 250.8 212.05 252.8 225.8 243.75
	M 308.15 275.65
	L 296.7 266.6 295.35 268.6 306.8 277.7 308.15 275.65
	M 275.9 253.5
	L 274.55 255.5 285.95 264.55 287.3 262.55 275.9 253.5
	M 251.7 227.3
	L 250.7 225.25 236.9 234.35 237.9 236.35 251.7 227.3
	M 257.05 240.7
	L 254.05 240.7 268.8 249.8 269.5 247.75 257.05 240.7
	M 277.2 207.8
	L 263.45 216.85 264.45 218.9 278.25 209.8 277.2 207.8
	M 305.1 192.65
	L 304.1 190.65 290.3 199.75 291.35 201.75 305.1 192.65 Z"/>
					</g>
					<g id="Layer38_0_FILL">
						<path class="frontFascia" fill="#ECB27B" stroke="none" d="
	M 359.25 187.95
	L 346.4 174.95 333.85 202.9 359.25 187.95 Z"/>
					</g>
					<g id="Layer37_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 334 201.05
	L 334.35 232 359.2 217.55 359.25 187.95 334 201.05 Z"/>
					</g>
					<g id="Layer36_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 334.35 232.3
	L 334.35 205.1 305.1 191.35 305.1 216.85 334.35 232.3 Z"/>
					</g>
					<g id="Layer35_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 329.7 167.9
	L 331.05 167.9 344.55 176.7 347.85 176.7 363 192.25 363.15 189.55 350.65 176.7 350.55 176.7 334.25 167.5 334.25 159.1 329.7 159.1 329.7 164.9 322.65 160.95 322.3 162.15 329.7 167 329.7 167.9 Z"/>
					</g>
					<g id="Layer34_0_FILL">
						<path class="leftRoof" fill="#F2563B" stroke="none" d="
	M 334.05 207.05
	L 350.65 176.7 322.1 160.45 302.1 192.05 334.05 207.05 Z"/>
					</g>
					<g id="Layer30_0_FILL">
						<path id="windowFour" class="windows" stroke="none" fill="#975A42" d="
	M 341.35 203.3
	Q 340.9 203.45 340.5 203.8 340.1 204.2 339.85 204.75 339.7 205 339.7 205.3 339.6 205.75 339.7 206.1 339.7 206.15 339.7 206.2 339.8 206.5 340 206.8 340.55 207.4 341.45 207.4 342.35 207.4 343 206.8 343.4 206.5 343.65 206.1 343.85 205.75 343.95 205.3 344.05 204.4 343.55 203.8 343.3 203.45 343 203.3 342.65 203.15 342.2 203.15 341.8 203.15 341.35 203.3
	M 355.85 198.45
	Q 355.8 198.2 355.6 198 355.1 197.4 354.2 197.4 353.35 197.4 352.6 198 351.85 198.65 351.7 199.55 351.7 199.7 351.7 199.85 351.6 200.5 352 201.05 352.55 201.65 353.45 201.65 354.3 201.65 355.05 201.05 355.45 200.7 355.7 200.25 355.8 200.05 355.9 199.85 355.95 199.7 355.95 199.55 356.05 198.95 355.85 198.45 Z"/>
						<path class="door" fill="#B65041" stroke="none" d="
	M 351.95 211.2
	L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2
	M 351.2 211.2
	L 351.35 211.2 351.35 211.1 351.2 211.2 Z"/>
					</g>
					<g>
						<path id="Layer30_0_FILL" fill="#000000" fill-opacity="1" stroke="none" d="
	M 183.7 215.3
	L 183.7 215.6
	Q 187.25 231.75 212.25 234.35
	L 183.7 215.3 Z"/>
					</g>
					<g id="Layer29_0_FILL">
						<path fill="#000000" fill-opacity="0.4" stroke="none" d="
	M 305.1 216.85
	L 305.15 217.2
	Q 309.45 233.2 334.35 232.3
	L 305.1 216.85 Z"/>
					</g>
					<g id="Layer27_0_FILL">
						<path class="vegetation" fill="#78A950" stroke="none" d="
	M 177.45 231.65
	Q 175.75 235.35 181.8 239.35 185.5 235.7 185.15 231.3 182.8 230.65 181.45 234 179.45 231.3 177.45 231.65
	M 236.9 266.6
	Q 235.2 270.3 241.25 274.3 244.95 270.6 244.65 266.25 242.3 265.6 240.95 268.95 238.9 266.25 236.9 266.6
	M 254.7 277
	Q 253.05 280.7 259.1 284.75 262.75 281.05 262.45 276.65 260.1 276 258.75 279.35 256.7 276.65 254.7 277
	M 315.5 245.75
	Q 313.5 243.05 311.5 243.4 309.8 247.1 315.85 251.15 319.55 247.45 319.2 243.05 316.85 242.4 315.5 245.75
	M 295.35 232.65
	Q 293.7 236.35 299.75 240.4 303.45 236.7 303.1 232.3 300.75 231.65 299.4 235 297.4 232.3 295.35 232.65
	M 277.2 171.85
	Q 275.55 175.55 281.6 179.55 285.3 175.85 284.95 171.5 282.6 170.85 281.25 174.2 279.25 171.5 277.2 171.85 Z"/>
					</g>
					<g id="Layer26_0_FILL">
						<path class="treeWood" fill="#AE663D" stroke="none" d="
	M 175.1 177.55
	L 172.05 177.55 172.05 191.1 159.3 172.85
	Q 154.6 171.5 172.05 195.7
	L 172.05 212.5 175.1 212.5 175.1 177.55
	M 252.7 151.35
	L 249 151.35 249 176.9 252.7 176.9 252.7 151.35 Z"/>
					</g>
					<g id="Layer25_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 192.55 179.55
	Q 200.95 173.5 200.95 165.1 200.95 156.4 192.55 150 184.15 144.3 172.05 144.3 160.3 144.3 151.9 150 143.15 156.4 143.15 165.1 143.15 173.5 151.9 179.55 160.3 185.95 172.05 185.95 184.15 185.95 192.55 179.55
	M 236.25 106.65
	Q 230.2 116.05 230.2 129.15 230.2 142.25 236.25 151.35 242.3 160.75 250.7 160.75 258.75 160.75 264.8 151.35 270.85 142.25 270.85 129.15 270.85 116.05 264.8 106.65 258.75 97.6 250.7 97.6 242.3 97.6 236.25 106.65 Z"/>
					</g>
					<g id="Layer24_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 158.3 221.9
	Q 160.65 221.9 161.95 220.2 163 219.55 163.3 218.55 164.65 218.9 166.35 218.9 170.05 218.9 172.4 216.2 175.1 213.85 175.1 210.15 175.1 206.45 172.4 203.75 170.05 201.4 166.35 201.4 162.65 201.4 159.95 203.75 157.6 206.45 157.6 210.15 157.6 210.8 157.6 211.15 155.95 211.5 154.6 212.5 152.9 214.15 152.9 216.55 152.9 218.9 154.6 220.2 156.25 221.9 158.3 221.9
	M 338.35 240.05
	Q 341.05 237.7 341.05 234 341.05 230.3 338.35 227.6 336 225.25 332.3 225.25 328.65 225.25 325.95 227.6 323.6 230.3 323.6 234 323.6 237.7 325.95 240.05 328.65 242.75 332.3 242.75 336 242.75 338.35 240.05 Z"/>
					</g>
					<g id="Layer22_0_FILL">
						<path class="rightRoof" fill="#D05041" stroke="none" d="
	M 220 173.85
	L 236.8 186.7 264.35 171.15 244.5 159.55 220 173.85 Z"/>
					</g>
					<g id="Layer21_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 212.25 191.35
	L 183.35 172.3 183.7 215.3 212.25 234.35 212.25 191.35 Z"/>
					</g>
					<g id="Layer20_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 192.1 149.85
	L 236.45 174.8 243.1 171.4
	Q 220.05 150.55 196.3 139.95
	L 192.1 149.85 Z"/>
					</g>
					<g id="Layer19_0_FILL">
						<path class="frontFascia" fill="#EBB17B" stroke="none" d="
	M 226.85 160.95
	L 212 190.6 229.75 192.6 239.75 172.85 226.85 160.95 Z"/>
					</g>
					<g id="Layer18_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 240.15 172.65
	L 211.9 191.6 212.25 233.65 264.35 201.7 264.35 170.8 240.8 184.45 240.15 172.65 Z"/>
					</g>
					<g id="Layer17_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 210.9 142.2
	L 205.9 142.2 205.9 152.65 210.9 152.65 210.9 142.2 Z"/>
					</g>
					<g>
						<path id="Layer16_0_FILL" class="leftRoof" fill="#F2563B" stroke="none" d="
	M 210.25 195.5
	L 227.4 160.95 195.45 141.35 177.65 175.85 210.25 195.5 Z"/>
					</g>
					<g>
						<path id="sun" fill="#E3BD0E" stroke="none" d="
	M 257.05 15.95
	Q 251.7 15.95 248 19.65 244.3 23.35 244.3 28.7 244.3 34.1 248 37.8 251.7 41.5 257.05 41.5 262.45 41.5 266.15 37.8 269.85 34.1 269.85 28.7 269.85 23.35 266.15 19.65 262.45 15.95 257.05 15.95 Z"/>
					</g>
					<g id="Layer8_0_FILL">
						<path fill="#975A42" stroke="none" d="
	M 238.45 189.65
	Q 238.295703125 189.362109375 238.05 189.1 237.35 188.3 236.2 188.3 235.05 188.3 234.15 189.1 233.3 189.9 233.2 191.05 233.1 192.2 233.8 193 234.55 193.8 235.7 193.8 236.85 193.8 237.7 193 238.1970703125 192.558203125 238.45 192 238.6552734375 191.56484375 238.7 191.05 238.7671875 190.276953125 238.45 189.65
	M 220.55 197.55
	Q 220 197.55 219.5 197.75 218.95 197.95 218.5 198.35 217.933203125 198.8833984375 217.7 199.55 217.5833984375 199.916796875 217.55 200.3 217.4923828125 200.96171875 217.7 201.5 217.852734375 201.9103515625 218.15 202.25 218.95 203.05 220.1 203.05 221.25 203.05 222.05 202.25 222.95 201.45 223.05 200.3 223.15 199.15 222.4 198.35 222.05 197.95 221.65 197.75 221.15 197.55 220.55 197.55 Z"/>
					</g>
					<g id="Layer7_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 233.55 206.75
	L 225.9 211.95 226.25 225.5 233.95 220.35 233.55 206.75 Z"/>
					</g>
					<g>
						<path id="windowOne" class="windows" fill="#975A42" stroke="none" d="
	M 188.65 198.4
	L 188.8 204.1 198.65 210.45 198.55 204.75 188.65 198.4
	M 208.45 216.8
	L 208.35 211.1 198.55 204.75 198.65 210.45 208.45 216.8
	M 188.8 204.1
	L 188.95 209.8 198.8 216.15 198.65 210.45 188.8 204.1
	M 208.6 222.5
	L 208.45 216.8 198.65 210.45 198.8 216.15 208.6 222.5 Z"/>
					</g>
					<g>
						<path id="windowThree" class="windows" fill="#975A42" stroke="none" d="
	M 311.7 214.1
	L 318.55 217.55 318.45 211.9 311.6 208.45 311.7 214.1
	M 325.4 221
	L 325.25 215.35 318.45 211.9 318.55 217.55 325.4 221
	M 318.4 206.2
	L 311.5 202.75 311.6 208.45 318.45 211.9 318.4 206.2
	M 325.25 215.35
	L 325.2 209.7 318.4 206.2 318.45 211.9 325.25 215.35 Z"/>
					</g>
					<g id="Layer2_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 259.7 183.25
	L 244.6 191.9 244.6 213.8 259.7 204.55 259.7 183.25 Z"/>
					</g>
					<path id="windowTwo" fill="#975A42" class="windows" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" d="
	M 223.05 200.3
	Q 222.95 201.45 222.05 202.25 221.25 203.05 220.1 203.05 218.95 203.05 218.15 202.25 217.852734375 201.9103515625 217.7 201.5 217.4923828125 200.96171875 217.55 200.3 217.5833984375 199.916796875 217.7 199.575 217.933203125 198.8833984375 218.5 198.35 218.95 197.95 219.5 197.75 220 197.55 220.55 197.55 221.15 197.55 221.65 197.75 222.05 197.95 222.4 198.35 223.15 199.15 223.05 200.3 Z
	M 238.7 191.05
	Q 238.6552734375 191.56484375 238.45 192 238.1970703125 192.558203125 237.7 193 236.85 193.8 235.7 193.8 234.55 193.8 233.8 193 233.1 192.2 233.2 191.05 233.3 189.9 234.15 189.1 235.05 188.3 236.2 188.3 237.35 188.3 238.05 189.1 238.295703125 189.362109375 238.45 189.65 238.7671875 190.276953125 238.7 191.05 Z"/>
					<path fill="#F2563B" stroke="none" d=" M 351.95 211.2 L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2 Z"/>
					<path id="Layer6_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 198.55 204.75
	L 208.35 211.1 208.45 216.8 208.6 222.5 198.8 216.15 188.95 209.8 188.8 204.1 188.65 198.4 198.55 204.75 198.65 210.45 208.45 216.8
	M 198.8 216.15
	L 198.65 210.45 188.8 204.1"/>
					<path id="Layer5_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 325.25 215.35
	L 325.4 221 318.55 217.55 311.7 214.1 311.6 208.45 311.5 202.75 318.4 206.2 325.2 209.7 325.25 215.35 318.45 211.9 318.55 217.55
	M 318.4 206.2
	L 318.45 211.9 311.6 208.45"/>
				</defs>
				<g id="shadow">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use xlink:href="#bottomShadow"/>
					</g>
				</g>
				<g transform="matrix( 1, 0, 0, 1, 0,0) ">
					<use xlink:href="#sun"/>
				</g>
				<g id="earth">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer52_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer51_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer50_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer48_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer47_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer46_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer45_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer44_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer43_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer41_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer40_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer38_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer37_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer36_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer35_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer34_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowFour"/>
						<use class="element" xlink:href="#Layer32_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer30_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer27_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer26_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer25_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer24_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer22_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer21_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer20_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer19_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer18_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer17_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer16_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer8_0_FILL"/>
						<use class="element" xlink:href="#windowTwo"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer7_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowOne"/>
						<use class="element" xlink:href="#Layer6_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowThree"/>
						<use class="element" xlink:href="#Layer5_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer2_0_FILL"/>
					</g>
				</g>
			</svg>
			<! -- End of SVG file -->
			<! -- Moon/Sun Toggle -->
			<div id="toggleButton" class="day-toggle">
				<div class="sun-icon"></div>
				<label class="switch">
            <input id="toggleCheckbox" type="checkbox">
            <div class="slider"></div>
        </label>
				<div class="cloud-icon"></div>
			</div>
			<! -- Moon/Sun Toggle -->
			<! -- End of Container -->
		</div>
			</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">舞动乾坤</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">星光不问赶路人 岁月不负有心人</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/26/写一个webpack内联代码插件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/26/写一个webpack内联代码插件/" itemprop="url">写一个webpack内联代码插件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-26T17:44:40+08:00">
                2019-02-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>单页开发很多时候index.html只有些html,外链一些css和js,通常导致一些打包后的代码非常大,造成头轻脚重。导致index.html很小，打包的js和css很臃肿，我们可以将一些常用的例如reset.css,jquery,vue等内联到index.html,合理分配文件大小，毕竟index.html一个http请求就拿那么点东西，太浪费了。</p>
<p>我们尝试写一个webpack plugin,通过配置实现内联代码！</p>
<h2 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h2><ul>
<li>传一个数组，第一个表示要内联的js路径列表，第二个是css路径列表</li>
<li>css插入<code>&lt;head&gt;</code>标签中，js插入<code>&lt;body&gt;</code>标签中</li>
<li>按数组顺序插入</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> WebpackInlineSourcePlugin([&#123;</span><br><span class="line">	path:[<span class="string">'./src/lib/jquery-3.2.1.min.js'</span>,<span class="string">'./src/lib/vue.min.js'</span>]</span><br><span class="line">&#125;,&#123;</span><br><span class="line">	path:[<span class="string">'./src/lib/reset.min.css'</span>,<span class="string">'./src/lib/A.css'</span>]</span><br><span class="line">&#125;]),</span><br></pre></td></tr></table></figure>
<h3 id="WebPackInlineSourcePlugin插件代码-webpack内联code插件"><a href="#WebPackInlineSourcePlugin插件代码-webpack内联code插件" class="headerlink" title="WebPackInlineSourcePlugin插件代码               webpack内联code插件  "></a>WebPackInlineSourcePlugin插件代码              <a href="https://github.com/libin1991/webpack4-vue-more-page-cli/tree/master/webpack%E5%86%85%E8%81%94code%E6%8F%92%E4%BB%B6" target="_blank" rel="noopener"><font color="#dd0000"> webpack内联code插件  </font></a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>); <span class="comment">//断言库</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeOf</span>(<span class="params">value, type</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value).slice(<span class="number">8</span>, <span class="number">-1</span>).toLowerCase() === type.toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeAssets</span>(<span class="params">assets, normalized = &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">	js: [], </span></span></span><br><span class="line"><span class="function"><span class="params">	css: []</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(typeOf(assets, <span class="string">'array'</span>)) &#123;</span><br><span class="line">		assets.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!index) &#123;</span><br><span class="line">				normalized.js.push(...item.path)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				normalized.css.push(...item.path)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> normalized;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractSource</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fs.readFileSync(path, &#123;</span><br><span class="line">		encoding: <span class="string">'utf8'</span></span><br><span class="line">	&#125;).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processAsset</span>(<span class="params">asset</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(asset.type === <span class="string">'css'</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">`&lt;style type="text/css"&gt;<span class="subst">$&#123;extractSource(asset.path)&#125;</span>&lt;/style&gt;`</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">`&lt;script type="text/javascript"&gt;<span class="subst">$&#123;extractSource(asset.path)&#125;</span>&lt;/script&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WebpackInlineSourcePlugin</span>(<span class="params">assets, filter</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.assets = normalizeAssets(assets);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebpackInlineSourcePlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">	compiler.plugin(<span class="string">'compilation'</span>, (compilation) =&gt; &#123;</span><br><span class="line">		compilation.plugin(<span class="string">'html-webpack-plugin-before-html-processing'</span>, (htmlPluginData) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">const</span> bodyAssets = self.assets.js.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					path:item,</span><br><span class="line">					type:<span class="string">'js'</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).map(processAsset);</span><br><span class="line">			 </span><br><span class="line">			<span class="keyword">const</span> headAssets = self.assets.css.map(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> &#123;</span><br><span class="line">					path:item,</span><br><span class="line">					type:<span class="string">'css'</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).map(processAsset);</span><br><span class="line">          </span><br><span class="line">			htmlPluginData.html = htmlPluginData.html.replace(<span class="regexp">/(&lt;\/head&gt;)/i</span>, (match, head) =&gt; headAssets.join(<span class="string">'\n'</span>) + head);</span><br><span class="line">			htmlPluginData.html = htmlPluginData.html.replace(<span class="regexp">/(&lt;\/body&gt;)/i</span>, (match, body) =&gt; bodyAssets.join(<span class="string">'\n'</span>) + body);</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;);</span><br><span class="line">	compiler.plugin(<span class="string">'done'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = WebpackInlineSourcePlugin;</span><br></pre></td></tr></table></figure>
<p>我们以Vue-cli为例,vue.config.js配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> WebpackInlineSourcePlugin = <span class="built_in">require</span>(<span class="string">'./plugin/plugin2'</span>);</span><br><span class="line"><span class="keyword">const</span> WebpackfilelistPlugin = <span class="built_in">require</span>(<span class="string">'./plugin/filelist.js'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path.join(__dirname, dir)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 基本路径</span></span><br><span class="line">    baseUrl: <span class="string">'./'</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="number">8888</span>,</span><br><span class="line">        open: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    configureWebpack: &#123;</span><br><span class="line">        plugins: [</span><br><span class="line">            <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">                jQuery: <span class="string">'jquery'</span>,</span><br><span class="line">                $: <span class="string">'jquery'</span></span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="keyword">new</span> WebpackInlineSourcePlugin([&#123;</span><br><span class="line">            	path:[<span class="string">'./src/lib/jquery-3.2.1.min.js'</span>,<span class="string">'./src/lib/vue.min.js'</span>]</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">            	path:[<span class="string">'./src/lib/reset.min.css'</span>,<span class="string">'./src/lib/A.css'</span>]</span><br><span class="line">            &#125;]),</span><br><span class="line">            <span class="keyword">new</span> WebpackfilelistPlugin()</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">    lintOnSave: <span class="literal">false</span>,</span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config.entry.app = [<span class="string">"babel-polyfill"</span>, resolve(<span class="string">'src/main.js'</span>)]</span><br><span class="line">        <span class="comment">//config.resolve.alias.set('@', resolve('src'))</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="走起"><a href="#走起" class="headerlink" title="走起"></a>走起</h3><p><img src="/2019/02/26/写一个webpack内联代码插件/1.jpg" alt=""><br><img src="/2019/02/26/写一个webpack内联代码插件/2.jpg" alt=""></p>
<h3 id="plugin和loader的区别是什么"><a href="#plugin和loader的区别是什么" class="headerlink" title="plugin和loader的区别是什么"></a>plugin和loader的区别是什么</h3><p>在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 【事件钩子】改变输出结果。</p>
<blockquote>
<p><font color="#ff0000">对于loader，它就是一个转换器【文件解析器】，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程 </font><br> </p>
</blockquote>
<blockquote>
<font color="#ff0000">plugin是一个扩展器，它丰富了wepack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务。 </font> 
</blockquote>
<p>webpack整个构建流程有许多钩子，开发者可以在指定的阶段加入自己的行为到webpack构建流程中。插件由以下构成:</p>
<ul>
<li>一个 JavaScript 命名函数。</li>
<li>在插件函数的 prototype 上定义一个 apply 方法。</li>
<li>指定一个绑定到 webpack 自身的事件钩子。</li>
<li>处理 webpack 内部实例的特定数据。</li>
<li>功能完成后调用 webpack 提供的回调。</li>
</ul>
<p>整个webpack流程由compiler和compilation构成,compiler只会创建一次，compilation如果开起了watch文件变化，那么会多次生成compilation.  </p>
<hr>
<h2 id="Webpack-Plugin原理"><a href="#Webpack-Plugin原理" class="headerlink" title="Webpack Plugin原理"></a>Webpack Plugin原理</h2><p>Webpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。<br>在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<p>一个最基础的 Plugin 的代码是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasicPlugin</span></span>&#123;</span><br><span class="line">  <span class="comment">// 在构造函数中获取用户给该插件传入的配置</span></span><br><span class="line">  <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象</span></span><br><span class="line">  apply(compiler)&#123;</span><br><span class="line">    compiler.plugin(<span class="string">'compilation'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出 Plugin</span></span><br><span class="line"><span class="built_in">module</span>.exports = BasicPlugin;</span><br></pre></td></tr></table></figure></p>
<p>在使用这个 Plugin 时，相关配置代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> BasicPlugin = <span class="built_in">require</span>(<span class="string">'./BasicPlugin.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> BasicPlugin(options),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Webpack 启动后，在读取配置的过程中会先执行 <code>new BasicPlugin(options)</code> 初始化一个 BasicPlugin 获得其实例。<br>在初始化 compiler 对象后，再调用 <code>basicPlugin.apply(compiler)</code> 给插件实例传入 compiler 对象。<br>插件实例在获取到 compiler 对象后，就可以通过 <code>compiler.plugin(事件名称, 回调函数)</code> 监听到 Webpack 广播出来的事件。<br>并且可以通过 compiler 对象去操作 Webpack。</p>
<p>通过以上最简单的 Plugin 相信你大概明白了 Plugin 的工作原理，但实际开发中还有很多细节需要注意，下面来详细介绍。</p>
<h2 id="Compiler-和-Compilation"><a href="#Compiler-和-Compilation" class="headerlink" title="Compiler 和 Compilation"></a>Compiler 和 Compilation</h2><p>在开发 Plugin 时最常用的两个对象就是 Compiler 和 Compilation，它们是 Plugin 和 Webpack 之间的桥梁。<br>Compiler 和 Compilation 的含义如下：</p>
<ul>
<li>Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例；</li>
<li>Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。</li>
</ul>
<p>Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。</p>
<h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。<br>这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。<br>插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。</p>
<p>Webpack 通过 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Ftapable" target="_blank" rel="noopener">Tapable</a> 来组织这条复杂的生产线。<br>Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。<br>Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p>
<p>Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。<br>Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 广播出事件</span></span><br><span class="line"><span class="comment">* event-name 为事件名称，注意不要和现有的事件重名</span></span><br><span class="line"><span class="comment">* params 为附带的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.apply(<span class="string">'event-name'</span>,params);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。</span></span><br><span class="line"><span class="comment">* 同时函数中的 params 参数为广播事件时附带的参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">compiler.plugin(<span class="string">'event-name'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同理，compilation.apply 和 compilation.plugin 使用方法和上面一致。</p>
<p>在开发插件时，你可能会不知道该如何下手，因为你不知道该监听哪个事件才能完成任务。</p>
<p>在开发插件时，还需要注意以下两点：</p>
<ul>
<li>只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。</li>
<li>传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。</li>
<li>有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  compiler.plugin(<span class="string">'emit'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">compilation, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 支持处理逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理完毕后执行 callback 以通知 Webpack </span></span><br><span class="line">  <span class="comment">// 如果不执行 callback，运行流程将会一直卡在这不往下执行 </span></span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><p>插件可以用来修改输出文件、增加输出文件、甚至可以提升 Webpack 性能、等等，总之插件通过调用 Webpack 提供的 API 能完成很多事情。<br>由于 Webpack 提供的 API 非常多，有很多 API 很少用的上，又加上篇幅有限，下面来介绍一些常用的 API。</p>
<h3 id="读取输出资源、代码块、模块及其依赖"><a href="#读取输出资源、代码块、模块及其依赖" class="headerlink" title="读取输出资源、代码块、模块及其依赖"></a>读取输出资源、代码块、模块及其依赖</h3><p>有些插件可能需要读取 Webpack 的处理结果，例如输出资源、代码块、模块及其依赖，以便做下一步处理。</p>
<p>在 <code>emit</code> 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。<br>插件代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// compilation.chunks 存放所有代码块，是一个数组</span></span><br><span class="line">      compilation.chunks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// chunk 代表一个代码块</span></span><br><span class="line">        <span class="comment">// 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块</span></span><br><span class="line">        chunk.forEachModule(<span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// module 代表一个模块</span></span><br><span class="line">          <span class="comment">// module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组</span></span><br><span class="line">          <span class="built_in">module</span>.fileDependencies.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filepath</span>) </span>&#123;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件</span></span><br><span class="line">        <span class="comment">// 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时，</span></span><br><span class="line">        <span class="comment">// 该 Chunk 就会生成 .js 和 .css 两个文件</span></span><br><span class="line">        chunk.files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// compilation.assets 存放当前所有即将输出的资源</span></span><br><span class="line">          <span class="comment">// 调用一个输出资源的 source() 方法能获取到输出资源的内容</span></span><br><span class="line">          <span class="keyword">let</span> source = compilation.assets[filename].source();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。</span></span><br><span class="line">      <span class="comment">// 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。</span></span><br><span class="line">      callback();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="监听文件变化"><a href="#监听文件变化" class="headerlink" title="监听文件变化"></a>监听文件变化</h3><p>在<a href="https://link.juejin.im?target=..%2F4%25E4%25BC%2598%25E5%258C%2596%2F4-5%25E4%25BD%25BF%25E7%2594%25A8%25E8%2587%25AA%25E5%258A%25A8%25E5%2588%25B7%25E6%2596%25B0.md" target="_blank" rel="noopener">4-5使用自动刷新</a> 中介绍过 Webpack 会从配置的入口模块出发，依次找出所有的依赖模块，当入口模块或者其依赖的模块发生变化时，<br>就会触发一次新的 Compilation。</p>
<p>在开发插件时经常需要知道是哪个文件发生变化导致了新的 Compilation，为此可以使用如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当依赖的文件发生变化时会触发 watch-run 事件</span></span><br><span class="line">compiler.plugin(<span class="string">'watch-run'</span>, (watching, callback) =&gt; &#123;</span><br><span class="line">	<span class="comment">// 获取发生变化的文件列表</span></span><br><span class="line">	<span class="keyword">const</span> changedFiles = watching.compiler.watchFileSystem.watcher.mtimes;</span><br><span class="line">	<span class="comment">// changedFiles 格式为键值对，键为发生变化的文件路径。</span></span><br><span class="line">	<span class="keyword">if</span> (changedFiles[filePath] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">	  <span class="comment">// filePath 对应的文件发生了变化</span></span><br><span class="line">	&#125;</span><br><span class="line">	callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。<br>由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。<br>为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'after-compile'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译</span></span><br><span class="line">	compilation.fileDependencies.push(filePath);</span><br><span class="line">	callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="修改输出资源"><a href="#修改输出资源" class="headerlink" title="修改输出资源"></a>修改输出资源</h3><p>有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 <code>emit</code> 事件，因为发生 <code>emit</code> 事件时所有模块的转换和代码块对应的文件已经生成好，<br>需要输出的资源即将输出，因此 <code>emit</code> 事件是修改 Webpack 输出资源的最后时机。</p>
<p>所有需要输出的资源会存放在 <code>compilation.assets</code> 中，<code>compilation.assets</code> 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。</p>
<p>设置 <code>compilation.assets</code> 的代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'emit'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 设置名称为 fileName 的输出资源</span></span><br><span class="line">  compilation.assets[fileName] = &#123;</span><br><span class="line">    <span class="comment">// 返回文件内容</span></span><br><span class="line">    source: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer</span></span><br><span class="line">      <span class="keyword">return</span> fileContent;</span><br><span class="line">  	&#125;,</span><br><span class="line">    <span class="comment">// 返回文件大小</span></span><br><span class="line">  	size: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Buffer.byteLength(fileContent, <span class="string">'utf8'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>读取 <code>compilation.assets</code> 的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'emit'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取名称为 fileName 的输出资源</span></span><br><span class="line">  <span class="keyword">const</span> asset = compilation.assets[fileName];</span><br><span class="line">  <span class="comment">// 获取输出资源的内容</span></span><br><span class="line">  asset.source();</span><br><span class="line">  <span class="comment">// 获取输出资源的文件大小</span></span><br><span class="line">  asset.size();</span><br><span class="line">  callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="判断-Webpack-使用了哪些插件"><a href="#判断-Webpack-使用了哪些插件" class="headerlink" title="判断 Webpack 使用了哪些插件"></a>判断 Webpack 使用了哪些插件</h3><p>在开发一个插件时可能需要根据当前配置是否使用了其它某个插件而做下一步决定，因此需要读取 Webpack 当前的插件配置情况。<br>以判断当前是否使用了 ExtractTextPlugin 为例，可以使用如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前配置使用使用了 ExtractTextPlugin，</span></span><br><span class="line"><span class="comment">// compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasExtractTextPlugin</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当前配置所有使用的插件列表</span></span><br><span class="line">  <span class="keyword">const</span> plugins = compiler.options.plugins;</span><br><span class="line">  <span class="comment">// 去 plugins 中寻找有没有 ExtractTextPlugin 的实例</span></span><br><span class="line">  <span class="keyword">return</span> plugins.find(<span class="function"><span class="params">plugin</span>=&gt;</span>plugin.__proto__.constructor === ExtractTextPlugin) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>下面我们举一个实际的例子，带你一步步去实现一个插件。</p>
<p>该插件的名称取名叫 EndWebpackPlugin，作用是在 Webpack 即将退出时再附加一些额外的操作，例如在 Webpack 成功编译和输出了文件后执行发布操作把输出的文件上传到服务器。<br>同时该插件还能区分 Webpack 构建是否执行成功。使用该插件时方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="comment">// 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数；</span></span><br><span class="line">    <span class="keyword">new</span> EndWebpackPlugin(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作</span></span><br><span class="line">    &#125;, (err) =&gt; &#123;</span><br><span class="line">      <span class="comment">// Webpack 构建失败，err 是导致错误的原因</span></span><br><span class="line">      <span class="built_in">console</span>.error(err);        </span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现该插件，需要借助两个事件：</p>
<ul>
<li><strong>done</strong>：在成功构建并且输出了文件后，Webpack 即将退出时发生；</li>
<li><strong>failed</strong>：在构建出现异常导致构建失败，Webpack 即将退出时发生；</li>
</ul>
<p>实现该插件非常简单，完整代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EndWebpackPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(doneCallback, failCallback) &#123;</span><br><span class="line">    <span class="comment">// 存下在构造函数中传入的回调函数</span></span><br><span class="line">    <span class="keyword">this</span>.doneCallback = doneCallback;</span><br><span class="line">    <span class="keyword">this</span>.failCallback = failCallback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.plugin(<span class="string">'done'</span>, (stats) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在 done 事件中回调 doneCallback</span></span><br><span class="line">        <span class="keyword">this</span>.doneCallback(stats);</span><br><span class="line">    &#125;);</span><br><span class="line">    compiler.plugin(<span class="string">'failed'</span>, (err) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 在 failed 事件中回调 failCallback</span></span><br><span class="line">        <span class="keyword">this</span>.failCallback(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出插件 </span></span><br><span class="line"><span class="built_in">module</span>.exports = EndWebpackPlugin;</span><br></pre></td></tr></table></figure>
<p>从开发这个插件可以看出，找到合适的事件点去完成功能在开发插件时显得尤为重要。</p>
<h2 id="输出打包文件列表"><a href="#输出打包文件列表" class="headerlink" title="输出打包文件列表"></a>输出打包文件列表</h2><p><img src="/2019/02/26/写一个webpack内联代码插件/3.jpg" alt=""><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> gzipSize = <span class="built_in">require</span>(<span class="string">'gzip-size'</span>);</span><br><span class="line"><span class="keyword">const</span> filesize = <span class="built_in">require</span>(<span class="string">'filesize'</span>);</span><br><span class="line"><span class="keyword">const</span> herb = <span class="built_in">require</span>(<span class="string">'herb'</span>);   <span class="comment">//表格输出</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">TablePlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(</span><br><span class="line">    options = &#123;</span><br><span class="line">      errorSize: <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">500</span></span><br><span class="line">    &#125;</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="keyword">const</span> errorSize = <span class="keyword">this</span>.options.errorSize;</span><br><span class="line">    <span class="keyword">const</span> beforeMsg = <span class="keyword">this</span>.options.beforeMsg;</span><br><span class="line">    <span class="keyword">const</span> afterMsg = <span class="keyword">this</span>.options.afterMsg;</span><br><span class="line">    compiler.hooks.done.tapPromise(<span class="string">'table-plugin'</span>, <span class="keyword">async</span> (stats) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (stats.hasErrors()) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">const</span> assets = stats.compilation.assets;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> gzipedSizes = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        <span class="built_in">Object</span>.keys(assets).map(<span class="keyword">async</span> (name) =&gt; &#123;</span><br><span class="line">        	<span class="built_in">console</span>.log(<span class="string">'--------------------------'</span>)</span><br><span class="line">          <span class="built_in">console</span>.log(name)</span><br><span class="line">          <span class="keyword">const</span> size = <span class="keyword">await</span> gzipSize(assets[name].source());</span><br><span class="line">          <span class="keyword">return</span> size;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> headers = [<span class="string">'asset'</span>, <span class="string">'size'</span>, <span class="string">'gziped'</span>];</span><br><span class="line">      <span class="keyword">const</span> rows = <span class="built_in">Object</span>.keys(assets).map(<span class="function">(<span class="params">name, i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> row = [name, filesize(assets[name].size()), filesize(gzipedSizes[i])];</span><br><span class="line">        <span class="keyword">if</span> (assets[name].size() &gt;= errorSize) &#123;</span><br><span class="line">          row = row.map(herb.red);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> row;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (beforeMsg) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(beforeMsg, <span class="string">'\n'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      herb.table(&#123;</span><br><span class="line">        headers,</span><br><span class="line">        rows,</span><br><span class="line">        borders: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">if</span> (afterMsg) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'\n'</span>, afterMsg);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="webpack原理"><a href="#webpack原理" class="headerlink" title="webpack原理"></a><a href="https://segmentfault.com/a/1190000015088834#articleHeader28" target="_blank" rel="noopener">webpack原理</a></h2><h2 id="webpack-loader和plugin编写"><a href="#webpack-loader和plugin编写" class="headerlink" title="webpack loader和plugin编写"></a><a href="https://juejin.im/post/5bbf190de51d450ea52fffd3#heading-1" target="_blank" rel="noopener">webpack loader和plugin编写</a></h2><h2 id="webpack-源码探索之插件机制"><a href="#webpack-源码探索之插件机制" class="headerlink" title="webpack 源码探索之插件机制"></a><a href="https://juejin.im/post/5a80e7fe6fb9a0633a70fe62" target="_blank" rel="noopener">webpack 源码探索之插件机制</a></h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/24/Puppeteer学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/24/Puppeteer学习/" itemprop="url">Puppeteer学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-24T20:00:54+08:00">
                2019-02-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Puppeteer-简介"><a href="#Puppeteer-简介" class="headerlink" title="Puppeteer 简介"></a>Puppeteer 简介</h2><p>Puppeteer 是一个node库，他提供了一组用来操纵Chrome的API, 通俗来说就是一个 headless chrome浏览器(当然你也可以配置成有UI的，默认是没有的)。既然是浏览器，那么我们手工可以在浏览器上做的事情 Puppeteer 都能胜任,另外，Puppeteer 翻译成中文是”木偶”意思，所以听名字就知道，操纵起来很方便，你可以很方便的操纵她去实现：</p>
<blockquote>
<p>1） 生成网页截图或者 PDF<br>2） 高级爬虫，可以爬取大量异步渲染内容的网页<br>3） 模拟键盘输入、表单自动提交、登录网页等，实现 UI 自动化测试<br>4） 捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题<br>5） 从网站抓取内容</p>
</blockquote>
<p>如果你用过 PhantomJS 的话，你会发现她们有点类似，但Puppeteer是Chrome官方团队进行维护的，用俗话说就是”有娘家的人“，前景更好。</p>
<h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><p>查看 Puppeteer 的官方 API 你会发现满屏的 async, await 之类，这些都是 ES7 的规范，所以你需要：</p>
<ol>
<li>Nodejs 的版本不能低于 v7.6.0, 需要支持 async, await.</li>
<li>需要最新的 chrome driver, 这个你在通过 npm 安装 Puppeteer 的时候系统会自动下载的</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm i puppeteer -D</span><br></pre></td></tr></table></figure>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先开看看官方的入门的 DEMO<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com/'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'baidu.png'</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>上面这段代码就实现了网页截图，先大概解读一下上面几行代码：</p>
<ol>
<li>先通过 puppeteer.launch() 创建一个浏览器实例 Browser 对象</li>
<li>然后通过 Browser 对象创建页面 Page 对象</li>
<li>然后 page.goto() 跳转到指定的页面</li>
<li>调用 page.screenshot() 对页面进行截图</li>
<li>关闭浏览器</li>
</ol>
<p>是不是觉得好简单？ 反正我是觉得比 PhantomJS 简单，至于跟 selenium-webdriver 比起来，<br>那更不用说了。下面就介绍一下 puppeteer 的常用的几个 API。</p>
<h2 id="puppeteer-launch-options"><a href="#puppeteer-launch-options" class="headerlink" title="puppeteer.launch(options)"></a>puppeteer.launch(options)</h2><p>使用 puppeteer.launch() 运行 puppeteer，它会 return 一个 promise，使用 then 方法获取 browser 实例， 当然高版本的<br>的 nodejs 已经支持 await 特性了，所以上面的例子使用 await 关键字，这一点需要特殊说明一下，<strong>Puppeteer 几乎所有的操作都是<br>异步的</strong>, 为了使用大量的 then 使得代码的可读性降低，本文所有 demo 代码都是用 <strong>async, await</strong> 方式实现。这个<br>也是 Puppeteer 官方推荐的写法。 </p>
<h3 id="options-参数详解"><a href="#options-参数详解" class="headerlink" title="options 参数详解"></a>options 参数详解</h3><p><img src="/2019/02/24/Puppeteer学习/1.jpg" alt=""></p>
<h2 id="Browser-对象"><a href="#Browser-对象" class="headerlink" title="Browser 对象"></a>Browser 对象</h2><p>当 Puppeteer 连接到一个 Chrome 实例的时候就会创建一个 Browser 对象，有以下两种方式：</p>
<p>Puppeteer.launch 和 Puppeteer.connect.</p>
<p>下面这个 DEMO 实现断开连接之后重新连接浏览器实例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="comment">// 保存 Endpoint，这样就可以重新连接  Chromium</span></span><br><span class="line">  <span class="keyword">const</span> browserWSEndpoint = browser.wsEndpoint();</span><br><span class="line">  <span class="comment">// 从Chromium 断开连接</span></span><br><span class="line">  browser.disconnect();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用endpoint 重新和 Chromiunm 建立连接</span></span><br><span class="line">  <span class="keyword">const</span> browser2 = <span class="keyword">await</span> puppeteer.connect(&#123;browserWSEndpoint&#125;);</span><br><span class="line">  <span class="comment">// Close Chromium</span></span><br><span class="line">  <span class="keyword">await</span> browser2.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Browser-对象-API"><a href="#Browser-对象-API" class="headerlink" title="Browser 对象 API"></a>Browser 对象 API</h3><p><img src="/2019/02/24/Puppeteer学习/2.png" alt=""></p>
<h2 id="Puppeteer-实战"><a href="#Puppeteer-实战" class="headerlink" title="Puppeteer 实战"></a>Puppeteer 实战</h2><p>了解 API 之后我们就可以来一些实战了，在此之前，我们先了解一下 Puppeteer 的设计原理，简单来说 Puppeteer 跟 webdriver 以及 PhantomJS 最大的<br>的不同就是它是站在用户浏览的角度，而 webdriver 和 PhantomJS 最初设计就是用来做自动化测试的，所以它是站在机器浏览的角度来设计的，所以它们<br>使用的是不同的设计哲学。举个栗子，加入我需要打开京东的首页并进行一次产品搜索，分别看看使用 Puppeteer 和 webdriver 的实现流程：</p>
<p><strong>Puppeteer 的实现流程：</strong></p>
<ol>
<li>打开京东首页</li>
<li>将光标 focus 到搜索输入框</li>
<li>键盘点击输入文字</li>
<li>点击搜索按钮</li>
</ol>
<p><strong>webdriver 的实现流程：</strong></p>
<ol>
<li>打开京东首页</li>
<li>找到输入框的 input 元素</li>
<li>设置 input 的值为要搜索文字</li>
<li>触发搜索按钮的单机事件</li>
</ol>
<p>个人感觉 Puppeteer 设计哲学更符合任何的操作习惯，更自然一些。</p>
<p>下面我们就用一个简单的需求实现来进行 Puppeteer 的入门学习。这个简单的需求就是：</p>
<blockquote>
<p>在京东商城抓取10个手机商品，并把商品的详情页截图。</p>
</blockquote>
<p>首先我们来梳理一下操作流程</p>
<ol>
<li>打开京东首页</li>
<li>输入“手机”关键字并搜索</li>
<li>获取前10个商品的 A 标签，并获取 href 属性值，获取商品详情链接</li>
<li>分别打开10个商品的详情页，截取网页图片</li>
</ol>
<p>要实现上面的功能需要用到查找元素，获取属性，键盘事件等，那接下来我们就一个一个的讲解一下。</p>
<h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><p>Page 对象提供了2个 API 来获取页面元素</p>
<p>(1). Page.$(selector) 获取单个元素，底层是调用的是 document.querySelector() , 所以选择器的 selector 格式遵循 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors" target="_blank" rel="noopener">css 选择器规范</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> inputElement = <span class="keyword">await</span> page.$(<span class="string">"#search"</span>, input =&gt; input);</span><br><span class="line"><span class="comment">//下面写法等价</span></span><br><span class="line"><span class="keyword">let</span> inputElement = <span class="keyword">await</span> page.$(<span class="string">'#search'</span>);</span><br></pre></td></tr></table></figure>
<p>(2). Page.$$(selector) 获取一组元素，底层调用的是 document.querySelectorAll(). 返回 Promise(Array(ElemetHandle)) 元素数组.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> links = <span class="keyword">await</span> page.$$(<span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//下面写法等价</span></span><br><span class="line"><span class="keyword">const</span> links = <span class="keyword">await</span> page.$$(<span class="string">"a"</span>, links =&gt; links);</span><br></pre></td></tr></table></figure>
<p>最终返回的都是 ElemetHandle 对象</p>
<h3 id="获取元素属性"><a href="#获取元素属性" class="headerlink" title="获取元素属性"></a>获取元素属性</h3><p>Puppeteer 获取元素属性跟我们平时写前段的js的逻辑有点不一样，按照通常的逻辑，应该是现获取元素，然后在获取元素的属性。但是上面我们知道<br>获取元素的 API 最终返回的都是 ElemetHandle 对象，而你去查看 ElemetHandle 的 API 你会发现，它并没有获取元素属性的 API.</p>
<p>事实上 Puppeteer 专门提供了一套获取属性的 API， Page.$eval() 和 Page.$$eval()</p>
<p>(1). Page.$$eval(selector, pageFunction[, …args]), 获取单个元素的属性，这里的选择器 selector 跟上面 Page.$(selector) 是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'input[name=search]'</span>, input =&gt; input.value);</span><br><span class="line"><span class="keyword">const</span> href = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'#a", ele =&gt; ele.href);</span></span><br><span class="line"><span class="string">const content = await page.$eval('</span>.content<span class="string">', ele =&gt; ele.outerHTML);</span></span><br></pre></td></tr></table></figure>
<h3 id="执行自定义的-JS-脚本"><a href="#执行自定义的-JS-脚本" class="headerlink" title="执行自定义的 JS 脚本"></a>执行自定义的 JS 脚本</h3><p>Puppeteer 的 Page 对象提供了一系列 evaluate 方法，你可以通过他们来执行一些自定义的 js 代码，主要提供了下面三个 API</p>
<blockquote>
<p>(1). page.evaluate(pageFunction, …args) 返回一个可序列化的普通对象，pageFunction 表示要在页面执行的函数，<br>args 表示传入给 pageFunction 的参数， 下面的 pageFunction 和 args 表示同样的意思。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">8</span> * <span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// prints "56"</span></span><br></pre></td></tr></table></figure>
<p>这个方法很有用，比如我们在获取页面的截图的时候，默认是只截图当前浏览器窗口的尺寸大小，默认值是800x600，那如果我们需要获取整个网页的完整<br>截图是没办法办到的。Page.screenshot() 方法提供了可以设置截图区域大小的参数，那么我们只要在页面加载完了之后获取页面的宽度和高度就可以解决<br>这个问题了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">	<span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">	<span class="keyword">await</span> page.goto(<span class="string">'https://jr.dayi35.com'</span>);</span><br><span class="line">	<span class="keyword">await</span> page.setViewport(&#123;<span class="attr">width</span>:<span class="number">1920</span>, <span class="attr">height</span>:<span class="number">1080</span>&#125;);</span><br><span class="line">	<span class="keyword">const</span> documentSize = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">			height : <span class="built_in">document</span>.body.clientHeight,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>:<span class="string">"example.png"</span>, <span class="attr">clip</span> : &#123;<span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span>, <span class="attr">width</span>:<span class="number">1920</span>, <span class="attr">height</span>:documentSize.height&#125;&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(2). Page.evaluateHandle(pageFunction, …args) 在 Page 上下文执行一个 pageFunction, 返回 JSHandle 实体</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aWindowHandle = <span class="keyword">await</span> page.evaluateHandle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="built_in">window</span>));</span><br><span class="line">aWindowHandle; <span class="comment">// Handle for the window object. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aHandle = <span class="keyword">await</span> page.evaluateHandle(<span class="string">'document'</span>); <span class="comment">// Handle for the 'document'.</span></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，page.evaluateHandle() 方法也是通过 Promise.resolve 方法直接把 Promise 的最终处理结果返回，<br>只不过把最后返回的对象封装成了 JSHandle 对象。本质上跟 evaluate 没有什么区别。</p>
<p>下面这段代码实现获取页面的动态（包括js动态插入的元素） HTML 代码.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aHandle = <span class="keyword">await</span> page.evaluateHandle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.body);</span><br><span class="line"><span class="keyword">const</span> resultHandle = <span class="keyword">await</span> page.evaluateHandle(<span class="function"><span class="params">body</span> =&gt;</span> body.innerHTML, aHandle);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> resultHandle.jsonValue());</span><br><span class="line"><span class="keyword">await</span> resultHandle.dispose();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>(3). page.evaluateOnNewDocument(pageFunction, …args), 在文档页面载入前调用 pageFunction, 如果页面中有 iframe 或者 frame, 则函数调用<br>的上下文环境将变成子页面的，即iframe 或者 frame, 由于是在页面加载前调用，这个函数一般是用来初始化 javascript 环境的，比如重置或者<br>初始化一些全局变量。</p>
</blockquote>
<h3 id="Page-exposeFunction"><a href="#Page-exposeFunction" class="headerlink" title="Page.exposeFunction"></a>Page.exposeFunction</h3><p>除此上面三个 API 之外，还有一类似的非常有用的 API， 那就是 <strong>Page.exposeFunction</strong>，这个 API 用来在页面注册全局函数，非常有用：</p>
<p>因为有时候需要在页面处理一些操作的时候需要用到一些函数，虽然可以通过 Page.evaluate() API 在页面定义函数，比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> docSize = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getPageSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">			height : <span class="built_in">document</span>.body.clientHeight,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> getPageSize();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是这样的函数不是全局的，需要在每个 evaluate 中去重新定义，无法做到代码复用，在一个就是 nodejs 有很多工具包可以很轻松的实现很复杂的功能<br>比如要实现 md5 加密函数，这个用纯 js 去实现就不太方便了，而用 nodejs 却是几行代码的事情。</p>
<p>下面代码实现给 Page 上下文的 window 对象添加 md5 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  page.on(<span class="string">'console'</span>, msg =&gt; <span class="built_in">console</span>.log(msg.text));</span><br><span class="line">  <span class="keyword">await</span> page.exposeFunction(<span class="string">'md5'</span>, text =&gt;</span><br><span class="line">    crypto.createHash(<span class="string">'md5'</span>).update(text).digest(<span class="string">'hex'</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// use window.md5 to compute hashes</span></span><br><span class="line">    <span class="keyword">const</span> myString = <span class="string">'PUPPETEER'</span>;</span><br><span class="line">    <span class="keyword">const</span> myHash = <span class="keyword">await</span> <span class="built_in">window</span>.md5(myString);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`md5 of <span class="subst">$&#123;myString&#125;</span> is <span class="subst">$&#123;myHash&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看出，Page.exposeFunction API 使用起来是很方便的，也非常有用，在比如给 window 对象注册 readfile 全局函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  page.on(<span class="string">'console'</span>, msg =&gt; <span class="built_in">console</span>.log(msg.text));</span><br><span class="line">  <span class="keyword">await</span> page.exposeFunction(<span class="string">'readfile'</span>, <span class="keyword">async</span> filePath =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fs.readFile(filePath, <span class="string">'utf8'</span>, (err, text) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">          reject(err);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          resolve(text);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// use window.readfile to read contents of a file</span></span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">await</span> <span class="built_in">window</span>.readfile(<span class="string">'/etc/hosts'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(content);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Page-emulate-修改模拟器-客户端-运行配置"><a href="#Page-emulate-修改模拟器-客户端-运行配置" class="headerlink" title="Page.emulate 修改模拟器(客户端)运行配置"></a>Page.emulate 修改模拟器(客户端)运行配置</h2><p>Puppeteer 提供了一些 API 供我们修改浏览器终端的配置</p>
<ol>
<li>Page.setViewport() 修改浏览器视窗大小</li>
<li>Page.setUserAgent() 设置浏览器的 UserAgent 信息</li>
<li>Page.emulateMedia() 更改页面的CSS媒体类型，用于进行模拟媒体仿真。可选值为 “screen”, “print”, “null”, 如果设置为 null 则表示禁用媒体仿真。</li>
<li>Page.emulate() 模拟设备，参数设备对象，比如 iPhone, Mac, Android 等</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">page.setViewport(&#123;<span class="attr">width</span>:<span class="number">1920</span>, <span class="attr">height</span>:<span class="number">1080</span>&#125;); <span class="comment">//设置视窗大小为 1920x1080</span></span><br><span class="line">page.setUserAgent(<span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36'</span>);</span><br><span class="line">page.emulateMedia(<span class="string">'print'</span>); <span class="comment">//设置打印机媒体样式</span></span><br></pre></td></tr></table></figure>
<p>除此之外我们还可以模拟非 PC 机设备, 比如下面这段代码模拟 iPhone 6 访问google：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> devices = <span class="built_in">require</span>(<span class="string">'puppeteer/DeviceDescriptors'</span>);</span><br><span class="line"><span class="keyword">const</span> iPhone = devices[<span class="string">'iPhone 6'</span>];</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.emulate(iPhone);</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.google.com'</span>);</span><br><span class="line">  <span class="comment">// other actions...</span></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Puppeteer 支持很多设备模拟仿真，比如Galaxy, iPhone, IPad 等，想要知道详细设备支持，请戳这里 <a href="https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js" target="_blank" rel="noopener">DeviceDescriptors.js.</a></p>
<h2 id="键盘和鼠标"><a href="#键盘和鼠标" class="headerlink" title="键盘和鼠标"></a>键盘和鼠标</h2><p>键盘和鼠标的API比较简单，键盘的几个API如下：</p>
<ul>
<li>keyboard.down(key[, options]) 触发 keydown 事件</li>
<li>keyboard.press(key[, options]) 按下某个键，key 表示键的名称，比如 ‘ArrowLeft’ 向左键，详细的键名映射请<a href="https://github.com/GoogleChrome/puppeteer/blob/master/lib/USKeyboardLayout.js" target="_blank" rel="noopener">戳这里</a></li>
<li>keyboard.sendCharacter(char) 输入一个字符</li>
<li>keyboard.type(text, options) 输入一个字符串</li>
<li>keyboard.up(key) 触发 keyup 事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">page.keyboard.press(<span class="string">"Shift"</span>); <span class="comment">//按下 Shift 键</span></span><br><span class="line">page.keyboard.sendCharacter(<span class="string">'嗨'</span>);</span><br><span class="line">page.keyboard.type(<span class="string">'Hello'</span>); <span class="comment">// 一次输入完成</span></span><br><span class="line">page.keyboard.type(<span class="string">'World'</span>, &#123;<span class="attr">delay</span>: <span class="number">100</span>&#125;); <span class="comment">// 像用户一样慢慢输入</span></span><br></pre></td></tr></table></figure>
<p>鼠标操作:</p>
<ul>
<li>mouse.click(x, y, [options]) 移动鼠标指针到指定的位置，然后按下鼠标，这个其实 mouse.move 和 mouse.down 或 mouse.up 的快捷操作</li>
<li>mouse.down([options]) 触发 mousedown 事件，options 可配置:<ul>
<li>options.button 按下了哪个键，可选值为[left, right, middle], 默认是 left, 表示鼠标左键</li>
<li>options.clickCount 按下的次数，单击，双击或者其他次数</li>
<li>delay 按键延时时间</li>
</ul>
</li>
<li>mouse.move(x, y, [options]) 移动鼠标到指定位置， options.steps 表示移动的步长</li>
<li>mouse.up([options]) 触发 mouseup 事件</li>
</ul>
<h2 id="另外几个有用的-API"><a href="#另外几个有用的-API" class="headerlink" title="另外几个有用的 API"></a>另外几个有用的 API</h2><p>Puppeteer 还提供几个非常有用的 API， 比如：</p>
<h3 id="Page-waitFor-系列-API"><a href="#Page-waitFor-系列-API" class="headerlink" title="Page.waitFor 系列 API"></a>Page.waitFor 系列 API</h3><ul>
<li>page.waitFor(selectorOrFunctionOrTimeout[, options[, …args]]) 下面三个的综合 API</li>
<li>page.waitForFunction(pageFunction[, options[, …args]]) 等待 pageFunction 执行完成之后</li>
<li>page.waitForNavigation(options) 等待页面基本元素加载完之后，比如同步的 HTML, CSS, JS 等代码</li>
<li>page.waitForSelector(selector[, options]) 等待某个选择器的元素加载之后，这个元素可以是异步加载的，这个 API 非常有用，你懂的。</li>
</ul>
<p>比如我想获取某个通过 js 异步加载的元素，那么直接获取肯定是获取不到的。这个时候就可以使用 page.waitForSelector 来解决：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">'.gl-item'</span>); <span class="comment">//等待元素加载之后，否则获取不到异步加载的元素</span></span><br><span class="line"><span class="keyword">const</span> links = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'.gl-item &gt; .gl-i-wrap &gt; .p-img &gt; a'</span>, links =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> links.map(<span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			href: a.href.trim(),</span><br><span class="line">			name: a.title</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实上面的代码就可以解决我们最上面的需求，抓取京东的产品，因为是异步加载的，所以使用这种方式。</p>
<h3 id="page-getMetrics"><a href="#page-getMetrics" class="headerlink" title="page.getMetrics()"></a>page.getMetrics()</h3><p>通过 page.getMetrics() 可以得到一些页面性能数据， 捕获网站的时间线跟踪，以帮助诊断性能问题。</p>
<ul>
<li>Timestamp 度量标准采样的时间戳</li>
<li>Documents 页面文档数</li>
<li>Frames 页面 frame 数</li>
<li>JSEventListeners 页面内事件监听器数</li>
<li>Nodes 页面 DOM 节点数</li>
<li>LayoutCount 页面布局总数</li>
<li>RecalcStyleCount 样式重算数</li>
<li>LayoutDuration 所有页面布局的合并持续时间</li>
<li>RecalcStyleDuration 所有页面样式重新计算的组合持续时间。</li>
<li>ScriptDuration 所有脚本执行的持续时间</li>
<li>TaskDuration 所有浏览器任务时长</li>
<li>JSHeapUsedSize JavaScript 占用堆大小</li>
<li>JSHeapTotalSize JavaScript 堆总量</li>
</ul>
<h2 id="总结和源码"><a href="#总结和源码" class="headerlink" title="总结和源码"></a>总结和源码</h2><p>本文通过一个实际需求来学习了 Puppeteer 的一些基本的常用的 API， API 的版本是 v0.13.0-alpha. 最新邦本的 API 请参考<br><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" target="_blank" rel="noopener">Puppeteer 官方API</a>.</p>
<p>总的来说，Puppeteer 真是一款不错的 headless 工具，操作简单，功能强大。用来做UI自动化测试，和一些小工具都是很不错的。</p>
<p>下面贴上我们开始的需求实现源码，仅供参考：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				resolve(<span class="number">1</span>)</span><br><span class="line">			&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">				reject(<span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, delay)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line">puppeteer.launch(&#123;</span><br><span class="line">	ignoreHTTPSErrors:<span class="literal">true</span>, </span><br><span class="line">	headless:<span class="literal">false</span>,<span class="attr">slowMo</span>:<span class="number">250</span>, </span><br><span class="line">	timeout:<span class="number">0</span>&#125;).then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">	<span class="keyword">await</span> page.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">await</span> page.goto(<span class="string">"https://www.jd.com/"</span>);</span><br><span class="line">	<span class="keyword">const</span> searchInput = <span class="keyword">await</span> page.$(<span class="string">"#key"</span>);</span><br><span class="line">	<span class="keyword">await</span> searchInput.focus(); <span class="comment">//定位到搜索框</span></span><br><span class="line">	<span class="keyword">await</span> page.keyboard.type(<span class="string">"手机"</span>);</span><br><span class="line">	<span class="keyword">const</span> searchBtn = <span class="keyword">await</span> page.$(<span class="string">".button"</span>);</span><br><span class="line">	<span class="keyword">await</span> searchBtn.click();</span><br><span class="line">	<span class="keyword">await</span> page.waitForSelector(<span class="string">'.gl-item'</span>); <span class="comment">//等待元素加载之后，否则获取不异步加载的元素</span></span><br><span class="line">	<span class="keyword">const</span> links = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'.gl-item &gt; .gl-i-wrap &gt; .p-img &gt; a'</span>, links =&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> links.map(<span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				href: a.href.trim(),</span><br><span class="line">				title: a.title</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">	page.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> aTags = links.splice(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; aTags.length; i++) &#123;</span><br><span class="line">		page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">		page.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">await</span> page.setViewport(&#123;<span class="attr">width</span>:<span class="number">1920</span>, <span class="attr">height</span>:<span class="number">1080</span>&#125;);</span><br><span class="line">		<span class="keyword">var</span> a = aTags[i];</span><br><span class="line">		<span class="keyword">await</span> page.goto(a.href, &#123;<span class="attr">timeout</span>:<span class="number">0</span>&#125;); <span class="comment">//防止页面太长，加载超时</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//注入代码，慢慢把滚动条滑到最底部，保证所有的元素被全部加载</span></span><br><span class="line">		<span class="keyword">let</span> scrollEnable = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">let</span> scrollStep = <span class="number">500</span>; <span class="comment">//每次滚动的步长</span></span><br><span class="line">		<span class="keyword">while</span> (scrollEnable) &#123;</span><br><span class="line">			scrollEnable = <span class="keyword">await</span> page.evaluate(<span class="function">(<span class="params">scrollStep</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.scrollingElement.scrollTop;</span><br><span class="line">				<span class="built_in">document</span>.scrollingElement.scrollTop = scrollTop + scrollStep;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">document</span>.body.clientHeight &gt; scrollTop + <span class="number">1080</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">			&#125;, scrollStep);</span><br><span class="line">			<span class="keyword">await</span> sleep(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">await</span> page.waitForSelector(<span class="string">"#footer-2014"</span>, &#123;<span class="attr">timeout</span>:<span class="number">0</span>&#125;); <span class="comment">//判断是否到达底部了</span></span><br><span class="line">		<span class="keyword">let</span> filename = <span class="string">"images/items-"</span>+i+<span class="string">".png"</span>;</span><br><span class="line">		<span class="comment">//这里有个Puppeteer的bug一直没有解决，发现截图的高度最大只能是16384px， 超出部分被截掉了。</span></span><br><span class="line">		<span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>:filename, <span class="attr">fullPage</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">		page.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="测试网页性能performance"><a href="#测试网页性能performance" class="headerlink" title="测试网页性能performance"></a>测试网页性能performance</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);　</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"></span><br><span class="line">　</span><br><span class="line"><span class="comment">//(async() =&gt; &#123;　　</span></span><br><span class="line"><span class="comment">//	const browser = await puppeteer.launch(&#123; headless: true &#125;);　　</span></span><br><span class="line"><span class="comment">//	const page = await browser.newPage();　　</span></span><br><span class="line"><span class="comment">//	await page.setViewport(&#123; width: 2000, height: 800, &#125;);   //修改浏览器视窗大小</span></span><br><span class="line"><span class="comment">//	await page.goto('https://www.baidu.com/');</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	await page.focus("#kw");</span></span><br><span class="line"><span class="comment">//  await page.keyboard.sendCharacter('123');</span></span><br><span class="line"><span class="comment">//  await page.waitFor(".s_search");</span></span><br><span class="line"><span class="comment">//  await page.click(".s_search");</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	console.log('123');</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	page.on("load", async () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//		const performanceTiming = JSON.parse(　　</span></span><br><span class="line"><span class="comment">//			await page.evaluate(() =&gt; JSON.stringify(window.peformance.timing))　　</span></span><br><span class="line"><span class="comment">//		);　　</span></span><br><span class="line"><span class="comment">//		console.log(performanceTiming);</span></span><br><span class="line"><span class="comment">//		 </span></span><br><span class="line"><span class="comment">//	&#125;);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	page.on('pageCreated', async (page) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		console.log('pageCreated')</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//       const performanceTiming = JSON.parse(　　</span></span><br><span class="line"><span class="comment">//			await page.evaluate(() =&gt; JSON.stringify(window.peformance.timing))　　</span></span><br><span class="line"><span class="comment">//		);　　</span></span><br><span class="line"><span class="comment">//		console.log(performanceTiming);</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"><span class="comment">//  page.on('perf',async (page) =&gt;   &#123;</span></span><br><span class="line"><span class="comment">//  	</span></span><br><span class="line"><span class="comment">//  	console.log('perf')</span></span><br><span class="line"><span class="comment">//  	</span></span><br><span class="line"><span class="comment">//      const performanceTiming = JSON.parse(　　</span></span><br><span class="line"><span class="comment">//			await page.evaluate(() =&gt; JSON.stringify(window.peformance.timing))　　</span></span><br><span class="line"><span class="comment">//		);　　</span></span><br><span class="line"><span class="comment">//		console.log(performanceTiming);</span></span><br><span class="line"><span class="comment">//  &#125;);</span></span><br><span class="line"><span class="comment">//  page.on('metrics',async (page) =&gt;   &#123;</span></span><br><span class="line"><span class="comment">//  	</span></span><br><span class="line"><span class="comment">//  	console.log('metrics')</span></span><br><span class="line"><span class="comment">//  	</span></span><br><span class="line"><span class="comment">//      const performanceTiming = JSON.parse(　　</span></span><br><span class="line"><span class="comment">//			await page.evaluate(() =&gt; JSON.stringify(window.peformance.timing))　　</span></span><br><span class="line"><span class="comment">//		);　　</span></span><br><span class="line"><span class="comment">//		console.log(performanceTiming);</span></span><br><span class="line"><span class="comment">//  &#125;);　　　　</span></span><br><span class="line"><span class="comment">//&#125;)();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> extractDataFromPerformanceTiming = <span class="function">(<span class="params">timing, ...dataNames</span>) =&gt;</span> &#123;　　</span><br><span class="line">	<span class="keyword">const</span> navigationStart = timing.navigationStart;　　</span><br><span class="line">	<span class="keyword">const</span> extractedData = &#123;&#125;;　　</span><br><span class="line">	dataNames.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;　　</span><br><span class="line">		extractedData[name] = timing[name] - navigationStart;　　</span><br><span class="line">	&#125;);　　</span><br><span class="line">	<span class="keyword">return</span> extractedData;　　</span><br><span class="line">&#125;;　　</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testPage</span>(<span class="params">page</span>) </span>&#123;　　</span><br><span class="line">	<span class="keyword">await</span> page.goto(<span class="string">"https://www.cnblogs.com"</span>);　</span><br><span class="line">	<span class="keyword">const</span> performanceTiming = <span class="built_in">JSON</span>.parse(<span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">JSON</span>.stringify(<span class="built_in">window</span>.performance.timing)));　　</span><br><span class="line">	<span class="keyword">return</span> extractDataFromPerformanceTiming(</span><br><span class="line">		performanceTiming,</span><br><span class="line">		<span class="string">'domainLookupStart'</span>, <span class="comment">// dns开始</span></span><br><span class="line">		<span class="string">'domainLookupEnd'</span>, <span class="comment">// dns结束</span></span><br><span class="line">		<span class="string">'connectStart'</span>, <span class="comment">// tcp开始</span></span><br><span class="line">		<span class="string">'connectEnd'</span>, <span class="comment">// tcp结束</span></span><br><span class="line">		<span class="string">'responseStart'</span>, <span class="comment">// ttfb，time to first byte，首字节抵达</span></span><br><span class="line">		<span class="string">'responseEnd'</span>, <span class="comment">// 最后一个字节抵达</span></span><br><span class="line">		<span class="string">'domLoading'</span>, <span class="comment">// dom 开始解析，即Document.readyState属性变为“loading”、相应的readystatechange事件触发</span></span><br><span class="line">		<span class="string">'domInteractive'</span>, <span class="comment">// 文档完成解析，但是诸如图像，样式表和框架之类的子资源仍在加载。即Document.readyState属性变为“interactive”、相应的readystatechange事件触发</span></span><br><span class="line">		<span class="string">'domContentLoadedEventStart'</span>, <span class="comment">// DOMContentLoaded 事件触发，即所有需要被执行的脚本已经被解析</span></span><br><span class="line">		<span class="string">'domContentLoadedEventEnd'</span>, <span class="comment">// 所有需要立即执行的脚本已经被执行</span></span><br><span class="line">		<span class="string">'domComplete'</span>, <span class="comment">// 文档和所有子资源已完成加载，即Document.readyState变为 'complete'且相对应的readystatechange 被触发，load 事件即将被触发</span></span><br><span class="line">		<span class="string">'loadEventStart'</span>, <span class="comment">// 文档触发load事件的时间。如果load事件没有触发，那么该接口就返回0</span></span><br><span class="line">		<span class="string">'loadEventEnd'</span> <span class="comment">// 文档触发load事件结束后的时间。如果load事件没有触发，那么该接口就返回0</span></span><br><span class="line">	);　　</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRequestCount</span>(<span class="params">page</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> res = &#123;</span><br><span class="line">		post: <span class="number">0</span>,</span><br><span class="line">		get: <span class="number">0</span>,</span><br><span class="line">		js: <span class="number">0</span>,</span><br><span class="line">		css: <span class="number">0</span></span><br><span class="line">	&#125;;</span><br><span class="line">	page.on(<span class="string">'request'</span>, request =&gt; &#123;</span><br><span class="line">		<span class="keyword">const</span> method = request.method();</span><br><span class="line">		<span class="keyword">const</span> pathname = url.parse(request.url()).pathname;</span><br><span class="line">		<span class="keyword">if</span>(method === <span class="string">'GET'</span>) &#123;</span><br><span class="line">			res.get++;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">			res.post++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(pathname.endsWith(<span class="string">'.js'</span>)) &#123;</span><br><span class="line">			res.js++;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pathname.endsWith(<span class="string">'.css'</span>)) &#123;</span><br><span class="line">			res.css++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">		page.on(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">			resolve(res);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span>() =&gt; &#123;　　</span><br><span class="line">	<span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();　　</span><br><span class="line">	<span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> res = &#123;</span><br><span class="line">		post: <span class="number">0</span>,</span><br><span class="line">		get: <span class="number">0</span>,</span><br><span class="line">		js: <span class="number">0</span>,</span><br><span class="line">		css: <span class="number">0</span></span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	page.on('load',async () =&gt; &#123;</span></span><br><span class="line"><span class="comment">//		console.log("222222")</span></span><br><span class="line"><span class="comment">//		console.log(res)</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		//await browser.close();</span></span><br><span class="line"><span class="comment">//	&#125;);</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//	page.on('request', request =&gt; &#123;</span></span><br><span class="line"><span class="comment">//		console.log("1111")</span></span><br><span class="line"><span class="comment">//		const method = request.method();</span></span><br><span class="line"><span class="comment">//		const pathname = url.parse(request.url()).pathname;</span></span><br><span class="line"><span class="comment">//		if(method === 'GET') &#123;</span></span><br><span class="line"><span class="comment">//			res.get++;</span></span><br><span class="line"><span class="comment">//		&#125; else if(method === 'POST') &#123;</span></span><br><span class="line"><span class="comment">//			res.post++;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		if(pathname.endsWith('.js')) &#123;</span></span><br><span class="line"><span class="comment">//			res.js++;</span></span><br><span class="line"><span class="comment">//		&#125; else if(pathname.endsWith('.css')) &#123;</span></span><br><span class="line"><span class="comment">//			res.css++;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;);</span></span><br><span class="line">	</span><br><span class="line">	　　</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">await</span> testPage(page));</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">await</span> getRequestCount(page));</span><br><span class="line">	<span class="keyword">await</span> browser.close();　　</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/18/用keep-alive优化页面性能/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/18/用keep-alive优化页面性能/" itemprop="url">用keep-alive优化页面性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-18T21:35:00+08:00">
                2019-02-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h2><p>keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，从而节省性能，由于是一个抽象组件，所以在v页面渲染完毕后不会被渲染成一个DOM元素<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//keep-alive 用来缓存组件,避免多次加载相应的组件,减少性能消耗</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;keep-alive&gt;</span><br><span class="line">      &lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>&lt;keep-alive&gt;</code>包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</keep-alive></transition></p>
</li>
<li><p>keep-alive内被切换时组件的activated、deactivated这两个生命周期钩子函数会被执行</p>
</li>
<li>被包裹在keep-alive中的组件的状态将会被保留，例如我们将某个列表类组件内容滑动到第10条位置，那么我们在切换到一个组件后再次切换回到该组件，该组件的位置状态依旧会保持在第10条列表处.</li>
</ul>
<p>我们在创建一个router实例的时候，可以提供一个scrollBehavior方法，该方法会在用户切换路由时触发<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router=<span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">        routes:[</span><br><span class="line">            &#123;</span><br><span class="line">                path:<span class="string">"/"</span>,</span><br><span class="line">                component:Home</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        scrollBehavior(to,form,savedPosition)&#123;</span><br><span class="line">        <span class="comment">//scrollBehavior方法接收to，form路由对象</span></span><br><span class="line">        <span class="comment">//第三个参数savedPosition当且仅当在浏览器前进后退按钮触发时才可用</span></span><br><span class="line">        <span class="comment">//该方法会返回滚动位置的对象信息，如果返回false，或者是一个空的对象，那么不会发生滚动</span></span><br><span class="line">        <span class="comment">//我们可以在该方法中设置返回值来指定页面的滚动位置，例如：</span></span><br><span class="line">         <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;</span><br><span class="line">        <span class="comment">//表示在用户切换路由时让是所有页面都返回到顶部位置</span></span><br><span class="line">        <span class="comment">//如果返回savedPosition,那么在点击后退按钮时就会表现的像原生浏览器一样，返回的页面会滚动过到之前按钮点击跳转的位置，大概写法如下：</span></span><br><span class="line">         <span class="keyword">if</span>(savedPosition)&#123;</span><br><span class="line">            <span class="keyword">return</span> savedPosition</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果想要模拟滚动到锚点的行为:</span></span><br><span class="line">         <span class="keyword">if</span>(to.hash)&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">             selector:to.hash</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>还有一个方法就是利用我们上面说过的，在keep-alive激活会触发activated钩子函数，那么在该函数内设置scrollTop为0<br>被keep-alive包裹的动态组件或router-view会缓存不活动的实例，再次被调用这些被缓存的实例会被再次复用，对于我们的某些不是需要实时更新的页面来说大大减少了性能上的消耗，不需要再次发送HTTP请求，但是同样也存在一个问题就是被keep-alive包裹的组件我们请求获取的数据不会再重新渲染页面，这也就出现了例如我们使用动态路由做匹配的话页面只会保持第一次请求数据的渲染结果，所以需要我们在特定的情况下强制刷新某些组件</p>
<h2 id="利用include、exclude属性"><a href="#利用include、exclude属性" class="headerlink" title="利用include、exclude属性"></a>利用include、exclude属性</h2><blockquote>
<p>prop:</p>
</blockquote>
<ul>
<li>include: 字符串或正则表达式。只有匹配的组件会被缓存，keep-alive组件激活时调用。</li>
<li>exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存，组件停用时调用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive include=<span class="string">"bookLists,bookLists"</span>&gt;</span><br><span class="line">      &lt;router-view&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line">&lt;keep-alive exclude="indexLists"&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>
<p>include属性表示只有name属性为bookLists，bookLists的组件会被缓存，（注意是组件的名字，不是路由的名字）其它组件不会被缓存exclude属性表示除了name属性为indexLists的组件不会被缓存，其它组件都会被缓存<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用meta属性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>[</span><br><span class="line"> &#123;</span><br><span class="line">  path:<span class="string">'/'</span>,</span><br><span class="line">  name:<span class="string">'home'</span>,</span><br><span class="line">  components:Home,</span><br><span class="line">  meta:&#123;</span><br><span class="line">    keepAlive:<span class="literal">true</span> <span class="comment">//需要被缓存的组件</span></span><br><span class="line"> &#125;,</span><br><span class="line"> &#123;</span><br><span class="line">  path:<span class="string">'/book'</span>,</span><br><span class="line">  name:<span class="string">'book'</span>,</span><br><span class="line">  components:Book,</span><br><span class="line">  meta:&#123;</span><br><span class="line">     keepAlive:<span class="literal">false</span> <span class="comment">//不需要被缓存的组件</span></span><br><span class="line"> &#125; </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view v-<span class="keyword">if</span>=<span class="string">"this.$route.meat.keepAlive"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="comment">&lt;!--这里是会被缓存的组件--&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span></span><br><span class="line">&lt;keep-alive v-if="!this.$router.meta.keepAlive"&gt;&lt;/keep-alive&gt;</span><br><span class="line">&lt;!--这里是不会被缓存的组件--&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong> 当引入keep-alive的时候，页面第一次进入，钩子的触发顺序 created-&gt; mounted-&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//$route发生变化时再次赋值listId</span><br><span class="line">watch: &#123;</span><br><span class="line">   &apos;$route&apos;() &#123;</span><br><span class="line">        this.listId = this.$route.params.id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//通过activated钩子触发请求函数</span><br><span class="line">activated() &#123;</span><br><span class="line">    this.getDetail();</span><br><span class="line">&#125;,</span><br><span class="line">//返回详情页面时 隐藏内容div区块 再进入详情时 显示内容div区块 </span><br><span class="line">deactivated() &#123;</span><br><span class="line">    this.isShowContent = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="DEMO前进刷新-后退不刷新"><a href="#DEMO前进刷新-后退不刷新" class="headerlink" title="DEMO前进刷新,后退不刷新"></a>DEMO前进刷新,后退不刷新</h2><blockquote>
<p>App.vue</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"title"</span>&gt;F12，打开控制台，通过<span class="built_in">console</span>查看数据变化&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;keep-alive&gt;</span></span><br><span class="line"><span class="regexp">        &lt;router-view v-if="$route.meta.keepAlive"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;!-- 这里是会被缓存的视图组件，比如 page1,page2 --&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>router-view&gt;</span><br><span class="line">    &lt;<span class="regexp">/keep-alive&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;router-view v-if="!$route.meta.keepAlive"&gt;</span></span><br><span class="line"><span class="regexp">        &lt;!-- 这里是不被缓存的视图组件，比如 page3 --&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>router-view&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"app"</span></span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">#app &#123;</span></span><br><span class="line"><span class="regexp">  font-family: "Avenir", Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="regexp">  -webkit-font-smoothing: antialiased;</span></span><br><span class="line"><span class="regexp">  -moz-osx-font-smoothing: grayscale;</span></span><br><span class="line"><span class="regexp">  text-align: center;</span></span><br><span class="line"><span class="regexp">  color: #2c3e50;</span></span><br><span class="line"><span class="regexp">  margin-top: 60px;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">.title &#123;</span></span><br><span class="line"><span class="regexp">  font-size: 20px;</span></span><br><span class="line"><span class="regexp">  color: red;</span></span><br><span class="line"><span class="regexp">  margin-bottom: 40px;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>router/index.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> index <span class="keyword">from</span> <span class="string">'@/components/index'</span></span><br><span class="line"><span class="keyword">import</span> page1 <span class="keyword">from</span> <span class="string">'@/components/page1'</span></span><br><span class="line"><span class="keyword">import</span> page2 <span class="keyword">from</span> <span class="string">'@/components/page2'</span></span><br><span class="line"><span class="keyword">import</span> page3 <span class="keyword">from</span> <span class="string">'@/components/page3'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">	routes: [&#123;</span><br><span class="line">			path: <span class="string">'/'</span>,</span><br><span class="line">			name: <span class="string">'index'</span>,</span><br><span class="line">			component: index,</span><br><span class="line">			meta: &#123;</span><br><span class="line">				keepAlive: <span class="literal">false</span>, <span class="comment">//此组件不需要被缓存</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			path: <span class="string">'/page1'</span>,</span><br><span class="line">			name: <span class="string">'page1'</span>,</span><br><span class="line">			component: page1,</span><br><span class="line">			meta: &#123;</span><br><span class="line">				keepAlive: <span class="literal">true</span>, <span class="comment">//此组件需要被缓存</span></span><br><span class="line">				isBack: <span class="literal">false</span>, <span class="comment">//用于判断上一个页面是哪个</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			path: <span class="string">'/page2'</span>,</span><br><span class="line">			name: <span class="string">'page2'</span>,</span><br><span class="line">			component: page2,</span><br><span class="line">			meta: &#123;</span><br><span class="line">				keepAlive: <span class="literal">true</span>, <span class="comment">// 此组件需要被缓存</span></span><br><span class="line">				isBack: <span class="literal">false</span>, <span class="comment">//用于判断上一个页面是哪个</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			path: <span class="string">'/page3'</span>,</span><br><span class="line">			name: <span class="string">'page3'</span>,</span><br><span class="line">			component: page3,</span><br><span class="line">			meta: &#123;</span><br><span class="line">				keepAlive: <span class="literal">false</span>, <span class="comment">// 此组件不需要被缓存</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	mode: <span class="string">'history'</span>,</span><br><span class="line">	scrollBehavior(to, <span class="keyword">from</span>, savedPosition) &#123;</span><br><span class="line">		<span class="keyword">if</span>(savedPosition) &#123;</span><br><span class="line">			<span class="keyword">return</span> savedPosition</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				x: <span class="number">0</span>,</span><br><span class="line">				y: <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>page.vue  page1.vue  page2.vue  page3.vue</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">//page.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;router-link to=&quot;page1&quot;&gt;第一个页面&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link to=&quot;page2&quot;&gt;第二个页面&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link to=&quot;page3&quot;&gt;第三个页面&lt;/router-link&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">a&#123;</span><br><span class="line">    display: block;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//page1.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;page1&quot;&gt;</span><br><span class="line">		&lt;button @click=&quot;goBack&quot;&gt;返回&lt;/button&gt;</span><br><span class="line">		&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">		&lt;p&gt;&#123;&#123;str&#125;&#125;&lt;/p&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; v-model=&quot;val&quot; /&gt;</span><br><span class="line">		&lt;router-link to=&quot;page2&quot;&gt;跳转到下一个页面&lt;/router-link&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &quot;page1&quot;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				val:&quot;我是输入框&quot;,</span><br><span class="line">				msg: &quot;我是第一个页面&quot;,</span><br><span class="line">				str: &quot;&quot;, // 加载页面后执行获取数据的方法，插入到此</span><br><span class="line">				isFirstEnter: false // 是否第一次进入，默认false</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			getData() &#123;</span><br><span class="line">				// getData方法，模拟从后台请求数据</span><br><span class="line">				console.warn(&quot;我调用第一个页面getData方法了&quot;);</span><br><span class="line">				this.str = &quot;我是通过调用方法加载的数据。。。&quot;;</span><br><span class="line">			&#125;,</span><br><span class="line">			goBack() &#123;</span><br><span class="line">				this.$router.go(-1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">			console.log(&quot;我是第一个页面的beforeRouteEnter方法&quot;);</span><br><span class="line">			// 路由导航钩子，此时还不能获取组件实例 `this`，所以无法在data中定义变量（利用vm除外）</span><br><span class="line">			// 参考 https://router.vuejs.org/zh-cn/advanced/navigation-guards.html</span><br><span class="line">			// 所以，利用路由元信息中的meta字段设置变量，方便在各个位置获取。这就是为什么在meta中定义isBack</span><br><span class="line">			// 参考 https://router.vuejs.org/zh-cn/advanced/meta.html</span><br><span class="line">			if(from.name == &apos;page2&apos;) &#123;</span><br><span class="line">				to.meta.isBack = true;</span><br><span class="line">				//判断是从哪个路由过来的，如果是page2过来的，表明当前页面不需要刷新获取新数据，直接用之前缓存的数据即可</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			next();</span><br><span class="line">		&#125;,</span><br><span class="line">		created() &#123;</span><br><span class="line">			console.log(&quot;我是第一个页面的 created 方法&quot;);</span><br><span class="line">			this.isFirstEnter = true;</span><br><span class="line">			// 只有第一次进入或者刷新页面后才会执行此钩子函数</span><br><span class="line">			// 使用keep-alive后（2+次）进入不会再执行此钩子函数</span><br><span class="line">		&#125;,</span><br><span class="line">		mounted() &#123;</span><br><span class="line">			console.log(&quot;我是第一个页面的 mounted 方法&quot;);</span><br><span class="line">		&#125;,</span><br><span class="line">		activated() &#123;</span><br><span class="line">			console.log(&quot;我是第一个页面的 activated 方法&quot;);</span><br><span class="line">			if(!this.$route.meta.isBack || this.isFirstEnter) &#123;</span><br><span class="line">				// 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据</span><br><span class="line">				// 如果isFirstEnter是true，表明是第一次进入此页面或用户刷新了页面，需获取新数据</span><br><span class="line">				this.str = &apos;&apos; // 把数据清空，可以稍微避免让用户看到之前缓存的数据</span><br><span class="line">				this.getData();</span><br><span class="line">			&#125;</span><br><span class="line">			// 恢复成默认的false，避免isBack一直是true，导致下次无法获取数据</span><br><span class="line">			this.$route.meta.isBack = false</span><br><span class="line">			// 恢复成默认的false，避免isBack一直是true，导致每次都获取新数据</span><br><span class="line">			this.isFirstEnter = false;</span><br><span class="line"></span><br><span class="line">		&#125;,</span><br><span class="line">		deactivated() &#123;</span><br><span class="line">			console.log(&quot;我是第一个页面的 deactivated 方法&quot;);</span><br><span class="line">		&#125;,</span><br><span class="line">		destroyed() &#123;</span><br><span class="line">			console.log(&quot;我是第一个页面的 destroyed 方法&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//page2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;page2&quot;&gt;</span><br><span class="line">		&lt;button @click=&quot;goBack&quot;&gt;返回&lt;/button&gt;</span><br><span class="line">		&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">		&lt;p&gt;&#123;&#123;str&#125;&#125;&lt;/p&gt;</span><br><span class="line">		&lt;input type=&quot;text&quot; v-model=&quot;val&quot; /&gt;</span><br><span class="line">		&lt;router-link to=&quot;page3&quot;&gt;跳转到下一个页面&lt;/router-link&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &quot;page2&quot;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				val:&quot;我是输入框&quot;,</span><br><span class="line">				msg: &quot;我是第二个页面&quot;,</span><br><span class="line">				str: &quot;&quot;,</span><br><span class="line">				isFirstEnter: false</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			getData() &#123;</span><br><span class="line">				console.warn(&quot;我调用第二个页面getData方法了&quot;);</span><br><span class="line">				this.str = &quot;我是通过调用方法加载的数据。。。&quot;;</span><br><span class="line">			&#125;,</span><br><span class="line">			goBack() &#123;</span><br><span class="line">				this.$router.go(-1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">			console.log(&apos;我是第二个页面的beforeRouteEnter方法&apos;)</span><br><span class="line">			if(from.name == &apos;page3&apos;) &#123;</span><br><span class="line">				to.meta.isBack = true;</span><br><span class="line">			&#125;</span><br><span class="line">			next()</span><br><span class="line">		&#125;,</span><br><span class="line">		created() &#123;</span><br><span class="line">			console.log(&quot;我是第二个页面的 created 方法&quot;);</span><br><span class="line">			this.isFirstEnter = true;</span><br><span class="line">		&#125;,</span><br><span class="line">		mounted() &#123;</span><br><span class="line">			console.log(&quot;我是第二个页面的 mounted 方法&quot;);</span><br><span class="line">		&#125;,</span><br><span class="line">		activated() &#123;</span><br><span class="line">			console.log(&quot;我是第二个页面的 activated 方法&quot;);</span><br><span class="line">			if(!this.$route.meta.isBack || this.isFirstEnter) &#123;</span><br><span class="line">				this.str = &apos;&apos;</span><br><span class="line">				this.getData();</span><br><span class="line">			&#125;</span><br><span class="line">			this.$route.meta.isBack = false</span><br><span class="line">			this.isFirstEnter = false;</span><br><span class="line">		&#125;,</span><br><span class="line">		deactivated() &#123;</span><br><span class="line">			console.log(&quot;我是第二个页面的 deactivated 方法&quot;);</span><br><span class="line">		&#125;,</span><br><span class="line">		destroyed() &#123;</span><br><span class="line">			console.log(&quot;我是第二个页面的 destroyed 方法&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//page3.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;page3&quot;&gt;</span><br><span class="line">		&lt;button @click=&quot;goBack&quot;&gt;返回&lt;/button&gt;</span><br><span class="line">		&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;</span><br><span class="line">		&lt;p&gt;&#123;&#123;str&#125;&#125;&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &quot;page3&quot;,</span><br><span class="line">		data() &#123;</span><br><span class="line">			return &#123;</span><br><span class="line">				msg: &quot;我是第三个页面&quot;,</span><br><span class="line">				str: &apos;&apos;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			getData() &#123;</span><br><span class="line">				console.warn(&apos;我调用第三个页面getData方法了&apos;)</span><br><span class="line">				this.str = &quot;我是通过调用方法加载的数据。。。&quot;;</span><br><span class="line">			&#125;,</span><br><span class="line">			goBack() &#123;</span><br><span class="line">				this.$router.go(-1)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">		beforeRouteEnter(to, from, next) &#123;</span><br><span class="line">			console.log(&apos;我是第三个页面的beforeRouteEnter方法&apos;)</span><br><span class="line">			next()</span><br><span class="line">		&#125;,</span><br><span class="line">		created() &#123;</span><br><span class="line">			console.log(&apos;我是第三个页面的 created 方法&apos;)</span><br><span class="line">		&#125;,</span><br><span class="line">		mounted() &#123;</span><br><span class="line">			this.getData()</span><br><span class="line">			console.log(&apos;我是第三个页面的 mounted 方法&apos;)</span><br><span class="line">		&#125;,</span><br><span class="line">		activated() &#123;</span><br><span class="line">			console.log(&apos;我是第三个页面的 activated 方法&apos;)</span><br><span class="line">		&#125;,</span><br><span class="line">		deactivated() &#123;</span><br><span class="line">			console.log(&apos;我是第三个页面的 deactivated 方法&apos;)</span><br><span class="line">		&#125;,</span><br><span class="line">		destroyed() &#123;</span><br><span class="line">			console.log(&apos;我是第三个页面的 destroyed 方法&apos;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p><strong> 依次加入page1,page2,page1 </strong><br><img src="/2019/02/18/用keep-alive优化页面性能/1.png" alt=""><br><img src="/2019/02/18/用keep-alive优化页面性能/2.png" alt=""></p>
<h2 id="vue-keep-scroll-position"><a href="#vue-keep-scroll-position" class="headerlink" title="vue-keep-scroll-position"></a>vue-keep-scroll-position</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">	var plugin;</span><br><span class="line">	plugin = function (Vue) &#123;</span><br><span class="line">		return Vue.directive(&apos;keep-scroll-position&apos;, &#123;</span><br><span class="line">			bind: function (el) &#123;</span><br><span class="line">				el.addEventListener(&apos;scroll&apos;, function (event) &#123;</span><br><span class="line">					event.target.setAttribute(&apos;data-vue-keep-scroll-position&apos;, event.target.scrollLeft + &apos;-&apos; + event.target.scrollTop);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;,</span><br><span class="line">			inserted: function (el) &#123;</span><br><span class="line">				var i, len, pos, target, targets;</span><br><span class="line">				targets = el.querySelectorAll(&apos;[data-vue-keep-scroll-position]&apos;);</span><br><span class="line">				if (targets.length &gt; 0) &#123;</span><br><span class="line">					for (i = 0, len = targets.length; i &lt; len; i++) &#123;</span><br><span class="line">						target = targets[i];</span><br><span class="line">						pos = target.getAttribute(&apos;data-vue-keep-scroll-position&apos;).split(&apos;-&apos;);</span><br><span class="line">						target.scrollLeft = pos[0];</span><br><span class="line">						target.scrollTop = pos[1];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					if (el.hasAttribute(&apos;data-vue-keep-scroll-position&apos;)) &#123;</span><br><span class="line">						pos = el.getAttribute(&apos;data-vue-keep-scroll-position&apos;).split(&apos;-&apos;);</span><br><span class="line">						el.scrollLeft = pos[0];</span><br><span class="line">						el.scrollTop = pos[1];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;;</span><br><span class="line">	if (typeof Vue !== &quot;undefined&quot; &amp;&amp; Vue !== null) &#123;</span><br><span class="line">		Vue.use(plugin);</span><br><span class="line">	&#125;</span><br><span class="line">	if (typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;) &#123;</span><br><span class="line">		return module.exports = plugin;</span><br><span class="line">	&#125; else if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line">		return define(function () &#123;</span><br><span class="line">			return plugin;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; else if (typeof window !== &quot;undefined&quot; &amp;&amp; window !== null) &#123;</span><br><span class="line">		return window.VueKeepScrollPosition = plugin;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>Install<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -S vue-keep-scroll-position</span><br></pre></td></tr></table></figure></p>
<p>Use:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import VueKeepScrollPosition from &apos;vue-keep-scroll-position&apos;</span><br><span class="line">Vue.use VueKeepScrollPosition</span><br></pre></td></tr></table></figure></p>
<p>只需添加v-keep-scroll-position到您的组件内即可<keep-alive>。用于router-view：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;router-view  v-keep-scroll-position&gt; &lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></keep-alive></p>
<p>对于简单的动态组件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is=&quot;someComponentName&quot;  v-keep-scroll-position&gt;&lt;/component&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="keep-alive组件实现原理"><a href="#keep-alive组件实现原理" class="headerlink" title="keep-alive组件实现原理"></a>keep-alive组件实现原理</h2><h2 id="Vue源码keep-alive-js文件地址"><a href="#Vue源码keep-alive-js文件地址" class="headerlink" title="Vue源码keep-alive.js文件地址"></a><a href="https://github.com/vuejs/vue/blob/59d8579fbd3a3450ab684d6a596f1853f2257d08/src/core/components/keep-alive.js" target="_blank" rel="noopener">Vue源码keep-alive.js文件地址</a></h2><h2 id="深入keep-alive组件实现"><a href="#深入keep-alive组件实现" class="headerlink" title="深入keep-alive组件实现"></a>深入keep-alive组件实现</h2><p>说完了keep-alive组件的使用，我们从源码角度看一下keep-alive组件究竟是如何实现组件的缓存的呢？</p>
<ul>
<li>首先，你要知道Vue.js内部将DOM节点抽象成了一个个的VNode节点，这个我之前写过相关文章可以参考VNode节点。所以，keep-alive的缓存也是基于VNode节点的而不是直接存储DOM结构。</li>
<li>其实就是将需要缓存的VNode节点保存在this.cache中／在render时,如果VNode的name符合在缓存条件（可以用include以及exclude控制），则会从this.cache中取出之前缓存的VNode实例进行渲染。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">type VNodeCache = &#123; [key: string]: ?VNode &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> patternTypes: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt; = [<span class="built_in">String</span>, <span class="built_in">RegExp</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取组件名称 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponentName</span> (<span class="params">opts: ? VNodeComponentOptions</span>): ?<span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> opts &amp;&amp; (opts.Ctor.options.name || opts.tag)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检测name是否匹配 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matches</span> (<span class="params">pattern: string | RegExp, name: string</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">/* 字符串情况，如a,b,c */</span></span><br><span class="line">    <span class="keyword">return</span> pattern.split(<span class="string">','</span>).indexOf(name) &gt; <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(pattern)) &#123;</span><br><span class="line">    <span class="comment">/* 正则 */</span></span><br><span class="line">    <span class="keyword">return</span> pattern.test(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修正cache */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCache</span> (<span class="params">cache: VNodeCache, current: VNode, filter: Function</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="comment">/* 取出cache中的vnode */</span></span><br><span class="line">    <span class="keyword">const</span> cachedNode: ?VNode = cache[key]</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(cachedNode.componentOptions)</span><br><span class="line">      <span class="comment">/* name不符合filter条件的，同时不是目前渲染的vnode时，销毁vnode对应的组件实例（Vue实例），并从cache中移除 */</span></span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedNode !== current) &#123;</span><br><span class="line">          pruneCacheEntry(cachedNode)</span><br><span class="line">        &#125;</span><br><span class="line">        cache[key] = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁vnode对应的组件实例（Vue实例） */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCacheEntry</span> (<span class="params">vnode: ?VNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode) &#123;</span><br><span class="line">    vnode.componentInstance.$destroy()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* keep-alive组件 */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'keep-alive'</span>,</span><br><span class="line">  <span class="comment">/* 抽象组件 */</span></span><br><span class="line">  abstract: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  props: &#123;</span><br><span class="line">    include: patternTypes,</span><br><span class="line">    exclude: patternTypes</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="comment">/* 缓存对象 */</span></span><br><span class="line">    <span class="keyword">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* destroyed钩子中销毁所有cache中的组件实例 */</span></span><br><span class="line">  destroyed () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">this</span>.cache) &#123;</span><br><span class="line">      pruneCacheEntry(<span class="keyword">this</span>.cache[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="comment">/* 监视include以及exclude，在被修改的时候对cache进行修正 */</span></span><br><span class="line">    include (val: string | <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>.cache, <span class="keyword">this</span>._vnode, name =&gt; matches(val, name))</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude (val: string | <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">      pruneCache(<span class="keyword">this</span>.cache, <span class="keyword">this</span>._vnode, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="comment">/* 得到slot插槽中的第一个组件 */</span></span><br><span class="line">    <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(<span class="keyword">this</span>.$slots.default)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">      <span class="comment">// check pattern</span></span><br><span class="line">      <span class="comment">/* 获取组件名称，优先获取组件的name字段，否则是组件的tag */</span></span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(componentOptions)</span><br><span class="line">      <span class="comment">/* name不在inlcude中或者在exlude中则直接返回vnode（没有取缓存） */</span></span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; (</span><br><span class="line">        (<span class="keyword">this</span>.include &amp;&amp; !matches(<span class="keyword">this</span>.include, name)) ||</span><br><span class="line">        (<span class="keyword">this</span>.exclude &amp;&amp; matches(<span class="keyword">this</span>.exclude, name))</span><br><span class="line">      )) &#123;</span><br><span class="line">        <span class="keyword">return</span> vnode</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">        : vnode.key</span><br><span class="line">      <span class="comment">/* 如果已经做过缓存了则直接从缓存中获取组件实例给vnode，还未缓存过则进行缓存 */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.cache[key]) &#123;</span><br><span class="line">        vnode.componentInstance = <span class="keyword">this</span>.cache[key].componentInstance</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.cache[key] = vnode</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* keepAlive标记位 */</span></span><br><span class="line">      vnode.data.keepAlive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="created与destroyed钩子"><a href="#created与destroyed钩子" class="headerlink" title="created与destroyed钩子"></a>created与destroyed钩子</h3><p>created钩子会创建一个cache对象，用来作为缓存容器，保存vnode节点。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type VNodeCache = &#123; [key: string]: ?VNode &#125;;    <span class="comment">//缓存keep-alive对象VNodeCache</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="comment">/* 缓存对象 */</span></span><br><span class="line">   <span class="keyword">this</span>.cache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<p>destroyed钩子则在组件被销毁的时候清除cache缓存中的所有组件实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* destroyed钩子中销毁所有cache中的组件实例 */</span></span><br><span class="line">destroyed () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> <span class="keyword">this</span>.cache) &#123;</span><br><span class="line">        pruneCacheEntry(<span class="keyword">this</span>.cache[key])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p>接下来是render函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">    <span class="comment">/* 得到slot插槽中的第一个组件 */</span></span><br><span class="line">    <span class="keyword">const</span> vnode: VNode = getFirstComponentChild(<span class="keyword">this</span>.$slots.default)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions</span><br><span class="line">    <span class="keyword">if</span> (componentOptions) &#123;</span><br><span class="line">        <span class="comment">// check pattern</span></span><br><span class="line">        <span class="comment">/* 获取组件名称，优先获取组件的name字段，否则是组件的tag */</span></span><br><span class="line">        <span class="keyword">const</span> name: ?string = getComponentName(componentOptions)</span><br><span class="line">        <span class="comment">/* name不在inlcude中或者在exlude中则直接返回vnode（没有取缓存） */</span></span><br><span class="line">        <span class="keyword">if</span> (name &amp;&amp; (</span><br><span class="line">        (<span class="keyword">this</span>.include &amp;&amp; !matches(<span class="keyword">this</span>.include, name)) ||</span><br><span class="line">        (<span class="keyword">this</span>.exclude &amp;&amp; matches(<span class="keyword">this</span>.exclude, name))</span><br><span class="line">        )) &#123;</span><br><span class="line">            <span class="keyword">return</span> vnode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> key: ?string = vnode.key == <span class="literal">null</span></span><br><span class="line">        <span class="comment">// same constructor may get registered as different local components</span></span><br><span class="line">        <span class="comment">// so cid alone is not enough (#3269)</span></span><br><span class="line">        ? componentOptions.Ctor.cid + (componentOptions.tag ? <span class="string">`::<span class="subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="string">''</span>)</span><br><span class="line">        : vnode.key</span><br><span class="line">        <span class="comment">/* 如果已经做过缓存了则直接从缓存中获取组件实例给vnode，还未缓存过则进行缓存 */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.cache[key]) &#123;</span><br><span class="line">            vnode.componentInstance = <span class="keyword">this</span>.cache[key].componentInstance</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cache[key] = vnode</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* keepAlive标记位 */</span></span><br><span class="line">        vnode.data.keepAlive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过getFirstComponentChild获取第一个子组件，获取该组件的name（存在组件名则直接使用组件名，否则会使用tag）。接下来会将这个name通过include与exclude属性进行匹配，匹配不成功（说明不需要进行缓存）则不进行任何操作直接返回vnode，vnode是一个VNode类型的对象，不了解VNode的同学可以参考笔者的另一篇文章<a href="https://link.jianshu.com?t=https://github.com/answershuto/learnVue/blob/master/docs/VNode%E8%8A%82%E7%82%B9.MarkDown" target="_blank" rel="noopener">《VNode节点》</a> .<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检测name是否匹配 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matches</span> (<span class="params">pattern: string | RegExp, name: string</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> pattern === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">/* 字符串情况，如a,b,c */</span></span><br><span class="line">    <span class="keyword">return</span> pattern.split(<span class="string">','</span>).indexOf(name) &gt; <span class="number">-1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isRegExp(pattern)) &#123;</span><br><span class="line">    <span class="comment">/* 正则 */</span></span><br><span class="line">    <span class="keyword">return</span> pattern.test(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>检测include与exclude属性匹配的函数很简单，include与exclude属性支持字符串如”a,b,c”这样组件名以逗号隔开的情况以及正则表达式。matches通过这两种方式分别检测是否匹配当前组件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.cache[key]) &#123;</span><br><span class="line">    vnode.componentInstance = <span class="keyword">this</span>.cache[key].componentInstance</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.cache[key] = vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来的事情很简单，根据key在this.cache中查找，如果存在则说明之前已经缓存过了，直接将缓存的vnode的componentInstance（组件实例）覆盖到目前的vnode上面。否则将vnode存储在cache中。</p>
<p>最后返回vnode（有缓存时该vnode的componentInstance已经被替换成缓存中的了）。</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>用watch来监听pruneCache与pruneCache这两个属性的改变，在改变的时候修改cache缓存中的缓存数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    <span class="comment">/* 监视include以及exclude，在被修改的时候对cache进行修正 */</span></span><br><span class="line">    include (val: string | <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">        pruneCache(<span class="keyword">this</span>.cache, <span class="keyword">this</span>._vnode, name =&gt; matches(val, name))</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude (val: string | <span class="built_in">RegExp</span>) &#123;</span><br><span class="line">        pruneCache(<span class="keyword">this</span>.cache, <span class="keyword">this</span>._vnode, name =&gt; !matches(val, name))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>来看一下pruneCache的实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 修正cache */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCache</span> (<span class="params">cache: VNodeCache, current: VNode, filter: Function</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> cache) &#123;</span><br><span class="line">    <span class="comment">/* 取出cache中的vnode */</span></span><br><span class="line">    <span class="keyword">const</span> cachedNode: ?VNode = cache[key]</span><br><span class="line">    <span class="keyword">if</span> (cachedNode) &#123;</span><br><span class="line">      <span class="keyword">const</span> name: ?string = getComponentName(cachedNode.componentOptions)</span><br><span class="line">      <span class="comment">/* name不符合filter条件的，同时不是目前渲染的vnode时，销毁vnode对应的组件实例（Vue实例），并从cache中移除 */</span></span><br><span class="line">      <span class="keyword">if</span> (name &amp;&amp; !filter(name)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedNode !== current) &#123;</span><br><span class="line">          pruneCacheEntry(cachedNode)</span><br><span class="line">        &#125;</span><br><span class="line">        cache[key] = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁vnode对应的组件实例（Vue实例） */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pruneCacheEntry</span> (<span class="params">vnode: ?VNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode) &#123;</span><br><span class="line">    vnode.componentInstance.$destroy()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历cache中的所有项，如果不符合filter指定的规则的话，则会执行pruneCacheEntry。pruneCacheEntry则会调用组件实例的$destroy方法来将组件销毁。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>Vue.js内部将DOM节点抽象成了一个个的<a href="https://link.jianshu.com?t=https://github.com/answershuto/learnVue/blob/master/docs/VNode%E8%8A%82%E7%82%B9.MarkDown" target="_blank" rel="noopener">VNode节点</a>，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/React用PureComponent和React-memo优化性能/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/14/React用PureComponent和React-memo优化性能/" itemprop="url">React用PureComponent和React.memo优化性能</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T15:38:13+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文将从 render 函数的角度总结 React App 的优化技巧。</p>
<p>需要提醒的是，文中将涉及 React 16.8.2 版本的内容(也即 Hooks），因此请至少了解 useState 以保证食用效果。</p>
<p>当我们讨论 React App 的性能问题时，组件的<strong>渲染</strong>速度是一个重要问题。在进入到具体优化建议之前，我们先要理解以下 3 点：</p>
<ol>
<li>当我们在说「render」时，我们在说什么？</li>
<li>什么时候会执行「render」？</li>
<li>在「render」过程中会发生什么？</li>
</ol>
<h2 id="解读-render-函数"><a href="#解读-render-函数" class="headerlink" title="解读 render 函数"></a>解读 render 函数</h2><p>这部分涉及 reconciliation 和 diffing 的概念，当然官方文档在<a href="https://link.juejin.im?target=https%3A%2F%2Freactjs.org%2Fdocs%2Freconciliation.html" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="当我们在说「render」时，我们在说什么？"><a href="#当我们在说「render」时，我们在说什么？" class="headerlink" title="当我们在说「render」时，我们在说什么？"></a>当我们在说「render」时，我们在说什么？</h3><p>这个问题其实写过 React 的人都会知道，这里再简单说下：</p>
<p>在 class 组件中，我们指的是 render 方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Foo <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在函数式组件中，我们指的是函数组件本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Foo <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="什么时候会执行「render」？"><a href="#什么时候会执行「render」？" class="headerlink" title="什么时候会执行「render」？"></a>什么时候会执行「render」？</h3><p>render 函数会在两种场景下被调用：</p>
<h4 id="状态更新时"><a href="#状态更新时" class="headerlink" title="状态更新时"></a>状态更新时</h4><h5 id="a-继承自-React-Component-的-class-组件更新状态时"><a href="#a-继承自-React-Component-的-class-组件更新状态时" class="headerlink" title="a. 继承自 React.Component 的 class 组件更新状态时"></a>a. 继承自 React.Component 的 class 组件更新状态时</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class Foo extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  state = &#123; count: 0 &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  increment = () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const &#123; count &#125; = this.state;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    const newCount = count <span class="tag">&lt; <span class="attr">10</span> ? <span class="attr">count</span> + <span class="attr">1</span> <span class="attr">:</span> <span class="attr">count</span>;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    this.setState(&#123; count: newCount &#125;);</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    const &#123; count &#125; = this.state;</span></span><br><span class="line"><span class="xml">    console.log("Foo render");</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt; &#123;count&#125; &lt;/h1&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.increment&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure>
<p>可以看到，代码中的逻辑是我们点击就会更新 count，到 10 以后，就会维持在 10。增加一个 console.log，这样我们就可以知道 render 是否被调用了。从执行结果可以知道，即使 count 到了 10 以上，render 仍然会被调用。</p>
<p>总结：<strong> <font color="#ff0000"> 继承了 React.Component 的 class 组件，即使状态没变化，只要调用了setState 依然会触发 render。</font> </strong></p>
<h5 id="b-函数式组件更新状态时"><a href="#b-函数式组件更新状态时" class="headerlink" title="b. 函数式组件更新状态时"></a>b. 函数式组件更新状态时</h5><p>我们用函数实现相同的组件，当然因为要有状态，我们用上了 useState hook：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Foo() &#123;</span></span><br><span class="line"><span class="xml">  const [count, setCount] = useState(0);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  function increment() &#123;</span></span><br><span class="line"><span class="xml">    const newCount = count <span class="tag">&lt; <span class="attr">10</span> ? <span class="attr">count</span> + <span class="attr">1</span> <span class="attr">:</span> <span class="attr">count</span>;</span></span></span><br><span class="line"><span class="xml">    setCount(newCount);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  console.log("Foo render");</span></span><br><span class="line"><span class="xml">  </span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt; &#123;count&#125; &lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;increment&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以注意到，当状态值不再改变之后，render 的调用就停止了。</p>
<p>总结：<strong> <font color="#ff0000"> 对函数式组件来说，状态值改变时才会触发 render 函数的调用。</font> </strong></p>
<h4 id="父容器重新渲染时"><a href="#父容器重新渲染时" class="headerlink" title="父容器重新渲染时"></a>父容器重新渲染时</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span>: <span class="string">"App"</span> &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;Foo /&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">name</span>: <span class="string">"App"</span> &#125;)&#125;&gt;</span><br><span class="line">          Change name</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Foo render"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt; Foo &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure>
<p>只要点击了 App 组件内的 Change name 按钮，就会重新 render。而且可以注意到，不管 Foo 具体实现是什么，Foo 都会被重新渲染。</p>
<p>总结：<strong> <font color="#ff0000"> 无论组件是继承自 React.Component 的 class 组件还是函数式组件，一旦父容器重新 render，组件的 render 都会再次被调用。</font> </strong></p>
<h3 id="在「render」过程中会发生什么？"><a href="#在「render」过程中会发生什么？" class="headerlink" title="在「render」过程中会发生什么？"></a>在「render」过程中会发生什么？</h3><p>只要 render 函数被调用，就会有两个步骤按顺序执行。这两个步骤非常重要，理解了它们才好知道如何去优化 React App。</p>
<h4 id="Diffing-【对比】"><a href="#Diffing-【对比】" class="headerlink" title="Diffing 【对比】"></a>Diffing 【对比】</h4><p>在此步骤中，React 将新调用的 render 函数返回的树与旧版本的VDOM树进行比较，这一步是 React 决定如何更新 DOM 的必要步骤。虽然 React 使用高度优化的算法执行此步骤，但仍然有一定的性能开销。</p>
<h4 id="Reconciliation-【更新】"><a href="#Reconciliation-【更新】" class="headerlink" title="Reconciliation 【更新】"></a>Reconciliation 【更新】</h4><p>基于 diffing 的结果，React 更新 DOM 树。这一步因为需要卸载和挂载 DOM 节点同样存在许多性能开销。</p>
<h2 id="开始我们的-Tips"><a href="#开始我们的-Tips" class="headerlink" title="开始我们的 Tips"></a>开始我们的 Tips</h2><h3 id="谨慎分配-state-以避免不必要的-render-调用"><a href="#谨慎分配-state-以避免不必要的-render-调用" class="headerlink" title="谨慎分配 state 以避免不必要的 render 调用"></a>谨慎分配 state 以避免不必要的 render 调用</h3><p>我们以下面为例，其中 App 会渲染两个组件：</p>
<ul>
<li><code>CounterLabel</code>，接收 count 值和一个 inc 父组件 App 中状态 count 的方法。</li>
<li><code>List</code>，接收 item 的列表。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ITEMS = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [items, setItems] = useState(ITEMS);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;CounterLabel count=&#123;count&#125; increment=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125; /&gt;</span><br><span class="line">      &lt;List items=&#123;items&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function CounterLabel(&#123; count, increment &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;&#123;count&#125; &lt;/</span>h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;increment&#125;&gt; Increment &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">&#123; items &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"List render"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;items.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;index&#125;&gt;&#123;item&#125; &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>执行上面代码可知，只要父组件 App 中的状态被更新，<code>CounterLabel</code> 和 <code>List</code> 就都会更新。</p>
<p>当然，<code>CounterLabel</code> 重新渲染是正常的，因为 count 发生了变化，自然要重新渲染；但是对于 <code>List</code> 而言，就完全是不必要的更新了，因为它的渲染与 count 无关。</p>
<p><strong>  <font color="#ff0000"> 尽管 React 并不会在 reconciliation 阶段真的更新 DOM，毕竟完全没变化，但是仍然会执行 diffing 阶段来对前后的树进行对比，这仍然存在性能开销。</font> </strong></p>
<p>还记得 render 执行过程中的 diffing 和 reconciliation 阶段吗？前面讲过的东西在这里碰到了。</p>
<p>因此，为了避免不必要的 diffing 开销，我们应当考虑将特定的状态值放到更低的层级或组件中（与 React 中所说的「提升」概念刚好相反）。在这个例子中，我们可以通过将 count 放到 <code>CounterLabel</code> 组件中管理来解决这个问题。</p>
<h3 id="合并状态更新"><a href="#合并状态更新" class="headerlink" title="合并状态更新"></a>合并状态更新</h3><p>因为每次状态更新都会触发新的 render 调用，那么更少的状态更新也就可以更少的调用 render 了。</p>
<p>我们知道，React class 组件有 <code>componentDidUpdate(prevProps, prevState)</code> 的钩子，可以用来检测 props 或 state 有没有发生变化。尽管有时有必要在 props 发生变化时再触发 state 更新，但我们总可以避免在一次 state 变化后再进行一次 state 更新这种操作：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRange</span>(<span class="params">limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> range = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">    range.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    numbers: getRange(<span class="number">7</span>),</span><br><span class="line">    limit: <span class="number">7</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleLimitChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> limit = e.target.value;</span><br><span class="line">    <span class="keyword">const</span> limitChanged = limit !== <span class="keyword">this</span>.state.limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (limitChanged) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; limit &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">const</span> limitChanged = prevState.limit !== <span class="keyword">this</span>.state.limit;</span><br><span class="line">    <span class="keyword">if</span> (limitChanged) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">numbers</span>: getRange(<span class="keyword">this</span>.state.limit) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleLimitChange&#125;</span><br><span class="line">          placeholder=<span class="string">"limit"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.limit&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.numbers.map(<span class="function">(<span class="params">number, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;p key=&#123;idx&#125;&gt;&#123;number&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure></p>
<p>这里渲染了一个范围数字序列，即范围为 0 到 limit。只要用户改变了 limit 值，我们就会在 componentDidUpdate 中进行检测，并设定新的数字列表。</p>
<p>毫无疑问，上面的代码是可以满足需求的，但是，我们仍然可以进行优化。</p>
<p>上面的代码中，每次 limit 发生改变，我们都会触发两次状态更新：第一次是为了修改 limit，第二次是为了修改展示的数字列表。这样一来，每次 limit 的变化会带来两次 render 开销：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line">&#123; <span class="attr">limit</span>: <span class="number">7</span>, <span class="attr">numbers</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment">// 更新 limit -&gt; 4</span></span><br><span class="line">render <span class="number">1</span>: &#123; <span class="attr">limit</span>: <span class="number">4</span>, <span class="attr">numbers</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] &#125; </span><br><span class="line">render <span class="number">2</span>: &#123; <span class="attr">limit</span>: <span class="number">4</span>, <span class="attr">numbers</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>我们的代码逻辑带来了下面的问题：</p>
<ul>
<li>我们触发了比实际需要更多的状态更新；</li>
<li>我们出现了「不连续」的渲染结果，即数字列表与 limit 不匹配。</li>
</ul>
<p>为了改进，我们应避免在不同的状态更新中改变数字列表。事实上，我们可以在一次状态更新中搞定：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRange</span>(<span class="params">limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> range = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">    range.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    numbers: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    limit: <span class="number">7</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleLimitChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> limit = e.target.value;</span><br><span class="line">    <span class="keyword">const</span> limitChanged = limit !== <span class="keyword">this</span>.state.limit;</span><br><span class="line">    <span class="keyword">if</span> (limitChanged) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; limit, <span class="attr">numbers</span>: getRange(limit) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleLimitChange&#125;</span><br><span class="line">          placeholder=<span class="string">"limit"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.limit&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.numbers.map(<span class="function">(<span class="params">number, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;p key=&#123;idx&#125;&gt;&#123;number&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用-PureComponent-和-React-memo-以避免不必要的-render-调用"><a href="#使用-PureComponent-和-React-memo-以避免不必要的-render-调用" class="headerlink" title="使用 PureComponent 和 React.memo 以避免不必要的 render 调用"></a>使用 PureComponent 和 React.memo 以避免不必要的 render 调用</h3><p>我们在之前的例子中看到将特定状态值放到更低的层级来避免不必要渲染的方法，不过这并不总是有用。</p>
<p>我们来看下下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isFooVisible, setFooVisibility] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &#123;isFooVisible ? (</span><br><span class="line">        &lt;Foo hideFoo=&#123;() =&gt; setFooVisibility(<span class="literal">false</span>)&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setFooVisibility(<span class="literal">true</span>)&#125;&gt;Show Foo &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Bar name="Bar" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Foo(&#123; hideFoo &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Foo&lt;/</span>h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;hideFoo&#125;&gt;Hide Foo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">&#123; name &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，只要父组件 App 的状态值 isFooVisible 发生变化，Foo 和 Bar 就都会被重新渲染。</p>
<p>这里因为为了决定 Foo 是否要被渲染出来，我们需要将 isFooVisible 放在 App中维护，因此也就不能将状态拆出放到更低的层级。</p>
<p>不过，在 isFooVisible 发生变化时重新渲染 Bar 仍然是不必要的，因为 Bar 并不依赖 isFooVisible。我们只希望 Bar 在传入属性 name 变化时重新渲染。</p>
<p>那我们该怎么搞呢？两种方法。</p>
<p>其一，对 Bar 做记忆化（memoize）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Bar = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">&#123;name&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这就能保证 Bar 只在 name 发生变化时才重新渲染。</p>
<p>此外，另一个方法就是让 Bar 继承<strong> <font color="#ff0000"> React.PureComponent </font> </strong>而非 React.Component：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不是很熟悉？我们经常提到使用 React.PureComponent 能带来一定的性能提升，避免不必要的 render。</p>
<p>总结：<strong> <font color="#ff0000"> 避免组件不必要的渲染的方法有：React.memo 包裹的函数式组件，继承自 React.PureComponent 的 class 组件 。</font> </strong></p>
<h4 id="为什么不让每个组件都继承-PureComponent-或者用-memo-包呢？"><a href="#为什么不让每个组件都继承-PureComponent-或者用-memo-包呢？" class="headerlink" title="为什么不让每个组件都继承 PureComponent 或者用 memo 包呢？"></a>为什么不让每个组件都继承 PureComponent 或者用 memo 包呢？</h4><p>如果这条建议可以让我们避免不必要的重新渲染，那我们为什么不把每个 class 组件变成 PureComponent、把每个函数式组件用 React.memo 包起来？为什么有了更好的方法还要保留 React.Component 呢？为什么函数式组件不默认记忆化呢？</p>
<p>毫无疑问，这些方法并不总是万灵药。</p>
<h5 id="嵌套对象的问题"><a href="#嵌套对象的问题" class="headerlink" title="嵌套对象的问题"></a>嵌套对象的问题</h5><p>我们先来考虑下 PureComponent 和 React.memo 的组件到底做了什么？</p>
<p>每次更新的时候（包括状态更新或上层组件重新渲染），它们就会在新 props、state 和旧 props、state 之间对 key 和 value 进行浅比较。浅比较是个严格相等的检查，如果检测到差异，render 就会执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型的比较</span></span><br><span class="line">shallowCompare(&#123; <span class="attr">name</span>: <span class="string">'bar'</span>&#125;, &#123; <span class="attr">name</span>: <span class="string">'bar'</span>&#125;); <span class="comment">// output: true</span></span><br><span class="line">shallowCompare(&#123; <span class="attr">name</span>: <span class="string">'bar'</span>&#125;, &#123; <span class="attr">name</span>: <span class="string">'bar1'</span>&#125;); <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure>
<p>尽管基本类型（如字符串、数字、布尔）的比较可以工作的很好，但对象这类复杂的情况可能就会带来意想不到的行为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shallowCompare(&#123; <span class="attr">name</span>: &#123;<span class="attr">first</span>: <span class="string">'John'</span>, <span class="attr">last</span>: <span class="string">'Schilling'</span>&#125;&#125;,</span><br><span class="line">			   &#123; <span class="attr">name</span>: &#123;<span class="attr">first</span>: <span class="string">'John'</span>, <span class="attr">last</span>: <span class="string">'Schilling'</span>&#125;&#125;); <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure>
<p>上述两个 name 对应的对象的引用是不同的。</p>
<p>我们重新看下之前的例子，然后修改我们传入 Bar 的 props：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Bar = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">&#123; name: &#123; first, last &#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Bar render"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;first&#125; &#123;last&#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Foo(&#123; hideFoo &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Foo&lt;/</span>h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;hideFoo&#125;&gt;Hide Foo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isFooVisible, setFooVisibility] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &#123;isFooVisible ? (</span><br><span class="line">        &lt;Foo hideFoo=&#123;() =&gt; setFooVisibility(<span class="literal">false</span>)&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setFooVisibility(<span class="literal">true</span>)&#125;&gt;Show Foo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Bar name=&#123;&#123; first: "John", last: "Schilling" &#125;&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br></pre></td></tr></table></figure></p>
<p>尽管 Bar 做了记忆化且 props 值并没有发生变动，每次父组件重新渲染时它仍然会重新渲染。这是因为尽管每次比较的两个对象拥有相同的值，引用并不同。</p>
<h5 id="函数-props-的问题"><a href="#函数-props-的问题" class="headerlink" title="函数 props 的问题"></a>函数 props 的问题</h5><p>我们也可以把函数作为 props 向组件传递，当然，在 JavaScript 中函数也会传递引用，因此浅比较也是基于其传递的引用。</p>
<p><strong>因此，如果我们传递的是箭头函数（匿名函数），组件仍然会在父组件重新渲染时重新渲染</strong>。</p>
<h3 id="更好的-props-写法"><a href="#更好的-props-写法" class="headerlink" title="更好的 props 写法"></a>更好的 props 写法</h3><p>前面的问题的一种解决方法是改写我们的 props。</p>
<p>我们不传递对象作为 props，而是<strong>将对象拆分成基本类型</strong>：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Bar</span> <span class="attr">firstName</span>=<span class="string">"John"</span> <span class="attr">lastName</span>=<span class="string">"Schilling"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>而对于传递箭头函数的场景，我们可以代以只唯一声明过一次的函数，从而总可以拿到相同的引用，如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doSomethingMethod = <span class="keyword">this</span>.doSomethingMethod.bind(<span class="keyword">this</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">  doSomethingMethod () &#123; <span class="comment">// do something&#125;</span></span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Bar</span> <span class="attr">onSomething</span>=<span class="string">&#123;this.doSomethingMethod&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="控制更新"><a href="#控制更新" class="headerlink" title="控制更新"></a>控制更新</h3><p>还是那句话，任何方法总有其适用范围。</p>
<p>第三条建议虽然处理了不必要的更新问题，但我们也不总能使用它。</p>
<p>而第四条，在某些情况下我们并不能拆分对象，如果我们传递了某种嵌套确实复杂的数据结构，那我们也很难将其拆分开来。</p>
<p>不仅如此，我们也不总能传递只声明了一次的函数。比如在我们的例子中，如果 App 是个函数式组件，恐怕就不能做到这一点了（在 class 组件中，我们可以用 bind 或者类内箭头函数来保证 this 的指向及唯一声明，而在函数式组件中则可能会有些问题）。</p>
<p>幸运的是，<strong> <font color="#ff0000"> 无论是 class 组件还是函数式组件，我们都有办法控制浅比较的逻辑 。</font></strong></p>
<p><table><tr><td bgcolor="#FF00FF"> 在 class 组件中，我们可以使用生命周期钩子 <code>shouldComponentUpdate(prevProps, prevState)</code> 来返回一个布尔值，当返回值为 true 时才会触发 render。常用Immutable.js库的is()比较。</td></tr></table> <strong> <a href="https://juejin.im/post/5c62ae34e51d450aab0a373f#heading-17" target="_blank" rel="noopener">Immutable.js了解一下？</a> </strong></p>
<p>而如果我们使用 React.memo，我们可以传递一个比较函数作为第二个参数。</p>
<blockquote>
<p><strong>注意！</strong>React.memo 的第二参数（比较函数）和 <code>shouldComponentUpdate</code> 的逻辑是相反的，只有当返回值为 false 的时候才会触发 render。<a href="https://link.juejin.im?target=https%3A%2F%2Freactjs.org%2Fdocs%2Freact-api.html%23reactmemo" target="_blank" rel="noopener">参考文档</a>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Bar = React.memo(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">&#123; name: &#123; first, last &#125; &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"update"</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        &#123;first&#125; &#123;last&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  (prevProps, newProps) =&gt;</span></span><br><span class="line"><span class="regexp">    prevProps.name.first === newProps.name.first &amp;&amp;</span></span><br><span class="line"><span class="regexp">    prevProps.name.last === newProps.name.last</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p>尽管这条建议是可行的，但我们仍要注意<strong>比较函数的性能开销</strong>。如果 props 对象过深，反而会消耗不少的性能。</p>
<hr>
<h2 id="PureComponent-Vs-Component"><a href="#PureComponent-Vs-Component" class="headerlink" title="PureComponent Vs Component"></a>PureComponent Vs Component</h2><p>它们几乎完全相同，但是PureComponent通过prop和state的浅比较来实现shouldComponentUpdate，某些情况下可以用PureComponent提升性能</p>
<ol>
<li>所谓<code>浅比较</code>(shallowEqual)，即react源码中的一个函数，然后根据下面的方法进行是不是<code>PureComponent</code>的判断，帮我们做了本来应该我们在<code>shouldComponentUpdate</code>中做的事情<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>而本来我们做的事情如下，这里判断了<code>state</code>有没有发生变化（prop同理），从而决定要不要重新渲染，这里的函数在一个继承了<code>Component</code>的组件中，而这里<code>this.state.person</code>是一个对象，你会发现，在这个对象的引用没有发生变化的时候是不会重新<code>render</code>的（即下面提到的第三点），所以我们可以用<code>shouldComponentUpdate</code>进行优化，这个方法如果返回<code>false</code>，表示不需要重新进行渲染，返回<code>true</code>则重新渲染，默认返回<code>true</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">   <span class="keyword">return</span> (nextState.person !== <span class="keyword">this</span>.state.person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li><p>上面提到的某些情况下可以使用<code>PureComponent</code>来提升性能，那具体是哪些情况可以，哪些情况不可以呢，实践出真知</p>
</li>
<li><p>如下显示的是一个<code>IndexPage</code>组件，设置了一个<code>state</code>是<code>isShow</code>，通过一个按钮点击可以改变它的值，</p>
</li>
</ol>
<p>结果是：初始化的时候输出的是<code>constructor</code>，<code>render</code>，而第一次点击按钮，会输出一次render，即重新渲染了一次，界面也会从显示<code>false</code>变成显示<code>true</code>，</p>
<p>但是当这个组件是继承自<code>PureComponent</code>的时候，再点击的时，不会再输出<code>render</code>，即不会再重新渲染了，而当这个组件是继承自<code>Component</code>时，还是会输出<code>render</code>，还是会重新渲染，这时候就是<code>PureComponent</code>内部做了优化的体现</p>
<ol start="4">
<li><p>同理也适用于<code>string</code>，<code>number</code>等基本数据类型，因为基本数据类型，值改变了就算改变了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isShow: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  changeState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isShow: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.changeState&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.state.isShow.toString()&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当这个<code>this.state.arr</code>是一个数组时，且这个组件是继承自<code>PureComponent</code>时，初始化依旧是输出<code>constructor</code>和<code>render</code>，但是当点击按钮时，界面上没有变化，也没有输出<code>render</code>，证明没有渲染，但是我们可以从下面的注释中看到，每点击一次按钮，我们想要修改的<code>arr</code>的值已经改变，而这个值将去修改<code>this.state.arr</code>,但是因为在<code>PureComponent</code>中<code>浅比较</code>这个数组的引用没有变化所以没有渲染，<code>this.state.arr</code>也没有更新，因为在<code>this.setState()</code>以后，值是在<code>render</code>的时候更新的，这里涉及到<code>this.setState()</code>的知识</p>
</li>
<li><p>但是当这个组件是继承自<code>Component</code>的时候，初始化依旧是输出<code>constructor</code>和<code>render</code>，但是当点击按钮时，界面上出现了变化，即我们打印处理的<code>arr</code>的值输出，而且每点击一次按钮都会输出一次<code>render</code>，证明已经重新渲染，<code>this.state.arr</code>的值已经更新，所以我们能在界面上看到这个变化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      arr:[<span class="string">'1'</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  changeState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; arr &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    arr.push(<span class="string">'2'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">    <span class="comment">// ["1", "2"]</span></span><br><span class="line">    <span class="comment">// ["1", "2", "2"]</span></span><br><span class="line">    <span class="comment">// ["1", "2", "2", "2"] </span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      arr</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.changeState&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.arr.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return item;</span></span><br><span class="line"><span class="regexp">          &#125;)&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>7.下面的例子用<code>扩展运算符</code>产生新数组，使<code>this.state.arr</code>的引用发生了变化，所以初始化的时候输出<code>constructor</code>和<code>render</code>后，每次点击按钮都会输出<code>render</code>，界面也会变化，不管该组件是继承自<code>Component</code>还是<code>PureComponent</code>的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      arr:[<span class="string">'1'</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  changeState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; arr &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      arr: [...arr, <span class="string">'2'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.changeState&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.arr.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return item;</span></span><br><span class="line"><span class="regexp">          &#125;)&#125;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>8.上面的情况同样适用于<code>对象</code>的情况</p>
<h3 id="PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件"><a href="#PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件" class="headerlink" title="PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件"></a>PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件</h3><p>1.我们让<code>IndexPage</code>组件里面包含一个子组件<code>Example</code>来展示<code>PureComponent</code>是如何影响子组件的</p>
<p>2.父组件继承<code>PureComponent</code>，子组件继承<code>Component</code>时：下面的结果初始化时输出为<code>constructor</code>，<code>IndexPage render</code>，<code>example render</code>，但是当我们点击按钮时，界面没有变化，因为这个<code>this.state.person</code>对象的引用没有改变，只是改变了它里面的属性值所以尽管子组件是继承<code>Component</code>的也没有办法渲染，因为父组件是<code>PureComponent</code>，父组件根本没有渲染，所以子组件也不会渲染</p>
<p>3.父组件继承<code>PureComponent</code>，子组件继承<code>PureComponent</code>时：因为渲染在父组件的时候就没有进行，相当于被拦截了，所以子组件是<code>PureComponent</code>还是<code>Component</code>根本不会影响结果，界面依旧没有变化</p>
<p>4.父组件继承<code>Component</code>，子组件继承<code>PureComponent</code>时：结果和我们预期的一样，即初始化是会输出<code>constructor</code>，<code>IndexPage render</code>，<code>example render</code>，但是点击的时候只会出现<code>IndexPage render</code>，因为父组件是<code>Component</code>，所以父组件会渲染，但是</p>
<p>当父组件把值传给子组件的时候，因为子组件是<code>PureComponent</code>，所以它会对<code>prop</code>进行浅比较，发现这个<code>person</code>对象的引用没有发生变化，所以不会重新渲染，而界面显示是由子组件显示的，所以界面也不会变化</p>
<p>5.父组件继承<code>Component</code>，子组件继承<code>Component</code>时：初始化是会输出<code>constructor</code>，<code>IndexPage render</code>，<code>example render</code>，当我们第一次点击按钮以后，界面发生变化，后面就不再改变，因为我们一直把它设置为sxt2，但是每点击一次都会输出<code>IndexPage render</code>，<code>example render</code>，因为每次不管父组件还是子组件都会渲染</p>
<p>6.所以正如下面第四条说的，如果<code>state</code>和<code>prop</code>一直变化的话，还是建议使用<code>Component</code>，并且<code>PureComponent</code>的最好作为展示组件</p>
<pre><code class="js"><span class="comment">//父组件</span>
<span class="keyword">import</span> React, { PureComponent, Component } <span class="keyword">from</span> <span class="string">'react'</span>;
<span class="keyword">import</span> Example <span class="keyword">from</span> <span class="string">"../components/Example"</span>;

<span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>{
  <span class="keyword">constructor</span>() {
    <span class="keyword">super</span>();
    <span class="keyword">this</span>.state = {
      person: {
        name: <span class="string">'sxt'</span>
      }
    };
    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);
  }
  changeState = <span class="function"><span class="params">()</span> =&gt;</span> {
    <span class="keyword">let</span> { person } = <span class="keyword">this</span>.state;
    person.name = <span class="string">'sxt2'</span>;
    <span class="keyword">this</span>.setState({
      person
    })
  };
  render() {
    <span class="built_in">console</span>.log(<span class="string">'IndexPage render'</span>);
    <span class="keyword">const</span> { person } = <span class="keyword">this</span>.state;
    <span class="keyword">return</span> (
      &lt;div&gt;
        &lt;button onClick={<span class="keyword">this</span>.changeState}&gt;点击&lt;<span class="regexp">/button&gt;</span>
<span class="regexp">        &lt;Example person={person} /</span>&gt;
      &lt;<span class="regexp">/div&gt;</span>
<span class="regexp">    );</span>
<span class="regexp">  }</span>
<span class="regexp">}</span>
<span class="regexp">/</span><span class="regexp">/子组件</span>
<span class="regexp">import React, { Component } from 'react';</span>
<span class="regexp"></span>
<span class="regexp">class Example extends Component {</span>
<span class="regexp"></span>
<span class="regexp">  render() {</span>
<span class="regexp">    console.log('example render');</span>
<span class="regexp">    const { person } = this.props;</span>
<span class="regexp">    return(</span>
<span class="regexp">      &lt;div&gt;</span>
<span class="regexp">        {person.name}</span>
<span class="regexp">      &lt;/</span>div&gt;
    );
  }
}
</code></pre>
<h3 id="三-若是数组和对象等引用类型，则要引用不同，才会渲染"><a href="#三-若是数组和对象等引用类型，则要引用不同，才会渲染" class="headerlink" title="三.若是数组和对象等引用类型，则要引用不同，才会渲染"></a>三.若是数组和对象等引用类型，则要引用不同，才会渲染</h3><h3 id="四-如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间"><a href="#四-如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间" class="headerlink" title="四.如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间"></a>四.如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间</h3><h3 id="五-若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较"><a href="#五-若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较" class="headerlink" title="五.若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较"></a>五.若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较</h3><p>1.继承自<code>Component</code>的组件，若是<code>shouldComponentUpdate</code>返回<code>false</code>，就不会渲染了，继承自<code>PureComponent</code>的组件不用我们手动去判断<code>prop</code>和<code>state</code>，所以在<code>PureComponent</code>中使用<code>shouldComponentUpdate</code>会有如下警告:</p>
<p><strong>IndexPage has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.</strong></p>
<p>也是比较好理解的，就是不要在<code>PureComponent</code>中使用<code>shouldComponentUpdate</code>，因为根本没有必要.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/06/一道赋值面试题引发的思考3【并发数控制】/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/06/一道赋值面试题引发的思考3【并发数控制】/" itemprop="url">一道赋值面试题引发的思考3【并发数控制】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-06T21:25:02+08:00">
                2019-02-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Promise面试题1"><a href="#Promise面试题1" class="headerlink" title="Promise面试题1"></a>Promise面试题1</h2><p>有这样一道关于promise的面试题，描述如下：</p>
<blockquote>
<p>页面上有一个输入框，两个按钮，A按钮和B按钮，点击A或者B分别会发送一个异步请求，请求完成后，结果会显示在输入框中。</p>
</blockquote>
<p>题目要求，用户随机点击A和B多次，要求输入框显示结果时，按照用户点击的顺序显示，举例：</p>
<p>用户点击了一次A，然后点击一次B，又点击一次A，输入框显示结果的顺序为先显示A异步请求结果，再次显示B的请求结果，最后再次显示A的请求结果。</p>
<p>UI界面如图：</p>
<p><img src="/2019/02/06/一道赋值面试题引发的思考3【并发数控制】/1.webp" alt=""></p>
<p>这个需求该如何用promise来实现呢？代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dom元素</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.querySelector(<span class="string">"#a"</span>)</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">document</span>.querySelector(<span class="string">"#b"</span>)</span><br><span class="line"><span class="keyword">var</span> i = <span class="built_in">document</span>.querySelector(<span class="string">"#ipt"</span>);</span><br><span class="line"><span class="comment">//全局变量p保存promie实例</span></span><br><span class="line"><span class="keyword">var</span> P = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">a.onclick  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将事件过程包装成一个promise并通过then链连接到</span></span><br><span class="line">    <span class="comment">//全局的Promise实例上，并更新全局变量，这样其他点击</span></span><br><span class="line">    <span class="comment">//就可以拿到最新的Promies执行链</span></span><br><span class="line">    P = P.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//then链里面的函数返回一个新的promise实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                resolve()</span><br><span class="line">                i.value = <span class="string">"a"</span>;</span><br><span class="line">            &#125;,<span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">b.onclick  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    P = P.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                resolve()</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"b"</span>)</span><br><span class="line">                i.value = <span class="string">"b"</span></span><br><span class="line">            &#125;,<span class="number">2000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们用定时器来模拟异步请求，仔细于阅读代码我们发现，在全局我们定义了一个全局P，P保存了一个promise的实例。</p>
<p>然后再观察点击事件的代码，用户每次点击按钮时，我们在事件中访问全局Promise实例，将异步操作包装到成新的Promise实例，然后通过全局Promise实例的then方法来连接这些行为。</p>
<p>连接的时候需要注意，then链的函数中必须将新的promise实例进行返回，不然就会执行顺序就不正确了。</p>
<p>需要注意的是，then链连接完成后，我们需要更新全局的P变量，只有这样，其它点击事件才能得到最新的Promise的执行链。</p>
<p>这样每次用户点击按钮就不需要关心回调执行时机了，因为promise的then链会按照其连接顺序依次执行。</p>
<p>这样就能保证用户的点击顺序和promise的执行顺序一致了。</p>
<h2 id="Promise面试题2"><a href="#Promise面试题2" class="headerlink" title="Promise面试题2"></a>Promise面试题2</h2><p>按照要求：</p>
<blockquote>
<p>实现 mergePromise 函数，把传进去的函数数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。</p>
</blockquote>
<p>代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergePromise = <span class="function"><span class="params">ajaxArray</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里实现你的代码</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>分析： </p>
<p>timeout是一个函数，这个函数执行后返回一个promise实例。</p>
<blockquote>
<p>ajax1 、ajax2、ajax3 都是函数，不过这些函数有一些特点，执行后都会会返回一个 新的promise实例。</p>
</blockquote>
<p>按题目的要求我们只要顺序执行这三个函数就好了，然后把结果放到 data 中，但是这些函数里都是异步操作，想要按顺序执行，然后输出 1，2，3并没有那么简单，看个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A();</span><br><span class="line">B();</span><br><span class="line"></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// a</span></span><br></pre></td></tr></table></figure></p>
<p>例子中我们是按顺序执行的 A，B 但是输出的结果却是 b，a 对于这些异步函数来说，并不会按顺序执行完一个，再执行后一个。 </p>
<p>这道题主要考察的是Promise 控制异步流程，我们要想办法，让这些函数，一个执行完之后，再执行下一个，代码如何实现呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数组中的函数执行后的结果</span></span><br><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。</span></span><br><span class="line"><span class="keyword">var</span> sequence = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">ajaxArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次的 then 方法用来执行数组中的每个函数，</span></span><br><span class="line">    <span class="comment">// 第二次的 then 方法接受数组中的函数执行后返回的结果，</span></span><br><span class="line">    <span class="comment">// 并把结果添加到 data 中，然后把 data 返回。</span></span><br><span class="line">    sequence = sequence.then(item).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        data.push(res);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，</span></span><br><span class="line"><span class="comment">// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。</span></span><br><span class="line"><span class="keyword">return</span> sequence;</span><br></pre></td></tr></table></figure></p>
<p>大概思路如下：全局定义一个promise实例sequence，循环遍历函数数组，每次循环更新sequence，将要执行的函数item通过sequence的then方法进行串联，并且将执行结果推入data数组，最后将更新的data返回，这样保证后面sequence调用then方法，如何后面的函数需要使用data只需要将函数改为带参数的函数。</p>
<h2 id="Promise面试题3"><a href="#Promise面试题3" class="headerlink" title="Promise面试题3"></a>Promise面试题3</h2><p>题目是这样的：</p>
<blockquote>
<p>有 8 个图片资源的 url，已经存储在数组 urls 中（即urls = [‘<a href="http://example.com/1.jpg&#39;" target="_blank" rel="noopener">http://example.com/1.jpg&#39;</a>, …., ‘<a href="http://example.com/8.jpg&#39;]），而且已经有一个函数" target="_blank" rel="noopener">http://example.com/8.jpg&#39;]），而且已经有一个函数</a> function loadImg，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。</p>
</blockquote>
<p>但是我们要求，任意时刻，<strong>同时下载的链接数量不可以超过 3 个</strong>。</p>
<p>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p>
<p>已有代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> urls = [</span><br><span class="line">    <span class="string">'https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg'</span>, </span><br><span class="line">    <span class="string">'https://www.kkkk1000.com/images/getImgData/gray.gif'</span>, </span><br><span class="line">    <span class="string">'https://www.kkkk1000.com/images/getImgData/Particle.gif'</span>, </span><br><span class="line">    <span class="string">'https://www.kkkk1000.com/images/getImgData/arithmetic.png'</span>, </span><br><span class="line">    <span class="string">'https://www.kkkk1000.com/images/getImgData/arithmetic2.gif'</span>, </span><br><span class="line">    <span class="string">'https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg'</span>, </span><br><span class="line">    <span class="string">'https://www.kkkk1000.com/images/getImgData/arithmetic.gif'</span>, </span><br><span class="line">    <span class="string">'https://www.kkkk1000.com/images/wxQrCode2.png'</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'一张图片加载完成'</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        img.onerror = reject</span><br><span class="line">        img.src = url</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>看到这个题目的时候，脑袋里瞬间想到了高效率排队买地铁票的情景，那个情景类似下图：</p>
<p><img src="/2019/02/06/一道赋值面试题引发的思考3【并发数控制】/2.webp" alt=""></p>
<p>上图这样的排队和并发请求的场景基本类似，窗口只有三个，人超过三个之后，后面的人只能排队了。</p>
<p>首先想到的便是利用递归来做，就如这篇文章采取的措施一样，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//对加载图片的函数做处理，计数器叠加计数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bao</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"并发数:"</span>,count)</span><br><span class="line">    <span class="comment">//条件判断，urls长度大于0继续，小于等于零说明图片加载完成</span></span><br><span class="line">    <span class="keyword">if</span>(urls.length&gt;<span class="number">0</span>&amp;&amp;count&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//shift从数组中取出连接</span></span><br><span class="line">        loadImg(urls.shift()).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//计数器递减</span></span><br><span class="line">            count--</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            &#125;).then(bao)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//循环开启三次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        bao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br></pre></td></tr></table></figure></p>
<p>以上是最常规的思路，我将加载图片的函数loadImg封装在bao函数内，根据条件判断，是否发送请求，请求完成后继续递归调用。</p>
<p>以上代码所有逻辑都写在了同一个函数中然后递归调用，可以优化一下，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;   <span class="comment">//当前正在进行数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装请求的异步函数,增加计数器功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    loadImg(urls.shift()).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            count--</span><br><span class="line">            &#125;).then(diaodu)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责调度的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diaodu</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(urls.length&gt;<span class="number">0</span>&amp;&amp;count&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">        request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">        request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br></pre></td></tr></table></figure></p>
<p>上面代码将一个递归函数拆分成两个，一个函数只负责计数和发送请求，另外一个负责调度。</p>
<p>这里的请求既然已经被封装成了Promise，那么我们用Promise和saync、await来完成一下，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 全局锁</span></span><br><span class="line"><span class="keyword">var</span> lock = [];</span><br><span class="line"><span class="keyword">var</span> l = urls.length;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bao</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">//超过限制利用await和promise进行阻塞;</span></span><br><span class="line">        <span class="keyword">let</span> _resolve;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            _resolve=resolve;</span><br><span class="line">            <span class="comment">// resolve不执行,将其推入lock数组;</span></span><br><span class="line">            lock.push(_resolve);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(urls.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">await</span> loadImg(urls.shift());</span><br><span class="line">        count--;</span><br><span class="line">        lock.length&amp;&amp;lock.shift()()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    bao();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大致思路是，遍历执行urls.length长度的请求，但是当请求并发数大于限制时，超过的请求用await结合promise将其阻塞，并且将resolve填充到lock数组中，继续执行，并发过程中有图片加载完成后，从lock中推出一项resolve执行，lock相当于一个叫号机；</p>
<p>以上代码可以优化为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//省略代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 全局锁</span></span><br><span class="line"><span class="keyword">var</span> lock = [];</span><br><span class="line"><span class="keyword">var</span> l = urls.length;</span><br><span class="line"><span class="comment">// 阻塞函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve;</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        _resolve=resolve;</span><br><span class="line">        <span class="comment">// resolve不执行,将其推入lock数组;</span></span><br><span class="line">        lock.push(_resolve);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 叫号机</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    lock.length&amp;&amp;lock.shift()()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bao</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(count&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="comment">//超过限制利用await和promise进行阻塞;</span></span><br><span class="line">        <span class="keyword">await</span> block();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(urls.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(count);</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">await</span> loadImg(urls.shift());</span><br><span class="line">        count--;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">    bao();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一种方案，也是我十分喜欢的，思考好久才明白，大概思路如下：</p>
<p>用 Promise.race来实现，先并发请求3个图片资源，这样可以得到 3 个 Promise实例，组成一个数组promises ，然后不断的调用 Promise.race 来返回最快改变状态的 Promise，然后从数组（promises ）中删掉这个 Promise 对象实例，再加入一个新的 Promise实例，直到全部的 url 被取完。</p>
<p>代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">limitLoad</span>(<span class="params">urls, handler, limit</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对数组做一个拷贝</span></span><br><span class="line">    <span class="keyword">const</span> sequence = [].concat(urls)</span><br><span class="line">    <span class="keyword">let</span> promises = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发请求到最大数</span></span><br><span class="line">    promises = sequence.splice(<span class="number">0</span>, limit).map(<span class="function">(<span class="params">url, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里返回的 index 是任务在 promises 的脚标，</span></span><br><span class="line">        <span class="comment">//用于在 Promise.race 之后找到完成的任务脚标</span></span><br><span class="line">        <span class="keyword">return</span> handler(url).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> p = <span class="built_in">Promise</span>.race(promises);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sequence.length; i++) &#123;</span><br><span class="line">            p = p.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">                promises[res] = handler(sequence[i]).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.race(promises)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br><span class="line">limitLoad(urls, loadImg, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>第三种方案的巧妙之处，在于使用了Promise.race。并且在循环时用then链串起了执行顺序。</p>
<h3 id="15-行代码实现并发控制（javascript）"><a href="#15-行代码实现并发控制（javascript）" class="headerlink" title="15 行代码实现并发控制（javascript）"></a>15 行代码实现并发控制（javascript）</h3><p>做过爬虫的都知道，要控制爬虫的请求并发量，其实也就是控制其爬取频率，以免被封IP，还有的就是以此来控制爬虫应用运行内存，否则一下子处理N个请求，内存分分钟会爆。 </p>
<p>而 <code>python</code>爬虫一般用多线程来控制并发，</p>
<p>然而如果是<code>node.js</code>爬虫，由于其<strong>单线程无阻塞</strong>性质以及事件循环机制，一般不用多线程来控制并发（当然<code>node.js</code>也可以实现多线程，此处非重点不再多讲），而是更加简便地直接在代码层级上实现并发。</p>
<p>为图方便，开发者在开发<code>node</code>爬虫一般会找一个并发控制的<code>npm包</code>，然而第三方的模块有时候也并不能完全满足我们的特殊需求，这时候我们可能就需要一个自己定制版的并发控制函数。</p>
<p>下面我们用15行代码实现一个并发控制的函数。</p>
<p>首先，一个基本的并发控制函数，基本要有以下3个参数：</p>
<ul>
<li><code>list</code> {Array} - 要迭代的数组</li>
<li><code>limit</code> {number} - 控制的并发数量</li>
<li><code>asyncHandle</code> {function} - 对<code>list</code>的每一个项的处理函数</li>
</ul>
<h4 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h4><p>以下以爬虫为实例进行讲解</p>
<p>设计思路其实很简单，假如并发量控制是 5</p>
<p>1.首先，瞬发 5 个异步请求，我们就得到了并发的 5 个异步请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// limit = 5</span></span><br><span class="line"><span class="keyword">while</span>(limit--) &#123;</span><br><span class="line">    handleFunction(list)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后，这 5 个异步请求中无论哪一个先执行完，都会继续执行下一个<code>list</code>项</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> recursion = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncHandle(arr.shift())</span><br><span class="line">        .then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">// 迭代数组长度不为0， 递归执行自身if (arr.length!==0) return recursion(arr) </span></span><br><span class="line">            <span class="comment">// 迭代数组长度为0，结束 elsereturn'finish';</span></span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>等<code>list</code>所有的项迭代完之后的回调</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.all(allHandle)</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>上述步骤组合起来，就是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @params list &#123;Array&#125; - 要迭代的数组</span></span><br><span class="line"><span class="comment"> * @params limit &#123;Number&#125; - 并发数量控制数</span></span><br><span class="line"><span class="comment"> * @params asyncHandle &#123;Function&#125; - 对`list`的每一个项的处理函数，参数为当前处理项，必须 return 一个Promise来确定是否继续进行迭代</span></span><br><span class="line"><span class="comment"> * @return &#123;Promise&#125; - 返回一个 Promise 值来确认所有数据是否迭代完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> mapLimit = <span class="function">(<span class="params">list, limit, asyncHandle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> recursion = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> asyncHandle(arr.shift())</span><br><span class="line">            .then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr.length!==<span class="number">0</span>) <span class="keyword">return</span> recursion(arr)   <span class="comment">// 数组还未迭代完，递归继续进行迭代</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">'finish'</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> listCopy = [].concat(list);</span><br><span class="line">    <span class="keyword">let</span> asyncList = []; <span class="comment">// 正在进行的所有并发异步操作</span></span><br><span class="line">    <span class="keyword">while</span>(limit--) &#123;</span><br><span class="line">        asyncList.push( recursion(listCopy) ); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(asyncList);  <span class="comment">// 所有并发异步操作都完成后，本次并发控制迭代完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="测试demo"><a href="#测试demo" class="headerlink" title="测试demo"></a>测试demo</h3><p>模拟一下异步的并发情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataLists = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">100</span>,<span class="number">123</span>];</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">mapLimit(dataLists, <span class="number">3</span>, (curItem)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(curItem, <span class="string">'当前并发量:'</span>, count--)</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="built_in">Math</span>.random() * <span class="number">5000</span>)  </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finish'</span>, response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>结果如下：</p>
<p><img src="/2019/02/06/一道赋值面试题引发的思考3【并发数控制】/3.webp" alt=""></p>
<p>手动抛出异常中断并发函数测试：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataLists = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">100</span>,<span class="number">123</span>];</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">mapLimit(dataLists, <span class="number">3</span>, (curItem)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        count++</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(curItem, <span class="string">'当前并发量:'</span>, count--)</span><br><span class="line">            <span class="keyword">if</span>(curItem &gt; <span class="number">4</span>) reject(<span class="string">'error happen'</span>)</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="built_in">Math</span>.random() * <span class="number">5000</span>)  </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finish'</span>, response)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>并发控制情况下，迭代到5,6,7 手动抛出异常，停止后续迭代：</p>
<p><img src="/2019/02/06/一道赋值面试题引发的思考3【并发数控制】/4.webp" alt=""> </p>
<h2 id="JS数组拍平-扁平化-的3种方法"><a href="#JS数组拍平-扁平化-的3种方法" class="headerlink" title="JS数组拍平[扁平化]的3种方法"></a>JS数组拍平[扁平化]的3种方法</h2><p>在开发过程中有得时候总是碰一些共性的问题，比如将一个二维数组拍平成一维数组，或者三维数组拍平成一维数组。这些问题在遇到的时候总会重新思考，不如将其提炼出来，总结一下。</p>
<p>下面笔者将为大家演示一下，将一个多维数组拍平成一个一维数组的两种方法，算是抛砖引玉，大家有更好的方法可以在留言区发表。</p>
<p>首先是第一种方法，闭包+递归处理，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, [<span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]],[<span class="number">333</span>, <span class="number">4444</span>]];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">product</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1、创建一个空数组,</span></span><br><span class="line">    <span class="keyword">var</span> newarr = [];</span><br><span class="line">    <span class="comment">///2、并且返回一个函数,函数参数为要拍平的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">flatten</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 3、循环数组，判断每一项,不为输的话将其塞入newarr</span></span><br><span class="line">        <span class="comment">// 若为数组,递归调用 faltten,并将结果与newarr合并</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t <span class="keyword">of</span> arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(t)) &#123;</span><br><span class="line">                newarr.push(t);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newarr.concat(flatten(t))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newarr</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flatten = product();</span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure></p>
<p>执行结果为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">333</span>, <span class="number">4444</span>]</span><br></pre></td></tr></table></figure></p>
<p>上面这这种方法比较中规中矩，代码详解见注释，下面这种方法运用到了javascript语言的一些新特性，代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, [<span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]], [<span class="number">333</span>, <span class="number">4444</span>] ];</span><br><span class="line">functionflatten(arr)&#123;</span><br><span class="line">  <span class="keyword">return</span>  arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">pre,cur</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(cur))&#123;</span><br><span class="line">            <span class="keyword">return</span> [...pre,cur];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> [...pre,...flatten(cur)]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr))</span><br></pre></td></tr></table></figure></p>
<p>上面代码中用了ES6的一个新特性扩展云算法 “…”，“[…abc,…fff]”其作用相当于abc.concat(fff),这种用法更加直观明了，还有就是运用了reduce方法。reduce是javascript语言中数组的一个方法。</p>
<p>数组调用recduce方法时，可以传递两个参数，第一个参数为回调函数，第二个参数为一个初始值。回调函数中需要传递两个参数，第一个参数为每次执行函数的返回值，第二个参数为当前索引对应数组的值。reduce的第二个参数是可以省略的，省略的话，回调函数第一次调用的参数为数组的第一项和第二项的值，如果没有省略，回调函数的第一个参数就是这个初始值。上面的例子，reduce的第二个参数设置了一个空数组。</p>
<p>相比来说第一种比较好理解，第二种的难点在于对reduce函数的运用和理解。</p>
<p>第三种比较粗暴<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, [<span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]],[<span class="number">333</span>, <span class="number">4444</span>]];</span><br><span class="line"> </span><br><span class="line">arr.join(<span class="string">","</span>).split(<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//["1", "2", "3", "3", "3", "3", "5", "4", "5", "6", "6", "7", "8", "333", "4444"]</span></span><br></pre></td></tr></table></figure></p>
<h2 id="页面返回要刷新"><a href="#页面返回要刷新" class="headerlink" title="页面返回要刷新"></a>页面返回要刷新</h2><p><strong> 之前在项目中使用pageshow，发现页面返回的时候persisted依然为false，这时候只好找其他方案解决。</strong><br>这时候发现有一个window.performance对象，performance.navigation.type是一个无符号短整型</p>
<ul>
<li>TYPE_NAVIGATE (0)：<br>当前页面是通过点击链接，书签和表单提交，或者脚本操作，或者在url中直接输入地址，type值为0</li>
<li>TYPE_RELOAD (1)<br>点击刷新页面按钮或者通过Location.reload()方法显示的页面，type值为1</li>
<li>TYPE_BACK_FORWARD (2)<br>页面通过历史记录和前进后退访问时。type值为2</li>
<li>TYPE_RESERVED (255)<br>任何其他方式，type值为255</li>
</ul>
<p>这真是我们需要的部分，于是可以预见，解决方案如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.persisted || (<span class="built_in">window</span>.performance &amp;&amp; </span><br><span class="line">    <span class="built_in">window</span>.performance.navigation.type == <span class="number">2</span>)) &#123;</span><br><span class="line">    location.reload()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="两个鲜有人知的-Vuex-技巧"><a href="#两个鲜有人知的-Vuex-技巧" class="headerlink" title="两个鲜有人知的 Vuex 技巧"></a>两个鲜有人知的 Vuex 技巧</h2><p>当在我们 Vue.js 的组件中使用了 Vuex，除了映射功能的函数之外，我们好像忘记了它所暴露出来的其他有用的 API。</p>
<p>我们一起来看看可以利用它来干些什么。首先，还是先来创建一个基本的 store：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    getCountPlusOne: <span class="function"><span class="params">state</span> =&gt;</span> state.count + <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment(state) &#123;</span><br><span class="line">      state.count++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="Watch-方法"><a href="#Watch-方法" class="headerlink" title="Watch 方法"></a>Watch 方法</h3><p><code>watch</code> 是将 Vuex 与其他外部代码整合的最有用的方法，可以在你的 <code>awesomeService</code> 或者是在 <code>catchAllAuthUtils</code> 等等类似的服务中使用。</p>
<p>使用示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unsubscribe = store.watch(</span><br><span class="line">  (state, getters) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [state.count, getters.getCountPlusOne];</span><br><span class="line">  &#125;,</span><br><span class="line">  watched =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Count is:"</span>, watched[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Count plus one is:"</span>, watched[<span class="number">1</span>]);</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// To unsubscribe:</span></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure></p>
<p>我们所做的就是在调用 vuex 的实例方法 <code>watch</code> 时，传入两个函数作为实参，第一个函数实参返回我们想要在 state 与/或 getters 上监听的属性；第二个函数实参是当属性值 <code>state.count</code> 或 <code>getters.getCountPlusOne</code> 有改变时，调用的回调函数。</p>
<p>这是用来结合 Vuex 与 react 或者 angular 甚至是 JQuery 代码时，非常有用的技巧。</p>
<p>可以在这个 <a href="https://codesandbox.io/s/vm6r05qjq0" target="_blank" rel="noopener">CodeSandbox</a> 上查看例子。</p>
<h3 id="SubscribeAction-方法"><a href="#SubscribeAction-方法" class="headerlink" title="SubscribeAction 方法"></a>SubscribeAction 方法</h3><p>有时候，与其监听 store 中的一个属性改变，不如使用 <code>subscribeAction</code> 方法订阅一个特定的 action，比如像 <code>login</code> 和 <code>logout</code> 之类的异步请求，这也是更有用的方案。</p>
<p>调用监听函数，在每一个 action 分发的时候调用指定的回调函数，并在其中调用自定义代码。</p>
<p>我们在每一个 action 的分发前以及完成后，来分别开始和停止全局的 spinner。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> unsubscribe = store.subscribeAction(&#123;</span><br><span class="line">  before: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    startBigLoadingSpinner();</span><br><span class="line">  &#125;,</span><br><span class="line">  after: <span class="function">(<span class="params">action, state</span>) =&gt;</span> &#123;</span><br><span class="line">    stoptBigLoadingSpinner();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// To unsubscribe:</span></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/Vue组件通信方式全面详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/Vue组件通信方式全面详解/" itemprop="url">Vue组件通信方式全面详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T15:22:59+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>众所周知，Vue 主要思想之一就是组件式开发。因此，在实际的项目开发中，肯定会以组件的开发模式进行。形如页面和页面之间需要通信一样，Vue 组件和组件之间肯定也需要互通有无、共享状态。接下来，我们就悉数给大家展示所有 Vue 组件之间的通信方式。</p>
<h2 id="组件关系"><a href="#组件关系" class="headerlink" title="组件关系"></a>组件关系</h2><p><img src="/2019/02/03/Vue组件通信方式全面详解/1.png" alt="Vue 组件通信.png"></p>
<p>上面展示的图片可以引入所有 Vue 组件的关系形式：</p>
<ul>
<li>A 组件和 B 组件、B 组件和 C 组件、B 组件和 D 组件形成了父子关系</li>
<li>C 组件和 D 组件形成了兄弟关系</li>
<li>A 组件和 C 组件、A 组件和 D 组件形成了隔代关系（其中的层级可能是多级，即隔多代）</li>
</ul>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>这么多的组件关系，那么组件和组件之间又有哪些通信的方式呢？各种方式的区别又是什么？适用场景又是什么呢？带着问题继续往下看吧！</p>
<h3 id="props-和-emit"><a href="#props-和-emit" class="headerlink" title="props 和 $emit"></a><code>props</code> 和 <code>$emit</code></h3><p>用过 Vue 技术栈开发项目过的开发者对这样一个组合肯定不会陌生，这种组件通信的方式是我们运用的非常多的一种。props 以单向数据流的形式可以很好的完成父子组件的通信。</p>
<p>所谓单向数据流：就是数据只能通过 props 由父组件流向子组件，而子组件并不能通过修改 props 传过来的数据修改父组件的相应状态。至于为什么这样做，Vue 官网做出了解释：</p>
<p><strong>所有的 prop 都使得其父子 prop 之间形成了一个<code>单向下行绑定</code>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</strong></p>
<p><strong>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。</strong></p>
<p>正因为这个特性，于是就有了对应的 <code>$emit</code>。<code>$emit</code> 用来触发当前实例上的事件。对此，我们可以在父组件自定义一个处理接受变化状态的逻辑，然后在子组件中如若相关的状态改变时，就触发父组件的逻辑处理事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">Vue.component(<span class="string">'parent'</span>, &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;this is parent component!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;child :message="message" v-on:getChildData="getChildData"&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    <span class="comment">// 执行子组件触发的事件</span></span><br><span class="line">    getChildData(val) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="text" v-model="myMessage" @input="passData(myMessage)"&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 得到父组件传递过来的数据</span></span><br><span class="line"><span class="comment">   * 这里的定义最好是写成数据校验的形式，免得得到的数据是我们意料之外的</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * props: &#123;</span></span><br><span class="line"><span class="comment">   *   message: &#123;</span></span><br><span class="line"><span class="comment">   *     type: String,</span></span><br><span class="line"><span class="comment">   *     default: ''</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  props:[<span class="string">'message'</span>], </span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 这里是必要的，因为你不能直接修改 props 的值</span></span><br><span class="line">      myMessage: <span class="keyword">this</span>.message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    passData(val) &#123;</span><br><span class="line">      <span class="comment">// 数据状态变化时触发父组件中的事件this.$emit('getChildData', val);</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;parent /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，有父组件 parent 和子组件 child。</p>
<ul>
<li>父组件传递了 message 数据给子组件，并且通过v-on绑定了一个 getChildData 事件来监听子组件的触发事件；</li>
<li>子组件通过 props 得到相关的 message 数据，然后将数据缓存在 data 里面，最后当属性数据值发生变化时，通过 this.$emit 触发了父组件注册的 getChildData 事件处理数据逻辑。</li>
</ul>
<h3 id="attrs-和-listeners"><a href="#attrs-和-listeners" class="headerlink" title="$attrs 和 $listeners"></a><code>$attrs</code> 和 <code>$listeners</code></h3><p>上面这种组件通信的方式只适合直接的父子组件，也就是如果父组件A下面有子组件B，组件B下面有组件C，这时如果组件A直接想传递数据给组件C那就行不通了！ 只能是组件A通过 props 将数据传给组件B，然后组件B获取到组件A 传递过来的数据后再通过 props 将数据传给组件C。当然这种方式是非常复杂的，无关组件中的逻辑业务一种增多了，代码维护也没变得困难，再加上如果嵌套的层级越多逻辑也复杂，无关代码越多！</p>
<p>针对这样一个问题，<code>Vue 2.4</code> 提供了<code>$attrs</code> 和 <code>$listeners</code> 来实现能够直接让组件A传递消息给组件C。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件A</span></span><br><span class="line">Vue.component(<span class="string">'A'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;this is parent component!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;B :messagec="messagec" :message="message" v-on:getCData="getCData" v-on:getChildData="getChildData(message)"&gt;&lt;/B&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span>,</span><br><span class="line">      messagec: <span class="string">'hello c'</span><span class="comment">//传递给c组件的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 执行B子组件触发的事件</span></span><br><span class="line">    getChildData(val) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`这是来自B组件的数据：<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行C子组件触发的事件</span></span><br><span class="line">    getCData(val) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`这是来自C组件的数据：<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件B</span></span><br><span class="line">Vue.component(<span class="string">'B'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; </span></span><br><span class="line"><span class="string">      &lt;!-- C组件中能直接触发 getCData 的原因在于：B组件调用 C组件时，使用 v-on 绑定了 $listeners 属性 --&gt;</span></span><br><span class="line"><span class="string">      &lt;!-- 通过v-bind 绑定 $attrs 属性，C组件可以直接获取到 A组件中传递下来的 props（除了 B组件中 props声明的） --&gt;</span></span><br><span class="line"><span class="string">      &lt;C v-bind="$attrs" v-on="$listeners"&gt;&lt;/C&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 得到父组件传递过来的数据</span></span><br><span class="line"><span class="comment">   * 这里的定义最好是写成数据校验的形式，免得得到的数据是我们意料之外的</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * props: &#123;</span></span><br><span class="line"><span class="comment">   *   message: &#123;</span></span><br><span class="line"><span class="comment">   *     type: String,</span></span><br><span class="line"><span class="comment">   *     default: ''</span></span><br><span class="line"><span class="comment">   *   &#125;</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  props: [<span class="string">'message'</span>],</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      mymessage: <span class="keyword">this</span>.message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    passData(val)&#123;</span><br><span class="line">      <span class="comment">//触发父组件中的事件this.$emit('getChildData', val)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件C</span></span><br><span class="line">Vue.component(<span class="string">'C'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="text" v-model="$attrs.messagec" @input="passCData($attrs.messagec)"&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    passCData(val) &#123;</span><br><span class="line">      <span class="comment">// 触发父组件A中的事件this.$emit('getCData',val)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;A /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，我们定义了 A，B，C 三个组件，其中组件B 是组件 A 的子组件，组件C 是组件B 的子组件。</p>
<ul>
<li>在组件 A 里面为组件 B 和组件 C 分别定义了一个属性值（message，messagec）和监听事件（getChildData，getCData），并将这些通过 props 传递给了组件 A 的直接子组件 B；</li>
<li>在组件 B 中通过 props 只获取了与自身直接相关的属性（message），并将属性值缓存在了 data 中，以便后续的变化监听处理，然后当属性值变化时触发父组件 A 定义的数据逻辑处理事件（getChildData）。关于组件 B 的直接子组件 C，传递了属性 <code>$attrs</code> 和绑定了事件 <code>$listeners</code>；</li>
<li>在组件 C 中直接在 v-model 上绑定了 <code>$attrs</code> 属性，通过 v-on 绑定了 <code>$listeners</code>；</li>
</ul>
<p>最后就将 <code>$attrs</code> 和 <code>$listeners</code> 单独拿出来说说吧！</p>
<ul>
<li><p><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定属性 (class和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件。</p>
</li>
<li><p><code>$listeners</code>：包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件。</p>
</li>
</ul>
<h3 id="中央事件总线-EventBus"><a href="#中央事件总线-EventBus" class="headerlink" title="中央事件总线 EventBus"></a>中央事件总线 EventBus</h3><p>对于父子组件之间的通信，上面的两种方式是完全可以实现的，但是对于两个组件不是父子关系，那么又该如何实现通信呢？在项目规模不大的情况下，完全可以使用中央事件总线 <code>EventBus</code> 的方式。如果你的项目规模是大中型的，那你可以使用我们后面即将介绍的 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.yuque.com%2Flittlelane%2Fvue%2Fkllzcm%231765f2e8" target="_blank" rel="noopener">Vuex 状态管理</a>。</p>
<p><code>EventBus</code> 通过新建一个 <code>Vue</code> 事件 <code>bus</code> 对象，然后通过 <code>bus.$emit</code> 触发事件，<code>bus.$on</code> 监听触发的事件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件 A</span></span><br><span class="line">Vue.component(<span class="string">'A'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;this is A component!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; </span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      mymessage: <span class="string">'hello brother1'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    passData(val) &#123;</span><br><span class="line">      <span class="comment">//触发全局事件globalEventthis.$EventBus.$emit('globalEvent', val)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件 B</span></span><br><span class="line">Vue.component(<span class="string">'B'</span>, &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;this is B component!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;组件A 传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      mymessage: <span class="string">'hello brother2'</span>,</span><br><span class="line">      brothermessage: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">//绑定全局事件globalEventthis.$EventBus.$on('globalEvent', (val) =&gt; &#123;</span></span><br><span class="line">      <span class="keyword">this</span>.brothermessage = val;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义中央事件总线const EventBus = new Vue();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将中央事件总线赋值到 Vue.prototype 上，这样所有组件都能访问到了</span></span><br><span class="line">Vue.prototype.$EventBus = EventBus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;A /&gt;</span></span><br><span class="line"><span class="string">      &lt;B /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的实例中，我们定义了组件 A 和组件 B，但是组件 A 和组件 B 之间没有任何的关系。</p>
<ul>
<li>1)、 首先我们通过 <code>new Vue()</code> 实例化了一个 Vue 的实例，也就是我们这里称呼的中央事件总线 EventBus ，然后将其赋值给了 <code>Vue.prototype.$EventBus</code>，使得所有的业务逻辑组件都能够访问到；</li>
<li>2)、 然后定义了组件 A，在组件 A 里面定义了一个处理的方法 passData，主要定义触发一个全局的 <code>globalEvent</code> 事件，并传递一个参数；</li>
<li>3). 最后定义了组件 B，在组件 B 里面的 <code>mounted</code> 生命周期监听了组件 A 里面定义的全局 <code>globalEvent</code> 事件，并在回调函数里面执行了一些逻辑处理。</li>
</ul>
<p>中央事件总线 <code>EventBus</code> 非常简单，就是任意组件和组件之间打交道，没有多余的业务逻辑，只需要在状态变化组件触发一个事件，然后在处理逻辑组件监听该事件就可以。该方法非常适合小型的项目！</p>
<h3 id="provide-和-inject"><a href="#provide-和-inject" class="headerlink" title="provide 和 inject"></a><code>provide</code> 和 <code>inject</code></h3><p>熟悉 React 开发的同学对 <code>Context API</code> 肯定不会陌生吧！在 Vue 中也提供了类似的 API 用于组件之间的通信。</p>
<p>在父组件中通过 <code>provider</code> 来提供属性，然后在子组件中通过 inject 来注入变量。不论子组件有多深，只要调用了 <code>inject</code> 那么就可以注入在 provider 中提供的数据，而不是局限于只能从当前父组件的 prop 属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。这和 React 中的 <code>Context API</code> 有没有很相似！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 parent 组件</span></span><br><span class="line">Vue.component(<span class="string">'parent'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;this is parent component!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;child&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    <span class="keyword">for</span>:<span class="string">'test'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 child 组件</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="tet" v-model="mymessage"&gt; </span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  inject: [<span class="string">'for'</span>],	<span class="comment">// 得到父组件传递过来的数据</span></span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      mymessage: <span class="keyword">this</span>.for</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;parent /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面的实例中，我们定义了组件 <code>parent</code> 和组件 <code>child</code>，组件 <code>parent</code> 和组件 <code>child</code> 是父子关系。</p>
<ul>
<li>1)、 在 <code>parent</code> 组件中，通过 <code>provide</code> 属性，以对象的形式向子孙组件暴露了一些属性</li>
<li>2)、 在 <code>child</code> 组件中，通过 <code>inject</code> 属性注入了 <code>parent</code> 组件提供的数据，实际这些通过 <code>inject</code> 注入的属性是挂载到 Vue 实例上的，所以在组件内部可以通过 this 来访问。</li>
</ul>
<blockquote>
<p>⚠️ 注意：官网文档提及 provide 和 inject 主要为高阶插件/组件库提供用例，并不推荐直接用于应用程序代码中。</p>
</blockquote>
<p>关于 <code>provide</code> 和 <code>inject</code> 这对属性的更多具体用法可以参照<a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%3F%23provide-inject" target="_blank" rel="noopener">官网的文档</a>。</p>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a><code>v-model</code></h3><p>这种方式和前面讲到的 props 有点类型，但是既然单独提出来说了，那肯定也有其独特之处！不管了，先上代码吧！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 parent 组件</span></span><br><span class="line">Vue.component(<span class="string">'parent'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;this is parent component!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;child v-model="message"&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 child 组件</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; </span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: <span class="built_in">String</span>, <span class="comment">// v-model 会自动传递一个字段为 value 的 props 属性</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      mymessage: <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeValue() &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.mymessage); <span class="comment">//通过如此调用可以改变父组件上 v-model 绑定的值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">     &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;parent /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>说到 v-model 这个指定，大家肯定会想到双向数据绑定，如 input 输入值，下面的显示就是实时的根据输入的不同而显示相应的内容。刚开始学习 Vue 的时候有没有觉得很神奇，不管你有没有，反正我有过这种感觉！</p>
<p>关于详细的 v-model 用法和自定义组件 v-model 的实现，可以到<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.yuque.com%2Flittlelane%2Fvue%2Fiqevua" target="_blank" rel="noopener">这里</a>查看！这里我们主要讲解 v-model 是如何实现父子组件通信的。</p>
<p>在上面的实例代码中，我们定义了 parent 和 child 两个组件，这两个组件是父子关系，v-model 也只能实现父子组件之间的通信。</p>
<ul>
<li>1)、 在 parent 组件中，我们给自定义的 child 组件实现了 v-model 绑定了 message 属性。此时相当于给 child 组件传递了 value 属性和绑定了 input 事件。</li>
<li>2)、 顺理成章，在定义的 child 组件中，可以通过 props 获取 value 属性，根据 props 单向数据流的原则，又将 value 缓存在了 data 里面的 mymessage 上，再在 input 上通过 <code>v-model</code> 绑定了 <code>mymessage</code> 属性和一个 <code>change</code> 事件。当 input 值变化时，就会触发 change 事件，处理 parent 组件通过 <code>v-model</code> 给 child 组件绑定的 <code>input</code> 事件，触发 <code>parent</code> 组件中 <code>message</code> 属性值的变化，完成 <code>child</code> 子组件改变 parent 组件的属性值。</li>
</ul>
<p>这里主要是 <code>v-model</code> 的实现原理要着重了解一下！这种方式的用处适合于将展示组件和业务逻辑组件分离。</p>
<h3 id="parent-和-children"><a href="#parent-和-children" class="headerlink" title="$parent 和 $children"></a><code>$parent</code> 和 <code>$children</code></h3><p>这里要说的这种方式就比较直观了，直接操作父子组件的实例。<code>$parent</code> 就是父组件的实例对象，而 <code>$children</code> 就是当前实例的直接子组件实例了，不过这个属性值是数组类型的，且并不保证顺序，也不是响应式的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 parent 组件</span></span><br><span class="line">Vue.component(<span class="string">'parent'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;this is parent component!&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;button @click="changeChildValue"&gt;test&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;child /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'hello'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeChildValue()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$children[<span class="number">0</span>].mymessage = <span class="string">'hello'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 child 组件</span></span><br><span class="line">Vue.component(<span class="string">'child'</span>, &#123;</span><br><span class="line">  template:<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;input type="text" v-model="mymessage" @change="changeValue" /&gt; </span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      mymessage: <span class="keyword">this</span>.$parent.message</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeValue()&#123;</span><br><span class="line">      <span class="keyword">this</span>.$parent.message = <span class="keyword">this</span>.mymessage;<span class="comment">//通过如此调用可以改变父组件的值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &lt;parent /&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在上面实例代码中，分别定义了 parent 和 child 组件，这两个组件是直接的父子关系。两个组件分别在内部定义了自己的属性。在 parent 组件中，直接通过 <code>this.$children[0].mymessage = &#39;hello&#39;;</code> 给 <code>child</code> 组件内的 <code>mymessage</code> 属性赋值，而在 child 子组件中，同样也是直接通过<code>this.$parent.message</code> 给 <code>parent</code> 组件中的 <code>message</code> 赋值，形成了父子组件通信。</p>
<p>关于 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23vm-parent" target="_blank" rel="noopener"><code>$parent</code></a> 和 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23vm-children" target="_blank" rel="noopener"><code>$children</code></a> 这对属性的详细介绍可以查询官网文档！</p>
<h3 id="boradcast-和-dispatch"><a href="#boradcast-和-dispatch" class="headerlink" title="$boradcast 和 $dispatch"></a><code>$boradcast</code> 和 <code>$dispatch</code></h3><p>这也是一对成对出现的方法，不过只是在 <code>Vue1.0</code> 中提供了，而 <code>Vue2.0</code> 被废弃了，但是还是有很多开源软件都自己封装了这种组件通信的方式，比如 <a href="https://link.juejin.im?target=http%3A%2F%2Fmint-ui.github.io%2F%23!%2Fzh-cn" target="_blank" rel="noopener">Mint UI</a>、<a href="https://link.juejin.im?target=http%3A%2F%2Felement-cn.eleme.io%2F%23%2Fzh-CN" target="_blank" rel="noopener">Element UI</a> 和 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.iviewui.com%2F" target="_blank" rel="noopener">iView</a> 等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// broadcast 方法的主逻辑处理方法functionbroadcast(componentName, eventName, params) &#123;</span></span><br><span class="line">  <span class="keyword">this</span>.$children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = child.$options.componentName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name === componentName) &#123;</span><br><span class="line">      child.$emit.apply(child, [eventName].concat(params));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      broadcast.apply(child, [componentName, eventName].concat(params));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exportdefault &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 定义 dispatch 方法</span></span><br><span class="line">    dispatch(componentName, eventName, params) &#123;</span><br><span class="line">      <span class="keyword">let</span> parent = <span class="keyword">this</span>.$parent;</span><br><span class="line">      <span class="keyword">let</span> name = parent.$options.componentName;</span><br><span class="line">      <span class="keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) &#123;</span><br><span class="line">        parent = parent.$parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">          name = parent.$options.componentName;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        parent.$emit.apply(parent, [eventName].concat(params));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义 broadcast 方法</span></span><br><span class="line">    broadcast(componentName, eventName, params) &#123;</span><br><span class="line">      broadcast.call(<span class="keyword">this</span>, componentName, eventName, params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面所示的代码，一般都作为一个 <code>mixins</code> 去混入使用, <code>broadcast</code> 是向特定的父组件触发事件，<code>dispatch</code> 是向特定的子组件触发事件，本质上这种方式还是 <code>on</code> 和 <code>emit</code> 的封装，在一些基础组件中都很实用。</p>
<p>因为在 <code>Vue 2.0</code> 这个 API 已经废弃，那我们在这里也就提一下，如果想详细了解 <code>Vue 1.0</code> 和其他基于 Vue 的 UI 框架关于这个 API 的实现，可以点击查看<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.yuque.com%2Flittlelane%2Fvue%2Fusdfkw" target="_blank" rel="noopener">这篇文章</a>！</p>
<h3 id="Vuex-状态管理"><a href="#Vuex-状态管理" class="headerlink" title="Vuex 状态管理"></a>Vuex 状态管理</h3><p>Vuex 是状态管理工具，实现了项目状态的集中式管理。工具的实现借鉴了 <a href="https://link.juejin.im?target=https%3A%2F%2Ffacebook.github.io%2Fflux%2Fdocs%2Foverview.html" target="_blank" rel="noopener">Flux</a>、<a href="https://link.juejin.im?target=http%3A%2F%2Fredux.js.org%2F" target="_blank" rel="noopener">Redux</a>、和 <a href="https://link.juejin.im?target=https%3A%2F%2Fguide.elm-lang.org%2Farchitecture%2F" target="_blank" rel="noopener">The Elm Architecture</a> 的模式和概念。当然与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。详细的关于 Vuex 的介绍，你既可以去查看<a href="https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" target="_blank" rel="noopener">官网文档</a>，也可以查看本专栏关于 Vuex 一系列的介绍。</p>
<h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><p>通过this.$refs.XXX 拿到组件上面的所有方法属性</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写到这里，Vue 中关于组件通信的所有方式就介绍完了，是不是感觉还是颇丰的呢？其实还有另外的两种方式可以实现组件的通信，一是通过 <a href="https://link.juejin.im?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2F" target="_blank" rel="noopener">Vue Router</a> 通信，二是通过浏览器本地存储实现组件通信。关于这两种方式，这里我就不讲了，当然我会在本专栏中单独开篇讲解的，希望大家有兴趣就去看看！</p>
<p>准确来说本文详细讲解了实现 Vue 通信的六种方式，每种方式都有其特点。在实际的项目，大家可以酌情的进行使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/async-await优雅的错误处理方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/async-await优雅的错误处理方法/" itemprop="url">async/await优雅的错误处理方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T22:58:50+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="async-await错误处理"><a href="#async-await错误处理" class="headerlink" title="async/await错误处理"></a>async/await错误处理</h3><p>一般情况下 async/await 在错误处理方面，主要使用 <code>try/catch</code>，像这样<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch data is me'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> fetchData()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'data is -&gt;'</span>, data)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>这么看，感觉倒是没什么问题，如果是这样呢？有多个异步操作，需要对每个异步返回的 error 错误状态进行不同的处理，以下是示例代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchDataA = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch data is A'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchDataB = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch data is B'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchDataC = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">'fetch data is C'</span>)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dataA = <span class="keyword">await</span> fetchDataA()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataA is -&gt;'</span>, dataA)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dataB = <span class="keyword">await</span> fetchDataB()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataB is -&gt;'</span>, dataB)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dataC = <span class="keyword">await</span> fetchDataC()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataC is -&gt;'</span>, dataC)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>这样写代码里充斥着 <code>try/catch</code>，有代码洁癖的你能忍受的了吗？这时可能会想到只用一个 <code>try/catch</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 这里 fetch 函数省略</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dataA = <span class="keyword">await</span> fetchDataA()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataA is -&gt;'</span>, dataA)</span><br><span class="line">        <span class="keyword">const</span> dataB = <span class="keyword">await</span> fetchDataB()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataB is -&gt;'</span>, dataB)</span><br><span class="line">        <span class="keyword">const</span> dataC = <span class="keyword">await</span> fetchDataC()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'dataC is -&gt;'</span>, dataC)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'err is -&gt;'</span>, err)</span><br><span class="line">        <span class="comment">// 难道要定义 err 类型，然后判断吗？？/**</span></span><br><span class="line">         * <span class="keyword">if</span> (err.type === <span class="string">'dataA'</span>) &#123;</span><br><span class="line">         *  <span class="built_in">console</span>.log(<span class="string">'dataA err is'</span>, err)</span><br><span class="line">         * &#125;</span><br><span class="line">         * ......</span><br><span class="line">         * *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)()</span></span><br></pre></td></tr></table></figure></p>
<p>如果是这样写只会增加编码的复杂度，而且要多写代码，这个时候就应该想想怎么优雅的解决，<code>async/await</code> 本质就是 <code>promise</code> 的语法糖，既然是 <code>promise</code> 那么就可以使用 <code>then</code> 函数了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">'fetch data is me'</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> data ).catch(<span class="function"><span class="params">err</span> =&gt;</span> err)</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>在上面写法中，如果 fetchData 返回 resolve 正确结果时，data 是我们要的结果，如果是 reject 了，发生错误了，那么 data 是错误结果，这显然是行不通的，再对其完善。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">'fetch data is me'</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [err, data] = <span class="keyword">await</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data] ).catch(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">null</span>])</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>, err)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data'</span>, data)</span><br><span class="line">    <span class="comment">// err null// data fetch data is me</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>这样是不是好很多了呢，但是问题又来了，不能每个 await 都写这么长，写着也不方便也不优雅，再优化一下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(<span class="string">'fetch data is me'</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽离成公共方法</span></span><br><span class="line">    <span class="keyword">const</span> awaitWrap = <span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> promise</span><br><span class="line">            .then(<span class="function"><span class="params">data</span> =&gt;</span> [<span class="literal">null</span>, data])</span><br><span class="line">            .catch(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">null</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [err, data] = <span class="keyword">await</span> awaitWrap(fetchData())</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'err'</span>, err)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'data'</span>, data)</span><br><span class="line">    <span class="comment">// err null// data fetch data is me</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>将对 <code>await</code> 处理的方法抽离成公共的方法，在使用 <code>await</code> 调用 <code>awaitWrap</code> 这样的方法是不是更优雅了呢。如果使用 typescript 实现大概是这个样子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">functionawaitWrap&lt;T, U = any&gt;(promise: <span class="built_in">Promise</span>&lt;T&gt;): <span class="built_in">Promise</span>&lt;[U | <span class="literal">null</span>, T | <span class="literal">null</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">        .then&lt;[<span class="literal">null</span>, T]&gt;<span class="function">(<span class="params">(data: T</span>) =&gt;</span> [<span class="literal">null</span>, data])</span><br><span class="line">        .catch&lt;[U, <span class="literal">null</span>]&gt;(<span class="function"><span class="params">err</span> =&gt;</span> [err, <span class="literal">null</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h3><p>ES2018另一振奋人心的特效是finally()方法。 之前有几个 JavaScript 库实现了类似的方法，并且它被证实是有用的。这促使 Ecma技术委员会正式将finally()添加到规范中。 使用该方法，开发者可无需理会 promise 命数如何，直接执行这个代码块中的代码。 我们来看一个简单的例子：<br><img src="/2019/01/25/async-await优雅的错误处理方法/1.webp" alt=""><br>finally() 方法可在操作完成后进行一些扫尾（clean up）工作，无论操作是否成功。 在此代码中，finally() 方法在数据获取处理后直接隐藏了加载 spinner。 无论 promise 完成与否，函数中的注册代码都会执行，开发者不必在 then() 和 catch() 方法中重复编写逻辑。使用promise.then(func, func)也可实现与promise.then(func, func) 同样的效果，但你必须在 fulfillment 句柄及 rejection 句柄中重复相同的代码，或者引入一个变量：<br><img src="/2019/01/25/async-await优雅的错误处理方法/2.webp" alt=""><br>与 then() 和 catch() 相同，finally() 方法总是返回一个 promise，因此你可以链接更多的方法。 一般来说，我们会将 finally() 作为最后一环。但某些情况，例如在创建 HTTP 请求时，在 finally() 之后链接另一个catch(),以处理请求中可能发生的错误是不错的实践。<br><img src="/2019/01/25/async-await优雅的错误处理方法/3.webp" alt=""></p>
<h3 id="ES7-Async-await"><a href="#ES7-Async-await" class="headerlink" title="ES7 Async / await"></a>ES7 Async / await</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncTask</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> UserModel.findById(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(!user) <span class="keyword">return</span> cb(<span class="string">'No user found'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> savedTask = <span class="keyword">await</span> TaskModel(&#123;<span class="attr">userId</span>: user.id, <span class="attr">name</span>: <span class="string">'Demo Task'</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(user.notificationsEnabled) &#123;</span><br><span class="line">         <span class="keyword">await</span> NotificationService.sendNotification(user.id, <span class="string">'Task Created'</span>);  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(savedTask.assignedUser.id !== user.id) &#123;</span><br><span class="line">        <span class="keyword">await</span> NotificationService.sendNotification(savedTask.assignedUser.id, <span class="string">'Task was created for you'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb(<span class="literal">null</span>, savedTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码看起来更清晰，<strong>但是，错误处理呢？</strong></p>
<p>在进行异步调用时，在执行promise（DB连接错误，db模型验证错误等等）时可能会发生某些事情。</p>
<p>由于异步函数正在等待Promise，因此当promise遇到错误时，它会抛出一个异常，该异常将在promise的catch方法中捕获。</p>
<p>在async / await函数中，通常使用<strong>try / catch</strong>块来捕获此类错误。</p>
<p>我不是来自一个打字的语言背景，所以try / catch为我添加了额外的代码，在我看来，看起来并不干净。我确定这是个人偏好的问题，但这是我的看法。</p>
<p>所以前面的代码看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncTask</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> user = <span class="keyword">await</span> UserModel.findById(<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span>(!user) <span class="keyword">return</span> cb(<span class="string">'No user found'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> cb(<span class="string">'Unexpected error occurred'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> savedTask = <span class="keyword">await</span> TaskModel(&#123;<span class="attr">userId</span>: user.id, <span class="attr">name</span>: <span class="string">'Demo Task'</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> cb(<span class="string">'Error occurred while saving task'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user.notificationsEnabled) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> NotificationService.sendNotification(user.id, <span class="string">'Task Created'</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="keyword">return</span> cb(<span class="string">'Error while sending notification'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(savedTask.assignedUser.id !== user.id) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">await</span> NotificationService.sendNotification(savedTask.assignedUser.id, <span class="string">'Task was created for you'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="keyword">return</span> cb(<span class="string">'Error while sending notification'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb(<span class="literal">null</span>, savedTask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一种不同的做事方式"><a href="#一种不同的做事方式" class="headerlink" title="一种不同的做事方式"></a>一种不同的做事方式</h3><p>最近我一直在使用<strong>go-lang</strong>进行编码，并且非常喜欢他们的解决方案，看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data, <span class="attr">err</span> := db.Query(<span class="string">"SELECT ..."</span>)</span><br><span class="line"><span class="keyword">if</span> err != nil &#123; <span class="keyword">return</span> err &#125;</span><br></pre></td></tr></table></figure>
<p>我认为它比使用try-catch块更清晰，并且代码更少，这使得它具有可读性和可维护性。</p>
<p>但是<strong>等待</strong>的问题是，如果没有为它提供try-catch块，它将默默地退出你的函数。除非提供catch子句，否则你无法控制它。</p>
<p>当我和我的好朋友Tomer Barnea坐下来并试图寻找更清洁的解决方案时，我们完成了下一个方法：</p>
<p>还记得<strong>await</strong>正在等待解决的承诺吗？</p>
<p>有了这些知识，我们可以使用小实用功能来帮助我们捕获这些错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="literal">null</span>, data];</span><br><span class="line">   &#125;)</span><br><span class="line">   .catch(<span class="function"><span class="params">err</span> =&gt;</span> [err]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实用程序函数接收一个promise，然后使用返回数据作为第二项解析对数组的成功响应。并且从第一个接收到的错误。</p>
<p>然后我们可以使异步代码看起来像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> to <span class="keyword">from</span> <span class="string">'./to.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">let</span> err, user, savedTask;</span><br><span class="line"></span><br><span class="line">     [err, user] = <span class="keyword">await</span> to(UserModel.findById(<span class="number">1</span>));</span><br><span class="line">     <span class="keyword">if</span>(!user) <span class="keyword">throw</span> <span class="keyword">new</span> CustomerError(<span class="string">'No user found'</span>);</span><br><span class="line"></span><br><span class="line">     [err, savedTask] = <span class="keyword">await</span> to(TaskModel(&#123;<span class="attr">userId</span>: user.id, <span class="attr">name</span>: <span class="string">'Demo Task'</span>&#125;));</span><br><span class="line">     <span class="keyword">if</span>(err) <span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">'Error occurred while saving task'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user.notificationsEnabled) &#123;</span><br><span class="line">       <span class="keyword">const</span> [err] = <span class="keyword">await</span> to(NotificationService.sendNotification(user.id, <span class="string">'Task Created'</span>));  </span><br><span class="line">       <span class="keyword">if</span> (err) <span class="built_in">console</span>.error(<span class="string">'Just log the error and continue flow'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例只是解决方案的一个简单用例，您可以在to.js方法中附加拦截器，该方法将接收原始错误对象，记录它或在传回之前执行您需要做的任何操作。</p>
<blockquote>
<p>这篇文章只是查看异步/等待错误处理的另一种方式。它不应该被用作你编写的每个async / await函数的goto，并且在很多情况下在顶部有一个catch会做得很好。有时我们不希望公开模型实现的错误对象，而是希望提供一个自定义错误对象来屏蔽底层的mongoose错误实现。</p>
</blockquote>
<h3 id="Github-Repo"><a href="#Github-Repo" class="headerlink" title=" Github Repo "></a><a href="https://github.com/scopsy/await-to-js" target="_blank" rel="noopener"><strong> Github Repo </strong></a></h3><p>我们为这个库创建了一个简单的NPM包，你可以使用它来安装它：</p>
<pre><code class="js">npm i <span class="keyword">await</span>-to-js
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/更优雅的方式处理数组/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/16/更优雅的方式处理数组/" itemprop="url">更优雅的方式处理数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T23:23:17+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="使用Set处理数组去重和元素剔除问题"><a href="#使用Set处理数组去重和元素剔除问题" class="headerlink" title="使用Set处理数组去重和元素剔除问题"></a>使用<code>Set</code>处理数组去重和元素剔除问题</h3><p><code>Set</code>是es6新增的一种<strong>数据结构</strong>，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。它提供了4个语义化的API：</p>
<ol>
<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ol>
<blockquote>
<p>参考自@阮一峰 老师的<a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fset-map" target="_blank" rel="noopener">《ECMAScript 6 入门》</a></p>
</blockquote>
<p>那么我们可以用<code>Set</code>来干嘛呢？</p>
<p>第一个用法，数组去重。对于一个一维数组，我们可以先把它转化成<code>Set</code>，再配合<code>...</code>解构运算符重新转化为数组，达到去重的目的。请看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 1, 2, 2, 3, 4, 5, 5]</span><br><span class="line"></span><br><span class="line">const newArr = [...new Set(arr)]</span><br><span class="line"></span><br><span class="line">console.log(newArr)</span><br><span class="line"></span><br><span class="line">// [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，这个方法不能对元素为“对象”的数组奏效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [&#123; name: &apos;Alice&apos;, age: 12 &#125;, &#123; name: &apos;Alice&apos;, age: 12 &#125;, &#123; name: &apos;Bob&apos;, age: 13 &#125;]</span><br><span class="line"></span><br><span class="line">const newArr = [...new Set(arr)]</span><br><span class="line"></span><br><span class="line">console.log(newArr)</span><br><span class="line"></span><br><span class="line">// [&#123; name: &apos;Alice&apos;, age: 12 &#125;, &#123; name: &apos;Alice&apos;, age: 12 &#125;, &#123; name: &apos;Bob&apos;, age: 13 &#125;]</span><br></pre></td></tr></table></figure></p>
<p>这是因为<code>Set</code>判断元素是否重复的办法类似于<code>===</code>运算符，两个对象总是不相等的。</p>
<p>除了去重，<code>Set</code>提供的<code>delete()</code>方法也是非常实用。在以往的做法中，如果要删除数组中指定的元素，我们需要先获取该元素所在下标，然后通过<code>splice()</code>方法去删除对应下标的元素，在理解上容易引起混乱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 我想删除数组当中值为2的元素const arr = [1, 2, 3]</span><br><span class="line">const index = arr.indexOf(2)</span><br><span class="line">if (index !== -1) &#123;</span><br><span class="line">    arr.splice(index, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr)</span><br><span class="line"></span><br><span class="line">// [1, 3]</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Set</code>就清晰多了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3]</span><br><span class="line">const set = newSet(arr)</span><br><span class="line">set.delete(2)</span><br><span class="line">arr = [...set]</span><br><span class="line"></span><br><span class="line">console.log(arr)</span><br><span class="line"></span><br><span class="line">// [1, 3]</span><br></pre></td></tr></table></figure></p>
<h3 id="使用map-方法和对象解构语法提取字段"><a href="#使用map-方法和对象解构语法提取字段" class="headerlink" title="使用map()方法和对象解构语法提取字段"></a>使用<code>map()</code>方法和对象解构语法提取字段</h3><p>请求后台接口返回的数据中，很可能会遇到下面这种数据格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">studentInfo = [</span><br><span class="line">  &#123; name: &apos;Alice&apos;, age: 18, no: 2 &#125;,</span><br><span class="line">  &#123; name: &apos;Bob&apos;, age: 16, no: 5 &#125;,</span><br><span class="line">  &#123; name: &apos;Candy&apos;, age: 17, no: 3 &#125;,</span><br><span class="line">  &#123; name: &apos;Den&apos;, age: 18, no: 4 &#125;,</span><br><span class="line">  &#123; name: &apos;Eve&apos;, age: 16, no: 1 &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>当我们要获取姓名列表、年龄列表和编号列表的时候，我们可以通过<code>map()</code>再配合对象的解构语法方便快捷地进行处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const nameList = studentInfo.map((&#123; name &#125;) =&gt; name)</span><br><span class="line">const ageList = studentInfo.map((&#123; age &#125;) =&gt; age)</span><br><span class="line">const noList = studentInfo.map((&#123; no &#125;) =&gt; no)</span><br><span class="line"></span><br><span class="line">// nameList: [ &apos;Alice&apos;, &apos;Bob&apos;, &apos;Candy&apos;, &apos;Den&apos;, &apos;Eve&apos; ]// ageList: [ 18, 16, 17, 18, 16 ]// noList: [ 2, 5, 3, 4, 1 ]</span><br></pre></td></tr></table></figure></p>
<h3 id="使用filter-方法和对象解构语法过滤数组"><a href="#使用filter-方法和对象解构语法过滤数组" class="headerlink" title="使用filter()方法和对象解构语法过滤数组"></a>使用<code>filter()</code>方法和对象解构语法过滤数组</h3><p>接上上面的例子，如果我想获取一个“年龄小于等于17岁”的新列表，应该怎么做呢？类似<code>map()</code>方法，我们可以用<code>filter()</code>方法进行过滤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const newStudentInfo = studentInfo.filter((&#123; age &#125;) =&gt; &#123;</span><br><span class="line">  return age &lt;= 17</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">newStudentInfo: [</span><br><span class="line">  &#123; name: &apos;Bob&apos;, age: 16, no: 5 &#125;,</span><br><span class="line">  &#123; name: &apos;Candy&apos;, age: 17, no: 3 &#125;,</span><br><span class="line">  &#123; name: &apos;Eve&apos;, age: 16, no: 1 &#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<h3 id="借助includes-方法求两个数组的差集"><a href="#借助includes-方法求两个数组的差集" class="headerlink" title="借助includes()方法求两个数组的差集"></a>借助<code>includes()</code>方法求两个数组的差集</h3><p>假设我们有以下两个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, &#123;s:3&#125;, &#123;s:4&#125;, &#123;s:5&#125;]</span><br><span class="line">var b = [&#123;s:2&#125;, &#123;s:3&#125;, &#123;s:4&#125;, &apos;a&apos;]</span><br></pre></td></tr></table></figure></p>
<p>我们应该如何找到它们的差集呢？传统的方法可能需要把它们以Object形式hash化，但其实我们可以通过<code>.includes()</code>方法更加优雅方便地找出差集，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, &#123;s:3&#125;, &#123;s:4&#125;, &#123;s:5&#125;].map(item =&gt;JSON.stringify(item))</span><br><span class="line">var b = [&#123;s:2&#125;, &#123;s:3&#125;, &#123;s:4&#125;, &apos;a&apos;].map(item =&gt;JSON.stringify(item))</span><br><span class="line"></span><br><span class="line">var diff = a.concat(b)</span><br><span class="line">            .filter(v =&gt; !a.includes(v) || !b.includes(v))</span><br><span class="line">            .map(item =&gt;JSON.parse(item))</span><br><span class="line">            </span><br><span class="line">// diff: [1, 2, &#123;s:5&#125;, &#123;s:2&#125;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></p>
<p>至于为什么要<code>JSON.stringify()</code>，是因为要对比两个“对象元素”是否相等，是无法直接以“对象”形式比较的（永远返回不相等）。</p>
<hr>
<h3 id="Array-includes-与条件判断"><a href="#Array-includes-与条件判断" class="headerlink" title="Array.includes 与条件判断"></a>Array.includes 与条件判断</h3><p>一般我们判断或用 ||<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// condition</span><br><span class="line">function test(fruit) &#123;</span><br><span class="line">  if (fruit == &quot;apple&quot; || fruit == &quot;strawberry&quot;) &#123;</span><br><span class="line">    console.log(&quot;red&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们有更多水果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(fruit) &#123;</span><br><span class="line">  const redFruits = [&quot;apple&quot;, &quot;strawberry&quot;, &quot;cherry&quot;, &quot;cranberries&quot;];</span><br><span class="line"></span><br><span class="line">  if (redFruits.includes(fruit)) &#123;</span><br><span class="line">    console.log(&quot;red&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Set-与去重"><a href="#Set-与去重" class="headerlink" title="Set 与去重"></a>Set 与去重</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<p>数组去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [3, 5, 2, 2, 5, 5];</span><br><span class="line">const unique = [...new Set(arr)];</span><br><span class="line">// [3,5,2]</span><br></pre></td></tr></table></figure></p>
<p>Array.from 方法可以将 Set 结构转为数组。我们可以专门编写使用一个去重的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function unique(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique([1, 1, 2, 3]); // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p><strong>字符去重</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = [...new Set(&quot;ababbc&quot;)].join(&quot;&quot;);</span><br><span class="line">console.log(str);</span><br><span class="line">// &apos;abc&apos;</span><br></pre></td></tr></table></figure></p>
<p>另外 Set 是如此强大，因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = new Set([1, 2, 3]);</span><br><span class="line">let b = new Set([4, 3, 2]);</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let union = new Set([...a, ...b]);</span><br><span class="line">// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)));</span><br><span class="line">// set &#123;2, 3&#125;</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Map-与字典类型数据"><a href="#Map-与字典类型数据" class="headerlink" title="Map 与字典类型数据"></a>Map 与字典类型数据</h3><p>一般而已，JavaScript 实现字典数据是基于 Object 对象。但是 JavaScript 的对象的键只能是字符串。对于编程来说有很多不便。 ES6 提供了 Map 数据结构。它类似于 Object 对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值，字符串、数值、布尔值、数组、对象等等都可以当作键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const resultMap = new Map()</span><br><span class="line">  .set(-1, &#123;text:&apos;小于&apos;,color:&apos;yellow&apos;)</span><br><span class="line">  .set(0, &#123;text:&apos;等于&apos;,color:&apos;black&apos;)</span><br><span class="line">  .set(1, &#123;text:&apos;大于&apos;,color:&apos;green&apos;)</span><br><span class="line">  .set(null,&#123;text:&apos;没有物品&apos;,color:&apos;red&apos;&#125;)</span><br><span class="line"></span><br><span class="line">let state = resultMap.get(null)</span><br><span class="line">// &#123;text:&apos;没有物品&apos;,color:&apos;red&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Map 的遍历顺序就是插入顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([[&quot;F&quot;, &quot;no&quot;], [&quot;T&quot;, &quot;yes&quot;]]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot;</span><br><span class="line">// &quot;T&quot;</span><br><span class="line"></span><br><span class="line">for (let value of map.value()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;no&quot;</span><br><span class="line">// &quot;yes&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数式的方式处理数据"><a href="#函数式的方式处理数据" class="headerlink" title="函数式的方式处理数据"></a>函数式的方式处理数据</h3><p>按照我的理解，函数式编程主张函数必须接受至少一个参数并返回一个值。所以所有的关于数据的操作，都可以用函数式的方式处理。</p>
<p>假设我们有这样的需求，需要先把数组 foo 中的对象结构更改，然后从中挑选出一些符合条件的对象，并且把这些对象放进新数组 result 里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">let foo = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;Stark&quot;,</span><br><span class="line">    age: 21</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;Jarvis&quot;,</span><br><span class="line">    age: 20</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;Pepper&quot;,</span><br><span class="line">    age: 16</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">//我们希望得到结构稍微不同，age大于16的对象：</span><br><span class="line">let result = [</span><br><span class="line">  &#123;</span><br><span class="line">    person: &#123;</span><br><span class="line">      name: &quot;Stark&quot;,</span><br><span class="line">      age: 21</span><br><span class="line">    &#125;,</span><br><span class="line">    friends: []</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    person: &#123;</span><br><span class="line">      name: &quot;Jarvis&quot;,</span><br><span class="line">      age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    friends: []</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>从直觉上我们很容易写出这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let result = [];</span><br><span class="line"></span><br><span class="line">//有时甚至是普通的for循环</span><br><span class="line">foo.forEach(function(person)&#123;</span><br><span class="line">    if(person.age &gt; 16)&#123;</span><br><span class="line">        let newItem = &#123;</span><br><span class="line">            person: person,</span><br><span class="line">            friends: [];</span><br><span class="line">        &#125;;</span><br><span class="line">        result.push(newItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>使用函数式的写法，可以优雅得多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let result = foo</span><br><span class="line">  .filter(person =&gt; person.age &gt; 16)</span><br><span class="line">  .map(person =&gt; (&#123;</span><br><span class="line">    person: person,</span><br><span class="line">    friends: []</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure></p>
<p>数组求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let foo = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">//不优雅</span><br><span class="line">function sum(arr) &#123;</span><br><span class="line">  let x = 0;</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    x += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">sum(foo); // =&gt; 15</span><br><span class="line"></span><br><span class="line">//优雅</span><br><span class="line">foo.reduce((a, b) =&gt; a + b); // =&gt; 15</span><br></pre></td></tr></table></figure></p>
<h3 id="compose-与函数组合"><a href="#compose-与函数组合" class="headerlink" title="compose 与函数组合"></a>compose 与函数组合</h3><p>以下代码称为组合 compose<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const compose = function(f, g) &#123;</span><br><span class="line">  return function(x) &#123;</span><br><span class="line">    return f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于函数式编程大行其道，所以现在将会在 JavaScript 代码看到大量的箭头()=&gt;()=&gt;()=&gt;的代码。</p>
<p>ES6 版本 compose<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const compose = (f, g) =&gt; x =&gt; f(g(x));</span><br></pre></td></tr></table></figure></p>
<p>在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据 流。这样做的可读性远远高于嵌套一大堆的函数调用.</p>
<p>我们选择一些函数，让它们结合，生成一个崭新的函数。</p>
<p>reverse 反转列表， head 取列表中的第一个元素；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const head = arr =&gt; arr[0];</span><br><span class="line">const reverse = arr =&gt; [].concat(arr).reverse();</span><br><span class="line"></span><br><span class="line">const last = compose(head, reverse);</span><br><span class="line">last([&quot;jumpkick&quot;, &quot;roundhouse&quot;, &quot;uppercut&quot;]);</span><br><span class="line">// &quot;uppercut&quot;</span><br></pre></td></tr></table></figure></p>
<p>但是我们这个这个compose不够完善，只能处理两个函数参数。redux源码有个很完备的compose函数，我们借鉴一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function compose(...funcs)&#123;</span><br><span class="line">  if (funcs.length === 0)&#123;</span><br><span class="line">      return arg =&gt; arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (funcs.length === 1 )&#123;</span><br><span class="line">      return funcs[0]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return funcs.reduce((a,b)=&gt;(...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了这个函数，我们可以随意组合无数个函数。现在我们增加需求，组合出一个lastAndUpper函数，内容是先reverse 反转列表， head 取列表中的第一个元素, 最后toUpperCase大写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const head = arr =&gt; arr[0];</span><br><span class="line">const reverse = arr =&gt; [].concat(arr).reverse();</span><br><span class="line">const toUpperCase = str =&gt; str.toUpperCase();</span><br><span class="line"></span><br><span class="line">const last = compose(head, reverse);</span><br><span class="line"></span><br><span class="line">const lastAndUpper = compose(toUpperCase, head, reverse,);</span><br><span class="line"></span><br><span class="line">console.log(last([&quot;jumpkick&quot;, &quot;roundhouse&quot;, &quot;uppercut&quot;]));</span><br><span class="line">// &quot;uppercut&quot;</span><br><span class="line">console.log(lastAndUpper([&quot;jumpkick&quot;, &quot;roundhouse&quot;, &quot;uppercut&quot;]))</span><br><span class="line">// &quot;UPPERCUT&quot;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>过去的一年， <code>JavaScript</code> 在持续变化着，其使用范围也越来越广。接下来，我将针对 <code>JavaScript</code> 的使用，列出 9 条 建议，以帮助你写出更加整洁高效的代码，成为更好的开发者。</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p><code>JavaScript</code> 极速发展的今天，回调地狱所产生的问题已不复存在。实际开发过程中我们应当尽量避免使用回调函数，除非为了遵守代码库规则或是维护性能。而解决回调地狱的一个常用方法为 <code>Promise</code>，但在代码量较多时使用会适得其反。于是提出了 <code>async / await</code>，使代码结构更加清晰明了，便于阅读和维护。一般而言，可以 <code>await</code> 任何 <code>Promise</code> 以防止正使用的库的返回值为 <code>Promise</code> ，也就是说 <code>async/await</code> 是 <code>Promise</code> 的语法糖，而且使用方法也十分简单：在函数前加 <code>async</code>。下面是一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function getData() &#123;</span><br><span class="line">    const result = await axios.get(&apos;https://dube.io/service/ping&apos;)</span><br><span class="line">    const data = result.data</span><br><span class="line">    console.log(&apos;data&apos;, data)</span><br><span class="line">    return data</span><br><span class="line">&#125;</span><br><span class="line">getData()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>await 只能使用在 async 函数中，不能用于全局作用域。</p>
</blockquote>
<blockquote>
<p><code>async/await</code> 是 ES2017 中引入的，使用时请进行转换。</p>
</blockquote>
<h3 id="异步控制流"><a href="#异步控制流" class="headerlink" title="异步控制流"></a>异步控制流</h3><p>当我们进行异步调用并获得返回值时，通常期望直接获取多个数据集，并且分别操作每个数据集。因此有了以下方式：</p>
<h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><p>假设页面上要展示 Pokemon 数据，可以通过 <code>axios</code> 获取它们的详细信息，我们所期望的是在得到返回值时立即更新页面中的所有数据，而不是等所有调用完成后才进行更新。</p>
<p>我们可以使用 <code>for...of</code> 解决上述问题。 首先循环遍历数组，并在每个循环内执行异步代码，当所有调用都成功时跳出循环。需要注意的是，这种方法虽然会对性能产生一些影响，但也不乏是一个很好的方法。</p>
<p>以下是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import axios from&apos;axios&apos;</span><br><span class="line">let myData = [&#123; id: 0 &#125;, &#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125;]</span><br><span class="line"></span><br><span class="line">async function fetchData(dataSet) &#123;</span><br><span class="line">    for (entry of dataSet) &#123;</span><br><span class="line">        const result = await axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`)</span><br><span class="line">        const newData = result.data</span><br><span class="line">        updateData(newData)</span><br><span class="line">        console.log(myData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function updateData(newData) &#123;</span><br><span class="line">    myData = myData.map(el =&gt; &#123;</span><br><span class="line">        if (el.id === newData.id) return newData</span><br><span class="line">        return el</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fetchData(myData)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以将这些例子复制粘贴到编辑器中调试运行。</p>
</blockquote>
<blockquote>
<p>译者注：除了循环本身带来的性能问题之外，在使用 <code>async/await</code> 处理异步请求时也会对性能造成影响：如果使用过多 <code>await</code> 语句，而且候这些语句并不需要依赖于之前的语句，则会产生 <code>async/await</code> 地狱，影响性能。</p>
</blockquote>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>如果想要并行获取所有的 Pokemon，我们可以使用 <code>Promise.all</code> 方法来 <code>await</code> 所有 <code>Promise</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import axios from&apos;axios&apos;</span><br><span class="line">let myData = [&#123; id: 0 &#125;, &#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125;]</span><br><span class="line">async function fetchData(dataSet) &#123;</span><br><span class="line">    const pokemonPromises = dataSet.map(entry =&gt; &#123;</span><br><span class="line">        return axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    const results = awaitPromise.all(pokemonPromises)</span><br><span class="line">    results.forEach(result =&gt; &#123;</span><br><span class="line">        updateData(result.data)</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(myData)</span><br><span class="line">&#125;</span><br><span class="line">function updateData(newData) &#123;</span><br><span class="line">    myData = myData.map(el =&gt; &#123;</span><br><span class="line">        if (el.id === newData.id) return newData</span><br><span class="line">        return el</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fetchData(myData)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>for...of</code> 和 <code>Promise.all</code> 都是 <code>ES6+</code> 引入的，使用时请进行转换。</p>
</blockquote>
<h3 id="解构赋值-amp-默认值"><a href="#解构赋值-amp-默认值" class="headerlink" title="解构赋值 &amp; 默认值"></a>解构赋值 &amp; 默认值</h3><p>回到上个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const result = axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`)</span><br><span class="line">const data = result.data</span><br></pre></td></tr></table></figure></p>
<p>现在有一种更简单的方法来实现它：通过解构赋值的方式从对象或数组中获取一个或多个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; data &#125; = await axios.get(...)</span><br></pre></td></tr></table></figure></p>
<p>也可对变量重命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; data: newData &#125; = await axios.get(...)</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是在解构赋值时指定默认值，这样做可以确保代码不会出现 <code>undefined</code>，也避免手动检查变量的麻烦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; id = 5 &#125; = &#123;&#125;</span><br><span class="line">console.log(id) // 5</span><br></pre></td></tr></table></figure></p>
<p>这些方法也可以用于函数参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function calculate(&#123; operands = [1, 2], type = &apos;addition&apos; &#125; = &#123;&#125;) &#123;</span><br><span class="line">    return operands.reduce((acc, val) =&gt; &#123;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case&apos;addition&apos;:</span><br><span class="line">                return acc + val</span><br><span class="line">            case&apos;subtraction&apos;:</span><br><span class="line">                return acc - val</span><br><span class="line">            case&apos;multiplication&apos;:</span><br><span class="line">                return acc * val</span><br><span class="line">            case&apos;division&apos;:</span><br><span class="line">                return acc / val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [&apos;addition&apos;, &apos;subtraction&apos;].includes(type) ? 0 : 1)</span><br><span class="line">&#125;</span><br><span class="line">console.log(calculate()) // 3 </span><br><span class="line">console.log(calculate(&#123; type: &apos;division&apos; &#125;)) // 0.5 </span><br><span class="line">console.log(calculate(&#123; operands: [2, 3, 4], type: &apos;multiplication&apos; &#125;)) // 24</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>ES6</code> 引入了解构赋值和默认值，使用时请进行转换。</p>
</blockquote>
<h3 id="真值和虚值"><a href="#真值和虚值" class="headerlink" title="真值和虚值"></a>真值和虚值</h3><p>当我们使用默认值时，通常要对现有值进行一系列判断，这种方法使代码变得异常繁琐，而现在我们可以真值（<code>Truthy</code>）和虚值（<code>Falsy</code>）的方式来改进它，不仅可以节省代码量，还使人更加信服。</p>
<p>以下是之前的做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (myBool === true) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br><span class="line">// OR</span><br><span class="line">if (myString.length &gt; 0) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br><span class="line">// OR</span><br><span class="line">if (isNaN(myNumber)) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (myBool) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br><span class="line">// OR</span><br><span class="line">if (myString) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br><span class="line">// OR</span><br><span class="line">if (!myNumber) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下为 <code>Falsy</code> 和 <code>Truthy</code> 的概念：</p>
<p><strong>False</strong></p>
<ul>
<li>长度为0的字符串</li>
<li>数字 <code>0</code></li>
<li><code>false</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>NaN</code></li>
</ul>
<p><strong>True</strong></p>
<ul>
<li>空数组</li>
<li>空对象</li>
<li>其他</li>
</ul>
<p>使用真值和虚值时没有确切的比较方式，这类似于我们进行比较时常使用双等号 <code>==</code> 而不是三等号 <code>===</code>。一般而言，这两者的判定方式相同，但在某些情况下也会遇到一些错误，对我来说主要为数字 <code>0</code>。</p>
<h3 id="逻辑运算符和三元运算符"><a href="#逻辑运算符和三元运算符" class="headerlink" title="逻辑运算符和三元运算符"></a>逻辑运算符和三元运算符</h3><p>逻辑运算符和三元运算符主要用于精简代码，有助于保持代码整洁度，但当他们形成运算链时会显得杂乱。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符：和（<code>&amp;&amp;</code>）、或（<code>||</code>），一般用于比较两个表达式，返回值为： <code>true</code>、<code>false</code> 或着它的匹配值。如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(true &amp;&amp; true) // true</span><br><span class="line">console.log(false &amp;&amp; true) // false</span><br><span class="line">console.log(true &amp;&amp; false) // false</span><br><span class="line">console.log(false &amp;&amp; false) // false</span><br><span class="line">console.log(true || true) // true</span><br><span class="line">console.log(true || false) // true</span><br><span class="line">console.log(false || true) // true</span><br><span class="line">console.log(false || false) // false</span><br></pre></td></tr></table></figure></p>
<p>我们可以将逻辑运算符与真值和虚值的相关知识结合起来。</p>
<p>如果有表达式 <code>A</code> 和 <code>B</code>，针对两种逻辑运算符，有以下规则：</p>
<ul>
<li><code>A &amp;&amp; B</code> ： 当 <code>A</code> 为 <code>false</code> 时则直接返回 <code>A</code> 的值 ；否则返回 <code>B</code> 的值。</li>
<li><code>A || B</code> ： 当 <code>A</code> 为 <code>true</code> 时则直接返回 <code>A</code> 的值 ；否则返回 <code>B</code> 的值。</li>
</ul>
<blockquote>
<p>译者注：上述规则为逻辑运算中的短路现象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(0 &amp;&amp; &#123; a: 1 &#125;) // 0</span><br><span class="line">console.log(false &amp;&amp; &apos;a&apos;) // false</span><br><span class="line">console.log(&apos;2&apos; &amp;&amp; 5) // 5</span><br><span class="line">console.log([] || false) // []</span><br><span class="line">console.log(NaN || null) // null</span><br><span class="line">console.log(true || &apos;a&apos;) // true</span><br></pre></td></tr></table></figure>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>三元运算符与逻辑运算符非常相似，但有由三个部分组成：</p>
<ol>
<li>条件表达式：其结果为真值或是虚值</li>
<li>返回值 1：条件表达式为真值时，返回该值</li>
<li>返回值 2：条件表达式为虚值时，返回该值</li>
</ol>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const lang = &apos;German&apos;</span><br><span class="line">console.log(lang === &apos;German&apos; ? &apos;Hallo&apos; : &apos;Hello&apos;) // Hallo</span><br><span class="line">console.log(lang ? &apos;Ja&apos; : &apos;Yes&apos;) // Ja</span><br><span class="line">console.log(lang === &apos;French&apos; ? &apos;Bon soir&apos; : &apos;Good evening&apos;) // Good eveing</span><br></pre></td></tr></table></figure></p>
<h3 id="自判断链接"><a href="#自判断链接" class="headerlink" title="自判断链接"></a>自判断链接</h3><p>当访问某个嵌套对象的属性时，由于不能确定目标对象或者属性性是否存在，而需要进行一系列判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let data</span><br><span class="line">if (myObj &amp;&amp; myObj.firstProp &amp;&amp; myObj.firstProp.secondProp &amp;&amp; myObj.firstProp.secondProp.actualData)</span><br><span class="line">    data = myObj.firstProp.secondProp.actualData</span><br></pre></td></tr></table></figure></p>
<p>显而易见，代码变得非常臃肿难看。而自判断链接（<code>optional chaining</code>）的提出，正好可以满足对嵌套属性的校验需求，并使代码更加清晰整洁。如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const data = myObj?.firstProp?.secondProp?.actualData</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function safeGet(o, path)&#123;</span><br><span class="line">   </span><br><span class="line">   return path.split(&apos;.&apos;).reduce((o=&#123;&#125;,b)=&#123;   //用到参数默认值</span><br><span class="line">     </span><br><span class="line">      return o[b]  </span><br><span class="line">   &#125;,o)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译者注：自判断链接： 检查一个对象上面是否存在某属性。</p>
<p>出现原因：调用某 <code>Object</code>属性链中的某个属性时，如果该属性不存在，会导致 <code>Cannot read property xxx of undefined</code> 错误。于是自判断链接 <code>?.</code> 出现。</p>
<p>使用方式：<code>obj?.a?.b?.c</code>。依次对代码中的属性进行判断，如果为 <code>null</code> 或者 <code>undefined</code> 时，结束调用，返回 <code>undefined</code> 。</p>
</blockquote>
<blockquote>
<p>目前，自判断链接还未纳入官方规范中，只处于第一阶段的实验特性。您需要在 <code>babelrc</code> 中添加 <code>@ babel / plugin-proposal-optional-chaining</code> 后方可使用它。</p>
</blockquote>
<h3 id="类属性-amp-绑定"><a href="#类属性-amp-绑定" class="headerlink" title="类属性 &amp; 绑定"></a>类属性 &amp; 绑定</h3><p><code>JavaScript</code> 中经常会用到绑定（<code>bind</code>）。<code>ES6</code> 规范中箭头函数的引入，使 <code>JavaScript</code> 开发人员有了一种将函数自动绑定到执行上下文中的常用方法，同时这种方法非常重要。</p>
<p>由于 <code>JavaScript</code> 中的类方法有特定的调用方式，因此当我们首次声明一个类时不能使用箭头函数，因此需要在其他位置进行函数绑定，比如在构造函数中（以 <code>React.js</code> 为例）。工作当中我总是先定义类方法再对其进行绑定，这种方法非常繁琐且容易出错。但如果使用 <code>class</code> 语法，我们可以通过箭头函数自动绑定它。以下是绑定 <code>_increaseCount</code> 的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">classCounterextendsReact.Component&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123; count: 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;&lt;buttononClick=&#123;this._increaseCount&#125;&gt;Increase Count&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    _increaseCount = () =&gt; &#123;</span><br><span class="line">        this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>目前，类属性还未纳入官方规范中，只处于第三阶段的实验特性。您需要在 <code>babelrc</code> 中添加 <code>@ babel / plugin-proposal-class-properties</code> 后方可使用。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/一道赋值面试题引发的思考2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/一道赋值面试题引发的思考2/" itemprop="url">一道赋值面试题引发的思考2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-13T14:14:11+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一道面试题"><a href="#一道面试题" class="headerlink" title="一道面试题"></a>一道面试题</h2><p>最近，有篇名为 <strong> <a href="https://segmentfault.com/a/1190000017224799" target="_blank" rel="noopener">《8张图帮你一步步看清 async/await 和 promise 的执行顺序》</a> </strong> 的文章引起了我的关注。</p>
<p>作者用一道2017年「今日头条」的前端面试题为引子，分步讲解了最终结果的执行原因。其中涉及到了不少概念，比如异步的执行顺序，宏任务，微任务等等，同时作者限定了执行范围，以浏览器的 event loop 机制为准。下面是原题的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">async functionasync1 () &#123;</span><br><span class="line">    console.log(&apos;async1 start&apos;);</span><br><span class="line">    await async2();</span><br><span class="line">    console.log(&apos;async1 end&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async functionasync2 () &#123;</span><br><span class="line">    console.log(&apos;async2&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(&apos;script start&apos;);</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">async1();</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve) &#123;</span><br><span class="line">    console.log(&apos;promise1&apos;);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&apos;promise2&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;script end&apos;);</span><br></pre></td></tr></table></figure></p>
<h5 id="chromeV71"><a href="#chromeV71" class="headerlink" title="chromeV71:"></a>chromeV71:</h5><p><img src="/2019/01/13/一道赋值面试题引发的思考2/1.png" alt=""></p>
<p>紧接着，作者先给出了答案。并希望读者先行自我测试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p>
<p>我在看这道题的时候，先按照自己的理解写出了结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p>
<h2 id="一些重要的概念"><a href="#一些重要的概念" class="headerlink" title="一些重要的概念"></a>一些重要的概念</h2><p>这里需要先简单地说一些 event loop 的概念。</p>
<ul>
<li>Javascript是单线程的，所有的同步任务都会在主线程中执行。</li>
<li>主线程之外，还有一个任务队列。每当一个异步任务有结果了，就往任务队列里塞一个事件。</li>
<li>当主线程中的任务，都执行完之后，系统会 “依次” 读取任务队列里的事件。与之相对应的异步任务进入主线程，开始执行。</li>
<li>异步任务之间，会存在差异，所以它们执行的优先级也会有区别。大致分为 微任务（micro task，如：Promise、MutaionObserver等）和宏任务（macro task，如：setTimeout、setInterval、I/O等）。同一次事件循环中，微任务永远在宏任务之前执行。</li>
<li>主线程会不断重复上面的步骤，直到执行完所有任务。</li>
</ul>
<p>另外，还有 async/await 的概念。</p>
<ul>
<li>async 函数，可以理解为是Generator 函数的语法糖。</li>
<li>它建立在promise之上，总是与await一起使用的。</li>
<li>await会返回一个Promise 对象，或者一个表达式的值。</li>
<li>其目的是为了让异步操作更优雅，能像同步一样地书写。</li>
</ul>
<h2 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h2><p>再说说我对这道题的理解。</p>
<ul>
<li>首先，从console的数量上看，会输出8行结果。</li>
<li>再瞟了一眼代码，看到了setTimeout，于是，默默地把它填入第8行。</li>
<li>在setTimeout附近，看到了 console.log( ‘script start’ ) 和 async1()，可以确认它们是同步任务，会先在主线程中执行。所以，妥妥地在第1行填入 script start，第2行填入async1方法中的第一行 async1 start。</li>
<li>接下来，遇到了await。从字面意思理解，让我们等等。需要等待async2()函数的返回，同时会阻塞后面的代码。所以，第3行填入 async2。</li>
<li>讲道理，await都执行完了，该轮到console.log( ‘async1 end’ )的输出了。但是，别忘了下面还有个Promise，有一点需要注意的是：当 new 一个 Promise的时候，其 resolve 方法中的代码会立即执行。如果不是 async1()的 await 横插一杠，promise1 可以排得更前面。所以，现在第4行填入 promise1。</li>
<li>再接下来，同步任务 console.log( ‘script end’ ) 执行。第5行填入 script end。</li>
<li>还有第6和第7行，未填。回顾一下上面提到 async/await 的概念，其目的是为了让异步能像同步一样地书写。那么，我认为 console.log( ‘async1 end’ ) 就是个同步任务。所以，第6行填入async1 end。</li>
<li>最后，顺理成章地在第7行填入 promise2。</li>
</ul>
<h2 id="与作者答案的不同"><a href="#与作者答案的不同" class="headerlink" title="与作者答案的不同"></a>与作者答案的不同</h2><p>回过头对比与作者的答案，发现第6和第7行的顺序有问题。</p>
<p>再耐心地往下看文章，反复地看了几遍 async1 end 和 promise2 谁先谁后，还是无法理解为何在chrome浏览器中，promise2 会先于 async1 end 输出。</p>
<p>然后，看到评论区，发现也有人提出了相同的疑惑。<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fu%2Frhinel" target="_blank" rel="noopener">@rhinel</a>提出，在他的72.0.3622.0（正式版本）dev（64 位）的chrome中，跑出来的结果是 async1 end 在 promise2 之前。</p>
<p><strong>随即我想到了一种可能，JS的规范可能会在未来有变化。于是，我用自己的react工程试了一下（工程中的babel-loader版本为7.1.5。.babelrc的presets设置了stage-3），结果与我的理解一致。当前的最新版本 chromeV71，在这里的执行顺序上，的确存在有问题。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h4 id="8张图帮你一步步看清-async-await-和-promise-的执行顺序"><a href="#8张图帮你一步步看清-async-await-和-promise-的执行顺序" class="headerlink" title="8张图帮你一步步看清 async/await 和 promise 的执行顺序"></a><a href="https://segmentfault.com/a/1190000017224799" target="_blank" rel="noopener">8张图帮你一步步看清 async/await 和 promise 的执行顺序</a></h4><h4 id="简单理解async、await语法实现原理"><a href="#简单理解async、await语法实现原理" class="headerlink" title="简单理解async、await语法实现原理"></a><a href="https://libin1991.github.io/2018/10/04/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3async%E3%80%81await%E8%AF%AD%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">简单理解async、await语法实现原理</a></h4><h4 id="细说-async-await-相较于-Promise-的优势"><a href="#细说-async-await-相较于-Promise-的优势" class="headerlink" title="细说 async/await 相较于 Promise 的优势"></a><a href="https://juejin.im/post/5c39523651882525a67c53d6" target="_blank" rel="noopener">细说 async/await 相较于 Promise 的优势</a></h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/06/一道赋值面试题引发的思考/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/06/一道赋值面试题引发的思考/" itemprop="url">一道赋值面试题引发的思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-06T17:53:16+08:00">
                2019-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="开头先来做一道面试题"><a href="#开头先来做一道面试题" class="headerlink" title="开头先来做一道面试题"></a>开头先来做一道面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;<span class="attr">n</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b=a;</span><br><span class="line">a.x=a=&#123;<span class="attr">n</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);</span><br><span class="line"><span class="built_in">console</span>.log(b.x);</span><br></pre></td></tr></table></figure>
<p>最后输出的是什么？ 先不说答案，我们来分析一下</p>
<p>(第二行) 我们把a赋值给b， 由于a是对象类型，这就意味着b和a指向同一个内存地址<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们有个疑惑，这句语句执行顺序是 <code>a = {n: 2} &amp;&amp; a.x = {n:2}</code> 还是 <code>a.x = {n:2} &amp;&amp; a= {n:2}</code> 还是这种 <code>a = {n: 2} &amp;&amp; a.x = a</code></p>
<p>我们这里可以借助 <code>Object.defineProperty</code> 或 ES6的 <code>Proxy</code>来验证多项赋值的顺序是怎样的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = newProxy(&#123;&#125;, &#123;</span><br><span class="line">  set(target, key, value, r) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key, value)</span><br><span class="line">	<span class="keyword">if</span> (key === <span class="string">'a'</span>) <span class="built_in">Reflect</span>.set(target, key, <span class="string">'isA'</span>, r);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">Reflect</span>.set(target, key, value, r);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.b = obj.a= &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// "a" &#123;n: 1&#125;</span></span><br><span class="line"><span class="comment">// "b" &#123;n: 1&#125;</span></span><br><span class="line"></span><br><span class="line">obj.a; <span class="comment">// isA</span></span><br><span class="line">obj.b; <span class="comment">// &#123;n: 1&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>所以我们可以得出 赋值的顺序是从右边开始到左边的。而且是直接 <code>a = {n: 1}, a.x = {n:1 }</code>，而不是 <code>a.x = a</code> 这样去赋值</p>
<p>现在我们再借助 Proxy 来分析一开始part1这道题，用obj.a, obj.b 来代替原题目的 a和b。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = newProxy(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a = &#123;<span class="attr">n</span>: <span class="number">1</span> &#125;;<span class="comment">// getting a;</span></span><br><span class="line">obj.b = obj.a; <span class="comment">// getting a; setting b;</span></span><br><span class="line">obj.a.x = obj.a = &#123;<span class="attr">n</span>:<span class="number">2</span> &#125;; <span class="comment">// getting a; setting a;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到 <code>obj.a.x = obj.a = {n: 2}</code>这段语句执行时，会先输出一个 <strong>getting a</strong> 再输出 <strong>setting a</strong>。<br>这就意味着在对 <code>obj.a.x</code> 赋值时，程序是先获取 <code>obj.a</code>指向的对象的内存地址，此时触发了 <strong>getting a</strong>，然后再对右边 <code>obj.a</code> 进行赋值，触发了 <strong>setting a</strong>， 赋值完最后一步才是对 <code>obj.a.x</code>赋值 <code>{n:2 }</code>。</p>
<p><font color="#ff0000"> <strong> 重点: 在对obj.a.x赋值的时刻已经获取了obj.a该对象指向的内存地址【也就是obj.a.x在obj.a赋值前就已经确定了】，所以后面a就算指向其他地址，也和这里的obj.a.x无关。此时指向该地址的还有obj.b </strong> </font> <br> </p>
<p>我们再用三张图来捋一捋整理的思路</p>
<p>执行 <code>obj.a = {n: 1}; obj.b = obj.a</code>后obj对应的引用是这样的</p>
<p><img src="/2019/01/06/一道赋值面试题引发的思考/init.png" alt=""></p>
<p>执行 <code>obj.a.x = xxx</code> 时</p>
<p><img src="/2019/01/06/一道赋值面试题引发的思考/obj.a.x.png" alt=""></p>
<p>执行<code>obj.a.x = obj.a = {n:2}</code> 后</p>
<p><img src="/2019/01/06/一道赋值面试题引发的思考/result.png" alt=""></p>
<p>至此，这道面试题相信大家都有答案了，可以自己去控制台验证一下。 假如这时候再执行 <code>obj.a.n = 3</code>， 打印<code>obj.b</code>会输出什么呢？</p>
<p><img src="/2019/01/06/一道赋值面试题引发的思考/1.png" alt=""></p>
<h2 id="对象循环引用"><a href="#对象循环引用" class="headerlink" title="对象循环引用"></a>对象循环引用</h2><p>接下来我们来看另一道题，关于对象循环引用的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span>&#125;</span><br><span class="line">a.b = a;</span><br></pre></td></tr></table></figure></p>
<p>这里的a明显是循环引用，那么我们要怎样才能判断一个对象是否是循环引用呢？<br><img src="/2019/01/06/一道赋值面试题引发的思考/2.png" alt=""></p>
<p>其实这道题我一开始除了递归判断外没有很好的解决方案，后面是群里一个大佬说(这道题也是他出的)直接用 <code>JSON.stringify</code>，微信小游戏的源码里面就是这么去判断。</p>
<p><code>JSON.stringify</code> 如果遇到参数里有循环引用的，就会抛出一个循环调用的错误 <strong>Uncaught TypeError: Converting circular structure to JSON</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Uncaught <span class="built_in">TypeError</span>: Converting circular structure to <span class="built_in">JSON</span></span><br><span class="line">    at <span class="built_in">JSON</span>.stringify (<span class="xml"><span class="tag">&lt;<span class="name">anonymous</span>&gt;</span>)</span></span><br><span class="line"><span class="xml">    at mainctrl.js:234</span></span><br><span class="line"><span class="xml">    at Object.getUser (api.js:247)</span></span><br><span class="line"><span class="xml">    at mainctrl.js:228</span></span><br></pre></td></tr></table></figure></p>
<p>那如果不用JSON.stringify或者想要自己实现一个去检测循环调用，该怎么写呢？（面试官和部门前端leader最喜欢这么问）</p>
<p>一般遇到这种，最简单的方法就是去找这个方法的 polyfill， <a href="https://github.com/bestiejs/json3" target="_blank" rel="noopener">json3</a>。我找的是 json3的 polyfill 里面大概是遍历对象存到stack数组，再在解析的时候去判断是否有循环引用的情况。 <a href="https://github.com/bestiejs/json3/blob/master/lib/json3.js#L482" target="_blank" rel="noopener">json3.js#L482</a></p>
<p>照着他的思路大概写了一个，其实就是前面说到的简单递归判断</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len;</span><br><span class="line">    <span class="keyword">for</span> (len = stack.length; len--;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack[len] === obj) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"循环引用"</span>)     <span class="comment">//循环引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    stack.push(obj);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = obj[k]</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'object'</span>) fn(value);     <span class="comment">//递归判断</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/06/一道赋值面试题引发的思考/3.png" alt=""> </p>
<h2 id="对象循环引用破解办法"><a href="#对象循环引用破解办法" class="headerlink" title="对象循环引用破解办法"></a>对象循环引用破解办法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo: Circular reference</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o.o = o;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Note: cache should not be re-used by repeated calls to JSON.stringify.</span></span><br><span class="line"><span class="keyword">var</span> cache = [];</span><br><span class="line"><span class="built_in">JSON</span>.stringify(o, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'object'</span> &amp;&amp; value !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.indexOf(value) !== <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// Circular reference found, discard key</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Store value in our collection</span></span><br><span class="line">        cache.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;);</span><br><span class="line">cache = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/06/一道赋值面试题引发的思考/4.png" alt=""> </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tx.jpg" alt="李斌">
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">147</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


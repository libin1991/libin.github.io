<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/解密webpack-tree-starking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/解密webpack-tree-starking/" itemprop="url">解密webpack tree-starking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T19:42:07+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tree-Shaking-简介"><a href="#Tree-Shaking-简介" class="headerlink" title="Tree-Shaking 简介"></a>Tree-Shaking 简介</h2><h5 id="最近看了一篇-你的Tree-Shaking并没什么卵用-吓得我赶紧好好研究Tree-Shaking。"><a href="#最近看了一篇-你的Tree-Shaking并没什么卵用-吓得我赶紧好好研究Tree-Shaking。" class="headerlink" title="最近看了一篇 你的Tree-Shaking并没什么卵用 吓得我赶紧好好研究Tree-Shaking。"></a>最近看了一篇 <a href="https://juejin.im/post/5a5652d8f265da3e497ff3de" target="_blank" rel="noopener">你的Tree-Shaking并没什么卵用</a> 吓得我赶紧好好研究Tree-Shaking。</h5><p><code>tree-sharking</code> 是 <code>Webpack 2</code> 后续版本的优化功能，顾名思义，就是将多余的代码给 “摇晃” 掉，在开发中我们经常使用一些第三方库，而这些第三方库只使用了这个库的一部门功能或代码，未使用的代码也要被打包进来，这样出口文件会非常大，<code>tree-sharking</code> 帮我们解决了这个问题，它可以将各个模块中没有使用的方法过滤掉，只对有效代码进行打包。</p>
<p>Tree-Shaking在前端界由rollup首先提出并实现，后续webpack在2.x版本也借助于UglifyJS实现了。自那以后，在各类讨论优化打包的文章中，都能看到Tree-Shaking的身影。</p>
<hr>
<h2 id="AST-语法树分析"><a href="#AST-语法树分析" class="headerlink" title="AST 语法树分析"></a>AST 语法树分析</h2><blockquote>
<p>AST 抽象语法树简介</p>
</blockquote>
<p>AST（Abstract Syntax Tree）是源代码的抽象语法结构树状表现形式，Webpack、ESLint、JSX、TypeScript 的编译和模块化规则之间的转化都是通过 AST 来实现对代码的检查、分析以及编译等操作。</p>
<h3 id="JavaScript-语法的-AST-语法树"><a href="#JavaScript-语法的-AST-语法树" class="headerlink" title="JavaScript 语法的 AST 语法树"></a>JavaScript 语法的 AST 语法树</h3><blockquote>
<p>JavaScript 中想要使用 AST 进行开发，要知道抽象成语法树之后的结构是什么，里面的字段名称都代表什么含义以及遍历的规则，<br>我们可以通过在线转换网站<strong><a href="http://esprima.org/demo/parse.html" target="_blank" rel="noopener">http://esprima.org/demo/parse.html</a></strong>将 JS 代码装换成 AST 语法树。</p>
</blockquote>
<p>通过在线编译工具，可以将 <code>function fn(a, b) {}</code>编译为下面的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line">            &quot;id&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;fn&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;params&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;b&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;body&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line">                &quot;body&quot;: []</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;generator&quot;: false,</span><br><span class="line">            &quot;expression&quot;: false,</span><br><span class="line">            &quot;async&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>将 JavaScript 语法编译成抽象语法树后，需要对它进行遍历、修该并重新编译，遍历树结构的过程为 “先序深度优先”。</p>
</blockquote>
<h2 id="esprima、estraverse-和-escodegen"><a href="#esprima、estraverse-和-escodegen" class="headerlink" title="esprima、estraverse 和 escodegen"></a>esprima、estraverse 和 escodegen</h2><p><code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 模块是操作 AST 的三个重要模块，也是实现 <code>babel</code> 的核心依赖，下面是分别介绍三个模块的作用。</p>
<h3 id="1、esprima-将-JS-转换成-AST"><a href="#1、esprima-将-JS-转换成-AST" class="headerlink" title="1、esprima 将 JS 转换成 AST"></a>1、esprima 将 JS 转换成 AST</h3><p><strong>esprima 模块的用法如下：</strong></p>
<blockquote>
<p>文件：esprima-test.js</p>
</blockquote>
<pre><code>const esprima = require(&quot;esprima&quot;);

let code = &quot;function fn() {}&quot;;

// 生成语法树
let tree = esprima.parseScript(code);

console.log(tree);

// Script {
//   type: &apos;Program&apos;,
//   body:
//    [ FunctionDeclaration {
//        type: &apos;FunctionDeclaration&apos;,
//        id: [Identifier],
//        params: [],
//        body: [BlockStatement],
//        generator: false,
//        expression: false,
//        async: false } ],
//   sourceType: &apos;script&apos; }
</code></pre><p>通过上面的案例可以看出，通过 <code>esprima</code> 模块的 <code>parseScript</code> 方法将 JS 代码块转换成语法树，代码块需要转换成字符串，也可以通过 <code>parseModule</code> 方法转换一个模块。</p>
<h3 id="2、estraverse-遍历和修改-AST"><a href="#2、estraverse-遍历和修改-AST" class="headerlink" title="2、estraverse 遍历和修改 AST"></a>2、estraverse 遍历和修改 AST</h3><p><strong>查看遍历过程：</strong></p>
<blockquote>
<p>文件：estraverse-test.js</p>
</blockquote>
<pre><code>const esprima = require(&quot;esprima&quot;);
const estraverse = require(&quot;estraverse&quot;);

let code = &quot;function fn() {}&quot;;

// 遍历语法树
estraverse.traverse(esprima.parseScript(code), {
    enter(node) {
console.log(&quot;enter&quot;, node.type);
    },
    leave() {
console.log(&quot;leave&quot;, node.type);
    }
});

// enter Program
// enter FunctionDeclaration
// enter Identifier
// leave Identifier
// enter BlockStatement
// leave BlockStatement
// leave FunctionDeclaration
// leave Program
</code></pre><p>上面代码通过 <code>estraverse</code> 模块的 <code>traverse</code> 方法将 <code>esprima</code> 模块转换的 AST 进行了遍历，并打印了所有的 <code>type</code> 属性并打印，每含有一个 <code>type</code> 属性的对象被叫做一个节点，修改是获取对应的类型并修改该节点中的属性即可。</p>
<p>其实深度遍历 AST 就是在遍历每一层的 <code>type</code> 属性，所以遍历会分为两个阶段，进入阶段和离开阶段，在 <code>estraverse</code> 的 <code>traverse</code> 方法中分别用参数指定的 <code>entry</code> 和 <code>leave</code> 两个函数监听，但是我们一般只使用 <code>entry</code>。</p>
<h3 id="3、escodegen-将-AST-转换成-JS"><a href="#3、escodegen-将-AST-转换成-JS" class="headerlink" title="3、escodegen 将 AST 转换成 JS"></a>3、escodegen 将 AST 转换成 JS</h3><p>下面的案例是一个段 JS 代码块被转换成 AST，并将遍历、修改后的 AST 重新转换成 JS 的全过程。</p>
<blockquote>
<p>文件：escodegen-test.js</p>
</blockquote>
<pre><code>const esprima = require(&quot;esprima&quot;);
const estraverse = require(&quot;estraverse&quot;);
const escodegen = require(&quot;escodegen&quot;);

let code = &quot;function fn() {}&quot;;

// 生成语法树
let tree = esprima.parseScript(code);

// 遍历语法树
estraverse.traverse(tree, {
    enter(node) {
// 修改函数名
if (node.type === &quot;FunctionDeclaration&quot;) {
            node.id.name = &quot;ast&quot;;
        }
    }
});

// 编译语法树
let result = escodegen.generate(tree);

console.log(result);

// function ast() {
// }
</code></pre><p><strong><em>在遍历 AST 的过程中 <code>params</code> 值为数组，没有 <code>type</code> 属性。</em></strong></p>
<hr>
<h2 id="实现-Babel-语法转换插件"><a href="#实现-Babel-语法转换插件" class="headerlink" title="实现 Babel 语法转换插件"></a>实现 Babel 语法转换插件</h2><p>实现语法转换插件需要借助 <code>babel-core</code> 和 <code>babel-types</code> 两个模块，其实这两个模块就是依赖 <code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 的。</p>
<p><strong>使用这两个模块需要安装，命令如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-types</span><br></pre></td></tr></table></figure>
<h3 id="1、plugin-transform-arrow-functions"><a href="#1、plugin-transform-arrow-functions" class="headerlink" title="1、plugin-transform-arrow-functions"></a>1、plugin-transform-arrow-functions</h3><p><code>plugin-transform-arrow-functions</code> 是 Babel 家族成员之一，用于将箭头函数转换 ES5 语法的函数表达式。</p>
<blockquote>
<p>文件：plugin-transform-arrow-functions.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">// 箭头函数代码块</span><br><span class="line">let sumCode = `</span><br><span class="line">const sum = (a, b) =&gt; &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;`;</span><br><span class="line">let minusCode = `const minus = (a, b) =&gt; a - b;`;</span><br><span class="line"></span><br><span class="line">// 转化 ES5 插件</span><br><span class="line">let ArrowPlugin = &#123;</span><br><span class="line">// 访问者（访问者模式）</span><br><span class="line">    visitor: &#123;</span><br><span class="line">// path 是树的路径</span><br><span class="line">        ArrowFunctionExpression(path) &#123;</span><br><span class="line">// 获取树节点</span><br><span class="line">let node = path.node;</span><br><span class="line"></span><br><span class="line">// 获取参数和函数体</span><br><span class="line">let params = node.params;</span><br><span class="line">let body = node.body;</span><br><span class="line"></span><br><span class="line">// 判断函数体是否是代码块，不是代码块则添加 return 和 &#123;&#125;</span><br><span class="line">if (!types.isBlockStatement(body)) &#123;</span><br><span class="line">let returnStatement = types.returnStatement(body);</span><br><span class="line">                body = types.blockStatement([returnStatement]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">// 生成一个函数表达式树结构</span><br><span class="line">let func = types.functionExpression(null, params, body, false, false);</span><br><span class="line"></span><br><span class="line">// 用新的树结构替换掉旧的树结构</span><br><span class="line">            types.replaceWith(func);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 生成转换后的代码块</span><br><span class="line">let sumResult = babel.transform(sumCode, &#123;</span><br><span class="line">    plugins: [ArrowPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let minusResult = babel.transform(minusCode, &#123;</span><br><span class="line">    plugins: [ArrowPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(sumResult.code);</span><br><span class="line">console.log(minusResult.code);</span><br><span class="line"></span><br><span class="line">// let sum = function (a, b) &#123;</span><br><span class="line">//   return a + b;</span><br><span class="line">// &#125;;</span><br><span class="line">// let minus = function (a, b) &#123;</span><br><span class="line">//   return a - b;</span><br><span class="line">// &#125;;</span><br></pre></td></tr></table></figure>
<p>我们主要使用 <code>babel-core</code> 的 <code>transform</code> 方法将 AST 转化成代码块，第一个参数为转换前的代码块（字符串），第二个参数为配置项，其中 <code>plugins</code> 值为数组，存储修改 <code>babal-core</code> 转换的 AST 的插件（对象），使用 <code>transform</code> 方法将旧的 AST 处理成新的代码块后，返回值为一个对象，对象的 <code>code</code> 属性为转换后的代码块（字符串）。</p>
<p>内部修改通过 <code>babel-types</code> 模块提供的方法实现，API 可以到 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank" rel="noopener">https://github.com/babel/babel/tree/6.x/packages/babel-types</a> 中查看。</p>
<p><code>ArrowPlugin</code> 就是传入 <code>transform</code> 方法的插件，必须含有 <code>visitor</code> 属性（固定），值同为对象，用于存储修改语法树的方法，方法名要严格按照 API，对应的方法会修改 AST 对应的节点。</p>
<p>在 <code>types.functionExpression</code> 方法中参数分别代表，函数名（匿名函数为 <code>null</code>）、函数参数（必填）、函数体（必填）、是否为 <code>generator</code> 函数（默认 <code>false</code>）、是否为 <code>async</code> 函数（默认 <code>false</code>），返回值为修改后的 AST，<code>types.replaceWith</code> 方法用于替换 AST，参数为新的 AST。</p>
<h3 id="2、plugin-transform-classes"><a href="#2、plugin-transform-classes" class="headerlink" title="2、plugin-transform-classes"></a>2、plugin-transform-classes</h3><p><code>plugin-transform-classes</code> 也是 Babel 家族中的成员之一，用于将 ES6 的 <code>class</code> 类转换成 ES5 的构造函数。</p>
<blockquote>
<p>文件：plugin-transform-classes.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">// 类</span><br><span class="line">let code = `</span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName () &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;`;</span><br><span class="line"></span><br><span class="line">// 将类转化 ES5 构造函数插件</span><br><span class="line">let ClassPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ClassDeclaration(path) &#123;</span><br><span class="line">let node = path.node;</span><br><span class="line">let classList = node.body.body;</span><br><span class="line"></span><br><span class="line">// 将取到的类名转换成标识符 &#123; type: &apos;Identifier&apos;, name: &apos;Person&apos; &#125;</span><br><span class="line">let className = types.identifier(node.id.name);</span><br><span class="line">let body = types.blockStatement([]);</span><br><span class="line">let func = types.functionDeclaration(className, [], body, false, false);</span><br><span class="line">            path.replaceWith(func);</span><br><span class="line"></span><br><span class="line">// 用于存储多个原型方法</span><br><span class="line">let es5Func = [];</span><br><span class="line"></span><br><span class="line">// 获取 class 中的代码体</span><br><span class="line">            classList.forEach((item, index) =&gt; &#123;</span><br><span class="line">// 函数的代码体</span><br><span class="line">let body = classList[index].body;</span><br><span class="line"></span><br><span class="line">// 获取参数</span><br><span class="line">let params = item.params.length ? item.params.map(val =&gt; val.name) : [];</span><br><span class="line"></span><br><span class="line">// 转化参数为标识符</span><br><span class="line">                params = types.identifier(params);</span><br><span class="line"></span><br><span class="line">// 判断是否是 constructor，如果构造函数那就生成新的函数替换</span><br><span class="line">if (item.kind === &quot;constructor&quot;) &#123;</span><br><span class="line">// 生成一个构造函数树结构</span><br><span class="line">                    func = types.functionDeclaration(className, [params], body, false, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">// 其他情况是原型方法</span><br><span class="line">let proto = types.memberExpression(className, types.identifier(&quot;prototype&quot;));</span><br><span class="line"></span><br><span class="line">// 左侧层层定义标识符 Person.prototype.getName</span><br><span class="line">let left = types.memberExpression(proto, types.identifier(item.key.name));</span><br><span class="line"></span><br><span class="line">// 右侧定义匿名函数</span><br><span class="line">let right = types.functionExpression(null, [params], body, false, false);</span><br><span class="line"></span><br><span class="line">// 将左侧和右侧进行合并并存入数组</span><br><span class="line">                    es5Func.push(types.assignmentExpression(&quot;=&quot;, left, right));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">// 如果没有原型方法，直接替换</span><br><span class="line">if (es5Func.length === 0) &#123;</span><br><span class="line">                path.replaceWith(func);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                es5Func.push(func);</span><br><span class="line">// 替换 n 个节点</span><br><span class="line">                path.replaceWithMultiple(es5Func);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 生成转换后的代码块</span><br><span class="line">result = babel.transform(code, &#123;</span><br><span class="line">    plugins: [ClassPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result.code);</span><br><span class="line"></span><br><span class="line">// Person.prototype.getName = function () &#123;</span><br><span class="line">//     return this.name;</span><br><span class="line">// &#125;</span><br><span class="line">// function Person(name) &#123;</span><br><span class="line">//     this.name = name;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<p>上面这个插件的实现要比 <code>plugin-transform-arrow-functions</code> 复杂一些，归根结底还是将要互相转换的 ES6 和 ES5 语法树做对比，找到他们的不同，并使用 <code>babel-types</code> 提供的 API 对语法树对应的节点属性进行修改并替换语法树，值得注意的是 <code>path.replaceWithMultiple</code> 与 <code>path.replaceWith</code> 不同，参数为一个数组，数组支持多个语法树结构，可根据具体修改语法树的场景选择使用，也可根据不同情况使用不同的替换方法。</p>
<blockquote>
<p>通过本节我们了解了什么是 AST 抽象语法树、抽象语法树在 JavaScript 中的体现以及在 NodeJS 中用于生成、遍历和修改 AST 抽象语法树的核心依赖，并通过使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块简易模拟了 ES6 新特性转换为 ES5 语法的过程，希望可以为后面自己实现一些编译插件提供了思路。</p>
</blockquote>
<hr>
<p>假设我们现在使用了 ElementUI 库的两个组件，通常会使用解构赋值来引入。</p>
<blockquote>
<p>优化前</p>
</blockquote>
<pre><code>import { Button, Alert } from&quot;element-ui&quot;;
</code></pre><p>这样引用资源， Webpack 在打包的时候会找到 <code>element-ui</code> 并把里面所有的代码全部打包到出口文件，我们只使用了两个组件，全部打包不是我们所希望的，<code>tree-sharking</code> 是通过在 Webpack 中配置 <code>babel-plugin-import</code> 插件来实现的，它可以将解构的代码转换成下面的形式。</p>
<blockquote>
<p>优化后</p>
</blockquote>
<pre><code>import Button from&quot;element-ui/lib/button&quot;;
import Alert from&quot;element-ui/lib/Alert&quot;;
</code></pre><p>转化后会去 <code>node_modules</code> 中的 <code>element-ui</code> 模块找到 <code>Button</code> 和 <code>Alert</code> 两个组件对应的文件，并打包到出口文件中。</p>
<p>通过上面的转换可以看出，其实 <code>tree-sharking</code> 的实现原理是通过改变 AST 语法树的结构来实现的，如果不了解抽象语法树可以参考 <a href="https://www.pandashen.com/2018/07/25/20180725130233/" target="_blank" rel="noopener">AST 抽象语法树</a>，</p>
<blockquote>
<p>优化前的 AST 语法树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;imported&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;imported&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优化后的 AST 语法树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui/lib/button&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui/lib/button\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui/lib/Alert&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui/lib/Alert\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的语法树对比，可以看出在优化前 <code>body</code> 里面只有一个对象，使用的组件信息存在 <code>specifiers</code> 里，<code>source</code> 指向了 <code>element-ui</code>，而在优化后，将两个组件分别拆成了两个对象存在 <code>body</code> 中，每个对象的的 <code>specifiers</code> 只存储一个组件，并在 <code>source</code> 里面指向了当前组件对应的路径。</p>
<hr>
<h2 id="模拟-tree-starking"><a href="#模拟-tree-starking" class="headerlink" title="模拟 tree-starking"></a>模拟 tree-starking</h2><p>既然我们已经清楚要修改语法树的位置，下面就使用 AST 来模拟 <code>tree-sharking</code> 功能，对语法树的操作是依赖于 <code>babel-core</code> 和 <code>babel-types</code> 两个核心模块的，下面先安装依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-types</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>文件：babel-plugin-my-import.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">let code = `import &#123; Button, Alert &#125; from &quot;element-ui&quot;`;</span><br><span class="line"></span><br><span class="line">let importPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ImportDeclaration(path) &#123;</span><br><span class="line">            let node = path.node;</span><br><span class="line">            let source = node.source.value;</span><br><span class="line">            let specifiers = node.specifiers;</span><br><span class="line"></span><br><span class="line">            // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出</span><br><span class="line">            if (!types.isImportDefaultSpecifier(specifiers[0])) &#123;</span><br><span class="line">                // 如果不是默认导出，则需要转换</span><br><span class="line">                specifiers = specifiers.map(specifier =&gt; &#123;</span><br><span class="line">                    // 数组内容：当前默认导出的标识、从哪里导入</span><br><span class="line">                    return types.importDeclaration(</span><br><span class="line">                        [types.importDefaultSpecifier(specifier.local)],</span><br><span class="line">                        types.stringLiteral(`$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;`)</span><br><span class="line">                    );</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // 替换树结构</span><br><span class="line">                path.replaceWithMultiple(specifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let result = babel.transform(code, &#123;</span><br><span class="line">    plugins: [importPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result.code);</span><br><span class="line"></span><br><span class="line">// import Button from &quot;element-ui/lib/button&quot;;</span><br><span class="line">// import Alert from &quot;element-ui/lib/alert&quot;;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码可以发现我们使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块的核心方法对语法书进行了遍历、修改和替换，更详细的 API 可以查看 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank" rel="noopener">https://github.com/babel/babel/tree/6.x/packages/babel-types</a>。</p>
<hr>
<h2 id="结合-Webpack-使用插件"><a href="#结合-Webpack-使用插件" class="headerlink" title="结合 Webpack 使用插件"></a>结合 Webpack 使用插件</h2><p>前面只是验证了 <code>tree-sharking</code> 中 JS 语法的转换过程，接下来将上面的代码转换成插件配合 Webpack 使用，来彻底感受 <code>tree-sharking</code> 的工作过程。</p>
<blockquote>
<p>文件：~node_modules/babel-plugin-my-import.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">let importPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ImportDeclaration(path) &#123;</span><br><span class="line">            let node = path.node;</span><br><span class="line">            let source = node.source.value;</span><br><span class="line">            let specifiers = node.specifiers;</span><br><span class="line"></span><br><span class="line">            // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出</span><br><span class="line">            if (!types.isImportDefaultSpecifier(specifiers[0])) &#123;</span><br><span class="line">                // 如果不是默认导出，则需要转换</span><br><span class="line">                specifiers = specifiers.map(specifier =&gt; &#123;</span><br><span class="line">                    // 数组内容：当前默认导出的标识、从哪里导入</span><br><span class="line">                    return types.importDeclaration(</span><br><span class="line">                        [types.importDefaultSpecifier(specifier.local)],</span><br><span class="line">                        types.stringLiteral(`$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;`)</span><br><span class="line">                    );</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // 替换树解构</span><br><span class="line">                path.replaceWithMultiple(specifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = importPlugin;</span><br></pre></td></tr></table></figure>
<p>上面删掉了多余的测试代码，将模块中的 <code>importPlugin</code> 插件导出，并把 <code>babel-plugin-my-import.js</code> 移入了 <code>node_modules</code> 当中。</p>
<p><strong>接下来安装需要的依赖：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli babel-loader babel-presets-env</span><br><span class="line">npm install vue element-ui --save</span><br></pre></td></tr></table></figure></p>
<p>安装完依赖，写一个要编译的文件，使用 Webpack 进行打包，查看使用插件前和使用插件后出口文件的大小。<br>文件：import.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vue from&quot;vue&quot;;</span><br><span class="line">import &#123; Button, Alert &#125; from&quot;element-ui&quot;;</span><br></pre></td></tr></table></figure></p>
<p>下面来写一个简单的 Webpack 配置文件。</p>
<blockquote>
<p>文件：webpcak.config.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    module.exports = &#123;</span><br><span class="line">    mode: &quot;development&quot;,</span><br><span class="line">    entry: &quot;import.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;bundle.js&quot;,</span><br><span class="line">        path: __dirname</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: &quot;babel-loader&quot;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [</span><br><span class="line">                        &quot;env&quot;,</span><br><span class="line">                    ],</span><br><span class="line">                    plugins: [</span><br><span class="line">                        // 插件：不使用插件打包注释掉该行即可</span><br><span class="line">                        [&quot;my-import&quot;, &#123; libararyName: &quot;element-ui&quot; &#125;]</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了防止 <code>babel</code> 相关的依赖升级 <code>7.0</code> 后出现一些问题导致 Webpack 无法启动，再此贴出 <code>package.json</code> 文件，按照对应版本下载依赖保证上面 Webpack 配置生效。</p>
<blockquote>
<p>文件：package.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;: &quot;ast-lesson&quot;,</span><br><span class="line"> &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line"> &quot;description&quot;: &quot;tree-starking&quot;,</span><br><span class="line"> &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line"> &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">   &#125;,</span><br><span class="line"> &quot;keywords&quot;: [],</span><br><span class="line"> &quot;author&quot;: &quot;&quot;,</span><br><span class="line"> &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line"> &quot;dependencies&quot;: &#123;</span><br><span class="line"> &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line"> &quot;babel-loader&quot;: &quot;^7.1.5&quot;,</span><br><span class="line"> &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,</span><br><span class="line"> &quot;babel-types&quot;: &quot;^6.26.0&quot;,</span><br><span class="line"> &quot;escodegen&quot;: &quot;^1.10.0&quot;,</span><br><span class="line"> &quot;esprima&quot;: &quot;^4.0.0&quot;,</span><br><span class="line"> &quot;estraverse&quot;: &quot;^4.2.0&quot;,</span><br><span class="line"> &quot;webpack&quot;: &quot;^4.16.0&quot;,</span><br><span class="line"> &quot;webpack-cli&quot;: &quot;^3.0.8&quot;</span><br><span class="line">   &#125;,</span><br><span class="line"> &quot;devDependencies&quot;: &#123;</span><br><span class="line"> &quot;vue&quot;: &quot;^2.5.17&quot;,</span><br><span class="line"> &quot;element-ui&quot;: &quot;^2.4.6&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="对比使用插件前后的出口文件"><a href="#对比使用插件前后的出口文件" class="headerlink" title="对比使用插件前后的出口文件"></a>对比使用插件前后的出口文件</h2><p>接下来分别在使用插件和不使用插件时执行打包命令，查看出口文件 <code>bondle.js</code> 的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>babel-plugin-my-import</code> 前：</p>
<p><a href="/2018/07/26/20180726122146/before-babel-plugin.jpg"><img src="/2018/10/25/解密webpack-tree-starking/before-babel-plugin.jpg" alt="使用 tree-starking 之前"></a></p>
<p>使用 <code>babel-plugin-my-import</code> 后：</p>
<p><a href="/2018/07/26/20180726122146/after-babel-plugin.jpg"><img src="/2018/10/25/解密webpack-tree-starking/after-babel-plugin.jpg" alt="使用 tree-starking 之后"></a></p>
<p>通过对比，可以看到使用 <code>tree-sharking</code> 即我们自己实现的 <code>babel-plugin-my-import</code> 插件后，打包的出口文件大大减小，其原因是将引入第三方库没有使用的代码全都过滤掉了，只打包了有效代码。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面对 Webpack 的 <code>tree-sharking</code> 进行了分析，并模拟 <code>babel-plugin-import</code> 简易的实现了一版 <code>tree-sharking</code> 的优化插件，这个过程中相信大家已经了解了 <code>tree-sharking</code> 的原理以及实现类似插件的思路，并已经具备了开发类似插件的基本条件，最后还有一点需要补充，<code>tree-sharking</code> 优化的方式是根据 ES6 语法 <code>import</code> “静态” 引入的特性实现的，如果要说 <code>tree-sharking</code> 很强大，还不如说 ES6 模块化规范 “静态” 引入的特性强大，正由于是基于 “静态” 引入，所以目前 <code>tree-sharking</code> 只支持遍历一层 <code>import</code> 关键字。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/24/async-并发执行和继发执行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/24/async-并发执行和继发执行/" itemprop="url">async 并发执行和继发执行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-24T19:50:49+08:00">
                2018-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong> 面试题继发执行 : 1s后执行10，等1s后输出20，再等1s后输出30 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			function Pro(val) &#123;</span><br><span class="line">				return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">					setTimeout(function() &#123;</span><br><span class="line">						resolve(val)</span><br><span class="line">					&#125;, 1000)</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			async function log(arrs) &#123;</span><br><span class="line">				for(const item of arrs) &#123;</span><br><span class="line">					var response = await Pro(item);</span><br><span class="line">					console.log(response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			log([10, 20, 30])</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>问题：给定一个 URL 数组，如何实现接口的继发和并发？</strong></p>
<h3 id="async-继发实现："><a href="#async-继发实现：" class="headerlink" title="async 继发实现："></a>async 继发实现：</h3><h4 id="继发一"><a href="#继发一" class="headerlink" title="继发一"></a>继发一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async functionloadData() &#123;</span><br><span class="line">  var res1 = await fetch(url1);</span><br><span class="line">  var res2 = await fetch(url2);</span><br><span class="line">  var res3 = await fetch(url3);</span><br><span class="line">  return&quot;whew all done&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继发二"><a href="#继发二" class="headerlink" title="继发二"></a>继发二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async functionloadData(urls) &#123;</span><br><span class="line">  for (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async-并发实现："><a href="#async-并发实现：" class="headerlink" title="async 并发实现："></a>async 并发实现：</h3><h4 id="并发一"><a href="#并发一" class="headerlink" title="并发一"></a>并发一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async functionloadData() &#123;</span><br><span class="line">  var res = awaitPromise.all([fetch(url1), fetch(url2), fetch(url3)]);</span><br><span class="line">  return&quot;whew all done&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并发二"><a href="#并发二" class="headerlink" title="并发二"></a>并发二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async functionloadData(urls) &#123;</span><br><span class="line">  // 并发读取 urlconst textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    return response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出for (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/javascript-原生常用API大全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/javascript-原生常用API大全/" itemprop="url">javascript 原生常用API大全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T21:11:22+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原生JS-API"><a href="#原生JS-API" class="headerlink" title="原生JS API"></a>原生JS API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br></pre></td><td class="code"><pre><span class="line">一、节点</span><br><span class="line">1.1 节点属性</span><br><span class="line">Node.nodeName   //返回节点名称，只读</span><br><span class="line">Node.nodeType   //返回节点类型的常数值，只读</span><br><span class="line">Node.nodeValue  //返回Text或Comment节点的文本值，只读</span><br><span class="line">Node.textContent  //返回当前节点和它的所有后代节点的文本内容，可读写</span><br><span class="line">Node.baseURI    //返回当前网页的绝对路径</span><br><span class="line"></span><br><span class="line">Node.ownerDocument  //返回当前节点所在的顶层文档对象，即document</span><br><span class="line">Node.nextSibling  //返回紧跟在当前节点后面的第一个兄弟节点</span><br><span class="line">Node.previousSibling  //返回当前节点前面的、距离最近的一个兄弟节点</span><br><span class="line">Node.parentNode   //返回当前节点的父节点</span><br><span class="line">Node.parentElement  //返回当前节点的父Element节点</span><br><span class="line">Node.childNodes   //返回当前节点的所有子节点</span><br><span class="line">Node.firstChild  //返回当前节点的第一个子节点</span><br><span class="line">Node.lastChild   //返回当前节点的最后一个子节点</span><br><span class="line"></span><br><span class="line">//parentNode接口</span><br><span class="line">Node.children  //返回指定节点的所有Element子节点</span><br><span class="line">Node.firstElementChild  //返回当前节点的第一个Element子节点</span><br><span class="line">Node.lastElementChild   //返回当前节点的最后一个Element子节点</span><br><span class="line">Node.childElementCount  //返回当前节点所有Element子节点的数目。</span><br><span class="line">1.2 操作</span><br><span class="line">Node.appendChild(node)   //向节点添加最后一个子节点</span><br><span class="line">Node.hasChildNodes()   //返回布尔值，表示当前节点是否有子节点</span><br><span class="line">Node.cloneNode(true);  // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)</span><br><span class="line">Node.insertBefore(newNode,oldNode)  // 在指定子节点之前插入新的子节点</span><br><span class="line">Node.removeChild(node)   //删除节点，在要删除节点的父节点上操作</span><br><span class="line">Node.replaceChild(newChild,oldChild)  //替换节点</span><br><span class="line">Node.contains(node)  //返回一个布尔值，表示参数节点是否为当前节点的后代节点。</span><br><span class="line">Node.compareDocumentPosition(node)   //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系</span><br><span class="line">Node.isEqualNode(noe)  //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</span><br><span class="line">Node.normalize()   //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。</span><br><span class="line"></span><br><span class="line">//ChildNode接口</span><br><span class="line">Node.remove()  //用于删除当前节点</span><br><span class="line">Node.before()  //</span><br><span class="line">Node.after()</span><br><span class="line">Node.replaceWith()</span><br><span class="line">1.3 Document节点</span><br><span class="line">1.3.1 Document节点的属性</span><br><span class="line">document.doctype   //</span><br><span class="line">document.documentElement  //返回当前文档的根节点</span><br><span class="line">document.defaultView   //返回document对象所在的window对象</span><br><span class="line">document.body   //返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head   //返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement  //返回当前文档中获得焦点的那个元素。</span><br><span class="line"></span><br><span class="line">//节点集合属性</span><br><span class="line">document.links  //返回当前文档的所有a元素</span><br><span class="line">document.forms  //返回页面中所有表单元素</span><br><span class="line">document.images  //返回页面中所有图片元素</span><br><span class="line">document.embeds  //返回网页中所有嵌入对象</span><br><span class="line">document.scripts  //返回当前文档的所有脚本</span><br><span class="line">document.styleSheets  //返回当前网页的所有样式表</span><br><span class="line"></span><br><span class="line">//文档信息属性</span><br><span class="line">document.documentURI  //表示当前文档的网址</span><br><span class="line">document.URL  //返回当前文档的网址</span><br><span class="line">document.domain  //返回当前文档的域名</span><br><span class="line">document.lastModified  //返回当前文档最后修改的时间戳</span><br><span class="line">document.location  //返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer  //返回当前文档的访问来源</span><br><span class="line">document.title    //返回当前文档的标题</span><br><span class="line">document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。</span><br><span class="line">document.readyState  //返回当前文档的状态</span><br><span class="line">document.designMode  //控制当前文档是否可编辑，可读写</span><br><span class="line">document.compatMode  //返回浏览器处理文档的模式</span><br><span class="line">document.cookie   //用来操作Cookie</span><br><span class="line">1.3.2 Document节点的方法</span><br><span class="line">（1）读写方法</span><br><span class="line">document.open()   //用于新建并打开一个文档</span><br><span class="line">document.close()   //不安比open方法所新建的文档</span><br><span class="line">document.write()   //用于向当前文档写入内容</span><br><span class="line">document.writeIn()  //用于向当前文档写入内容，尾部添加换行符。</span><br><span class="line">（2）查找节点</span><br><span class="line">document.querySelector(selectors)   //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。</span><br><span class="line">document.querySelectorAll(selectors)  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。</span><br><span class="line">document.getElementsByTagName(tagName)  //返回所有指定HTML标签的元素</span><br><span class="line">document.getElementsByClassName(className)   //返回包括了所有class名字符合指定条件的元素</span><br><span class="line">document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）</span><br><span class="line">document.getElementById(id)   //返回匹配指定id属性的元素节点。</span><br><span class="line">document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。</span><br><span class="line">（3）生成节点</span><br><span class="line">document.createElement(tagName)   //用来生成HTML元素节点。</span><br><span class="line">document.createTextNode(text)   //用来生成文本节点</span><br><span class="line">document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。</span><br><span class="line">document.createDocumentFragment()  //生成一个DocumentFragment对象</span><br><span class="line">（4）事件方法</span><br><span class="line">document.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span><br><span class="line">document.addEventListener(type,listener,capture)  //注册事件</span><br><span class="line">document.removeEventListener(type,listener,capture)  //注销事件</span><br><span class="line">document.dispatchEvent(event)  //触发事件</span><br><span class="line">（5）其他</span><br><span class="line">document.hasFocus()   //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</span><br><span class="line">document.adoptNode(externalNode)  //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。</span><br><span class="line">document.importNode(externalNode, deep)   //从外部文档拷贝指定节点，插入当前文档。</span><br><span class="line">1.4 Element节点</span><br><span class="line">1.4.1 Element节点的属性</span><br><span class="line">（1）特性属性</span><br><span class="line">Element.attributes  //返回当前元素节点的所有属性节点</span><br><span class="line">Element.id  //返回指定元素的id属性，可读写</span><br><span class="line">Element.tagName  //返回指定元素的大写标签名</span><br><span class="line">Element.innerHTML   //返回该元素包含的HTML代码，可读写</span><br><span class="line">Element.outerHTML  //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写</span><br><span class="line">Element.className  //返回当前元素的class属性，可读写</span><br><span class="line">Element.classList  //返回当前元素节点的所有class集合</span><br><span class="line">Element.dataset   //返回元素节点中所有的data-*属性。</span><br><span class="line">（2）尺寸属性</span><br><span class="line">Element.clientHeight   //返回元素节点可见部分的高度</span><br><span class="line">Element.clientWidth   //返回元素节点可见部分的宽度</span><br><span class="line">Element.clientLeft   //返回元素节点左边框的宽度</span><br><span class="line">Element.clientTop   //返回元素节点顶部边框的宽度</span><br><span class="line">Element.scrollHeight  //返回元素节点的总高度</span><br><span class="line">Element.scrollWidth  //返回元素节点的总宽度</span><br><span class="line">Element.scrollLeft   //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置</span><br><span class="line">Element.scrollTop   //返回元素节点的垂直滚动向下滚动的像素数值</span><br><span class="line">Element.offsetHeight   //返回元素的垂直高度(包含border,padding)</span><br><span class="line">Element.offsetWidth    //返回元素的水平宽度(包含border,padding)</span><br><span class="line">Element.offsetLeft    //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移</span><br><span class="line">Element.offsetTop   //返回水平位移</span><br><span class="line">Element.style  //返回元素节点的行内样式</span><br><span class="line">（3）节点相关属性</span><br><span class="line">Element.children   //包括当前元素节点的所有子元素</span><br><span class="line">Element.childElementCount   //返回当前元素节点包含的子HTML元素节点的个数</span><br><span class="line">Element.firstElementChild  //返回当前节点的第一个Element子节点  </span><br><span class="line">Element.lastElementChild   //返回当前节点的最后一个Element子节点  </span><br><span class="line">Element.nextElementSibling  //返回当前元素节点的下一个兄弟HTML元素节点</span><br><span class="line">Element.previousElementSibling  //返回当前元素节点的前一个兄弟HTML节点</span><br><span class="line">Element.offsetParent   //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。</span><br><span class="line">1.4.2 Element节点的方法</span><br><span class="line">（1）位置方法</span><br><span class="line">getBoundingClientRect()  </span><br><span class="line">// getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高</span><br><span class="line">// top 元素上外边界距窗口最上面的距离</span><br><span class="line">// right 元素右外边界距窗口最上面的距离</span><br><span class="line">// bottom 元素下外边界距窗口最上面的距离</span><br><span class="line">// left 元素左外边界距窗口最上面的距离</span><br><span class="line">// width 元素自身宽(包含border,padding) </span><br><span class="line">// height 元素自身高(包含border,padding) </span><br><span class="line"></span><br><span class="line">getClientRects()   //返回当前元素在页面上形参的所有矩形。</span><br><span class="line"></span><br><span class="line">// 元素在页面上的偏移量  </span><br><span class="line">var rect = el.getBoundingClientRect()  </span><br><span class="line">return &#123;   </span><br><span class="line">  top: rect.top + document.body.scrollTop,   </span><br><span class="line">  left: rect.left + document.body.scrollLeft  </span><br><span class="line">&#125;</span><br><span class="line">（2）属性方法</span><br><span class="line">Element.getAttribute()：读取指定属性  </span><br><span class="line">Element.setAttribute()：设置指定属性  </span><br><span class="line">Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  </span><br><span class="line">Element.removeAttribute()：移除指定属性</span><br><span class="line">（3）查找方法</span><br><span class="line">Element.querySelector()  </span><br><span class="line">Element.querySelectorAll()  </span><br><span class="line">Element.getElementsByTagName()  </span><br><span class="line">Element.getElementsByClassName()</span><br><span class="line">（4）事件方法</span><br><span class="line">Element.addEventListener()：添加事件的回调函数  </span><br><span class="line">Element.removeEventListener()：移除事件监听函数  </span><br><span class="line">Element.dispatchEvent()：触发事件</span><br><span class="line"></span><br><span class="line">//ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line"></span><br><span class="line">// event对象  </span><br><span class="line">var event = window.event||event;    </span><br><span class="line"></span><br><span class="line">// 事件的目标节点  </span><br><span class="line">var target = event.target || event.srcElement;</span><br><span class="line"></span><br><span class="line">// 事件代理  </span><br><span class="line">ul.addEventListener(&apos;click&apos;, function(event) &#123;   </span><br><span class="line">  if (event.target.tagName.toLowerCase() === &apos;li&apos;) &#123;   </span><br><span class="line">    console.log(event.target.innerHTML)   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);</span><br><span class="line">（5）其他</span><br><span class="line">Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域</span><br><span class="line"></span><br><span class="line">//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。</span><br><span class="line">Element.insertAdjacentHTML(where, htmlString); </span><br><span class="line">Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入  </span><br><span class="line">Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 </span><br><span class="line">Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 </span><br><span class="line">Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入</span><br><span class="line"></span><br><span class="line">Element.remove()  //用于将当前元素节点从DOM中移除</span><br><span class="line">Element.focus()   //用于将当前页面的焦点，转移到指定元素上</span><br><span class="line">二、CSS操作</span><br><span class="line">（1）类名操作</span><br><span class="line">//ie8以下</span><br><span class="line">Element.className  //获取元素节点的类名</span><br><span class="line">Element.className += &apos; &apos; + newClassName  //新增一个类名</span><br><span class="line"></span><br><span class="line">//判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;</span><br><span class="line">  return new RegExp(className,&apos;gi&apos;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除class</span><br><span class="line">function removeClass(element,className)&#123;</span><br><span class="line">  element.className = element.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ie10 </span><br><span class="line">element.classList.add(className)  //新增</span><br><span class="line">element.classList.remove(className)  //删除</span><br><span class="line">element.classList.contains(className)  //是否包含</span><br><span class="line">element.classList.toggle(className)  //toggle class</span><br><span class="line">（2）style操作</span><br><span class="line">element.setAttribute(&apos;style&apos;,&apos;&apos;)</span><br><span class="line"></span><br><span class="line">element.style.backgroundColor = &apos;red&apos;</span><br><span class="line"></span><br><span class="line">element.style.cssText //用来读写或删除整个style属性</span><br><span class="line"></span><br><span class="line">element.style.setProperty(propertyName,value)  //设置css属性</span><br><span class="line">element.style.getPropertyValue(property)  //获取css属性</span><br><span class="line">element.style.removeProperty(property)  //删除css属性</span><br><span class="line">操作非内联样式</span><br><span class="line">//ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">//ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName] </span><br><span class="line">window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">//伪类</span><br><span class="line">window.getComputedStyle(el,&apos;:after&apos;)[attrName]</span><br><span class="line">三、对象</span><br><span class="line">3.1 Object对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var o = new Object()</span><br><span class="line">（2）属性</span><br><span class="line">Object.prototype   //返回原型对象</span><br><span class="line">（3）方法</span><br><span class="line">Object.keys(o)   //遍历对象的可枚举属性</span><br><span class="line">Object.getOwnPropertyName(o)   //遍历对象不可枚举的属性</span><br><span class="line">对象实例的方法</span><br><span class="line">valueOf()：返回当前对象对应的值。  </span><br><span class="line">toString()：返回当前对象对应的字符串形式。  </span><br><span class="line">toLocaleString()：返回当前对象对应的本地字符串形式。  </span><br><span class="line">hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 </span><br><span class="line">isPrototypeOf()：判断当前对象是否为另一个对象的原型。</span><br><span class="line">propertyIsEnumerable()：判断某个属性是否可枚举。</span><br><span class="line">3.2 Array对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var a = new Array()</span><br><span class="line">（2）属性</span><br><span class="line">a.length  //长度</span><br><span class="line">（3）Array.isArray()</span><br><span class="line">Array.isArray(a)   //用来判断一个值是否为数组</span><br><span class="line">（4）Array实例的方法</span><br><span class="line"></span><br><span class="line">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</span><br><span class="line"></span><br><span class="line">a.valueof()   //返回数组本身</span><br><span class="line">a.toString()  //返回数组的字符串形式</span><br><span class="line">a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。</span><br><span class="line">pop()   //用于删除数组的最后一个元素，并返回该元素</span><br><span class="line">join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。</span><br><span class="line">concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。</span><br><span class="line">shift()  //用于删除数组的第一个元素，并返回该元素。</span><br><span class="line">unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</span><br><span class="line">reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组</span><br><span class="line">slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。</span><br><span class="line">splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</span><br><span class="line">sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。</span><br><span class="line">map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。</span><br><span class="line">map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。</span><br><span class="line">forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。</span><br><span class="line">filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</span><br><span class="line">some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。</span><br><span class="line">every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。</span><br><span class="line">reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）</span><br><span class="line">reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）</span><br><span class="line">indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置</span><br><span class="line">lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">3.3 Number对象</span><br><span class="line">（1）生成对象</span><br><span class="line">var n = new Number()</span><br><span class="line">（2）Number对象的属性</span><br><span class="line">Number.POSITIVE_INFINITY：正的无限，指向Infinity。  </span><br><span class="line">Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。  </span><br><span class="line">Number.NaN：表示非数值，指向NaN。  </span><br><span class="line">Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。  </span><br><span class="line">Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。  </span><br><span class="line">Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。  </span><br><span class="line">Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</span><br><span class="line">（4）Number对象实例的方法</span><br><span class="line">toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</span><br><span class="line">toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。</span><br><span class="line">toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。</span><br><span class="line">toPrecision()  //用于将一个数转为指定位数的有效数字。</span><br><span class="line">3.4 String 对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var s = new String()</span><br><span class="line">（2）String对象的属性</span><br><span class="line">s.length   //返回字符串的长度</span><br><span class="line">（3）方法</span><br><span class="line">s.chatAt(index)   //返回指定位置的字符    //&quot;123456&quot;[0] == &quot;1&quot;</span><br><span class="line">s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。</span><br><span class="line">s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）</span><br><span class="line">s.concat(s2)  //用于连接两个字符串</span><br><span class="line">s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</span><br><span class="line">s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。</span><br><span class="line">s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</span><br><span class="line">s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 </span><br><span class="line">s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">s.trim()  //用于去除字符串两端的空格，返回一个新字符串</span><br><span class="line">s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。</span><br><span class="line">s.toUpperCase()  //全部转为大写</span><br><span class="line">s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</span><br><span class="line">s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</span><br><span class="line">s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</span><br><span class="line">s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</span><br><span class="line">s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。</span><br><span class="line">3.5 Math对象</span><br><span class="line">（1）属性</span><br><span class="line">Math.E：常数e。  </span><br><span class="line">Math.LN2：2的自然对数。  </span><br><span class="line">Math.LN10：10的自然对数。  </span><br><span class="line">Math.LOG2E：以2为底的e的对数。  </span><br><span class="line">Math.LOG10E：以10为底的e的对数。  </span><br><span class="line">Math.PI：常数Pi。  </span><br><span class="line">Math.SQRT1_2：0.5的平方根。  </span><br><span class="line">Math.SQRT2：2的平方根。</span><br><span class="line">（2）数学方法</span><br><span class="line">Math.abs()：返回参数的绝对值  </span><br><span class="line">Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 </span><br><span class="line">Math.floor()：向下取整  </span><br><span class="line">Math.max(n,n1,...)：可接受多个参数，返回最大值  </span><br><span class="line">Math.min(n,n1,..)：可接受多个参数，返回最小值  </span><br><span class="line">Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 </span><br><span class="line">Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。  </span><br><span class="line">Math.log()：返回以e为底的自然对数值。</span><br><span class="line">Math.exp()：返回e的指数，也就是常数e的参数次方。</span><br><span class="line">Math.round()：四舍五入  </span><br><span class="line">Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</span><br><span class="line">（3）三角函数方法</span><br><span class="line">Math.sin()：返回参数的正弦  </span><br><span class="line">Math.cos()：返回参数的余弦  </span><br><span class="line">Math.tan()：返回参数的正切  </span><br><span class="line">Math.asin()：返回参数的反正弦（弧度值）  </span><br><span class="line">Math.acos()：返回参数的反余弦（弧度值）  </span><br><span class="line">Math.atan()：返回参数的反正切（弧度值）</span><br><span class="line">3.6 JSON对象</span><br><span class="line">（1）方法</span><br><span class="line">JSON.stringify()   </span><br><span class="line">//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。</span><br><span class="line">//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</span><br><span class="line">//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</span><br><span class="line"></span><br><span class="line">JSON.parse()   //用于将JSON字符串转化成对象。</span><br><span class="line">3.7 console对象</span><br><span class="line">（1）方法</span><br><span class="line">console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</span><br><span class="line">console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。</span><br><span class="line">console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。</span><br><span class="line">console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；</span><br><span class="line">console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈</span><br><span class="line">console.table()  //可以将复合类型的数据转为表格显示。</span><br><span class="line">console.count()  //用于计数，输出它被调用了多少次。</span><br><span class="line">console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</span><br><span class="line">console.dirxml()  //用于以目录树的形式，显示DOM节点。</span><br><span class="line">console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</span><br><span class="line"></span><br><span class="line">//这两个方法用于计时，可以算出一个操作所花费的准确时间。</span><br><span class="line">console.time()</span><br><span class="line">console.timeEnd()</span><br><span class="line">//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。</span><br><span class="line"></span><br><span class="line">console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。</span><br><span class="line">console.profileEnd()  //用来结束正在运行的性能测试器。</span><br><span class="line"></span><br><span class="line">console.group()</span><br><span class="line">console.groupend()</span><br><span class="line">//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</span><br><span class="line">console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</span><br><span class="line"></span><br><span class="line">console.trace()  //显示当前执行的代码在堆栈中的调用路径。</span><br><span class="line">console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正则表达式：</span><br><span class="line">只允许输入汉字：onkeyup=&quot;value=value.replace(/[^\u4E00-\u9FA5]/g,&apos;&apos;)&quot; </span><br><span class="line">只允许输入数字：onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot;</span><br><span class="line">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure>
<h3 id="setTimeout-fn-0-的作用"><a href="#setTimeout-fn-0-的作用" class="headerlink" title="setTimeout(fn, 0) 的作用"></a>setTimeout(fn, 0) 的作用</h3><blockquote>
<p>setTimeout（0）单线程和异步队列<br>setTimeout和setInterval是JS内置的两个定时器，使用很简单，但这两个方法背后的原理却不简单。<br>我们知道，JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，<br>主线程会形成一个全局执行环境，执行环境采用栈的方式将待执行任务按顺序依次来执行。<br>但在浏览器中有一些任务是非常耗时的，比如http请求、定时器、事件回调等，为了保证其他任务的执行效率不被影响，<br>JS在执行环境中维护了一个异步队列(也叫工作线程)，并将这些任务放入队列中进行等待，这些任务的执行时机并不确定，<br>只有当主线程的任务执行完成以后，才会去检查异步队列中的任务是否需要开始执行。这就是为什么setTimeout(fn,0)<br> 始终要等到最后执行的原因。关于单线程和异步队列问题请参考：setTimeout（0）</p>
</blockquote>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(p, c) &#123;</span><br><span class="line">  var c = c || &#123;&#125;;</span><br><span class="line">  for (var i in p) &#123;</span><br><span class="line">    if (typeof p[i] === &apos;object&apos;) &#123;</span><br><span class="line">      c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class="line">      deepCopy(p[i], c[i]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="POST和GET的区别，HTTP状态码"><a href="#POST和GET的区别，HTTP状态码" class="headerlink" title="POST和GET的区别，HTTP状态码"></a>POST和GET的区别，HTTP状态码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST和GET的区别</span><br><span class="line">GET在浏览器回退时是无害的，而POST会再次提交请求</span><br><span class="line">GET产生的URL地址可以被收藏，而POST不可以</span><br><span class="line">GET请求会被浏览器主动缓存，而POST不会，除非手动设置</span><br><span class="line">GET请求只能进行URL编码，而POST支持多种编码方式</span><br><span class="line">GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</span><br><span class="line">GET请求在URL中传送的参数是有长度限制的，而POST没有长度限制</span><br><span class="line">对参数的数据类型，GET只能请求ASCII字符，而POST没有限制</span><br><span class="line">GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传敏感信息</span><br><span class="line">GET参数通过URL传递，POST放在Request body中</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP状态码</span><br><span class="line">1XX：指示信息-表示请求已接受，继续处理</span><br><span class="line">2XX：成功-表示请求已被成功接收200 OK ：客户端请求成功</span><br><span class="line">206 Partial Content：客户发送一个带有Range头的GET请求，服务器完成了它 播放视频和音频</span><br><span class="line">3XX：重定向-要完成请求必须进行更进一步的操作301 Move Permanently：所请求的页面已经转移至新的URL</span><br><span class="line">302 Found：所请求的页面已经临时转移到新的URL</span><br><span class="line">304 Not Modified：客户端有缓冲的文档并发出一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用</span><br><span class="line">4XX：客户端错误-请求有语法错误或请求无法实现400 Bad Request：客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class="line">403 Forbidden：对被请求页面的访问被禁止</span><br><span class="line">404 Not Found：请求资源不存在</span><br><span class="line">5XX：服务错误-服务器未能实现合法的请求500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</span><br><span class="line">503 Server Unavailable：请求未完成，服务器临时过载或当机，一段事件后恢复正常</span><br></pre></td></tr></table></figure>
<blockquote>
<p>301与302：二者都是进行重定向，前者为永久重定向，后者为临时重定向。301，302对用户来说没有区别，他们看到效果只是一个跳转，浏览器中旧的URL变成了新的URL。实际工作中，当我们的前一个域名被永久性停止使用，并且不希望用户还能访问以前的域名时，我们会用到301。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">301—永久移动。被请求的资源已被永久移动位置； 【永久重定向】</span><br><span class="line">302—请求的资源现在临时从不同的 URI 响应请求；  【临时重定向】</span><br><span class="line">305—使用代理。被请求的资源必须通过指定的代理才能被访问； </span><br><span class="line">307—临时跳转。被请求的资源在临时从不同的URL响应请求； </span><br><span class="line">400—错误请求； </span><br><span class="line">402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付； </span><br><span class="line">403—禁止访问。服务器已经理解请求，但是拒绝执行它； </span><br><span class="line">404—找不到对象。请求失败，资源不存在； </span><br><span class="line">406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体； </span><br><span class="line">408—请求超时； </span><br><span class="line">409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成； </span><br><span class="line">410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址； </span><br><span class="line">413—响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。 </span><br><span class="line">417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足； </span><br><span class="line">418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现； </span><br><span class="line">420—方法失效。 </span><br><span class="line">422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应； </span><br><span class="line">500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理；</span><br></pre></td></tr></table></figure>
<h3 id="JS返回所有子节点对象childNodes"><a href="#JS返回所有子节点对象childNodes" class="headerlink" title="JS返回所有子节点对象childNodes"></a>JS返回所有子节点对象childNodes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mylist = document.getElementById(&apos;myid&apos;);</span><br><span class="line">for(var i=0,i&lt;mylist.childNodes.length;i++)&#123;</span><br><span class="line">console.log(mylist.childNodes[i]);</span><br><span class="line">&#125;</span><br><span class="line">firstChild返回第一个子节点</span><br><span class="line">lastChild返回最后一个子节点</span><br><span class="line">parentNode返回父节点对象</span><br><span class="line">nextSibling返回下一个兄弟节点对象</span><br><span class="line">previousSibling返回前一个兄弟节点对象</span><br><span class="line">nodeName返回节点的HTML标记名称</span><br></pre></td></tr></table></figure>
<h3 id="insertBefore-插入节点（父节点内容的最前面）"><a href="#insertBefore-插入节点（父节点内容的最前面）" class="headerlink" title="insertBefore()插入节点（父节点内容的最前面）"></a>insertBefore()插入节点（父节点内容的最前面）</h3><p>注意：insertBefore()有两个参数，第一个是插入的节点，第二个是插入的位置</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = document.getElementById(&apos;myList&apos;);</span><br><span class="line">list.insertBefore(newItem,list.childNodes[1]);</span><br><span class="line">//插入新节点newItem到list的第二个子节点</span><br></pre></td></tr></table></figure></p>
<h3 id="Element-matches-精确匹配"><a href="#Element-matches-精确匹配" class="headerlink" title="Element.matches 精确匹配"></a>Element.matches 精确匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;list&apos;).addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  var event = e || window.event;</span><br><span class="line">  var target = event.target || event.srcElement;</span><br><span class="line">  if (target.matches(&apos;li.class-1&apos;)) &#123;</span><br><span class="line">    console.log(&apos;the content is: &apos;, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="移动端touch事件-区分webkit-和-winphone"><a href="#移动端touch事件-区分webkit-和-winphone" class="headerlink" title="移动端touch事件(区分webkit 和 winphone)"></a>移动端touch事件(区分webkit 和 winphone)</h3><blockquote>
<p>当用户手指放在移动设备在屏幕上滑动会触发的touch事件,以下支持webkit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指</span><br><span class="line">touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动</span><br><span class="line">touchend——当手指离开屏幕时触发</span><br><span class="line">touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用TouchEvent</span><br><span class="line">touches：屏幕上所有手指的信息</span><br><span class="line">targetTouches：手指在目标区域的手指信息</span><br><span class="line">changedTouches：最近一次触发该事件的手指信息</span><br><span class="line">touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息参数信息(changedTouches[0])</span><br><span class="line">clientX、clientY在显示区的坐标</span><br><span class="line">target：当前元素</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="全局错误监控"><a href="#全局错误监控" class="headerlink" title="全局错误监控"></a>全局错误监控</h3><p>监听window上的error事件，过滤事件代理的error。</p>
<h3 id="手动触发一个dom事件，需要3步，如果你对document-createEvent-�不是很熟悉，可以点击查看。"><a href="#手动触发一个dom事件，需要3步，如果你对document-createEvent-�不是很熟悉，可以点击查看。" class="headerlink" title="手动触发一个dom事件，需要3步，如果你对document.createEvent,�不是很熟悉，可以点击查看。"></a>手动触发一个dom事件，需要3步，如果你对document.createEvent,�不是很熟悉，可以点击查看。</h3><p>创建一个事件对象 document.createEvent(event)<br>初始化事件对象 event.initEvent(type, bubbles, true)<br>分发事件 dom.dispatchEvent(event)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Object.preventExtensions(obj)  让一个对象变的不可扩展，也就是永远不能再添加新的属性。</span><br><span class="line">Object.isExtensible(obj) 判断一个对象是否是可扩展的</span><br><span class="line">Object.seal(obj)让一个对象密封(只能读写 不能新增)</span><br><span class="line">Object.isSealed(obj)判断一个对象是否密封</span><br><span class="line">Object.isFrozen(arr)  让一个对象被冻结(只能读)</span><br><span class="line">Object.isFrozen(obj)：判断一个对象是否被冻结</span><br><span class="line">Object.keys(obj) 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组</span><br><span class="line">Object.getOwnPropertyNames(obj)：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组</span><br><span class="line">Object.is(value1, value2)：判断两个值是否是同一个值,Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</span><br><span class="line">Object.create(proto [, propertiesObject ]) 是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个参数是对象的属性描述符，这个参数是可选的。</span><br><span class="line">Object.assign 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。【浅复制】</span><br><span class="line">//var copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">Object.defineProperty() 定义单个对象属性或方法(可以设置读写可枚举)</span><br><span class="line">Object.defineProperties() 定义多个对象属性或方法(可以设置读写可枚举)</span><br><span class="line"></span><br><span class="line">Object.assign() //浅拷贝，类似&#123;...obj1,...obj2&#125; 都是浅拷贝</span><br><span class="line">Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）</span><br><span class="line"></span><br><span class="line">var target = &#123; a: 1 &#125;;</span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br><span class="line"></span><br><span class="line">//如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</span><br><span class="line"></span><br><span class="line">Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br><span class="line"></span><br><span class="line">对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</span><br><span class="line">var target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;</span><br><span class="line">var source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line">Object.assign(target, source)</span><br><span class="line">// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line"></span><br><span class="line">停止jq中的ajax请求用abort()函数  </span><br><span class="line">  </span><br><span class="line">var currentAjax = null;  </span><br><span class="line">	functionstartAjax()&#123;  </span><br><span class="line">	    //方法就是将XHR对象指向currentAjax，再调用currentAjax的.abort()来中止请求  </span><br><span class="line">	    currentAjax = $.ajax(&#123;  </span><br><span class="line">	           type:&apos;POST&apos;,  </span><br><span class="line">	           beforeSend:function()&#123;&#125;,  </span><br><span class="line">	           url:&apos;test.php&apos;,  </span><br><span class="line">	           data:&apos;username=xxx&apos;,  </span><br><span class="line">	           dataType:&apos;JSON&apos;,  </span><br><span class="line">	           error:function()&#123;alert(&apos;error&apos;)&#125;,  </span><br><span class="line">	           success:function(data)&#123;alert(data)&#125;  </span><br><span class="line">	    &#125;);  </span><br><span class="line">	&#125;  </span><br><span class="line">	functionstopAjax()&#123;  </span><br><span class="line">	    //如若上一次AJAX请求未完成，则中止请求  </span><br><span class="line">	    if(currentAjax) &#123;currentAjax.abort();&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSONP 超时：</span><br><span class="line"></span><br><span class="line">  设置超时标志位flag=false，当超时后将flag=true;</span><br><span class="line">  异步加载JS文件并执行回调函数：</span><br><span class="line">  </span><br><span class="line">  function loadJS(src, callback)&#123;</span><br><span class="line">    var script = document.createElement(&apos;script&apos;);</span><br><span class="line">    var head = document.getElementsByTagName(&apos;head&apos;)[0];</span><br><span class="line">    var loaded;</span><br><span class="line">    script.src = src;</span><br><span class="line">    if(typeof callback === &apos;function&apos;)&#123;</span><br><span class="line">        script.onload = script.onreadystatechange = function()&#123;</span><br><span class="line">            if(!loaded &amp;&amp; (!script.readyState || /loaded|complete/.test(script.readyState)))&#123;</span><br><span class="line">                script.onload = script.onreadystatechange = null;</span><br><span class="line">                loaded = true;</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取元素的绝对位置"><a href="#获取元素的绝对位置" class="headerlink" title="获取元素的绝对位置"></a>获取元素的绝对位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getPosition(node) &#123;</span><br><span class="line">	var width = node.offsetWidth; //元素宽度</span><br><span class="line">	var height = node.offsetHeight; //元素高度</span><br><span class="line">	var left = node.offsetLeft; //获取元素相对于其根元素的left值var left</span><br><span class="line">	var top = node.offsetTop; //获取元素相对于其根元素的top值var top</span><br><span class="line">	current = node.offsetParent; // 取得元素的offsetParent</span><br><span class="line"></span><br><span class="line">	// 一直循环直到根元素　　</span><br><span class="line">	while(current != null) &#123;　　</span><br><span class="line">		left += current.offsetLeft;　　</span><br><span class="line">		top += current.offsetTop;　　</span><br><span class="line">		current = current.offsetParent;　　</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123;</span><br><span class="line">		&quot;width&quot;: width,</span><br><span class="line">		&quot;height&quot;: height,</span><br><span class="line">		&quot;left&quot;: left,</span><br><span class="line">		&quot;top&quot;: top</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动画结束时事件"><a href="#动画结束时事件" class="headerlink" title="动画结束时事件"></a>动画结束时事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">o.addEventListener(&quot;webkitAnimationEnd&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画结束&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">-webkit-animation动画有三个事件：</span><br><span class="line">开始事件: webkitAnimationStart</span><br><span class="line">结束事件:  webkitAnimationEnd</span><br><span class="line">重复运动事件: webkitAnimationIteration// 动画开始时事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o.addEventListener(&quot;webkitAnimationStart&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画开始&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 动画重复运动时事件</span><br><span class="line">o.addEventListener(&quot;webkitAnimationIteration&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画重复运动&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 动画结束时事件</span><br><span class="line">o.addEventListener(&quot;webkitAnimationEnd&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画结束&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="解决键盘弹出遮挡："><a href="#解决键盘弹出遮挡：" class="headerlink" title="解决键盘弹出遮挡："></a>解决键盘弹出遮挡：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 解决键盘弹出后挡表单的问题</span><br><span class="line">		window.addEventListener(&apos;resize&apos;, function() &#123;</span><br><span class="line">			if(</span><br><span class="line">				document.activeElement.tagName === &apos;INPUT&apos; ||</span><br><span class="line">				document.activeElement.tagName === &apos;TEXTAREA&apos;</span><br><span class="line">			) &#123;</span><br><span class="line">				window.setTimeout(function() &#123;</span><br><span class="line">					if(&apos;scrollIntoView&apos; in document.activeElement) &#123;</span><br><span class="line">						document.activeElement.scrollIntoView();</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						document.activeElement.scrollIntoViewIfNeeded();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, 0);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="单个for循环实现排序："><a href="#单个for循环实现排序：" class="headerlink" title="单个for循环实现排序："></a>单个for循环实现排序：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [12, 13, 65, 54, 86, 21, 37, 1, 95, 4];</span><br><span class="line">var l=a.length;</span><br><span class="line">		for(var i = 0; i &lt; l; i++) &#123;</span><br><span class="line">			if(a[i] &gt; a[i + 1]) &#123;</span><br><span class="line">				var tem = a[i];</span><br><span class="line">				a[i] = a[i + 1];</span><br><span class="line">				a[i + 1] = tem;</span><br><span class="line">			&#125;</span><br><span class="line">			if(i == l - 1) &#123;</span><br><span class="line">				i = -1;</span><br><span class="line">				l--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		console.log(a);</span><br></pre></td></tr></table></figure>
<h3 id="Object-assign实现"><a href="#Object-assign实现" class="headerlink" title="Object.assign实现:"></a>Object.assign实现:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">if (!Object.assign) &#123;</span><br><span class="line">    // 定义assign方法</span><br><span class="line">  Object.defineProperty(Object, &apos;assign&apos;, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">    value: function(target) &#123; // assign方法的第一个参数</span><br><span class="line">      &apos;use strict&apos;;</span><br><span class="line">      // 第一个参数为空，则抛错</span><br><span class="line">      if (target === undefined || target === null) &#123;</span><br><span class="line">        throw new TypeError(&apos;Cannot convert first argument to object&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var to = Object(target);</span><br><span class="line">      // 遍历剩余所有参数</span><br><span class="line">      for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        var nextSource = arguments[i];</span><br><span class="line">        // 参数为空，则跳过，继续下一个</span><br><span class="line">        if (nextSource === undefined || nextSource === null) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        nextSource = Object(nextSource);</span><br><span class="line"></span><br><span class="line">        // 获取改参数的所有key值，并遍历</span><br><span class="line">        var keysArray = Object.keys(nextSource);</span><br><span class="line">        for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) &#123;</span><br><span class="line">          var nextKey = keysArray[nextIndex];</span><br><span class="line">          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);</span><br><span class="line">          // 如果不为空且可枚举，则直接浅拷贝赋值</span><br><span class="line">          if (desc !== undefined &amp;&amp; desc.enumerable) &#123;</span><br><span class="line">            to[nextKey] = nextSource[nextKey];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript中巧用位运算"><a href="#JavaScript中巧用位运算" class="headerlink" title="JavaScript中巧用位运算"></a>JavaScript中巧用位运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">日常前端开发中我们很少用到位运算，容易让人遗忘，让我们一起回顾下一下js中的位运算。</span><br><span class="line">位运算详细说明查看JavaScript|MDN</span><br><span class="line">下面主要回顾一下一些常用的位运算的巧用。</span><br><span class="line">将十进制转化为二进制</span><br><span class="line">var number = 3;</span><br><span class="line">var result = number.toString(2);</span><br><span class="line"></span><br><span class="line">var result2 = 14..toString(2); // &quot;1110&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们使用位运算来代替Math.floor()来向下取整</span><br><span class="line">var data = 2.2352524535;</span><br><span class="line">var result = data | 0; // 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var re2 = ~~data; // 2</span><br></pre></td></tr></table></figure>
<h3 id="将颜色从RGA转换为Hex格式"><a href="#将颜色从RGA转换为Hex格式" class="headerlink" title="将颜色从RGA转换为Hex格式"></a>将颜色从RGA转换为Hex格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var color = &#123;r: 186, g: 218, b: 85&#125;;</span><br><span class="line"></span><br><span class="line">// RGB to HEX</span><br><span class="line">var rgb2hex = function(r, g, b) &#123;</span><br><span class="line">    return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).substr(1);</span><br><span class="line">&#125;</span><br><span class="line">rgb2hex(color.r, color.g, color.b);//&quot;#bada55&quot;</span><br></pre></td></tr></table></figure>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">/*========================常用函数========================*/</span><br><span class="line"></span><br><span class="line">/*时间格式化*/</span><br><span class="line">Date.prototype.Format = function (fmt) &#123;</span><br><span class="line">    var o = &#123;</span><br><span class="line">        &quot;M+&quot;: this.getMonth() + 1, /*月份*/</span><br><span class="line">        &quot;d+&quot;: this.getDate(), /*日*/</span><br><span class="line">        &quot;h+&quot;: this.getHours(), /*小时*/</span><br><span class="line">        &quot;m+&quot;: this.getMinutes(), /*分*/</span><br><span class="line">        &quot;s+&quot;: this.getSeconds(), /*秒*/</span><br><span class="line">        &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), /*季度*/</span><br><span class="line">        &quot;S&quot;: this.getMilliseconds() /*毫秒*/</span><br><span class="line">    &#125;;</span><br><span class="line">    if (/(y+)/.test(fmt))</span><br><span class="line">        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));</span><br><span class="line">    for (var k in o)</span><br><span class="line">        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))</span><br><span class="line">            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));</span><br><span class="line">    return fmt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*IE浏览器不支持date(time),所以用此方法转换*/</span><br><span class="line">function NewDate(fmt) &#123;</span><br><span class="line">    /*首先将日期分隔 ，获取到日期部分 和 时间部分*/</span><br><span class="line">    var day = fmt.split(&apos; &apos;);</span><br><span class="line">    /*获取日期部分的年月日*/</span><br><span class="line">    var days = day[0].split(&apos;-&apos;);</span><br><span class="line">    /*获取时间部分的 时分秒*/</span><br><span class="line">    var mi = day[day.length - 1].split(&apos;:&apos;);</span><br><span class="line">    /*获取当前date类型日期*/</span><br><span class="line">    var date = new Date();</span><br><span class="line">    /*给date赋值  年月日*/</span><br><span class="line">    date.setUTCFullYear(days[0], days[1] - 1, days[2]);</span><br><span class="line">    /*给date赋值 时分秒  首先转换utc时区 ：+8*/</span><br><span class="line">    date.setUTCHours(mi[0] - 8, mi[1], mi[2]);</span><br><span class="line">    return date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*为空判断*/</span><br><span class="line">function isEmpty(s) &#123;</span><br><span class="line">    switch (typeof(s)) &#123;</span><br><span class="line">        case &apos;string&apos;:</span><br><span class="line">            return !s.length;</span><br><span class="line">            break;</span><br><span class="line">        case &apos;array&apos;:</span><br><span class="line">        case &apos;object&apos;:</span><br><span class="line">            for (var i in s) return false;</span><br><span class="line">            return true;</span><br><span class="line">            break;</span><br><span class="line">        case &apos;undefined&apos;:</span><br><span class="line">            return true;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return !s;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*数字判断*/</span><br><span class="line">function isNumber(s) &#123;</span><br><span class="line">    return typeof(s) == &apos;number&apos; ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*整数判断*/</span><br><span class="line">function isInt(s) &#123;</span><br><span class="line">    var re = /^-?\d*$/;</span><br><span class="line">    return re.test(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*正整数判断*/</span><br><span class="line">function isUInt(s) &#123;</span><br><span class="line">    var re = /^\d*$/;</span><br><span class="line">    return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*小数判断*/</span><br><span class="line">function isDecimal(s, bit) &#123;</span><br><span class="line">    if (!arguments[1]) bit = -1;</span><br><span class="line">    if (bit == -1) &#123;</span><br><span class="line">        var re = /^-?\d*.?\d*$/;</span><br><span class="line">        return re.test(s);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var re = new RegExp(&apos;^-?\\d*.?\\d&#123;0,&apos; + bit + &apos;&#125;$&apos;);</span><br><span class="line">        return re.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*正小数判断*/</span><br><span class="line">function isUDecimal(s, bit) &#123;</span><br><span class="line">    if (!arguments[1]) bit = -1;</span><br><span class="line">    if (bit == -1) &#123;</span><br><span class="line">        var re = /^\d*.?\d*$/;</span><br><span class="line">        return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var re = new RegExp(&apos;^\\d*.?\\d&#123;0,&apos; + bit + &apos;&#125;$&apos;);</span><br><span class="line">        return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*字符串判断*/</span><br><span class="line">function isString(s) &#123;</span><br><span class="line">    return typeof(s) == &apos;string&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*========================/常用函数========================*/</span><br><span class="line"></span><br><span class="line">js onkeyup replace 自动替换</span><br><span class="line"></span><br><span class="line">检测浮点数 只能是整数或者小数 </span><br><span class="line">多余的就replace 掉 的表单验证</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function checkFloatNum(obj)</span><br><span class="line">&#123;</span><br><span class="line">    //先把非数字的都替换掉，除了数字和.</span><br><span class="line">    obj.value = obj.value.replace(/[^\d.]/g,&quot;&quot;);</span><br><span class="line">    //必须保证第一个为数字而不是.</span><br><span class="line">    obj.value = obj.value.replace(/^\./g,&quot;&quot;);</span><br><span class="line">    //保证只有出现一个.而没有多个.</span><br><span class="line">    obj.value = obj.value.replace(/\.&#123;2,&#125;/g,&quot;.&quot;);</span><br><span class="line">    //保证.只出现一次，而不能出现两次以上</span><br><span class="line">    obj.value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(function() &#123;</span><br><span class="line"></span><br><span class="line">	handleAddListener(&apos;load&apos;, getTiming)</span><br><span class="line"></span><br><span class="line">	function handleAddListener(type, fn) &#123;</span><br><span class="line">		if(window.addEventListener) &#123;</span><br><span class="line">			window.addEventListener(type, fn)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			window.attachEvent(&apos;on&apos; + type, fn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function getTiming() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			var time = performance.timing;</span><br><span class="line">			var timingObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">			var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;</span><br><span class="line"></span><br><span class="line">			if(loadTime &lt; 0) &#123;</span><br><span class="line">				setTimeout(function() &#123;</span><br><span class="line">					getTiming();</span><br><span class="line">				&#125;, 200);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000;</span><br><span class="line">			timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000;</span><br><span class="line">			timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000;</span><br><span class="line">			timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000;</span><br><span class="line">			timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000;</span><br><span class="line">			timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000;</span><br><span class="line">			timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000;</span><br><span class="line">			timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;</span><br><span class="line">			timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000;</span><br><span class="line">			timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]);</span><br><span class="line"></span><br><span class="line">			for(item in timingObj) &#123;</span><br><span class="line">				console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			console.log(performance.timing);</span><br><span class="line"></span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			console.log(timingObj)</span><br><span class="line">			console.log(performance.timing);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default class Cookie &#123;</span><br><span class="line">	//写cookies</span><br><span class="line">	static setCookie = (name, value) =&gt; &#123;</span><br><span class="line">		var Days = 30;</span><br><span class="line">		var exp = new Date();</span><br><span class="line">		exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000);</span><br><span class="line">		document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">	&#125;</span><br><span class="line">	//读取cookies </span><br><span class="line">	static getCookie = (name) =&gt; &#123;</span><br><span class="line">		var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;);</span><br><span class="line">		if(arr = document.cookie.match(reg))</span><br><span class="line">			return unescape(arr[2]);</span><br><span class="line">		else</span><br><span class="line">			return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//删除cookies </span><br><span class="line">	static delCookie = (name) =&gt; &#123;</span><br><span class="line">		var exp = new Date();</span><br><span class="line">		exp.setTime(exp.getTime() - 1);</span><br><span class="line">		var cval = getCookie(name);</span><br><span class="line">		if(cval != null)</span><br><span class="line">			document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    function jsonp(objects)&#123;</span><br><span class="line">        objects = objects || &#123;&#125;;</span><br><span class="line">        if(!objects.url || !objects.callback)&#123;</span><br><span class="line">            throw new Error(&apos;参数不合法&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建script标签并插入</span><br><span class="line">        var callbackName =  (&apos;jsonp_&apos; + Math.random()).replace(&quot;.&quot;, &quot;&quot;);//随机生成callbackName</span><br><span class="line"></span><br><span class="line">        var script = document.createElement(&apos;script&apos;);</span><br><span class="line">        var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line">        body.appendChild(script);</span><br><span class="line"></span><br><span class="line">        window[callbackName] = function (json) &#123;</span><br><span class="line">            body.removeChild(script);</span><br><span class="line">            clearTimeout(script.timer);</span><br><span class="line">            window[callbackName] = null;</span><br><span class="line">            objects.callback &amp;&amp; objects.callback(json);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //发出请求</span><br><span class="line">        script.src = objects.url + callbackName;</span><br><span class="line"></span><br><span class="line">        //响应时间</span><br><span class="line">        if(objects.time)&#123;</span><br><span class="line">            script.timer = setTimeout(function () &#123;</span><br><span class="line">                window[callbackName] = null;</span><br><span class="line">                body.removeChild(script);</span><br><span class="line">                objects.fail &amp;&amp; objects.fail(&apos;超时&apos;);</span><br><span class="line">            &#125;, objects.time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="js判断DOM是否包含另一个DOM"><a href="#js判断DOM是否包含另一个DOM" class="headerlink" title="js判断DOM是否包含另一个DOM"></a>js判断DOM是否包含另一个DOM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">			.first&#123;</span><br><span class="line">				width: 200px;</span><br><span class="line">				height: 200px;</span><br><span class="line">				background: red;</span><br><span class="line">			&#125;</span><br><span class="line">			.first-child&#123;</span><br><span class="line">				width: 100px;</span><br><span class="line">				height: 100px;</span><br><span class="line">				background: green;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div class=&quot;first&quot;&gt;</span><br><span class="line">			&lt;div class=&quot;first-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;div class=&quot;second&quot;&gt;</span><br><span class="line">			&lt;div class=&quot;second-child&quot;&gt;</span><br><span class="line">				&lt;div class=&quot;second-child-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			var first = document.querySelector(&apos;.first&apos;);</span><br><span class="line">			var firstchild = document.querySelector(&apos;.first-child&apos;);</span><br><span class="line">			</span><br><span class="line">			var second = document.querySelector(&apos;.second&apos;);</span><br><span class="line">			var secondchild = document.querySelector(&apos;.second-child&apos;);</span><br><span class="line">			var secondchildchild = document.querySelector(&apos;.second-child-child&apos;);</span><br><span class="line">			 </span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">			function isChildOf(child, parent) &#123;</span><br><span class="line">				var parentNode;</span><br><span class="line">				if(child &amp;&amp; parent) &#123;</span><br><span class="line">					parentNode = child.parentNode;</span><br><span class="line">					while(parentNode) &#123;</span><br><span class="line">						if(parent === parentNode) &#123;</span><br><span class="line">							return true;</span><br><span class="line">						&#125;</span><br><span class="line">						parentNode = parentNode.parentNode;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			console.log(isChildOf(firstchild, first));</span><br><span class="line">			console.log(isChildOf(secondchild, second));</span><br><span class="line">			console.log(isChildOf(secondchildchild, secondchild));</span><br><span class="line">			console.log(isChildOf(secondchildchild, second));</span><br><span class="line">			</span><br><span class="line">			console.log(isChildOf(secondchildchild, first));</span><br><span class="line">			</span><br><span class="line">			console.log(document.documentElement.contains(document.body));</span><br><span class="line">			console.log(second.contains(secondchildchild));</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="回到顶部带动画"><a href="#回到顶部带动画" class="headerlink" title="回到顶部带动画"></a>回到顶部带动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">/* 滚动条动画：</span><br><span class="line"> * 移动端:document.body.scrollTop</span><br><span class="line">   PC端：document.documentElement.scrollTop</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //使用:gotoTop(400,callBack)</span><br><span class="line">   gotoTop(durations,  callback = undefined) &#123;</span><br><span class="line">      const doc = document.documentElement</span><br><span class="line">      const scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)</span><br><span class="line">      for (var i = 60; i &gt;= 0; i--) &#123;</span><br><span class="line">        setTimeout((i =&gt; &#123;</span><br><span class="line">          return () =&gt; &#123;</span><br><span class="line">            doc.scrollTop = scrollTop * i / 60</span><br><span class="line">            if (i === 0 &amp;&amp; typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">              callback()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i), durations * (1 - i / 60))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"> * */</span><br><span class="line">var requestAnimFrame = (function() &#123;</span><br><span class="line">	return window.requestAnimationFrame ||</span><br><span class="line">		window.webkitRequestAnimationFrame ||</span><br><span class="line">		window.mozRequestAnimationFrame ||</span><br><span class="line">		function(callback) &#123;</span><br><span class="line">			window.setTimeout(callback, 1000 / 60);</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var cancelAnimationFrame = (function() &#123;</span><br><span class="line">	return window.cancelAnimationFrame ||</span><br><span class="line">		window.webkitCancelAnimationFrame ||</span><br><span class="line">		window.mozCancelAnimationFrame ||</span><br><span class="line">		window.oCancelAnimationFrame ||</span><br><span class="line">		function(id) &#123;</span><br><span class="line">			window.clearTimeout(id)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// Tween中的方法接受4个参数t,b,c,d 。t为初始时间 b、c、d三个参数（即初始值，变化量，持续时间）。返回值为当前位置</span><br><span class="line">// t =&gt; time(初始记步次数)  b =&gt; begin(初始位置)   c =&gt; change(变化量)   d =&gt; duration(持续次数)</span><br><span class="line"></span><br><span class="line">var tween = &#123;</span><br><span class="line">	linear: function(t, b, c, d) &#123;</span><br><span class="line">		return c * t / d + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeIn: function(t, b, c, d) &#123;</span><br><span class="line">		return c * (t /= d) * t + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	strongEaseIn: function(t, b, c, d) &#123;</span><br><span class="line">		return c * (t /= d) * t * t * t * t + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	strongEaseOut: function(t, b, c, d) &#123;</span><br><span class="line">		return c * ((t = t / d - 1) * t * t * t * t + 1) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	sineaseIn: function(t, b, c, d) &#123;</span><br><span class="line">		return c * (t /= d) * t * t + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	sineaseOut: function(t, b, c, d) &#123;</span><br><span class="line">		return c * ((t = t / d - 1) * t * t + 1) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeInOutQuad: function(t, b, c, d) &#123;</span><br><span class="line">		t /= d / 2;</span><br><span class="line">		if(t &lt; 1) return c / 2 * t * t + b;</span><br><span class="line">		t--;</span><br><span class="line">		return -c / 2 * (t * (t - 2) - 1) + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var myReq; </span><br><span class="line">export var animatedScrollTo = function(element, to, duration, callback, Bzr = &apos;linear&apos;) &#123;</span><br><span class="line">	var start = element.scrollTop,</span><br><span class="line">		change = to - start,</span><br><span class="line">		animationStart = +new Date();</span><br><span class="line">	var animating = true;</span><br><span class="line">	var lastpos = null;</span><br><span class="line"></span><br><span class="line">	var animateScroll = function() &#123;</span><br><span class="line">		if(!animating) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		myReq=requestAnimFrame(animateScroll);</span><br><span class="line">		var now = +new Date();</span><br><span class="line">		var val = Math.floor(tween[Bzr](now - animationStart, start, change, duration));</span><br><span class="line"></span><br><span class="line">		if(lastpos) &#123;</span><br><span class="line">			if(lastpos === element.scrollTop) &#123;</span><br><span class="line">				lastpos = val;</span><br><span class="line">				element.scrollTop = val;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				animating = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			lastpos = val;</span><br><span class="line">			element.scrollTop = val;</span><br><span class="line">		&#125;</span><br><span class="line">		if(now &gt; animationStart + duration) &#123;</span><br><span class="line">			element.scrollTop = to;</span><br><span class="line">			animating = false;</span><br><span class="line">			cancelAnimationFrame(myReq);   //清除定时器动画</span><br><span class="line">			callback&amp;&amp;callback();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	myReq=requestAnimFrame(animateScroll);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用js唤起Native下的App"><a href="#使用js唤起Native下的App" class="headerlink" title="使用js唤起Native下的App"></a>使用js唤起Native下的App</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 浏览器的相关信息</span><br><span class="line"> */</span><br><span class="line">var Browser = /** @class */ (function() &#123;</span><br><span class="line">	function Browser() &#123;&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 获取浏览器数据</span><br><span class="line">	 */</span><br><span class="line">	Browser.getBrowser = function() &#123;</span><br><span class="line">		var UA = navigator.userAgent || &apos;&apos;</span><br><span class="line">		var isAndroid = (function() &#123;</span><br><span class="line">			return UA.match(/Android/i) ? true : false</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isQQ = (function() &#123;</span><br><span class="line">			return /(iPad|iPhone|iPod).*? (IPad)?QQ\/([\d\.]+)/.test(UA) || /\bV1_AND_SQI?_([\d\.]+)(.*? QQ\/([\d\.]+))?/.test(UA)</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isIOS = (function() &#123;</span><br><span class="line">			return UA.match(/iPhone|iPad|iPod/i) ? true : false</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isSafari = (function() &#123;</span><br><span class="line">			return /iPhone|iPad|iPod\/([\w.]+).*(safari).*/i.test(UA)</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isWx = (function() &#123;</span><br><span class="line">			return UA.match(/micromessenger/i) ? true : false</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isWb = (function() &#123;</span><br><span class="line">			return UA.match(/weibo/i) ? true : false</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isAndroidChrome = (function() &#123;</span><br><span class="line">			return(UA.match(/Chrome\/([\d.]+)/) || UA.match(/CriOS\/([\d.]+)/)) &amp;&amp; isAndroid &amp;&amp; !isQQ</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isQZ = (function() &#123;</span><br><span class="line">			return UA.indexOf(&apos;Qzone/&apos;) !== -1</span><br><span class="line">		&#125;)()</span><br><span class="line">		var browser = &#123;</span><br><span class="line">			isAndroid: isAndroid,</span><br><span class="line">			isIOS: isIOS,</span><br><span class="line">			isSafari: isSafari,</span><br><span class="line">			isQQ: isQQ,</span><br><span class="line">			isWb: isWb,</span><br><span class="line">			isWx: isWx,</span><br><span class="line">			isQZ: isQZ,</span><br><span class="line">			isAndroidChrome: isAndroidChrome</span><br><span class="line">		&#125;</span><br><span class="line">		return browser</span><br><span class="line">	&#125;</span><br><span class="line">	return Browser</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * AppLink:H5唤起APP的所有方法</span><br><span class="line"> */</span><br><span class="line">var AppLink = /** @class */ (function() &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 类的contructor方法</span><br><span class="line">	 * @param config IAppLink类型的config文件</span><br><span class="line">	 */</span><br><span class="line">	function AppLink(config) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * UA</span><br><span class="line">		 */</span><br><span class="line">		this.UA = &#123;&#125;</span><br><span class="line">		/**</span><br><span class="line">		 * 传入的config数据，以接口约束</span><br><span class="line">		 */</span><br><span class="line">		this.config = &#123;&#125;</span><br><span class="line">		this.UA = navigator.userAgent || &apos;&apos;</span><br><span class="line">		this.config = config</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 跳转函数</span><br><span class="line">	 * @param url 链接</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.go = function(url) &#123;</span><br><span class="line">		window.location.href = url</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 检查是否唤起</span><br><span class="line">	 * @param cb 回调函数</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.checkOpen = function(cb) &#123;</span><br><span class="line">		var inter = null</span><br><span class="line">		var statue = false</span><br><span class="line">		var count = 0</span><br><span class="line">		inter = window.setInterval(function() &#123;</span><br><span class="line">			count++</span><br><span class="line">			statue = document.hidden || document.webkitHidden</span><br><span class="line">			if(statue || count &gt; 40) &#123;</span><br><span class="line">				cb(statue)</span><br><span class="line">				clearInterval(inter)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, 50)</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 外部调用的入口函数</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.open = function() &#123;</span><br><span class="line">		var _this = this</span><br><span class="line">		var browser = Browser.getBrowser()</span><br><span class="line">		var config = this.config</span><br><span class="line">		// 微信直接跳 应用宝</span><br><span class="line">		if(browser.isWx) &#123;</span><br><span class="line">			this.go(this.config.yyb)</span><br><span class="line">		&#125; else if(browser.isQQ) &#123;</span><br><span class="line">			if(browser.isIOS) &#123;</span><br><span class="line">				// 没有下载</span><br><span class="line">				this.checkOpen(function(isSuccess) &#123;</span><br><span class="line">					if(!isSuccess) &#123;</span><br><span class="line">						_this.go(_this.config.appstore)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			// iOS跳到AppStore</span><br><span class="line">			if(browser.isAndroid) &#123;</span><br><span class="line">				// 使用scheme唤起</span><br><span class="line">				this.tryCallApp(this.config.schema)</span><br><span class="line">				// 唤起失败 跳到应用宝</span><br><span class="line">				this.checkOpen(function(isSuccess) &#123;</span><br><span class="line">					if(!isSuccess) &#123;</span><br><span class="line">						_this.go(_this.config.yyb)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if(browser.isWb) &#123;</span><br><span class="line">			// 使用scheme唤起</span><br><span class="line">			this.tryCallApp(this.config.schema)</span><br><span class="line">			// 微博：唤起失败，也不跳转，会有引导功能</span><br><span class="line">		&#125; else if(browser.isSafari) &#123;</span><br><span class="line">			var version = this.getIOSVersion()</span><br><span class="line">			// iOS10以下不支持直接跳转到AppStore，跳到应用宝</span><br><span class="line">			if(version &lt; 10) &#123;</span><br><span class="line">				this.go(this.config.yyb)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				this.go(this.config.appstore)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 其他情况，直接跳应用宝</span><br><span class="line">			this.go(this.config.yyb)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 下载按钮的url地址</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.getDownloadUrl = function() &#123;</span><br><span class="line">		var browser = Browser.getBrowser()</span><br><span class="line">		var config = this.config</span><br><span class="line">		var url = &apos;&apos;</span><br><span class="line">		if(browser.isQQ) &#123;</span><br><span class="line">			if(browser.isIOS) &#123;</span><br><span class="line">				url = this.config.appstore</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				url = this.config.yyb</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if(browser.isSafari) &#123;</span><br><span class="line">			var version = this.getIOSVersion()</span><br><span class="line">			if(version &lt; 10) &#123;</span><br><span class="line">				url = this.config.yyb</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				url = this.config.appstore</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if(browser.isWb) &#123;</span><br><span class="line">			url = &apos;&apos;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			url = this.config.yyb</span><br><span class="line">		&#125;</span><br><span class="line">		return url</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 尝试唤起APP</span><br><span class="line">	 * @param scheme 唤起的scheme</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.tryCallApp = function(scheme) &#123;</span><br><span class="line">		var aLink = document.createElement(&apos;a&apos;),</span><br><span class="line">			body = document.body</span><br><span class="line">		aLink.href = scheme</span><br><span class="line">		body.appendChild(aLink)</span><br><span class="line">		aLink.click()</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 判断iOS版本</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.getIOSVersion = function() &#123;</span><br><span class="line">		var ver = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)</span><br><span class="line">		var version = parseInt(ver[1], 10)</span><br><span class="line">		return version</span><br><span class="line">	&#125;</span><br><span class="line">	return AppLink</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="获取CSS样式"><a href="#获取CSS样式" class="headerlink" title="获取CSS样式"></a>获取CSS样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getStyle(obj, attr) &#123;</span><br><span class="line">	if(obj.currentStyle) &#123;</span><br><span class="line">		return obj.currentStyle[attr]; //IE678</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return window.getComputedStyle(obj, null)[attr];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function rgbToRgba(rgbValue) &#123;</span><br><span class="line">	const rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);</span><br><span class="line">	return rgb ? `rgba($&#123;rgb[1]&#125;,1)` : rgbValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hexToRgba(hexValue) &#123;</span><br><span class="line">	const rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;</span><br><span class="line">	const hex = hexValue.replace(rgx, (m, r, g, b) =&gt; r + r + g + g + b + b);</span><br><span class="line">	const rgb = /^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i.exec(hex);</span><br><span class="line">	const r = parseInt(rgb[1], 16);</span><br><span class="line">	const g = parseInt(rgb[2], 16);</span><br><span class="line">	const b = parseInt(rgb[3], 16);</span><br><span class="line">	return `rgba($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;,1)`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hslToRgba(hslValue) &#123;</span><br><span class="line">	const hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);</span><br><span class="line">	const h = parseInt(hsl[1]) / 360;</span><br><span class="line">	const s = parseInt(hsl[2]) / 100;</span><br><span class="line">	const l = parseInt(hsl[3]) / 100;</span><br><span class="line">	const a = hsl[4] || 1;</span><br><span class="line"></span><br><span class="line">	function hue2rgb(p, q, t) &#123;</span><br><span class="line">		if(t &lt; 0) t += 1;</span><br><span class="line">		if(t &gt; 1) t -= 1;</span><br><span class="line">		if(t &lt; 1 / 6) return p + (q - p) * 6 * t;</span><br><span class="line">		if(t &lt; 1 / 2) return q;</span><br><span class="line">		if(t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	let r, g, b;</span><br><span class="line">	if(s == 0) &#123;</span><br><span class="line">		r = g = b = l;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;</span><br><span class="line">		const p = 2 * l - q;</span><br><span class="line">		r = hue2rgb(p, q, h + 1 / 3);</span><br><span class="line">		g = hue2rgb(p, q, h);</span><br><span class="line">		b = hue2rgb(p, q, h - 1 / 3);</span><br><span class="line">	&#125;</span><br><span class="line">	return `rgba($&#123;r * 255&#125;,$&#123;g * 255&#125;,$&#123;b * 255&#125;,$&#123;a&#125;)`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function colorToRgb(val) &#123;</span><br><span class="line">	if(is.rgb(val)) return rgbToRgba(val);</span><br><span class="line">	if(is.hex(val)) return hexToRgba(val);</span><br><span class="line">	if(is.hsl(val)) return hslToRgba(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="750rem"><a href="#750rem" class="headerlink" title="750rem"></a>750rem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function(doc, win) &#123;</span><br><span class="line">	var docEl = doc.documentElement,</span><br><span class="line">		resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,</span><br><span class="line">		recalc = function() &#123;</span><br><span class="line">			var clientWidth = docEl.clientWidth;</span><br><span class="line">			if(!clientWidth) return;</span><br><span class="line">			if(clientWidth &gt;= 750) &#123;</span><br><span class="line">				docEl.style.fontSize = &apos;100px&apos;;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				docEl.style.fontSize = 100 * (clientWidth / 750) + &apos;px&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	if(!doc.addEventListener) return;</span><br><span class="line">	win.addEventListener(resizeEvt, recalc, false);</span><br><span class="line">	doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure>
<h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static checkType = (str, type) =&gt; &#123;</span><br><span class="line">	switch(type) &#123;</span><br><span class="line">		case &apos;email&apos;:</span><br><span class="line">			return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);</span><br><span class="line">		case &apos;phone&apos;:</span><br><span class="line">			return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str);</span><br><span class="line">		case &apos;tel&apos;:</span><br><span class="line">			return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str);</span><br><span class="line">		case &apos;number&apos;:</span><br><span class="line">			return /^[0-9]$/.test(str);</span><br><span class="line">		case &apos;english&apos;:</span><br><span class="line">			return /^[a-zA-Z]+$/.test(str);</span><br><span class="line">		case &apos;chinese&apos;:</span><br><span class="line">			return /^[\u4E00-\u9FA5]+$/.test(str);</span><br><span class="line">		case &apos;lower&apos;:</span><br><span class="line">			return /^[a-z]+$/.test(str);</span><br><span class="line">		case &apos;upper&apos;:</span><br><span class="line">			return /^[A-Z]+$/.test(str);</span><br><span class="line">		default:</span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="navigator帮助类"><a href="#navigator帮助类" class="headerlink" title="navigator帮助类"></a>navigator帮助类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">class navigatorUtil &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 头部信息</span><br><span class="line">	 * @type &#123;[type]&#125;</span><br><span class="line">	 */</span><br><span class="line">	static userAgent = navigator.userAgent;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 是否为ipad</span><br><span class="line">	 */</span><br><span class="line">	static isIPad = () =&gt; &#123;</span><br><span class="line">		return(navigatorUtil.userAgent.indexOf(&quot;iPad&quot;) &gt; -1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 是否为iphone</span><br><span class="line">	 * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line">	 * @return &#123;Boolean&#125;           [description]</span><br><span class="line">	 */</span><br><span class="line">	static isIPhone = () =&gt; &#123;</span><br><span class="line">		return(navigatorUtil.userAgent.indexOf(&quot;iPhone&quot;) &gt; -1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 是否为ios系统</span><br><span class="line">	 * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line">	 * @return &#123;Boolean&#125;           [description]</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	static isIOS = () =&gt; &#123;</span><br><span class="line">		return navigatorUtil.isIPad(navigatorUtil.userAgent) || navigatorUtil.isIPhone(</span><br><span class="line">			navigatorUtil.userAgent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 是否为Android系统</span><br><span class="line">	 * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line">	 * @return &#123;Boolean&#125;           [description]</span><br><span class="line">	 */</span><br><span class="line">	static isAndroid = () =&gt; &#123;</span><br><span class="line">		return(navigatorUtil.userAgent.indexOf(&quot;Android&quot;) &gt; -1) ||</span><br><span class="line">			(navigatorUtil.userAgent.indexOf(&quot;Linux&quot;) &gt; -1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 判断是否为微信</span><br><span class="line">	 */</span><br><span class="line">	static isWeixin = () =&gt; &#123;</span><br><span class="line">		return(navigatorUtil.userAgent.indexOf(&quot;MicroMessenger&quot;) &gt; -1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @desc 获取浏览器类型和版本</span><br><span class="line">	 * @return &#123;String&#125; </span><br><span class="line">	 */</span><br><span class="line">	static getExplore = () =&gt; &#123;</span><br><span class="line">		var sys = &#123;&#125;,</span><br><span class="line">			ua = navigator.userAgent.toLowerCase(),</span><br><span class="line">			s;</span><br><span class="line">		(s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:</span><br><span class="line">			(s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :</span><br><span class="line">			(s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :</span><br><span class="line">			(s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :</span><br><span class="line">			(s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :</span><br><span class="line">			(s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :</span><br><span class="line">			(s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;</span><br><span class="line">		// 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie)</span><br><span class="line">		if(sys.edge) return(&apos;EDGE: &apos; + sys.edge)</span><br><span class="line">		if(sys.firefox) return(&apos;Firefox: &apos; + sys.firefox)</span><br><span class="line">		if(sys.chrome) return(&apos;Chrome: &apos; + sys.chrome)</span><br><span class="line">		if(sys.opera) return(&apos;Opera: &apos; + sys.opera)</span><br><span class="line">		if(sys.safari) return(&apos;Safari: &apos; + sys.safari)</span><br><span class="line">		return &apos;Unkonwn&apos;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @desc 获取操作系统类型</span><br><span class="line">	 * @return &#123;String&#125; </span><br><span class="line">	 */</span><br><span class="line">	static getOS = () =&gt; &#123;</span><br><span class="line">		var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;;</span><br><span class="line">		var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;;</span><br><span class="line">		var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;;</span><br><span class="line"></span><br><span class="line">		if(/mac/i.test(appVersion)) return &apos;MacOSX&apos;</span><br><span class="line">		if(/win/i.test(appVersion)) return &apos;windows&apos;</span><br><span class="line">		if(/linux/i.test(appVersion)) return &apos;linux&apos;</span><br><span class="line">		if(/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos;</span><br><span class="line">		if(/android/i.test(userAgent)) return &apos;android&apos;</span><br><span class="line">		if(/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//进入全屏模式,  判断各种浏览器，找到正确的方法</span><br><span class="line">	static launchFullScreen = (element) =&gt; &#123;</span><br><span class="line">		if(element.requestFullscreen) &#123;</span><br><span class="line">			element.requestFullscreen();</span><br><span class="line">		&#125; else if(element.mozRequestFullScreen) &#123;</span><br><span class="line">			element.mozRequestFullScreen();</span><br><span class="line">		&#125; else if(element.webkitRequestFullscreen) &#123;</span><br><span class="line">			element.webkitRequestFullscreen();</span><br><span class="line">		&#125; else if(element.msRequestFullscreen) &#123;</span><br><span class="line">			element.msRequestFullscreen();</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	//退出全屏模式</span><br><span class="line">	static exitFullScreen = () =&gt; &#123;</span><br><span class="line">		if(document.exitFullscreen) &#123;</span><br><span class="line">			document.exitFullscreen();</span><br><span class="line">		&#125; else if(document.mozCancelFullScreen) &#123;</span><br><span class="line">			document.mozCancelFullScreen();</span><br><span class="line">		&#125; else if(document.webkitExitFullscreen) &#123;</span><br><span class="line">			document.webkitExitFullscreen();</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">function Promise(task) &#123;</span><br><span class="line">	let self = this; //缓存this</span><br><span class="line">	self.status = &apos;pending&apos;; //默认状态为pending</span><br><span class="line">	self.value = undefined; //存放着此promise的结果</span><br><span class="line">	self.onResolvedCallbacks = []; //存放着所有成功的回调函数</span><br><span class="line">	self.onRejectedCallbacks = []; //存放着所有的失败的回调函数</span><br><span class="line"></span><br><span class="line">	// 调用resolve方法可以把promise状态变成成功态</span><br><span class="line">	function resolve(value) &#123;</span><br><span class="line">		if(value instanceof Promise) &#123;</span><br><span class="line">			return value.then(resolve, reject)</span><br><span class="line">		&#125;</span><br><span class="line">		setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line">			// 如果当前状态是初始态（pending），则转成成功态</span><br><span class="line">			// 此处这个写判断的原因是因为resolved和rejected两个状态只能由pending转化而来，两者不能相互转化</span><br><span class="line">			if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">				self.value = value;</span><br><span class="line">				self.status = &apos;resolved&apos;;</span><br><span class="line">				self.onResolvedCallbacks.forEach(item =&gt; item(self.value));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 调用reject方法可以把当前的promise状态变成失败态</span><br><span class="line">	function reject(value) &#123;</span><br><span class="line">		setTimeout(function() &#123;</span><br><span class="line">			if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">				self.value = value;</span><br><span class="line">				self.status = &apos;rejected&apos;;</span><br><span class="line">				self.onRejectedCallbacks.forEach(item =&gt; item(value));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 立即执行传入的任务</span><br><span class="line">	try &#123;</span><br><span class="line">		task(resolve, reject);</span><br><span class="line">	&#125; catch(e) &#123;</span><br><span class="line">		reject(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * resolvePromise函数的目的是与原生Promise相兼容，可以互相调用</span><br><span class="line"> */</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">	// 将返回的promise不停的调用执行，直到失败或者返回一个普通的数据类型</span><br><span class="line">	if(promise2 === x) &#123;</span><br><span class="line">		return reject(new TypeError(&apos;循环引用&apos;));</span><br><span class="line">	&#125;</span><br><span class="line">	let then, called;</span><br><span class="line"></span><br><span class="line">	if(x != null &amp;&amp; ((typeof x == &apos;object&apos; || isFunction(x)))) &#123;</span><br><span class="line">		// promise</span><br><span class="line">		try &#123;</span><br><span class="line">			then = x.then;</span><br><span class="line">			if(isFunction(then)) &#123;</span><br><span class="line">				then.call(x, function(value) &#123;</span><br><span class="line">					if(called) return;</span><br><span class="line">					called = true;</span><br><span class="line">					resolvePromise(promise2, value, resolve, reject);</span><br><span class="line">				&#125;, function(reason) &#123;</span><br><span class="line">					if(called) return;</span><br><span class="line">					called = true;</span><br><span class="line">					reject(reason);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				resolve(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			if(called) return;</span><br><span class="line">			called = true;</span><br><span class="line">			reject(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		resolve(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * onFulfilled成功的回调，onReject失败的回调</span><br><span class="line"> */</span><br><span class="line">Promise.prototype.then = function(onFulfilled, onRejected) &#123;</span><br><span class="line">	let self = this;</span><br><span class="line">	// 当调用时没有写函数给它一个默认函数值</span><br><span class="line">	onFulfilled = isFunction(onFulfilled) ? onFulfilled : function(value) &#123;</span><br><span class="line">		return value</span><br><span class="line">	&#125;;</span><br><span class="line">	onRejected = isFunction(onRejected) ? onRejected : function(value) &#123;</span><br><span class="line">		throw value</span><br><span class="line">	&#125;;</span><br><span class="line">	let promise2;</span><br><span class="line">	if(self.status == &apos;resolved&apos;) &#123;</span><br><span class="line">		promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">			setTimeout(function() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					let x = onFulfilled(self.value);</span><br><span class="line">					resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">				&#125; catch(e) &#123;</span><br><span class="line">					reject(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(self.status == &apos;rejected&apos;) &#123;</span><br><span class="line">		promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">			setTimeout(function() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					let x = onRejected(self.value);</span><br><span class="line">					resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">				&#125; catch(e) &#123;</span><br><span class="line">					reject(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">		promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">			self.onResolvedCallbacks.push(function(value) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					let x = onFulfilled(value);</span><br><span class="line">					resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">				&#125; catch(e) &#123;</span><br><span class="line">					reject(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			self.onRejectedCallbacks.push(function(value) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					let x = onRejected(value);</span><br><span class="line">					resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">				&#125; catch(e) &#123;</span><br><span class="line">					reject(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	return promise2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * catch实际上是then的一个简写,成功回调传空值即可</span><br><span class="line"> */</span><br><span class="line">Promise.prototype.catch = function(onRejected) &#123;</span><br><span class="line">	return this.then(null, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Promise.reject(error)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。</span><br><span class="line"> */</span><br><span class="line">Promise.resolve = function(value) &#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		if(typeof value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; isFunction(value.then)) &#123;</span><br><span class="line">			value.then();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			resolve(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.reject = function(reason) &#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		reject(reason);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * all方法，可以传入多个promise，全部执行完后会将结果以数组的方式返回，如果有一个失败就返回失败</span><br><span class="line"> */</span><br><span class="line">Promise.all = function(promises) &#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		let result = []; // all方法最终返回的结果</span><br><span class="line">		let count = 0; // 完成的数量</span><br><span class="line">		for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">			promises[i].then(function(data) &#123;</span><br><span class="line">				result[i] = data;</span><br><span class="line">				if(++count == promises.length) &#123;</span><br><span class="line">					resolve(result);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, function(err) &#123;</span><br><span class="line">				reject(err);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * race方法，可以传入多个promise，返回的是第一个执行完的resolve的结果，如果有一个失败就返回失败</span><br><span class="line"> */</span><br><span class="line">Promise.race = function(promises) &#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">			promises[i].then(function(data) &#123;</span><br><span class="line">				resolve(data);</span><br><span class="line">			&#125;, function(err) &#123;</span><br><span class="line">				reject(err);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = function() &#123;</span><br><span class="line">	var defer = &#123;&#125;;</span><br><span class="line">	defer.promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">		defer.resolve = resolve;</span><br><span class="line">		defer.reject = reject;</span><br><span class="line">	&#125;)</span><br><span class="line">	return defer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一些会多次使用的复用功能函数</span><br><span class="line"> */</span><br><span class="line">function isFunction(obj) &#123;</span><br><span class="line">	return typeof obj === &quot;function&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最后可以通过以下命令安装一个promises测试插件，用插件来测试自己实现的promise符不符合规范</span><br><span class="line"> * npm(cnpm) i -g promises-aplus-tests</span><br><span class="line"> * promises-aplus-tests Promise.js</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = Promise;</span><br></pre></td></tr></table></figure>
<h3 id="ES6-promise"><a href="#ES6-promise" class="headerlink" title="ES6 promise"></a>ES6 promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">class es6Promise &#123;</span><br><span class="line">	constructor(task) &#123;</span><br><span class="line">		let self = this; //缓存this</span><br><span class="line">		self.status = &apos;pending&apos;; //默认状态为pending</span><br><span class="line">		self.value = undefined; //存放着此promise的结果</span><br><span class="line">		self.onResolvedCallbacks = []; //存放着所有成功的回调函数</span><br><span class="line">		self.onRejectedCallbacks = []; //存放着所有的失败的回调函数</span><br><span class="line"></span><br><span class="line">		// 调用resolve方法可以把promise状态变成成功态</span><br><span class="line">		function resolve(value) &#123;</span><br><span class="line">			if(value instanceof Promise) &#123;</span><br><span class="line">				return value.then(resolve, reject)</span><br><span class="line">			&#125;</span><br><span class="line">			setTimeout(() =&gt; &#123; // 异步执行所有的回调函数</span><br><span class="line">				// 如果当前状态是初始态（pending），则转成成功态</span><br><span class="line">				// 此处这个写判断的原因是因为resolved和rejected两个状态只能由pending转化而来，两者不能相互转化</span><br><span class="line">				if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">					self.value = value;</span><br><span class="line">					self.status = &apos;resolved&apos;;</span><br><span class="line">					self.onResolvedCallbacks.forEach(item =&gt; item(self.value));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 调用reject方法可以把当前的promise状态变成失败态</span><br><span class="line">		function reject(value) &#123;</span><br><span class="line">			setTimeout(() =&gt; &#123;</span><br><span class="line">				if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">					self.value = value;</span><br><span class="line">					self.status = &apos;rejected&apos;;</span><br><span class="line">					self.onRejectedCallbacks.forEach(item =&gt; item(value));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 立即执行传入的任务</span><br><span class="line">		try &#123;</span><br><span class="line">			task(resolve, reject);</span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			reject(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * onFulfilled成功的回调，onReject失败的回调</span><br><span class="line">	 * 原型链方法</span><br><span class="line">	 */</span><br><span class="line">	then(onFulfilled, onRejected) &#123;</span><br><span class="line">		let self = this;</span><br><span class="line">		// 当调用时没有写函数给它一个默认函数值</span><br><span class="line">		onFulfilled = isFunction(onFulfilled) ? onFulfilled : value =&gt; value;</span><br><span class="line">		onRejected = isFunction(onRejected) ? onRejected : value =&gt; &#123;</span><br><span class="line">			throw value</span><br><span class="line">		&#125;;</span><br><span class="line">		let promise2;</span><br><span class="line">		if(self.status == &apos;resolved&apos;) &#123;</span><br><span class="line">			promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">				setTimeout(() =&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						let x = onFulfilled(self.value);</span><br><span class="line">						resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">					&#125; catch(e) &#123;</span><br><span class="line">						reject(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(self.status == &apos;rejected&apos;) &#123;</span><br><span class="line">			promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">				setTimeout(() =&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						let x = onRejected(self.value);</span><br><span class="line">						resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">					&#125; catch(e) &#123;</span><br><span class="line">						reject(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">			promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">				self.onResolvedCallbacks.push(value =&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						let x = onFulfilled(value);</span><br><span class="line">						resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">					&#125; catch(e) &#123;</span><br><span class="line">						reject(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				self.onRejectedCallbacks.push(value =&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						let x = onRejected(value);</span><br><span class="line">						resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">					&#125; catch(e) &#123;</span><br><span class="line">						reject(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		return promise2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * catch实际上是then的一个简写,成功回调传空值即可</span><br><span class="line">	 * 原型链方法</span><br><span class="line">	 */</span><br><span class="line">	catch(onRejected) &#123;</span><br><span class="line">		return this.then(null, onRejected);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Promise.reject(err)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。</span><br><span class="line">	 * 静态方法为类自己的方法，不在原型链上</span><br><span class="line">	 */</span><br><span class="line">	static resolve(value) &#123;</span><br><span class="line">		return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			if(typeof value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; isFunction(value.then)) &#123;</span><br><span class="line">				value.then();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				resolve(value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static reject(err) &#123;</span><br><span class="line">		return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			reject(err);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * all方法，可以传入多个promise，全部执行完后会将结果以数组的方式返回，如果有一个失败就返回失败</span><br><span class="line">	 * 静态方法为类自己的方法，不在原型链上</span><br><span class="line">	 */</span><br><span class="line">	static all(promises) &#123;</span><br><span class="line">		return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			let result = []; // all方法最终返回的结果</span><br><span class="line">			let count = 0; // 完成的数量</span><br><span class="line">			for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">				promises[i].then(data =&gt; &#123;</span><br><span class="line">					result[i] = data;</span><br><span class="line">					if(++count == promises.length) &#123;</span><br><span class="line">						resolve(result);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, err =&gt; &#123;</span><br><span class="line">					reject(err);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * race方法，可以传入多个promise，返回的是第一个执行完的resolve的结果，如果有一个失败就返回失败</span><br><span class="line">	 *  静态方法为类自己的方法，不在原型链上</span><br><span class="line">	 */</span><br><span class="line">	static race(promises) &#123;</span><br><span class="line">		return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">				promises[i].then(data =&gt; &#123;</span><br><span class="line">					resolve(data);</span><br><span class="line">				&#125;, err =&gt; &#123;</span><br><span class="line">					reject(err);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * resolvePromise函数的目的是与原生Promise相兼容，可以互相调用</span><br><span class="line"> */</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">	// 将返回的promise不停的调用执行，直到失败或者返回一个普通的数据类型</span><br><span class="line">	if(promise2 === x) &#123;</span><br><span class="line">		return reject(new TypeError(&apos;循环引用&apos;));</span><br><span class="line">	&#125;</span><br><span class="line">	let then;</span><br><span class="line">	let called;</span><br><span class="line"></span><br><span class="line">	if(x != null &amp;&amp; ((typeof x == &apos;object&apos; || isFunction(x)))) &#123;</span><br><span class="line">		// promise</span><br><span class="line">		try &#123;</span><br><span class="line">			then = x.then;</span><br><span class="line">			if(isFunction(then)) &#123;</span><br><span class="line">				then.call(x, value =&gt; &#123;</span><br><span class="line">					if(called) return;</span><br><span class="line">					called = true;</span><br><span class="line">					resolvePromise(promise2, value, resolve, reject);</span><br><span class="line">				&#125;, reason =&gt; &#123;</span><br><span class="line">					if(called) return;</span><br><span class="line">					called = true;</span><br><span class="line">					reject(reason);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				resolve(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			if(called) return;</span><br><span class="line">			called = true;</span><br><span class="line">			reject(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		resolve(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = () =&gt; &#123;</span><br><span class="line">	const defer = &#123;&#125;;</span><br><span class="line">	defer.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		defer.resolve = resolve;</span><br><span class="line">		defer.reject = reject;</span><br><span class="line">	&#125;)</span><br><span class="line">	return defer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一些会多次使用的复用功能函数</span><br><span class="line"> */</span><br><span class="line">function isFunction(obj) &#123;</span><br><span class="line">	return typeof obj === &quot;function&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最后可以通过以下命令安装一个promises测试插件，用插件来测试自己实现的promise符不符合规范</span><br><span class="line"> * npm(cnpm) i -g promises-aplus-tests</span><br><span class="line"> * promises-aplus-tests es6Promise.js</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = es6Promise;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/js获取深层次属性-一道很经典的面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/js获取深层次属性-一道很经典的面试题/" itemprop="url">js获取深层次属性,一道很经典的面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T21:09:05+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："><a href="#题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：" class="headerlink" title="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："></a>题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; a: &#123; b: &#123; c: &apos;ScriptOJ&apos; &#125; &#125; &#125;</span><br><span class="line">data.a.b.c // =&gt; scriptoj</span><br><span class="line">data.a.b.c.d // =&gt; 报错，代码停止执行console.log(&apos;ScriptOJ&apos;) // =&gt; 不会被执行</span><br></pre></td></tr></table></figure>
<p>请你完成一个 safeGet 函数，可以安全的获取无限多层次的数据，一旦数据不存在不会报错，会返回 undefined，<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; a: &#123; b: &#123; c: &apos;ScriptOJ&apos; &#125; &#125; &#125;</span><br><span class="line">safeGet(data, &apos;a.b.c&apos;) // =&gt; scriptoj</span><br><span class="line">safeGet(data, &apos;a.b.c.d&apos;) // =&gt; 返回 undefined</span><br><span class="line">safeGet(data, &apos;a.b.c.d.e.f.g&apos;) // =&gt; 返回 undefined</span><br></pre></td></tr></table></figure></p>
<p>答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const safeGet = (o, path) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return path.split(&apos;.&apos;).reduce((o, k) =&gt; o[k], o)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    return void 666</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/Web-安全攻防总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/Web-安全攻防总结/" itemprop="url">Web 安全攻防总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T20:02:04+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Web 安全的对于 Web 从业人员来说是一个非常重要的课题，所以在这里总结一下 Web 相关的安全攻防知识，希望以后不要再踩雷，也希望对看到这篇文章的同学有所帮助。今天这边文章主要的内容就是分析几种常见的攻击的类型以及防御的方法。</p>
<blockquote>
<p>也许你对所有的安全问题都有一定的认识，但最主要的还是在编码设计的过程中时刻绷紧安全那根弦，需要反复推敲每个实现细节，安全无小事。</p>
<p>本文代码 Demo 都是基于 Node.js 讲解，其他服务端语言同样可以参考。</p>
</blockquote>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。</p>
<p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。</p>
<h3 id="非持久型-XSS"><a href="#非持久型-XSS" class="headerlink" title="非持久型 XSS"></a>非持久型 XSS</h3><p>非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br><img src="/2018/10/23/Web-安全攻防总结/xss1.jpg" alt="非持久型 XSS"><br>举一个例子，比如你的 Web 页面中包含有以下代码：</p>
<pre><code>&lt;select&gt;
    &lt;script&gt;
        document.write(&apos;&apos;
                + &apos;&lt;optionvalue=1&gt;&apos;
                +     location.href.substring(location.href.indexOf(&apos;default=&apos;) + 8)
                + &apos;&lt;/option&gt;&apos;
            );
            document.write(&apos;&lt;optionvalue=2&gt;English&lt;/option&gt;&apos;);
    &lt;/script&gt;
&lt;/select&gt;
</code></pre><p>攻击者可以直接通过 URL (类似： </p>
<pre><code>https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;
</code></pre><p>注入可执行的脚本代码。</p>
<p>非持久型 XSS 漏洞攻击有以下几点<strong>特征</strong>：</p>
<ul>
<li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li>
<li>攻击者需要诱骗点击</li>
<li>反馈率低，所以较难发现和响应修复</li>
<li>盗取用户敏感保密信息</li>
</ul>
<p>为了<strong>防止出现非持久型 XSS 漏洞</strong>，需要确保这么几件事情：</p>
<ul>
<li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li>
<li>尽量不要从 URL，<code>document.referrer</code>，<code>document.forms</code> 等这种 DOM API 中获取数据直接渲染。</li>
<li>尽量不要使用 <code>eval</code>, <code>new Function()</code>，<code>document.write()</code>，<code>document.writeln()</code>，<code>window.setInterval()</code>，<code>window.setTimeout()</code>，<code>innerHTML</code>，<code>document.creteElement()</code> 等可执行字符串的方法。</li>
<li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li>
<li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li>
</ul>
<blockquote>
<p>escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 <code>&lt;</code>，<code>&gt;</code>，<code>空格</code> 等，转义成 <code>&amp;lt;</code>，<code>&amp;gt;</code>，<code>&amp;nbsp;</code> 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。</p>
</blockquote>
<h3 id="持久型-XSS"><a href="#持久型-XSS" class="headerlink" title="持久型 XSS"></a>持久型 XSS</h3><p>持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>
<p>主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。攻击成功需要同时满足以下几个条件：</p>
<ul>
<li>POST 请求提交表单后端没做转义直接入库。</li>
<li>后端从数据库中取出数据没做转义直接输出给前端。</li>
<li>前端拿到后端数据没做转义直接渲染成 DOM。</li>
</ul>
<p>持久型 XSS 有以下几个<strong>特点</strong>：</p>
<ul>
<li>持久性，植入在数据库中</li>
<li>危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。</li>
<li>盗取用户敏感私密信息</li>
</ul>
<p>为了<strong>防止持久型 XSS 漏洞</strong>，需要前后端共同努力：</p>
<ul>
<li>后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。</li>
<li>后端在输出给前端数据统一进行转义处理。</li>
<li>前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</li>
</ul>
<h3 id="基于字符集的-XSS"><a href="#基于字符集的-XSS" class="headerlink" title="基于字符集的 XSS"></a>基于字符集的 XSS</h3><p>其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。</p>
<p>以基于 utf-7 的 XSS 为例</p>
<p>utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。</p>
<p>这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。</p>
<pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;
      可以被解释为：
+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4-
</code></pre><p>可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。</p>
<p>所以我们有什么办法避免这种 XSS 呢？</p>
<ul>
<li>记住指定 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></li>
<li>XML 中不仅要指定字符集为 utf-8，而且标签要闭合</li>
<li>牛文推荐：<a href="http://drops.wooyun.org/papers/1327" target="_blank" rel="noopener">http://drops.wooyun.org/papers/1327</a> （这个讲的很详细）</li>
</ul>
<h3 id="基于-Flash-的跨站-XSS"><a href="#基于-Flash-的跨站-XSS" class="headerlink" title="基于 Flash 的跨站 XSS"></a>基于 Flash 的跨站 XSS</h3><p>基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。</p>
<p>避免方法：</p>
<ul>
<li>严格管理 cookie 的读写权限</li>
<li>对 Flash 能接受用户输入的参数进行过滤 escape 转义处理</li>
</ul>
<h3 id="未经验证的跳转-XSS"><a href="#未经验证的跳转-XSS" class="headerlink" title="未经验证的跳转 XSS"></a>未经验证的跳转 XSS</h3><p>有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。</p>
<p>这时候需要通过以下方式来防止这类漏洞：</p>
<ul>
<li>对待跳转的 URL 参数做白名单或者某种规则过滤</li>
<li>后端注意对敏感信息的保护, 比如 cookie 使用来源验证。</li>
</ul>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF（Cross-Site Request Forgery），中文名称：跨站请求伪造攻击</p>
<p>那么 CSRF 到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。攻击者只要借助少许的社会工程学的诡计，例如通过 QQ 等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使 Web 应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。</p>
<p>所以遇到 CSRF 攻击时，将对终端用户的数据和操作指令构成严重的威胁。当受攻击的终端用户具有管理员帐户的时候，CSRF 攻击将危及整个 Web 应用程序。</p>
<h3 id="CSRF-原理"><a href="#CSRF-原理" class="headerlink" title="CSRF 原理"></a>CSRF 原理</h3><p>下图大概描述了 CSRF 攻击的原理，可以理解为有一个小偷在你配钥匙的地方得到了你家的钥匙，然后拿着要是去你家想偷什么偷什么。<br><img src="/2018/10/23/Web-安全攻防总结/csrf.jpg" alt="csrf原理"><br>完成 CSRF 攻击必须要有三个条件：</p>
<ol>
<li>用户已经登录了站点 A，并在本地记录了 cookie</li>
<li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。</li>
<li>站点 A 没有做任何 CSRF 防御</li>
</ol>
<p>你也许会问：「如果我不满足以上三个条件中的任意一个，就不会受到 CSRF 的攻击」。其实可以这么说的，但你不能保证以下情况不会发生：</p>
<ul>
<li>你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站，特别现在浏览器都是支持多 tab 的。</li>
<li>你不能保证你关闭浏览器了后，你本地的 cookie 立刻过期，你上次的会话已经结束。</li>
<li>上图中所谓的攻击网站 B，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li>
</ul>
<h3 id="预防-CSRF"><a href="#预防-CSRF" class="headerlink" title="预防 CSRF"></a>预防 CSRF</h3><p>CSRF 的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的 CSRF 防御也都在服务端进行。服务端的预防 CSRF 攻击的方式方法有多种，但思路上都是差不多的，主要从以下两个方面入手：</p>
<ul>
<li>正确使用 GET，POST 请求和 cookie</li>
<li>在非 GET 请求中增加 token</li>
</ul>
<p>一般而言，普通的 Web 应用都是以 GET、POST 请求为主，还有一种请求是 cookie 方式。我们一般都是按照如下规则设计应用的请求：</p>
<ul>
<li>GET 请求常用在查看，列举，展示等不需要改变资源属性的时候（数据库 query 查询的时候）</li>
<li>POST 请求常用在 From 表单提交，改变一个资源的属性或者做其他一些事情的时候（数据库有 insert、update、delete 的时候）</li>
</ul>
<p>当正确的使用了 GET 和 POST 请求之后，剩下的就是在非 GET 方式的请求中增加随机数，这个大概有三种方式来进行：</p>
<ul>
<li><p><strong>为每个用户生成一个唯一的 cookie token</strong>，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的 cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。</p>
</li>
<li><p><strong>每个 POST 请求使用验证码</strong>，这个方案算是比较完美的，但是需要用户多次输入验证码，用户体验比较差，所以不适合在业务中大量运用。</p>
</li>
<li><p><strong>渲染表单的时候，为每一个表单包含一个 csrfToken</strong>，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。</p>
</li>
</ul>
<p>CSRF 的防御可以根据应用场景的不同自行选择。CSRF 的防御工作确实会在正常业务逻辑的基础上带来很多额外的开发量，但是这种工作量是值得的，毕竟用户隐私以及财产安全是产品最基础的根本。</p>
<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p>
<p>而造成 SQL 注入的原因是因为程序没有有效的转义过滤用户的输入，使攻击者成功的向服务器提交恶意的 SQL 查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p>
<p>很多 Web 开发者没有意识到 SQL 查询是可以被篡改的，从而把 SQL 查询当作可信任的命令。殊不知，SQL 查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过 SQL 查询去运行主机系统级的命令。</p>
<h3 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a>SQL 注入原理</h3><p>下面将通过一些真实的例子来详细讲解 SQL 注入的方式的原理。</p>
<p>考虑以下简单的管理员登录表单：</p>
<pre><code>&lt;formaction=&quot;/login&quot;method=&quot;POST&quot;&gt;
&lt;p&gt;Username: &lt;inputtype=&quot;text&quot;name=&quot;username&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Password: &lt;inputtype=&quot;password&quot;name=&quot;password&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;inputtype=&quot;submit&quot;value=&quot;登陆&quot; /&gt;&lt;/p&gt;
&lt;/form&gt;
</code></pre><p>后端的 SQL 语句可能是如下这样的：</p>
<pre><code>let querySQL = `
    SELECT *
    FROM user
    WHERE username=&apos;${username}&apos;
    AND psw=&apos;${password}&apos;
`;
// 接下来就是执行 sql 语句...
</code></pre><p>目的就是来验证用户名和密码是不是正确，按理说乍一看上面的 SQL 语句也没什么毛病，确实是能够达到我们的目的，可是你只是站在用户会老老实实按照你的设计来输入的角度来看问题，如果有一个恶意攻击者输入的用户名是 <code>zoumiaojiang&#39; OR 1 = 1 --</code>，密码随意输入，就可以直接登入系统了。WFT!</p>
<p>冷静下来思考一下，我们之前预想的真实 SQL 语句是:</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;AND psw=&apos;mypassword&apos;
</code></pre><p>可以恶意攻击者的奇怪用户名将你的 SQL 语句变成了如下形式：</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1--&apos; AND psw=&apos;xxxx&apos;
</code></pre><p>在 SQL 中，<code>--</code> 是注释后面的内容的意思，所以查询语句就变成了：</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1
</code></pre><p>这条 SQL 语句的查询条件永远为真，所以意思就是恶意攻击者不用我的密码，就可以登录进我的账号，然后可以在里面为所欲为，然而这还只是最简单的注入，牛逼的 SQL 注入高手甚至可以通过 SQL 查询去运行主机系统级的命令，将你主机里的内容一览无余，这里我也没有这个能力讲解的太深入，毕竟不是专业研究这类攻击的，但是通过以上的例子，已经了解了 SQL 注入的原理，我们基本已经能找到防御 SQL 注入的方案了。</p>
<h3 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h3><p>防止 SQL 注入主要是不能允许用户输入的内容影响正常的 SQL 语句的逻辑，当用户的输入的信息将要用来拼接 SQL 语句的话，我们应该永远选择不相信，任何内容都必须进行转义过滤，当然做到这个还是不够的，下面列出防御 SQL 注入的几点注意事项：</p>
<ul>
<li><p><strong>严格限制Web应用的数据库的操作权限</strong>，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p>
</li>
<li><p><strong>后端代码检查输入的数据是否符合预期</strong>，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>
</li>
<li><p><strong>对进入数据库的特殊字符（<code>&#39;</code>，<code>&quot;</code>，<code>\</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&amp;</code>，<code>*</code>，<code>;</code> 等）进行转义处理</strong>，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 <code>lodash._escapehtmlchar</code> 库。</p>
</li>
<li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口</strong>，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 <code>query</code> 方法中的 <code>?</code> 占位参数。</p>
</li>
</ul>
<pre><code>mysql.query(`SELECT * FROM user WHERE username = ? AND psw = ?`, [username, psw]);
</code></pre><ul>
<li><p><strong>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测</strong>，以及时修补被发现的 SQL 注入漏洞。网上有很多这方面的开源工具，例如 sqlmap、SQLninja 等。</p>
</li>
<li><p><strong>避免网站打印出 SQL 错误信息</strong>，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。</p>
</li>
<li><p><strong>不要过于细化返回的错误信息</strong>，如果目的是方便调试，就去使用后端日志，不要在接口上过多的暴露出错信息，毕竟真正的用户不关心太多的技术细节，只要话术合理就行。</p>
</li>
</ul>
<p>碰到要操作的数据库的代码，一定要慎重，小心使得万年船，多找几个人多来几次 code review，将问题都暴露出来，而且要善于利用工具，操作数据库相关的代码属于机密，没事不要去各种论坛晒自家站点的 SQL 语句，万一被人盯上了呢？</p>
<h2 id="命令行注入"><a href="#命令行注入" class="headerlink" title="命令行注入"></a>命令行注入</h2><p>命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令，听起来好像匪夷所思，这往往是 Web 开发者最容易忽视但是却是最危险的一个漏洞之一，看一个实例：</p>
<p>假如现在需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去产出一个结果返回给用户，接口的部分实现如下：</p>
<pre><code>// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo
const exec = require(&apos;mz/child_process&apos;).exec;
let params = {/* 用户输入的参数 */};

exec(`git clone ${params.repo} /some/path`);
</code></pre><p>这段代码确实能够满足业务需求，正常的用户也确实能从指定的 git repo 上下载到想要的代码，可是和 SQL 注入一样，这段代码在恶意攻击者眼中，简直就是香饽饽。</p>
<p>如果 <code>params.repo</code> 传入的是 <code>https://github.com/zoumiaojiang/zoumiaojiang.github.io.git</code> 当然没问题了。</p>
<p>可是如果 <code>params.repo</code> 传入的是 <code>https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;</code> 恰好你的服务是用 root 权限起的就惨了。</p>
<p>具体恶意攻击者能用命令行注入干什么也像 SQL 注入一样，手法是千变万化的，比如「<a href="http://wiki.bash-hackers.org/howto/redirection_tutorial" target="_blank" rel="noopener">反弹 shell 注入</a>」等，但原理都是一样的，我们绝对有能力防止命令行注入发生。防止命令行注入需要做到以下几件事情：</p>
<ul>
<li>后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。</li>
<li>在调用系统命令前对所有传入参数进行命令行参数转义过滤。</li>
<li>不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 <code>shell-escape</code> npm 包。</li>
</ul>
<p>还是前面的例子，我们可以做到如下：</p>
<pre><code>const exec = require(&apos;mz/child_process&apos;).exec;

// 借助 shell-escape npm 包解决参数转义过滤问题
const shellescape = require(&apos;shell-escape&apos;);

let params = {/* 用户输入的参数 */};

// 先过滤一下参数，让参数符合预期
if (!/正确的表达式/.test(params.repo)) {
return;
}

let cmd = shellescape([
&apos;git&apos;,
&apos;clone&apos;,
    params.repo,
&apos;/some/path&apos;
]);

// cmd 的值: git clone &apos;https://github.com/xx/xx.git &amp;&amp; rm -rf / &amp;&amp;&apos; /some/path
// 这样就不会被注入成功了。
exec(cmd);
</code></pre><blockquote>
<p>无论是在何种后端语言环境中，凡是涉及到代码调用系统 shell 命令的时候都一定要谨慎。</p>
</blockquote>
<h2 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h2><p>DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用，这个攻击应该不能算是安全问题，这应该算是一个另类的存在，因为这种攻击根本就是耍流氓的存在，「伤敌一千，自损八百」的行为。出于保护 Web App 不受攻击的攻防角度，还是介绍一下 DDoS 攻击吧，毕竟也是挺常见的。</p>
<p>DDoS 攻击可以理解为：「你开了一家店，隔壁家点看不惯，就雇了一大堆黑社会人员进你店里干坐着，也不消费，其他客人也进不来，导致你营业惨淡」。为啥说 DDoS 是个「伤敌一千，自损八百」的行为呢？毕竟隔壁店还是花了不少钱雇黑社会但是啥也没得到不是？DDoS 攻击的目的基本上就以下几个：</p>
<ul>
<li>深仇大恨，就是要干死你</li>
<li>敲诈你，不给钱就干你</li>
<li>忽悠你，不买我防火墙服务就会有“人”继续干你</li>
</ul>
<p>也许你的站点遭受过 DDoS 攻击，具体什么原因怎么解读见仁见智。DDos 攻击从层次上可分为网络层攻击与应用层攻击，从攻击手法上可分为快型流量攻击与慢型流量攻击，但其原理都是造成资源过载，导致服务不可用。</p>
<h3 id="网络层-DDoS"><a href="#网络层-DDoS" class="headerlink" title="网络层 DDoS"></a>网络层 DDoS</h3><p>网络层 DDos 攻击包括 <code>SYN Flood</code>、<code>ACK Flood</code>、<code>UDP Flood</code>、<code>ICMP Flood</code> 等。</p>
<p><strong>SYN Flood 攻击</strong></p>
<p>SYN flood 攻击主要利用了 TCP 三次握手过程中的 Bug，我们都知道 TCP 三次握手过程是要建立连接的双方发送 SYN，SYN + ACK，ACK 数据包，而当攻击方随意构造源 IP 去发送 SYN 包时，服务器返回的 SYN + ACK 就不能得到应答（因为 IP 是随意构造的），此时服务器就会尝试重新发送，并且会有至少 30s 的等待时间，导致资源饱和服务不可用，此攻击属于慢型 DDoS 攻击。</p>
<p><strong>ACK Flood 攻击</strong></p>
<p>ACK Flood 攻击是在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。</p>
<p><strong>UDP Flood 攻击</strong></p>
<p>UDP flood 攻击是由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。</p>
<p><strong>ICMP Flood 攻击</strong></p>
<p>ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。</p>
<h3 id="网络层-DDoS-防御"><a href="#网络层-DDoS-防御" class="headerlink" title="网络层 DDoS 防御"></a>网络层 DDoS 防御</h3><p>网络层的 DDoS 攻击究其本质其实是无法防御的，我们能做得就是不断优化服务本身部署的网络架构，以及提升网络带宽。当然，还是做好以下几件事也是有助于缓解网络层 DDoS 攻击的冲击：</p>
<ul>
<li>网络架构上做好优化，采用负载均衡分流。</li>
<li>确保服务器的系统文件是最新的版本，并及时更新系统补丁。</li>
<li>添加抗 DDos 设备，进行流量清洗。</li>
<li>限制同时打开的 SYN 半连接数目，缩短 SYN 半连接的 Timeout 时间。</li>
<li>限制单 IP 请求频率。</li>
<li>防火墙等防护设置禁止 ICMP 包等。</li>
<li>严格限制对外开放的服务器的向外访问。</li>
<li>运行端口映射程序或端口扫描程序，要认真检查特权端口和非特权端口。</li>
<li>关闭不必要的服务。</li>
<li>认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更,那这台机器就可能遭到了攻击。</li>
<li>限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。</li>
<li>加钱堆机器。。</li>
<li>报警。。</li>
</ul>
<h3 id="应用层-DDoS"><a href="#应用层-DDoS" class="headerlink" title="应用层 DDoS"></a>应用层 DDoS</h3><p>应用层 DDoS 攻击不是发生在网络层，是发生在 TCP 建立握手成功之后，应用程序处理请求的时候，现在很多常见的 DDoS 攻击都是应用层攻击。应用层攻击千变万化，目的就是在网络应用层耗尽你的带宽，下面列出集中典型的攻击类型。</p>
<p><strong>CC 攻击</strong></p>
<p>当时绿盟为了防御 DDoS 攻击研发了一款叫做 <code>Collapasar</code> 的产品，能够有效的防御 SYN Flood 攻击。黑客为了挑衅，研发了一款 <code>Challenge Collapasar</code> 攻击工具（简称 CC）。</p>
<p>CC 攻击的原理，就是针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。因此在发送 CC 攻击前，我们需要寻找加载比较慢，消耗资源比较多的网页，比如需要查询数据库的页面、读写硬盘文件的等。通过 CC 攻击，使用爬虫对某些加载需要消耗大量资源的页面发起 HTTP 请求。</p>
<p><strong>DNS Flood</strong></p>
<p>DNS Flood 攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名，被攻击的DNS 服务器在接收到域名解析请求的时候首先会在服务器上查找是否有对应的缓存，如果查找不到并且该域名无法直接由服务器解析的时候，DNS 服务器会向其上层 DNS 服务器递归查询域名信息。域名解析的过程给服务器带来了很大的负载，每秒钟域名解析请求超过一定的数量就会造成 DNS 服务器解析域名超时。</p>
<p>根据微软的统计数据，一台 DNS 服务器所能承受的动态域名查询的上限是每秒钟 9000 个请求。而我们知道，在一台 P3 的 PC 机上可以轻易地构造出每秒钟几万个域名解析请求，足以使一台硬件配置极高的 DNS 服务器瘫痪，由此可见 DNS 服务器的脆弱性。</p>
<p><strong>HTTP 慢速连接攻击</strong></p>
<p>针对 HTTP 协议，先建立起 HTTP 连接，设置一个较大的 Conetnt-Length，每次只发送很少的字节，让服务器一直以为 HTTP 头部没有传输完成，这样连接一多就很快会出现连接耗尽。</p>
<h3 id="应用层-DDoS-防御"><a href="#应用层-DDoS-防御" class="headerlink" title="应用层 DDoS 防御"></a>应用层 DDoS 防御</h3><ul>
<li>判断 User-Agent 字段（不可靠，因为可以随意构造）</li>
<li>针对 IP + cookie，限制访问频率（由于 cookie 可以更改，IP 可以使用代理，或者肉鸡，也不可靠)</li>
<li>关闭服务器最大连接数等，合理配置中间件，缓解 DDoS 攻击。</li>
<li>请求中添加验证码，比如请求中有数据库操作的时候。</li>
<li>编写代码时，尽量实现优化，并合理使用缓存技术，减少数据库的读取操作。</li>
<li>加钱堆机器。。</li>
<li>报警。。</li>
</ul>
<p>应用层的防御有时比网络层的更难，因为导致应用层被 DDoS 攻击的因素非常多，有时往往是因为程序员的失误，导致某个页面加载需要消耗大量资源，有时是因为中间件配置不当等等。而应用层 DDoS 防御的核心就是区分人与机器（爬虫），因为大量的请求不可能是人为的，肯定是机器构造的。因此如果能有效的区分人与爬虫行为，则可以很好地防御此攻击。</p>
<h3 id="其他-DDoS-攻击"><a href="#其他-DDoS-攻击" class="headerlink" title="其他 DDoS 攻击"></a>其他 DDoS 攻击</h3><p>发起 DDoS 也是需要大量的带宽资源的，但是互联网就像森林，林子大了什么鸟都有，DDoS 攻击者也能找到其他的方式发起廉价并且极具杀伤力的 DDoS 攻击。</p>
<p><strong>利用 XSS</strong></p>
<p>举个例子，如果 12306 页面有一个 XSS 持久型漏洞被恶意攻击者发现，只需在春节抢票期间在这个漏洞中执行脚本使得往某一个小站点随便发点什么请求，然后随着用户访问的增多，感染用户增多，被攻击的站点自然就会迅速瘫痪了。这种 DDoS 简直就是无本万利，不用惊讶，现在大站有 XSS 漏洞的不要太多。</p>
<p><strong>来自 P2P 网络攻击</strong></p>
<p>大家都知道，互联网上的 P2P 用户和流量都是一个极为庞大的数字。如果他们都去一个指定的地方下载数据，成千上万的真实 IP 地址连接过来，没有哪个设备能够支撑住。拿 BT 下载来说，伪造一些热门视频的种子，发布到搜索引擎，就足以骗到许多用户和流量了，但是这只是基础攻击。</p>
<p>高级的 P2P 攻击，是直接欺骗资源管理服务器。如迅雷客户端会把自己发现的资源上传到资源管理服务器，然后推送给其它需要下载相同资源的用户，这样，一个链接就发布出去。通过协议逆向，攻击者伪造出大批量的热门资源信息通过资源管理中心分发出去，瞬间就可以传遍整个 P2P 网络。更为恐怖的是，这种攻击是无法停止的，即使是攻击者自身也无法停止，攻击一直持续到 P2P 官方发现问题更新服务器且下载用户重启下载软件为止。</p>
<blockquote>
<p>最后总结下，DDoS 不可能防的住，就好比你的店只能容纳 50 人，黑社会有 100 人，你就换一家大店，能容纳 500 人，然后黑社会又找来了 1000 人，这种堆人头的做法就是 DDoS 本质上的攻防之道，「道高一尺，魔高一丈，魔高一尺，道高一丈」，讲真，必要的时候就答应勒索你的人的条件吧，实在不行就报警吧。</p>
</blockquote>
<h2 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h2><p>流量劫持应该算是黑产行业的一大经济支柱了吧？简直是让人恶心到吐，不吐槽了，还是继续谈干货吧，流量劫持基本分两种：<code>DNS 劫持</code> 和 <code>HTTP 劫持</code>，目的都是一样的，就是当用户访问 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 的时候，给你展示的并不是或者不完全是 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 提供的 “内容”。</p>
<h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持，也叫做域名劫持，可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了</strong>」，DNS 的作用是把网络地址域名对应到真实的计算机能够识别的 IP 地址，以便计算机能够进一步通信，传递网址和内容等。如果当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。<br><img src="/2018/10/23/Web-安全攻防总结/dns.jpg" alt="dns劫持"><br>这类劫持，要不就是网络运营商搞的鬼，一般小的网络运营商与黑产勾结会劫持 DNS，要不就是电脑中毒，被恶意篡改了路由器的 DNS 配置，基本上做为开发者或站长却是很难察觉的，除非有用户反馈，现在升级版的 DNS 劫持还可以对特定用户、特定区域等使用了用户画像进行筛选用户劫持的办法，另外这类广告显示更加随机更小，一般站长除非用户投诉否则很难觉察到，就算觉察到了取证举报更难。无论如何，如果接到有 DNS 劫持的反馈，一定要做好以下几件事：</p>
<ul>
<li>取证很重要，时间、地点、IP、拨号账户、截屏、URL 地址等一定要有。</li>
<li>可以跟劫持区域的电信运营商进行投诉反馈。</li>
<li>如果投诉反馈无效，直接去工信部投诉，一般来说会加白你的域名。</li>
</ul>
<h3 id="HTTP-劫持"><a href="#HTTP-劫持" class="headerlink" title="HTTP 劫持"></a>HTTP 劫持</h3><p>HTTP 劫持您可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告</strong>」，HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面，轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私。能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。</p>
<p>HTTPS 协议就是一种基于 SSL 协议的安全加密网络应用层协议，可以很好的防止 HTTP 劫持。这里有篇 <a href="https://www.jianshu.com/p/13a1b955d095" target="_blank" rel="noopener">文章</a> 讲的不错。HTTPS 在这就不深讲了，后面有机会我会单独好好讲讲 HTTPS。如果不想站点被 HTTP 劫持，赶紧将你的站点全站改造成 HTTPS 吧。</p>
<h2 id="服务器漏洞"><a href="#服务器漏洞" class="headerlink" title="服务器漏洞"></a>服务器漏洞</h2><p>服务器除了以上提到的那些大名鼎鼎的漏洞和臭名昭著的攻击以外，其实还有很多其他的漏洞，往往也很容易被忽视，在这个小节也稍微介绍几种。</p>
<h3 id="越权操作漏洞"><a href="#越权操作漏洞" class="headerlink" title="越权操作漏洞"></a>越权操作漏洞</h3><p>如果你的系统是有登录控制的，那就要格外小心了，因为很有可能你的系统越权操作漏洞，越权操作漏洞可以简单的总结为 「<strong>A 用户能看到或者操作 B 用户的隐私内容</strong>」，如果你的系统中还有权限控制就更加需要小心了。所以每一个请求都需要做 userid 的判断</p>
<p>以下是一段有漏洞的后端示意代码：</p>
<pre><code>// ctx 为请求的 context 上下文
let msgId = ctx.params.msgId;

mysql.query(
&apos;SELECT * FROM msg_table WHERE msg_id = ?&apos;,
    [msgId]
);
</code></pre><p>以上代码是任何人都可以查询到任何用户的消息，只要有 msg_id 就可以，这就是比较典型的越权漏洞，需要如下这么改进一下：</p>
<pre><code>// ctx 为请求的 context 上下文
let msgId = ctx.params.msgId;
let userId = ctx.session.userId; // 从会话中取出当前登陆的 userId

mysql.query(
&apos;SELECT * FROM msg_table WHERE msg_id = ? AND user_id = ?&apos;,
    [msgId, userId]
);
</code></pre><p>嗯，大概就是这个意思，如果有更严格的权限控制，那在每个请求中凡是涉及到数据库的操作都需要先进行严格的验证，并且在设计数据库表的时候需要考虑进 userId 的账号关联以及权限关联。</p>
<h3 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h3><p>目录遍历漏洞指通过在 URL 或参数中构造 <code>../</code>，<code>./</code> 和类似的跨父目录字符串的 ASCII 编码、unicode 编码等，完成目录跳转，读取操作系统各个目录下的敏感文件，也可以称作「任意文件读取漏洞」。</p>
<p>目录遍历漏洞原理：程序没有充分过滤用户输入的 <code>../</code> 之类的目录跳转符，导致用户可以通过提交目录跳转来遍历服务器上的任意文件。使用多个<code>..</code> 符号，不断向上跳转，最终停留在根 <code>/</code>，通过绝对路径去读取任意文件。</p>
<p>目录遍历漏洞几个示例和测试，一般构造 URL 然后使用浏览器直接访问，或者使用 Web 漏洞扫描工具检测，当然也可以自写程序测试。</p>
<pre><code>http://somehost.com/../../../../../../../../../etc/passwd
http://somehost.com/some/path?file=../../Windows/system.ini

# 借助 %00 空字符截断是一个比较经典的攻击手法
http://somehost.com/some/path?file=../../Windows/system.ini%00.js

# 使用了 IIS 的脚本目录来移动目录并执行指令
http://somehost.com/scripts/..%5c../Windows/System32/cmd.exe?/c+dir+c:\
</code></pre><p><strong>防御</strong> 方法就是需要对 URL 或者参数进行 <code>../</code>，<code>./</code> 等字符的转义过滤。</p>
<h3 id="物理路径泄漏"><a href="#物理路径泄漏" class="headerlink" title="物理路径泄漏"></a>物理路径泄漏</h3><p>物理路径泄露属于低风险等级缺陷，它的危害一般被描述为「攻击者可以利用此漏洞得到信息，来对系统进一步地攻击」，通常都是系统报错 500 的错误信息直接返回到页面可见导致的漏洞。得到物理路径有些时候它能给攻击者带来一些有用的信息，比如说：可以大致了解系统的文件目录结构；可以看出系统所使用的第三方软件；也说不定会得到一个合法的用户名（因为很多人把自己的用户名作为网站的目录名）。</p>
<p>防止这种泄漏的方法就是做好后端程序的出错处理，定制特殊的 500 报错页面。</p>
<h3 id="源码暴露漏洞"><a href="#源码暴露漏洞" class="headerlink" title="源码暴露漏洞"></a>源码暴露漏洞</h3><p>和物理路径泄露类似，就是攻击者可以通过请求直接获取到你站点的后端源代码，然后就可以对系统进一步研究攻击。那么导致源代码暴露的原因是什么呢？基本上就是发生在服务器配置上了，服务器可以设置哪些路径的文件才可以被直接访问的，这里给一个 koa 服务起的例子，正常的 koa 服务器可以通过 koa-static 中间件去指定静态资源的目录，好让静态资源可以通过路径的路由访问。比如你的系统源代码目录是这样的：</p>
<pre><code>|- project
    |- src
    |- static
    |- ...
|- server.js
</code></pre><p>你想要将 static 的文件夹配成静态资源目录，你应该会在 <code>server.js</code> 做如下配置：</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const serve = require(&apos;koa-static&apos;);
const app = new Koa();

app.use(serve(__dirname + &apos;/project/static&apos;));
</code></pre><p>但是如果配错了静态资源的目录，可能就出大事了，比如：</p>
<pre><code>// ...
app.use(serve(__dirname + &apos;/project&apos;));
</code></pre><p>这样所有的源代码都可以通过路由访问到了，所有的服务器都提供了静态资源机制，所以在通过服务器配置静态资源目录和路径的时候，一定要注意检验，不然很可能产生漏洞。</p>
<p>最后，希望 Web 开发者们能够管理好自己的代码隐私，注意代码安全问题，比如不要将产品的含有敏感信息的代码放到第三方外部站点或者暴露给外部用户，尤其是前端代码，私钥类似的保密性的东西不要直接输出在代码里或者页面中。也许还有很多值得注意的点，但是归根结底还是绷住安全那根弦，对待每一行代码都要多多推敲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/21/面试之Vue-nextTick原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/21/面试之Vue-nextTick原理/" itemprop="url">面试之Vue.$nextTick原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-21T14:16:44+08:00">
                2018-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="面试官-Vue的nextTick是怎么监听DOM树更新完毕的？"><a href="#面试官-Vue的nextTick是怎么监听DOM树更新完毕的？" class="headerlink" title="面试官:Vue的nextTick是怎么监听DOM树更新完毕的？"></a>面试官:Vue的nextTick是怎么监听DOM树更新完毕的？</h2><p>nextTick是全局vue的一个函数，在vue系统中，用于处理dom更新的操作。vue里面有一个watcher，用于观察数据的变化，然后更新dom，vue里面并不是每次数据改变都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom更新操作。 </p>
<p>通常情况下，我们不需要关心这个问题，而如果想在DOM状态更新后做点什么，则需要用到nextTick。在vue生命周期的created()钩子函数进行的DOM操作要放在Vue.nextTick()的回调函数中，因为created()钩子函数执行的时候DOM并未进行任何渲染，而此时进行DOM操作是徒劳的，所以此处一定要将DOM操作的JS代码放进Vue.nextTick()的回调函数中。而与之对应的mounted钩子函数，该钩子函数执行时所有的DOM挂载和渲染都已完成，此时该钩子函数进行任何DOM操作都不会有个问题。 </p>
<p><code>Vue.nextTick(callback)</code>，当数据发生变化，更新后执行回调。</p>
<p><code>Vue.$nextTick(callback)</code>，当dom发生变化，更新后执行的回调。</p>
<hr>
<p>废话少说，来看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;span id=&apos;name&apos; ref=&apos;name&apos;&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;button @click=&apos;change&apos;&gt;change name&lt;/button&gt;</span><br><span class="line">  &lt;div id=&apos;content&apos;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &apos;SHERlocked93&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change() &#123;</span><br><span class="line">        const $name = this.$refs.name</span><br><span class="line">        this.$nextTick(() =&gt; console.log(&apos;setter前：&apos; + $name.innerHTML))</span><br><span class="line">        this.name = &apos; name改喽 &apos;</span><br><span class="line">        console.log(&apos;同步方式：&apos; + this.$refs.name.innerHTML)</span><br><span class="line">        setTimeout(() =&gt; this.console(&quot;setTimeout方式：&quot; + this.$refs.name.innerHTML))</span><br><span class="line">        this.$nextTick(() =&gt; console.log(&apos;setter后：&apos; + $name.innerHTML))</span><br><span class="line">        this.$nextTick().then(() =&gt; console.log(&apos;Promise方式：&apos; + $name.innerHTML))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>执行以下看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同步方式：SHERlocked93 </span><br><span class="line">setter前：SHERlocked93 </span><br><span class="line">setter后：name改喽 </span><br><span class="line">Promise方式：name改喽 </span><br><span class="line">setTimeout方式：name改喽</span><br></pre></td></tr></table></figure></p>
<hr>
<p>再看一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div ref=&quot;text&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;text&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            text: &apos;start&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods () &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            this.text = &apos;end&apos;;</span><br><span class="line">            console.log(this.$refs.text.innerText);//打印“start”</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的结果是start，为什么明明已经将text设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“start”呢？</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>带着这个疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。</p>
<h3 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class="line">   */</span><br><span class="line">  update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">    /*同步则执行run直接渲染视图*/</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现Vue.js默认是使用异步执行DOM更新。<br>当异步执行update的时候，会调用queueWatcher函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Push a watcher into the watcher queue.</span><br><span class="line"> * Jobs with duplicate IDs will be skipped unless it&apos;s</span><br><span class="line"> * pushed when the queue is being flushed.</span><br><span class="line"> **/</span><br><span class="line"> /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/</span><br><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">    /*获取watcher的id*/</span><br><span class="line">  const id = watcher.id</span><br><span class="line">   /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">    /*如果没有flush掉，直接push到队列中即可*/</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // if already flushing, splice the watcher based on its id</span><br><span class="line">      // if already past its id, it will be run next immediately.</span><br><span class="line">      let i = queue.length - 1</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    // queue the flush</span><br><span class="line">    // 刷新队列</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true</span><br><span class="line"></span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</p>
<h3 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/observer/scheduler.js</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Flush both queues and run the watchers.</span><br><span class="line"> */</span><br><span class="line">  /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/</span><br><span class="line">function flushSchedulerQueue () &#123;</span><br><span class="line">  flushing = true</span><br><span class="line">  let watcher, id</span><br><span class="line"></span><br><span class="line">  // Sort queue before flush.</span><br><span class="line">  // This ensures that:</span><br><span class="line">  // 1. Components are updated from parent to child. (because parent is always</span><br><span class="line">  //    created before the child)</span><br><span class="line">  // 2. A component&apos;s user watchers are run before its render watcher (because</span><br><span class="line">  //    user watchers are created before the render watcher)</span><br><span class="line">  // 3. If a component is destroyed during a parent component&apos;s watcher run,</span><br><span class="line">  //    its watchers can be skipped.</span><br><span class="line">  /*</span><br><span class="line">    刷新前给queue排序，这样做可以保证：</span><br><span class="line">    1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。</span><br><span class="line">    2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建</span><br><span class="line">    3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。</span><br><span class="line">  */</span><br><span class="line">  queue.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line"></span><br><span class="line">  // do not cache length because more watchers might be pushed</span><br><span class="line">  // as we run existing watchers</span><br><span class="line">  /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，</span><br><span class="line">  因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/</span><br><span class="line">  for (index = 0; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    if (watcher.before) &#123;</span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id</span><br><span class="line">     /*将has的标记删除*/</span><br><span class="line">    has[id] = null</span><br><span class="line">     /*执行watcher*/</span><br><span class="line">    watcher.run()</span><br><span class="line">    // in dev build, check and stop circular updates.</span><br><span class="line">    /*</span><br><span class="line">      在测试环境中，检测watch是否在死循环中</span><br><span class="line">      比如这样一种情况</span><br><span class="line">      watch: &#123;</span><br><span class="line">        test () &#123;</span><br><span class="line">          this.test++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      持续执行了一百次watch代表可能存在死循环</span><br><span class="line">    */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) &#123;</span><br><span class="line">      circular[id] = (circular[id] || 0) + 1</span><br><span class="line">      if (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;You may have an infinite update loop &apos; + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? `in watcher with expression &quot;$&#123;watcher.expression&#125;&quot;`</span><br><span class="line">              : `in a component render function.`</span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // keep copies of post queues before resetting state</span><br><span class="line">  /*得到队列的拷贝*/</span><br><span class="line">  const activatedQueue = activatedChildren.slice()</span><br><span class="line">  const updatedQueue = queue.slice()</span><br><span class="line">  /*重置调度者的状态*/</span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  // call component updated and activated hooks</span><br><span class="line">  /*使子组件状态都改编成active同时调用activated钩子*/</span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  /*调用updated钩子*/</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">  // devtool hook</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(&apos;flush&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图</p>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>vue.js提供了一个nextTick函数，其实也就是上面调用的nextTick。</p>
<p>nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion。</p>
<p>网上很多文章讨论的nextTick实现是2.4版本以下的实现，2.5以上版本对于nextTick的内部实现进行了大量的修改，看一下源码：</p>
<p>首先是从Vue 2.5+开始，抽出来了一个单独的文件next-tick.js来执行它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/util/next-tick.js</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line">    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function</span><br><span class="line">    这个函数的作用是在task或者microtask中推入一个timerFunc，</span><br><span class="line">    在当前调用栈执行完以后以此执行直到执行到timerFunc</span><br><span class="line">    目的是延迟到当前调用栈执行完以后执行</span><br><span class="line">*/</span><br><span class="line">/*存放异步执行的回调*/</span><br><span class="line">const callbacks = []</span><br><span class="line">/*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/</span><br><span class="line">let pending = false</span><br><span class="line"></span><br><span class="line">/*下一个tick时的回调*/</span><br><span class="line">function flushCallbacks () &#123;</span><br><span class="line">/*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/</span><br><span class="line">  pending = false</span><br><span class="line">  //复制callback</span><br><span class="line">  const copies = callbacks.slice(0)</span><br><span class="line">  //清除callbacks</span><br><span class="line">  callbacks.length = 0</span><br><span class="line">  for (let i = 0; i &lt; copies.length; i++) &#123;</span><br><span class="line">  //触发callback的回调函数</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span><br><span class="line">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span><br><span class="line">// microtasks have too high a priority and fire in between supposedly</span><br><span class="line">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span><br><span class="line">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span><br><span class="line">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span><br><span class="line">// Here we use microtask by default, but expose a way to force (macro) task when</span><br><span class="line">// needed (e.g. in event handlers attached by v-on).</span><br><span class="line">/**</span><br><span class="line">其大概的意思就是：在Vue2.4之前的版本中，nextTick几乎都是基于microTask实现的，</span><br><span class="line">但是由于microTask的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，</span><br><span class="line">就会导致一些诡异的问题；但是如果全部都改成macroTask，对一些有重绘和动画的场</span><br><span class="line">景也会有性能的影响。所以最终nextTick采取的策略是默认走microTask，对于一些DOM</span><br><span class="line">的交互事件，如v-on绑定的事件回调处理函数的处理，会强制走macroTask。</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">let microTimerFunc</span><br><span class="line">let macroTimerFunc</span><br><span class="line">let useMacroTask = false</span><br><span class="line"></span><br><span class="line">// Determine (macro) task defer implementation.</span><br><span class="line">// Technically setImmediate should be the ideal choice, but it&apos;s only available</span><br><span class="line">// in IE. The only polyfill that consistently queues the callback after all DOM</span><br><span class="line">// events triggered in the same loop is by using MessageChannel.</span><br><span class="line">/* istanbul ignore if */</span><br><span class="line">/**</span><br><span class="line">而对于macroTask的执行，Vue优先检测是否支持原生setImmediate（高版本IE和Edge支持），</span><br><span class="line">不支持的话再去检测是否支持原生MessageChannel，如果还不支持的话为setTimeout(fn, 0)。</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (typeof MessageChannel !== &apos;undefined&apos; &amp;&amp; ( </span><br><span class="line">// MessageChannel与原先的MutationObserver异曲同工</span><br><span class="line">/**</span><br><span class="line">在Vue 2.4版本以前使用的MutationObserver来模拟异步任务。</span><br><span class="line">而Vue 2.5版本以后，由于兼容性弃用了MutationObserver。</span><br><span class="line">Vue 2.5+版本使用了MessageChannel来模拟macroTask。</span><br><span class="line">除了IE以外，messageChannel的兼容性还是比较可观的。</span><br><span class="line">**/</span><br><span class="line">  isNative(MessageChannel) ||</span><br><span class="line">  // PhantomJS</span><br><span class="line">  MessageChannel.toString() === &apos;[object MessageChannelConstructor]&apos;</span><br><span class="line">)) &#123;</span><br><span class="line">  /**</span><br><span class="line">  可见，新建一个MessageChannel对象，该对象通过port1来检测信息，port2发送信息。</span><br><span class="line">  通过port2的主动postMessage来触发port1的onmessage事件，</span><br><span class="line">  进而把回调函数flushCallbacks作为macroTask参与事件循环。</span><br><span class="line">  **/</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  /* istanbul ignore next */</span><br><span class="line">   //上面两种都不支持，用setTimeout</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Determine microtask defer implementation.</span><br><span class="line">/* istanbul ignore next, $flow-disable-line */</span><br><span class="line"></span><br><span class="line">if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123;</span><br><span class="line">/*使用Promise*/</span><br><span class="line">  const p = Promise.resolve()</span><br><span class="line">  microTimerFunc = () =&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but</span><br><span class="line">    // it can get stuck in a weird state where callbacks are pushed into the</span><br><span class="line">    // microtask queue but the queue isn&apos;t being flushed, until the browser</span><br><span class="line">    // needs to do some other work, e.g. handle a timer. Therefore we can</span><br><span class="line">    // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span><br><span class="line">    //iOS的webview下，需要强制刷新队列，执行上面的回调函数</span><br><span class="line">    if (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // fallback to macro</span><br><span class="line">  microTimerFunc = macroTimerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wrap a function so that if any code inside triggers state change,</span><br><span class="line"> * the changes are queued using a (macro) task instead of a microtask.</span><br><span class="line"> */</span><br><span class="line"> /**</span><br><span class="line"> 在Vue执行绑定的DOM事件时，默认会给回调的handler函数调用withMacroTask方法做一层包装，</span><br><span class="line"> 它保证整个回调函数的执行过程中，遇到数据状态的改变，这些改变而导致的视图更新（DOM更新）</span><br><span class="line"> 的任务都会被推到macroTask而不是microtask。</span><br><span class="line"> **/</span><br><span class="line">export function withMacroTask (fn: Function): Function &#123;</span><br><span class="line">  return fn._withTask || (fn._withTask = function () &#123;</span><br><span class="line">    useMacroTask = true</span><br><span class="line">    const res = fn.apply(null, arguments)</span><br><span class="line">    useMacroTask = false</span><br><span class="line">    return res</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> /*</span><br><span class="line">    推送到队列中下一个tick时执行</span><br><span class="line">    cb 回调函数</span><br><span class="line">    ctx 上下文</span><br><span class="line">  */</span><br><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">   /*cb存到callbacks中*/</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &apos;nextTick&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    if (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MessageChannel-VS-setTimeout"><a href="#MessageChannel-VS-setTimeout" class="headerlink" title="MessageChannel VS setTimeout"></a>MessageChannel VS setTimeout</h3><p>为什么要优先MessageChannel创建macroTask而不是setTimeout？</p>
<p><strong> <font color="#dd0000">HTML5中规定setTimeout的最小时间延迟是4ms，也就是说理想环境下异步回调最快也是4ms才能触发。</font> </strong></p>
<p>Vue使用这么多函数来模拟异步任务，其目的只有一个，就是让回调异步且尽早调用。而MessageChannel的延迟明显是小于setTimeout的。</p>
<p>说了这么多，到底什么是macrotasks，什么是microtasks呢？</p>
<h5 id="两者的具体实现"><a href="#两者的具体实现" class="headerlink" title="两者的具体实现"></a>两者的具体实现</h5><p><strong>macrotasks：</strong></p>
<blockquote>
<font color="#dd0000">setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染</font>
</blockquote>
<p><strong>microtasks:</strong></p>
<blockquote>
<font color="#dd0000">Promise， process.nextTick， Object.observe， MutationObserver</font>
</blockquote>
<p><strong>1.在 macrotask 队列中执行最早的那个 task ，然后移出</strong></p>
<p><strong>2.再执行 microtask 队列中所有可用的任务，然后移出</strong></p>
<p><strong>3.下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</strong></p>
<p>那我们上面提到的任务队列到底是什么呢？跟macrotasks和microtasks有什么联系呢？</p>
<p>• 一个事件循环有一个或者多个任务队列；</p>
<p>• 每个事件循环都有一个microtask队列；</p>
<p>• macrotask队列就是我们常说的任务队列，microtask队列不是任务队列；</p>
<p>• 一个任务可以被放入到macrotask队列，也可以放入microtask队列；</p>
<p>• 当一个任务被放入microtask或者macrotask队列后，准备工作就已经结束，这时候可以开始执行任务了。</p>
<p>可见，setTimeout和Promises不是同一类的任务，处理方式应该会有区别，具体的处理方式有什么不同呢？ </p>
<p>通俗的解释一下，microtasks的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务。 例如响应事件、或者异步操作，以避免付出额外的一个task的费用。</p>
<p>microtask会在两种情况下执行：</p>
<p>任务队列(macrotask = task queue)回调后执行，前提条件是当前没有其他执行中的代码。<br>每个task末尾执行。<br>另外在处理microtask期间，如果有新添加的microtasks，也会被添加到队列的末尾并执行。</p>
<p>也就是说执行顺序是：</p>
<p>开始 -&gt; 取task queue第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取task queue下一个任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复</p>
<p>Promise一旦状态置为完成态，便为其回调(.then内的函数)安排一个microtask。</p>
<p>接下来我们看回我们上面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;,0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    for( var i=100000 ; i&gt;0 ; i-- )&#123;</span><br><span class="line">        i==1 &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(5);</span><br></pre></td></tr></table></figure>
<p>按照上面的规则重新分析一遍：</p>
<p>当运行到setTimeout时，会把setTimeout的回调函数console.log(1)放到任务队列里去，然后继续向下执行。</p>
<p>接下来会遇到一个Promise。首先执行打印console.log(2)，然后执行for循环，即时for循环要累加到10万，也是在执行栈里面，等待for循环执行完毕以后，将Promise的状态从fulfilled切换到resolve，随后把要执行的回调函数，也就是then里面的console.log(4)推到microtask里面去。接下来马上执行马上console.log(3)。</p>
<p>然后出Promise，还剩一个同步的console.log(5)，直接打印。这样第一轮下来，已经依次打印了2，3，5。</p>
<p>现在第一轮任务队列已经执行完毕，没有正在执行的代码。符合上面讲的microtask执行条件，因此会将microtask中的任务优先执行，因此执行console.log(4)</p>
<p>最后还剩macrotask里的setTimeout放入的函数console.log(1)最后执行。</p>
<p>如此分析输出顺序是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>我们再来看一个：</p>
<p>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：</p>
<p><strong> 1.先执行 macrotasks：I/O -》 UI渲染 </strong></p>
<p><strong> 2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe </strong></p>
<p><strong> 3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次： setTimeout ，setInterval –》setImmediate </strong></p>
<p>综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;,0);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;,0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(6);</span><br><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(7);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(8);</span><br><span class="line">结果是：3 4 6 8 7 5 2 1</span><br></pre></td></tr></table></figure>
<h3 id="使用了nextTick异步更新视图有什么好处呢？"><a href="#使用了nextTick异步更新视图有什么好处呢？" class="headerlink" title="使用了nextTick异步更新视图有什么好处呢？"></a>使用了nextTick异步更新视图有什么好处呢？</h3><p>接下来我们看一下一个Demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            test: 0</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">      for(let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        this.test++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有这样的一种情况，created的时候test的值会被++循环执行1000次。<br>每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。<br>如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。<br>所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。<br>保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/15/vue-router浅析原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/15/vue-router浅析原理/" itemprop="url">vue-router浅析原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-15T13:06:49+08:00">
                2018-10-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近期被问到一个问题，在你们项目中使用的是Vue的SPA（单页面）还是Vue的多页面设计？</p>
<p>这篇文章主要围绕Vue的SPA单页面设计展开。<br>关于如何展开Vue多页面设计<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a8e3f00f265da4e747fc700" target="_blank" rel="noopener">请点击查看</a>。</p>
<h2 id="vue-router是什么？"><a href="#vue-router是什么？" class="headerlink" title="vue-router是什么？"></a>vue-router是什么？</h2><p>首先我们需要知道vue-router是什么，它是干什么的？</p>
<p>这里指的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。<br>换句话说，vue-router就是WebApp的链接路径管理系统。</p>
<p>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。</p>
<p>那与传统的页面跳转有什么区别呢？</p>
<p>1.vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。</p>
<p>2.传统的页面应用，是用一些超链接来实现页面切换和跳转的。</p>
<p>在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</p>
<p>至于为啥不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，必须使用vue-router来进行管理。</p>
<h2 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h2><p>SPA(single page application):单一页面应用程序，有且只有一个完整的页面；当它在加载页面的时候，不会加载整个页面的内容，而只更新某个指定的容器中内容。</p>
<p>单页面应用(SPA)的核心之一是:</p>
<p>1.更新视图而不重新请求页面;</p>
<p>2.vue-router在实现单页面前端路由时，提供了三种方式：Hash模式、History模式、abstract模式，根据mode参数来决定采用哪一种方式。</p>
<h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><p>vue-router 提供了三种运行模式：</p>
<p>● hash: 使用 URL hash 值来作路由。默认模式。</p>
<p>● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p>
<p>● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。</p>
<h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p><strong>vue-router 默认模式是 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会去重新加载</strong>。</p>
<p>hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分（/#/..），浏览器只会加载相应位置的内容，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；<strong>所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据</strong>。</p>
<h3 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h3><p>HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；</p>
<p>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p>
<pre><code>//main.js文件中
const router = new VueRouter({
  mode: &apos;history&apos;,
  routes: [...]
})
</code></pre><p>当使用 history 模式时，URL 就像正常的 url，例如 <a href="https://link.juejin.im?target=http%3A%2F%2Fyoursite.com%2Fuser%2Fid%25EF%25BC%258C%25E6%25AF%2594%25E8%25BE%2583%25E5%25A5%25BD%25E7%259C%258B%25EF%25BC%2581" target="_blank" rel="noopener">yoursite.com/user/id，比较好…</a><br>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问</p>
<p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p>
<pre><code>export const routes = [ 
  {path: &quot;/&quot;, name: &quot;homeLink&quot;, component:Home}
  {path: &quot;/register&quot;, name: &quot;registerLink&quot;, component: Register},
  {path: &quot;/login&quot;, name: &quot;loginLink&quot;, component: Login},
  {path: &quot;*&quot;, redirect: &quot;/&quot;}]
</code></pre><p>此处就设置如果URL输入错误或者是URL 匹配不到任何静态资源，就自动跳到到Home页面。</p>
<h3 id="abstract模式"><a href="#abstract模式" class="headerlink" title="abstract模式"></a>abstract模式</h3><p>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</p>
<p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）</p>
<h2 id="vue-router使用方式"><a href="#vue-router使用方式" class="headerlink" title="vue-router使用方式"></a>vue-router使用方式</h2><p><strong>1:下载</strong> npm i vue-router -S</p>
<p><strong>2:在main.js中引入 </strong> import VueRouter from ‘vue-router’;</p>
<p><strong>3:安装插件</strong> Vue.use(VueRouter);</p>
<p><strong>4:创建路由对象并配置路由规则</strong></p>
<p>let router = new VueRouter({routes:[{path:’/home’,component:Home}]});</p>
<p><strong>5:将其路由对象传递给Vue的实例</strong>，options中加入 router:router</p>
<p><strong>6:在app.vue中留坑</strong></p>
<pre><code>&lt;router-view&gt;&lt;/router-view&gt;
</code></pre><p>具体实现请看如下代码：</p>
<pre><code>//main.js文件中引入
import Vue from &apos;vue&apos;;
import VueRouter from &apos;vue-router&apos;;
//主体
import App from &apos;./components/app.vue&apos;;
import index from &apos;./components/index.vue&apos;
//安装插件
Vue.use(VueRouter); //挂载属性
//创建路由对象并配置路由规则
let router = new VueRouter({
    routes: [
        //一个个对象
        { path: &apos;/index&apos;, component: index }
    ]
});
//new Vue 启动
new Vue({
    el: &apos;#app&apos;,
    //让vue知道我们的路由规则
    router: router, //可以简写router
    render: c =&gt; c(App),
})
</code></pre><p>最后记得在在app.vue中“留坑”</p>
<pre><code>//app.vue中
&lt;template&gt;
    &lt;div&gt;
        &lt;!-- 留坑，非常重要 --&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data(){
            return {}
        }
    }
&lt;/script&gt;
</code></pre><h2 id="vue-router源码分析"><a href="#vue-router源码分析" class="headerlink" title="vue-router源码分析"></a>vue-router源码分析</h2><p>我们先来看看vue的实现路径。<br><img src="https://user-gold-cdn.xitu.io/2018/10/18/16684f162d3090eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>在入口文件中需要实例化一个 VueRouter 的实例对象 ，然后将其传入 Vue 实例的 options 中。</p>
<pre><code>export default class VueRouter {
  static install: () =&gt; void;
  static version: string;

  app: any;
  apps: Array&lt;any&gt;;
  ready: boolean;
  readyCbs: Array&lt;Function&gt;;
  options: RouterOptions;
  mode: string;
  history: HashHistory | HTML5History | AbstractHistory;
  matcher: Matcher;
  fallback: boolean;
  beforeHooks: Array&lt;?NavigationGuard&gt;;
  resolveHooks: Array&lt;?NavigationGuard&gt;;
  afterHooks: Array&lt;?AfterNavigationHook&gt;;

  constructor (options: RouterOptions = {}) {
    this.app = null
    this.apps = []
    this.options = options
    this.beforeHooks = []
    this.resolveHooks = []
    this.afterHooks = []
    // 创建 matcher 匹配函数
    this.matcher = createMatcher(options.routes || [], this)
    // 根据 mode 实例化具体的 History，默认为&apos;hash&apos;模式
    let mode = options.mode || &apos;hash&apos;
    // 通过 supportsPushState 判断浏览器是否支持&apos;history&apos;模式
    // 如果设置的是&apos;history&apos;但是如果浏览器不支持的话，&apos;history&apos;模式会退回到&apos;hash&apos;模式
    // fallback 是当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true。
    this.fallback = mode === &apos;history&apos; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== falseif (this.fallback) {
      mode = &apos;hash&apos;
    }
    // 不在浏览器内部的话，就会变成&apos;abstract&apos;模式
    if (!inBrowser) {
      mode = &apos;abstract&apos;
    }
    this.mode = mode
     // 根据不同模式选择实例化对应的 History 类
    switch (mode) {
      case&apos;history&apos;:
        this.history = new HTML5History(this, options.base)
        breakcase&apos;hash&apos;:
        this.history = new HashHistory(this, options.base, this.fallback)
        breakcase&apos;abstract&apos;:
        this.history = new AbstractHistory(this, options.base)
        break
      default:
        if (process.env.NODE_ENV !== &apos;production&apos;) {
          assert(false, `invalid mode: ${mode}`)
        }
    }
  }

  match (
    raw: RawLocation,
    current?: Route,
    redirectedFrom?: Location
  ): Route {
    return this.matcher.match(raw, current, redirectedFrom)
  }

  get currentRoute (): ?Route {
    return this.history &amp;&amp; this.history.current
  }

  init (app: any /* Vue component instance */) {
    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; assert(
      install.installed,
      `not installed. Make sure to call \`Vue.use(VueRouter)\` ` +
      `before creating root instance.`
    )

    this.apps.push(app)

    // main app already initialized.
    if (this.app) {
      return
    }

    this.app = app

    const history = this.history
    // 根据history的类别执行相应的初始化操作和监听
    if (history instanceof HTML5History) {
      history.transitionTo(history.getCurrentLocation())
    } elseif (history instanceof HashHistory) {
      const setupHashListener = () =&gt; {
        history.setupListeners()
      }
      history.transitionTo(
        history.getCurrentLocation(),
        setupHashListener,
        setupHashListener
      )
    }

    history.listen(route =&gt; {
      this.apps.forEach((app) =&gt; {
        app._route = route
      })
    })
  }
  // 路由跳转之前
  beforeEach (fn: Function): Function {
    return registerHook(this.beforeHooks, fn)
  }
  // 路由导航被确认之间前
  beforeResolve (fn: Function): Function {
    return registerHook(this.resolveHooks, fn)
  }
  // 路由跳转之后
  afterEach (fn: Function): Function {
    return registerHook(this.afterHooks, fn)
  }
  // 第一次路由跳转完成时被调用的回调函数
  onReady (cb: Function, errorCb?: Function) {
    this.history.onReady(cb, errorCb)
  }
  // 路由报错
  onError (errorCb: Function) {
    this.history.onError(errorCb)
  }
  // 路由添加，这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。
  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.push(location, onComplete, onAbort)
  }
  // 这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。
  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    this.history.replace(location, onComplete, onAbort)
  }
  // 相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面
  go (n: number) {
    this.history.go(n)
  }
  // 后退到上一个页面
  back () {
    this.go(-1)
  }
  // 前进到下一个页面
  forward () {
    this.go(1)
  }

  getMatchedComponents (to?: RawLocation | Route): Array&lt;any&gt; {
    const route: any = to
      ? to.matched
        ? to
        : this.resolve(to).route
      : this.currentRoute
    if (!route) {
      return []
    }
    return [].concat.apply([], route.matched.map(m =&gt; {
      return Object.keys(m.components).map(key =&gt; {
        return m.components[key]
      })
    }))
  }

  resolve (
    to: RawLocation,
    current?: Route,
    append?: boolean
  ): {
    location: Location,
    route: Route,
    href: string,
    // for backwards compat
    normalizedTo: Location,
    resolved: Route
  } {
    const location = normalizeLocation(
      to,
      current || this.history.current,
      append,
      this
    )
    const route = this.match(location, current)
    const fullPath = route.redirectedFrom || route.fullPath
    const base = this.history.base
    const href = createHref(base, fullPath, this.mode)
    return {
      location,
      route,
      href,
      // for backwards compat
      normalizedTo: location,
      resolved: route
    }
  }

  addRoutes (routes: Array&lt;RouteConfig&gt;) {
    this.matcher.addRoutes(routes)
    if (this.history.current !== START) {
      this.history.transitionTo(this.history.getCurrentLocation())
    }
  }
}
</code></pre><h3 id="HashHistory"><a href="#HashHistory" class="headerlink" title="HashHistory"></a>HashHistory</h3><p>• hash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。</p>
<p>• 可以为hash的改变添加监听事件：</p>
<pre><code>window.addEventListener(&quot;hashchange&quot;,funcRef,false)
</code></pre><p>• 每一次改变hash(window.location.hash)，都会在浏览器访问历史中增加一个记录。</p>
<pre><code>export class HashHistory extends History {
  constructor (router: Router, base: ?string, fallback: boolean) {
    super(router, base)
    // check history fallback deeplinking
    // 如果是从history模式降级来的，需要做降级检查
    if (fallback &amp;&amp; checkFallback(this.base)) {
    // 如果降级且做了降级处理，则返回
      return
    }
    ensureSlash()
  }
  .......


function checkFallback (base) {
  const location = getLocation(base)
  // 得到除去base的真正的 location 值
  if (!/^\/#/.test(location)) {
  // 如果此时地址不是以 /# 开头的
  // 需要做一次降级处理，降为 hash 模式下应有的 /# 开头
    window.location.replace(
      cleanPath(base + &apos;/#&apos; + location)
    )
    returntrue
  }
}

function ensureSlash (): boolean {
// 得到 hash 值
  const path = getHash()
  if (path.charAt(0) === &apos;/&apos;) {
   // 如果是以 / 开头的，直接返回即可
    returntrue
  }
  // 不是的话，需要手动保证一次 替换 hash 值
  replaceHash(&apos;/&apos; + path)
  returnfalse
}

exportfunction getHash (): string {
  // We can&apos;t use window.location.hash here because it&apos;s not
  // consistent across browsers - Firefox will pre-decode it!
  // 因为兼容性的问题，这里没有直接使用 window.location.hash
  // 因为 Firefox decode hash 值
  const href = window.location.href
  const index = href.indexOf(&apos;#&apos;)
  return index === -1 ? &apos;&apos; : decodeURI(href.slice(index + 1))
}
// 得到hash之前的url地址
function getUrl (path) {
  const href = window.location.href
  const i = href.indexOf(&apos;#&apos;)
  const base = i &gt;= 0 ? href.slice(0, i) : href
  return `${base}#${path}`
}
// 添加一个hashfunction pushHash (path) {
  if (supportsPushState) {
    pushState(getUrl(path))
  } else {
    window.location.hash = path
  }
}
// 替代hashfunction replaceHash (path) {
  if (supportsPushState) {
    replaceState(getUrl(path))
  } else {
    window.location.replace(getUrl(path))
  }
}
</code></pre><p>hash的改变会自动添加到浏览器的访问历史记录中。 那么视图的更新是怎么实现的呢，看下 transitionTo()方法：</p>
<pre><code>transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {
    const route = this.router.match(location, this.current) //找到匹配路由
    this.confirmTransition(route, () =&gt; { //确认是否转化
      this.updateRoute(route) //更新route
      onComplete &amp;&amp; onComplete(route)
      this.ensureURL()

      // fire ready cbs once
      if (!this.ready) {
        this.ready = true
        this.readyCbs.forEach(cb =&gt; { cb(route) })
      }
    }, err =&gt; {
      if (onAbort) {
        onAbort(err)
      }
      if (err &amp;&amp; !this.ready) {
        this.ready = true
        this.readyErrorCbs.forEach(cb =&gt; { cb(err) })
      }
    })
  }

//更新路由
updateRoute (route: Route) {
    const prev = this.current // 跳转前路由
    this.current = route // 装备跳转路由
    this.cb &amp;&amp; this.cb(route) // 回调函数，这一步很重要，这个回调函数在index文件中注册，会更新被劫持的数据 _router
    this.router.afterHooks.forEach(hook =&gt; {
      hook &amp;&amp; hook(route, prev)
    })
  }
}
</code></pre><h4 id="pushState"><a href="#pushState" class="headerlink" title="pushState"></a>pushState</h4><pre><code>exportfunction pushState (url?: string, replace?: boolean) {
  saveScrollPosition()
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  // 加了 try...catch 是因为 Safari 有调用 pushState 100 次限制
  // 一旦达到就会抛出 DOM Exception 18 错误
  const history = window.history
  try {
    if (replace) {
    // replace 的话 key 还是当前的 key 没必要生成新的
      history.replaceState({ key: _key }, &apos;&apos;, url)
    } else {
    // 重新生成 key
      _key = genKey()
       // 带入新的 key 值
      history.pushState({ key: _key }, &apos;&apos;, url)
    }
  } catch (e) {
  // 达到限制了 则重新指定新的地址
    window.location[replace ? &apos;replace&apos; : &apos;assign&apos;](url)
  }
}
</code></pre><h4 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h4><pre><code>// 直接调用 pushState 传入 replace 为 trueexportfunction replaceState (url?: string) {
  pushState(url, true)
}
</code></pre><p>pushState和replaceState两种方法的共同特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。</p>
<h4 id="supportsPushState"><a href="#supportsPushState" class="headerlink" title="supportsPushState"></a>supportsPushState</h4><pre><code>export const supportsPushState = inBrowser &amp;&amp; (function () {
  const ua = window.navigator.userAgent

  if (
    (ua.indexOf(&apos;Android 2.&apos;) !== -1 || ua.indexOf(&apos;Android 4.0&apos;) !== -1) &amp;&amp;
    ua.indexOf(&apos;Mobile Safari&apos;) !== -1 &amp;&amp;
    ua.indexOf(&apos;Chrome&apos;) === -1 &amp;&amp;
    ua.indexOf(&apos;Windows Phone&apos;) === -1
  ) {
    returnfalse
  }

  return window.history &amp;&amp; &apos;pushState&apos;in window.history
})()
</code></pre><p>其实所谓响应式属性，即当_route值改变时，会自动调用Vue实例的render()方法，更新视图。<br>$router.push()–&gt;HashHistory.push()–&gt;History.transitionTo()–&gt;History.updateRoute()–&gt;{app._route=route}–&gt;vm.render()</p>
<h4 id="监听地址栏"><a href="#监听地址栏" class="headerlink" title="监听地址栏"></a>监听地址栏</h4><p>在浏览器中，用户可以直接在浏览器地址栏中输入改变路由，因此还需要监听浏览器地址栏中路由的变化 ，并具有与通过代码调用相同的响应行为，在HashHistory中这一功能通过setupListeners监听hashchange实现：</p>
<pre><code>setupListeners () {
    window.addEventListener(&apos;hashchange&apos;, () =&gt; {
        if (!ensureSlash()) {
            return
        }
        this.transitionTo(getHash(), route =&gt; {
            replaceHash(route.fullPath)
        })
    })
}
</code></pre><h3 id="HTML5History"><a href="#HTML5History" class="headerlink" title="HTML5History"></a>HTML5History</h3><p>History interface是浏览器历史记录栈提供的接口，通过back(),forward(),go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</p>
<pre><code>export class HTML5History extends History {
  constructor (router: Router, base: ?string) {
    super(router, base)

    const expectScroll = router.options.scrollBehavior //指回滚方式
    const supportsScroll = supportsPushState &amp;&amp; expectScroll

    if (supportsScroll) {
      setupScroll()
    }

    const initLocation = getLocation(this.base)
    //监控popstate事件
    window.addEventListener(&apos;popstate&apos;, e =&gt; {
      const current = this.current

      // Avoiding first `popstate` event dispatched in some browsers but first
      // history route not updated since async guard at the same time.
      // 避免在某些浏览器中首次发出“popstate”事件
      // 由于同一时间异步监听，history路由没有同时更新。
      const location = getLocation(this.base)
      if (this.current === START &amp;&amp; location === initLocation) {
        return
      }

      this.transitionTo(location, route =&gt; {
        if (supportsScroll) {
          handleScroll(router, route, current, true)
        }
      })
    })
  }
</code></pre><p>hash模式仅改变hash部分的内容，而hash部分是不会包含在http请求中的(hash带#)：</p>
<p><a href="https://link.juejin.im?target=http%3A%2F%2Foursite.com%2F%23%2Fuser%2Fid" target="_blank" rel="noopener">oursite.com/#/user/id</a> //如请求，只会发送<a href="http://oursite.com/" target="_blank" rel="noopener">http://oursite.com/</a></p>
<p>所以hash模式下遇到根据url请求页面不会有问题</p>
<p>而history模式则将url修改的就和正常请求后端的url一样(history不带#)</p>
<p><a href="https://link.juejin.im?target=http%3A%2F%2Foursite.com%2Fuser%2Fid" target="_blank" rel="noopener">oursite.com/user/id</a></p>
<p>如果这种向后端发送请求的话，后端没有配置对应/user/id的get路由处理,会返回404错误。</p>
<p>官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。</p>
<h4 id="两种模式比较"><a href="#两种模式比较" class="headerlink" title="两种模式比较"></a>两种模式比较</h4><p>一般的需求场景中，hash模式与history模式是差不多的，根据MDN的介绍，调用history.pushState()相比于直接修改hash主要有以下优势：</p>
<p>• pushState设置的新url可以是与当前url同源的任意url,而hash只可修改#后面的部分，故只可设置与当前同文档的url</p>
<p>• pushState设置的新url可以与当前url一模一样，这样也会把记录添加到栈中，而hash设置的新值必须与原来不一样才会触发记录添加到栈中</p>
<p>• pushState通过stateObject可以添加任意类型的数据记录中，而hash只可添加短字符串<br>pushState可额外设置title属性供后续使用</p>
<h3 id="AbstractHistory"><a href="#AbstractHistory" class="headerlink" title="AbstractHistory"></a>AbstractHistory</h3><p>‘abstract’模式，不涉及和浏览器地址的相关记录，流程跟’HashHistory’是一样的，其原理是通过数组模拟浏览器历史记录栈的功能</p>
<pre><code>//abstract.js实现，这里通过栈的数据结构来模拟路由路径
export class AbstractHistory extends History {
  index: number;
  stack: Array&lt;Route&gt;;

  constructor (router: Router, base: ?string) {
    super(router, base)
    this.stack = []
    this.index = -1
  }

  // 对于 go 的模拟
  go (n: number) {
    // 新的历史记录位置
    const targetIndex = this.index + n
    // 小于或大于超出则返回
    if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) {
      return
    }
    // 取得新的 route 对象
    // 因为是和浏览器无关的 这里得到的一定是已经访问过的
    const route = this.stack[targetIndex]
    // 所以这里直接调用 confirmTransition 了
    // 而不是调用 transitionTo 还要走一遍 match 逻辑
    this.confirmTransition(route, () =&gt; {
      this.index = targetIndex
      this.updateRoute(route)
    })
  }


 //确认是否转化路由
  confirmTransition (route: Route, onComplete: Function, onAbort?: Function) {
    const current = this.current
    const abort = err =&gt; {
      if (isError(err)) {
        if (this.errorCbs.length) {
          this.errorCbs.forEach(cb =&gt; { cb(err) })
        } else {
          warn(false, &apos;uncaught error during route navigation:&apos;)
          console.error(err)
        }
      }
      onAbort &amp;&amp; onAbort(err)
    }
    //判断如果前后是同一个路由，不进行操作
    if (
      isSameRoute(route, current) &amp;&amp;
      route.matched.length === current.matched.length
    ) {
      this.ensureURL()
      return abort()
    }
    //下面是各类钩子函数的处理
    //*********************
    })
  }
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/11/compose-串联中间件实现-洋葱模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/11/compose-串联中间件实现-洋葱模型/" itemprop="url">compose-串联中间件实现(洋葱模型)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-11T12:41:27+08:00">
                2018-10-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Koa</code> 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 <code>Express</code> 支持了异步，所以编码时经常使用 <code>async/await</code>，提高了可读性，使代码变得更优雅，上一篇文章 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.pandashen.com%2F2018%2F09%2F02%2F20180902141819%2F" target="_blank" rel="noopener">NodeJS 进阶 —— Koa 源码分析</a>，也对 “洋葱模型” 和实现它的 <code>compose</code> 进行分析，由于个人觉得 <code>compose</code> 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 <code>compose</code>。</p>
<h2 id="洋葱模型案例"><a href="#洋葱模型案例" class="headerlink" title="洋葱模型案例"></a>洋葱模型案例</h2><p>如果你已经使用 <code>Koa</code> 对 “洋葱模型” 这个词一定不陌生，它就是 <code>Koa</code> 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。</p>
<pre><code>const Koa = require(&quot;koa&quot;);

const app = new Koa();

app.use(asycn (ctx, next) =&gt; {
    console.log(1);
    await next();
    console.log(2);
});

app.use(asycn (ctx, next) =&gt; {
    console.log(3);
    await next();
    console.log(4);
});

app.use(asycn (ctx, next) =&gt; {
    console.log(5);
    await next();
    console.log(6);
});

app.listen(3000);

// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>上面的写法我们按照官方推荐，使用了 <code>async/await</code>，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 <code>next</code>，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 <code>Koa</code> 源码中，这一功能是靠一个 <code>compose</code> 方法实现的，我们本文四种实现 <code>compose</code> 的方式中实现同步和异步，并附带对应的案例来验证。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在真正创建 <code>compose</code> 方法之前应该先做些准备工作，比如创建一个 <code>app</code> 对象来顶替 <code>Koa</code> 创建出的实例对象，并添加 <code>use</code> 方法和管理中间件的数组 <code>middlewares</code>。</p>
<p>文件：app.js</p>
<pre><code>// 模拟 Koa 创建的实例
const app = {
    middlewares: []
};

// 创建 use 方法
app.use = function(fn) {
    app.middlewares.push(fn);
};

// app.compose.....

module.exports = app;
</code></pre><p>上面的模块中导出了 <code>app</code> 对象，并创建了存储中间件函数的 <code>middlewares</code> 和添加中间件的 <code>use</code> 方法，因为无论用哪种方式实现 <code>compose</code> 这些都是需要的，只是 <code>compose</code> 逻辑的不同，所以后面的代码块中会只写 <code>compose</code> 方法。</p>
<h2 id="Koa-中-compose-的实现方式"><a href="#Koa-中-compose-的实现方式" class="headerlink" title="Koa 中 compose 的实现方式"></a>Koa 中 compose 的实现方式</h2><p>首先介绍的是 <code>Koa</code> 源码中的实现方式，在 <code>Koa</code> 源码中其实是通过 <code>koa-compose</code> 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 <code>compose</code> 的原理，所以 <code>ctx</code> 参数就被去掉了，因为我们不会使用它，重点是 <code>next</code> 参数。</p>
<h3 id="1、同步的实现"><a href="#1、同步的实现" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    // 递归函数
    function dispatch(index) {
        // 如果所有中间件都执行完跳出
        if (index === app.middlewares.length) return;

        // 取出第 index 个中间件并执行
        const route = app.middlewares[index];
        return route(() =&gt; dispatch(index + 1));
    }

    // 取出第一个中间件函数执行
    dispatch(0);
};
</code></pre><p>上面是同步的实现，通过递归函数 <code>dispatch</code> 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 <code>dispatch</code>，传入的参数 <code>+1</code>，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 <code>1 3 5 6 4 2</code> 的情况执行，测试例子如下（同步上、异步下）。</p>
<p>文件：sync-test.js</p>
<pre><code>const app = require(&quot;./app&quot;);

app.use(next =&gt; {
    console.log(1);
    next();
    console.log(2);
});

app.use(next =&gt; {
    console.log(3);
    next();
    console.log(4);
});

app.use(next =&gt; {
    console.log(5);
    next();
    console.log(6);
});

app.compose();
// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>文件：async-test.js</p>
<pre><code>const app = require(&quot;./app&quot;);

// 异步函数
functionfn() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve();
            console.log(&quot;hello&quot;);
        }, 3000);
    });
}

app.use(async next =&gt; {
    console.log(1);
    await next();
    console.log(2);
});

app.use(async next =&gt; {
    console.log(3);
    await fn(); // 调用异步函数
    await next();
    console.log(4);
});

app.use(async next =&gt; {
    console.log(5);
    await next();
    console.log(6);
});

app.compose();
</code></pre><p>我们发现如果案例中按照 <code>Koa</code> 的推荐写法，即使用 <code>async</code> 函数，都会通过，但是在给 <code>use</code> 传参时可能会传入普通函数或 <code>async</code> 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 <code>Koa</code> 中 <code>compose</code> 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。</p>
<p>注意：后面 <code>compose</code> 的其他实现方式中，都是使用 <code>sync-test.js</code> 和 <code>async-test.js</code> 验证，所以后面就不再重复了。</p>
<h3 id="2、升级为支持异步"><a href="#2、升级为支持异步" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    // 递归函数
    function dispatch(index) {
        // 如果所有中间件都执行完跳出，并返回一个 Promise
        if (index === app.middlewares.length) return Promise.resolve();

        // 取出第 index 个中间件并执行
        const route = app.middlewares[index];

        // 执行后返回成功态的 Promise
        return Promise.resolve(route(() =&gt; dispatch(index + 1)));
    }

    // 取出第一个中间件函数执行
    dispatch(0);
};
</code></pre><p>我们知道 <code>async</code> 函数中 <code>await</code> 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 <code>async-test.js</code>进行测试，发现结果为 <code>1 3 hello(3s后) 5 6 4 2</code>。</p>
<h2 id="Redux-旧版本-compose-的实现方式"><a href="#Redux-旧版本-compose-的实现方式" class="headerlink" title="Redux 旧版本 compose 的实现方式"></a>Redux 旧版本 compose 的实现方式</h2><h3 id="1、同步的实现-1"><a href="#1、同步的实现-1" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    return app.middlewares.reduceRight((a, b) =&gt; () =&gt; b(a), () =&gt; {})();
};
</code></pre><p>上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 <code>middlewares</code> 中存储的三个中间件函数分别为 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于使用的是 <code>reduceRight</code> 方法，所以是逆序归并，第一次 <code>a</code> 代表初始值（空函数），<code>b</code> 代表 <code>fn3</code>，而执行 <code>fn3</code> 返回了一个函数，这个函数再作为下一次归并的 <code>a</code>，而 <code>fn2</code> 作为 <code>b</code>，依次类推，过程如下。</p>
<pre><code>// 第 1 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn3(() =&gt; {});

// 第 2 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn2(() =&gt; fn3(() =&gt; {}));

// 第 3 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {})));
</code></pre><p>由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 <code>fn1</code>，如果调用 <code>next</code> 则会执行 <code>fn2</code>，如果同样调用 <code>next</code> 则会执行 <code>fn3</code>，<code>fn3</code> 已经是最后一个中间件函数了，再次调 <code>next</code> 会执行我们最初传入的空函数，这也是为什么要将 <code>reduceRight</code> 的初始值设置成一个空函数，就是防止最后一个中间件调用 <code>next</code> 而报错。</p>
<p>经过测试上面的代码不会出现顺序错乱的情况，但是在 <code>compose</code> 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 <code>use</code> 的中间件函数既可以是普通函数，又可以是 <code>async</code> 函数，这就要我们的 <code>compose</code> 完全支持异步。</p>
<h3 id="2、升级为支持异步-1"><a href="#2、升级为支持异步-1" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    return Promise.resolve(
        app.middlewares.reduceRight(
            (a, b) =&gt; () =&gt; Promise.resolve(b(a)),
            () =&gt; Promise.resolve();
        )()
    );
};
</code></pre><p>参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 <code>next</code> 后又调用了 <code>then</code>），都处理成了 Promise，保证了 <code>reduceRight</code> 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 <code>async</code> 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 <code>compose</code> 就可以调用 <code>then</code> 方法执行后续逻辑。</p>
<h2 id="Redux-新版本-compose-的实现方式"><a href="#Redux-新版本-compose-的实现方式" class="headerlink" title="Redux 新版本 compose 的实现方式"></a>Redux 新版本 compose 的实现方式</h2><h3 id="1、同步的实现-2"><a href="#1、同步的实现-2" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    return app.middlewares.reduce((a, b) =&gt; arg =&gt; a(() =&gt; b(arg)))(() =&gt; {});
};
</code></pre><p><code>Redux</code> 新版本中将 <code>compose</code> 的逻辑做了些改动，将原本的 <code>reduceRight</code> 换成 <code>reduce</code>，也就是说将逆序归并改为了正序，我们不一定和 <code>Redux</code> 源码完全相同，是根据相同的思路来实现串行中间件的需求。</p>
<p>个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于 <code>reduce</code> 并没有传入初始值，所以此时 <code>a</code> 为 <code>fn1</code>，<code>b</code> 为 <code>fn2</code>。</p>
<pre><code>// 第 1 次 reduce 的返回值，下一次将作为 a
arg =&gt; fn1(() =&gt; fn2(arg));

// 第 2 次 reduce 的返回值，下一次将作为 a
arg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg));

// 等价于...
arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg)));

// 执行最后返回的函数连接中间件，返回值等价于...
fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {})));
</code></pre><p>所以在调用 <code>reduce</code> 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 <code>fn3</code>，也就是第三个中间件，这样保证了在最后一个中间件调用 <code>next</code> 时不会报错。</p>
<h3 id="2、升级为支持异步-2"><a href="#2、升级为支持异步-2" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。</p>
<p>文件：app.js</p>
<pre><code>app.compose = function() {
    return Promise.resolve(
        app.middlewares.reduce((a, b) =&gt; arg =&gt;
            Promise.resolve(a(() =&gt; b(arg)))
        )(() =&gt; Promise.resolve())
    );
};
</code></pre><p>实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 <code>compose</code> 也返回 Promise。</p>
<h2 id="使用-async-函数实现"><a href="#使用-async-函数实现" class="headerlink" title="使用 async 函数实现"></a>使用 async 函数实现</h2><p>这个版本是我在之前在学习 <code>Koa</code> 源码时偶然在一位大佬的一篇分析 <code>Koa</code> 原理的文章中看到的（翻了半天实在没找到链接），在这里也拿出来和大家分享一下，由于是利用 <code>async</code> 函数实现的，所以默认就是支持异步的，因为 <code>async</code> 函数会返回一个 Promise。</p>
<p>文件：app.js</p>
<pre><code>app.compose = function() {
    // 自执行 async 函数返回 Promise
    return (async function () {
        // 定义默认的 next，最后一个中间件内执行的 next
        let next = async () =&gt; Promise.resolve();

        // middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next
        // 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题
        function createNext(middleware, oldNext) {
            return async () =&gt; {
                await middleware(oldNext);
            }
        }

        // 反向遍历中间件数组，先把 next 传给最后一个中间件函数
        // 将新的中间件函数存入 next 变量
        // 调用下一个中间件函数，将新生成的 next 传入
        for (let i = app.middlewares.length - 1; i &gt;= 0; i--) {
            next = createNext(app.middlewares[i], next);
        }

        await next();
    })();
};
</code></pre><p>上面代码中的 <code>next</code> 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 <code>next</code>，而数组 <code>middlewares</code> 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 <code>createNext</code>作用是返回一个新的可以执行数组中最后一个中间件的 <code>async</code> 函数，并传入了初始的 <code>next</code>，这个返回的 <code>async</code> 函数作为新的 <code>next</code>，再取到倒数第二个中间件，调用 <code>createNext</code>，又返回了一个 <code>async</code> 函数，函数内依然是倒数第二个中间件的执行，传入的 <code>next</code> 就是上次新生成的 <code>next</code>，这样依次类推到第一个中间件。</p>
<p>因此执行第一个中间件返回的 <code>next</code> 则会执行传入的上一个生成的 <code>next</code> 函数，就会执行第二个中间件，就会执行第二个中间件中的 <code>next</code>，就这样直到执行完最初定义的的 <code>next</code>，通过案例的验证，执行结果与洋葱模型完全相同。</p>
<p>至于异步的问题，每次执行的 <code>next</code> 都是 <code>async</code> 函数，执行后返回的都是 Promise，而最外层的自执行 <code>async</code> 函数返回的也是 Promise，也就是说 <code>compose</code> 最后返回的是 Promise，因此完全支持异步。</p>
<p>这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>或许你看完这几种方式会觉得，还是 <code>Koa</code> 对于 <code>compose</code> 的实现方式最容易理解，你也可能和我一样在感慨 <code>Redux</code> 的两种实现方式和 <code>async</code> 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想，写出 <code>compose</code> 这种优雅又高逼格的代码，路漫漫其修远兮，愿你在技术的路上 “一去不复返”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/10/koa-bodyparser中间件模拟/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/10/koa-bodyparser中间件模拟/" itemprop="url">koa-bodyparser中间件模拟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-10T23:05:34+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Koa 2.x</code> 版本是当下最流行的 NodeJS 框架，<code>Koa 2.0</code> 的源码特别精简，不像 <code>Express</code> 封装的功能那么多，所以大部分的功能都是由 <code>Koa</code> 开发团队（同 <code>Express</code> 是一家出品）和社区贡献者针对 <code>Koa</code> 对 NodeJS 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 <code>Koa</code> 的 <code>use</code> 方法使用在对应的位置，这样就可以通过在内部操作 <code>ctx</code> 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 <code>Koa</code> 中间件供自己和别人使用。</p>
<h2 id="Koa-的洋葱模型介绍"><a href="#Koa-的洋葱模型介绍" class="headerlink" title="Koa 的洋葱模型介绍"></a>Koa 的洋葱模型介绍</h2><p>我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 API 的使用方式及洋葱模型分析中间件是如何工作的。</p>
<pre><code>// 洋葱模型特点// 引入 Koa
const Koa = require(&quot;koa&quot;);

// 创建服务
const app = new Koa();

app.use(async (ctx, next) =&gt; {
    console.log(1);
    await next();
    console.log(2);
});

app.use(async (ctx, next) =&gt; {
    console.log(3);
    await next();
    console.log(4);
});

app.use(async (ctx, next) =&gt; {
    console.log(5);
    await next();
    console.log(6);
});

// 监听服务
app.listen(3000);

// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>我们知道 <code>Koa</code> 的 <code>use</code> 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 <code>next</code> 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 <code>Koa</code> 中都是建议使用 <code>async/await</code> 的，引入的中间件都是在 <code>use</code> 方法中调用，由此我们可以分析出每一个 <code>Koa</code> 的中间件都是返回一个 <code>async</code> 函数的。</p>
<h2 id="koa-bodyparser-中间件模拟"><a href="#koa-bodyparser-中间件模拟" class="headerlink" title="koa-bodyparser 中间件模拟"></a>koa-bodyparser 中间件模拟</h2><p>想要分析 <code>koa-bodyparser</code> 的原理首先需要知道用法和作用，<code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值，使用前需提前安装。</p>
<blockquote>
<p>npm install koa koa-bodyparser</p>
</blockquote>
<p><strong>koa-bodyparser 具体用法如下：</strong></p>
<pre><code>// koa-bodyparser 的用法
const Koa = require(&quot;koa&quot;);
const bodyParser = require(&quot;koa-bodyparser&quot;);

const app = new Koa();

// 使用中间件
app.use(bodyParser());

app.use(async (ctx, next) =&gt; {
    if (ctx.path === &quot;/&quot; &amp;&amp; ctx.method === &quot;POST&quot;) {
        // 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据
        console.log(ctx.request.body);
    }
});

app.listen(3000);
</code></pre><p>根据用法我们可以看出 <code>koa-bodyparser</code> 中间件引入的其实是一个函数，我们把它放在了 <code>use</code> 中执行，根据 <code>Koa</code> 的特点，我们推断出 <code>koa-bodyparser</code> 的函数执行后应该给我们返回了一个 <code>async</code> 函数，下面是我们模拟实现的代码。</p>
<pre><code>// 文件：my-koa-bodyparser.js
const querystring = require(&quot;querystring&quot;);

module.exports = functionbodyParser() {
    returnasync (ctx, next) =&gt; {
        await new Promise((resolve, reject) =&gt; {
            // 存储数据的数组
            let dataArr = [];

            // 接收数据
            ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data));

            // 整合数据并使用 Promise 成功
            ctx.req.on(&quot;end&quot;, () =&gt; {
                // 获取请求数据的类型 json 或表单
                let contentType = ctx.get(&quot;Content-Type&quot;);

                // 获取数据 Buffer 格式
                let data = Buffer.concat(dataArr).toString();

                if (contentType === &quot;application/x-www-form-urlencoded&quot;) {
                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body
                    ctx.request.body = querystring.parse(data);
                } elseif (contentType === &quot;applaction/json&quot;) {
                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body
                    ctx.request.body = JSON.parse(data);
                }

                // 执行成功的回调
                resolve();
            });
        });

        // 继续向下执行
        await next();
    };
};
</code></pre><p>在上面代码中由几点是需要我们注意的，即 <code>next</code> 的调用以及为什么通过流接收数据、处理数据和将数据挂在 <code>ctx.request.body</code> 要在 Promise 中进行。</p>
<p><strong>首先是 <code>next</code> 的调用，我们知道 <code>Koa</code> 的 <code>next</code> 执行，其实就是在执行下一个中间件的函数，即下一个 <code>use</code> 中的 <code>async</code> 函数，为了保证后面的异步代码执行完毕后再继续执行当前的代码，所以我们需要使用 <code>await</code> 进行等待，其次就是数据从接收到挂在 <code>ctx.request.body</code> 都在 Promise 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 <code>ctx.request.body</code> 上，可以保证我们在下一个 <code>use</code> 的 <code>async</code> 函数中可以在 <code>ctx.request.body</code> 上拿到数据，所以我们使用 <code>await</code> 等待一个 Promise 成功后再执行 <code>next</code>。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/10/基于IntersectionObserver的图片懒加载实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/10/基于IntersectionObserver的图片懒加载实现/" itemprop="url">基于IntersectionObserver的图片懒加载实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-10T21:54:27+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;图片懒加载&lt;/title&gt;</span><br><span class="line">  &lt;link href=&quot;./css/style.css&quot; rel=&quot;stylesheet&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;view&quot;&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://img.pconline.com.cn/images/upload/upc/tx/wallpaper/1301/05/c0/17135331_1357355776882.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://f.hiphotos.baidu.com/zhidao/pic/item/eac4b74543a982267a3d54978a82b9014b90eb86.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://pic1.win4000.com/wallpaper/2/58b61f7dc6c1d.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://file03.16sucai.com/2017/1100/16sucai_p20161106032_0c2.JPG&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://imgsrc.baidu.com/image/c0%3Dpixel_huitu%2C0%2C0%2C294%2C40/sign=5a7938d38acb39dbd5cd6f16b96e6c48/aec379310a55b3196c79de4c48a98226cffc1702.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://c.hiphotos.baidu.com/zhidao/pic/item/8d5494eef01f3a2987a8062f9f25bc315d607ceb.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;link href=&quot;./css/style.css&quot; rel=&quot;stylesheet&quot;/&gt;</span><br><span class="line">&lt;script src=&quot;js/lazy-image.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.documentElement.clientHeight)</span><br><span class="line">  new LazyImage(&apos;.lazy-image&apos;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class LazyImage &#123;</span><br><span class="line">    constructor(selector) &#123;</span><br><span class="line">      // 懒记载图片列表，将伪数组转为数组，以便可以使用数组的api</span><br><span class="line">      this.lazyImages = Array.prototype.slice.call(document.querySelectorAll(selector))</span><br><span class="line">      this.init()</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    inViewShow() &#123;</span><br><span class="line">      // 不支持IntersectionObserver api的情况下判断图片是否出现在可视区域内</span><br><span class="line">      let len = this.lazyImages.length</span><br><span class="line">      for(let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let lazyImage = this.lazyImages[i]</span><br><span class="line">        const rect = lazyImage.getBoundingClientRect()</span><br><span class="line">        // 出现在视野的时候加载图片</span><br><span class="line">        if(rect.top &lt; document.documentElement.clientHeight) &#123;</span><br><span class="line">          lazyImage.src = lazyImage.dataset.src</span><br><span class="line">          // 移除掉已经显示的</span><br><span class="line">          this.lazyImages.splice(i, 1)</span><br><span class="line">          len--</span><br><span class="line">          i--</span><br><span class="line">          if(this.lazyImages.length === 0) &#123;</span><br><span class="line">            // 如果全部都加载完 则去掉滚动事件监听</span><br><span class="line">            document.removeEventListener(&apos;scroll&apos;, this._throttleFn)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    throttle(fn, delay = 15, mustRun = 30) &#123;</span><br><span class="line">      let t_start = null</span><br><span class="line">      let timer = null</span><br><span class="line">      let context = this</span><br><span class="line">      return function() &#123;</span><br><span class="line">        let t_current = +(new Date())</span><br><span class="line">        let args = Array.prototype.slice.call(arguments)</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        if(!t_start) &#123;</span><br><span class="line">          t_start = t_current</span><br><span class="line">        &#125;</span><br><span class="line">        if(t_current - t_start &gt; mustRun) &#123;</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">          t_start = t_current</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    init() &#123;</span><br><span class="line">      // 通过IntersectionObserver api判断图片是否出现在可视区域内，不需要监听Scroll来判断</span><br><span class="line">      if (&quot;IntersectionObserver&quot; in window) &#123;</span><br><span class="line">        let lazyImageObserver = new IntersectionObserver((entries, observer) =&gt; &#123;</span><br><span class="line">          entries.forEach((entry, index) =&gt; &#123;</span><br><span class="line">            // 如果元素可见</span><br><span class="line">            if (entry.isIntersecting) &#123;</span><br><span class="line">              let lazyImage = entry.target</span><br><span class="line">              lazyImage.src = lazyImage.dataset.src</span><br><span class="line">              lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">              // this.lazyImages.splice(index, 1)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.lazyImages.forEach(function(lazyImage) &#123;</span><br><span class="line">          lazyImageObserver.observe(lazyImage);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.inViewShow()</span><br><span class="line">        this._throttleFn = this.throttle(this.inViewShow)</span><br><span class="line">        document.addEventListener(&apos;scroll&apos;, this._throttleFn)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html,body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  width: 100%;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#view &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 300px</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.lazy-image &#123;</span><br><span class="line">  background: url(&apos;../img/loading.gif&apos;) no-repeat center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img&#123;</span><br><span class="line">  margin-top: 100px;</span><br><span class="line">  background-size: cover;</span><br><span class="line">  background-position: center;</span><br><span class="line">  width: 490px;</span><br><span class="line">  height: 242px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">79</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


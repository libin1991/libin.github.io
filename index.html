<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LuckDay</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/01/从你在浏览器输入一个网址.../">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/从你在浏览器输入一个网址.../" itemprop="url">从你在浏览器输入一个网址....</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T18:35:10+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们在面试的时候或许经常会被问到：</p>
<blockquote>
<p>从你在浏览器输入一个网址到网页内容完全被展示的这段时间内，都发生了什么事情？</p>
</blockquote>
<p>确实是个老生常谈的问题，但问题的答案并不是唯一的，或许在三五年前，这个问题还会有一个「相对」标准的答案。</p>
<ol>
<li>浏览器在接收到这个请求时，会开启一个单独的线程来处理这个请求，首先要判断用户输入是否为合法或合理的 URL 地址，是否为 HTTP 协议请求，如果是那就进入下一步</li>
<li>浏览器的浏览器引擎将对此 URL 进行分析加载</li>
<li>通过 DNS 解析域名获取该网站地址对应的 IP 地址，查询完成后连同浏览器的 Cookie、 userAgent 等信息向网站目的 IP 发出 GET 请求。</li>
<li>接下来就是经典的「三次握手」，HTTP 协议会话，浏览器客户端向 Web 服务器发送报文，进行通讯和数据传输。</li>
<li>进入网站的后端服务，如 Tomcat、Apache 等，还有近几年流行的 Node.js 服务器，这些服务器上部署着应用代码，语言有很多，如 Java、 PHP、 C++、 C# 和 Javascript 等。</li>
<li>服务器根据 URL 执行相应的后端应用逻辑，整理数据组装成一个完整的 HTML 数据返回给浏览器，期间会使用到「服务器缓存」或「数据库」内的内容。</li>
<li>浏览器接收到返回信息后先判读此 HTML 文件是否存在本地缓存，如果不存在或不可用，则下载此 HTML 文件（200状态码），如果可用（未过期），则走浏览器缓存（304返回码）。「强缓存（200返回码）不在考虑范围」</li>
<li>浏览器的渲染引擎在拿到 HTML 文件后，便开始解析构建 DOM 数，并根据 HTML 中的标记请求下载指定的 MIME 类型文件（如 CSS、 JavaScript 脚本等），同时使用&amp;设置缓存等内容。</li>
<li>渲染引擎根据 CSS 样式规则将 DOM 树扩充为渲染树，然后进行重排、重绘。</li>
<li>如果含有 JS 文件将会执行，进行 Dom 操作、缓存读存、时间绑定等操作。最终页面将被展示在浏览器上。</li>
</ol>
<p>此答案精简的概括了「后端为主的 MVC 模式」及早期 Web 应用的浏览器相应的全过程。那，前端技术发展到现在，「前后端分离」「中间件直出」和「MNV*模式」也已问世，再谈及此问题，答案会有不同。</p>
<p>就以「前后端分离」为例，在上方答案的第4步后，紧接着就不会直接进入后端服务器了。而会被 HTTP 和反向代理服务器，如 Ngnix，代替。</p>
<ul>
<li>前置步骤1、2、3、4</li>
<li>Ngnix 在接收到 HTTP（80端口）或 HTTPS（443端口）后，根据 URL 做服务器分发，分发（rewrite）到后端服务器或静态资源服务器，首页请求基本是静态服务器，返回一个静态的 HTML 文件</li>
<li>步骤7、8、9</li>
<li>执行 JS 脚本，异步 ajax、 fetch 发起 POST、 GET 请求，重新进入 Ngnix 分发，此次分发到后端服务器，步骤5、6，然后返回一个 xml 或 json 格式的信息，一般含有 code（返回码）、result（依赖信息）</li>
<li>最后根据返回码执行不同的 js 逻辑，增删改页面元素，此时可能会发生重排或重汇。首页加载结束。</li>
</ul>
<p>以上步骤可以发现，浏览器可能会触发重绘两次，极易发生「白屏」或「页面抖动」，为了解决这个问题「中间件直出」的模式应运而生。另外为了扩充大前端的阵营，吸纳 IOS 和 Android，Google又设计了「MNV*模式」，典型代表就是 ReactNative，但此模式已经脱离了浏览器的范畴，此处就不再做扩展。</p>
<p>以上讨论的渲染过程中使用到了较多的浏览器功能，如用户地址栏输入框、网络请求、浏览器文档解析、渲染引擎渲染网页、 JavaScript 引擎执行js脚本、客户端存储等。 接下来我们介绍下浏览器的基本结构组成。</p>
<h2 id="浏览器的结构组成"><a href="#浏览器的结构组成" class="headerlink" title="浏览器的结构组成"></a>浏览器的结构组成</h2><p>浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储） 如下图：</p>
<p><img src="https://pic1.zhimg.com/v2-47101c25a44a21a25f3123a88c623b15_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-47101c25a44a21a25f3123a88c623b15_hd.jpg" alt=""></p>
<ul>
<li>用户界面－包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了页面显示窗口之外的其他部分</li>
<li>浏览器引擎－可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心</li>
<li>渲染引擎－解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎</li>
<li>网络－用来完成网络调用或资源下载的模块</li>
<li>UI 后端－用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的效果也不同</li>
<li>JS解释器－用来解释执行JS脚本的模块，如 V8 引擎</li>
<li>数据存储－浏览器在硬盘中保存 cookie、localStorage等各种数据，可通过浏览器引擎提供的API进行调用</li>
</ul>
<p>作为前端开发人员，我们需要重点理解渲染引擎的工作原理，灵活应用数据存储技术，在实际项目开发中会经常涉及到这两个部分，尤其是在做项目性能优化时，理解浏览器渲染引擎尤为重要。而其他部分则是由各种浏览器自行管理的，开发者能控制的地方较少。今天我们就围绕这两个重点其中的一个部分「浏览器渲染引擎」进行展开</p>
<h2 id="浏览器渲染引擎"><a href="#浏览器渲染引擎" class="headerlink" title="浏览器渲染引擎"></a>浏览器渲染引擎</h2><p>浏览器渲染引擎是由各大浏览器厂商依照 W3C 标准自行实现的，也被称之为「浏览器内核」。</p>
<p>目前，市面上使用的主流浏览器内核有5类：Trident、Gecko、Presto、Webkit、Blink。</p>
<p>Trident：俗称 IE 内核，也被叫做 MSHTML 引擎，目前在使用的浏览器为 IE11-，以及各种国产多核浏览器中的IE兼容模式。另外Edge 浏览器不再使用 MSHTML 引擎，而是使用类全新的引擎 EdgeHTML。</p>
<p>Gecko：俗称 Firefox 内核，Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。</p>
<p>Presto：Opera 前内核，为啥说是前内核呢？因为 Opera12.17 以后便拥抱了 Google Chrome 的 Blink 内核，此内核就没了寄托</p>
<p>Webkit：Safari 内核也是 Chrome 内核原型，主要是 Safari 浏览器在使用的内核，也是特性上表现较好的浏览器内核。也被大量使用在移动端浏览器上。</p>
<p>Blink： 由Google和Opera Software开发的浏览器排版引擎，在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器 中使用。Blink 其实是 WebKit 的一个分支，添加了一些优化的新特性，例如跨进程的 iframe，将 DOM 移入 JavaScript 中来提高 JavaScript 对 DOM 的访问速度等，目前较多的移动端应用内嵌的浏览器内核也渐渐开始采用 Blink。</p>
<h2 id="渲染引擎的工作流程"><a href="#渲染引擎的工作流程" class="headerlink" title="渲染引擎的工作流程"></a>渲染引擎的工作流程</h2><p>浏览器渲染引擎重要的工作就是将 HTML 和 CSS 文档解析组合最终渲染到浏览器窗口上。如下图所示，渲染引擎在接受到 HTML 文件后主要进行了以下操作：解析 HTML 构建 DOM 树 -&gt; 构建渲染树 -&gt; 渲染树布局 -&gt; 渲染树绘制。</p>
<p><img src="https://pic2.zhimg.com/v2-898d192f36fcc9c8843ec9d89f112bde_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-898d192f36fcc9c8843ec9d89f112bde_hd.jpg" alt=""></p>
<p>解析 HTML 构建 DOM 树时渲染引擎会将 HTML 文件的便签元素解析成多个 DOM 元素对象节点，并且将这些对象根据父子关系组成一个树结构。同时 CSS 文件被解析成 CSS规则表，然后将每条 CSS 规则按照「从右向左」的方式在 DOM 树上进行逆向匹配，生成一个具有样式规则描述的 DOM 渲染树。接下来就是将渲染树进行布局、绘制的过程。首先根据 DOM 渲染树上的样式规则，对 DOM 元素进行大小和位置的定位，关键属性如<code>position;width;margin;padding;top;border;...</code>，接下来在根据元素样式规则中的<code>color;background;shadow;...</code>规则进行 DOM 的绘制。</p>
<p>另外，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<p>再者，需要注意的是，在浏览器渲染完首屏页面后，如果对 DOM 进行操作会引起浏览器引擎对 DOM 渲染树的重新布局和重新绘制，我们叫做「重排」和「重绘」，由于重排和重绘是前后依赖的关系，所以重绘发生时未必会触发渲染引擎的重排，但是如果发生了重排就必然会触发重绘操作，这样带来的性能损害就是巨大的。因此我们在做性能优化的时候应该遵循「避免重排；减少重绘」的原则。</p>
<h2 id="不同浏览器内核间的差异"><a href="#不同浏览器内核间的差异" class="headerlink" title="不同浏览器内核间的差异"></a>不同浏览器内核间的差异</h2><p>在不同的浏览器内核下， 浏览器页面渲染的流程略有不同</p>
<p><img src="https://pic2.zhimg.com/v2-d29985fb1443ee3dc499a2b974f52c0e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-d29985fb1443ee3dc499a2b974f52c0e_hd.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-17090b8745e504fd6877dfa6f5950422_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-17090b8745e504fd6877dfa6f5950422_hd.jpg" alt=""></p>
<p>上面两幅图分别是 Webkit 和 Geoko 内核渲染 DOM 的工作流程，对比可以看出，两者流程的区别主要在于 CSS 样式表的解析时机，Webkit 内核下，HTML 和 CSS 文件的解析是同步的，而 Geoko 内核下，CSS 文件需要等到 HTML 文件解析成内容 Sink 后才进行解析。</p>
<p>另外两者的不同还有描述术语，除此之外两者的流程就基本相同了，其中最重要的三个部分就是 「HTML 的解析」「CSS 的解析」「渲染树的生成」。这三个部分的原理内容就比较深，涉及到「词法分析」「语法分析」「转换」「解释」等数据结构的内容，比较枯燥，一般我们了解到这里就够了，不过想深入了解的同学可以阅读此篇译文，<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fblog.csdn.net%252Fu010794365%252Farticle%252Fdetails%252F77982768" target="_blank" rel="noopener">浏览器的工作原理</a>，里面详细的解释了以上三个部分的流程和关系。此处就不再多做赘述了。</p>
<h2 id="关于-CSS-规则的匹配"><a href="#关于-CSS-规则的匹配" class="headerlink" title="关于 CSS 规则的匹配"></a>关于 CSS 规则的匹配</h2><p>上面我们提到过， CSS 规则是按照「从右向左」的方式在 DOM 树上进行逆向匹配的，最终生成一个具有样式规则描述的 DOM 渲染树。</p>
<p>但是你知道为什么要「从右向左」做逆向匹配码？</p>
<p>我们重新回到【webkit 内核工作流程】图</p>
<p><img src="https://pic2.zhimg.com/v2-d29985fb1443ee3dc499a2b974f52c0e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-d29985fb1443ee3dc499a2b974f52c0e_hd.jpg" alt=""></p>
<p>CSS 规则匹配是发生在webkit引擎的「Attachment」过程中，浏览器要为每个 DOM Tree 中的元素扩充 CSS 样式规则（匹配 Style Rules）。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。</p>
<p>我们来举一个最简单的栗子：</p>
<pre><code>&lt;template&gt;
&lt;div&gt;
  &lt;div class=&quot;t&quot;&gt;
    &lt;span&gt;test&lt;/span&gt;
    &lt;p&gt;test&lt;/p&gt;
  &lt;div&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
div{ color: #000; }
div .t span{ color: red; }
div .t p{color: blue; }
&lt;/style&gt;
</code></pre><p>此处我们有一个 html 元素 和一个 style 元素，两者需要做遍历匹配</p>
<p><img src="https://pic1.zhimg.com/v2-727bdb01745d4f9692a5f7a8678e62e2_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-727bdb01745d4f9692a5f7a8678e62e2_hd.jpg" alt=""></p>
<p>此处会有 4*3 个匹配项，如果做正向匹配，在遇到 <code>&lt;span&gt;</code> 标签匹配 <code>div .t p{ color: red; }</code>到匹配项时，显然时不通过到，计算机首先要找到<code>&lt;span&gt;</code> 标签到父标签和祖父标签，判断他们是否满足<code>div .t</code>的规则，然后在匹配<code>&lt;span&gt;</code>是否为<code>p</code>标签，此处匹配不成功，此处就产生了三次浪费。</p>
<p>如果时逆向匹配，那么第一次对比<code>&lt;span&gt;</code>是否为<code>p</code>标签便可排除此规则，效率更高。</p>
<p>如果将 HTML 结构变复杂，CSS 规则表变庞大，那么，「逆向匹配」的优势就远大于「正向匹配」了，因为匹配的情况远远低于不匹配的情况。同时如果在选择器结尾加上通配符「*」，那么「逆向匹配」的优势就大打折扣，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。</p>
<p>极限了想，如果我们的样式表不存在嵌套关系，如下：</p>
<pre><code>&lt;template&gt;
&lt;div&gt;
  &lt;div&gt;
    &lt;span class=&quot;div_t_span&quot;&gt;test&lt;/span&gt;
    &lt;p class=&quot;div_t_p&quot;&gt;test&lt;/p&gt;
  &lt;div&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;style&gt;
div{ color: #000; }
.div_t_span{ color: red; }
.div_t_p{color: blue; }
&lt;/style
</code></pre><p>那么引擎的「Attachment」过程将得到极大的精简，效率也是可想而知的，这就是为什么「微信小程序」样式表不建议使用关系行写法的原因。</p>
<h2 id="相关的性能优化"><a href="#相关的性能优化" class="headerlink" title="相关的性能优化"></a>相关的性能优化</h2><p>由以上介绍，我们大致可以在案例中看到同浏览器渲染引擎相关的可行优化点。</p>
<p>大致为以下几种</p>
<ol>
<li>减少 JS 加载对 Dom 渲染的影响：将 JS 文件放在 HTML 文档后加载，或者使用异步的方式加载 JS 代码</li>
<li>避免重排，减少重绘：在做css动画的时候减少使用 width、 margin、 padding等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替</li>
<li>减少使用关系型样式表的写法：直接使用唯一的类名即可最大限度的提升渲染效率</li>
<li>减少 DOM 的层级：减少无意义的dom 层级可以减少 渲染引擎 Attachment 过程中的匹配计算量</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/深入理解ES6  Async Functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/深入理解ES6  Async Functions/" itemprop="url">深入理解ES6 Async Functions (异步函数)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T18:35:10+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="async-异步-函数变体"><a href="#async-异步-函数变体" class="headerlink" title="async(异步) 函数变体"></a>async(异步) 函数变体</h2><p>以下是已经存在的异步函数变体。请注意无处不在的 <code>async</code> 关键字。</p>
<ul>
<li>异步函数声明： <code>async function foo() {}</code></li>
<li>异步函数表达式： <code>const foo = async function () {};</code></li>
<li>异步函数定义：<code>let obj = { async foo() {} }</code></li>
<li>异步箭头函数： <code>const foo = async () =&gt; {};</code></li>
</ul>
<h2 id="async-异步-函数总是返回-Promises"><a href="#async-异步-函数总是返回-Promises" class="headerlink" title="async(异步) 函数总是返回 Promises"></a>async(异步) 函数总是返回 Promises</h2><p>async(异步) 函数的 Promise 完成状态：</p>
<pre><code>async function asyncFunc() {
return 123;
}

asyncFunc()
.then(x =&gt; console.log(x));
// 123
</code></pre><p>async(异步) 函数的 Promise 拒绝状态：</p>
<pre><code>async function asyncFunc() {
throw new Error(&apos;Problem!&apos;);
}

asyncFunc()
.catch(err =&gt; console.log(err));
// Error: Problem!
</code></pre><h2 id="通过-await-处理-async-异步-计算的结果和错误"><a href="#通过-await-处理-async-异步-计算的结果和错误" class="headerlink" title="通过 await 处理 async(异步) 计算的结果和错误"></a>通过 <code>await</code> 处理 async(异步) 计算的结果和错误</h2><p><code>await</code>（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise 返回：</p>
<ul>
<li>如果 Promise 是完成状态，<code>await</code> 的结果是完成态的值。</li>
<li>如果 Promise 是拒绝状态，<code>await</code> 会抛出拒绝值。</li>
</ul>
<p>处理单个 async(异步) 返回值：</p>
<pre><code>async function asyncFunc() {
const result = await otherAsyncFunc();
   console.log(result);
}

// 等价于:
function asyncFunc() {
return otherAsyncFunc()
.then(result =&gt; {
       console.log(result);
});
}
</code></pre><p>按顺序处理多个 async(异步) 返回值：</p>
<pre><code>async function asyncFunc() {
const result1 = await otherAsyncFunc1();
   console.log(result1);
const result2 = await otherAsyncFunc2();
   console.log(result2);
}

// 等价于:
function asyncFunc() {
return otherAsyncFunc1()
.then(result1 =&gt; {
       console.log(result1);
return otherAsyncFunc2();
})
.then(result2 =&gt; {
       console.log(result2);
});
}
</code></pre><p>并行处理多个 async(异步) 返回值：</p>
<pre><code>async function asyncFunc() {
const [result1, result2] = await Promise.all([
       otherAsyncFunc1(),
       otherAsyncFunc2(),
]);
   console.log(result1, result2);
}

// 等价于:
function asyncFunc() {
return Promise.all([
       otherAsyncFunc1(),
       otherAsyncFunc2(),
])
.then([result1, result2] =&gt; {
       console.log(result1, result2);
});
}
</code></pre><p>错误处理：</p>
<pre><code>async function asyncFunc() {
try {
await otherAsyncFunc();
} catch (err) {
       console.error(err);
}
}

// 等价于:
function asyncFunc() {
return otherAsyncFunc()
.catch(err =&gt; {
       console.error(err);
});
}
</code></pre><h2 id="理解-async-异步-函数"><a href="#理解-async-异步-函数" class="headerlink" title="理解 async(异步) 函数"></a>理解 async(异步) 函数</h2><p>在我解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。</p>
<p>对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 <a href="https://link.zhihu.com/?target=https%3A//fetch.spec.whatwg.org/%23concept-request" target="_blank" rel="noopener">客户端 fetch API</a> ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下：</p>
<pre><code>function fetchJson(url) {
return fetch(url)
.then(request =&gt; request.text())
.then(text =&gt; {
return JSON.parse(text);
})
.catch(error =&gt; {
       console.log(`ERROR: ${error.stack}`);
});
}
fetchJson(&apos;http://example.com/some_file.json&apos;)
.then(obj =&gt; console.log(obj));
</code></pre><h2 id="通过-generator-来编写异步代码"><a href="#通过-generator-来编写异步代码" class="headerlink" title="通过 generator 来编写异步代码"></a>通过 generator 来编写异步代码</h2><p>co 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同：</p>
<pre><code>const fetchJson = co.wrap(function* (url) {
try {
let request = yield fetch(url);
let text = yield request.text();
return JSON.parse(text);
}
catch (error) {
       console.log(`ERROR: ${error.stack}`);
}
});
</code></pre><p>每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，<code>yield</code> 返回完成状态的值，如果处于拒绝状态，<code>yield</code> 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于 <code>then()</code> 所做的工作）。</p>
<h2 id="通过-async-异步-函数来编写异步代码"><a href="#通过-async-异步-函数来编写异步代码" class="headerlink" title="通过 async(异步) 函数来编写异步代码"></a>通过 async(异步) 函数来编写异步代码</h2><p>async(异步) 函数用的特定语法基本上和 co 类似：</p>
<pre><code>async function fetchJson(url) {
try {
let request = await fetch(url);
let text = await request.text();
return JSON.parse(text);
}
catch (error) {
       console.log(`ERROR: ${error.stack}`);
}
}
</code></pre><p>在内部，异步函数写法更类似于 generators 。</p>
<h2 id="以同步开始，异步处理的-async-异步-函数"><a href="#以同步开始，异步处理的-async-异步-函数" class="headerlink" title="以同步开始，异步处理的 async(异步) 函数"></a>以同步开始，异步处理的 async(异步) 函数</h2><p>以下是 async(异步)函数是如何工作的：</p>
<ol>
<li>async(异步) 函数总是返回一个 Promise 对象 <code>p</code> 。Promise 对象在 async(异步) 函数开始执行时被创建。</li>
<li>函数体执行过程中，可以通过 <code>return</code> 或 <code>throw</code> 终止执行。或者通过 <code>await</code> 暂停执行，在这种情况下，通常会在以后继续执行。</li>
<li>返回 Promise 对象 <code>p</code>。</li>
</ol>
<p>当执行 async(异步) 函数的函数体时，<code>return x</code> 中的 <code>x</code> 是 Promise 对象 <code>p</code> 的完成状态的结果，而 <code>throw err</code> 是 <code>p</code> 的拒绝状态的结果。执行结果是异步返回的。换句话说：<code>then()</code> 和 <code>catch()</code> 的回调总是在当前代码完成后执行。</p>
<p>以下是代码示例：</p>
<pre><code>async function asyncFunc() {
   console.log(&apos;asyncFunc()&apos;); // (A)
return &apos;abc&apos;;
}
asyncFunc().
then(x =&gt; console.log(`Resolved: ${x}`)); // (B)
console.log(&apos;main&apos;); // (C)

// Output:
// asyncFunc()
// main
// Resolved: abc
</code></pre><p>您可以认为是以下的执行顺序：</p>
<ol>
<li>行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 <code>return</code> 来返回完成状态的结果。</li>
<li>行C：执行继续。</li>
<li>行B：Promise 完成状态通知是异步发生的。</li>
</ol>
<h2 id="返回不被包裹的-Promise-对象"><a href="#返回不被包裹的-Promise-对象" class="headerlink" title="返回不被包裹的 Promise 对象"></a>返回不被包裹的 Promise 对象</h2><p>Promise 的 resolve 是一项标准操作。 <code>return</code> 就是使用它来 resolve async(异步) 函数的 Promise <code>p</code> 的。这意味着：</p>
<ol>
<li>返回一个非 Promise 值，该值将被处理成 <code>p</code> 的完成状态值。</li>
<li>返回一个 Promise 对象，那么 <code>p</code> 此时相当于是该 Promise 的状态。</li>
</ol>
<p>因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：</p>
<pre><code>async function asyncFunc() {
return Promise.resolve(123);
}
asyncFunc()
.then(x =&gt; console.log(x)) // 123
</code></pre><p>有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 <code>throw</code> ）：</p>
<pre><code>async function asyncFunc() {
return Promise.reject(new Error(&apos;Problem!&apos;));
}
asyncFunc()
.catch(err =&gt; console.error(err)); // Error: Problem!
</code></pre><p>这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 <code>await</code> 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：</p>
<pre><code>async function asyncFunc() {
return anotherAsyncFunc();
}
</code></pre><p>上面的代码示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹 <code>anotherAsyncFunc()</code> 的 Promise ，而是包裹 <code>anotherAsyncFunc()</code> 本身 ）：</p>
<pre><code>async function asyncFunc() {
return await anotherAsyncFunc();
}
</code></pre><h2 id="使用-await-小贴士"><a href="#使用-await-小贴士" class="headerlink" title="使用 await 小贴士"></a>使用 <code>await</code> 小贴士</h2><h2 id="不要忘记使用-await"><a href="#不要忘记使用-await" class="headerlink" title="不要忘记使用 await"></a>不要忘记使用 <code>await</code></h2><p>在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 <code>await</code> ：</p>
<pre><code>async function asyncFunc() {
const value = otherAsyncFunc(); // missing `await`!
···
}
</code></pre><p>在这个例子中，方法执行返回的 Promise 对象赋值给了 <code>value</code> ，它通常不是你在 async(异步) 函数中想要的结果。</p>
<p>await 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：</p>
<pre><code>async function foo() {
await step1(); // (A)
···
}
</code></pre><p>行A中的 <code>await</code> 确保在执行 <code>foo()</code> 剩余部分之前， <code>step1()</code> 已经执行完成。</p>
<h2 id="不需要使用-await-的情况"><a href="#不需要使用-await-的情况" class="headerlink" title="不需要使用 await 的情况"></a>不需要使用 await 的情况</h2><p>有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：</p>
<pre><code>async function asyncFunc() {
const writer = openFile(&apos;someFile.txt&apos;);
   writer.write(&apos;hello&apos;); // don’t wait
   writer.write(&apos;world&apos;); // don’t wait
await writer.close(); // wait for file to close
}
</code></pre><p>在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。</p>
<p><code>asyncFunc()</code> 函数最后一行的 <code>await</code> 确保该函数仅在文件写入关闭后才会执行。</p>
<p>由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 <code>return</code> 替换 <code>await writer.close()</code> ：</p>
<pre><code>async function asyncFunc() {
const writer = openFile(&apos;someFile.txt&apos;);
   writer.write(&apos;hello&apos;);
   writer.write(&apos;world&apos;);
return writer.close();
}
</code></pre><p>这两个版本各有利弊，<code>await</code> 版本可能稍微更容易理解。</p>
<h2 id="await-是顺序执行的，Promise-all-是并行的"><a href="#await-是顺序执行的，Promise-all-是并行的" class="headerlink" title="await 是顺序执行的，Promise.all() 是并行的"></a>await 是顺序执行的，Promise.all() 是并行的</h2><p>下面的代码调用了两个 async(异步) 函数， <code>asyncFunc1()</code> 和 <code>asyncFunc1()</code> 。</p>
<pre><code>async function foo() {
const result1 = await asyncFunc1();
const result2 = await asyncFunc2();
}
</code></pre><p>这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ：</p>
<pre><code>async function foo() {
const [result1, result2] = await Promise.all([
       asyncFunc1(),
       asyncFunc2(),
]);
}
</code></pre><p>我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。</p>
<h2 id="异步函数和回调"><a href="#异步函数和回调" class="headerlink" title="异步函数和回调"></a>异步函数和回调</h2><p>async(异步) 函数的一个限制是 <code>await</code>(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 <code>await</code>(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 <code>map()</code> 和 <code>forEach()</code>。</p>
<h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><p>我们从数组方法 <code>map()</code> 开始讲解。在下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。</p>
<pre><code>async function downloadContent(urls) {
return urls.map(url =&gt; {
// 错误的语法!
const content = await httpGet(url);
return content;
});
}
</code></pre><p>这不起作用，因为在正常箭头函数中 <code>await</code> 语法上是非法的(愚人码头注： <code>await</code>(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？</p>
<pre><code>async function downloadContent(urls) {
return urls.map(async (url) =&gt; { // 注意这一行中的 async ;
const content = await httpGet(url);
return content;
});
}
</code></pre><p>这段代码有两个问题：</p>
<ul>
<li>现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。</li>
<li>一旦 <code>map()</code> 执行完成，回调执行的工作并不能同时完成，因为 <code>await</code> 只暂停了包裹它的箭头函数 和 <code>httpGet()</code> 异步执行达到完成状态。这意味着你不能使用 <code>await</code>，来等待 <code>downloadContent()</code> 执行结束。</li>
</ul>
<p>我们可以通过 <code>Promise.all()</code> 来解决这两个问题，<code>Promise.all()</code> 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：</p>
<pre><code>async function downloadContent(urls) {
const promiseArray = urls.map(async (url) =&gt; {
const content = await httpGet(url);
return content;
});
return await Promise.all(promiseArray);
}
</code></pre><p><code>map()</code> 的回调并不对 <code>httpGet()</code> 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。</p>
<pre><code>async function downloadContent(urls) {
const promiseArray = urls.map(
       url =&gt; httpGet(url));
return await Promise.all(promiseArray);
}
</code></pre><p>我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 <code>await</code> 来解开 <code>Promise.all()</code> 的结果，然后通过 <code>return</code> 再次包裹它。 假设 <code>return</code> 不包裹 Promises，我们可以直接返回 <code>Promise.all()</code> 的结果：</p>
<pre><code>async function downloadContent(urls) {
const promiseArray = urls.map(
       url =&gt; httpGet(url));
return Promise.all(promiseArray);
}
</code></pre><h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h2><p>我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：</p>
<pre><code>async function logContent(urls) {
   urls.forEach(url =&gt; {
// Wrong syntax
const content = await httpGet(url);
       console.log(content);
});
}
</code></pre><p>同样的，这里的代码会产生一个语法错误，因为你不能在通常的箭头函数内部使用 <code>await</code> 。</p>
<p>我们换作异步箭头函数：</p>
<pre><code>async function logContent(urls) {
   urls.forEach(async url =&gt; {
const content = await httpGet(url);
       console.log(content);
});
// Not finished here
}
</code></pre><p>这段代码起作用了，但是会出现一个警告：<code>httpGet()</code> 返回的 Promise 对象是异步完成的，这也意味着当 <code>forEach()</code> 返回的时候回调可能还没有结束，因此你无法等到 <code>logContent()</code> 只能结束。</p>
<p>如果你并不想要这个结果，你可以将 <code>forEach()</code> 转换为 <code>for-of</code> 循环。</p>
<pre><code>async function logContent(urls) {
for (const url of urls) {
const content = await httpGet(url);
       console.log(content);
}
}
</code></pre><p>现在一切都在 <code>for-of</code> 循环完成后完成。但是，处理步骤依次发生：<code>httpGet()</code> 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 <code>Promise.all()</code>：</p>
<pre><code>async function logContent(urls) {
await Promise.all(urls.map(
async url =&gt; {
const content = await httpGet(url);
           console.log(content);
}));
}
</code></pre><p><code>map()</code> 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 <code>await</code>(等待) 所有方法执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 <code>Promise.all()</code> ，但是该函数的结果是一个数组，其元素都是未完成状态的。</p>
<h2 id="使用异步函数小贴士"><a href="#使用异步函数小贴士" class="headerlink" title="使用异步函数小贴士"></a>使用异步函数小贴士</h2><h2 id="了解你的-Promises"><a href="#了解你的-Promises" class="headerlink" title="了解你的 Promises"></a>了解你的 Promises</h2><p>async(异步) 函数的基础就是 <a href="https://link.zhihu.com/?target=http%3A//exploringjs.com/es6/ch_promises.html" target="_blank" rel="noopener">Promises</a> 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。</p>
<p>举个例子，这里有个 “promisified” 版本的 <code>XMLHttpRequest</code> ：</p>
<pre><code>function httpGet(url, responseType=&quot;&quot;) {
return new Promise(
function (resolve, reject) {
const request = new XMLHttpRequest();
           request.onload = function () {
if (this.status === 200) {
// Success
                   resolve(this.response);
} else {
// Something went wrong (404 etc.)
                   reject(new Error(this.statusText));
}
};
           request.onerror = function () {
               reject(new Error(
&apos;XMLHttpRequest Error: &apos;+this.statusText));
};
           request.open(&apos;GET&apos;, url);
           xhr.responseType = responseType;
           request.send();
});
}
</code></pre><p>XMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 <code>return</code> 或者 <code>throw</code> 来完成这样的操作。你不能从回调函数内部 <code>return</code> 一个函数的结果。<code>throw</code>也有类似的约束。</p>
<p>因此，异步函数的通用编码风格是：</p>
<ul>
<li>直接使用 Promise 对象来构建异步原语。</li>
<li>用异步函数来使用这些原语。</li>
</ul>
<p>扩展阅读：“Exploring ES6” 中的 “<a href="https://link.zhihu.com/?target=http%3A//exploringjs.com/es6/ch_promises.html" target="_blank" rel="noopener">异步编程中的 Promises 对象</a>” 章节</p>
<h2 id="立即调用异步函数表达式"><a href="#立即调用异步函数表达式" class="headerlink" title="立即调用异步函数表达式"></a>立即调用异步函数表达式</h2><p>有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 <code>main()</code> 并立即调用它：</p>
<pre><code>async function main() {
   console.log(await asyncFunction());
}
main();
</code></pre><p>或者您可以使用立即调用异步函数表达式：</p>
<pre><code>(async function () {
   console.log(await asyncFunction());
})();
</code></pre><p>另一个选择是立即调用异步箭头函数：</p>
<pre><code>(async () =&gt; {
   console.log(await asyncFunction());
})();
</code></pre><h2 id="用异步函数进行单元测试"><a href="#用异步函数进行单元测试" class="headerlink" title="用异步函数进行单元测试"></a>用异步函数进行单元测试</h2><p>以下代码使用 <a href="https://link.zhihu.com/?target=https%3A//mochajs.org/" target="_blank" rel="noopener">测试框架 mocha</a> 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试：</p>
<pre><code>import assert from &apos;assert&apos;;

// Bug: the following test always succeeds
test(&apos;Testing async code&apos;, function () {
   asyncFunc1() // (A)
.then(result1 =&gt; {
assert.strictEqual(result1, &apos;a&apos;); // (B)
return asyncFunc2();
})
.then(result2 =&gt; {
assert.strictEqual(result2, &apos;b&apos;); // (C)
});
});
</code></pre><p>然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。</p>
<p>你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。</p>
<pre><code>return asyncFunc1() // (A)
</code></pre><p>异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：</p>
<pre><code>import assert from &apos;assert&apos;;
test(&apos;Testing async code&apos;, async function () {
const result1 = await asyncFunc1();
assert.strictEqual(result1, &apos;a&apos;);
const result2 = await asyncFunc2();
assert.strictEqual(result2, &apos;b&apos;);
});
</code></pre><p>在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。</p>
<h2 id="不要担心没有处理的拒绝拒态"><a href="#不要担心没有处理的拒绝拒态" class="headerlink" title="不要担心没有处理的拒绝拒态"></a>不要担心没有处理的拒绝拒态</h2><p>当前的 JavaScript 引擎可以在拒绝态未处理的情况下提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告：</p>
<pre><code>JavaScript 代码:
async function foo() {
throw new Error(&apos;Problem!&apos;);
}
foo();
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/20个CSS高级技巧汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/20个CSS高级技巧汇总/" itemprop="url">20个 CSS高级技巧汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T16:24:04+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用技巧会让人变的越来越懒，没错，我就是想让你变懒。下面是我收集的CSS高级技巧，希望你懒出境界。</p>
<h2 id="1-黑白图像"><a href="#1-黑白图像" class="headerlink" title="1. 黑白图像"></a>1. 黑白图像</h2><p>这段代码会让你的彩色照片显示为黑白照片，是不是很酷？</p>
<pre><code>img.desaturate {
 filter: grayscale(100%);
-webkit-filter: grayscale(100%);
-moz-filter: grayscale(100%);
-ms-filter: grayscale(100%);
-o-filter: grayscale(100%);
}
</code></pre><h2 id="2-使用-not-在菜单上应用-取消应用边框"><a href="#2-使用-not-在菜单上应用-取消应用边框" class="headerlink" title="2. 使用 :not() 在菜单上应用/取消应用边框"></a>2. 使用 <code>:not()</code> 在菜单上应用/取消应用边框</h2><p>先给每一个菜单项添加边框</p>
<pre><code>/* add border */
.nav li {
 border-right: 1px solid #666;
}
</code></pre><p>然后再除去最后一个元素</p>
<pre><code>// remove border /

.nav li:last-child {
 border-right: none;
}
</code></pre><p>可以直接使用 :not() 伪类来应用元素：</p>
<pre><code>.nav li:not(:last-child) {
 border-right: 1px solid #666;
}
</code></pre><p>这样代码就干净，易读，易于理解了。</p>
<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>
<pre><code>.nav li:first-child ~ li {
 border-left: 1px solid #666;
}
</code></pre><h2 id="3-页面顶部阴影"><a href="#3-页面顶部阴影" class="headerlink" title="3. 页面顶部阴影"></a>3. 页面顶部阴影</h2><p>下面这个简单的 CSS3 代码片段可以给网页加上漂亮的顶部阴影效果：</p>
<pre><code>body:before {
 content: &quot;&quot;;
 position: fixed;
 top: -10px;
 left: 0;
 width: 100%;
 height: 10px;

-webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
-moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
 box-shadow: 0px 0px 10px rgba(0,0,0,.8);

 z-index: 100;
}
</code></pre><h2 id="4-给-body-添加行高"><a href="#4-给-body-添加行高" class="headerlink" title="4. 给 body 添加行高"></a>4. 给 body 添加行高</h2><p>你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可：</p>
<pre><code>body {
 line-height: 1;
}
</code></pre><p>这样文本元素就可以很容易地从 body 继承。</p>
<h2 id="5-所有一切都垂直居中"><a href="#5-所有一切都垂直居中" class="headerlink" title="5. 所有一切都垂直居中"></a>5. 所有一切都垂直居中</h2><p>要将所有元素垂直居中，太简单了：</p>
<pre><code>html, body {
 height: 100%;
 margin: 0;
}

body {
-webkit-align-items: center; 
-ms-flex-align: center; 
 align-items: center;
 display: -webkit-flex;
 display: flex;
}
</code></pre><p>看，是不是很简单。</p>
<p>注意：在IE11中要小心flexbox</p>
<h2 id="6-逗号分隔的列表"><a href="#6-逗号分隔的列表" class="headerlink" title="6. 逗号分隔的列表"></a>6. 逗号分隔的列表</h2><p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>
<pre><code>ul &gt; li:not(:last-child)::after {
 content: &quot;,&quot;;
}
</code></pre><p>对最后一个列表项使用 :not() 伪类。</p>
<h2 id="7-使用负的-nth-child-选择项目"><a href="#7-使用负的-nth-child-选择项目" class="headerlink" title="7. 使用负的 nth-child 选择项目"></a>7. 使用负的 nth-child 选择项目</h2><p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>
<pre><code>li {
 display: none;
}

/* select items 1 through 3 and display them */
li:nth-child(-n+3) {
 display: block;
}
</code></pre><h2 id="8-对图标使用-SVG"><a href="#8-对图标使用-SVG" class="headerlink" title="8. 对图标使用 SVG"></a>8. 对图标使用 SVG</h2><p>我们没有理由不对图标使用SVG：</p>
<pre><code>.logo {
 background: url(&quot;logo.svg&quot;);
}
</code></pre><p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>
<h2 id="9-优化显示文本"><a href="#9-优化显示文本" class="headerlink" title="9. 优化显示文本"></a>9. 优化显示文本</h2><p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>
<pre><code>html {
-moz-osx-font-smoothing: grayscale;
-webkit-font-smoothing: antialiased;
 text-rendering: optimizeLegibility;
}
</code></pre><p>注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。</p>
<h2 id="10-对纯-CSS-滑块使用-max-height"><a href="#10-对纯-CSS-滑块使用-max-height" class="headerlink" title="10. 对纯 CSS 滑块使用 max-height"></a>10. 对纯 CSS 滑块使用 max-height</h2><p>使用 max-height 和溢出隐藏来实现只有CSS的滑块：</p>
<pre><code>.slider ul {
 max-height: 0;
 overlow: hidden;
}

.slider:hover ul {
 max-height: 1000px;
 transition: .3s ease;
}
</code></pre><h2 id="11-继承-box-sizing"><a href="#11-继承-box-sizing" class="headerlink" title="11. 继承 box-sizing"></a>11. 继承 box-sizing</h2><p>让 box-sizing 继承 html：</p>
<pre><code>html {
 box-sizing: border-box;
}

*, *:before, *:after {
 box-sizing: inherit;
}
</code></pre><p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。</p>
<h2 id="12-表格单元格等宽"><a href="#12-表格单元格等宽" class="headerlink" title="12. 表格单元格等宽"></a>12. 表格单元格等宽</h2><p>表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽：</p>
<pre><code>.calendar {
 table-layout: fixed;
}
</code></pre><h2 id="13-用-Flexbox-摆脱外边距的各种-hack"><a href="#13-用-Flexbox-摆脱外边距的各种-hack" class="headerlink" title="13. 用 Flexbox 摆脱外边距的各种 hack"></a>13. 用 Flexbox 摆脱外边距的各种 hack</h2><p>当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了：</p>
<pre><code>.list {
 display: flex;
 justify-content: space-between;
}

.list .person {
 flex-basis: 23%;
}
</code></pre><p>现在，列表分隔符就会在均匀间隔的位置出现。</p>
<h2 id="14-使用属性选择器用于空链接"><a href="#14-使用属性选择器用于空链接" class="headerlink" title="14. 使用属性选择器用于空链接"></a>14. 使用属性选择器用于空链接</h2><p>当a元素没有文本值，但 href 属性有链接的时候显示链接：</p>
<pre><code>a[href^=&quot;http&quot;]:empty::before {
 content: attr(href);
}
</code></pre><p>相当方便。</p>
<h2 id="15-检测鼠标双击"><a href="#15-检测鼠标双击" class="headerlink" title="15. 检测鼠标双击"></a>15. 检测鼠标双击</h2><p>HTML：</p>
<pre><code>&lt;div class=&quot;test3&quot;&gt;
&lt;span&gt;&lt;input type=&quot;text&quot; value=&quot; &quot; readonly=&quot;true&quot; /&gt;
&lt;a href=&quot;http://renpingjun.com&quot;&gt;Double click me&lt;/a&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>CSS：</p>
<pre><code>.test3 span {
 position: relative;
}
.test3 span a {
 position: relative;
 z-index: 2;
}
.test3 span a:hover, .test3 span a:active {
 z-index: 4;
}
.test3 span input {
 background: transparent;
 border: 0;
 cursor: pointer;
 position: absolute;
 top: -1px;
 left: 0;
 width: 101%; /* Hacky */
 height: 301%; /* Hacky */
 z-index: 3;
}
.test3 span input:focus {
 background: transparent;
 border: 0;
 z-index: 1;
}
</code></pre><h2 id="16-CSS-写出三角形"><a href="#16-CSS-写出三角形" class="headerlink" title="16. CSS 写出三角形"></a>16. CSS 写出三角形</h2><pre><code>/* create an arrow that points up */
div.arrow-up {
 width:0px;
 height:0px;
 border-left:5px solid transparent; /* left arrow slant */
 border-right:5px solid transparent; /* right arrow slant */
 border-bottom:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points down */
div.arrow-down {
 width:0px;
 height:0px;
 border-left:5px solid transparent;
 border-right:5px solid transparent;
 border-top:5px solid #2f2f2f;
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points left */
div.arrow-left {
 width:0px;
 height:0px;
 border-bottom:5px solid transparent; /* left arrow slant */
 border-top:5px solid transparent; /* right arrow slant */
 border-right:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points right */
div.arrow-right {
 width:0px;
 height:0px;
 border-bottom:5px solid transparent; /* left arrow slant */
 border-top:5px solid transparent; /* right arrow slant */
 border-left:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}
</code></pre><h2 id="17-CSS3-calc-的使用"><a href="#17-CSS3-calc-的使用" class="headerlink" title="17. CSS3 calc() 的使用"></a>17. CSS3 calc() 的使用</h2><p>calc() 用法类似于函数，能够给元素设置动态的值：</p>
<pre><code>/* basic calc */
.simpleBlock {
 width: calc(100% - 100px);
}

/* calc in calc */
.complexBlock {
 width: calc(100% - 50% / 3);
 padding: 5px calc(3% - 2px);
 margin-left: calc(10% + 10px);
}
</code></pre><h2 id="18-文本渐变"><a href="#18-文本渐变" class="headerlink" title="18. 文本渐变"></a>18. 文本渐变</h2><p>文本渐变效果很流行，使用 CSS3 能够很简单就实现：</p>
<pre><code>h2[data-text] {
 position: relative;
}
h2[data-text]::after {
 content: attr(data-text);
 z-index: 10;
 color: #e3e3e3;
 position: absolute;
 top: 0;
 left: 0;
-webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));}
</code></pre><h2 id="19-禁用鼠标事件"><a href="#19-禁用鼠标事件" class="headerlink" title="19. 禁用鼠标事件"></a>19. 禁用鼠标事件</h2><p>CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。</p>
<pre><code>.disabled { pointer-events: none; }
</code></pre><h2 id="20-模糊文本"><a href="#20-模糊文本" class="headerlink" title="20. 模糊文本"></a>20. 模糊文本</h2><p>简单但很漂亮的文本模糊效果，简单又好看！</p>
<pre><code>.blur {
  color: transparent;
  text-shadow: 0 0 5px rgba(0,0,0,0.5);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/NPM学习笔记整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/NPM学习笔记整理/" itemprop="url">NPM学习笔记整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T18:35:10+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是-NPM什么是-NPM"><a href="#什么是-NPM什么是-NPM" class="headerlink" title="什么是-NPM什么是 NPM"></a><a href="#什么是-NPM">什么是-NPM</a>什么是 NPM</h1><p><code>npm</code> 之于 <code>Node</code> ，就像 <code>pip</code> 之于 <code>Python</code> , <code>gem</code> 之于 <code>Ruby</code> , <code>composer</code> 之于 <code>PHP</code> 。</p>
<p><code>npm</code> 是 <code>Node</code> 官方提供的包管理工具，他已经成了 <code>Node</code> 包的标准发布平台，用于 <code>Node</code> 包的发布、传播、依赖控制。<br><code>npm</code> 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p>
<h1 id="为什么要使用-NPM为什么要使用-NPM"><a href="#为什么要使用-NPM为什么要使用-NPM" class="headerlink" title="为什么要使用-NPM为什么要使用 NPM"></a><a href="#为什么要使用-NPM">为什么要使用-NPM</a>为什么要使用 NPM</h1><p><code>npm</code> 是随同 <code>Node</code> 一起安装的包管理工具，能解决 <code>Node</code> 代码部署上的很多问题，常见的场景有以下几种：</p>
<ul>
<li>允许用户从 <code>npm</code> 服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从 <code>npm</code> 服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到 <code>npm</code> 服务器供别人使用。</li>
</ul>
<p><code>npm</code> 的背后，是基于 <code>CouchDB</code> 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。</p>
<h1 id="如何使用-NPM如何使用-NPM"><a href="#如何使用-NPM如何使用-NPM" class="headerlink" title="如何使用-NPM如何使用 NPM"></a><a href="#如何使用-NPM">如何使用-NPM</a>如何使用 NPM</h1><h2 id="安装安装"><a href="#安装安装" class="headerlink" title="安装安装"></a><a href="#安装">安装</a>安装</h2><p><code>npm</code> 不需要单独安装。在安装 <code>Node</code> 的时候，会连带一起安装 <code>npm</code> 。但是，<code>Node</code> 附带的 <code>npm</code> 可能不是最新版本，最后用下面的命令，更新到最新版本。</p>
<pre><code>$ sudo npm install npm@latest -g
</code></pre><p>如果是 Window 系统使用以下命令即可：</p>
<pre><code>npm install npm -g
</code></pre><p>也就是使用 <code>npm</code> 安装自己。之所以可以这样，是因为 <code>npm</code> 本身与 <code>Node</code> 的其他模块没有区别。</p>
<p>然后，运行下面的命令，查看各种信息。</p>
<pre><code># 查看 npm 命令列表
$ npm help

# 查看各个命令的简单用法
$ npm -l

# 查看 npm 的版本
$ npm -v

# 查看 npm 的配置
$ npm config list -l
</code></pre><h2 id="使用使用"><a href="#使用使用" class="headerlink" title="使用使用"></a><a href="#使用">使用</a>使用</h2><h3 id="npm-initnpm-init"><a href="#npm-initnpm-init" class="headerlink" title="npm-initnpm init"></a><a href="#npm-init">npm-init</a>npm init</h3><p><code>npm init</code> 用来初始化生成一个新的 <code>package.json</code> 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。<br>如果使用了 <code>-f</code>（代表<code>force</code>）、<code>-y</code>（代表<code>yes</code>），则跳过提问阶段，直接生成一个新的 <code>package.json</code> 文件。</p>
<pre><code>$ npm init -y
</code></pre><h3 id="npm-setnpm-set"><a href="#npm-setnpm-set" class="headerlink" title="npm-setnpm set"></a><a href="#npm-set">npm-set</a>npm set</h3><p><code>npm set</code> 用来设置环境变量</p>
<pre><code>$ npm set init-author-name &apos;Your name&apos;
$ npm set init-author-email &apos;Your email&apos;
$ npm set init-author-url &apos;http://yourdomain.com&apos;
$ npm set init-license &apos;MIT&apos;
</code></pre><p>上面命令等于为 <code>npm init</code> 设置了默认值，以后执行 <code>npm init</code> 的时候，<code>package.json</code>的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 <code>~/.npmrc</code>文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 <code>npm config</code>。</p>
<h3 id="npm-infonpm-info"><a href="#npm-infonpm-info" class="headerlink" title="npm-infonpm info"></a><a href="#npm-info">npm-info</a>npm info</h3><p><code>npm info</code> 命令可以查看每个模块的具体信息。比如，查看 <code>underscore</code> 模块的信息。</p>
<pre><code>$ npm info underscore
</code></pre><p>上面命令返回一个 <code>JavaScript</code> 对象，包含了 <code>underscore</code> 模块的详细信息。这个对象的每个成员，都可以直接从 <code>info</code> 命令查询。</p>
<pre><code>$ npm info underscore description

$ npm info underscore homepage

$ npm info underscore version
</code></pre><h3 id="npm-searchnpm-search"><a href="#npm-searchnpm-search" class="headerlink" title="npm-searchnpm search"></a><a href="#npm-search">npm-search</a>npm search</h3><p><code>npm search</code> 命令用于搜索 <code>npm</code> 仓库，它后面可以跟字符串，也可以跟正则表达式。</p>
<pre><code>$ npm search &lt;搜索词&gt;
</code></pre><h3 id="npm-listnpm-list"><a href="#npm-listnpm-list" class="headerlink" title="npm-listnpm list"></a><a href="#npm-list">npm-list</a>npm list</h3><p><code>npm list</code> 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。</p>
<pre><code>$ npm list

# 加上 global 参数，会列出全局安装的模块
$ npm list -global

# npm list 命令也可以列出单个模块
$ npm list underscore
</code></pre><h3 id="npm-installnpm-install"><a href="#npm-installnpm-install" class="headerlink" title="npm-installnpm install"></a><a href="#npm-install">npm-install</a>npm install</h3><p>使用 <code>npm</code> 安装包的命令格式为：<code>npm [install/i] [package_name]</code></p>
<h4 id="本地模式和全局模式本地模式和全局模式"><a href="#本地模式和全局模式本地模式和全局模式" class="headerlink" title="本地模式和全局模式本地模式和全局模式"></a><a href="#本地模式和全局模式">本地模式和全局模式</a>本地模式和全局模式</h4><p><code>npm</code> 在默认情况下会从 <a href="http://npmjs.org" target="_blank" rel="noopener">NPM</a> 搜索或下载包，将包安装到当前目录的 <code>node_modules</code> 子目录下。</p>
<p>如果你熟悉 <code>Ruby</code> 的 <code>gem</code> 或者 <code>Python</code> 的 <code>pip</code> ，你会发现 <code>npm</code> 与它们的行为不同， <code>gem</code> 或 <code>pip</code> 总是以全局模式安装，使包可以供所有的程序使用，而 <code>npm</code> 默认会把包安装到当前目录下。这反映了 <code>npm</code> 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 <code>API</code> 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p>
<p>我们在使用 <code>supervisor</code> 的时候使用了 <code>npm install -g supervisor</code> 命令，就是以全局模式安装 <code>supervisor</code> 。</p>
<p>这里注意一点的就是， <code>supervisor</code> 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 <code>npm config set prefix &quot;路径&quot;</code> 安装完以后就可以用 <code>supervisor</code> 来启动服务了。<br><code>supervisor</code> 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 <code>Node</code> 。</p>
<p>一般来说，全局安装只适用于工具模块，比如 <code>eslint</code> 和 <code>gulp</code> 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为 <strong>本地模式不会注册 <code>PATH</code> 环境变量</strong>。<br>“本地安装”指的是将一个模块下载到当前项目的 <code>node_modules</code> 子目录，然后只有在项目目录之中，才能调用这个模块。</p>
<p>本地模式和全局模式的特点如下：<br>模式可通过 require 使用注册 PATH本地模式是否全局模式否是</p>
<pre><code># 本地安装
$ npm install &lt;package name&gt;

# 全局安装
$ sudo npm install -global &lt;package name&gt;
$ sudo npm install -g &lt;package name&gt;
</code></pre><p><code>npm install</code> 也支持直接输入 <code>Github</code> 代码库地址。</p>
<pre><code>$ npm install git://github.com/package/path.git
$ npm install git://github.com/package/path.git#0.1.0
</code></pre><p>安装之前，<code>npm install</code> 会先检查，<code>node_modules</code> 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p>
<p>如果你希望，一个模块不管是否安装过， <code>npm</code> 都要强制重新安装，可以使用 <code>-f</code> 或 <code>--force</code> 参数。</p>
<pre><code>$ npm install &lt;packageName&gt; --force
</code></pre><h4 id="安装不同版本安装不同版本"><a href="#安装不同版本安装不同版本" class="headerlink" title="安装不同版本安装不同版本"></a><a href="#安装不同版本">安装不同版本</a>安装不同版本</h4><p><code>install</code> 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 <code>@</code> 和版本号。</p>
<pre><code>$ npm install sax@latest
$ npm install sax@0.1.1
$ npm install sax@&quot;&gt;=0.1.0 &lt;0.2.0&quot;
</code></pre><p><code>install</code> 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 <code>packages.json</code> 文件的哪一项中。</p>
<blockquote>
<p>–save：模块名将被添加到 dependencies，可以简化为参数-S。<br>–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。</p>
</blockquote>
<pre><code>$ npm install sax --save
$ npm install node-tap --save-dev
# 或者
$ npm install sax -S
$ npm install node-tap -D
</code></pre><h5 id="dependencies-依赖dependencies-依赖"><a href="#dependencies-依赖dependencies-依赖" class="headerlink" title="dependencies-依赖dependencies 依赖"></a><a href="#dependencies-依赖">dependencies-依赖</a>dependencies 依赖</h5><p>这个可以说是我们 <code>npm</code> 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 <code>js</code> 模块包。下面这段代码表示我们依赖了 <code>markdown-it</code> 这个包，版本是 <code>^8.1.0</code> ，代表最小依赖版本是 <code>8.1.0</code> ，如果这个包有更新，那么当我们使用 <code>npm install</code> 命令的时候， <code>npm</code> 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。</p>
<pre><code>&quot;dependencies&quot;: {
&quot;markdown-it&quot;: &quot;^8.1.0&quot;
}
</code></pre><h5 id="devDependencies-开发依赖devDependencies-开发依赖"><a href="#devDependencies-开发依赖devDependencies-开发依赖" class="headerlink" title="devDependencies-开发依赖devDependencies 开发依赖"></a><a href="#devDependencies-开发依赖">devDependencies-开发依赖</a>devDependencies 开发依赖</h5><p>在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 <code>devDependencies</code> 的包，在别人引用的时候不会被 <code>npm</code> 下载。</p>
<pre><code>&quot;devDependencies&quot;: {
&quot;autoprefixer&quot;: &quot;^6.4.0&quot;,
&quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;,
&quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;,
&quot;babel-register&quot;: &quot;^6.0.0&quot;,
&quot;webpack&quot;: &quot;^1.13.2&quot;,
&quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;,
&quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot;,
&quot;webpack-merge&quot;: &quot;^0.14.1&quot;,
&quot;highlightjs&quot;: &quot;^9.8.0&quot;
}
</code></pre><p>当你有了一个完整的 <code>package.json</code>文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 <code>npm install</code> 就可以很方便的下载好这个模块所需要的包。</p>
<p><code>npm install</code> 默认会安装 <code>dependencies</code> 字段和 <code>devDependencies</code> 字段中的所有模块，如果使用 <code>--production</code> 参数，可以只安装 <code>dependencies</code> 字段的模块。</p>
<pre><code>$ npm install --production
# 或者
$ NODE_ENV=production npm install
</code></pre><p>一旦安装了某个模块，就可以在代码中用 <code>require</code> 命令加载这个模块。</p>
<pre><code>var backbone = require(&apos;backbone&apos;)
console.log(backbone.VERSION)
</code></pre><h3 id="npm-runnpm-run"><a href="#npm-runnpm-run" class="headerlink" title="npm-runnpm run"></a><a href="#npm-run">npm-run</a>npm run</h3><p><code>npm</code> 不仅可以用于模块管理，还可以用于执行脚本。<code>package.json</code> 文件有一个 <code>scripts</code> 字段，可以用于指定脚本命令，供 <code>npm</code> 直接调用。<br><code>package.json</code> 文件内容：</p>
<pre><code>{
&quot;name&quot;: &quot;myproject&quot;,
&quot;devDependencies&quot;: {
&quot;jshint&quot;: &quot;latest&quot;,
&quot;browserify&quot;: &quot;latest&quot;,
&quot;mocha&quot;: &quot;latest&quot;
  },
&quot;scripts&quot;: {
&quot;lint&quot;: &quot;jshint **.js&quot;,
&quot;test&quot;: &quot;mocha test/&quot;
  }
}
</code></pre><h4 id="scripts-脚本scripts-脚本"><a href="#scripts-脚本scripts-脚本" class="headerlink" title="scripts-脚本scripts 脚本"></a><a href="#scripts-脚本">scripts-脚本</a>scripts 脚本</h4><p>顾名思义，就是一些脚本代码，可以通过 <code>npm run script-key</code> 来调用，例如在这个 <code>package.json</code> 的文件夹下使用 <code>npm run dev</code> 就相当于运行了 <code>node build/dev-server.js</code> 这一段代码。使用 <code>scripts</code> 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。<br><code>npm run</code> 是 <code>npm run-script</code> 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。</p>
<pre><code>// 脚本
&quot;scripts&quot;: {
&quot;dev&quot;: &quot;node build/dev-server.js&quot;,
&quot;build&quot;: &quot;node build/build.js&quot;,
&quot;docs&quot;: &quot;node build/docs.js&quot;,
&quot;build-docs&quot;: &quot;npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m &apos;auto-pages&apos; &amp; git push &amp; git checkout master&quot;,
&quot;build-publish&quot;: &quot;rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push&quot;,
&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;
}
</code></pre><p><code>npm run</code> 如果不加任何参数，直接运行，会列出 <code>package.json</code> 里面所有可以执行的脚本命令。<br><code>npm</code> 内置了两个命令简写， <code>npm test</code> 等同于执行 <code>npm run test</code> ，<code>npm start</code> 等同于执行 <code>npm run start</code>。</p>
<pre><code>&quot;build&quot;: &quot;npm run build-js &amp;&amp; npm run build-css&quot;
</code></pre><p>上面的写法是先运行 <code>npm run build-js</code> ，然后再运行 <code>npm run build-css</code> ，两个命令中间用 <code>&amp;&amp;</code> 连接。如果希望两个命令同时平行执行，它们中间可以用 <code>&amp;</code> 连接。</p>
<p>写在 <code>scripts</code> 属性中的命令，也可以在 <code>node_modules/.bin</code> 目录中直接写成 <code>bash</code> 脚本。下面是一个 <code>bash</code> 脚本。</p>
<pre><code>#!/bin/bash

cd site/main
browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js
</code></pre><p>假定上面的脚本文件名为 <code>build.sh</code> ，并且权限为可执行，就可以在 <code>scripts</code> 属性中引用该文件。</p>
<pre><code>&quot;build-js&quot;: &quot;bin/build.sh&quot;
</code></pre><h3 id="pre-和-post-脚本pre-和-post-脚本"><a href="#pre-和-post-脚本pre-和-post-脚本" class="headerlink" title="pre-和-post-脚本pre- 和 post- 脚本"></a><a href="#pre-和-post-脚本">pre-和-post-脚本</a>pre- 和 post- 脚本</h3><p><code>npm run</code> 为每条命令提供了 <code>pre-</code> 和 <code>post-</code> 两个钩子（ <code>hook</code> ）。以 <code>npm run lint</code> 为例，执行这条命令之前， <code>npm</code> 会先查看有没有定义 <code>prelint</code> 和 <code>postlint</code> 两个钩子，如果有的话，就会先执行 <code>npm run prelint</code> ，然后执行 <code>npm run lint</code> ，最后执行 <code>npm run postlint</code> 。</p>
<pre><code>{
&quot;name&quot;: &quot;myproject&quot;,
&quot;devDependencies&quot;: {
&quot;eslint&quot;: &quot;latest&quot;
&quot;karma&quot;: &quot;latest&quot;
  },
&quot;scripts&quot;: {
&quot;lint&quot;: &quot;eslint --cache --ext .js --ext .jsx src&quot;,
&quot;test&quot;: &quot;karma start --log-leve=error karma.config.js --single-run=true&quot;,
&quot;pretest&quot;: &quot;npm run lint&quot;,
&quot;posttest&quot;: &quot;echo &apos;Finished running tests&apos;&quot;
  }
}
</code></pre><p>上面代码是一个 <code>package.json</code> 文件的例子。如果执行 <code>npm test</code>，会按下面的顺序执行相应的命令。</p>
<ol>
<li><code>pretest</code></li>
<li><code>test</code></li>
<li><code>posttest</code></li>
</ol>
<p>如果执行过程出错，就不会执行排在后面的脚本，即如果 <code>prelint</code> 脚本执行出错，就不会接着执行 <code>lint</code> 和 <code>postlint</code> 脚本。</p>
<h3 id="npm-binnpm-bin"><a href="#npm-binnpm-bin" class="headerlink" title="npm-binnpm bin"></a><a href="#npm-bin">npm-bin</a>npm bin</h3><p><code>npm bin</code> 命令显示相对于当前目录的，<code>Node</code> 模块的可执行脚本所在的目录（即 <code>.bin</code> 目录）。</p>
<pre><code># 项目根目录下执行
$ npm bin
./node_modules/.bin
</code></pre><h1 id="创建全局链接创建全局链接"><a href="#创建全局链接创建全局链接" class="headerlink" title="创建全局链接创建全局链接"></a><a href="#创建全局链接">创建全局链接</a>创建全局链接</h1><p><code>npm</code> 提供了一个有趣的命令 <code>npm link</code>，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 <code>require</code> 使用。但通过 <code>npm link</code> 命令可以打破这一限制。举个例子，我们已经通过 <code>npm install -g express</code> 安装了 <code>express</code> ，这时在工程的目录下运行命令：<code>npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express</code><br>我们可以在 <code>node_modules</code> 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。<br>除了将全局的包链接到本地以外，使用 <code>npm link</code> 命令还可以将本地的包链接到全局。使用方法是在包目录（<code>package.json</code> 所在目录）中运行 <code>npm link</code> 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。</p>
<h1 id="创建包创建包"><a href="#创建包创建包" class="headerlink" title="创建包创建包"></a><a href="#创建包">创建包</a>创建包</h1><p>包是在模块基础上更深一步的抽象，<code>Node</code> 的包类似于 <code>C/C++</code> 的函数库或者 <code>Java</code> 、<code>.Net</code> 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。<code>Node</code> 根据 <code>CommonJS</code> 规范实现了包机制，开发了 <code>npm</code> 来解决包的发布和获取需求。<br><code>Node</code> 的包是一个目录，其中包含了一个 <code>JSON</code> 格式的包说明文件 <code>package.json</code>。严格符合 <code>CommonJS</code> 规范的包应该具备以下特征：</p>
<ul>
<li><code>package.json</code> 必须在包的顶层目录下；</li>
<li>二进制文件应该在 <code>bin</code> 目录下；</li>
<li><code>JavaScript</code> 代码应该在 <code>lib</code> 目录下；</li>
<li>文档应该在 <code>doc</code> 目录下；</li>
<li>单元测试应该在 <code>test</code> 目录下。</li>
</ul>
<p><code>Node</code> 对包的要求并没有这么严格，只要顶层目录下有 <code>package.json</code>，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 <code>CommonJS</code> 规范。</p>
<p>我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 <code>package.json</code>，我们可以创建更复杂，更完善，更符合规范的包用于发布。</p>
<p><code>Node</code> 在调用某个包时，会首先检查包中 <code>packgage.json</code> 文件的 <code>main</code> 字段，将其作为包的接口模块，如果 <code>package.json</code> 或 <code>main</code> 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p>
<p><code>package.json</code> 是 <code>CommonJS</code> 规定的用来描述包的文件，完全符合规范的 <code>package.json</code> 文件应该含有以下字段：<br>name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。<br>description: 包的简要说明。<br>version: 符合语义化版本识别规范的版本字符串。<br>keywords: 关键字数组，通常用于搜索。<br>maintainers: 维护者数组，每个元素要包含 <code>name</code> 、 <code>email</code>(可选)、 <code>web</code>(可选)字段。<br>contributors: 贡献者数组，格式与 <code>maintainers</code> 相同。包的作者应该是贡献者数组的第一个元素。<br>bugs: 提交 <code>bug</code> 的地址，可以是网址或者电子邮件地址。<br>licenses: 许可证数组，每个元素要包含 <code>type</code> （许可证的名称）和 url（链接到许可证文本的地址）字段。<br>repositories: 仓库托管地址数组，每个元素要包含 <code>type</code> （仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。<br>dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。</p>
<h1 id="包的发布包的发布"><a href="#包的发布包的发布" class="headerlink" title="包的发布包的发布"></a><a href="#包的发布">包的发布</a>包的发布</h1><p>通过使用 <code>npm init</code> 可以根据交互式回答产生一个符合标准的 <code>package.json</code>。创建一个 <code>index.js</code> 作为包的接口,一个简单的包就制作完成了。<br>在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 <code>npm adduser</code> 根据提示完成账号的创建<br>完成后可以使用 <code>npm whoami</code> 检测是否已经取得了账号。<br>接下来,在 <code>package.json</code> 所在目录下运行 <code>npm publish</code>，稍等片刻就可以完成发布了，打开浏览器，访问 <a href="http://search.npmjs.org/" target="_blank" rel="noopener">NPM搜索</a> 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 <code>npm install neveryumodule</code> 命令来安装它。<br>如果你的包将来有更新,只需要在 <code>package.json</code> 文件中修改 <code>version</code> 字段,然后重新使用 <code>npm publish</code>命令就行了。<br>如果你对已发布的包不满意，可以使用 <code>npm unpublish</code> 命令来取消发布。</p>
<p><em>需要说明的是： <code>json</code> 文件不能有注释</em></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package.json 好处</span><br><span class="line"> 1.以json文件格式定义项目所依赖的包；</span><br><span class="line"> 2.确定每个包的使用版本；</span><br><span class="line"> 3.项目构建可重复，多人协助公用一套基础代码；</span><br><span class="line"> 4.npm init 初始化 【必须含有的两个：name 和 version】</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;react-redux-webpack&quot;,</span><br><span class="line">     &quot;version&quot;: &quot;1.1.0&quot;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">devDependencies    ：开发环境和测试环境所依赖的包列表</span><br><span class="line">dependencies       ：在生产环境使用的依赖包列表</span><br><span class="line"></span><br><span class="line">    dependencies下记录的是项目在运行时必须依赖的插件，常见的例如react jquery等，即及时项目打包好了、上线了，</span><br><span class="line">   这些也是需要用的，否则程序无法正常执行。</span><br><span class="line">    devDependencies下记录的是项目在开发过程中使用的插件，例如这里我们开发过程中需要使用webpack打包，</span><br><span class="line">    而我在工作中使用fis3打包，但是一旦项目打包发布、上线了之后，webpack和fis3就都没有用了，可卸磨杀驴。</span><br><span class="line"></span><br><span class="line">本地安装 npm install --save|--save-dev 分别写入  dependencies|devDependencies 中；</span><br><span class="line">简写：     npm i -S pkg      |  npm i -D pkg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">包（package)和模块（module）</span><br><span class="line">包：package.json 文件所描述的文件夹或者文件，符合CommonJS规范</span><br><span class="line">模块：任何被node.js中的require所载入的文件</span><br><span class="line"></span><br><span class="line">~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0</span><br><span class="line">^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0</span><br><span class="line">* 这意味着安装最新版本的依赖包</span><br><span class="line"></span><br><span class="line">常用命令:</span><br><span class="line">    npm init -y    //强制生成</span><br><span class="line">	npm init //在项目中引导创建一个package.json文件</span><br><span class="line">	npm search mkdir   //寻找包使用npm search命令</span><br><span class="line">	npm help //查看某条命令的详细帮助 </span><br><span class="line">	npm root //查看包的安装路径</span><br><span class="line">	npm config //管理npm的配置路径</span><br><span class="line">	npm prefix -g   //查看全局安装的包位置  -g全局</span><br><span class="line">	npm cache  //管理模块的缓存 ,可以使用下面命令，偶尔清楚一下缓存：      eg: npm cache clean</span><br><span class="line">	npm info webpack   //查看webpack 版本信息</span><br><span class="line">	npm install pkg //安装模块 简写：npm i pkg   ,带版本:  npm install underscore@1.8.2</span><br><span class="line">	npm uninstall //卸载模块   eg: npm uninstall webpack</span><br><span class="line">	npm update   // 更新模块   npm update underscore</span><br><span class="line">	npm outdated  //检查模块是否已经过时</span><br><span class="line">	npm ls   //查看安装的模块 </span><br><span class="line">	npm list  //可以查看全局路径下的所有包    eg:   npm list --global</span><br><span class="line">	          //也可以使用--depth=0来缩短返回的结果   eg:     npm list -g --depth=0</span><br><span class="line">	npm stop  //停止模块</span><br><span class="line">	npm restart  //重新启动模块</span><br><span class="line">	npm test //测试模块 </span><br><span class="line">	npm version //查看模块版本</span><br><span class="line">	npm publish //发布模块</span><br><span class="line"></span><br><span class="line">简写:</span><br><span class="line">	npm i – 安装包</span><br><span class="line">	npm i -g – 安装包到全局下</span><br><span class="line">	npm un – 删除本地下包</span><br><span class="line">	npm up – 更新包</span><br><span class="line">	npm t – 运行测试</span><br><span class="line">	npm ls – 罗列已经安装包</span><br><span class="line">	npm ll or npm la – 罗列包时显示额外信息</span><br><span class="line"></span><br><span class="line">    npm i express momemt lodash mongoose  webpack   //也可以一次安装多个包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    yarn cache clean   //删除电脑上所有 yarn 安装的缓存</span><br><span class="line">    yarn   //命令安装项目相关依赖</span><br><span class="line">    yarn cache dir //获取缓存文件夹地址</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/02/JavaScript核武库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/JavaScript核武库/" itemprop="url">JavaScript核武库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T16:24:04+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下是个人总结，也有一些是copy大神的，现在放到一起，方便以后查阅（有不对的地方，还望大家能够提出，我会尽快加以改正）。</p>
<h2 id="强制转boolean"><a href="#强制转boolean" class="headerlink" title="!!强制转boolean"></a>!!强制转<code>boolean</code></h2><p>根据真值，假值 判断，返回<code>true</code>，<code>false</code>假值：  0     “”  null   undefined  false NaN</p>
<pre><code>例如：
var nu=null;
var nul=&quot;&quot;;
var str=&quot;abcd&quot;;

console.log(!!nu)     // false;
console.log(!!nul)    // false;
console.log(!!str)    // true;
</code></pre><h2 id="obj-强制转Number"><a href="#obj-强制转Number" class="headerlink" title="+obj 强制转Number"></a>+obj 强制转<code>Number</code></h2><p> 将对象强制转<code>number</code>,如果是纯数字的“88”字符串，可转为<code>number</code></p>
<pre><code>var a=&quot;88&quot;;
console.log(+a)   =&gt;88
//但是如果是混合类型的字符串，则会转为NaN
var b=&quot;1606e&quot;;
console.log(+b)  =&gt; NaN
</code></pre><h2 id="强制取整"><a href="#强制取整" class="headerlink" title="~~ 强制取整"></a>~~ 强制取整</h2><pre><code>~~ 12.34
 12
~~ 12.88
 12
</code></pre><h2 id="不可靠的undefined-可靠的void-0"><a href="#不可靠的undefined-可靠的void-0" class="headerlink" title="不可靠的undefined 可靠的void 0"></a>不可靠的<code>undefined</code> 可靠的<code>void 0</code></h2><p>在<code>JavaScript</code>中，假设我们想判断一个是否是 <code>undefined</code>，那么我们通常会这样写：</p>
<pre><code>if(a === undefined){
  dosomething
}
</code></pre><p>//但是在<code>javascript</code>中，<code>undefined</code>是不可靠的</p>
<p>例如：<br>当undefined在函数内，并且是在局部变量是可以赋上值</p>
<pre><code>function foo2(){
 var undefined=1;
 console.log(undefined)
}
foo2();  =&gt;1;
</code></pre><p>但是当在函数内定义一个全局变量，并不能给赋上值</p>
<pre><code>var undefined;
function foo2(){
undefined=1;
 console.log(undefined)
}
foo2()  // undefined
void 0或者 void (0)：
</code></pre><p>最常见的用法是通过<code>void 0</code> 运算来获得 <code>undefined</code>，表达式为 0 时的运算开销最小：<br>那在以后需要判断值为<code>undefined</code>的时候，可以直接用<code>void 0</code>或者<code>void (0)</code></p>
<h2 id="字符串也是有length属性的！"><a href="#字符串也是有length属性的！" class="headerlink" title="字符串也是有length属性的！"></a>字符串也是有<code>length</code>属性的！</h2><p>我们知道所有的<code>array</code>都是有<code>length</code>,属性，就算事空数组，<code>length</code> 是0，那么字符串有没有呢？接下来我们来验证一下：</p>
<pre><code>var str=&quot;sdfsd5565s6dfsd65sd6+d5fd5&quot;;
console.log(str.length)      // 26
</code></pre><p>结果是有的，所以我们在判断类型时，不能单纯拿有没有<code>length</code>属性来判断是不是数组了，我们可以用下面的方法：</p>
<pre><code>var obj=[1,2] ;
console.log(toString.call(obj) === &apos;[object Array]&apos;);
</code></pre><h2 id="生成一个随机数组-创建数组，sort排序"><a href="#生成一个随机数组-创建数组，sort排序" class="headerlink" title="生成一个随机数组(创建数组，sort排序)"></a>生成一个随机数组(创建数组，<code>sort</code>排序)</h2><p>在项目中有时候我们需要一个随机打乱的数组，那么下面我们来实现以下：<br>先来创建一个数组：</p>
<pre><code>var arr=[];
for(var i=0;i&lt;10;i++){
   arr.push(i)
}
console.log(arr)    //  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p>接下来我们来打乱它：</p>
<pre><code>arr.sort(()=&gt;{
 return Math.random() - 0.5
})                 // [1, 0, 2, 3, 4, 6, 8, 5, 7, 9] 
</code></pre><p>第二种打乱方法：</p>
<pre><code>arr.sort((a,b)=&gt;{
　　　return a&gt;Math.random()*10;
})               //  [1, 2, 0, 6, 4, 3, 8, 9, 7, 5]
</code></pre><p>我们以前的正常排序是这样的：</p>
<pre><code>arr.sort(function(a,b){
   return b-a
});
</code></pre><p>解析：<br>先说正常的排序：<br>a,b表示数组中的任意两个元素，若<code>return &gt; 0</code> b前a后；<code>reutrn &lt; 0</code> a前b后；<code>a=b</code>时存在浏览器兼容 ，<br><code>a-b</code>输出从小到大排序，<code>b-a</code>输出从大到小排序。<br>然后再说我们打乱的方法：<br>创建数组不用说，接下来就是用js的sort方法 来实现，<code>Math.random()</code>实现一个随机<code>0-1</code>之间的小数 然后再减去<code>0.5</code>，这时就会根据return比较后得到的值排，所以说就会生成不是正常从大到小或者从小到大的排序。</p>
<p>第二个打乱的方法同样是遵循<code>sort</code>的方法，将<code>a,b</code>传进去 然后和随机数做比较，关于比较的方法不太清楚。</p>
<h2 id="去除前后、前、后-所有空格"><a href="#去除前后、前、后-所有空格" class="headerlink" title="去除前后、前、后 所有空格"></a>去除前后、前、后 所有空格</h2><p> 这是专门为去除空格写的一套方法，适用于各种情况，所有空格,前后空格，前空格，后空格。</p>
<p>var strr=”    1 ad dertasdf sdfASDFDF DFG SDFG    “<br>//  type 1-所有空格  2-前后空格  3-前空格 4-后空格</p>
<pre><code>function trim(str,type){
    switch (type){
        case 1:return str.replace(/\s+/g,&quot;&quot;);
        case 2:return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
        case 3:return str.replace(/(^\s*)/g, &quot;&quot;);
        case 4:return str.replace(/(\s*$)/g, &quot;&quot;);
        default:return str;
    }
}
console.log( trim(strr,1))      //  &quot;1addertasdfsdfASDFDFDFGSDFG&quot;
</code></pre><p>解析：<br>  这个方法用的是正则的匹配格式,后面我会把正则单独拿出来总结一个系列，敬请期待！！！</p>
<pre><code>\s ： 空格符，Tab,换页符，换行符
  \S ： 非\s的所有内容
  /g :  全局匹配
  ^  :  匹配在行首
  $  :  匹配在行尾
  +  ： 重复次数&gt;0
  *  ： 重复次数&gt;=0
  |  :  或者
</code></pre><p><code>replace(a,b)</code>： 方法用于在字符创中用一些字符替换另一些字符, 会传入两个值，将逗号前面的值<code>a</code>替换成逗号后面的值<code>b</code></p>
<h2 id="字母大小写切换（正则匹配，replace）"><a href="#字母大小写切换（正则匹配，replace）" class="headerlink" title="字母大小写切换（正则匹配，replace）"></a>字母大小写切换（正则匹配，<code>replace</code>）</h2><p>这个方法主要是给一些需要大小写转换提供的方法，主要有首字母大写，首字母小写，大小写转换，全部转大写和全部转小写。</p>
<pre><code>type：
　　1:首字母大写
　　2：首页母小写
　　3：大小写转换
　　4：全部大写
　　5：全部小写
</code></pre><p>原始字符串：</p>
<pre><code>var str=&quot;sdfwwerasfddffddeerAasdgFegqer&quot;;

function changeCase(str,type) {

   //这个函数是第三个大小写转换的方法
    function ToggleCase(str) {
        var itemText = &quot;&quot;
        str.split(&quot;&quot;).forEach(
                function (item) {
                 // 判断循环字符串中每个字符是否以a-z之间开头的并且重复大于0次
                    if (/^([a-z]+)/.test(item)) {
                    //  如果是小写，转换成大写
                        itemText += item.toUpperCase();
                    }
                //  判断循环字符串中每个字符是否以A-Z之间开头的并且重复大于0次
                    else if (/^([A-Z]+)/.test(item)) {
                   //   如果是大写，转换成小写
                        itemText += item.toLowerCase();
                    }
                    else{
                  //  如果都不符合，返回其本身
                        itemText += item;
                    }
                });
        return itemText;
    }
  //下面主要根据传入的type值来匹配各个场景
    switch (type) {
         //当匹配
        case 1:
            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {
                 //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer
                return v1.toUpperCase() + v2.toLowerCase();
            });
        case 2:
            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {
                //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer
                return v1.toLowerCase() + v2.toUpperCase();
            });
        case 3:
            return ToggleCase(str);
        case 4:
            return str.toUpperCase();
        case 5:
            return str.toLowerCase();
        default:
            return str;
    }

}

 console.log(changeCase(str,1)) =&gt;SdfwwerasfddffddeerAasdgFegqer
</code></pre><p>解析：</p>
<pre><code>split：用于把一个字符串分割成字符串数组
\w: 数字0-9或字母a-z及A-Z,或下划线
\W: 非\w，除以上的特殊符号等   
toUpperCase：转大写
toLowerCase：转小写
replace第二个参数可以是函数，函数的参数中，第一个是本身，第二个是正则匹配内容，第三个匹配剩下的内容
</code></pre><p>下面我们就通过小实验来验证一下：<br>网上有说replace是可以有4个参数的，但是我并没有验证到第四个代表的意义，前三个已经验证，第一个参数为验证本身，第二个正则匹配结果，第三为第二个匹配完剩下的值。</p>
<h2 id="循环n次传入的字符串str为传入随意字符串，count为循环的次数"><a href="#循环n次传入的字符串str为传入随意字符串，count为循环的次数" class="headerlink" title="循环n次传入的字符串str为传入随意字符串，count为循环的次数"></a>循环n次传入的字符串<code>str</code>为传入随意字符串，<code>count</code>为循环的次数</h2><pre><code>var str=&quot;abc&quot;;
 var number=555;

function repeatStr(str, count) {
    //声明一个空字符串，用来保存生成后的新字符串
    var text = &apos;&apos;;
    //循环传入的count值，即循环的次数
    for (var i = 0; i &lt; count; i++) {
       //循环一次就把字符串+到我们事先准备好的空字符串上
        text += str;
    }
    return text;
}

  console.log(repeatStr(str, 3))         // &quot;abcabcabc&quot;

  console.log(repeatStr(number, 3))      // &quot;555555555&quot;
</code></pre><p>解析：根据count循环的次数，在循环体内复制，return 返回+=后的值</p>
<h2 id="查找字符串的A内容替换成B内容"><a href="#查找字符串的A内容替换成B内容" class="headerlink" title="查找字符串的A内容替换成B内容"></a>查找字符串的A内容替换成B内容</h2><pre><code>let str=&quot;abacdasdfsd&quot; function replaceAll(str,AFindText,ARepText){
   raRegExp = new RegExp(AFindText,&quot;g&quot;);
   return str.replace(raRegExp,ARepText);
}
console.log(replaceAll(str,&quot;a&quot;,&quot;x&quot;))  // xbxcdxsdfsd
str：需要编辑的字符串本身
AFindText:需要替换的内容
ARepText:被替换成的内容
</code></pre><p>解析：创建正则，匹配内容，替换</p>
<h2 id="检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"><a href="#检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证" class="headerlink" title="检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"></a>检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证</h2><pre><code>function checkType (str, type) {
    switch (type) {
        case &apos;email&apos;:
            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);
        case &apos;phone&apos;:
            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);
        case &apos;tel&apos;:
            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);
        case &apos;number&apos;:
            return /^[0-9]$/.test(str);
        case &apos;english&apos;:
            return /^[a-zA-Z]+$/.test(str);
        case &apos;chinese&apos;:
            return /^[\u4E00-\u9FA5]+$/.test(str);
        case &apos;lower&apos;:
            return /^[a-z]+$/.test(str);
        case &apos;upper&apos;:
            return /^[A-Z]+$/.test(str);
        default :
            return true;
    }
}
console.log(checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;))   //false
</code></pre><p>解析：</p>
<pre><code>checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;)&apos;需要验证的字符串&apos;，&apos;匹配的格式&apos;
email：验证邮箱
phone：验证手机号
tel：验证座机号
number：验证数字
english：验证英文字母
chinese：验证中文字
lower：验证小写
upper：验证大写
</code></pre><p>JS返回浏览器历史第一页：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.xiejiahe.com/detail/5a18f8f5c7431c02ef43bca9" target="_blank" rel="noopener">JS返回浏览器历史第一页</a></p>
<p>我在浏览器控制台敲了 window.history 其实我想看看还有哪些API，他输出了以下信息，我看到length 这个属性让我眼前一亮，其他2个我不关心。</p>
<pre><code>{
    length: 2,
    scrollRestoration: &quot;auto&quot;,
    state: null
}
</code></pre><p>我尝试用length 去回退， 不成功！</p>
<pre><code>window.history.go(-2);
</code></pre><p>我再尝试用length去减1, 成功了， 我猜应该是跟新标签页有关吧。 那我不管了，我已经有答案了</p>
<pre><code>window.history.go(-1);
</code></pre><p>最后代码</p>
<pre><code>var historyLen = window.history;
window.history.go(-(historyLen - 1));
</code></pre><p>测试了3个浏览器， 都是第一次打开浏览器测试</p>
<pre><code>Chrome 会直接返回到新标签页
Safari 我这里测试是返回到百度，可能是我的设置问题
Firefox 直接关闭浏览器 
</code></pre><p>作为战斗在业务一线的前端，要想少加班，就要想办法提高工作效率。这里提一个小点，我们在业务开发过程中，经常会重复用到<code>日期格式化</code>、<code>url参数转对象</code>、<code>浏览器类型判断</code>、<code>节流函数</code>等一类函数，这些工具类函数，基本上在每个项目都会用到，为避免不同项目多次复制粘贴的麻烦，我们可以统一封装，发布到<code>npm</code>，以提高开发效率。</p>
<p>这里，笔者已经封装并发布了自己的武器库 <a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener">outils</a>，如果你对本项目感兴趣，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。当然你也可以在本项目的基础上封装自己的武器库。</p>
<p>常用函数汇总</p>
<h2 id="这里先分类整理下，之前项目中多次用到的工具函数。"><a href="#这里先分类整理下，之前项目中多次用到的工具函数。" class="headerlink" title="这里先分类整理下，之前项目中多次用到的工具函数。"></a>这里先分类整理下，之前项目中多次用到的工具函数。</h2><h2 id="1-Array"><a href="#1-Array" class="headerlink" title="1.Array"></a>1.Array</h2><h2 id="1-1-arrayEqual"><a href="#1-1-arrayEqual" class="headerlink" title="1.1 arrayEqual"></a>1.1 arrayEqual</h2><pre><code>/**
 * 
 * @desc 判断两个数组是否相等
 * @param {Array} arr1 
 * @param {Array} arr2 
 * @return {Boolean}
 */ function arrayEqual(arr1, arr2) {
    if (arr1 === arr2) return true;
    if (arr1.length != arr2.length) return false;
    for (var i = 0; i &lt; arr1.length; ++i) {
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
</code></pre><h2 id="2-Class"><a href="#2-Class" class="headerlink" title="2.Class"></a>2.Class</h2><h2 id="2-1-addClass"><a href="#2-1-addClass" class="headerlink" title="2.1 addClass"></a>2.1 addClass</h2><pre><code>/**
 * 
 * @desc   为元素添加class
 * @param  {HTMLElement} ele 
 * @param  {String} cls 
 */ 
var hasClass = require(&apos;./hasClass&apos;);
function addClass(ele, cls) {
    if (!hasClass(ele, cls)) {
        ele.className += &apos; &apos; + cls;
    }
}
</code></pre><p>2.2 hasClass</p>
<pre><code>/**
 * 
 * @desc 判断元素是否有某个class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 * @return {Boolean}
 */ 
function hasClass(ele, cls) {
    return (new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;)).test(ele.className);
}
</code></pre><p>2.3 removeClass</p>
<pre><code>/**
 * 
 * @desc 为元素移除class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 */ 
var hasClass = require(&apos;./hasClass&apos;);
function removeClass(ele, cls) {
    if (hasClass(ele, cls)) {
        var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;);
        ele.className = ele.className.replace(reg, &apos; &apos;);
    }
}
</code></pre><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h2><h2 id="3-1-getCookie"><a href="#3-1-getCookie" class="headerlink" title="3.1 getCookie"></a>3.1 getCookie</h2><pre><code>/**
 * 
 * @desc 根据name读取cookie
 * @param  {String} name 
 * @return {String}
 */ 
function getCookie(name) {
    var arr = document.cookie.replace(/\s/g, &quot;&quot;).split(&apos;;&apos;);
    for (var i = 0; i &lt; arr.length; i++) {
        var tempArr = arr[i].split(&apos;=&apos;);
        if (tempArr[0] == name) {
            return decodeURIComponent(tempArr[1]);
        }
    }
    return &apos;&apos;;
}
</code></pre><p>3.2 removeCookie</p>
<pre><code>var setCookie = require(&apos;./setCookie&apos;);
/**
 * 
 * @desc 根据name删除cookie
 * @param  {String} name 
 */
 function removeCookie(name) {
    // 设置已过期，系统会立刻删除cookie
    setCookie(name, &apos;1&apos;, -1);
}
</code></pre><p>3.3 setCookie</p>
<pre><code>/**
 * 
 * @desc  设置Cookie
 * @param {String} name 
 * @param {String} value 
 * @param {Number} days 
 */ 
function setCookie(name, value, days) {
    var date = new Date();
    date.setDate(date.getDate() + days);
    document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + date;
}
</code></pre><h2 id="4-Device"><a href="#4-Device" class="headerlink" title="4.Device"></a>4.Device</h2><h2 id="4-1-getExplore"><a href="#4-1-getExplore" class="headerlink" title="4.1 getExplore"></a>4.1 getExplore</h2><pre><code>/**
 * 
 * @desc 获取浏览器类型和版本
 * @return {String} 
 */ 
function getExplore() {
    var sys = {},
        ua = navigator.userAgent.toLowerCase(),
        s;
    (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:
        (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :
        (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :
        (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :
        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :
        (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :
        (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;
    // 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie)
    if (sys.edge) return (&apos;EDGE: &apos; + sys.edge)
    if (sys.firefox) return (&apos;Firefox: &apos; + sys.firefox)
    if (sys.chrome) return (&apos;Chrome: &apos; + sys.chrome)
    if (sys.opera) return (&apos;Opera: &apos; + sys.opera)
    if (sys.safari) return (&apos;Safari: &apos; + sys.safari)
    return &apos;Unkonwn&apos;
}
</code></pre><p>4.2 getOS</p>
<pre><code>/**
 * 
 * @desc 获取操作系统类型
 * @return {String} 
 */ 
function getOS() {
    var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;;
    var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;;
    var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;;

    if (/mac/i.test(appVersion)) return &apos;MacOSX&apos; if (/win/i.test(appVersion)) return &apos;windows&apos; if (/linux/i.test(appVersion)) return &apos;linux&apos; if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos; if (/android/i.test(userAgent)) return &apos;android&apos; if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos;
}
</code></pre><h2 id="5-Dom"><a href="#5-Dom" class="headerlink" title="5.Dom"></a>5.Dom</h2><h2 id="5-1-getScrollTop"><a href="#5-1-getScrollTop" class="headerlink" title="5.1 getScrollTop"></a>5.1 getScrollTop</h2><pre><code>/**
 * 
 * @desc 获取滚动条距顶部的距离
 */ 
function getScrollTop() {
    return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;
}
</code></pre><p>5.2 offset</p>
<pre><code>/**
 * 
 * @desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()
 * @param {HTMLElement} ele 
 * @returns { {left: number, top: number} }
 */ 
function offset(ele) {
    var pos = {
        left: 0,
        top: 0
    };
    while (ele) {
        pos.left += ele.offsetLeft;
        pos.top += ele.offsetTop;
        ele = ele.offsetParent;
    };
    return pos;
}
</code></pre><h2 id="5-3-scrollTo"><a href="#5-3-scrollTo" class="headerlink" title="5.3 scrollTo"></a>5.3 scrollTo</h2><pre><code>var getScrollTop = require(&apos;./getScrollTop&apos;);
var setScrollTop = require(&apos;./setScrollTop&apos;);
var requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 60);
        };
})();
/**
 * 
 * @desc  在${duration}时间内，滚动条平滑滚动到${to}指定位置
 * @param {Number} to 
 * @param {Number} duration 
 */ 
function scrollTo(to, duration) {
    if (duration &lt; 0) {
        setScrollTop(to);
        return
    }
    var diff = to - getScrollTop();
    if (diff === 0) return var step = diff / duration * 10;
    requestAnimationFrame(
        function () {
            if (Math.abs(step) &gt; Math.abs(diff)) {
                setScrollTop(getScrollTop() + diff);
                return;
            }
            setScrollTop(getScrollTop() + step);
            if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) {
                return;
            }
            scrollTo(to, duration - 16);
        });
}
</code></pre><h2 id="5-4-setScrollTop"><a href="#5-4-setScrollTop" class="headerlink" title="5.4 setScrollTop"></a>5.4 setScrollTop</h2><pre><code>/**
 * 
 * @desc 设置滚动条距顶部的距离
 */ 
function setScrollTop(value) {
    window.scrollTo(0, value);
    return value;
}
</code></pre><h2 id="6-Keycode"><a href="#6-Keycode" class="headerlink" title="6.Keycode"></a>6.Keycode</h2><h2 id="6-1-getKeyName"><a href="#6-1-getKeyName" class="headerlink" title="6.1 getKeyName"></a>6.1 getKeyName</h2><pre><code>var keyCodeMap = {
    8: &apos;Backspace&apos;,
    9: &apos;Tab&apos;,
    13: &apos;Enter&apos;,
    16: &apos;Shift&apos;,
    17: &apos;Ctrl&apos;,
    18: &apos;Alt&apos;,
    19: &apos;Pause&apos;,
    20: &apos;Caps Lock&apos;,
    27: &apos;Escape&apos;,
    32: &apos;Space&apos;,
    33: &apos;Page Up&apos;,
    34: &apos;Page Down&apos;,
    35: &apos;End&apos;,
    36: &apos;Home&apos;,
    37: &apos;Left&apos;,
    38: &apos;Up&apos;,
    39: &apos;Right&apos;,
    40: &apos;Down&apos;,
    42: &apos;Print Screen&apos;,
    45: &apos;Insert&apos;,
    46: &apos;Delete&apos;,

    48: &apos;0&apos;,
    49: &apos;1&apos;,
    50: &apos;2&apos;,
    51: &apos;3&apos;,
    52: &apos;4&apos;,
    53: &apos;5&apos;,
    54: &apos;6&apos;,
    55: &apos;7&apos;,
    56: &apos;8&apos;,
    57: &apos;9&apos;,

    65: &apos;A&apos;,
    66: &apos;B&apos;,
    67: &apos;C&apos;,
    68: &apos;D&apos;,
    69: &apos;E&apos;,
    70: &apos;F&apos;,
    71: &apos;G&apos;,
    72: &apos;H&apos;,
    73: &apos;I&apos;,
    74: &apos;J&apos;,
    75: &apos;K&apos;,
    76: &apos;L&apos;,
    77: &apos;M&apos;,
    78: &apos;N&apos;,
    79: &apos;O&apos;,
    80: &apos;P&apos;,
    81: &apos;Q&apos;,
    82: &apos;R&apos;,
    83: &apos;S&apos;,
    84: &apos;T&apos;,
    85: &apos;U&apos;,
    86: &apos;V&apos;,
    87: &apos;W&apos;,
    88: &apos;X&apos;,
    89: &apos;Y&apos;,
    90: &apos;Z&apos;,

    91: &apos;Windows&apos;,
    93: &apos;Right Click&apos;,

    96: &apos;Numpad 0&apos;,
    97: &apos;Numpad 1&apos;,
    98: &apos;Numpad 2&apos;,
    99: &apos;Numpad 3&apos;,
    100: &apos;Numpad 4&apos;,
    101: &apos;Numpad 5&apos;,
    102: &apos;Numpad 6&apos;,
    103: &apos;Numpad 7&apos;,
    104: &apos;Numpad 8&apos;,
    105: &apos;Numpad 9&apos;,
    106: &apos;Numpad *&apos;,
    107: &apos;Numpad +&apos;,
    109: &apos;Numpad -&apos;,
    110: &apos;Numpad .&apos;,
    111: &apos;Numpad /&apos;,

    112: &apos;F1&apos;,
    113: &apos;F2&apos;,
    114: &apos;F3&apos;,
    115: &apos;F4&apos;,
    116: &apos;F5&apos;,
    117: &apos;F6&apos;,
    118: &apos;F7&apos;,
    119: &apos;F8&apos;,
    120: &apos;F9&apos;,
    121: &apos;F10&apos;,
    122: &apos;F11&apos;,
    123: &apos;F12&apos;,

    144: &apos;Num Lock&apos;,
    145: &apos;Scroll Lock&apos;,
    182: &apos;My Computer&apos;,
    183: &apos;My Calculator&apos;,
    186: &apos;;&apos;,
    187: &apos;=&apos;,
    188: &apos;,&apos;,
    189: &apos;-&apos;,
    190: &apos;.&apos;,
    191: &apos;/&apos;,
    192: &apos;`&apos;,
    219: &apos;[&apos;,
    220: &apos;\\&apos;,
    221: &apos;]&apos;,
    222: &apos;\&apos;&apos;
};
/**
 * @desc 根据keycode获得键名
 * @param  {Number} keycode 
 * @return {String}
 */ 
function getKeyName(keycode) {
    if (keyCodeMap[keycode]) {
        return keyCodeMap[keycode];
    } else {
        console.log(&apos;Unknow Key(Key Code:&apos; + keycode + &apos;)&apos;);
        return &apos;&apos;;
    }
};
</code></pre><h2 id="7-Object"><a href="#7-Object" class="headerlink" title="7.Object"></a>7.Object</h2><h2 id="7-1-deepClone"><a href="#7-1-deepClone" class="headerlink" title="7.1 deepClone"></a>7.1 deepClone</h2><pre><code>/**
 * @desc 深拷贝，支持常见类型
 * @param {Any} values
 */ 
function deepClone(values) {
    var copy;

    // Handle the 3 simple types, and null or undefined if (null == values || &quot;object&quot; != typeof values) return values;

    // Handle Date if (values instanceof Date) {
        copy = new Date();
        copy.setTime(values.getTime());
        return copy;
    }

    // Handle Array if (values instanceof Array) {
        copy = [];
        for (var i = 0, len = values.length; i &lt; len; i++) {
            copy[i] = deepClone(values[i]);
        }
        return copy;
    }

    // Handle Object if (values instanceof Object) {
        copy = {};
        for (var attr in values) {
            if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);
        }
        return copy;
    }

    throw new Error(&quot;Unable to copy values! Its type isn&apos;t supported.&quot;);
}
</code></pre><h2 id="7-2-isEmptyObject"><a href="#7-2-isEmptyObject" class="headerlink" title="7.2 isEmptyObject"></a>7.2 isEmptyObject</h2><pre><code>/**
 * 
 * @desc   判断`obj`是否为空
 * @param  {Object} obj
 * @return {Boolean}
 */ 
function isEmptyObject(obj) {
    if (!obj || typeof obj !== &apos;object&apos; || Array.isArray(obj))
        return false return !Object.keys(obj).length
}
</code></pre><h2 id="8-Random"><a href="#8-Random" class="headerlink" title="8.Random"></a>8.Random</h2><h2 id="8-1-randomColor"><a href="#8-1-randomColor" class="headerlink" title="8.1 randomColor"></a>8.1 randomColor</h2><pre><code>/**
 * 
 * @desc 随机生成颜色
 * @return {String} 
 */ 
function randomColor() {
    return &apos;#&apos; + (&apos;00000&apos; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);
}
</code></pre><h2 id="8-2-randomNum"><a href="#8-2-randomNum" class="headerlink" title="8.2 randomNum"></a>8.2 randomNum</h2><pre><code>/**
 * 
 * @desc 生成指定范围随机数
 * @param  {Number} min 
 * @param  {Number} max 
 * @return {Number} 
 */ 
function randomNum(min, max) {
    return Math.floor(min + Math.random() * (max - min));
}
</code></pre><h2 id="9-Regexp"><a href="#9-Regexp" class="headerlink" title="9.Regexp"></a>9.Regexp</h2><h2 id="9-1-isEmail"><a href="#9-1-isEmail" class="headerlink" title="9.1 isEmail"></a>9.1 isEmail</h2><pre><code>/**
 * 
 * @desc   判断是否为邮箱地址
 * @param  {String}  str
 * @return {Boolean} 
 */ 
function isEmail(str) {
    return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str);
}
</code></pre><h2 id="9-2-isIdCard"><a href="#9-2-isIdCard" class="headerlink" title="9.2 isIdCard"></a>9.2 isIdCard</h2><pre><code>/**
 * 
 * @desc  判断是否为身份证号
 * @param  {String|Number} str 
 * @return {Boolean}
 */ 
function isIdCard(str) {
    return /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/.test(str)
}
</code></pre><h2 id="9-3-isPhoneNum"><a href="#9-3-isPhoneNum" class="headerlink" title="9.3 isPhoneNum"></a>9.3 isPhoneNum</h2><pre><code>/**
 * 
 * @desc   判断是否为手机号
 * @param  {String|Number} str 
 * @return {Boolean} 
 */
 function isPhoneNum(str) {
    return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/.test(str)
}
</code></pre><h2 id="9-4-isUrl"><a href="#9-4-isUrl" class="headerlink" title="9.4 isUrl"></a>9.4 isUrl</h2><pre><code>/**
 * 
 * @desc   判断是否为URL地址
 * @param  {String} str 
 * @return {Boolean}
 */ 
function isUrl(str) {
    return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str);
}
</code></pre><h2 id="10-String"><a href="#10-String" class="headerlink" title="10.String"></a>10.String</h2><h2 id="10-1-digitUppercase"><a href="#10-1-digitUppercase" class="headerlink" title="10.1 digitUppercase"></a>10.1 digitUppercase</h2><pre><code>/**
 * 
 * @desc   现金额转大写
 * @param  {Number} n 
 * @return {String}
 */
 function digitUppercase(n) {
    var fraction = [&apos;角&apos;, &apos;分&apos;];
    var digit = [
        &apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;,
        &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos;
    ];
    var unit = [
        [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;],
        [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;]
    ];
    var head = n &lt; 0 ? &apos;欠&apos; : &apos;&apos;;
    n = Math.abs(n);
    var s = &apos;&apos;;
    for (var i = 0; i &lt; fraction.length; i++) {
        s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;);
    }
    s = s || &apos;整&apos;;
    n = Math.floor(n);
    for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) {
        var p = &apos;&apos;;
        for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) {
            p = digit[n % 10] + unit[1][j] + p;
            n = Math.floor(n / 10);
        }
        s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s;
    }
    return head + s.replace(/(零.)*零元/, &apos;元&apos;)
        .replace(/(零.)+/g, &apos;零&apos;)
        .replace(/^整$/, &apos;零元整&apos;);
};
</code></pre><h2 id="11-Support"><a href="#11-Support" class="headerlink" title="11.Support"></a>11.Support</h2><h2 id="11-1-isSupportWebP"><a href="#11-1-isSupportWebP" class="headerlink" title="11.1 isSupportWebP"></a>11.1 isSupportWebP</h2><pre><code>/**
 * 
 * @desc 判断浏览器是否支持webP格式图片
 * @return {Boolean} 
 */ 
function isSupportWebP() {
    return !![].map &amp;&amp; document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0;
}
</code></pre><h2 id="12-Time"><a href="#12-Time" class="headerlink" title="12.Time"></a>12.Time</h2><h2 id="12-1-formatPassTime"><a href="#12-1-formatPassTime" class="headerlink" title="12.1 formatPassTime"></a>12.1 formatPassTime</h2><pre><code>/**
 * @desc   格式化${startTime}距现在的已过时间
 * @param  {Date} startTime 
 * @return {String}
 */ 
function formatPassTime(startTime) {
    var currentTime = Date.parse(new Date()),
        time = currentTime - startTime,
        day = parseInt(time / (1000 * 60 * 60 * 24)),
        hour = parseInt(time / (1000 * 60 * 60)),
        min = parseInt(time / (1000 * 60)),
        month = parseInt(day / 30),
        year = parseInt(month / 12);
    if (year) return year + &quot;年前&quot; if (month) return month + &quot;个月前&quot; if (day) return day + &quot;天前&quot; if (hour) return hour + &quot;小时前&quot; if (min) return min + &quot;分钟前&quot; else return &apos;刚刚&apos;
}
</code></pre><h2 id="12-2-formatRemainTime"><a href="#12-2-formatRemainTime" class="headerlink" title="12.2 formatRemainTime"></a>12.2 formatRemainTime</h2><pre><code>/**
 * 
 * @desc   格式化现在距${endTime}的剩余时间
 * @param  {Date} endTime  
 * @return {String}
 */ function formatRemainTime(endTime) {
    var startDate = new Date(); //开始时间 var endDate = new Date(endTime); //结束时间 var t = endDate.getTime() - startDate.getTime(); //时间差 var d = 0,
        h = 0,
        m = 0,
        s = 0;
    if (t &gt;= 0) {
        d = Math.floor(t / 1000 / 3600 / 24);
        h = Math.floor(t / 1000 / 60 / 60 % 24);
        m = Math.floor(t / 1000 / 60 % 60);
        s = Math.floor(t / 1000 % 60);
    }
    return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;;
}
</code></pre><h2 id="13-Url"><a href="#13-Url" class="headerlink" title="13.Url"></a>13.Url</h2><h2 id="13-1-parseQueryString"><a href="#13-1-parseQueryString" class="headerlink" title="13.1 parseQueryString"></a>13.1 parseQueryString</h2><pre><code>/**
 * 
 * @desc   url参数转对象
 * @param  {String} url  default: window.location.href
 * @return {Object} 
 */ 
function parseQueryString(url) {
    url = url == null ? window.location.href : url
    var search = url.substring(url.lastIndexOf(&apos;?&apos;) + 1)
    if (!search) {
        return {}
    }
    return JSON.parse(&apos;{&quot;&apos; + decodeURIComponent(search).replace(/&quot;/g, &apos;\\&quot;&apos;).replace(/&amp;/g, &apos;&quot;,&quot;&apos;).replace(/=/g, &apos;&quot;:&quot;&apos;) + &apos;&quot;}&apos;)
}
</code></pre><h2 id="13-2-stringfyQueryString"><a href="#13-2-stringfyQueryString" class="headerlink" title="13.2 stringfyQueryString"></a>13.2 stringfyQueryString</h2><pre><code>/**
 * 
 * @desc   对象序列化
 * @param  {Object} obj 
 * @return {String}
 */ function stringfyQueryString(obj) {
    if (!obj) return &apos;&apos;;
    var pairs = [];

    for (var key in obj) {
        var value = obj[key];

        if (value instanceof Array) {
            for (var i = 0; i &lt; value.length; ++i) {
                pairs.push(encodeURIComponent(key + &apos;[&apos; + i + &apos;]&apos;) + &apos;=&apos; + encodeURIComponent(value[i]));
            }
            continue;
        }

        pairs.push(encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(obj[key]));
    }

    return pairs.join(&apos;&amp;&apos;);
}
</code></pre><h2 id="14-Function"><a href="#14-Function" class="headerlink" title="14.Function"></a>14.Function</h2><h2 id="14-1-throttle"><a href="#14-1-throttle" class="headerlink" title="14.1 throttle"></a>14.1 throttle</h2><pre><code>/**
 * @desc   函数节流。
 * 适用于限制`resize`和`scroll`等函数的调用频率
 *
 * @param  {Number}    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}   noTrailing     可选，默认为false。
 *                                    如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。
 *                                    如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次.
 *                                    （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位）
 * @param  {Function}  callback       延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                    执行去节流功能时，调用`callback`。
 * @param  {Boolean}   debounceMode   如果`debounceMode`为true，`clear`在`delay`ms后执行。
 *                                    如果debounceMode是false，`callback`在`delay` ms之后执行。
 *
 * @return {Function}  新的节流函数
 */ function throttle(delay, noTrailing, callback, debounceMode) {

    // After wrapper has stopped being called, this timeout ensures that // `callback` is executed at the proper times in `throttle` and `end` // debounce modes. var timeoutID;

    // Keep track of the last time `callback` was executed. var lastExec = 0;

    // `noTrailing` defaults to falsy. if (typeof noTrailing !== &apos;boolean&apos;) {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing // functionality and when executed will limit the rate at which `callback` // is executed. function wrapper() {

        var self = this;
        var elapsed = Number(new Date()) - lastExec;
        var args = arguments;

        // Execute `callback` and update the `lastExec` timestamp. function exec() {
            lastExec = Number(new Date());
            callback.apply(self, args);
        }

        // If `debounceMode` is true (at begin) this is used to clear the flag // to allow future `callback` executions. function clear() {
            timeoutID = undefined;
        }

        if (debounceMode &amp;&amp; !timeoutID) {
            // Since `wrapper` is being called for the first time and // `debounceMode` is true (at begin), execute `callback`.
            exec();
        }

        // Clear any existing timeout. if (timeoutID) {
            clearTimeout(timeoutID);
        }

        if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) {
            // In throttle mode, if `delay` time has been exceeded, execute // `callback`.
            exec();

        } else if (noTrailing !== true) {
            // In trailing throttle mode, since `delay` time has not been // exceeded, schedule `callback` to execute `delay` ms after most // recent execution. // // If `debounceMode` is true (at begin), schedule `clear` to execute // after `delay` ms. // // If `debounceMode` is false (at end), schedule `callback` to // execute after `delay` ms.
            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
        }

    }

    // Return the wrapper function. return wrapper;

};
</code></pre><h2 id="14-2-debounce"><a href="#14-2-debounce" class="headerlink" title="14.2 debounce"></a>14.2 debounce</h2><pre><code>/**
 * @desc 函数防抖 
 * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次，
 * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。
 * @example 适用场景：如在线编辑的自动存储防抖。
 * @param  {Number}   delay         0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}  atBegin       可选，默认为false。
 *                                  如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。
                                    如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行
 * @param  {Function} callback      延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                  执行去抖动功能时，，调用`callback`。
 *
 * @return {Function} 新的防抖函数。
 */ 
var throttle = require(&apos;./throttle&apos;);
function debounce(delay, atBegin, callback) {
    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
};
</code></pre><p>封装</p>
<p>除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用<code>webpack</code>统一打包成<code>UMD</code> 通用模块规范，支持<code>webpack</code>、<code>RequireJS</code>、<code>SeaJS</code>等模块加载器，亦或直接通过<code>&lt;script&gt;</code>标签引入。</p>
<p>但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持按需引入吧</p>
<p>1.目录结构说明</p>
<pre><code>│  .babelrc
│  .gitignore
│  .travis.yml
│  LICENSE
│  package.json
│  README.md
│  setCookie.js  // 拷贝到根路径的函数模块，方便按需加载
│  setScrollTop.js
│  stringfyQueryString.js
│   ...
│   ...
│  
├─min
│      outils.min.js  // 所有函数统一打包生成的全量压缩包
│      
├─script  // 本项目开发脚本目录
│      build.js  // 打包构建脚本
│      test.js  // 测试脚本
│      webpack.conf.js  // webpack打包配置文件
│      
├─src // 源码目录
│  │  index.js  // webpack入口文件
│  │  
│  ├─array
│  │      
│  ├─class
│  │      
│  ├─cookie
│  │      
│  ├─device
│  │      
│  ├─dom
│  │      
│  ├─keycode
│  │      
│  ├─object
│  │      
│  ├─random
│  │      
│  ├─regexp
│  │      
│  ├─string
│  │      
│  ├─support
│  │      
│  ├─time
│  │      
│  └─url
│          
└─test // 测试用例目录
    │  array.test.js
    │  class.test.js
    │  cookie.test.js
    │  device.test.js
    │  dom.test.js
    │  index.html
    │  keycode.test.js
    │  object.test.js
    │  random.test.js
    │  regexp.test.js
    │  string.test.js
    │  support.test.js
    │  time.test.js
    │  url.test.js
    │  
    └─_lib // 测试所用到的第三方库
            mocha.css
            mocha.js
            power-assert.js
</code></pre><p>2.构建脚本</p>
<p>这里主要说明一下项目中<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fbuild.js" target="_blank" rel="noopener"> build.js </a>的构建过程<br>第一步，构建全量压缩包，先删除<code>min</code>目录中之前的<code>outils.min.js</code>，后通过<code>webpack</code>打包并保存新的压缩包至<code>min</code>目录中：</p>
<pre><code>......
 ......
 // 删除旧的全量压缩包
 rm(path.resolve(rootPath, &apos;min&apos;, `${pkg.name}.min.js`), err =&gt; {
     if (err) throw (err)
     webpack(config, function (err, stats) {
         if (err) throw (err)
         building.stop()
         process.stdout.write(stats.toString({
             colors: true,
             modules: false,
             children: false,
             chunks: false,
             chunkModules: false
         }) + &apos;\n\n&apos;)
         resolve()
         console.log(chalk.cyan(&apos;  Build complete.\n&apos;))
     })
 })
 ......
 ......
</code></pre><p>第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝<code>src</code>下面一层目录的所有<code>js</code>文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接<code>require(&#39;outils/&lt;方法名&gt;&#39;)</code>即可，缩短引入的路径，也算是提高点效率。</p>
<pre><code>// 替换模块文件
    ......
    ......
    // 先删除根目录中之前的函数模块
    rm(&apos;*.js&apos;, err =&gt; {
        if (err) throw (err)
        let folderList = fs.readdirSync(path.resolve(rootPath, &apos;src&apos;))
        folderList.forEach((item, index) =&gt; {
            // 拷贝`src`下面一层目录的所有`js`文件至根目录
            copy(`src/${item}/*.js`, rootPath, function (err, files) {
                if (err) throw err;
                if (index === folderList.length - 1) {
                    console.log(chalk.cyan(&apos;  Copy complete.\n&apos;))
                    copying.stop()
                }
            })
        })
    })
    ......
    ......
</code></pre><p>3.书写测试用例</p>
<p>俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。</p>
<p>但是因为时间关系，本项目暂时通过项目中的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Ftest.js" target="_blank" rel="noopener"> test.js </a>，启动了一个<code>koa</code>静态服务器，来加载<code>mocha</code>网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。<br>但是后续将使用<code>travis-ci</code>配合<code>Github</code>来做持续化构建，自动发布到<code>npm</code>。改用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>做单元测试，使用<code>Coverage</code>测试覆盖率。这一部分，后续更新。</p>
<p>这里给大家推荐一个好用的断言库<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252Fpackage%252Fpower-assert" target="_blank" rel="noopener"> power-assert </a>，这个库记住<code>assert(value, [message])</code>一个API就基本无敌，从此再也不用担心记不住断言库的API。</p>
<p>本项目的所有测试用例都在<code>test</code>目录下，大家可以作一定参考。</p>
<p>更新：单元测试，已使用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>，使用<code>Coverage</code>测试覆盖率，并集成<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Ftravis-ci.org%252F" target="_blank" rel="noopener"> travis-ci </a>配合<code>Github</code>来做持续化构建，可以参考本项目的<code>travis</code>配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252F.travis.yml" target="_blank" rel="noopener"> .travis.yml </a>和<code>karma</code>的配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fkarma.conf.js" target="_blank" rel="noopener"> karma.conf.js </a>。</p>
<blockquote>
<p>发布</p>
</blockquote>
<p>首先放到<code>Github</code>托管一下，当然你也可以直接<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252F" target="_blank" rel="noopener">fork</a>本项目，然后再加入你自己的函数。<br>以笔者项目，举个栗子:</p>
<p>1.添加自己的函数</p>
<p>在<code>src</code>目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。</p>
<pre><code>/**
 * 
 * @desc   判断是否NaN
 * @param  {Any} value 
 * @return {Boolean}
 */ 
function isNaN(value) {    
    return value !== value;
};

modules.export = isNaN
</code></pre><p>然后记得在src/index.js文件中暴露isNaN函数</p>
<p>2.单元测试</p>
<p>在<code>test</code>文件新建测试用例</p>
<pre><code>describe(&apos;#isNaN()&apos;, function () {
    it(`outils.isNaN(NaN) should return true`, function () {
        assert(outils.isNaN(NaN))
    })
    it(`outils.isNaN(&apos;value&apos;) should return false`, function () {
        assert.notEqual(outils.isNaN(NaN))
    })
})
</code></pre><p>然后记得在<code>test/index.html</code>中引入之前创建的测试用例脚本。</p>
<p>3.测试并打包</p>
<p>执行<code>npm run test</code>，看所有的测试用例是否通过。如果没有问题，执行<code>npm run build</code>构建，之后提交到个人的 github 仓库即可。</p>
<p>4.发布到<code>npm</code></p>
<p>在<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>注册账号，修改本地<code>package.json</code>中的<code>name</code>、<code>version</code>、<code>author</code>等信息，最后<code>npm publish</code>就大功告成了。<br>注意：向<code>npm</code>发包，要把镜像源切到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>，使用<code>cnpm</code>等第三方镜像源会报错。</p>
<p>使用</p>
<p>1.浏览器</p>
<p>直接下载<code>min</code>目录下的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fmin%252Foutils.min.js" target="_blank" rel="noopener"> outils.min.js </a>，通过<code>&lt;script&gt;</code>标签引入。</p>
<pre><code>&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var OS = outils.getOS()
  &lt;/script&gt;
</code></pre><p>注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Freleases" target="_blank" rel="noopener"> github Release </a>页面下载对应版本号的代码。</p>
<p>2.Webpack、RequireJS、SeaJS等模块加载器</p>
<p>先使用<code>npm</code>安装<code>outils</code>。</p>
<pre><code>$ npm install --save-dev outils
// 完整引入 const outils = require(&apos;outils&apos;)
const OS = outils.getOS()
推荐使用方法 
// 按需引入require(&apos;outils/&lt;方法名&gt;&apos;) const getOS = require(&apos;outils/getOS&apos;)
const OS = getOS()
</code></pre><p>当然，你的开发环境有<code>babel</code>编译<code>ES6</code>语法的话，也可以这样使用：</p>
<pre><code>import getOS from &apos;outils/getOS&apos; // 或 import { getOS } from &quot;outils&quot;;
</code></pre><p>总结</p>
<p>这里只是简单封装，发布到<code>npm</code>上，省去下次复制粘贴的功夫，或者直接Goole的时间。如果笔者的库中，没有你常用的函数，或者你有更好的建议，欢迎来本项目的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fissues" target="_blank" rel="noopener"> Github Issues </a>交流，如果觉得不错，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。</p>
<p>当然，更好的建议是<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> fork </a>本项目，或者直接新建自己的项目，添加自己 想要的 、常用的 、记不住的 函数，甚至是可以抽象出来的功能，封装成自己顺手、熟悉的库。 这样才能打造出你自己的武器库，瞬间提高你的单兵作战（开发）能力。</p>
<h2 id="libraries-：https-github-com-wuxianqiang-libraries"><a href="#libraries-：https-github-com-wuxianqiang-libraries" class="headerlink" title="libraries ：https://github.com/wuxianqiang/libraries"></a>libraries ：<a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries" target="_blank" rel="noopener">https://github.com/wuxianqiang/libraries</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectcreate%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.create()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADstringtrim%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中String.trim()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarrayreduce%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.reduce()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectkeys%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.keys()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADfunctionbind%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Function.bind()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarraymap%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.map()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFmathmax%25E6%2596%25B9%25E6%25B3%2595%25E4%25B8%258D%25E5%25AE%259A%25E5%25AE%259E%25E5%258F%2582%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿Math.max()方法实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFstringmatch%25E6%2596%25B9%25E6%25B3%2595%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">仿String.match()方法实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFhtml5%25E7%259A%2584classlist%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">仿HTML5的classList属性实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2587%25BD%25E6%2595%25B0%25E7%259A%2584%25E5%2590%258D%25E5%25AD%2597" target="_blank" rel="noopener">仿Function.name属性实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E5%25B1%2582%25E7%25A5%2596%25E5%2585%2588%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n层祖先元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%2585%2584%25E5%25BC%259F%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个兄弟元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%25AD%2590%25E4%25BB%25A3%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个子代元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB1" target="_blank" rel="noopener">原生JS实现CSS动画之震动</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB2" target="_blank" rel="noopener">原生JS实现CSS动画之隐藏</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E6%2595%25B0%25E7%25BB%2584%25E4%25B8%25AD%25E6%259F%25A5%25E6%2589%25BE%25E6%2589%2580%25E6%259C%2589%25E5%2587%25BA%25E7%258E%25B0%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E6%2596%25B9%25E6%25B3%2595" target="_blank" rel="noopener">在数组中查找所有出现的元素方法</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E6%258D%25AE%25E7%25B1%25BB%25E5%259E%258B%25E6%25A3%2580%25E6%25B5%258B%25E7%2589%25B9%25E6%25AE%258A%25E6%2583%2585%25E5%2586%25B5%25E7%2589%25B9%25E6%25AE%258A%25E5%25A4%2584%25E7%2590%2586" target="_blank" rel="noopener">数据类型检测之特殊情况特殊处理</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0outerhtml%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">使用innerHTML实现outerHTML属性</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258F%2592%25E5%2585%25A5%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">插入节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2580%2592%25E5%25BA%258F%25E6%258E%2592%25E5%2588%2597%25E5%25AD%2590%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">倒序排列子节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E6%25BB%259A%25E5%258A%25A8%25E6%259D%25A1%25E7%259A%2584%25E4%25BD%258D%25E7%25BD%25AE" target="_blank" rel="noopener">查询窗口滚动条的位置</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E7%259A%2584%25E8%25A7%2586%25E5%258F%25A3%25E5%25B0%25BA%25E5%25AF%25B8" target="_blank" rel="noopener">查询窗口的视口尺寸</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25A1%25A8%25E6%25A0%25BC%25E7%259A%2584%25E8%25A1%258C%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">表格的行排序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E7%2594%259F%25E6%2588%2590%25E7%259B%25AE%25E5%25BD%2595%25E8%25A1%25A8" target="_blank" rel="noopener">生成目录表</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E7%25BB%2584%25E5%258E%25BB%25E9%2587%258D" target="_blank" rel="noopener">数组去重</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">冒泡排序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%258Eurl%25E8%25A7%25A3%25E6%259E%2590%25E5%258F%2582%25E6%2595%25B0" target="_blank" rel="noopener">从URL解析参数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%258E%25B7%25E5%258F%2596%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">获取纯文本的元素内容</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2589%258B%25E5%2586%2599%25E4%25B8%2580%25E4%25B8%25AAjsonp%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">手写一个JSONP实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E5%25BD%25A2%25E5%25BC%258F%25E7%259A%2584%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">查询纯文本形式的内容</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E6%2589%25BE%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E5%2590%258E%25E4%25BB%25A3%25E4%25B8%25AD%25E8%258A%2582%25E7%2582%25B9%25E4%25B8%25AD%25E7%259A%2584%25E6%2589%2580%25E6%259C%2589text%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">查找元素的后代中节点中的所有Text节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0insertadjacenthtml" target="_blank" rel="noopener">使用innerHTML实现insertAdjacentHTML</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258B%2596%25E6%258B%25BD" target="_blank" rel="noopener">拖拽</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E8%25B0%25B7%25E6%25AD%258C%25E5%259C%25B0%25E5%259B%25BE%25E4%25B8%258A%25E6%2598%25BE%25E7%25A4%25BA%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E4%25BF%25A1%25E6%2581%25AF" target="_blank" rel="noopener">在谷歌地图上显示地理位置信息</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8%25E6%2589%2580%25E6%259C%2589%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E7%2589%25B9%25E6%2580%25A7" target="_blank" rel="noopener">使用所有地理位置特性</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BC%2598%25E9%259B%2585%25E7%259A%2584%25E5%259B%25BE%25E7%2589%2587%25E7%25BF%25BB%25E8%25BD%25AC%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">优雅的图片翻转实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E5%25A4%259A%25E8%25BE%25B9%25E5%25BD%25A2" target="_blank" rel="noopener">使用canvas绘制多边形</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E9%259B%25AA%25E8%258A%25B1" target="_blank" rel="noopener">使用canvas绘制雪花</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8web-worker%25E4%25B8%25AD%25E5%258F%2591%25E8%25B5%25B7%25E5%2590%258C%25E6%25AD%25A5xmlhtttprequest" target="_blank" rel="noopener">在Web Worker中发起同步XMLHtttpRequest</a></li>
</ul>
<h2 id="仿ECMAScript5中Object-create-函数"><a href="#仿ECMAScript5中Object-create-函数" class="headerlink" title="仿ECMAScript5中Object.create()函数"></a>仿ECMAScript5中Object.create()函数</h2><pre><code>function inherit(obj) {
            if (obj === null) throw TypeError();
            if (Object.create) return Object.create(obj);
            var t = typeof obj;
            if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) throw TypeError();
            function Fn() {};
            Fn.prototype = obj;
            return new Fn();
        }
</code></pre><h2 id="仿ECMAScript5中String-trim-函数"><a href="#仿ECMAScript5中String-trim-函数" class="headerlink" title="仿ECMAScript5中String.trim()函数"></a>仿ECMAScript5中String.trim()函数</h2><pre><code>String.prototype.mytrim = function () {
            String.prototype.trim || function () {
                if (!this) return this; //空字符串不做处理
                return this.replace(/^\s+|\s+$/g, &quot;&quot;) //使用正则表达式经行空格替换
            }
        }
</code></pre><h2 id="仿ECMAScript5中Array-reduce-函数"><a href="#仿ECMAScript5中Array-reduce-函数" class="headerlink" title="仿ECMAScript5中Array.reduce()函数"></a>仿ECMAScript5中Array.reduce()函数</h2><pre><code>var reduce = Array.prototype.reduce ? function (ary, fn, initial) {
            if (arguments.length &gt; 2) { //如果reduce()方法存在的话
                return ary.reduce(fn, initial); //如果传入了一个初始值
            } else {
                return ary.reduce(fn); //否则初始值
            }
        } : function (ary, fn, initial) { //以特定的初始值开始，否则第一个值取自ary
            var i = 0,
                len = ary.length,
                accumulator;
            if (arguments.length &gt; 2) {
                accumulator = initial;
            } else { //找到数组中第一个已经定义的索引
                if (len == 0) throw TypeError();
                while (i &lt; len) {
                    if (i in ary) {
                        accumulator = ary[i++];
                        break;
                    } else {
                        i++;
                    }
                }
                if (i == len) throw TypeError();
            }
            while (i &lt; len) { //对于数组中剩下的元素依次调用fn
                if (i in ary) {
                    accumulator = fn.call(undefined, accumulator, ary[i], i, ary)
                }
                i++;
            }
            return accumulator;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在数组中查找所有出现的元素方法"><a href="#在数组中查找所有出现的元素方法" class="headerlink" title="在数组中查找所有出现的元素方法"></a>在数组中查找所有出现的元素方法</h2><pre><code>function findAll(ary, ele) {
            var results = [],
                len = ary.length,
                pos = 0;
            while (pos &lt; len) {
                pos = ary.indexOf(ele, pos);
                if (pos === -1) break;
                results.push(pos);
                pos++;
            }
            return results;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="数据类型检测，特殊情况特殊处理"><a href="#数据类型检测，特殊情况特殊处理" class="headerlink" title="数据类型检测，特殊情况特殊处理"></a>数据类型检测，特殊情况特殊处理</h2><pre><code>function classOf(obj) {
            if (obj === null) return &quot;Null&quot;;
            if (obj === undefined) return &apos;Undefined&apos;;
            return Object.prototype.toString.call(obj).slice(8, -1);
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Object-keys-函数"><a href="#仿ECMAScript5中Object-keys-函数" class="headerlink" title="仿ECMAScript5中Object.keys()函数"></a>仿ECMAScript5中Object.keys()函数</h2><pre><code>function keys(obj) {
            if (typeof obj !== &quot;object&quot;) {
                throw TypeError();
            }
            var result = [];
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    result.push(prop);
                }
            }
            return result;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿Math-max方法（不定实参函数）"><a href="#仿Math-max方法（不定实参函数）" class="headerlink" title="仿Math.max方法（不定实参函数）"></a>仿Math.max方法（不定实参函数）</h2><pre><code>function max() {
            var max = Number.NEGATIVE_INFINITY;
            for (var i = 0; i &lt; arguments.length; i++) {
                if (arguments[i] &gt; max) max = arguments[i];
            }
            return max;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Function-bind-函数"><a href="#仿ECMAScript5中Function-bind-函数" class="headerlink" title="仿ECMAScript5中Function.bind()函数"></a>仿ECMAScript5中Function.bind()函数</h2><pre><code>if (!Function.prototype.bind) {
            Function.prototype.bind = function (obj) {
                var self = this,
                    boundArgs = arguments;
                return function () {
                    var args = [],
                        i;
                    for (i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);
                    for (i = 1; i &lt; arguments.length; i++) args.push(arguments[i]);
                    return self.apply(obj, args);
                }
            }
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Array-map-函数"><a href="#仿ECMAScript5中Array-map-函数" class="headerlink" title="仿ECMAScript5中Array.map()函数"></a>仿ECMAScript5中Array.map()函数</h2><pre><code>var map = Array.prototype.map ? function (ary, fn) {
            return ary.map(fn);
        } : function (ary, fn) {
            var results = [];
            for (var i = 0, len = ary.length; i &lt; len; i++) {
                if (i in ary) {
                    results[i] = fn.call(null, ary[i], i, ary);
                }
            }
            return results;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code>Array.prototype.unique = function unique() {
            var obj = {};
            for (var i = 0; i &lt; this.length; i++) {
                var current = this[i];
                if (obj[current] === current) {
                    current = this[this.length - 1];
                    this.length--;
                    i--;
                    continue;
                }
                obj[current] = current
            }
            obj = null;
            return this;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>Array.prototype.bubbleSort = function bubbleSort() {
            var temp = null;
            for (var i = 0; i &lt; this.length - 1; i++) {
                for (var k = 0; k &lt; this.length - 1 - i; k++) {
                    if (this[k] &gt; this[k + 1]) {
                        temp = this[k];
                        this[k] = this[k + 1];
                        this[k + 1] = temp;
                    }
                }
            }
            return this;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿String-match-方法实现"><a href="#仿String-match-方法实现" class="headerlink" title="仿String.match()方法实现"></a>仿String.match()方法实现</h2><pre><code>String.prototype.mymatch = function (reg) {
         var ary = [];
         var res = reg.exec(this);
         while (res) {
            ary.push(res[0]);
            res = reg.exec(this);
         }
         return ary;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n层祖先元素"><a href="#返回元素的第n层祖先元素" class="headerlink" title="返回元素的第n层祖先元素"></a>返回元素的第n层祖先元素</h2><pre><code>/**
        *返回元素ele的第n层祖先元素，如果不存在此类祖先或祖先不是Element，
        *（例如Document或者DocumentFragment）则返回null
        *如果n为0，则返回e本身。如果n为1（或省略），则返回其父元素
        *如果n为2，则返回其祖父元素，依次类推
        */
        function parent(ele, n) {
            if (n === nudefined) n = 1;
            while (n-- &amp;&amp; ele) {
                ele = ele.parentNode;
            }
            if (!ele || ele.nodeTope !== 1) return null;
            return ele;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n个兄弟元素"><a href="#返回元素的第n个兄弟元素" class="headerlink" title="返回元素的第n个兄弟元素"></a>返回元素的第n个兄弟元素</h2><pre><code>/**
 *返回元素ele的第n个兄弟元素
 *如果n为正，返回后续的第n个兄弟元素
 *如果n为负，返回前面的第n个兄弟元素
 *如果n为零，返回ele本身
 */
function sibling(ele, n) {
    while (ele &amp;&amp; n !== 0) { //如果ele未定义，即刻返回它
        if (n &gt; 0) { //查找后续的兄弟元素
            if (ele.nextElementSibling) {
                ele = ele.nextElementSibling;
            } else {
                for (ele = ele.nextSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;
            }
            n--;
        } else { //查找前面的兄弟元素
            if (ele.previousElementSibing) {
                ele = ele.previousElementSibling;
            } else {
                for (ele = ele.previousSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;
            }
            n++;
        }
    }
    return ele;
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n个子代元素"><a href="#返回元素的第n个子代元素" class="headerlink" title="返回元素的第n个子代元素"></a>返回元素的第n个子代元素</h2><pre><code>/**
 *返回元素ele的第n代子元素，如果不存在则为null
 *负值n代表从后往前计数。0表示第一个子元素，而-1代表最后一个，-2代表倒数第二个，依次类推
 */
function child(ele, n) {
    if (ele.children) { //如果children数组存在
        if (n &lt; 0) n += ele.children.length; //转换负的n为数组索引
        if (n &lt; 0) return null; //如果它仍然为负，说明没有子元素
        return ele.children[n]; //返回指定的子元素
    }
    //如果e没有children数组，找到第一个子元素并向前数，或找到最后一个子元素并往回数
    if (n &gt;= 0) { //n非负：从第一个子元素向前数
        //找到元素e的第一个子元素
        if (ele.firstElementChild) {
            ele = ele.firstElementChild;
        } else {
            for (ele = ele.firstChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;
        }
        return sibling(ele, n); //返回第一个子元素的第n个兄弟元素
    } else { //n为负：从最后一个子元素往回数
        if (ele.lastElementChild) {
            ele = ele.lastElementChild;
        } else {
            for (ele = ele.lastChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;
        }
        return sibling(ele, n + 1); //+1来转化最后1个子元素为最后1个兄弟元素
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="表格的行排序"><a href="#表格的行排序" class="headerlink" title="表格的行排序"></a>表格的行排序</h2><pre><code>//根据指定表格每行第n个单元格的值，对第一个＜tbody＞中的行进行排序
//如果存在comparator函数则使用它，否则按字母表顺序比较
function sortrows(table, n, comparator) {
    var tbody = table.tBodies[0]; //第一个＜tbody＞，可能是隐式创建的
    var rows = tbody.getElementsByTagName(&quot;tr&quot;); //tbody中的所有行
    rows = Array.prototype.slice.call(rows, 0); //真实数组中的快照
    //基于第n个＜td＞元素的值对行排序
    rows.sort(function (row1, row2) {
        var cell1 = row1.getElementsByTagName(&quot;td&quot;)[n]; //获得第n个单元格
        var cell2 = row2.getElementsByTagName(&quot;td&quot;)[n]; //两行都是
        var val1 = cell1.textContent || cell1.innerText; //获得文本内容
        var val2 = cell2.textContent || cell2.innerText; //两单元格都是
        if (comparator) return comparator(val1, val2); //进行比较
        if (val1 &lt; val2) {
            return -1;
        } else if (val1 &gt; val2) {
            return 1;
        } else {
            return 0;
        }
    }); //在tbody中按它们的顺序把行添加到最后
    //这将自动把它们从当前位置移走，故没必要预先删除它们
    //如果＜tbody＞还包含了除了＜tr＞的任何其他元素，这些节点将会悬浮到顶部位置
    for (var i = 0; i &lt; rows.length; i++) tbody.appendChild(rows[i]);
}
//查找表格的＜th＞元素（假设只有一行），让它们可单击，
//以便单击列标题，按该列对行排序
function makeSortable(table) {
    var headers = table.getElementsByTagName(&quot;th&quot;);
    for (var i = 0; i &lt; headers.length; i++) {
        (function (n) { //嵌套函数来创建本地作用域
            headers[i].onclick = function () {
                sortrows(table, n);
            };
        }(i)); //将i的值赋给局部变量n
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="生成目录表"><a href="#生成目录表" class="headerlink" title="生成目录表"></a>生成目录表</h2><pre><code>/**
 *
 *这个模块注册一个可在页面加载完成后自动运行的匿名函数。当执行这个函数时会去文档中查找
 *id为&quot;TOC&quot;的元素。如果这个元素不存在，就创建一个元素
 *
 *生成的TOC目录应当具有自己的CSS样式。整个目录区域的样式className设置为&quot;TOCEntry&quot;
 *同样我们为不同层级的目录标题定义不同的样式。＜h1＞标签生成的标题
 *className为&quot;TOCLevel1&quot;，＜h2＞标签生成的标题className为&quot;TOCLevel2&quot;，以此类推
 *段编号的样式为&quot;TOCSectNum&quot;
 *
 *完整的CSS样式代码如下:
 *
 *#TOC{border:solid black 1px;margin:10px;padding:10px;}
 *.TOCEntry{font-family:sans-serif;}
 *.TOCEntry a{text-decoration:none;}
 *.TOCLevel1{font-size:16pt;font-weight:bold;}
 *.TOCLevel2{font-size:12pt;margin-left:.5in;}
 *.TOCSectNum:after{content:&quot;:&quot;;}
 *
 *这段代码的最后一行表示每个段编号之后都有一个冒号和空格符。要想隐藏段编号，
 *请使用这行代码：
 *.TOCSectNum{display:none}
 *
 **/
(function () { //匿名函数定义了一个局部作用域
    //查找TOC容器元素
    //如果不存在，则在文档开头处创建一个
    var toc = document.getElementById(&quot;TOC&quot;);
    if (!toc) {
        toc = document.createElement(&quot;div&quot;);
        toc.id = &quot;TOC&quot;;
        document.body.insertBefore(toc, document.body.firstChild);
    }
    //查找所有的标题元素
    var headings;
    if (document.querySelectorAll) //我们是否能用这个简单的方法？
        headings = document.querySelectorAll(&quot;h1,h2,h3,h4,h5,h6&quot;);
    else //否则，查找方法稍微麻烦一些
        headings = findHeadings(document.body, []); //递归遍历document的body，查找标题元素
    function findHeadings(root, sects) {
        for (var c = root.firstChild; c != null; c = c.nextSibling) {
            if (c.nodeType !== 1) continue;
            if (c.tagName.length == 2 &amp;&amp; c.tagName.charAt(0) == &quot;H&quot;)
                sects.push(c);
            else
                findHeadings(c, sects);
        }
        return sects;
    }
    //初始化一个数组来保持跟踪章节号
    var sectionNumbers = [0, 0, 0, 0, 0, 0]; //现在，循环已找到的标题元素
    for (var h = 0; h &lt; headings.length; h++) {
        var heading = headings[h]; //跳过在TOC容器中的标题元素
        if (heading.parentNode == toc) continue; //判定标题的级别
        var level = parseInt(heading.tagName.charAt(1));
        if (isNaN(level) || level &lt; 1 || level &gt; 6) continue; //对于该标题级别增加sectionNumbers对应的数字
        //重置所有标题比它级别低的数字为零
        sectionNumbers[level - 1]++;
        for (var i = level; i &lt; 6; i++) sectionNumbers[i] = 0; //现在，将所有标题级别的章节号组合产生一个章节号， 如2 .3 .1
        var sectionNumber = sectionNumbers.slice(0, level).join(&quot;.&quot;) //为标题级别增加章节号
        //把数字放在＜span＞中，使得其可以用样式修饰
        var span = document.createElement(&quot;span&quot;);
        span.className = &quot;TOCSectNum&quot;;
        span.innerHTML = sectionNumber;
        heading.insertBefore(span, heading.firstChild); //用命名的锚点将标题包起来，以便为它增加链接
        var anchor = document.createElement(&quot;a&quot;);
        anchor.name = &quot;TOC&quot; + sectionNumber;
        heading.parentNode.insertBefore(anchor, heading);
        anchor.appendChild(heading); //现在为该节创建一个链接
        var link = document.createElement(&quot;a&quot;);
        link.href = &quot;#TOC&quot; + sectionNumber; //链接的目标地址
        link.innerHTML = heading.innerHTML; //链接文本与实际标题一致
        //将链接放在一个div中，div用基于级别名字的样式修饰
        var entry = document.createElement(&quot;div&quot;);
        entry.className = &quot;TOCEntry TOCLevel&quot; + level;
        entry.appendChild(link); //该div添加到TOC容器中
        toc.appendChild(entry);
    }
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="从URL解析参数"><a href="#从URL解析参数" class="headerlink" title="从URL解析参数"></a>从URL解析参数</h2><pre><code>/*
 *这个函数用来解析来自URL的查询串中的name=value参数对
 *它将name=value对存储在一个对象的属性中，并返回该对象
 *这样来使用它
 *
 *var args=urlArgs();//从URL中解析参数
 *var q=args.q||&quot;&quot;;//如果参数定义了的话就使用参数；否则使用一个默认值
 *var n=args.n?parseInt(args.n):10;
 */
function urlArgs() {
    var args = {}; //定义一个空对象
    var query = location.search.substring(1); //查找到查询串，并去掉&apos;?&apos;
    var pairs = query.split(&quot;&amp;&quot;); //根据&quot;&amp;&quot;符号将查询字符串分隔开
    for (var i = 0; i &lt; pairs.length; i++) { //对于每个片段
        var pos = pairs[i].indexOf(&apos;=&apos;); //查找&quot;name=value&quot;
        if (pos == -1) continue; //如果没有找到的话，就跳过
        var name = pairs[i].substring(0, pos); //提取name
        var value = pairs[i].substring(pos + 1); //提取value
        value = decodeURIComponent(value); //对value进行解码
        args[name] = value; //存储为属性
    }
    return args; //返回解析后的参数
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="获取纯文本的元素内容"><a href="#获取纯文本的元素内容" class="headerlink" title="获取纯文本的元素内容"></a>获取纯文本的元素内容</h2><pre><code>/**
 *一个参数，返回元素的textContent或innerText
 *两个参数，用value参数的值设置元素的textContent或innerText
 */
function textContent(element, value) {
    var content = element.textContent; //检测textContent是否有定义
    if (value === undefined) { //没传递value，因此返回当前文本
        if (content !== undefined) {
            return content;
        } else {
            return element.innerText;
        }
    } else { //传递了value，因此设置文本
        if (content !== undefined) {
            element.textContent = value;
        } else {
            element.innerText = value;
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="手写一个JSONP实现"><a href="#手写一个JSONP实现" class="headerlink" title="手写一个JSONP实现"></a>手写一个JSONP实现</h2><pre><code>//根据指定的URL发送一个JSONP请求
//然后把解析得到的响应数据传递给回调函数
//在URL中添加一个名为jsonp的查询参数，用于指定该请求的回调函数的名称
function getJSONP(url, callback) { //为本次请求创建一个唯一的回调函数名称
    var cbnum = &quot;cb&quot; + getJSONP.counter++; //每次自增计数器
    var cbname = &quot;getJSONP.&quot; + cbnum; //作为JSONP函数的属性
    //将回调函数名称以表单编码的形式添加到URL的查询部分中
    //使用jsonp作为参数名，一些支持JSONP的服务
    //可能使用其他的参数名，比如callback
    if (url.indexOf(&quot;?&quot;) === -1) //URL没有查询部分
        url += &quot;?jsonp=&quot; + cbname; //作为查询部分添加参数
    else //否则
        url += &quot;＆jsonp=&quot; + cbname; //作为新的参数添加它
    //创建script元素用于发送请求
    var script = document.createElement(&quot;script&quot;); //定义将被脚本执行的回调函数
    getJSONP[cbnum] = function (response) {
        try {
            callback(response); //处理响应数据
        } finally { //即使回调函数或响应抛出错误
            delete getJSONP[cbnum]; //删除该函数
            script.parentNode.removeChild(script); //移除script元素
        }
    }; //立即触发HTTP请求
    script.src = url; //设置脚本的URL
    document.body.appendChild(script); //把它添加到文档中
}
getJSONP.counter = 0; //用于创建唯一回调函数名称的计数器
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><pre><code>//将child节点插入到parent中，使其成为第n个子节点
function insertAt(parent, child, n) {
    if (n &lt; 0 || n &gt; parent.childNodes.length) {
        throw new Error(&quot;invalid index&quot;);
    } else if (n == parent.childNodes.length) {
        parent.appendChild(child);
    } else {
        parent.insertBefore(child, parent.childNodes[n]);
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用innerHTML实现outerHTML属性"><a href="#使用innerHTML实现outerHTML属性" class="headerlink" title="使用innerHTML实现outerHTML属性"></a>使用innerHTML实现outerHTML属性</h2><pre><code>//为那些不支持它的浏览器实现outerHTML属性
//假设浏览器确实支持innerHTML，并有个可扩展的Element.prototype，
//并且可以定义getter和setter
(function () { //如果outerHTML存在，则直接返回
    if (document.createElement(&quot;div&quot;).outerHTML) return; //返回this所引用元素的外部HTML
    function outerHTMLGetter() {
        var container = document.createElement(&quot;div&quot;); //虚拟元素
        container.appendChild(this.cloneNode(true)); //复制到该虚拟节点
        return container.innerHTML; //返回虚拟节点的innerHTML
    }
    //用指定的值设置元素的外部HTML
    function outerHTMLSetter(value) { //创建一个虚拟元素，设置其内容为指定的值
        var container = document.createElement(&quot;div&quot;);
        container.innerHTML = value; //将虚拟元素中的节点全部移动到文档中
        while (container.firstChild) //循环，直到container没有子节点为止
            this.parentNode.insertBefore(container.firstChild, this); //删除所被取代的节点
        this.parentNode.removeChild(this);
    }
    //现在使用这两个函数作为所有Element对象的outerHTML属性的getter和setter
    //如果它存在则使用ES5的Object.defineProperty()方法，
    //否则，退而求其次，使用__defineGetter__()和__defineSetter__()
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, &quot;outerHTML&quot;, {
            get: outerHTMLGetter,
            set: outerHTMLSetter,
            enumerable: false,
            configurable: true
        });
    } else {
        Element.prototype.__defineGetter__(&quot;outerHTML&quot;, outerHTMLGetter);
        Element.prototype.__defineSetter__(&quot;outerHTML&quot;, outerHTMLSetter);
    }
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="倒序排列子节点"><a href="#倒序排列子节点" class="headerlink" title="倒序排列子节点"></a>倒序排列子节点</h2><pre><code>//倒序排列节点n的子节点
function reverse(n) { //创建一个DocumentFragment作为临时容器
    var f = document.createDocumentFragment(); //从后至前循环子节点，将每一个子节点移动到文档片段中
    //n的最后一个节点变成f的第一个节点，反之亦然
    //注意，给f添加一个节点，该节点自动地会从n中删除
    while (n.lastChild) f.appendChild(n.lastChild); //最后，把f的所有子节点一次性全部移回n中
    n.appendChild(f);
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询窗口滚动条的位置"><a href="#查询窗口滚动条的位置" class="headerlink" title="查询窗口滚动条的位置"></a>查询窗口滚动条的位置</h2><pre><code>//以一个对象的x和y属性的方式返回滚动条的偏移量
function getScrollOffsets(w) { //使用指定的窗口，如果不带参数则使用当前窗口
    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用
    if (w.pageXOffset != null) return {
        x: w.pageXOffset,
        y: w.pageYOffset
    }; //对标准模式下的IE（或任何浏览器）
    var d = w.document;
    if (document.compatMode == &quot;CSS1Compat&quot;)
        return {
            x: d.documentElement.scrollLeft,
            y: d.documentElement.scrollTop
        }; //对怪异模式下的浏览器
    return {
        x: d.body.scrollLeft,
        y: d.body.scrollTop
    };
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询窗口的视口尺寸"><a href="#查询窗口的视口尺寸" class="headerlink" title="查询窗口的视口尺寸"></a>查询窗口的视口尺寸</h2><pre><code>//作为一个对象的w和h属性返回视口的尺寸
function getViewportSize(w) { //使用指定的窗口，如果不带参数则使用当前窗口
    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用
    if (w.innerWidth != null) return {
        w: w.innerWidth,
        h: w.innerHeight
    }; //对标准模式下的IE（或任何浏览器）
    var d = w.document;
    if (document.compatMode == &quot;CSS1Compat&quot;)
        return {
            w: d.documentElement.clientWidth,
            h: d.documentElement.clientHeight
        }; //对怪异模式下的浏览器
    return {
        w: d.body.clientWidth,
        h: d.body.clientWidth
    };
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回函数的名字"><a href="#返回函数的名字" class="headerlink" title="返回函数的名字"></a>返回函数的名字</h2><pre><code>Function.prototype.getName = function () {
    return this.name || this.toString().match(/function\s*(\w*)\s*\(/)[1];
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="原生JS实现CSS动画1"><a href="#原生JS实现CSS动画1" class="headerlink" title="原生JS实现CSS动画1"></a>原生JS实现CSS动画1</h2><pre><code>//将e转化为相对定位的元素，使之左右&quot;震动&quot;
//第一个参数可以是元素对象或者元素的id
//如果第二个参数是函数，以e为参数，它将在动画结束时调用
//第三个参数指定e震动的距离，默认是5像素
//第四个参数指定震动多久，默认是500毫秒
function shake(e, oncomplete, distance, time) { //句柄参数
    if (typeof e === &quot;string&quot;) e = document.getElementById(e);
    if (!time) time = 500;
    if (!distance) distance = 5;
    var originalStyle = e.style.cssText; //保存e的原始style
    e.style.position = &quot;relative&quot;; //使e相对定位
    var start = (new Date()).getTime(); //注意，动画的开始时间
    animate(); //动画开始
    //函数检查消耗的时间，并更新e的位置
    //如果动画完成，它将e还原为原始状态
    //否则，它更新e的位置，安排它自身重新运行
    function animate() {
        var now = (new Date()).getTime(); //得到当前时间
        var elapsed = now - start; //从开始以来消耗了多长时间？
        var fraction = elapsed / time; //是总时间的几分之几？
        if (fraction &lt; 1) { //如果动画未完成
            //作为动画完成比例的函数，计算e的x位置
            //使用正弦函数将完成比例乘以4pi
            //所以，它来回往复两次
            var x = distance * Math.sin(fraction * 4 * Math.PI);
            e.style.left = x + &quot;px&quot;; //在25毫秒后或在总时间的最后尝试再次运行函数
            //目的是为了产生每秒40帧的动画
            setTimeout(animate, Math.min(25, time - elapsed));
        } else { //否则，动画完成
            e.style.cssText = originalStyle //恢复原始样式
            if (oncomplete) oncomplete(e); //调用完成后的回调函数
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="原生JS实现CSS动画2"><a href="#原生JS实现CSS动画2" class="headerlink" title="原生JS实现CSS动画2"></a>原生JS实现CSS动画2</h2><pre><code>function fadeOut(e, oncomplete, time) {
    if (typeof e === &quot;string&quot;) e = document.getElementById(e);
    if (!time) time = 500; //使用Math.sqrt作为一个简单的“缓动函数”来创建动画
    //精巧的非线性：一开始淡出得比较快，然后缓慢了一些
    var ease = Math.sqrt;
    var start = (new Date()).getTime(); //注意：动画开始的时间
    animate(); //动画开始
    function animate() {
        var elapsed = (new Date()).getTime() - start; //消耗的时间
        var fraction = elapsed / time; //总时间的几分之几？
        if (fraction &lt; 1) { //如果动画未完成
            var opacity = 1 - ease(fraction); //计算元素的不透明度
            e.style.opacity = String(opacity); //设置在e上
            setTimeout(animate, //调度下一帧
                Math.min(25, time - elapsed));
        } else { //否则，动画完成
            e.style.opacity = &quot;0&quot;; //使e完全透明
            if (oncomplete) oncomplete(e); //调用完成后的回调函数
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿HTML5的classList属性"><a href="#仿HTML5的classList属性" class="headerlink" title="仿HTML5的classList属性"></a>仿HTML5的classList属性</h2><pre><code>/*
 *如果e有classList属性则返回它。否则，返回一个为e模拟DOMTokenList API的对象
 *返回的对象有contains()、add()、remove()、toggle()和toString()等方法
 *来检测和修改元素e的类集合。如果classList属性是原生支持的，
 *返回的类数组对象有length和数组索引属性。模拟DOMTokenList不是类数组对象，
 *但是它有一个toArray()方法来返回一个含元素类名的纯数组快照
 */
function classList(e) {
    if (e.classList) return e.classList; //如果e.classList存在，则返回它
    else return new CSSClassList(e); //否则，就伪造一个
}
//CSSClassList是一个模拟DOMTokenList的JavaScript类
function CSSClassList(e) {
    this.e = e;
} //如果e.className包含类名c则返回true否则返回false
CSSClassList.prototype.contains = function (c) { //检查c是否是合法的类名
    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)
        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //首先是常规检查
    var classes = this.e.className;
    if (!classes) return false; //e不含类名
    if (classes === c) return true; //e有一个完全匹配的类名
    //否则，把c自身看做一个单词，利用正则表达式搜索c
    //\b在正则表达式里代表单词的边界
    return classes.search(&quot;\\b&quot; + c + &quot;\\b&quot;) != -1;
}; //如果c不存在，将c添加到e.className中
CSSClassList.prototype.add = function (c) {
    if (this.contains(c)) return; //如果存在，什么都不做
    var classes = this.e.className;
    if (classes &amp;&amp; classes[classes.length - 1] != &quot;&quot;)
        c = &quot;&quot; + c; //如果需要加一个空格
    this.e.className += c; //将c添加到className中
}; //将在e.className中出现的所有c都删除
CSSClassList.prototype.remove = function (c) { //检查c是否是合法的类名
    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)
        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //将所有作为单词的c和多余的尾随空格全部删除
    var pattern = new RegExp(&quot;\\b&quot; + c + &quot;\\b\\s*&quot;, &quot;g&quot;);
    this.e.className = this.e.className.replace(pattern, &quot;&quot;);
}; //如果c不存在，将c添加到e.className中，并返回true
//否则，将在e.className中出现的所有c都删除，并返回false
CSSClassList.prototype.toggle = function (c) {
    if (this.contains(c)) { //如果e.className包含c
        this.remove(c); //删除它
        return false;
    } else { //否则
        this.add(c); //添加它
        return true;
    }
}; //返回e.className本身
CSSClassList.prototype.toString = function () {
    return this.e.className;
}; //返回在e.className中的类名
CSSClassList.prototype.toArray = function () {
    return this.e.className.match(/\b\w+\b/g) || [];
};
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询纯文本形式的内容"><a href="#查询纯文本形式的内容" class="headerlink" title="查询纯文本形式的内容"></a>查询纯文本形式的内容</h2><pre><code>/**
 *一个参数，返回元素的textContent或innerText
 *两个参数，用value参数的值设置元素的textContent或innerText
 */
function textContent(element, value) {
    var content = element.textContent; //检测textContent是否有定义
    if (value === undefined) { //没传递value，因此返回当前文本
        if (content !== undefined) return content;
        else return element.innerText;
    } else { //传递了value，因此设置文本
        if (content !== undefined) element.textContent = value;
        else element.innerText = value;
    }
}
</code></pre><p>textContent属性在除了IE的所有当前的浏览器中都支持。在IE中，可以用Element的innerText属性来代替。 <a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查找元素的后代中节点中的所有Text节点"><a href="#查找元素的后代中节点中的所有Text节点" class="headerlink" title="查找元素的后代中节点中的所有Text节点"></a>查找元素的后代中节点中的所有Text节点</h2><pre><code>//返回元素e的纯文本内容，递归进入其子元素
//该方法的效果类似于textContent属性
function textContent(e) {
    var child, type, s = &quot;&quot;; //s保存所有子节点的文本
    for (child = e.firstChild; child != null; child = child.nextSibling) {
        type = child.nodeType;
        if (type === 3 || type === 4) //Text和CDATASection节点
            s += child.nodeValue;
        else if (type === 1) //递归Element节点
            s += textContent(child);
    }
    return s;
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用innerHTML实现insertAdjacentHTML"><a href="#使用innerHTML实现insertAdjacentHTML" class="headerlink" title="使用innerHTML实现insertAdjacentHTML()"></a>使用innerHTML实现insertAdjacentHTML()</h2><pre><code>//本模块为不支持它的浏览器定义了Element.insertAdjacentHTML
//还定义了一些可移植的HTML插入函数，它们的名字比insertAdjacentHTML更符合逻辑：
//Insert.before()、Insert.after()、Insert.atStart()和Insert.atEnd()
var Insert = (function () { //如果元素有原生的insertAdjacentHTML，
    //在4个函数名更明了的HTML插入函数中使用它
    if (document.createElement(&quot;div&quot;).insertAdjacentHTML) {
        return {
            before: function (e, h) {
                e.insertAdjacentHTML(&quot;beforebegin&quot;, h);
            },
            after: function (e, h) {
                e.insertAdjacentHTML(&quot;afterend&quot;, h);
            },
            atStart: function (e, h) {
                e.insertAdjacentHTML(&quot;afterbegin&quot;, h);
            },
            atEnd: function (e, h) {
                e.insertAdjacentHTML(&quot;beforeend&quot;, h);
            }
        };
    }
    //否则，无原生的insertAdjacentHTML
    //实现同样的4个插入函数，并使用它们来定义insertAdjacentHTML
    //首先，定义一个工具函数，传入HTML字符串，返回一个DocumentFragment，
    //它包含了解析后的HTML的表示
    function fragment(html) {
        var elt = document.createElement(&quot;div&quot;); //创建空元素
        var frag = document.createDocumentFragment(); //创建空文档片段
        elt.innerHTML = html; //设置元素内容
        while (elt.firstChild) //移动所有的节点
            frag.appendChild(elt.firstChild); //从elt到frag
        return frag; //然后返回frag
    }
    var Insert = {
        before: function (elt, html) {
            elt.parentNode.insertBefore(fragment(html), elt);
        },
        after: function (elt, html) {
            elt.parentNode.insertBefore(fragment(html), elt.nextSibling);
        },
        atStart: function (elt, html) {
            elt.insertBefore(fragment(html), elt.firstChild);
        },
        atEnd: function (elt, html) {
            elt.appendChild(fragment(html));
        }
    }; //基于以上函数实现insertAdjacentHTML
    Element.prototype.insertAdjacentHTML = function (pos, html) {
        switch (pos.toLowerCase()) {
            case &quot;beforebegin&quot;:
                return Insert.before(this, html);
            case &quot;afterend&quot;:
                return Insert.after(this, html);
            case &quot;afterbegin&quot;:
                return Insert.atStart(this, html);
            case &quot;beforeend&quot;:
                return Insert.atEnd(this, html);
        }
    };
    return Insert; //最后返回4个插入函数
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><pre><code>/**
 *Drag.js：拖动绝对定位的HTML元素
 *
 *这个模块定义了一个drag()函数，它用于mousedown事件处理程序的调用
 *随后的mousemove事件将移动指定元素，mouseup事件将终止拖动
 *这些实现能同标准和IE两种事件模型一起工作
 *
 *参数：
 *
 *elementToDrag：接收mousedown事件的元素或某些包含元素
 *它必须是定位的元素,元素的样式必须是行内样式
 *它的style.left和style.top值将随着用户的拖动而改变
 *
 *event：mousedown事件对象
 **/
function drag(elementToDrag, event) { //初始鼠标位置，转换为文档坐标
    var startX = event.clientX;
    var startY = event.clientY; //在文档坐标下，待拖动元素的初始位置
    //因为elementToDrag是绝对定位的，
    //所以我们可以假设它的offsetParent就是文档的body元素
    var origX = parseFloat(elementToDrag.style.left);
    var origY = parseFloat(elementToDrag.style.top); //计算mousedown事件和元素左上角之间的距离
    //我们将它另存为鼠标移动的距离
    if (document.addEventListener) { //标准事件模型
        //在document对象上注册捕获事件处理程序
        document.addEventListener(&quot;mousemove&quot;, moveHandler, true);
        document.addEventListener(&quot;mouseup&quot;, upHandler, true);
    } else if (document.attachEvent) { //用于IE5～8的IE事件模型
        //在IE事件模型中，
        //捕获事件是通过调用元素上的setCapture()捕获它们
        elementToDrag.setCapture();
        elementToDrag.attachEvent(&quot;onmousemove&quot;, moveHandler);
        elementToDrag.attachEvent(&quot;onmouseup&quot;, upHandler); //作为mouseup事件看待鼠标捕获的丢失
        elementToDrag.attachEvent(&quot;onlosecapture&quot;, upHandler);
    }
    //我们处理了这个事件，不让任何其他元素看到它
    if (event.stopPropagation) event.stopPropagation(); //标准模型
    else event.cancelBubble = true; //IE
    //现在阻止任何默认操作
    if (event.preventDefault) event.preventDefault(); //标准模型
    else event.returnValue = false; //IE
    /**
     * 当元素正在被拖动时， 这就是捕获mousemove事件的处理程序
     *它用于移动这个元素 
     **/
    function moveHandler(e) {
        if (!e) e = window.event; //IE事件模型
        //移动这个元素到当前鼠标位置，
        //通过滚动条的位置和初始单击的偏移量来调整
        var targetLeft = e.clientX - startX + origX;
        var targetTop = e.clientY - startY + origY;
        var minLeft = 0;
        var minTop = 0;
        var maxLeft = (document.documentElement.clientWidth || document.body.clientWidth) - elementToDrag.offsetWidth;
        var maxTop = (document.documentElement.clientHeight || document.body.clientHeight) - elementToDrag.offsetHeight;
        targetLeft = targetLeft &gt; maxLeft ? maxLeft : (targetLeft &lt; minLeft ? minLeft : targetLeft);
        targetTop = targetTop &gt; maxTop ? maxTop : (targetTop &lt; minTop ? minTop : targetTop);
        elementToDrag.style.left = targetLeft + &quot;px&quot;;
        elementToDrag.style.top = targetTop + &quot;px&quot;;
        if (e.stopPropagation) e.stopPropagation(); //标准
        else e.cancelBubble = true; //IE
    }
    /**
     *这是捕获在拖动结束时发生的最终mouseup事件的处理程序
     **/
    function upHandler(e) {
        if (!e) e = window.event; //IE事件模型
        //注销捕获事件处理程序
        if (document.removeEventListener) { //DOM事件模型
            document.removeEventListener(&quot;mouseup&quot;, upHandler, true);
            document.removeEventListener(&quot;mousemove&quot;, moveHandler, true);
        } else if (document.detachEvent) { //IE 5+事件模型
            elementToDrag.detachEvent(&quot;onlosecapture&quot;, upHandler);
            elementToDrag.detachEvent(&quot;onmouseup&quot;, upHandler);
            elementToDrag.detachEvent(&quot;onmousemove&quot;, moveHandler);
            elementToDrag.releaseCapture();
        }
        //并且不让事件进一步传播
        if (e.stopPropagation) e.stopPropagation(); //标准模型
        else e.cancelBubble = true; //IE
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在谷歌地图上显示地理位置信息"><a href="#在谷歌地图上显示地理位置信息" class="headerlink" title="在谷歌地图上显示地理位置信息"></a>在谷歌地图上显示地理位置信息</h2><pre><code>//获取当前位置然后通过Google地图显示
//如果当前浏览器不支持地理位置API，则抛出一个错误
function getmap() { //检查是否支持地理位置API
    if (!navigator.geolocation) throw &quot;Geolocation not supported&quot;; //开始请求地理位置信息，
    navigator.geolocation.getCurrentPosition(setMapURL);
    function setMapURL(pos) { //从参数对象（pos）中获取位置信息
        var latitude = pos.coords.latitude; //经度
        var longitude = pos.coords.longitude; //纬度
        var accuracy = pos.coords.accuracy; //米
        var scale = 10; //比例
        //构造一个URL，用于跳转到Google地图
        var url = &quot;https://www.google.com/maps/@&quot; + latitude + &quot;,&quot; + longitude + &quot;,&quot; + scale + &quot;z&quot;; //设置一个大致的缩放级别
        location = url;
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用所有地理位置特性"><a href="#使用所有地理位置特性" class="headerlink" title="使用所有地理位置特性"></a>使用所有地理位置特性</h2><pre><code>//异步的获取我的位置，并在指定的元素中展示出来
function whereami(elt) { //将此对象作为第三个参数传递给getCurrentPosition()方法
    var options = { //设置为true，表示如果可以的话
        //获取高精度的位置信息（例如，通过GPS获取）
        //但是，要注意的是，这会影响电池寿命
        enableHighAccuracy: false, //可以近似：这是默认值
        //如果获取缓存过的位置信息就足够的话，可以设置此属性
        //默认值为0,表示强制检查新的位置信息
        maximumAge: 300000, //5分钟左后
        //愿意等待多长时间来获取位置信息？
        //默认值为无限长 [2] ，getCurrentPosition()方法永不超时
        timeout: 15000 //不要超过15秒
    };
    if (navigator.geolocation) //如果支持的话，就获取位置信息
        navigator.geolocation.getCurrentPosition(success, error, options);
    else
        elt.innerHTMl = &quot;Geolocation not supported in this browser&quot;; //当获取位置信息失败的时候，会调用此函数

    function error(e) { //error对象包含一些数字编码和文本消息，如下所示：
        //1:用户不允许分享他/她的位置信息
        //2:浏览器无法确定位置
        //3:发生超时
        elt.innerHTML = &quot;Geolocation error&quot; + e.code + &quot;:&quot; + e.message;
    }
    //当获取位置信息成功的时候，会调用此函数
    function success(pos) { //总是可以获取如下这些字段
        //但是要注意的是时间戳信息在outer对象中，而不在inner、coords对象中
        var msg = &quot;时间是&quot; +
            new Date(pos.timestamp).toLocaleString() + &quot;地理位置是&quot; +
            pos.coords.accuracy + &quot;米范围内经度是&quot; +
            pos.coords.latitude + &quot;纬度是&quot; +
            pos.coords.longitude + &quot;.&quot;; //如果设备还返回了海拔信息，则将其添加进去
        if (pos.coords.altitude) {
            msg += &quot;海拔是&quot; + pos.coords.altitude + &quot;±&quot; +
                pos.coords.altitudeAccuracy + &quot;千米.&quot;;
        }
        //如果设备还返回了速度和航向信息，也将它们添加进去
        if (pos.coords.speed) {
            msg += &quot;速度是&quot; +
                pos.coords.speed + &quot;m/s方向是&quot; +
                pos.coords.heading + &quot;.&quot;;
        }
        elt.innerHTML = msg; //显示所有的位置信息
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="优雅的图片翻转实现"><a href="#优雅的图片翻转实现" class="headerlink" title="优雅的图片翻转实现"></a>优雅的图片翻转实现</h2><pre><code>/**
 *优雅的图片翻转实现方式
 *
 *要创建图片翻转效果，将此模块引入到HTML文件中
 *然后在任意＜img＞元素上使用data-rollover属性来指定翻转图片的URL即可
 *如下所示:
 *
 *&lt;img src=&quot;normal_image.png &quot;data-rollover=&quot;rollover_image.png&quot;&gt;
 *
 */
function changeImage() { //所有处理逻辑都在一个匿名函数中:不定义任何符号
    //遍历所有的图片，查找data-rollover属性
    for (var i = 0; i &lt; document.images.length; i++) {
        var img = document.images[i];
        var rollover = img.getAttribute(&quot;data-rollover&quot;);
        if (!rollover) continue; //跳过没有data-rollover属性的图片
        //确保将翻转的图片缓存起来
        (new Image()).src = rollover; //定义一个属性来标识默认的图片URL
        img.setAttribute(&quot;data-rollout&quot;, img.src); //注册事件处理函数来创建翻转效果
        img.onmouseover = function () {
            this.src = this.getAttribute(&quot;data-rollover&quot;);
        };
        img.onmouseout = function () {
            this.src = this.getAttribute(&quot;data-rollout&quot;);
        };
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用canvas绘制多边形"><a href="#使用canvas绘制多边形" class="headerlink" title="使用canvas绘制多边形"></a>使用canvas绘制多边形</h2><pre><code>//定义一个以(x,y)为中心，半径为r的规则n边形,c可以通过调用画布getContext()方法得到
//每个顶点都是均匀分布在圆周上
//将第一个顶点放置在最上面，或者指定一定角度
//除非最后一个参数是true，否则顺时针旋转
function polygon(c, n, x, y, r, angle, counterclockwise) {
    angle = angle || 0;
    counterclockwise = counterclockwise || false;
    c.moveTo(x + r * Math.sin(angle), //从第一个顶点开始一条新的子路径
        y - r * Math.cos(angle)); //使用三角法计算位置
    var delta = 2 * Math.PI / n; //两个顶点之间的夹角
    for (var i = 1; i &lt; n; i++) { //循环剩余的每个顶点
        angle += counterclockwise ? -delta : delta; //调整角度
        c.lineTo(x + r * Math.sin(angle), //以下个顶点为端点添加线段
            y - r * Math.cos(angle));
    }
    c.closePath(); //将最后一个顶点和起点连接起来
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用canvas绘制雪花"><a href="#使用canvas绘制雪花" class="headerlink" title="使用canvas绘制雪花"></a>使用canvas绘制雪花</h2><pre><code>var deg = Math.PI / 180; //用于角度制到弧度制的转换
//在画布的上下文c中，以左下角的点(x,y)和边长len，绘制一个n级别的科赫雪花分形
function snowflake(c, n, x, y, len) {
    c.save(); //保存当前变换
    c.translate(x, y); //变换原点为起始点
    c.moveTo(0, 0); //从新的原点开始一条新的子路径
    leg(n); //绘制雪花的第一条边
    c.rotate(-120 * deg); //现在沿着逆时针方向旋转120 o
    leg(n); //绘制第二条边
    c.rotate(-120 * deg); //再次旋转
    leg(n); //画最后一条边
    c.closePath(); //闭合子路径
    c.restore(); //恢复初始的变换
    //绘制n级别的科赫雪花的一条边
    //此函数在画完一条边的时候就离开当前点，
    //然后通过坐标系变换将当前点又转换成(0,0,)
    //这意味着画完一条边之后可以很简单地调用rotate()进行旋转
    function leg(n) {
        c.save(); //保存当前坐标系变换
        if (n == 0) { //不需要递归的情况下:
            c.lineTo(len, 0); //就绘制一条水平线段
        } else { //递归情况下：绘制4条子边，类似这个样子： - \/ -
            c.scale(1 / 3, 1 / 3); //子边长度为原边长的1/3
            leg(n - 1); //递归第一条子边
            c.rotate(60 * deg); //顺时针旋转60 o
            leg(n - 1); //第二条子边
            c.rotate(-120 * deg); //逆时针旋转120 o
            leg(n - 1); //第三条子边
            c.rotate(60 * deg); //通过旋转回到初始状态
            leg(n - 1); //最后一条边
        }
        c.restore(); //恢复坐标系变换
        c.translate(len, 0); //但是通过转换使得边的结束点为(0,0)
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在Web-Worker中发起同步XMLHtttpRequest"><a href="#在Web-Worker中发起同步XMLHtttpRequest" class="headerlink" title="在Web Worker中发起同步XMLHtttpRequest"></a>在Web Worker中发起同步XMLHtttpRequest</h2><pre><code>//此文件会通过一个新的Worker()来载入，因此，它是运行在独立的线程中的，
//可以放心地使用同步XMLHttpRequest API
//消息是URL数组的形式。以字符串形式同步获取每个URL指定的内容，
//并将这些字符串数组传递回去。
onmessage = function (e) {
    var urls = e.data; //输入：要获取的URL
    var contents = []; //输出：URL指定的内容
    for (var i = 0; i &lt; urls.length; i++) {
        var url = urls[i]; //每个URL
        var xhr = new XMLHttpRequest(); //开始一个HTTP请求
        xhr.open(&quot;GET&quot;, url, false); //false则表示进行同步请求
        xhr.send(); //阻塞住，一直到响应完成
        if (xhr.status !== 200) //如果请求失败则抛出错误
            throw Error(xhr.status + &quot; &quot; + xhr.statusText + &quot;: &quot; + url);
        contents.push(xhr.responseText); //否则，存储通过URL获取得到的内容
    }
    //最后，将这些URL内容以数组的形式传递回主线程
    postMessage(contents);
}
</code></pre><p>善于利用JS中的小技巧，不仅可以使代码更加简洁，而且逼格更高。</p>
<h2 id="使用-模拟Boolean-函数"><a href="#使用-模拟Boolean-函数" class="headerlink" title="使用!!模拟Boolean()函数"></a>使用!!模拟Boolean()函数</h2><p>原理：逻辑非操作一个数据对象时，会先将数据对象转换为布尔值，然后取反，两个!!重复取反，就实现了转换为布尔值的效果。</p>
<h2 id="使用一元加-模拟Number-函数"><a href="#使用一元加-模拟Number-函数" class="headerlink" title="使用一元加(+)模拟Number()函数"></a>使用一元加(+)模拟Number()函数</h2><p>原理：对非数值类型的数据使用一元加(+)，会起到与Number()函数相同的效果。</p>
<p>null转换为0</p>
<p>undefined转换为NaN</p>
<p>false转换为0，true转换为1</p>
<p>对于字符串： </p>
<p>空字串转换为0</p>
<p>含有数字或者浮点数或者十六进制格式的数据(11, 0.3, 0xfe等)，转换为相应的数值</p>
<p>含有其他格式字符，无法转换为数值的字符串，转换为NaN</p>
<p>对于对象，先调用valueOf()方法，在转换，若结果为NaN，那么再调用toString()方法，之后再转换</p>
<h2 id="使用逻辑与-amp-amp-进行短路操作"><a href="#使用逻辑与-amp-amp-进行短路操作" class="headerlink" title="使用逻辑与(&amp;&amp;)进行短路操作"></a>使用逻辑与(&amp;&amp;)进行短路操作</h2><pre><code>if(connected){
    login();
}
</code></pre><p>以上代码可以简写为:</p>
<p><code>connected &amp;&amp; login();</code></p>
<p>也可用这种方法来检查对象中是否拥有某个属性</p>
<pre><code>user &amp;&amp; user.name
</code></pre><p>原理：逻辑与(&amp;&amp;)会首先对第一个操作数进行求值，只有求值结果为true时才会对第二个操作数求值。connected &amp;&amp; login()中，若判断connected不为true,则不再进行下一步操作。<br>所谓的短路操作即第一个操作数可以决定结果，则不再对第二个操作数进行求值。</p>
<h2 id="使用逻辑或-设置默认值"><a href="#使用逻辑或-设置默认值" class="headerlink" title="使用逻辑或(||)设置默认值"></a>使用逻辑或(||)设置默认值</h2><p>逻辑或(||)也属于短路操作，即当第一个操作数可以决定结果时，不再对第二个操作数进行求值。利用这个特点，我们可以给赋值语句设置默认值。只有当第一个操作数为null或者undefined时，才会把第二个操作数赋值给目标。</p>
<pre><code>function User(name, age){
    this.name = name || &quot;Liming&quot;;
}
</code></pre><p>上述代码中，如果函数中没有传入name参数，name的值为undefined，那么就会给this.name赋值为”Liming”。<br>ES6中可以为函数设置默认值，所以这种方法可能要成为过去式，但是其他地方还是很有用的。<br>ES6 写法 简洁了许多</p>
<pre><code>let User = (name=&quot;Liming&quot;, age) =&gt; { }
</code></pre><h2 id="获取数组最后n个元素"><a href="#获取数组最后n个元素" class="headerlink" title="获取数组最后n个元素"></a>获取数组最后n个元素</h2><p>可以使用以下代码获取数组中最后n个元素</p>
<pre><code>var array = [1, 2, 3, 4, 5, 6];
console.log(array.slice(-1));  //[6]
console.log(array.slice(-2));  //[5, 6]
</code></pre><p>原理:Array.prototype.slice(begin,end)可以用来裁剪数组，第二个参数的默认值是数组的长度值。若值传入一个参数，则会返回从指定索引开始到数组结尾的所有值。<br>而slice()方法还可以接收负值，当传入负值时，会自动加上数组的长度值使其转换为正值，于是便得到了最后的n个值。</p>
<h2 id="合并大数组"><a href="#合并大数组" class="headerlink" title="合并大数组"></a>合并大数组</h2><p>常用的合并数组的方式是使用Array.concat()函数。该函数会创建一个新数组，将两个数组连接起来存储到新数组中，这会大量消耗内存。可以使用Array.push.apply(arr1, arr2)，它不会创建新数组，而是将第二个数组合并到第一个数组中，以减少内存的消耗。</p>
<pre><code>var a = [1,2];
var b = [3,4];
console.log(a.push.apply(a, b));      // [1,2,3,4]
//或者
Array.prototype.push.apply(a, b);      // a变成了[1,2,3,4]
console.log(a); //[1,2,3,4]
</code></pre><p>原理: Array.push()是在数组的末尾增加元素，但是如果使用a.push(b)会把整个数组b当作一个元素添加到数组a中。<br>而apply()方法，则允许将某个方法的参数以数组的形式传入，所以起到了将数组b中的元素追加到数组a中的效果。</p>
<h2 id="NodeList转换为数组"><a href="#NodeList转换为数组" class="headerlink" title="NodeList转换为数组"></a>NodeList转换为数组</h2><p>使用document.querySelectorAll(‘div’)返回的是NodeList对象，虽然它很像数组，但是并不能使用诸如sort()，filter()等方法。你可以将其转换为真正的数组。</p>
<pre><code>var eles = document.querySelectorAll(&apos;p&apos;);  //NodeList
var arrayElements = [].slice.call(eles);       //转化为数组
// 或者
var arrayElements = Array.prototype.slice.call(eles);
// 或者
var arrayElements = Array.from(eles); 
</code></pre><p>原理:</p>
<p>[].slice.call(eles):<br>首先创建了一个空数组[]，然后调用他的slice()方法，但是在slice()方法的执行中，把this对象指向了eles,所以会对eles进行裁减，由于对slice()方法没有传入参数，所以相当于slice(0,eles.length),会按照元长度返回一个数组。</p>
<p>Array.prototype.slice.call(eles): 原理与上面相似，只不过这次没有创建空数组，而是直接使用了原型中的方法 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


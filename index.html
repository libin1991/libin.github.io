<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/React-Hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/06/React-Hooks/" itemprop="url">React Hooks</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-06T10:01:03+08:00">
                2018-11-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一个最简单的Hooks"><a href="#一个最简单的Hooks" class="headerlink" title="一个最简单的Hooks"></a>一个最简单的Hooks</h2><p>首先让我们看一下一个简单的有状态组件：</p>
<pre><code>class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>我们再来看一下使用hooks后的版本：</p>
<pre><code>import { useState } from &apos;react&apos;;

function Example() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>是不是简单多了！可以看到，<code>Example</code>变成了一个函数，但这个函数却有自己的状态（count），同时它还可以更新自己的状态（setCount）。这个函数之所以这么了不得，就是因为它注入了一个hook–<code>useState</code>，就是这个hook让我们的函数变成了一个有状态的函数。</p>
<p>除了<code>useState</code>这个hook外，还有很多别的hook，比如<code>useEffect</code>提供了类似于<code>componentDidMount</code>等生命周期钩子的功能，<code>useContext</code>提供了上下文（context）的功能等等。</p>
<p>Hooks本质上就是一类特殊的函数，它们可以为你的函数型组件（function component）注入一些特殊的功能。咦？这听起来有点像被诟病的Mixins啊？难道是Mixins要在react中死灰复燃了吗？当然不会了，等会我们再来谈两者的区别。总而言之，这些hooks的目标就是让你不再写class，让function一统江湖。</p>
<h2 id="React为什么要搞一个Hooks？"><a href="#React为什么要搞一个Hooks？" class="headerlink" title="React为什么要搞一个Hooks？"></a>React为什么要搞一个Hooks？</h2><h3 id="想要复用一个有状态的组件太麻烦了！"><a href="#想要复用一个有状态的组件太麻烦了！" class="headerlink" title="想要复用一个有状态的组件太麻烦了！"></a>想要复用一个有状态的组件太麻烦了！</h3><p>我们都知道react都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用react，你会发现你的项目中实际上很多react组件冗长且难以复用。尤其是那些写成class的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。</p>
<p>那之前，官方推荐怎么解决这个问题呢？答案是：<font color="#ff0000">渲染属性（Render Props）</font>和 <font color="#ff0000">高阶组件（Higher-Order Components）</font> 。我们可以稍微跑下题简单看一下这两种模式。</p>
<p>渲染属性指的是使用一个值为函数的prop来传递需要动态渲染的nodes或组件。如下面的代码可以看到我们的<code>DataProvider</code>组件包含了所有跟状态相关的代码，而<code>Cat</code>组件则可以是一个单纯的展示型组件，这样一来<code>DataProvider</code>就可以单独复用了。</p>
<pre><code>import Cat from &apos;components/cat&apos;
class DataProvider extends React.Component {
  constructor(props) {
    super(props);
    this.state = { target: &apos;Zac&apos; };
  }

  render() {
    return (
      &lt;div&gt;
        {this.props.render(this.state)}
      &lt;/div&gt;
    )
  }
}

&lt;DataProvider render={data =&gt; (
  &lt;Cat target={data.target} /&gt;
)}/&gt;
</code></pre><p>虽然这个模式叫Render Props，但不是说非用一个叫render的props不可，习惯上大家更常写成下面这种：</p>
<pre><code>...
&lt;DataProvider&gt;
  {data =&gt; (
    &lt;Cat target={data.target} /&gt;
  )}
&lt;/DataProvider&gt;
</code></pre><p>高阶组件这个概念就更好理解了，说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，<code>withUser</code>函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。</p>
<pre><code>const withUser = WrappedComponent =&gt; {
  const user = sessionStorage.getItem(&quot;user&quot;);
  return props =&gt; &lt;WrappedComponent user={user} {...props} /&gt;;
};

const UserPage = props =&gt; (
  &lt;div class=&quot;user-container&quot;&gt;
    &lt;p&gt;My name is {props.user}!&lt;/p&gt;
  &lt;/div&gt;
);

export default withUser(UserPage);
</code></pre><p>以上这两种模式看上去都挺不错的，很多库也运用了这种模式，比如我们常用的React Router。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开devtool看看你的组件层级嵌套是不是很夸张吧。这时候再回过头看我们上一节给出的hooks例子，是不是简洁多了，没有多余的层级嵌套。把各种想要的功能写成一个一个可复用的自定义hook，当你的组件想用什么功能时，直接在组件里调用这个hook即可。</p>
<h3 id="生命周期钩子函数里的逻辑太乱了吧！"><a href="#生命周期钩子函数里的逻辑太乱了吧！" class="headerlink" title="生命周期钩子函数里的逻辑太乱了吧！"></a>生命周期钩子函数里的逻辑太乱了吧！</h3><p>我们通常希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情。比如我们需要在<code>componentDidMount</code>中发起ajax请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在<code>componentDidUpdate</code>做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。</p>
<h3 id="classes真的太让人困惑了！"><a href="#classes真的太让人困惑了！" class="headerlink" title="classes真的太让人困惑了！"></a>classes真的太让人困惑了！</h3><p>我们用class来创建react组件时，还有一件很麻烦的事情，就是this的指向问题。为了保证this的指向正确，我们要经常写这样的代码：<code>this.handleClick = this.handleClick.bind(this)</code>，或者是这样的代码：<code>&lt;button onClick={() =&gt; this.handleClick(e)}&gt;</code>。一旦我们不小心忘了绑定this，各种bug就随之而来，很麻烦。</p>
<p>还有一件让我很苦恼的事情。我在之前的react系列文章当中曾经说过，尽可能把你的组件写成无状态组件的形式，因为它们更方便复用，可独立测试。然而很多时候，我们用function写了一个简洁完美的无状态组件，后来因为需求变动这个组件必须得有自己的state，我们又得很麻烦的把function改成class。</p>
<p>在这样的背景下，Hooks便横空出世了！</p>
<h2 id="什么是State-Hooks？"><a href="#什么是State-Hooks？" class="headerlink" title="什么是State Hooks？"></a>什么是State Hooks？</h2><p>回到一开始我们用的例子，我们分解来看到底state hooks做了什么：</p>
<pre><code>import { useState } from &apos;react&apos;;

function Example() {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><h3 id="声明一个状态变量"><a href="#声明一个状态变量" class="headerlink" title="声明一个状态变量"></a>声明一个状态变量</h3><pre><code>import { useState } from &apos;react&apos;;

function Example() {
  const [count, setCount] = useState(0);
</code></pre><p><code>useState</code>是react自带的一个hook函数，它的作用就是用来声明状态变量。<code>useState</code>这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第<code>[0]</code>项是当前当前的状态值，第<code>[1]</code>项是可以改变状态值的方法函数。</p>
<p>所以我们做的事情其实就是，声明了一个状态变量count，把它的初始值设为0，同时提供了一个可以更改count的函数setCount。</p>
<p>上面这种表达形式，是借用了<code>es6的数组解构</code> ，它可以让我们的代码看起来更简洁。</p>
<p>如果不用数组解构的话，可以写成下面这样。实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。具体可以去这篇文章的分析<a href="https://link.juejin.im?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1hWb-lQW4NSG9yRpyyiAA_9Ktytd5lypLnVLhPX9vamE%2Fedit%23" target="_blank" rel="noopener">Array destructuring for multi-value returns (in light of React hooks)</a>，这里不详细展开，我们就按照官方推荐使用数组解构就好。</p>
<pre><code>let _useState = useState(0);
let count = _useState[0];
let setCount = _useState[1];
</code></pre><h3 id="读取状态值"><a href="#读取状态值" class="headerlink" title="读取状态值"></a>读取状态值</h3><pre><code>&lt;p&gt;You clicked {count} times&lt;/p&gt;
</code></pre><p>是不是超简单？因为我们的状态count就是一个单纯的变量而已，我们再也不需要写成<code>{this.state.count}</code>这样了。</p>
<h3 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h3><pre><code>&lt;button onClick={() =&gt; setCount(count + 1)}&gt;
  Click me
&lt;/button&gt;
</code></pre><p>当用户点击按钮时，我们调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给react了，react将会重新渲染我们的Example组件，并且使用的是更新后的新的状态，即count=1。这里我们要停下来思考一下，Example本质上也是一个普通的函数，为什么它可以记住之前的状态？</p>
<h3 id="一个至关重要的问题"><a href="#一个至关重要的问题" class="headerlink" title="一个至关重要的问题"></a>一个至关重要的问题</h3><p>这里我们就发现了问题，通常来说我们在一个函数中声明的变量，当函数运行完成后，这个变量也就销毁了（这里我们先不考虑闭包等情况），比如考虑下面的例子：</p>
<pre><code>function add(n) {
    const result = 0;
    return result + 1;
}

add(1); //1
add(1); //1
</code></pre><p>不管我们反复调用add函数多少次，结果都是1。因为每一次我们调用add时，result变量都是从初始值0开始的。那为什么上面的Example函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？答案是：是react帮我们记住的。至于react是用什么机制记住的，我们可以再思考一下。</p>
<h3 id="假如一个组件有多个状态值怎么办？"><a href="#假如一个组件有多个状态值怎么办？" class="headerlink" title="假如一个组件有多个状态值怎么办？"></a>假如一个组件有多个状态值怎么办？</h3><p>首先，useState是可以多次调用的，所以我们完全可以这样写：</p>
<pre><code>function ExampleWithManyStates() {
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState(&apos;banana&apos;);
  const [todos, setTodos] = useState([{ text: &apos;Learn Hooks&apos; }]);
</code></pre><p>其次，useState接收的初始值没有规定一定要是string/number/boolean这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的<code>this.setState</code>做的是合并状态后返回一个新状态，而<code>useState</code>是直接替换老状态后返回新状态。最后，react也给我们提供了一个useReducer的hook，如果你更喜欢redux式的状态管理方案的话。</p>
<p>从ExampleWithManyStates函数我们可以看到，useState无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？</p>
<p>其实我们看hook的“形态”，有点类似之前被官方否定掉的Mixins这种方案，都是提供一种“插拔式的功能注入”的能力。而mixins之所以被否定，是因为Mixins机制是让多个Mixins共享一个对象的数据空间，这样就很难确保不同Mixins依赖的状态不发生冲突。</p>
<p>而现在我们的hook，一方面它是直接用在function当中，而不是class；另一方面每一个hook都是相互独立的，不同组件调用同一个hook也能保证各自状态的独立性。这就是两者的本质区别了。</p>
<h3 id="react是怎么保证多个useState的相互独立的？"><a href="#react是怎么保证多个useState的相互独立的？" class="headerlink" title="react是怎么保证多个useState的相互独立的？"></a>react是怎么保证多个useState的相互独立的？</h3><p>还是看上面给出的ExampleWithManyStates例子，我们调用了三次useState，每次我们传的参数只是一个值（如42，‘banana’），我们根本没有告诉react这些值对应的key是哪个，那react是怎么保证这三个useState找到它对应的state呢？</p>
<p>答案是，react是根据useState出现的顺序来定的。我们具体来看一下：</p>
<pre><code>//第一次渲染
useState(42);  //将age初始化为42
useState(&apos;banana&apos;);  //将fruit初始化为banana
useState([{ text: &apos;Learn Hooks&apos; }]); //...

//第二次渲染
useState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）
useState(&apos;banana&apos;);  //读取状态变量fruit的值（这时候传的参数banana直接被忽略）
useState([{ text: &apos;Learn Hooks&apos; }]); //...
</code></pre><p>假如我们改一下代码：</p>
<pre><code>let showFruit = true;
function ExampleWithManyStates() {
  const [age, setAge] = useState(42);

  if(showFruit) {
    const [fruit, setFruit] = useState(&apos;banana&apos;);
    showFruit = false;
  }

  const [todos, setTodos] = useState([{ text: &apos;Learn Hooks&apos; }]);
</code></pre><p>这样一来，</p>
<pre><code>//第一次渲染
useState(42);  //将age初始化为42
useState(&apos;banana&apos;);  //将fruit初始化为banana
useState([{ text: &apos;Learn Hooks&apos; }]); //...

//第二次渲染
useState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）
// useState(&apos;banana&apos;);  
useState([{ text: &apos;Learn Hooks&apos; }]); //读取到的却是状态变量fruit的值，导致报错
</code></pre><p>鉴于此，react规定我们必须把hooks写在函数的最外层，不能写在ifelse等条件语句当中，来确保hooks的执行顺序一致。</p>
<h2 id="什么是Effect-Hooks"><a href="#什么是Effect-Hooks" class="headerlink" title="什么是Effect Hooks?"></a>什么是Effect Hooks?</h2><p>我们在上一节的例子中增加一个新功能：</p>
<pre><code>import { useState, useEffect } from &apos;react&apos;;

function Example() {
  const [count, setCount] = useState(0);

  // 类似于componentDidMount 和 componentDidUpdate:
  useEffect(() =&gt; {
    // 更新文档的标题
    document.title = `You clicked ${count}times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>我们对比着看一下，如果没有hooks，我们会怎么写？</p>
<pre><code>class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count}times`;
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count}times`;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起ajax请求获取数据，添加一些监听的注册和取消注册，手动修改dom等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如componentDidMount，componentDidUpdate和componentWillUnmount。而现在的useEffect就相当与这些声明周期函数钩子的集合体。它以一抵三。</p>
<p>同时，由于前文所说hooks可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的useEffect钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。</p>
<h3 id="useEffect做了什么？"><a href="#useEffect做了什么？" class="headerlink" title="useEffect做了什么？"></a>useEffect做了什么？</h3><p>我们再梳理一遍下面代码的逻辑：</p>
<pre><code>function Example() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    document.title = `You clicked ${count}times`;
  });
</code></pre><p>首先，我们声明了一个状态变量<code>count</code>，将它的初始值设为0。然后我们告诉react，我们的这个组件有一个副作用。我们给<code>useEffect</code>hook传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我们的副作用是调用browser API来修改文档标题。当react要渲染我们的组件时，它会先记住我们用到的副作用。等react更新了DOM之后，它再依次执行我们定义的副作用函数。</p>
<p>这里要注意几点：<br>第一，react首次渲染和之后的每次渲染都会调用一遍传给useEffect的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount），和之后的更新导致的重新渲染（componentDidUpdate）。</p>
<p>第二，useEffect中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的componentDidMount或componentDidUpdate中的代码则是同步执行的。这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据DOM计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。</p>
<h3 id="useEffect怎么解绑一些副作用"><a href="#useEffect怎么解绑一些副作用" class="headerlink" title="useEffect怎么解绑一些副作用"></a>useEffect怎么解绑一些副作用</h3><p>这种场景很常见，当我们在componentDidMount里添加了一个注册，我们得马上在componentWillUnmount中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。</p>
<p>怎么清除呢？让我们传给useEffect的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些pubsub模式的实现中很常见。看下面的例子：</p>
<pre><code>import { useState, useEffect } from &apos;react&apos;;

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() =&gt; {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    // 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup
    returnfunctioncleanup() {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return&apos;Loading...&apos;;
  }
  return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;
}
</code></pre><p>这里有一个点需要重视！这种解绑的模式跟componentWillUnmount不一样。componentWillUnmount只会在组件被销毁前执行一次而已，而useEffect里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。</p>
<h3 id="为什么要让副作用函数每次组件更新都执行一遍？"><a href="#为什么要让副作用函数每次组件更新都执行一遍？" class="headerlink" title="为什么要让副作用函数每次组件更新都执行一遍？"></a>为什么要让副作用函数每次组件更新都执行一遍？</h3><p>我们先看以前的模式：</p>
<pre><code>componentDidMount() {
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }

  componentWillUnmount() {
    ChatAPI.unsubscribeFromFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
</code></pre><p>很清除，我们在componentDidMount注册，再在componentWillUnmount清除注册。但假如这时候<code>props.friend.id</code>变了怎么办？我们不得不再添加一个componentDidUpdate来处理这种情况：</p>
<pre><code>...
  componentDidUpdate(prevProps) {
    // 先把上一个friend.id解绑
    ChatAPI.unsubscribeFromFriendStatus(
      prevProps.friend.id,
      this.handleStatusChange
    );
    // 再重新注册新但friend.id
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  }
...
</code></pre><p>看到了吗？很繁琐，而我们但useEffect则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：</p>
<pre><code>1.页面首次渲染
2.替friend.id=1的朋友注册

3.突然friend.id变成了2
4.页面重新渲染
5.清除friend.id=1的绑定
6.替friend.id=2的朋友注册
...
</code></pre><h3 id="怎么跳过一些不必要的副作用函数"><a href="#怎么跳过一些不必要的副作用函数" class="headerlink" title="怎么跳过一些不必要的副作用函数"></a>怎么跳过一些不必要的副作用函数</h3><p>按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。</p>
<pre><code>useEffect(() =&gt; {
  document.title = `You clicked ${count}times`;
}, [count]);     // 只有当count的值发生变化时，才会重新执行`document.title`这一句
</code></pre><p>当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是componentDidMount加componentWillUnmount的模式。不过这种用法可能带来bug，少用。</p>
<h2 id="还有哪些自带的Effect-Hooks"><a href="#还有哪些自带的Effect-Hooks" class="headerlink" title="还有哪些自带的Effect Hooks?"></a>还有哪些自带的Effect Hooks?</h2><p>除了上文重点介绍的useState和useEffect，react还给我们提供来很多有用的hooks：</p>
<p>useContext<br>useReducer<br>useCallback<br>useMemo<br>useRef<br>useImperativeMethods<br>useMutationEffect<br>useLayoutEffect</p>
<p>我不再一一介绍，大家自行去查阅官方文档。</p>
<h2 id="怎么写自定义的Effect-Hooks"><a href="#怎么写自定义的Effect-Hooks" class="headerlink" title="怎么写自定义的Effect Hooks?"></a>怎么写自定义的Effect Hooks?</h2><p>为什么要自己去写一个Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。</p>
<p>比如我们可以把上面写的FriendStatus组件中判断朋友是否在线的功能抽出来，新建一个useFriendStatus的hook专门用来判断某个id是否在线。</p>
<pre><code>import { useState, useEffect } from &apos;react&apos;;

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() =&gt; {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}
</code></pre><p>这时候FriendStatus组件就可以简写为：</p>
<pre><code>function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return &apos;Loading...&apos;;
  }
  return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;
}
</code></pre><p>简直Perfect！假如这个时候我们又有一个朋友列表也需要显示是否在线的信息：</p>
<pre><code>function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;
      {props.friend.name}
    &lt;/li&gt;
  );
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/05/Redux源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/05/Redux源码分析/" itemprop="url">Redux源码分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-05T20:24:30+08:00">
                2018-11-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抛开React不谈，Redux其实就只是一个管理状态的数据中心，然而作为一个数据中心它的特色在于我们不能够直接修改数据中心里面的数据，我们需要自行定义操作逻辑<code>reducer</code>，以及操作类型<code>action</code>,通过分发不同的<code>action</code>来匹配<code>reducer</code>里面对应的操作，才能达到修改数据的目的。</p>
<p>一般来说我们会通过以下方式来创建一个数据中心<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from&apos;redux&apos;</span><br><span class="line">const store = createStore(...blablabla)</span><br></pre></td></tr></table></figure></p>
<p>这里最为关键的就是<code>createStore</code>这个函数，接下来我想详细地对它做个分析。</p>
<h2 id="createStore方法剖析"><a href="#createStore方法剖析" class="headerlink" title="createStore方法剖析"></a>createStore方法剖析</h2><p>createStore.js这个文件纯代码的部分大概有100多行，如果把他们全部贴出来再一一分析并非明智之举，我认为只对关键的部分进行分析是更恰当的做法。<br><strong>要分析一个方法我觉得比较有意义的是看它接收了什么，以及返回了什么。</strong></p>
<h3 id="接收的参数"><a href="#接收的参数" class="headerlink" title="接收的参数"></a>接收的参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法接受三个参数，分别是<code>reducer</code>, <code>preloadedState</code>, <code>enhancer</code>。以上都分别可以由开发者进行定义，<code>reducer</code>就是由开发者定义的一个操作方法，它会以旧的状态作为参数，处理过后返回一个新的状态。<code>preloadedState</code>则可以理解成数据中心的初始状态，它是个可选值。</p>
<p>最后的<code>enhancer</code>又是什么呢？从字面上理解它是一个增强器，用于增强<code>createStore</code>。从源码看它的工作方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  .....</span><br><span class="line">  if (typeof preloadedState === &apos;function&apos; &amp;&amp; typeof enhancer === &apos;undefined&apos;) &#123; // 参数归一</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = undefined</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (typeof enhancer !== &apos;undefined&apos;) &#123;</span><br><span class="line">    if (typeof enhancer !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new Error(&apos;Expected the enhancer to be a function.&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return enhancer(createStore)(reducer, preloadedState) // 直接返回一个增强后的`createStore</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，它接收了原来的<code>createStore</code>作为参数，并且返回了一个增强了的方法，最后用增强过的方法来调用原来传入的参数。了解原理之后我们可以很容易地写出一个<code>状态打印增强器</code>，用于打印<code>dispatch</code>前后的状态信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">function enhancer(createStore) &#123;</span><br><span class="line">  return (reducer, initialState, enhancer) =&gt; &#123;</span><br><span class="line">    const store = createStore(reducer, initialState, enhancer)</span><br><span class="line"></span><br><span class="line">    function dispatch(action) &#123;</span><br><span class="line">      console.log(&apos;old&apos;, store.getState())</span><br><span class="line">      const res = store.dispatch(action);</span><br><span class="line">      console.log(&apos;new&apos;, store.getState())</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 用心的dispatch方法来替换原有的dispatch方法</span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducers, undefined, enhancer)</span><br></pre></td></tr></table></figure></p>
<p>另外，从Redux的源码可以看到<code>createStore</code>做了一种叫做参数归一的处理，在许多JS库中都会采用这种方式兼容不同情况下的参数传入。当我们不需要传入初始状态，而只需要使用<code>enhancer</code>增强器的时候，我们还可以把代码写成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(reducers, enhancer)</span><br></pre></td></tr></table></figure></p>
<h3 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2) 返回值"></a>2) 返回值</h3><p>接下来我们看看返回值。<code>createStore</code>最终会返回一个对象，包含的东西如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import $$observable from &apos;symbol-observable&apos;</span><br><span class="line"></span><br><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  .....</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">    [$$observable]: observable</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些便是我们数据中心为外部提供的全部接口了。最后一个看起来有点奇怪，其他的从字面上应该都比较容易理解，容许许我一一分析。</p>
<h4 id="a-getState–返回当前状态"><a href="#a-getState–返回当前状态" class="headerlink" title="a. getState–返回当前状态"></a>a. getState–返回当前状态</h4><p>Redux的核心理念之一就是不支持直接修改状态，它是通过闭包来实现这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  let currentState = preloadedState</span><br><span class="line"></span><br><span class="line">  function getState() &#123;</span><br><span class="line">    .....</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它先是定义了一个内部的变量<code>currentState</code>，然后通过一个名为<code>getState</code>的方法来返回它的值。这就造成了<code>currentState</code>这个状态对我们而言是只读的，我们没办法直接修改它的值。在代码里面我们可以通过<code>getState</code>这个方法来返回当前状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(store.getState())</span><br></pre></td></tr></table></figure></p>
<h4 id="b-subscribe–构造监听者队列"><a href="#b-subscribe–构造监听者队列" class="headerlink" title="b. subscribe–构造监听者队列"></a>b. subscribe–构造监听者队列</h4><p>每个<code>store</code>本身会维护一个监听者队列，我们可以把它想象成一个方法的队列，在每次分发<code>action</code>的时候都会依次调用监听者队列中所有方法。通过这个<code>subscribe</code>方法可以手动地把一些回调函数添加到监听者队列中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  let currentListeners = []</span><br><span class="line">  let nextListeners = currentListeners</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  function ensureCanMutateNextListeners() &#123;</span><br><span class="line">    if (nextListeners === currentListeners) &#123;</span><br><span class="line">      nextListeners = currentListeners.slice()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  function subscribe(listener) &#123;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    let isSubscribed = true</span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">    return function unsubscribe() &#123;</span><br><span class="line">      if (!isSubscribed) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ....</span><br><span class="line"></span><br><span class="line">      isSubscribed = false</span><br><span class="line"></span><br><span class="line">      ensureCanMutateNextListeners()</span><br><span class="line">      const index = nextListeners.indexOf(listener)</span><br><span class="line">      nextListeners.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑其实很简单，为了减少篇幅我把一些类型检查的代码去掉了。每次调用<code>subscribe</code>的时候传入一个回调函数，<code>subscribe</code>会把它放到一个监听者队列中去，并返回一个<code>unsubscribe</code>的方法。这个<code>unsubscribe</code>方法是让开发者可以方便地从列表中删除对应的回调函数，此外该方法还维护着一个<code>isSubscribed</code>标识订阅状态。</p>
<p>这里面有一个比较有意思的<code>ensureCanMutateNextListeners</code>的方法，按照代码的逻辑，它是要保证监听者的添加与删除并不在<code>currentListeners</code>这个原始的队列里面进行直接操作，我们操作的只是它的一个副本。直到我们调用<code>dispatch</code>方法进行分发的时候，<code>currentListeners</code>与<code>nextListeners</code>才会再一次指向同一个对象，这个在后面的代码里面会看到。</p>
<h4 id="c-dispatch–低调的action分发者"><a href="#c-dispatch–低调的action分发者" class="headerlink" title="c. dispatch–低调的action分发者"></a>c. dispatch–低调的action分发者</h4><p><code>dispatch</code>方法是用来分发<code>action</code>的，可以把它理解成用于触发数据更新的方法。它的核心实现也比较简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  ...</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    // 调用reducer</span><br><span class="line">    try &#123;</span><br><span class="line">      isDispatching = true</span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isDispatching = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用监听者</span><br><span class="line">    const listeners = (currentListeners = nextListeners)</span><br><span class="line">    for (let i = 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      const listener = listeners[i]</span><br><span class="line">      listener()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return action</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我依旧把一些类型检查的代码去掉，首先<code>dispatch</code>方法会以当前的状态<code>currentState</code>以及我们定义的动作<code>action</code>作为参数来调用当前的<code>reducer</code>方法。另外它使用<code>isDispatching</code>变量来记录分发的状态，正在分发则设置为<code>true</code>。这里需要注意的是我们的<code>reducer</code>方法将会被设置成一个<strong>纯函数</strong>–它不会产生副作用，并且对于同样的输入它会返回同样的输出。换句话说它不会直接在原来状态的基础上进行修改，而是会直接返回一个新的状态，并对原有状态进行替换。</p>
<p>完成了上面这些之后我们会依次遍历所有的监听者，并且手动调用所有的回调函数。这里需要注意的是之前有讲过的，订阅/取消订阅的时候我们会生成一个<code>currentLIsteners</code>的副本<code>nextListeners</code>并在它上面添加/删除回调函数。然而到了<code>dispatch</code>这一步他们会做一次同步，这样他们就又会指向同一个对象了。</p>
<h4 id="d-replaceReducer–替换当前的reducer"><a href="#d-replaceReducer–替换当前的reducer" class="headerlink" title="d. replaceReducer–替换当前的reducer"></a>d. replaceReducer–替换当前的reducer</h4><p><code>replaceReducer</code>这个方法做的事情其实很简单，它可以用新的<code>reducer</code>替换掉当前的<code>reducer</code>，并且分发一个替换的<code>action</code>，下面是源代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  .....</span><br><span class="line">  function replaceReducer(nextReducer) &#123;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    dispatch(&#123; type: ActionTypes.REPLACE &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>据说这种方式在调试环境下会用得比较多。在正式环境下一般都不会在中途更替<code>reducer</code>，以免得增加维护成本。</p>
<h4 id="e-observable–观察者"><a href="#e-observable–观察者" class="headerlink" title="e. observable–观察者"></a>e. observable–观察者</h4><p>这个是比较让我费解的一个功能了，然而Redux的数据中心居然把它作为api开放出来，咱门先贴源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  ....</span><br><span class="line">  function observable() &#123;</span><br><span class="line">    const outerSubscribe = subscribe</span><br><span class="line">    return &#123;</span><br><span class="line">      ...</span><br><span class="line">      subscribe(observer) &#123;</span><br><span class="line">        ....</span><br><span class="line">        function observeState() &#123;</span><br><span class="line">          if (observer.next) &#123;</span><br><span class="line">            observer.next(getState())</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        observeState()</span><br><span class="line">        const unsubscribe = outerSubscribe(observeState)</span><br><span class="line">        return &#123; unsubscribe &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      [$$observable]() &#123;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果直接调用这个接口，它会返回一个对象，而对象里面包含了<code>subscribe</code>方法，并且我们可以把一个包含<code>next</code>字段(它是一个函数)的对象作为<code>subscribe</code>方法的参数，就可以在每次数据变动的时候以<strong>当前状态<code>getState()</code></strong>作为参数调用<code>next</code>所携带的函数。</p>
<p>这么说有点拗口，可能给个例子会比较直观</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import $$observable from &apos;symbol-observable&apos;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">const store = createStore(reducer)</span><br><span class="line"></span><br><span class="line">const subObject = store[$$observable]()</span><br><span class="line">subObject.subscribe(&#123;</span><br><span class="line">  next: (a) =&gt; &#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就可以做到每次动作被分发的时候都会调用<code>next</code>所携带的方法，并打印出<code>getState()</code>的值。这种观察者模式的写法有什么特殊的意义我也还没有时间去深究，似乎是<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-observable" target="_blank" rel="noopener">草案</a>的一部分，估计目前用的也不多，先不深入探究了。</p>
<hr>
<h2 id="1-中间件"><a href="#1-中间件" class="headerlink" title="1. 中间件"></a>1. 中间件</h2><p><img src="/2018/11/05/Redux源码分析/1.jpg" alt=""><br>中间件这个概念存在于许多流行的Web框架中，可以把它想象成是请求/响应分发的中间层，用于对请求/响应做进一步的处理，而无需改变原有的代码逻辑。在<code>node.js</code>社区的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkoajs%2Fkoa" target="_blank" rel="noopener">KOA</a>轻量级框架很出色地体现了这一点(当然它肯定不是第一个这样干的人)。koa本身只提供了最基础的请求/响应功能，如果想要更强大的功能(比如说日志，时间记录等功能)则需要自己添加相应的中间件。</p>
<p>Redux继承了这一理念，它把中间件应用到了<code>dispatch</code>方法的扩展中，让我们可以优雅地扩展<code>dispatch</code>方法，而不需要重写原有的<code>dispatch</code>方法，接下来我们好好体会一下它的精妙之处。</p>
<h2 id="2-中间件在Redux中的应用"><a href="#2-中间件在Redux中的应用" class="headerlink" title="2. 中间件在Redux中的应用"></a>2. 中间件在Redux中的应用</h2><p>在分析源码之前先来看看在Redux里面如何使用中间件，最关键的是<code>applyMiddleware</code>这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;</span><br><span class="line">// Add thunk</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">import logger from &apos;redux-logger&apos;</span><br><span class="line"></span><br><span class="line">const reducer = (state) =&gt; state</span><br><span class="line"></span><br><span class="line">let newCreateStore = applyMiddleware(</span><br><span class="line">  logger,</span><br><span class="line">  thunk</span><br><span class="line">)(createStore)</span><br><span class="line"></span><br><span class="line">// 创建store，数据中心</span><br><span class="line">let store = newCreateStore(reducer)</span><br></pre></td></tr></table></figure></p>
<p>其中<code>thunk</code>跟<code>logger</code>就是我们提到的中间件，依次把它们传入<code>applyMiddleware</code>函数中，就会返回一个新的函数，然后再用这个函数处理原始的<code>createStore</code>方法就会返回一个增强过的<code>createStore</code>方法。</p>
<p>另外，还记得<code>createStore</code>函数可以接收<code>enhancer</code>这个参数不？其实<code>applyMiddleware</code>这个方法经过调用后所得到的就是一个增强器。为此我们还可以这样调用<code>createStore</code>，并生成<code>store</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">let enhancer = applyMiddleware(</span><br><span class="line">  logger,</span><br><span class="line">  thunk</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">let store = createStore(reducer, enhancer)</span><br></pre></td></tr></table></figure></p>
<p>这种做法跟前面的扩展效果是一样的。</p>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><h3 id="1-中间件原理"><a href="#1-中间件原理" class="headerlink" title="1) 中间件原理"></a>1) 中间件原理</h3><p>在源码分析之前，先举个例子来看看一个简单的<code>中间件</code>内部应该是什么样子的，我分别定义<code>middleware1</code>，<code>middleware2</code>两个中间件(他们本质是高阶函数)，并用来扩展<code>originDispatch</code>函数</p>
<pre><code>let originDispatch = (...args) =&gt; {
  console.log(...args)
}

const middleware1 = (dispatch) =&gt; {
  return(...args) =&gt; {
    console.log(&apos;middleware1 before dispatch&apos;)
    dispatch(...args)
    console.log(&apos;middleware1 after dispatch&apos;)
  }
}

const middleware2 = (dispatch) =&gt; {
  return(...args) =&gt; {
    console.log(&apos;middleware2 before dispatch&apos;)
    dispatch(...args)
    console.log(&apos;middleware2 before dispatch&apos;)
  }
}

originDispatch = middleware2(middleware1(originDispatch))
originDispatch(&apos;ruby&apos;, &apos;cool&apos;, &apos;language&apos;)
</code></pre><p>结果如下</p>
<pre><code>middleware2 before dispatch
middleware1 before dispatch
ruby cool language
middleware1 after dispatch
middleware2 before dispatch
</code></pre><p>是不是运行过程是不是有点像洋葱？我们可以使用中间件来对原有的方法进行增强，并返回一个增强了的方法，然后再用另一个中间件来对这个已经增强过的方法再进一步增强，模型示意图如下<br><img src="/2018/11/05/Redux源码分析/164250984dffa839.webp" alt=""></p>
<h3 id="2-compose–方法封链辅助函数"><a href="#2-compose–方法封链辅助函数" class="headerlink" title="2) compose–方法封链辅助函数"></a>2) compose–方法封链辅助函数</h3><p>从上面的洋葱模型可以看出我们如果要增强一个方法，它的步骤如下</p>
<pre><code>newFunc = f1(f2(func))
</code></pre><p>可以简单地把<code>f1</code>,<code>f2</code>理解成我们需要各自定义的中间件函数，然而如果我们每次都要手动调用这些方法的话似乎并不太优雅，这个时候可以使用<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux%2Fblob%2Fmaster%2Fsrc%2Fcompose.js" target="_blank" rel="noopener">compose</a>函数来完成这种事情。</p>
<p><code>compose</code>在中文里面是组合的意思，Redux所定义的<code>compose</code>函数可以把函数的参数列表构造成依次调用的形式，并返回一个新的函数。它的源码如下</p>
<pre><code>export default functioncompose(...funcs) {
  ...
  // 以上都是判断
  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}
</code></pre><p>文字解释可能还不如流程图来得直观，下面简单地分析一下<code>compose(f1, f2, f3, f4)</code>的调用过程</p>
<pre><code>a: f1, b: f2, return: (...args) =&gt; f1(f2(...args))
a: (...args) =&gt; f1(f2(...args)), b: f3, return: (...args) =&gt; f1(f2(f3(...args)))
a: (...args) =&gt; f1(f2(f3(...args))), b: f4, return: (...args) =&gt; f1(f2(f3(f4(...args))))
</code></pre><p>把这个方法应用在最初的例子中</p>
<pre><code>&gt; newfunc = compose(middleware2, middleware1)(originDispatch)
[Function]
&gt; newfunc(&apos;node&apos;, &apos;good&apos;, &apos;languate&apos;)

middleware2 before dispatch
middleware1 before dispatch
node good languate
middleware1 after dispatch
middleware2 before dispatch
</code></pre><p>结果是一样的。而且从这个例子还可以看出在<code>compose</code>函数的参数列表中越靠后的函数，在构造完成之后，距离原始函数就越近。</p>
<h3 id="3-applyMiddleware–收集中间件，扩展createStore"><a href="#3-applyMiddleware–收集中间件，扩展createStore" class="headerlink" title="3) applyMiddleware–收集中间件，扩展createStore"></a>3) applyMiddleware–收集中间件，扩展createStore</h3><p>applyMiddleware.js这个文件里面就包含着它的源码</p>
<pre><code>export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    const store = createStore(...args)
    let dispatch = () =&gt; {
      throw new Error(
        `Dispatching while constructing your middleware is not allowed. ` +
          `Other middleware would not be applied to this dispatch.`
      )
    }

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (...args) =&gt; dispatch(...args)
    }

    // #1 中间件应该接收store
    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))

    // #2 返回的函数用于处理dispatch函数
    dispatch = compose(...chain)(store.dispatch)

    // #3 替换dispatchreturn {
      ...store,
      dispatch
    }
  }
}
</code></pre><p>代码片段<code>#2</code>中我们传入<code>compose</code>函数里的所有函数都是用于扩展<code>dispatch</code>的，这些函数会被定义为这种形式</p>
<pre><code>(dispatch) =&gt; {
  return function(...args) {
    // do something before
    dispatch(...args)
    // do something after
  }
}
</code></pre><p>这些函数会接收一个<code>dispatch</code>方法为参数，并返回一个增强的<code>dispatch</code>方法。然而我们需要编写的中间件却不仅如此，接下来再看看代码片段<code>#1</code>，以及相关的上下文逻辑</p>
<pre><code>export default function applyMiddleware(...middlewares) {
  ....
  const middlewareAPI = {
    getState: store.getState,
    dispatch: (...args) =&gt; dispatch(...args)
  }

  // #1 中间件应该接收store
  const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))

  // #2 返回的函数用于处理dispatch函数
  dispatch = compose(...chain)(store.dispatch)
  ...
}
</code></pre><p>我们通过<code>map</code>方法来处理<code>applyMiddleware</code>所接收的所有中间件，让他们分别以<code>middlewareAPI</code>这个对象作为参数调用过后会返回一个新的函数列表，而这个函数列表才是真正用来增强<code>dispatch</code>的。</p>
<p><code>middlewareAPI</code>是仅仅包含了<code>getState</code>与<code>dispatch</code>这两个字段的对象，可以把它看成是一个精简版的<code>store</code>。因此我们需要编写的中间件应该是以<code>store</code>作为参数，并且返回一个用于增强<code>dispatch</code>方法的函数，而这个<code>store</code>我们只能够使用<code>getState</code>，<code>dispatch</code>这两个接口。听起来有点拗口，下面我们自行编写一个用于打印状态日志的中间件。</p>
<pre><code>const Logger = (store) =&gt; (dispatch) =&gt; {
  return function(...args) {
    const wrappedDispatch = store.dispatch
    const getState = store.getState

    console.log(&apos;before dispatch&apos;, getState())
    dispatch(...args)
    console.log(&apos;after dispatch&apos;, getState())

    console.info(dispatch)
    console.info(wrappedDispatch)
  }
}
</code></pre><p>其中<code>dispatch</code>与<code>wrappedDispatch</code>所指代的分发方法是不一样的。</p>
<p><code>dispatch</code>是从参数中传入，如果当前中间件是第一个对<code>dispatch</code>方法进行增强的中间件，则当前的<code>dispatch</code>所指向的就是Redux原生定义的<code>dispatch</code>方法。如果当前中间件前面已经有若干中间件的调用，则当前<code>dispatch</code>所指代的是经过前面中间件加强过的新的<code>dispatch</code>方法。我们可以来验证一下</p>
<pre><code>let enhancer = applyMiddleware(
  Logger, // 我们自己编写的Logger
  thunk
)
</code></pre><p><code>dispatch</code>的打印结果如下</p>
<pre><code>ƒ(action) {
  if (typeof action === &apos;function&apos;) {
    return action(dispatch, getState, extraArgument);
  }

  return next(action);
}
</code></pre><p>可见，这是一个经过<code>thunk</code>中间件处理后返回的方法。</p>
<p><code>wrappedDispatch</code>因为匿名函数<code>(...args) =&gt; dispatch(...args)</code>的关系，在<code>applyMiddleware</code>函数运行完成并返回之后，匿名函数内部的<code>dispatch</code>会始终指向经过我们增强的<code>dispatch</code>方法。也就是说在中间件里面执行<code>store.dispatch</code>就会始终运行最外层的被增强过的<code>dispatch</code>方法。模型如下<br><img src="/2018/11/05/Redux源码分析/2.webp" alt=""><br><code>wrappedDispatch</code>打印结果虽然看不出什么，但我也顺手贴一下吧</p>
<pre><code>ƒ dispatch() {
  return _dispatch.apply(undefined, arguments);
}
</code></pre><p>接下来，我们看<code>applyMiddleware</code>的返回值，它会返回一个新的函数，该函数会以<code>createStore</code>作为参数，处理过后返回一个新的<code>createStore</code>方法，它的模式大概是这样子</p>
<pre><code>(createStore) =&gt; (...args) =&gt; {

  // createStore方法用来创建store
  return {
    ...
    getState: ...
    dispatch: ...
  }
}
</code></pre><p>而在<code>applyMiddleware</code>中实际上我们只需要增强<code>dispatch</code>方法，为此我们只需要用新的<code>dispatch</code>方法来替换原来的便可。代码片段<code>#3</code>就是用新的<code>dispatch</code>方法取代原来<code>store</code>中的<code>dispatch</code>方法。</p>
<pre><code>....
    return {
      ...store,
      dispatch
    }
....
</code></pre><hr>
<h2 id="1-模块化reducer"><a href="#1-模块化reducer" class="headerlink" title="1. 模块化reducer"></a>1. 模块化reducer</h2><p>我们写代码的时候也有这种情况<strong>当一个文件包含的代码太多的时候我们会考虑按逻辑把它们拆分成几个模块，而当我们遇到一些细粒度同类模块的集合时，则会考虑把他们汇总为一个的模块。</strong>至于什么时候该拆，什么时候该合，可能不同的领域自有它的权衡方式。</p>
<p>今天主要谈谈Redux里面如何模块化管理多个reducer函数。在Redux应用里reducer函数可以理解成一个处理状态的函数，它接受一个状态，以及一个动作，处理之后返回一个更新后的状态。一个简单的reducer函数大概如下</p>
<pre><code>function reducerExample(state={}, action) {
  switch (action.type) {
    case&apos;INCREMENT&apos;:
      return Object.assign({}, state, {counter: state.counter + 1})
    case&apos;DECREMENT&apos;:
      return Object.assign({}, state, {counter: state.counter - 1})
    default:
      return state
  }
}
</code></pre><p>然而这个函数所包含的逻辑仅仅是对状态的<code>counter</code>字段进行加一以及减一操作。Redux是数据中心，它所管理的状态可能会包含很多个字段，当字段相当多的时候，我们需要在<code>reducerExample</code>函数中定义的操作也会渐渐多起来</p>
<pre><code>function reducerExample(state={}, action) {
  switch (action.type) {
    case&apos;INCREMENT&apos;:
      return Object.assign({}, state, {counter: state.counter + 1})
    case&apos;DECREMENT&apos;:
      return Object.assign({}, state, {counter: state.counter - 1})
    case&apos;MULTI&apos;:
      return Object.assign({}, state, {otherCounter: state.otherCounter * 2})
    ....
    // 此处省略100行代码
    ....
    default:
      return state
  }
}
</code></pre><p>随着状态越来越多，操作函数也将会越来越复杂，单一的reducer函数并非长久之计。这也是Redux为何提供<code>combineReducers</code>的原因，它使得我们可以以模块的方式来管理多个reducer函数。</p>
<p>简单讲解该函数的使用，假设Redux管理的应用状态如下</p>
<pre><code>{
  counter: 0,
  article: {
    title: &quot;&quot;,
    content: &quot;&quot;
  }
}
</code></pre><p>则我们可以分别定义两个reducer函数<code>counterReducer</code>与<code>articleReducer</code></p>
<pre><code>function counterReducer(counter=0, action) {
  ...
}


function articleReducer(article={}, action) {
  ...
}
</code></pre><p>在<code>counterReducer</code>里面只定义与<code>counter</code>字段有关的数据操作，而在<code>articleReducer</code>里面只定义与<code>article</code>字段有关的数据操作，最后通过<code>combineReducers</code>来合并两个reducer函数，并生成新的函数<code>reducer</code>，我们只需要把这个新的函数<code>reducer</code>与系统进行集成即可。</p>
<pre><code>const reducer = combineReducers({
  counter: counterReducer,
  article: articleReducer
})
</code></pre><p>我们甚至可以把<code>counterReducer</code>与<code>articleReducer</code>两个函数放在不同的文件中，然后在同一个地方汇总(通过<code>combineReducers</code>)。当我们分发指定的动作之后只有定义了该动作的函数会改变它所对应字段的状态信息。</p>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>接下来分析一下<code>combineReducers</code>函数的工作原理。<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux%2Fblob%2Fmaster%2Fsrc%2FcombineReducers.js" target="_blank" rel="noopener">combineReducers.js</a>这个文件代码加注释大概100多行，然而我们真正需要了解的核心就仅仅是该脚本中需要导出的<code>combineReducers</code>这个函数，其他代码大多是用于断言，暂且略过不谈。</p>
<h3 id="1-收集reducers"><a href="#1-收集reducers" class="headerlink" title="1) 收集reducers"></a>1) 收集reducers</h3><p>我们都知道函数接收对象的每个键所对应的值都应该是一个可以用于改变状态的reducer函数，为此我们会先遍历<code>combineReducers</code>函数所接收的对象，排除其中不是函数的字段。</p>
<pre><code>export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers)
  const finalReducers = {}
  for (let i = 0; i &lt; reducerKeys.length; i++) { // #1
    const key = reducerKeys[i]

    ....

    if (typeof reducers[key] === &apos;function&apos;) { // #2
      finalReducers[key] = reducers[key]
    }
  }

  ......
}
</code></pre><p>代码片段<code>#1</code>遍历函数接收的对象的所有键，代码片段<code>#2</code>判断该键在原对象中指向的内容是否是一个函数。如果是函数的话，则把该函数以同样的键存储到<code>finalReducers</code>这个对象中，等循环结束以后<code>finalReducers</code>对象的每一个键所对应的值则都是一个函数了。</p>
<h3 id="2-返回一个新的reducer函数"><a href="#2-返回一个新的reducer函数" class="headerlink" title="2) 返回一个新的reducer函数"></a>2) 返回一个新的reducer函数</h3><p><code>combineReducers</code>其实是一个reducer函数的工厂，在收集不同模块的reducer函数之后，它的责任就是返回一个新的reducer，而这个新的reducer函数能够调度先前收集的所有reducer。我把后续源码中的断言都去掉之后就剩下下列代码</p>
<pre><code>export default function combineReducers(reducers) {
  ...

  const finalReducerKeys = Object.keys(finalReducers) // # 1
    return function combination(state = {}, action) {
    .....

    let hasChanged = false
    const nextState = {}
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key] // #2
      const previousStateForKey = state[key] // #3
      const nextStateForKey = reducer(previousStateForKey, action) // #4
      ....
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}
</code></pre><p>首先会在代码片段<code>#1</code>获取先前过滤好的<code>finalReducers</code>对象的所有键，并存储到<code>finalReducerKeys</code>中。然后当前函数会返回一个新的reducer函数，这个函数能够访问<code>finalReducers</code>形成一个闭包。</p>
<p>当调用这个新的reducer函数的时，它会遍历<code>finalReducerKeys</code>这个数组中的每一个键，在代码<code>#2</code>处获取当前键所对应的reducer函数并存储到常量<code>reducer</code>，然后在代码<code>#3</code>处获取当前键所对应的状态<code>previousStateForKey</code>。</p>
<p>接下来在代码<code>#4</code>处以当前状态<code>previousStateForKey</code>以及<code>action</code>作为参数来调用<code>reducer</code>函数，返回该键所对应的新状态<code>nextStateForKey</code>。在每次迭代中都会把当前键<code>key</code>作为字段，把新的状态存储到<code>nextState</code>这个对象中去，循环结束之后，我们就能够保证<code>action</code>被充分调度了。</p>
<p>另外，还记得咱门编写reducer函数的时候会经常使用这种语法吗？</p>
<pre><code>Object.assign({}, state, {counter: state.counter + 1})
</code></pre><p>这表明了我们不会在原来的<code>state</code>基础上进行修改操作，而是生成了一个新的<code>state</code>，原理大概如下</p>
<pre><code>&gt; a = {}
{}
&gt; b = Object.assign(a, {counter: 1})
{ counter: 1 }
&gt; c = Object.assign({}, a, {counter: 1})
{ counter: 1 }
&gt; a === b
true
&gt; a === c
false
</code></pre><p>而在Redux中，正常情况下如果reducer方法被调用后并没有产生新的对象，而只是在原有的对象中进行操作的话，则在绑定组件的时候，状态的修改将有可能不会引起组件的更新。reducer函数的定位是纯函数，不应该造成任何副作用，为此，reducer函数都应该要生成新的对象。</p>
<p>在<code>combineReducers</code>这个函数里也会有相应的处理，这里需要着重关注<code>hasChanged</code>这个变量</p>
<pre><code>...
  return hasChanged ? nextState : state
...
</code></pre><p>当且仅当，这个变量为真值的时候我们才会返回新的状态，不然的话依旧返回原有的状态。这个<code>hasChanged</code>是由以下代码控制的</p>
<pre><code>...
for (let i = 0; i &lt; finalReducerKeys.length; i++) {
  ....
  hasChanged = hasChanged || nextStateForKey !== previousStateForKey
}
</code></pre><p>也就是说在所有的迭代中至少有一次迭代符合<code>nextStateForKey !== previousStateForKey</code>这个条件的时候(所对应的reducer返回了新的对象)<code>hasChanged</code>才会为真，新的reducer函数才会返回新的状态对象<code>nextState</code>。否则将返回原有的状态对象<code>state</code>，这样在绑定React组件的时候则有可能会出现状态数据更新了，组件却没有响应的情况。</p>
<h2 id="为什么Redux-需要-reducers是纯函数？"><a href="#为什么Redux-需要-reducers是纯函数？" class="headerlink" title="为什么Redux 需要 reducers是纯函数？"></a><a href="http://localhost:4000/2018/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88Redux-%E9%9C%80%E8%A6%81-reducers%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9F/" target="_blank" rel="noopener">为什么Redux 需要 reducers是纯函数？</a></h2><h2 id="1-ActionCreator创建动作"><a href="#1-ActionCreator创建动作" class="headerlink" title="1. ActionCreator创建动作"></a>1. ActionCreator创建动作</h2><p>在深入分析源码之前我们先来聊聊<code>ActionCreator</code>。从字面上理解，它是一个动作的创造者，或者说是动作的工厂。如果我们想根据不同的参数来生成不同步长的计数器动作，则可以把工厂函数声明为</p>
<pre><code>const counterIncActionCreator = function(step) {
  return {
    type: &apos;INCREMENT&apos;,
    step: step || 1
  }
}
</code></pre><p>随着业务逻辑越来越复杂，我们可以通过定义更加复杂的工厂函数来生成更多样化的动作类型。</p>
<h2 id="2-bindActionCreator高阶函数"><a href="#2-bindActionCreator高阶函数" class="headerlink" title="2. bindActionCreator高阶函数"></a>2. bindActionCreator高阶函数</h2><p>从上述的例子出发，如果我们想生产出不同步长的计数器动作，并分发他们，则需要把代码写成下面这样子</p>
<pre><code>// 为了简化代码我把dispatch函数定义为只有打印功能的函数
const dispatch = function(action) {
  console.log(action)
}

const action1 = counterIncActionCreator()
dispatch(action1) // { type: &apos;INCREMENT&apos;, step: 1 }

const action2 = counterIncActionCreator(2)
dispatch(action2) // { type: &apos;INCREMENT&apos;, step: 2 }

const action3 = counterIncActionCreator(3)
dispatch(action3) // { type: &apos;INCREMENT&apos;, step: 3 }
</code></pre><p>可见每次分发动作之前我们都得手动调用<code>counterIncActionCreator</code>来生产相应的动作，这种方式并不是那么的优雅。这个时候我们就可以采用<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux%2Fblob%2Fmaster%2Fsrc%2FbindActionCreators.js" target="_blank" rel="noopener">bindActionCreators</a>这个文件里面的<code>bindActionCreator</code>工具函数来优化代码了，该函数的源码如下</p>
<pre><code>function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments))
  }
}
</code></pre><p><code>bindActionCreator</code>将会返回一个新函数，这个函数会用自身所接收的参数来调用<code>actionCreator</code>并生成对应动作，并且这个生成的动作将会作为<code>dispatch</code>函数的参数。也就是说我们把</p>
<ol>
<li>生成动作</li>
<li>调度动作</li>
</ol>
<p>这两个步骤都封装到一个函数里面了，于是便得到了更为优雅的调度过程</p>
<pre><code>...
const increment = bindActionCreator(counterIncActionCreator, dispatch)

increment() // { type: &apos;INCREMENT&apos;, step: 1 }

increment(2) // { type: &apos;INCREMENT&apos;, step: 2 }

increment(3) // { type: &apos;INCREMENT&apos;, step: 3 }
</code></pre><h2 id="3-bindActionCreators"><a href="#3-bindActionCreators" class="headerlink" title="3. bindActionCreators"></a>3. bindActionCreators</h2><p>接下来看看<code>bindActionCreators</code>这个函数，它是<code>bindActionCreator</code>函数的加强版。删掉一些断言语句之后源码如下</p>
<pre><code>export default functionbindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === &apos;function&apos;) { // #1
     return bindActionCreator(actionCreators, dispatch) // #2
  }

  ....

  const keys = Object.keys(actionCreators)
  const boundActionCreators = {}
  for (let i = 0; i &lt; keys.length; i++) {
    const key = keys[i]
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === &apos;function&apos;) { // #3
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  return boundActionCreators
}
</code></pre><p>代码<code>#1</code>的判断语句是为了做兼容处理，当接收的参数<code>actionCreators</code>为一个函数的时候，则认为它是单一的动作工厂，便在代码<code>#2</code>处直接调用<code>bindActionCreator</code>工具函数来封装调度过程。</p>
<p>另一情况是当<code>actionCreators</code>参数是一个对象的时候，则遍历这个对象。代码<code>#3</code>会判断每个键在原始对象中的值是否是个函数，如果是一个函数则认为它是一个动作工厂，并使用<code>bindActionCreator</code>函数来封装调度过程，最后把生成的新函数以同样的键<code>key</code>存储到<code>boundActionCreators</code>对象中。在函数的末尾会返回<code>boundActionCreators</code>对象。</p>
<p>举个简单应用例子，首先使用一个对象来存储两个事件工厂</p>
<pre><code>const MyActionCreators = {
  increment: function(step) {
    return {
      type: &apos;INCREMENT&apos;,
      step: step || 1
    }
  },

  decrement: function(step) {
    return {
      type: &apos;DECREMENT&apos;,
      step: - (step || 1)
    }
  }
}
</code></pre><p>然后通过<code>bindActionCreators</code>来封装调度过程，并返回一个新的对象</p>
<pre><code>const dispatch = function(action) {
  console.log(action)
}

const MyNewActionCreators = bindActionCreators(MyActionCreators, dispatch)
</code></pre><p>最后我们便可以用新的对象来主导调度过程了</p>
<pre><code>MyNewActionCreators.increment() // { type: &apos;INCREMENT&apos;, step: 1 }
MyNewActionCreators.increment(2) // { type: &apos;INCREMENT&apos;, step: 2 }
MyNewActionCreators.increment(3) // { type: &apos;INCREMENT&apos;, step: 3 }
MyNewActionCreators.decrement() // { type: &apos;DECREMENT&apos;, step: -1 }
MyNewActionCreators.decrement(2) // { type: &apos;DECREMENT&apos;, step: -2 }
MyNewActionCreators.decrement(3) // { type: &apos;DECREMENT&apos;, step: -3 }
</code></pre><p>这种调度方式显然比原始的依次调用的方式更为优雅</p>
<pre><code>// 原始的调度方式
dispatch(MyActionCreators.increment()) // { type: &apos;INCREMENT&apos;, step: 1 }
dispatch(MyActionCreators.increment(2)) // { type: &apos;INCREMENT&apos;, step: 2 }
dispatch(MyActionCreators.increment(3)) // { type: &apos;INCREMENT&apos;, step: 3 }
dispatch(MyActionCreators.decrement()) // { type: &apos;DECREMENT&apos;, step: -1 }
dispatch(MyActionCreators.decrement(2)) // { type: &apos;DECREMENT&apos;, step: -2 }
dispatch(MyActionCreators.decrement(3)) // { type: &apos;DECREMENT&apos;, step: -3 }
</code></pre><hr>
<h2 id="重点说说redux-middleware"><a href="#重点说说redux-middleware" class="headerlink" title="重点说说redux middleware"></a>重点说说redux middleware</h2><h3 id="middleware-的由来"><a href="#middleware-的由来" class="headerlink" title="middleware 的由来"></a>middleware 的由来</h3><p>在业务中需要打印每一个 action 信息来调试，又或者希望 dispatch 或 reducer 拥有异步请求的功能。面对这些场景时，一个个修改 dispatch 或 reducer 代码有些乏力，我们需要一个可组合的、自由增减的插件机制，Redux 借鉴了 Koa 中 middleware 的思想，利用它我们可以在前端应用中便捷地实现如日志打印、异步请求等功能。<br><img src="/2018/11/05/Redux源码分析/3.webp" alt=""></p>
<p>比如在项目中，进行了如下调用后，redux 就集成了 thunk 函数调用以及打印日志的功能。</p>
<pre><code>import thunk from&apos;redux-thunk&apos;
import logger from&apos;../middleware/logger&apos;
const enhancer = applyMiddleware(thunk, logger),  // 以 redux-thunk、logger 中间件为例介绍中间件的使用
const store = createStore(rootReducer, enhancer)
</code></pre><p>下面追本溯源，来分析下源码。</p>
<h3 id="applyMiddleware-调用入口"><a href="#applyMiddleware-调用入口" class="headerlink" title="applyMiddleware 调用入口"></a>applyMiddleware 调用入口</h3><pre><code>export default function createStore(reducer, preloadedState, enhancer) {
  // 通过下面代码可以发现，如果 createStore 传入 2 个参数，第二个参数相当于就是 enhancer
  if (typeof preloadedState === &apos;function&apos; &amp;&amp; typeof enhancer === &apos;undefined&apos;) {
    enhancer = preloadedState
    preloadedState = undefined
  }
  if (typeof enhancer !== &apos;undefined&apos;) {
    return enhancer(createStore)(reducer, preloadedState)
  }
  ...
}
</code></pre><p>由上述 createStore 发现，applyMiddleware 会进行 <code>applyMiddleware(thunk, logger)(createStore)(reducer, preloadedState)</code> 的调用。</p>
<p>applyMiddleware 源码  如下</p>
<pre><code>export default function applyMiddleware(...middlewares) {
  return createStore =&gt; (...args) =&gt; {
    const store = createStore(...args)
    let dispatch = store.dispatch
    let chain = []

    const middlewareAPI = {
      getState: store.getState,                // 调用 redux 原生方法，获取状态
      dispatch: (...args) =&gt; dispatch(...args) // 调用 redux 原生 dispatch 方法
    }
    // 串行 middleware
    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch // 返回加工过的 dispatch
    }
  }
}
</code></pre><p>可以发现 applyMiddleware 的作用其实就是返回加工过的 dispatch，下面会着重分析 middlewares 是如何串行起来的以及 dispatch 是如何被加工的。</p>
<h3 id="串行-middleware"><a href="#串行-middleware" class="headerlink" title="串行 middleware"></a>串行 middleware</h3><pre><code>const middlewareAPI = {
  getState: store.getState,
  dispatch: (...args) =&gt; dispatch(...args)
}
chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
dispatch = compose(...chain)(store.dispatch)
</code></pre><p>观察上述代码后发现每个 middleware 都会传入参数 middlewareAPI，来看下中间件 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FMuYunyun%2FreactSPA%2Fblob%2F274c00870853638fb0f77df8497f911eb560b617%2Fsrc%2Fclient%2Fmiddleware%2Flogger.js%23L1" target="_blank" rel="noopener">logger 的源码</a> 以及 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgaearon%2Fredux-thunk%2Fblob%2Fmaster%2Fsrc%2Findex.js" target="_blank" rel="noopener">redux-thunk 的源码</a>, 发现中间件接受的第一个参数正是 ({ dispatch, getState })</p>
<pre><code>// logger 源码
export default ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
  console.log(action)
  return next(action) // 经 compose 源码分析，此处 next 为 Store.dispatch
}


// redux-thunk 源码
export default ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {
  if (typeof action === &apos;function&apos;) {
    return action(dispatch,getState);
  }
  //这里可以理解为dispatch(action),本质上就是调用 middleware 链中下一个 middleware 的 dispatch。
  return next(action) // 此处 next 为 logger 中间件返回的 (action） =&gt; {} 函数
}

//使用redux-thunk
const store = createStore(  
  reducer,
  applyMiddleware(thunk)
);

//然后我们实现一个thunkActionCreator
//过一秒加1
export function thunkActionCreator(payload){
    return function(dispatch,getState){
        setTimeout(function(){
            dispatch({type:types.INCREMENT,payload:payload});
        },1000);
    }
},

//最后，在组件中dispatch thunk
this.dispatch(thunkActionCreator(payload));


DEMO:
export const getNav = () =&gt; async (dispatch, getState) =&gt; {
    try {
        let response = await instance.get(`book/navigation`)
        await dispatch(receiveNav(response.data))
    } catch (error) {
        console.log(&apos;error: &apos;, error)
    }
  }
</code></pre><h3 id="dispatch-是如何被加工的"><a href="#dispatch-是如何被加工的" class="headerlink" title="dispatch 是如何被加工的"></a>dispatch 是如何被加工的</h3><p>接着上个小节，在 <code>dispatch = compose(...chain)(store.dispatch)</code> 中发现了 compose 函数，来看下 compose 的源码 </p>
<pre><code>export default function compose(...funcs) {
  // ...
  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}
</code></pre><p>compose 源码中的 <code>funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</code> 算是比较重要的一句，它的作用是返回组合参数后的函数，比如 compose(f, g, h) 等价于 (…args) =&gt; f(g(h(…args)))，效果图如下所示，调用 this.props.dispatch() 后，会调用相应的中间件，最终会调用 redux 原生的 store.dispatch()，并且可以看到中间件调用的形式类似数据结构中的栈(先进后出)。<br><img src="/2018/11/05/Redux源码分析/4.webp" alt=""><br>拿上个小节提到的 logger、redux-thunk 中间件为例，其 middleware 的内部串行调用方式如下，从而完成了 dispatch 功能的增强(支持如 <code>this.props.dispatch(func)</code> 的调用以及日志功能)。具体可以看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FMuYunyun%2FreactSPA%2Fblob%2F274c00870853638fb0f77df8497f911eb560b617%2Fsrc%2Fcommon%2Fpages%2Fmusic%2Findex.js%23L35" target="_blank" rel="noopener">项目中的运用</a></p>
<pre><code>action =&gt; {
  if (typeof action === &apos;function&apos;) {
    return action(dispatch)
  }
  return (action =&gt; {
    console.log(action)
    return store.dispatch(action)
  })(action)
}
</code></pre><h3 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h3><p>redux-promise也是延迟执行的表达式，它是解决异步的另外一种方案。</p>
<p>redux-thunk和核心思想是把action变成thunk，而redux-promise的核心思想是让action返回一个promise对象。</p>
<p>这个中间件使得store.dispatch方法可以接收Promise对象作为参数。这时 ，action 有两种写法:</p>
<p>写法一、返回值是一个Promise对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function promiseIncrement(payload)&#123;</span><br><span class="line"> //  return &#123;type:types.INCREMENT,payload:payload&#125;  以前是这种写法</span><br><span class="line">    return new Promise(function(resolve,reject)&#123;</span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line">        resolve(&#123;type:types.INCREMENT,payload:payload&#125;);</span><br><span class="line">      &#125;,1000);</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p>
<p>写法二，action 对象的payload属性是一个Promise对象，这需要从<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function payloadIncrement()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type:types.INCREMENT,</span><br><span class="line">        payload: new Promise(function(resolve,reject)&#123;</span><br><span class="line">            setTimeout(function()&#123;</span><br><span class="line">                if(Math.random()&gt;.5)&#123;</span><br><span class="line">                    resolve(100);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    reject(-100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来看看 redux-promise是怎么实现的，就会明白它内部是怎么操作的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let promise = (&#123;dispatch,getState&#125;)=&gt;next=&gt;action=&gt;&#123;</span><br><span class="line">    if(action.then &amp;&amp; typeof action.then == &apos;function&apos;)&#123;</span><br><span class="line">        action.then(dispatch);</span><br><span class="line">        // 这里的dispatch就是一个函数，dispatch(action)&#123;state:reducer(state,action)&#125;;</span><br><span class="line">    &#125;else if(action.payload&amp;&amp; action.payload.then&amp;&amp; typeof action.payload.then == &apos;function&apos;)&#123;</span><br><span class="line">        action.payload.then(payload=&gt;dispatch(&#123;...action,payload&#125;),payload=&gt;dispatch(&#123;...action,payload&#125;));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        next(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码可以看出，如果Action本身就是一个Promise，它resolve以后的值应该是一个Action对象，会被dispatch方法送出action.then(dispatch)；如果Action对象的 payload属性是一个Promise对象，那么无论resolve和reject,dispatch 方法都会发出Action。</p>
<h2 id="理解-funcs-reduce-a-b-gt-args-gt-a-b-args"><a href="#理解-funcs-reduce-a-b-gt-args-gt-a-b-args" class="headerlink" title="理解 funcs.reduce((a, b) =&gt; (args) =&gt; a(b(args)))"></a>理解 funcs.reduce((a, b) =&gt; (args) =&gt; a(b(args)))</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			function originDispatch(...args) &#123;</span><br><span class="line">				console.log(...args)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			function middleware1(dispatch) &#123;</span><br><span class="line">				return (...args) =&gt; &#123;</span><br><span class="line">					console.log(&apos;middleware1 before dispatch&apos;)</span><br><span class="line">					dispatch(...args)</span><br><span class="line">					console.log(&apos;middleware1 after dispatch&apos;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			function middleware2(dispatch) &#123;</span><br><span class="line">				return (...args) =&gt; &#123;</span><br><span class="line">					console.log(&apos;middleware2 before dispatch&apos;)</span><br><span class="line">					dispatch(...args)</span><br><span class="line">					console.log(&apos;middleware2 after dispatch&apos;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			function middleware3(dispatch) &#123;</span><br><span class="line">				return (...args) =&gt; &#123;</span><br><span class="line">					console.log(&apos;middleware3 before dispatch&apos;)</span><br><span class="line">					dispatch(...args)</span><br><span class="line">					console.log(&apos;middleware3 after dispatch&apos;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			//			originDispatch = middleware2(middleware1(originDispatch))</span><br><span class="line">			//			originDispatch(&apos;redux&apos;, &apos;is&apos;, &apos;cool&apos;);</span><br><span class="line"></span><br><span class="line">			function compose(...funcs) &#123;</span><br><span class="line">				return funcs.reduce((a, b) =&gt; (args) =&gt; a(b(args)))</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">            //console.log(compose(middleware2, middleware1))</span><br><span class="line">               //(args) =&gt; middleware2(middleware1(args))  </span><br><span class="line">               //(originDispatch)=&gt;middleware2(middleware1(originDispatch))  </span><br><span class="line">               </span><br><span class="line">			compose(middleware2, middleware1)(originDispatch)(&apos;redux&apos;, &apos;is&apos;, &apos;cool&apos;);</span><br><span class="line">			</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>compose(middleware2, middleware1)</code>返回<code>(args) =&gt; middleware2(middleware1(args))</code>;</li>
<li><code>compose(middleware2, middleware1)(originDispatch)</code> 返回<code>middleware2(middleware1(originDispatch))</code></li>
<li>将<code>middleware1(originDispatch)</code>当做一个整体,<code>middleware2(middleware1(originDispatch))</code>中的<code>middleware2</code>返回一个函数，等着接受<code>...args</code>;当<code>compose(middleware2, middleware1)(originDispatch)(&#39;redux&#39;, &#39;is&#39;, &#39;cool&#39;)</code>,<code>...args</code>为<code>(&#39;redux&#39;, &#39;is&#39;, &#39;cool&#39;)</code>。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/27/剖析node的Common-JS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/剖析node的Common-JS/" itemprop="url">剖析node的Common.JS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-27T20:11:16+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Javascript最开始是怎样实现模块化呢？"><a href="#Javascript最开始是怎样实现模块化呢？" class="headerlink" title="Javascript最开始是怎样实现模块化呢？"></a>Javascript最开始是怎样实现模块化呢？</h3><p>我们知道javascript最开始是面向过程的思维编程，随着代码越来越庞大、复杂，在这种实际遇到的问题中，大佬们逐渐把面向对象、模块化的思想用在javascript当中。</p>
<h4 id="一开始，我们是把不同功能写在不同函数当中"><a href="#一开始，我们是把不同功能写在不同函数当中" class="headerlink" title="一开始，我们是把不同功能写在不同函数当中"></a>一开始，我们是把不同功能写在不同函数当中</h4><pre><code>// 比如getCssAttr函数来获取Css属性，当我们需要获取Css属性的时候可以直接调用该方法
function getCssAttr(obj, attr) {
    if (obj.currentStyle) {
        return obj.currentStyle[attr];
    } else {
        return window.getComputedStyle(obj, null)[attr];
    }
}

// 比如toJSON函数能够把url的query转为JSON对象
function toJSON(str) {
  var obj = {}, allArr = [], splitArr = [];
  str = str.indexOf(&apos;?&apos;) &gt;= 0 ? str.substr(1) : str;
  allArr = str.split(&apos;&amp;&apos;);
  for (var i = 0; i &lt; allArr.length; i++) {
    splitArr = allArr[i].split(&apos;=&apos;);
    obj[splitArr[0]] = splitArr[1];
  }
  return obj;
}
</code></pre><p>这样getCssAttr函数和toJSON组成了模块，当需要使用的时候，直接调用即可，但是随着项目代码量越来越庞大和复杂，而且这种方式会对全局变量造成了污染。</p>
<h4 id="为了解决上面的问题，会想到把这些方法、变量放到对象中"><a href="#为了解决上面的问题，会想到把这些方法、变量放到对象中" class="headerlink" title="为了解决上面的问题，会想到把这些方法、变量放到对象中"></a>为了解决上面的问题，会想到把这些方法、变量放到对象中</h4><pre><code>let utils = new Object({
    getCssAttr:function(){...},
    toJSON:function(){...}
})
</code></pre><p>当需要调用相应函数时，我们通过对象调用即可，<code>utils.getCssAttr()</code>、<code>utils.toJSON()</code>，但是这样会存在一个问题，就是可以直接通过外部修改内部方法属性。</p>
<pre><code>utils.getCssAttr = null
</code></pre><h4 id="那么我们有办法让内部方法属性不被修改吗？"><a href="#那么我们有办法让内部方法属性不被修改吗？" class="headerlink" title="那么我们有办法让内部方法属性不被修改吗？"></a>那么我们有办法让内部方法属性不被修改吗？</h4><p>答案是可以的，我们可以通过闭包的方式，使私有成员不暴露在外部。</p>
<pre><code>let utils = (function(){
    let getCssAttr = function(){...}
    let toJSON = function(){...}
    return {
        getCssAttr,
        toJSON
    }
})()
</code></pre><p>这样的话，外部就无法改变内部的私有成员了。</p>
<hr>
<h2 id="CMD和AMD规范"><a href="#CMD和AMD规范" class="headerlink" title="CMD和AMD规范"></a>CMD和AMD规范</h2><p>试想一下，如果一个项目，所有轮子都自己造，在现在追求敏捷开发的环境下，我们有必要所有轮子都自己造吗？一些常用通用的功能，是否可以提取出来，供大家使用，提高开发效率？</p>
<p>正所谓，无规矩不成方圆，每个程序猿的代码风格肯定是有差异的，你写你的，我写我的，这样就很难流通了，但是如果大家都遵循一个规范编写代码，形成一个个模块，就显得非常重要了。</p>
<p>在这样的背景下，形成了两种规范，一种是以sea.js为代表的CMD规范，另外一种是以require.js为代表的AMD规范。</p>
<ul>
<li>CMD规范（Common Module Definition 通用模块定义）</li>
<li>AMD规范（Asynchronous Module Definition 异步模块定义）</li>
</ul>
<p>在node.js中是遵循commonJS规范的，在对模块的导入是同步的，为什么这样说？因为在服务器中，模块都是存在本地的，即使要导入模块，也只是耗费了从硬盘读取模块的时间，而且可控。</p>
<p>但是在浏览器中，模块是需要通过网络请求获取的，如果是同步获取的话，那么网络请求的时间没办法保证，会造成浏览器假死的，但是异步的话，是不会阻塞主线程，所以不管是CMD还是AMD，都是属于异步的，CMD和AMD都是属于异步加载模块，当所需要依赖的模块加载完毕后，才通过一个回调函数，写我们所需要的业务逻辑。</p>
<h4 id="CMD和AMD的异同"><a href="#CMD和AMD的异同" class="headerlink" title="CMD和AMD的异同"></a>CMD和AMD的异同</h4><ul>
<li>CMD是<code>延迟执行，依赖就近</code>，而AMD是<code>提前执行，依赖前置</code>（require2.0开始可以改成延迟执行），怎么理解呢？看看下面代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line">    var a = require(&apos;./a&apos;)</span><br><span class="line">    a.run()</span><br><span class="line">    </span><br><span class="line">    var b = require(&apos;./b&apos;)</span><br><span class="line">    b.eat()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// AMD</span><br><span class="line">define([&apos;./a&apos;,&apos;./b&apos;],function(a,b)&#123;</span><br><span class="line">    a.run()</span><br><span class="line">    b.eat()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CMD-AMD执行对比"><a href="#CMD-AMD执行对比" class="headerlink" title="CMD,AMD执行对比"></a>CMD,AMD执行对比</h4><table>
<thead>
<tr>
<th>—</th>
<th style="text-align:center">CMD</th>
<th style="text-align:right">AMD</th>
</tr>
</thead>
<tbody>
<tr>
<td> 执行回调函数的时机</td>
<td style="text-align:center">快</td>
<td style="text-align:right">慢</td>
</tr>
<tr>
<td> 执行回调函数内的业务</td>
<td style="text-align:center">慢</td>
<td style="text-align:right">快</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="node-js遵循的commonJs规范"><a href="#node-js遵循的commonJs规范" class="headerlink" title="node.js遵循的commonJs规范"></a>node.js遵循的commonJs规范</h2><h3 id="首先，我们来剖析一下commonJs的源码"><a href="#首先，我们来剖析一下commonJs的源码" class="headerlink" title="首先，我们来剖析一下commonJs的源码"></a>首先，我们来剖析一下commonJs的源码</h3><p>我们分别创建两个文件<code>useModule.js</code>、<code>module.js</code>，并且打上断点。<br><img src="/2018/10/27/剖析node的Common-JS/166abfe6e856dc15.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// useModule.js</span><br><span class="line">let utils = require(&apos;./module&apos;)</span><br><span class="line">utils = require(&apos;./module&apos;)</span><br><span class="line">utils.sayhello()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// module.js</span><br><span class="line">let utils = &#123;</span><br><span class="line">  sayhello:function()&#123;</span><br><span class="line">    console.log(&apos;hello swr&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = utils</span><br></pre></td></tr></table></figure></p>
<p>然后开始执行，我们首先会进入commonJs的源码了<br><img src="/2018/10/27/剖析node的Common-JS/166ac006849ff31e.webp" alt=""><br> 在最上面可以看出是一个闭包的形式<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(exports,require,module,__filename,__dirname))&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> ，这里可以看出<code>__dirname</code>和<code>__filename</code>并非是<code>global</code>上的属性，而是每个模块对应的路径。</p>
<p>而且我们在模块当中<code>this</code>并不是指向<code>global</code>的，而是指向<code>module.exports</code>，至于为什么会这样呢？下面会讲到。</p>
<p>在红框中，我们可以看到<code>require</code>函数，<code>exports.requireDepth</code>可以暂时不用管，是一个引用深度的变量，接下来我们往下看，<code>return mod.require(path)</code>，这里的<code>mod</code>就是每一个文件、模块，而里面都有一个<code>require</code>方法，接下来我们看看<code>mod.require</code>函数内部是怎么写的。<br><img src="/2018/10/27/剖析node的Common-JS/1.webp" alt=""><br>进来后，我们会看到2个<code>assert</code>断言，用来判断<code>path</code>参数是否传递了，<code>path</code>是否字符串类型等等。</p>
<p><code>return Module._load(path,this,false)</code>，<code>path</code>为我们传入的模块路径，this则是这个模块，false则不是主要模块，主要模块的意思是，如果a.js加载了b.js，那么a.js是主要模块，而b.js则是非主要模块。</p>
<p>接下来我们看看<code>Module._load</code>这个静态方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line"></span><br><span class="line">  //  计算绝对路径</span><br><span class="line">  var filename = Module._resolveFilename(request, parent);</span><br><span class="line"></span><br><span class="line">  //  第一步：如果有缓存，取出缓存</span><br><span class="line">  var cachedModule = Module._cache[filename];</span><br><span class="line">  if (cachedModule) &#123;</span><br><span class="line">    return cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 第二步：是否为内置模块</span><br><span class="line">  if (NativeModule.exists(filename)) &#123;</span><br><span class="line">    return NativeModule.require(filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 第三步：生成模块实例，存入缓存</span><br><span class="line">  var module = new Module(filename, parent);</span><br><span class="line">  Module._cache[filename] = module;</span><br><span class="line"></span><br><span class="line">  // 第四步：加载模块</span><br><span class="line">  try &#123;</span><br><span class="line">    module.load(filename);</span><br><span class="line">    hadException = false;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (hadException) &#123;</span><br><span class="line">      delete Module._cache[filename];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 第五步：输出模块的exports属性</span><br><span class="line">  return module.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/10/27/剖析node的Common-JS/2.webp" alt=""><br><img src="/2018/10/27/剖析node的Common-JS/3.webp" alt=""><br><code>var filename = Module._resolveFilename(request, parent, isMain)</code>，这里的目的是解析出一个绝对路径，我们可以进去看看<code>Module._resolveFilename</code>函数是怎么写的<br><img src="/2018/10/27/剖析node的Common-JS/4.webp" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Module._resolveFilename = function(request, parent) &#123;</span><br><span class="line"></span><br><span class="line"> // 第一步：如果是内置模块，不含路径返回</span><br><span class="line"> if (NativeModule.exists(request)) &#123;</span><br><span class="line">   return request;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 第二步：确定所有可能的路径</span><br><span class="line"> var resolvedModule = Module._resolveLookupPaths(request, parent);</span><br><span class="line"> var id = resolvedModule[0];</span><br><span class="line"> var paths = resolvedModule[1];</span><br><span class="line"></span><br><span class="line"> // 第三步：确定哪一个路径为真</span><br><span class="line"> var filename = Module._findPath(request, paths);</span><br><span class="line"> if (!filename) &#123;</span><br><span class="line">   var err = new Error(&quot;Cannot find module &apos;&quot; + request + &quot;&apos;&quot;);</span><br><span class="line">   err.code = &apos;MODULE_NOT_FOUND&apos;;</span><br><span class="line">   throw err;</span><br><span class="line"> &#125;</span><br><span class="line"> return filename;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，在 Module.resolveFilrename 方法内部，又调用了两个方法  Module.reqolveLookPaths()和 Module._findPath(),前者用来列出可能的路径，后者用来确认哪一个路径为真。<br>有了可能的路径以后，下面就是 Module._findPath()的源码，用来确定到底哪一个是正确路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Module._findPath = function(request, paths) &#123;</span><br><span class="line"></span><br><span class="line"> // 列出所有可能的后缀名：.js，.json, .node</span><br><span class="line"> var exts = Object.keys(Module._extensions);</span><br><span class="line"></span><br><span class="line"> // 如果是绝对路径，就不再搜索</span><br><span class="line"> if (request.charAt(0) === &apos;/&apos;) &#123;</span><br><span class="line">   paths = [&apos;&apos;];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 是否有后缀的目录斜杠</span><br><span class="line"> var trailingSlash = (request.slice(-1) === &apos;/&apos;);</span><br><span class="line"></span><br><span class="line"> // 第一步：如果当前路径已在缓存中，就直接返回缓存</span><br><span class="line"> var cacheKey = JSON.stringify(&#123;request: request, paths: paths&#125;);</span><br><span class="line"> if (Module._pathCache[cacheKey]) &#123;</span><br><span class="line">   return Module._pathCache[cacheKey];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 第二步：依次遍历所有路径</span><br><span class="line"> for (var i = 0, PL = paths.length; i &lt; PL; i++) &#123;</span><br><span class="line">   var basePath = path.resolve(paths[i], request);</span><br><span class="line">   var filename;</span><br><span class="line"></span><br><span class="line">   if (!trailingSlash) &#123;</span><br><span class="line">     // 第三步：是否存在该模块文件</span><br><span class="line">     filename = tryFile(basePath);</span><br><span class="line"></span><br><span class="line">     if (!filename &amp;&amp; !trailingSlash) &#123;</span><br><span class="line">       // 第四步：该模块文件加上后缀名，是否存在</span><br><span class="line">       filename = tryExtensions(basePath, exts);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 第五步：目录中是否存在 package.json </span><br><span class="line">   if (!filename) &#123;</span><br><span class="line">     filename = tryPackage(basePath, exts);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!filename) &#123;</span><br><span class="line">     // 第六步：是否存在目录名 + index + 后缀名 </span><br><span class="line">     filename = tryExtensions(path.resolve(basePath, &apos;index&apos;), exts);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 第七步：将找到的文件路径存入返回缓存，然后返回</span><br><span class="line">   if (filename) &#123;</span><br><span class="line">     Module._pathCache[cacheKey] = filename;</span><br><span class="line">     return filename;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 第八步：没有找到文件，返回false </span><br><span class="line"> return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>有时在项目代码中，需要调用模块的绝对路径，那么除了 module.filename ，Node 还提供一个 require.resolve 方法，供外部调用，用于从模块名取到绝对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require.resolve = function(request) &#123;</span><br><span class="line">  return Module._resolveFilename(request, self);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">require.resolve(&apos;a.js&apos;)</span><br><span class="line">// 返回  /Users/danlan/workspace/node-stu/ree/a.js</span><br></pre></td></tr></table></figure></p>
<p><code>Module._resolveFilename</code>函数也没什么好说的，就是判断各种情况，然后解析出一个绝对路径出来，我们跳出这个函数，回到<code>Module._load</code>中.<br>然后我们看到<code>var cachedModule = Module._cache[filename]</code>，这是我们加载模块的缓存机制，就是说我们加载过一次模块后，会缓存到Module._cache这个对象中，并且是以<code>filename</code>作为键名，因为路径是唯一的，所以以路径作为唯一标识，如果已经缓存过，则会直接返回这个缓存过的模块。</p>
<p><code>NativeModule.nonInternalExists(filename)</code>判断是否原生模块，是的话则直接返回模块。</p>
<p>经过上面两个判断，基本可以判定这个模块没被加载过，那么接下来看到<code>var module = new Module(filename, parent)</code>，创建了一个模块，我们看看<code>Module</code>这个构造函数有什么内容<br><img src="/2018/10/27/剖析node的Common-JS/5.webp" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.id 模块的识别符，通常是带有绝对路径的模块文件名。</span><br><span class="line">module.filename 模块的文件名，带有绝对路径。</span><br><span class="line">module.loaded 返回一个布尔值，表示模块是否已经完成加载。</span><br><span class="line">module.parent 返回一个对象，表示调用该模块的模块。</span><br><span class="line">module.children 返回一个数组，表示该模块要用到的其他模块。</span><br><span class="line">module.exports 表示模块对外输出的值。</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>下面是一个示例文件，最后一行输出module变量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var jquery = require(&apos;jquery&apos;);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行这个文件，命令行会输出如下信息。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; id: &apos;.&apos;,</span><br><span class="line">  exports: &#123; &apos;$&apos;: [Function] &#125;,</span><br><span class="line">  parent: null,</span><br><span class="line">  filename: &apos;/path/to/example.js&apos;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children:</span><br><span class="line">   [ &#123; id: &apos;/path/to/node_modules/jquery/dist/jquery.js&apos;,</span><br><span class="line">       exports: [Function],</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: &apos;/path/to/node_modules/jquery/dist/jquery.js&apos;,</span><br><span class="line">       loaded: true,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [Object] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ &apos;/home/user/deleted/node_modules&apos;,</span><br><span class="line">     &apos;/home/user/node_modules&apos;,</span><br><span class="line">     &apos;/home/node_modules&apos;,</span><br><span class="line">     &apos;/node_modules&apos; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里的<code>id</code>，实际上就是<code>filename</code>唯一路径，另外一个很重要的是<code>this.exports</code>，也就是将来用于暴露模块的。<br>我们接着往下看，在创建一个实例后，接下来把这个实例存在缓存当中，<code>Module._cache[filename] = module</code><br>然后执行<code>tryModuleLoad(module, filename)</code>，这个函数非常重要，是用来加载模块的，我们看看是怎么写的<br><img src="/2018/10/27/剖析node的Common-JS/6.webp" alt=""><br> 这里有个<code>module.load</code>，我们再往里面看看是怎么写的<br><img src="/2018/10/27/剖析node的Common-JS/7.webp" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.load = function (filename) &#123;</span><br><span class="line">    var extension = path.extname(filename)  || &apos;js&apos;</span><br><span class="line">    if(!Module._extensions[extensions]) extension = &apos;.js&apos;</span><br><span class="line">    Module._extensions[extension](this, filename)</span><br><span class="line">    this.loaded = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 兜兜转转，终于来到最核心的地方了<br><code>this.paths = Module._nodeModulePaths(path.dirname(filename))</code>，我们知道，我们安装npm包时，node会由里到外一层层找<code>node_modules</code>文件夹，而这一步，则是路径一层层丢进数组里，我们可以看看<code>this.paths</code>的数组</p>
<h4 id="CommonJS-模块查找规范"><a href="#CommonJS-模块查找规范" class="headerlink" title="CommonJS 模块查找规范"></a>CommonJS 模块查找规范</h4><p><img src="/2018/10/27/剖析node的Common-JS/13.svg" alt=""><br><img src="/2018/10/27/剖析node的Common-JS/8.webp" alt=""></p>
<blockquote>
<p>新建一个b.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = require(&apos;./a.js&apos;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行一下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module.id:  /Users/danlan/workspace/node-stu/ree/a.js</span><br><span class="line">module.exports:  &#123;&#125;</span><br><span class="line">module.parent:  Module &#123;</span><br><span class="line">  id: &apos;.&apos;,</span><br><span class="line">  exports: &#123;&#125;,</span><br><span class="line">  parent: null,</span><br><span class="line">  filename: &apos;/Users/danlan/workspace/node-stu/ree/b.js&apos;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children:</span><br><span class="line">   [ Module &#123;</span><br><span class="line">       id: &apos;/Users/danlan/workspace/node-stu/ree/a.js&apos;,</span><br><span class="line">       exports: &#123;&#125;,</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: &apos;/Users/danlan/workspace/node-stu/ree/a.js&apos;,</span><br><span class="line">       loaded: false,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [Array] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ &apos;/Users/danlan/workspace/node-stu/ree/node_modules&apos;,</span><br><span class="line">     &apos;/Users/danlan/workspace/node-stu/node_modules&apos;,</span><br><span class="line">     &apos;/Users/danlan/workspace/node_modules&apos;,</span><br><span class="line">     &apos;/Users/danlan/node_modules&apos;,</span><br><span class="line">     &apos;/Users/node_modules&apos;,</span><br><span class="line">     &apos;/node_modules&apos; ] &#125;</span><br><span class="line">module.filename:  /Users/danlan/workspace/node-stu/ree/a.js</span><br><span class="line">module.loaded:  false</span><br><span class="line">module.children:  []</span><br><span class="line">module.paths:  [ &apos;/Users/danlan/workspace/node-stu/ree/node_modules&apos;,</span><br><span class="line">  &apos;/Users/danlan/workspace/node-stu/node_modules&apos;,</span><br><span class="line">  &apos;/Users/danlan/workspace/node_modules&apos;,</span><br><span class="line">  &apos;/Users/danlan/node_modules&apos;,</span><br><span class="line">  &apos;/Users/node_modules&apos;,</span><br><span class="line">  &apos;/node_modules&apos; ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/node/bar.js</span><br><span class="line">/home/user/projects/node_modules/bar.js</span><br><span class="line">/home/user/node_modules/bar.js</span><br><span class="line">/home/node_modules/bar.js</span><br><span class="line">/node_modules/bar.js</span><br></pre></td></tr></table></figure>
<p>这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</p>
<ul>
<li>如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</li>
<li><font color="#ff0000">如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</font></li>
<li>如果想得到require命令加载的确切文件名，使用require.resolve()方法。</li>
</ul>
<p>目录的加载规则</p>
<blockquote>
<p>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; </span><br><span class="line">  &quot;name&quot; : &quot;some-library&quot;,</span><br><span class="line">  &quot;main&quot; : &quot;./lib/some-library.js&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 继续往下看，<code>var extension = path.extname(filename) || &#39;.js&#39;</code>是获取后缀名，如果没有后缀名的话，暂时默认添加一个<code>.js</code>后缀名。<br>继续往下看，<code>if (!Module._extensions[extension]) extension = &#39;.js&#39;</code>是判断<code>Module._extensions</code>这个对象，是否有这个属性，如果没有的话，则让这个后缀名为<code>.js</code><br>继续往下看，<code>Module._extensions[extension](this, filename)</code>，根据后缀名，执行对应的函数，那么我们看一下<code>Module._extensions</code>对象有哪几个函数<br><img src="/2018/10/27/剖析node的Common-JS/9.webp" alt=""><br> 从这里我们可以看到，<code>Module._extensions</code>中有3个函数，分别是<code>.js</code>、<code>.json</code>、<code>.node</code>函数，意思是根据不同的后缀名，执行不同的函数，来解析不同的内容，我们可以留意到读取文件都是用<code>fs.readFileSync</code>同步读取，因为这些文件都是保存在服务器硬盘中，读取这些文件耗费时间非常短，所以采用了同步而不是异步<br>其中<code>.json</code>最为简单，读取出文件后，再通过<code>JSON.parse</code>把字符串转化为<code>JSON</code>对象，然后把结果赋值给<code>module.exports</code><br>接下来看看<code>.js</code>，也是一样先读取出文件内容，然后通过<code>module._compile</code>这个函数来解析<code>.js</code>的内容，我们看一下<code>module._compile</code>函数怎么写的<br> <img src="/2018/10/27/剖析node的Common-JS/10.webp" alt=""><br> <img src="/2018/10/27/剖析node的Common-JS/11.webp" alt=""><br> <code>var wrapper = Module.wrap(content)</code>这里对<code>.js</code>文件的内容进行了一层处理，我们可以看看<code>Module.wrap</code>怎么写的<br>  <img src="/2018/10/27/剖析node的Common-JS/12.webp" alt=""><br> 在这里可以看出，<code>NativeModule.wrapper</code>数组中有两个数组成员，是不是看起来似曾相识？没错，这就是闭包的形式，而<code>Module.wrap</code>中，是直接把js文件的内容，和这个闭包拼接成一段字符串，对，就是在这里，把一个个模块，套一层闭包！实际上拼接出来的是</p>
<pre><code>// 字符串
&quot;(function(exports,require,module,__filename,__dirname){
    let utils = {
      sayhello:function(){
        console.log(&apos;hello swr&apos;)
      }
    }
})&quot;
</code></pre><p>我们跳出来，回到<code>Module.prototype._compile</code>看看，接下来看到<code>var compiledWrapper = vm.runInThisContext(wrapper,{...})</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//虚拟机，帮我们创建一个黑箱执行代码，防止变量污染</span><br><span class="line">const vm = require(&quot;vm&quot;);</span><br></pre></td></tr></table></figure></p>
<p>在nodejs中是通过vm这个虚拟机，执行字符串，而且这样的好处是使内部完全是封闭的，不会被外在变量污染，而在前端的字符串模板则是通过<code>new Function()</code>来执行字符串，达到不被外在变量污染</p>
<p>继续往下看，<code>result = compiledWrapper.call(this.exports, this.exports, require, this,filename, dirname)</code>，其中<code>compiledWrapper</code>就是我们通过vm虚拟机执行的字符串后返回的闭包，而且通过<code>call</code>来把这个模块中的<code>this</code>指向更改为当前模块，而不是全局的<code>global</code>，这里就是为什么我们在模块当中打印<code>this</code>时，指向的是当前的<code>module.exports</code>而不是<code>global</code>，然后后面依次把相应的参数传递过去</p>
<p>最终一层层跳出后<code>Module._load</code>中，最后是<code>return module.exports</code>，也就是说我们通过<code>require</code>导入的模块，取的是<code>module.exports</code></p>
<h4 id="通过剖析commonJs源码，我们收获了什么？"><a href="#通过剖析commonJs源码，我们收获了什么？" class="headerlink" title="通过剖析commonJs源码，我们收获了什么？"></a>通过剖析commonJs源码，我们收获了什么？</h4><ul>
<li><p>懂得了模块加载的整个流程</p>
<ul>
<li>第一步：解析出一个绝对路径,如果是核心模块，比如fs，就直接返回模块</li>
<li>第二步：如文件没添加后缀，则添加<code>.js</code>、<code>.json</code>、<code>.node</code>作为后缀，然后通过<code>fs.existsSync</code>来判断文件是否存在<ul>
<li>.js 解析为JavaScript 文本文件</li>
<li>.json解析JSON对象</li>
<li>.node解析为二进制插件模块</li>
</ul>
</li>
<li>第三步：到缓存中找该模块是否被加载过(如果是带有路径的如/,./等等，则拼接出一个绝对路径，然后先读取缓存require.cache再读取文件。如果没有加后缀，则自动加后缀然后一一识别。)</li>
<li>第四步：new一个模块实例</li>
<li>第五步：把模块存到缓存当中(首次加载后的模块会缓存在require.cache之中，所以多次加载require，得到的对象是同一个。)</li>
<li>第六步：根据后缀名，加载这个模块<ul>
<li>在执行模块代码的时候，会将模块包装成如下模式，以便于作用域在模块范围之内。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   (function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">   // 模块的代码实际上在这里</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>知道如何实现由里到外一层层查找<code>node_modules</code></p>
</li>
<li>知道针对<code>.js</code>和<code>.json</code>是怎么解析的<ul>
<li><code>.js</code>是通过拼接字符串，形成一个闭包形式的字符串</li>
<li><code>.json</code>则是通过<code>JSON.parse</code>转为<code>JSON</code>对象</li>
</ul>
</li>
<li><p>知道如何执行字符串，并且不受外部变量污染</p>
<ul>
<li><p>nodejs中通过vm虚拟机来执行字符串</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   let vm=require(&quot;vm&quot;)</span><br><span class="line">   let a=&apos;console.log(&quot;a&quot;)&apos;</span><br><span class="line">vm.runInThisContext(a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>前端则是通过<code>new Function()</code>来执行字符串</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x+y&apos;); </span><br><span class="line">      f( 3, 4 )</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>知道为什么模块中的<code>this</code>指向的是<code>this.exports</code>而不是<code>global</code></p>
<ul>
<li>通过<code>call</code>把指针指向了<code>this.exports</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="接下来，我们手写一个简陋版的commonJs源码"><a href="#接下来，我们手写一个简陋版的commonJs源码" class="headerlink" title="接下来，我们手写一个简陋版的commonJs源码"></a>接下来，我们手写一个简陋版的commonJs源码</h3><p>commonJs其实在加载模块的时候，做了以下几个步骤</p>
<ul>
<li>第一步：解析出一个绝对路径</li>
<li>第二步：如文件没添加后缀，则添加<code>.js</code>、<code>.json</code>、<code>.node</code>作为后缀，然后通过<code>fs.existsSync</code>来判断文件是否存在</li>
<li>第三步：到缓存中找该模块是否被加载过</li>
<li>第四步：new一个模块实例</li>
<li>第五步：把模块存到缓存当中</li>
<li>第六步：根据后缀名，加载这个模块</li>
</ul>
<p>那么我们根据这几个步骤，来手写一下源码~</p>
<pre><code>// module.js
let utils = {
  sayhello: function () {
    console.log(&apos;hello swr&apos;)
  }
}
console.log(&apos;执行了&apos;)
module.exports = utils
</code></pre><p>首先写出解析一个绝对路径以及如文件没添加后缀，则添加<code>.js</code>、<code>.json</code>作为后缀，然后通过<code>fs.existsSync</code>来判断文件是否存在（ .. 每个步骤我都会标识1、2、3…</p>
<pre><code>// useModule.js
// 1.引入核心模块
let fs = require(&apos;fs&apos;)
let path = require(&apos;path&apos;)

// 3.声明一个Module构造函数
function Module(id) {
  this.id = id 
  this.exports = {} // 将来暴露模块的内容
}

// 8.支持的后缀名类型
Module._extensions = {
  &quot;.js&quot;:function(){},
  &quot;.json&quot;:function(){}
}

// 5.解析出绝对路径，_resolveFilename是Module的静态方法
Module._resolveFilename = function (relativePath) {
  // 6.返回一个路径
  let p = path.resolve(__dirname,relativePath)
  // 7.该路径是否存在文件，如果存在则直接返回
  //   这种情况主要考虑用户自行添加了后缀名
  //   如&apos;./module.js&apos;let exists = fs.existsSync(p)
  if(exists) return p
  // 9.如果relativePath传入的如&apos;./module&apos;，没有添加后缀
  //   那么我们给它添加后缀，并且判断添加后缀后是否存在该文件
  let keys = Object.keys(Module._extensions)
  let r = falsefor(let val of keys){ // 这里用for循环，是当找到文件后可以直接break跳出循环
    let realPath = p + val // 拼接后缀
    let exists = fs.existsSync(realPath)
    if(exists){
      r = realPath
      break
    }
  }
  if(!r){ // 如果找不到文件，则抛出错误
    throw new Error(&apos;file not exists&apos;)
  }
  return r
}

// 2.为了不与require冲突，这个函数命名为req
//   传入一个参数p 路径
function req(p) {
  // 10.因为Module._resolveFilename存在找不到文件
  //    找不到文件时会抛出错误，所以我们这里捕获错误
  try { 
    // 4.通过Module._resolveFilename解析出一个绝对路径
    let filename = Module._resolveFilename(p)
  } catch (e) {
    console.log(e)
  }
}

// 导入模块，并且导入两次，主要是校验是否加载过一次后
// 在有缓存的情况下，会不会直接返回缓存的模块
// 为此特意在module.js中添加了console.log(&quot;执行了&quot;)
// 来看打印了几次
let utils = req(&apos;./module&apos;)
utils = req(&apos;./module&apos;)
utils.sayhello()
</code></pre><p>然后到缓存中找该模块是否被加载过，如果没有加载过则new一个模块实例，把模块存到缓存当中，最后根据后缀名，加载这个模块（ .. 每个步骤我都会标识1、2、3…</p>
<pre><code>// useModule.js
// 1.引入核心模块
let fs = require(&apos;fs&apos;)
let path = require(&apos;path&apos;)

// 3.声明一个Module构造函数
function Module(id) {
  this.id = id 
  this.exports = {} // 将来暴露模块的内容
}

// * 21.因为处理js文件时，需要包裹一个闭包，我们写一个数组
Module.wrapper = [
  &quot;(function(exports,require,module){&quot;,
  &quot;\n})&quot;
]

// * 22.通过Module.wrap包裹成闭包的字符串形式
Module.wrap = function(script){
  return Module.wrapper[0] + script + Module.wrapper[1]
}

// 8.支持的后缀名类型
Module._extensions = {
  &quot;.js&quot;:function(module){ // * 20.其次看看js是如何处理的
    let str = fs.readFileSync(module.id,&apos;utf8&apos;)
    // * 23.通过Module.wrap函数把内容包裹成闭包
    let fnStr = Module.wrap(str)
    // * 24.引入vm虚拟机来执行字符串
    let vm = require(&apos;vm&apos;)
    let fn = vm.runInThisContext(fnStr)
    // 让产生的fn执行，并且把this指向更改为当前的module.exports
    fn.call(this.exports,this.exports,req,module)
  },
  &quot;.json&quot;:function(module){ // * 18.首先看看json是如何处理的
    let str = fs.readFileSync(module.id,&apos;utf8&apos;)
    // * 19.通过JSON.parse处理，并且赋值给module.exports
    let json = JSON.parse(str)
    module.exports = json
  }
}

// * 15.加载
Module.prototype._load = function(filename){
  // * 16.获取后缀名
  let extension = path.extname(filename)
  // * 17.根据不同后缀名 执行不同的方法
  Module._extensions[extension](this)
}

// 5.解析出绝对路径，_resolveFilename是Module的静态方法
Module._resolveFilename = function (relativePath) {
  // 6.返回一个路径
  let p = path.resolve(__dirname,relativePath)
  // 7.该路径是否存在文件，如果存在则直接返回
  //   这种情况主要考虑用户自行添加了后缀名
  //   如&apos;./module.js&apos;let exists = fs.existsSync(p)
  if(exists) return p
  // 9.如果relativePath传入的如&apos;./module&apos;，没有添加后缀
  //   那么我们给它添加后缀，并且判断添加后缀后是否存在该文件
  let keys = Object.keys(Module._extensions)
  let r = falsefor(let val of keys){ // 这里用for循环，是当找到文件后可以直接break跳出循环
    let realPath = p + val // 拼接后缀
    let exists = fs.existsSync(realPath)
    if(exists){
      r = realPath
      break
    }
  }
  if(!r){ // 如果找不到文件，则抛出错误
    throw new Error(&apos;file not exists&apos;)
  }
  return r
}

// * 11.缓存对象
Module._cache = {}

// 2.为了不与require冲突，这个函数命名为req
//   传入一个参数p 路径
function req(p) {
  // 10.因为Module._resolveFilename存在找不到文件
  //    找不到文件时会抛出错误，所以我们这里捕获错误
  try { 
    // 4.通过Module._resolveFilename解析出一个绝对路径
    let filename = Module._resolveFilename(p)
    // * 12.判断是否有缓存，如果有缓存的话，则直接返回缓存
    if(Module._cache[filename]){
      // * 因为实例的exports才是最终暴露出的内容
      return Module._cache[filename].exports
    }
    // * 13.new一个Module实例
    let module = new Module(filename)
    // * 14.加载这个模块
    module._load(filename)
    // * 25.把module存到缓存
    Module._cache[filename] = module
    // * 26.返回module.exprots
    return module.exports
  } catch (e) {
    console.log(e)
  }
}

// 导入模块，并且导入两次，主要是校验是否加载过一次后
// 在有缓存的情况下，会不会直接返回缓存的模块
// 为此特意在module.js中添加了console.log(&quot;执行了&quot;)
// 来看打印了几次
let utils = req(&apos;./module&apos;)
utils = req(&apos;./module&apos;)
utils.sayhello()
</code></pre><p>这样我们就完成了一个简陋版的commonJs，而且我们多次导入这个模块，只会打印出一次<code>执行了</code>，说明了只要缓存中有的，就直接返回，而不是重新加载这个模块<br>这里建议大家一个步骤一个步骤去理解，尝试敲一下代码，这样感悟会更加深</p>
<h4 id="那么为什么exports-xxx-却失效了呢？"><a href="#那么为什么exports-xxx-却失效了呢？" class="headerlink" title="那么为什么exports = xxx 却失效了呢？"></a>那么为什么exports = xxx 却失效了呢？</h4><pre><code>// 从上面源码我们可以看出，实际上
// exports = module.exports = {}
// 但是当我们exports = {name:&quot;CommonJS&quot;}时，
// require出来却获取不到这个对象，这是因为我们在上面源码中，
// req函数（即require）内部return出的是module.exports，而不是exports，
// 当我们exports = { name:&quot;CommonJS&quot; }时，实际上这个exports指向了一个新的对象，
// 而不是module.exports
// 那么我们的exports是不是多余的呢？肯定不是多余的，我们可以这样写
exports.name = &quot;CommonJS&quot; 
// 这样写没有改变exports的指向，而是在exports指向的module.exports对象上新增了属性

// 那么什么时候用exports，什么时候用module.exports呢？
// 如果导出的东西是一个，那么可以用module.exports，如果导出多个属性可以用exports，
// 一般情况下是用module.exports

// 还有一种方式，就是把属性挂载到global上供全局访问，不过不推荐。
</code></pre><h3 id="CommonJS模块总结"><a href="#CommonJS模块总结" class="headerlink" title="CommonJS模块总结"></a>CommonJS模块总结</h3><p><img src="/2018/10/27/剖析node的Common-JS/14.png" alt=""><br>CommonJS模块只能运行再支持此规范的环境之中，nodejs是基于CommonJS规范开发的，因此可以很完美地运行CommonJS模块，然后nodejs不支持ES6的模块规范，所以nodejs的服务器开发大家一般使用CommonJS规范来写。<br>CommonJS模块导入用require，导出用module.exports。导出的对象需注意，如果是静态值，而且非常量，后期可能会有所改动的，请使用函数动态获取，否则无法获取修改值。导入的参数，是可以随意改动的，所以大家使用时要小心。</p>
<h3 id="开发者需要了解的nodejs中require的机制"><a href="#开发者需要了解的nodejs中require的机制" class="headerlink" title="开发者需要了解的nodejs中require的机制"></a><a href="https://juejin.im/post/5bdea6b1518825170f50c485" target="_blank" rel="noopener">开发者需要了解的nodejs中require的机制</a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/26/理解-HTTPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/26/理解-HTTPS/" itemprop="url">理解 HTTPS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-26T17:33:47+08:00">
                2018-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><p>http2 的前身是由 google 领导开发的 SPDY，后来 google 把整个成果交给 IETF，IETF 把 SPDY 标准化之后变成 http2。google 也很大方的废弃掉 SPDY，转向支持 http2。http2 是完全兼容 http/1.x 的，在此基础上添加了 4 个主要新特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二进制分帧</span><br><span class="line">头部压缩</span><br><span class="line">服务端推送</span><br><span class="line">多路复用</span><br><span class="line">优化手段</span><br></pre></td></tr></table></figure></p>
<p><a href="https://juejin.im/post/5aaccf8f51882555784dbabc" target="_blank" rel="noopener">http2 简介</a></p>
<h3 id="存在即合理"><a href="#存在即合理" class="headerlink" title="存在即合理"></a>存在即合理</h3><p><font color="#ff0000">http是非常常见的应用层协议，是超文本传输协议的简称，其传输的内容都是明文的。</font> 在这个混乱的世界，明文传输信息想想就可怕，网络“小混混”的手段远比我们这些凡人高明得多，他们有一万种方式劫持，篡改我们的数据。对于一个网站或者服务，如果你给你的用户两个选择：</p>
<ul>
<li>通讯数据明文传输，速度快；</li>
<li>通讯数据加密传输，但是速度可能会稍微慢一点.<br>我想，只要脑袋没有长歪的用户都宁愿牺牲一点速度去换取数据传输的安全。</li>
</ul>
<p>这样，https的存在就具备了合理性，https中的s表示SSL或者TLS，就是在原http的基础上加上一层用于<font color="#ff0000">数据加密、解密、身份认证</font>的安全层。</p>
<h3 id="HTTP协议的缺点"><a href="#HTTP协议的缺点" class="headerlink" title="HTTP协议的缺点"></a>HTTP协议的缺点</h3><ul>
<li>通信使用明文；</li>
<li>不验证通信方的身份；</li>
<li>无法验证报文的完整性；</li>
</ul>
<p><strong>通信使用明文:</strong> 通信使用明文意味着安全性大大降低，当通信过程被窃听后，无需花费额外的投入就可看到传输的数据。例如使用抓包工具，无需任何配置就可查看任何使用HTTP协议的通信数据；<br><strong>不验证通信方身份 :</strong>不验证通信方的身份，将导致通信过程被窃听后，可能会遭遇伪装，例如使用抓包工具抓取数据后，就可按照数据包的格式构造HTTP请求；<br><strong>无法验证报文的完整性:</strong>不验证报文的完整性，数据在传输过程中就可能被篡改，本来想看喜洋洋呢，结果数据在传输过程中被换成了光头强。</p>
<p>为解决了HTTP的以上问题，HTTPS协议就诞生了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Https = Http + 加密 + 认证 + 完整性验证</span><br><span class="line">        ||</span><br><span class="line">Https = Http + SSL</span><br><span class="line">        ||</span><br><span class="line">HTTPS=数据加密+网站认证+完整性验证+HTTP</span><br></pre></td></tr></table></figure></p>
<h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><ul>
<li>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</li>
<li>HTTP 的端口号是 80，HTTPS 是 443</li>
<li>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费</li>
<li>HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li>
</ul>
<h3 id="HTTPS主要缺点："><a href="#HTTPS主要缺点：" class="headerlink" title="HTTPS主要缺点："></a>HTTPS主要缺点：</h3><ul>
<li>网络耗时（比HTTP多了交互次数）。</li>
<li>加解密耗时。</li>
<li>比HTTP慢几百毫秒以上，页面加载时间增加了50%，增加10%到20%的耗电</li>
</ul>
<h3 id="HTTPS工作流程："><a href="#HTTPS工作流程：" class="headerlink" title="HTTPS工作流程："></a>HTTPS工作流程：</h3><p><img src="/2018/10/26/理解-HTTPS/20170113193549689.png" alt=""><br>1.客户端向服务器发送请求，并告诉服务器支持的算法列表；<br>2.服务器选择一种算法，并将自己的证书返回给客户端，证书包含服务器域名和公钥等信息；<br>3.客户端得到证书后进行验证，验证通过的话就生成一个随机值，并用证书中的公钥进行加密<br>4.传递加密信息，目的就是让服务器得到这个随机值，以后客户端与服务器的通信就可以通过这个随机值来进行加密解密；<br>5.服务器用自己的私钥解密客户端传过来的随机值，然后把内容进行对称加密，即将信息和私钥通过加密算法混在一起，这样除非知道私钥，不然无法获取到内容，而客户端与服务器都知道这个私钥，所以只要加密算法够强大，私钥够复杂，数据就很安全了；<br>6.将加密后的信息发给客户端，客户端还原信息<br>7.客户端用之前生成的私钥解密服务器发过来的信息，便获取到了解密后的内容；</p>
<p>那么加密的信息通道又加密了哪些信息呢？</p>
<p>签发证书的 CA 中心会发布一种权威性的电子文档——数字证书，它可以通过加密技术（对称加密与非对称加密）对我们在网上传输的信息进行加密，比如我在 Pornhub 上输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：cbssfaw</span><br><span class="line">密码：123djaosid</span><br></pre></td></tr></table></figure></p>
<p>可是这个数据被黑客拦截盗窃了，那么加密后，黑客得到的数据可能就是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：çµø…≤¥ƒ∂ø†®∂˙∆¬</span><br><span class="line">密码：∆ø¥§®†ƒ©®†©˚¬</span><br></pre></td></tr></table></figure></p>
<hr>
<p>想要理解 HTTPS 加密。需要理解几个概念：</p>
<ul>
<li>对称加密算法</li>
<li>非对称加密算法</li>
<li>CA(Certificate Authority)</li>
<li>数字证书</li>
<li>摘要算法</li>
</ul>
<blockquote>
<p>常用的加密方式分为两种：</p>
</blockquote>
<ul>
<li>对称加密：<strong> <font color="#dd0000">加密和解密使用的是相同的密钥。</font></strong></li>
<li>非对称加密：<strong> <font color="#dd0000">加密和解密使用的不是相同的密钥，而是一对密钥对，分别称为公钥和私钥。 </font></strong></li>
</ul>
<blockquote>
<p>HTTPS 用了哪种加密方法？</p>
</blockquote>
<p>在 HTTPS 中，对称加密和非对称加密都用到了。非对称加密可以在不安全的信道上传递秘密内容，但是由于通常使用的非对称加密方法相较于对称加密算法慢很多，因此在 HTTPS 中仅使用非对称加密算法交换对称密钥，交换密钥之后的通信内容均使用对称加密算法加密和解密，这样既可以保证密钥的安全也可以保证内容的加解密速度，这对于移动端设备来说至关重要。</p>
<p>现在的问题是，如何在实现 HTTP 协议的情况下，对传输的信息进行加密解密？最开始使用到的是最简单的对称加密算法。 </p>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密算法非常简单，只要加密方和解密方都拥有同一密钥（可为128，192，256 bit 大小的密钥，密钥越长，加密解密时间越长，解密难度也越高），即可完成加密解密过程，且假设无法强制对加密过的明文进行解密。</p>
<p><strong> 问题：对于需要传递加密信息的双方而言，对称加密算法用于加密解密没有什么问题，但是密钥的传输就成了另外一个问题。因为密钥也需要传输才能使双方通信，密钥明文传输出去，被人轻易截取，就能利用密钥破解加密的密文。 </strong></p>
<p>所以引出了下面的非对称加密算法来传输密钥。</p>
<h3 id="公开密钥加密-Public-Key-Cryptography-的非对称加密算法"><a href="#公开密钥加密-Public-Key-Cryptography-的非对称加密算法" class="headerlink" title="公开密钥加密(Public-Key Cryptography)的非对称加密算法"></a>公开密钥加密(Public-Key Cryptography)的非对称加密算法</h3><p>对于使用最广泛的非对称加密算法——RSA，RSA 算法基于一个简单的数论理论：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p>
<p>RSA 算法得出了下面的规则：通讯两方 A, B 分别都有各自的一套公钥和私钥。同一套公钥私钥当中，公钥的加密需要私钥才能解密，私钥的加密需要公钥才能解密。</p>
<p>假设 A 把自己的公钥公开出去，B 得到了 A 的公钥，然后 B 用 A 的公钥加密了明文，传给 A，A 用私钥解密，即可获得明文。所以，过程中公开的信息任何第三方得到都不可以破解 A 和 B 要传递的信息。有了这个算法之后，对称加密算法所用到的密钥传输安全性就没问题了。但是因为加密解密过程时间比较长，非对称加密算法不适合应用于数据量大的信息传递，只适用于密钥的传递。（这个问题解释了对于数字签名的摘要算法的必要性）</p>
<h4 id="问题：虽然-RSA-算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是中间人攻击。"><a href="#问题：虽然-RSA-算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是中间人攻击。" class="headerlink" title="问题：虽然 RSA 算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是中间人攻击。"></a>问题：虽然 RSA 算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是<strong>中间人攻击</strong>。</h4><p>在用非对称加密算法传递密钥的过程中，因为公钥都是公开的，并没有任何东西可以认证这个公钥是 A 的还是 B 的。现在出现了中间人 M，M 采取某种手段在 A 和 B 的通讯过程成为中间人。在 B 想要得到 A 的公钥的时候，M 向 B 谎称自己的这个公钥是 A 的公钥，B 拿到用 M 的公钥加密信息后，传出 M 手中，然后 M 拿加密过的信息，然后用自己的私钥把这个信息解密，得到明文。既然已经知道了明文，还是用 A 的公钥加密这个信息，继续给 A，这样 A 还是以为这个信息是安全的，继续用私钥解开。而在这个过程中，M 既获得了信息，又没有让 A，B 双方知道。至于这个 M 是怎么欺骗 A，B 的，又是另外一个安全的问题。总之，假如 M 只要让 B 相信这个公钥是 A 的，就可以作中间人攻击。</p>
<p>假如上面的 A 是服务器，B 是用户，那么中间人就很容易获取和修改 A，B 需要传输的信息。所以为了让 M 不再得逞，出现一个具有公信力的第三方——CA。</p>
<h3 id="CA-Certificate-Authority-第三方认证机构"><a href="#CA-Certificate-Authority-第三方认证机构" class="headerlink" title="CA(Certificate Authority) 第三方认证机构"></a>CA(Certificate Authority) 第三方认证机构</h3><p>简单来说，CA 要做的就是，让 B 相信拿到的 A 的公钥真正属于 A，而不是其他中间人 M 伪造。</p>
<p>而在 CA 在做这件事的过程中如何才能让 B 认证这个公钥是 A 的呢？</p>
<p>这里需要另外一个概念：数字证书。</p>
<p>普通证书产生的过程就是：将个人提交的信息进行第三方具有权威性部门的认证，然后第三方权威部门确认个人信息<strong>合法无误</strong>后在自己的系统中登记，再把认证证书盖章签名给到个人手上，然后个人就可以用证书从事各类证明活动。现实世界中的做法是在个人提交的信息上盖章，例如4，6级的证书认证。假设你的成绩申请无误而合法，教育局就会将你的成绩记录，然后给你一张盖过章的证书。</p>
<p>数字证书同理。不过，与现实不一样，在互联网上完成一个完整的验证过程，需要兼顾到很多过程中的纰漏。</p>
<p>例如：</p>
<h4 id="问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？"><a href="#问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？" class="headerlink" title="问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？"></a>问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？</h4><p>现实中就是向政府部门认证哪些是登记过的可信任的部门，像4，6级证书颁发的部门——全国大学英语四六级考试委员会，是全国的教育局的下级和内部部门，是认证过的。而在互联网中，就需要顶级的最具有公信力的 CA，这个 CA 颁发的证书是最受信任的，这个就是<strong>根证书</strong>。为了不让所有鸡蛋都放在一个篮子里，其他的 CA 机构可以向上一级的 CA 机构申请成为中间 CA，获取自己的<strong>中间证书</strong>，最终个人像 A 向某一个中间 CA 申请的证书就是最终的<strong>终端普通数字证书</strong>。这个过程的签发关系就是<strong>证书链</strong>。当 B 得到 A 的数字证书之后，会在证书的信息中找到 A 申请的 CA，而这个 CA 则会根据自己中间证书找到的自己申请的 CA，就这样沿着证书链找证书，假如某个中间证书或者根证书在本机中安装有，则认证的时候会将 A 的证书设置为可被信任的。</p>
<p>如何识别可信任机构的这个问题就解决了。</p>
<h4 id="问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？"><a href="#问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？" class="headerlink" title="问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？"></a>问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？</h4><p>现实中可以在这个已经被认证的第三方机构系统中查询，像4，6级，可以到教育局的网上公开系统中查询。而在互联网中，则需要一个类似的查询验证过程——数字签名。为了对这个证书的验证，确保这个签名是来自可信任的 CA，而不是其他不可信的 CA。CA 在给 A 的数字证书中有一个数字签名。该签名是 CA 用自己的私钥对 A 的个人信息进行非对称加密得到的加密信息。当 B 得到 A 提供的数字证书，会拿到其中的数字签名和 A 的个人信息，然后用 CA 的公钥对这个数字签名进行非对称解密，得出的信息假如和 A 的数字证书中 A 的个人信息一样的话，就相信这个数字证书确实是 CA 认证过的。</p>
<p>如何认证这个签名是不是伪造的这个问题也解决了。但是这个问题又引出了另外一个问题：数字证书中 A 的个人信息数据比较大，而非对成加密算法的加密解密速度非常慢，使得认证过程中对个人信息的非对称加密解密非常耗占时间。所以需要用到另外一种算法来加快这个验证过程，这个算法就是摘要算法。（一直很疑惑为什么需要到摘要算法，总算找到了一个原因）</p>
<p>摘要算法可以将任意大小的原文消息加密并摘要成固定长度的简短密文。对于不同的原文消息，用同一种摘要算法，都可以得到不同但是固定长度的密文，而相同的原文消息，用同一种摘要算法，则可以得到相同固定长度的密文。这就解决了数字签名过程中，对数据大的个人信息文件的非对称加密解密的时间慢的问题。CA 用 A 个人信息进行摘要算法的处理，然后继续用私钥加密，作为数字证书的数字签名给到 A。B 拿到 A 提供的数字签名和 A 的个人信息，然后用 CA 的公钥解密 A 的数字签名，得到 A 个人信息的摘要。再用同一种摘要算法对 A 的个人信息进行处理，得到 A 个人信息的摘要，再与解密得到的 A 个人信息摘要对比，就可以确认改数字签名和个人信息是匹配的。 </p>
<p>到这一步，中间人攻击已经很难可以发生了，假设 M 想要在 A 和 B 之间充当中间人，有三种手段：</p>
<ul>
<li>需要从 A 服务器中直接获取域名数字证书；</li>
<li>得到 A 的域名管理，向 CA 申请证书</li>
<li>自己签发证书，然后要求 B 安装自己的证书。</li>
</ul>
<p>对于第一第二个问题的防范，在服务器端，只要要保护好私钥和服务器和域名的安全，就不会出现大问题。</p>
<p>对于第三个问题，在客户端，有一个很好的例子：12306。12306 的证书就是中铁局自己搞的认证机构颁发的。当你浏览 12306 的时候，虽然请求是带 HTTPS，但是浏览器检查的时候发现这个中铁局的认证机构没有在证书链当中，会提示“可能会被攻击”，当然 12306 会要求你直接安装他们的证书。这就要求你自己的明察秋毫了，你是选择相信 ZF 的证书，然后可能以后 ZF 的某些网站可能会在中铁局的认证机构认证证书，然后假装是 HTTPS，并且可能会伪装窃取你的个人信息。所以在客户端，安装证书需要谨慎，不要随意安装不信任的证书。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/解密webpack-tree-starking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/解密webpack-tree-starking/" itemprop="url">解密webpack tree-starking</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T19:42:07+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tree-Shaking-简介"><a href="#Tree-Shaking-简介" class="headerlink" title="Tree-Shaking 简介"></a>Tree-Shaking 简介</h2><p>最近看了一篇 <strong> <a href="https://juejin.im/post/5a5652d8f265da3e497ff3de" target="_blank" rel="noopener">你的Tree-Shaking并没什么卵用</a> </strong>吓得我赶紧好好研究Tree-Shaking。</p>
<p><code>tree-sharking</code> 是 <code>Webpack 2</code> 后续版本的优化功能，顾名思义，就是将多余的代码给 “摇晃” 掉，在开发中我们经常使用一些第三方库，而这些第三方库只使用了这个库的一部门功能或代码，未使用的代码也要被打包进来，这样出口文件会非常大，<code>tree-sharking</code> 帮我们解决了这个问题，它可以将各个模块中没有使用的方法过滤掉，只对有效代码进行打包。</p>
<p>Tree-Shaking在前端界由rollup首先提出并实现，后续webpack在2.x版本也借助于UglifyJS实现了。自那以后，在各类讨论优化打包的文章中，都能看到Tree-Shaking的身影。</p>
<h4 id="Tree-Shaking的原理"><a href="#Tree-Shaking的原理" class="headerlink" title="Tree-Shaking的原理"></a>Tree-Shaking的原理</h4><p>这里我不多冗余阐述，直接贴百度外卖前端的一篇文章：<strong> <a href="https://juejin.im/post/5a4dc842518825698e7279a9" target="_blank" rel="noopener">Tree-Shaking性能优化实践 - 原理篇</a> </strong>。</p>
<hr>
<h3 id="AST-语法树分析"><a href="#AST-语法树分析" class="headerlink" title="AST 语法树分析"></a>AST 语法树分析</h3><blockquote>
<p>AST 抽象语法树简介</p>
</blockquote>
<p>AST（Abstract Syntax Tree）是源代码的抽象语法结构树状表现形式，Webpack、ESLint、JSX、TypeScript 的编译和模块化规则之间的转化都是通过 AST 来实现对代码的检查、分析以及编译等操作。</p>
<h3 id="JavaScript-语法的-AST-语法树"><a href="#JavaScript-语法的-AST-语法树" class="headerlink" title="JavaScript 语法的 AST 语法树"></a>JavaScript 语法的 AST 语法树</h3><blockquote>
<p>JavaScript 中想要使用 AST 进行开发，要知道抽象成语法树之后的结构是什么，里面的字段名称都代表什么含义以及遍历的规则，<br>我们可以通过在线转换网站<strong><a href="http://esprima.org/demo/parse.html" target="_blank" rel="noopener">http://esprima.org/demo/parse.html</a></strong>将 JS 代码装换成 AST 语法树。</p>
</blockquote>
<p>通过在线编译工具，可以将 <code>function fn(a, b) {}</code>编译为下面的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line">            &quot;id&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;fn&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;params&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;b&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;body&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line">                &quot;body&quot;: []</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;generator&quot;: false,</span><br><span class="line">            &quot;expression&quot;: false,</span><br><span class="line">            &quot;async&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>将 JavaScript 语法编译成抽象语法树后，需要对它进行遍历、修该并重新编译，遍历树结构的过程为 “先序深度优先”。</p>
</blockquote>
<h2 id="esprima、estraverse-和-escodegen"><a href="#esprima、estraverse-和-escodegen" class="headerlink" title="esprima、estraverse 和 escodegen"></a>esprima、estraverse 和 escodegen</h2><p><code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 模块是操作 AST 的三个重要模块，也是实现 <code>babel</code> 的核心依赖，下面是分别介绍三个模块的作用。</p>
<h3 id="1、esprima-将-JS-转换成-AST"><a href="#1、esprima-将-JS-转换成-AST" class="headerlink" title="1、esprima 将 JS 转换成 AST"></a>1、esprima 将 JS 转换成 AST</h3><p><strong>esprima 模块的用法如下：</strong></p>
<blockquote>
<p>文件：esprima-test.js</p>
</blockquote>
<pre><code>const esprima = require(&quot;esprima&quot;);

let code = &quot;function fn() {}&quot;;

// 生成语法树
let tree = esprima.parseScript(code);

console.log(tree);

// Script {
//   type: &apos;Program&apos;,
//   body:
//    [ FunctionDeclaration {
//        type: &apos;FunctionDeclaration&apos;,
//        id: [Identifier],
//        params: [],
//        body: [BlockStatement],
//        generator: false,
//        expression: false,
//        async: false } ],
//   sourceType: &apos;script&apos; }
</code></pre><p>通过上面的案例可以看出，通过 <code>esprima</code> 模块的 <code>parseScript</code> 方法将 JS 代码块转换成语法树，代码块需要转换成字符串，也可以通过 <code>parseModule</code> 方法转换一个模块。</p>
<h3 id="2、estraverse-遍历和修改-AST"><a href="#2、estraverse-遍历和修改-AST" class="headerlink" title="2、estraverse 遍历和修改 AST"></a>2、estraverse 遍历和修改 AST</h3><p><strong>查看遍历过程：</strong></p>
<blockquote>
<p>文件：estraverse-test.js</p>
</blockquote>
<pre><code>const esprima = require(&quot;esprima&quot;);
const estraverse = require(&quot;estraverse&quot;);

let code = &quot;function fn() {}&quot;;

// 遍历语法树
estraverse.traverse(esprima.parseScript(code), {
    enter(node) {
console.log(&quot;enter&quot;, node.type);
    },
    leave() {
console.log(&quot;leave&quot;, node.type);
    }
});

// enter Program
// enter FunctionDeclaration
// enter Identifier
// leave Identifier
// enter BlockStatement
// leave BlockStatement
// leave FunctionDeclaration
// leave Program
</code></pre><p>上面代码通过 <code>estraverse</code> 模块的 <code>traverse</code> 方法将 <code>esprima</code> 模块转换的 AST 进行了遍历，并打印了所有的 <code>type</code> 属性并打印，每含有一个 <code>type</code> 属性的对象被叫做一个节点，修改是获取对应的类型并修改该节点中的属性即可。</p>
<p>其实深度遍历 AST 就是在遍历每一层的 <code>type</code> 属性，所以遍历会分为两个阶段，进入阶段和离开阶段，在 <code>estraverse</code> 的 <code>traverse</code> 方法中分别用参数指定的 <code>entry</code> 和 <code>leave</code> 两个函数监听，但是我们一般只使用 <code>entry</code>。</p>
<h3 id="3、escodegen-将-AST-转换成-JS"><a href="#3、escodegen-将-AST-转换成-JS" class="headerlink" title="3、escodegen 将 AST 转换成 JS"></a>3、escodegen 将 AST 转换成 JS</h3><p>下面的案例是一个段 JS 代码块被转换成 AST，并将遍历、修改后的 AST 重新转换成 JS 的全过程。</p>
<blockquote>
<p>文件：escodegen-test.js</p>
</blockquote>
<pre><code>const esprima = require(&quot;esprima&quot;);
const estraverse = require(&quot;estraverse&quot;);
const escodegen = require(&quot;escodegen&quot;);

let code = &quot;function fn() {}&quot;;

// 生成语法树
let tree = esprima.parseScript(code);

// 遍历语法树
estraverse.traverse(tree, {
    enter(node) {
// 修改函数名
if (node.type === &quot;FunctionDeclaration&quot;) {
            node.id.name = &quot;ast&quot;;
        }
    }
});

// 编译语法树
let result = escodegen.generate(tree);

console.log(result);

// function ast() {
// }
</code></pre><p><strong><em>在遍历 AST 的过程中 <code>params</code> 值为数组，没有 <code>type</code> 属性。</em></strong></p>
<hr>
<h2 id="实现-Babel-语法转换插件"><a href="#实现-Babel-语法转换插件" class="headerlink" title="实现 Babel 语法转换插件"></a>实现 Babel 语法转换插件</h2><p>实现语法转换插件需要借助 <code>babel-core</code> 和 <code>babel-types</code> 两个模块，其实这两个模块就是依赖 <code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 的。</p>
<p><strong>使用这两个模块需要安装，命令如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-types</span><br></pre></td></tr></table></figure>
<h3 id="1、plugin-transform-arrow-functions"><a href="#1、plugin-transform-arrow-functions" class="headerlink" title="1、plugin-transform-arrow-functions"></a>1、plugin-transform-arrow-functions</h3><p><code>plugin-transform-arrow-functions</code> 是 Babel 家族成员之一，用于将箭头函数转换 ES5 语法的函数表达式。</p>
<blockquote>
<p>文件：plugin-transform-arrow-functions.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">// 箭头函数代码块</span><br><span class="line">let sumCode = `</span><br><span class="line">const sum = (a, b) =&gt; &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;`;</span><br><span class="line">let minusCode = `const minus = (a, b) =&gt; a - b;`;</span><br><span class="line"></span><br><span class="line">// 转化 ES5 插件</span><br><span class="line">let ArrowPlugin = &#123;</span><br><span class="line">// 访问者（访问者模式）</span><br><span class="line">    visitor: &#123;</span><br><span class="line">// path 是树的路径</span><br><span class="line">        ArrowFunctionExpression(path) &#123;</span><br><span class="line">// 获取树节点</span><br><span class="line">let node = path.node;</span><br><span class="line"></span><br><span class="line">// 获取参数和函数体</span><br><span class="line">let params = node.params;</span><br><span class="line">let body = node.body;</span><br><span class="line"></span><br><span class="line">// 判断函数体是否是代码块，不是代码块则添加 return 和 &#123;&#125;</span><br><span class="line">if (!types.isBlockStatement(body)) &#123;</span><br><span class="line">let returnStatement = types.returnStatement(body);</span><br><span class="line">                body = types.blockStatement([returnStatement]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">// 生成一个函数表达式树结构</span><br><span class="line">let func = types.functionExpression(null, params, body, false, false);</span><br><span class="line"></span><br><span class="line">// 用新的树结构替换掉旧的树结构</span><br><span class="line">            types.replaceWith(func);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 生成转换后的代码块</span><br><span class="line">let sumResult = babel.transform(sumCode, &#123;</span><br><span class="line">    plugins: [ArrowPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let minusResult = babel.transform(minusCode, &#123;</span><br><span class="line">    plugins: [ArrowPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(sumResult.code);</span><br><span class="line">console.log(minusResult.code);</span><br><span class="line"></span><br><span class="line">// let sum = function (a, b) &#123;</span><br><span class="line">//   return a + b;</span><br><span class="line">// &#125;;</span><br><span class="line">// let minus = function (a, b) &#123;</span><br><span class="line">//   return a - b;</span><br><span class="line">// &#125;;</span><br></pre></td></tr></table></figure>
<p>我们主要使用 <code>babel-core</code> 的 <code>transform</code> 方法将 AST 转化成代码块，第一个参数为转换前的代码块（字符串），第二个参数为配置项，其中 <code>plugins</code> 值为数组，存储修改 <code>babal-core</code> 转换的 AST 的插件（对象），使用 <code>transform</code> 方法将旧的 AST 处理成新的代码块后，返回值为一个对象，对象的 <code>code</code> 属性为转换后的代码块（字符串）。</p>
<p>内部修改通过 <code>babel-types</code> 模块提供的方法实现，API 可以到 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank" rel="noopener">https://github.com/babel/babel/tree/6.x/packages/babel-types</a> 中查看。</p>
<p><code>ArrowPlugin</code> 就是传入 <code>transform</code> 方法的插件，必须含有 <code>visitor</code> 属性（固定），值同为对象，用于存储修改语法树的方法，方法名要严格按照 API，对应的方法会修改 AST 对应的节点。</p>
<p>在 <code>types.functionExpression</code> 方法中参数分别代表，函数名（匿名函数为 <code>null</code>）、函数参数（必填）、函数体（必填）、是否为 <code>generator</code> 函数（默认 <code>false</code>）、是否为 <code>async</code> 函数（默认 <code>false</code>），返回值为修改后的 AST，<code>types.replaceWith</code> 方法用于替换 AST，参数为新的 AST。</p>
<h3 id="2、plugin-transform-classes"><a href="#2、plugin-transform-classes" class="headerlink" title="2、plugin-transform-classes"></a>2、plugin-transform-classes</h3><p><code>plugin-transform-classes</code> 也是 Babel 家族中的成员之一，用于将 ES6 的 <code>class</code> 类转换成 ES5 的构造函数。</p>
<blockquote>
<p>文件：plugin-transform-classes.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">// 类</span><br><span class="line">let code = `</span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName () &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;`;</span><br><span class="line"></span><br><span class="line">// 将类转化 ES5 构造函数插件</span><br><span class="line">let ClassPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ClassDeclaration(path) &#123;</span><br><span class="line">let node = path.node;</span><br><span class="line">let classList = node.body.body;</span><br><span class="line"></span><br><span class="line">// 将取到的类名转换成标识符 &#123; type: &apos;Identifier&apos;, name: &apos;Person&apos; &#125;</span><br><span class="line">let className = types.identifier(node.id.name);</span><br><span class="line">let body = types.blockStatement([]);</span><br><span class="line">let func = types.functionDeclaration(className, [], body, false, false);</span><br><span class="line">            path.replaceWith(func);</span><br><span class="line"></span><br><span class="line">// 用于存储多个原型方法</span><br><span class="line">let es5Func = [];</span><br><span class="line"></span><br><span class="line">// 获取 class 中的代码体</span><br><span class="line">            classList.forEach((item, index) =&gt; &#123;</span><br><span class="line">// 函数的代码体</span><br><span class="line">let body = classList[index].body;</span><br><span class="line"></span><br><span class="line">// 获取参数</span><br><span class="line">let params = item.params.length ? item.params.map(val =&gt; val.name) : [];</span><br><span class="line"></span><br><span class="line">// 转化参数为标识符</span><br><span class="line">                params = types.identifier(params);</span><br><span class="line"></span><br><span class="line">// 判断是否是 constructor，如果构造函数那就生成新的函数替换</span><br><span class="line">if (item.kind === &quot;constructor&quot;) &#123;</span><br><span class="line">// 生成一个构造函数树结构</span><br><span class="line">                    func = types.functionDeclaration(className, [params], body, false, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">// 其他情况是原型方法</span><br><span class="line">let proto = types.memberExpression(className, types.identifier(&quot;prototype&quot;));</span><br><span class="line"></span><br><span class="line">// 左侧层层定义标识符 Person.prototype.getName</span><br><span class="line">let left = types.memberExpression(proto, types.identifier(item.key.name));</span><br><span class="line"></span><br><span class="line">// 右侧定义匿名函数</span><br><span class="line">let right = types.functionExpression(null, [params], body, false, false);</span><br><span class="line"></span><br><span class="line">// 将左侧和右侧进行合并并存入数组</span><br><span class="line">                    es5Func.push(types.assignmentExpression(&quot;=&quot;, left, right));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">// 如果没有原型方法，直接替换</span><br><span class="line">if (es5Func.length === 0) &#123;</span><br><span class="line">                path.replaceWith(func);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                es5Func.push(func);</span><br><span class="line">// 替换 n 个节点</span><br><span class="line">                path.replaceWithMultiple(es5Func);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 生成转换后的代码块</span><br><span class="line">result = babel.transform(code, &#123;</span><br><span class="line">    plugins: [ClassPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result.code);</span><br><span class="line"></span><br><span class="line">// Person.prototype.getName = function () &#123;</span><br><span class="line">//     return this.name;</span><br><span class="line">// &#125;</span><br><span class="line">// function Person(name) &#123;</span><br><span class="line">//     this.name = name;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<p>上面这个插件的实现要比 <code>plugin-transform-arrow-functions</code> 复杂一些，归根结底还是将要互相转换的 ES6 和 ES5 语法树做对比，找到他们的不同，并使用 <code>babel-types</code> 提供的 API 对语法树对应的节点属性进行修改并替换语法树，值得注意的是 <code>path.replaceWithMultiple</code> 与 <code>path.replaceWith</code> 不同，参数为一个数组，数组支持多个语法树结构，可根据具体修改语法树的场景选择使用，也可根据不同情况使用不同的替换方法。</p>
<blockquote>
<p>通过本节我们了解了什么是 AST 抽象语法树、抽象语法树在 JavaScript 中的体现以及在 NodeJS 中用于生成、遍历和修改 AST 抽象语法树的核心依赖，并通过使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块简易模拟了 ES6 新特性转换为 ES5 语法的过程，希望可以为后面自己实现一些编译插件提供了思路。</p>
</blockquote>
<hr>
<p>假设我们现在使用了 ElementUI 库的两个组件，通常会使用解构赋值来引入。</p>
<blockquote>
<p>优化前</p>
</blockquote>
<pre><code>import { Button, Alert } from&quot;element-ui&quot;;
</code></pre><p>这样引用资源， Webpack 在打包的时候会找到 <code>element-ui</code> 并把里面所有的代码全部打包到出口文件，我们只使用了两个组件，全部打包不是我们所希望的，<code>tree-sharking</code> 是通过在 Webpack 中配置 <code>babel-plugin-import</code> 插件来实现的，它可以将解构的代码转换成下面的形式。</p>
<blockquote>
<p>优化后</p>
</blockquote>
<pre><code>import Button from&quot;element-ui/lib/button&quot;;
import Alert from&quot;element-ui/lib/Alert&quot;;
</code></pre><p>转化后会去 <code>node_modules</code> 中的 <code>element-ui</code> 模块找到 <code>Button</code> 和 <code>Alert</code> 两个组件对应的文件，并打包到出口文件中。</p>
<p>通过上面的转换可以看出，其实 <code>tree-sharking</code> 的实现原理是通过改变 AST 语法树的结构来实现的，如果不了解抽象语法树可以参考 <a href="https://www.pandashen.com/2018/07/25/20180725130233/" target="_blank" rel="noopener">AST 抽象语法树</a>，</p>
<blockquote>
<p>优化前的 AST 语法树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;imported&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;imported&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优化后的 AST 语法树</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui/lib/button&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui/lib/button\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui/lib/Alert&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui/lib/Alert\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的语法树对比，可以看出在优化前 <code>body</code> 里面只有一个对象，使用的组件信息存在 <code>specifiers</code> 里，<code>source</code> 指向了 <code>element-ui</code>，而在优化后，将两个组件分别拆成了两个对象存在 <code>body</code> 中，每个对象的的 <code>specifiers</code> 只存储一个组件，并在 <code>source</code> 里面指向了当前组件对应的路径。</p>
<hr>
<h2 id="模拟-tree-starking"><a href="#模拟-tree-starking" class="headerlink" title="模拟 tree-starking"></a>模拟 tree-starking</h2><p>既然我们已经清楚要修改语法树的位置，下面就使用 AST 来模拟 <code>tree-sharking</code> 功能，对语法树的操作是依赖于 <code>babel-core</code> 和 <code>babel-types</code> 两个核心模块的，下面先安装依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-types</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>文件：babel-plugin-my-import.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">let code = `import &#123; Button, Alert &#125; from &quot;element-ui&quot;`;</span><br><span class="line"></span><br><span class="line">let importPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ImportDeclaration(path) &#123;</span><br><span class="line">            let node = path.node;</span><br><span class="line">            let source = node.source.value;</span><br><span class="line">            let specifiers = node.specifiers;</span><br><span class="line"></span><br><span class="line">            // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出</span><br><span class="line">            if (!types.isImportDefaultSpecifier(specifiers[0])) &#123;</span><br><span class="line">                // 如果不是默认导出，则需要转换</span><br><span class="line">                specifiers = specifiers.map(specifier =&gt; &#123;</span><br><span class="line">                    // 数组内容：当前默认导出的标识、从哪里导入</span><br><span class="line">                    return types.importDeclaration(</span><br><span class="line">                        [types.importDefaultSpecifier(specifier.local)],</span><br><span class="line">                        types.stringLiteral(`$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;`)</span><br><span class="line">                    );</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // 替换树结构</span><br><span class="line">                path.replaceWithMultiple(specifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let result = babel.transform(code, &#123;</span><br><span class="line">    plugins: [importPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result.code);</span><br><span class="line"></span><br><span class="line">// import Button from &quot;element-ui/lib/button&quot;;</span><br><span class="line">// import Alert from &quot;element-ui/lib/alert&quot;;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码可以发现我们使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块的核心方法对语法书进行了遍历、修改和替换，更详细的 API 可以查看 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank" rel="noopener">https://github.com/babel/babel/tree/6.x/packages/babel-types</a>。</p>
<hr>
<h2 id="结合-Webpack-使用插件"><a href="#结合-Webpack-使用插件" class="headerlink" title="结合 Webpack 使用插件"></a>结合 Webpack 使用插件</h2><p>前面只是验证了 <code>tree-sharking</code> 中 JS 语法的转换过程，接下来将上面的代码转换成插件配合 Webpack 使用，来彻底感受 <code>tree-sharking</code> 的工作过程。</p>
<blockquote>
<p>文件：~node_modules/babel-plugin-my-import.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">let importPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ImportDeclaration(path) &#123;</span><br><span class="line">            let node = path.node;</span><br><span class="line">            let source = node.source.value;</span><br><span class="line">            let specifiers = node.specifiers;</span><br><span class="line"></span><br><span class="line">            // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出</span><br><span class="line">            if (!types.isImportDefaultSpecifier(specifiers[0])) &#123;</span><br><span class="line">                // 如果不是默认导出，则需要转换</span><br><span class="line">                specifiers = specifiers.map(specifier =&gt; &#123;</span><br><span class="line">                    // 数组内容：当前默认导出的标识、从哪里导入</span><br><span class="line">                    return types.importDeclaration(</span><br><span class="line">                        [types.importDefaultSpecifier(specifier.local)],</span><br><span class="line">                        types.stringLiteral(`$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;`)</span><br><span class="line">                    );</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // 替换树解构</span><br><span class="line">                path.replaceWithMultiple(specifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = importPlugin;</span><br></pre></td></tr></table></figure>
<p>上面删掉了多余的测试代码，将模块中的 <code>importPlugin</code> 插件导出，并把 <code>babel-plugin-my-import.js</code> 移入了 <code>node_modules</code> 当中。</p>
<p><strong>接下来安装需要的依赖：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli babel-loader babel-presets-env</span><br><span class="line">npm install vue element-ui --save</span><br></pre></td></tr></table></figure></p>
<p>安装完依赖，写一个要编译的文件，使用 Webpack 进行打包，查看使用插件前和使用插件后出口文件的大小。<br>文件：import.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vue from&quot;vue&quot;;</span><br><span class="line">import &#123; Button, Alert &#125; from&quot;element-ui&quot;;</span><br></pre></td></tr></table></figure></p>
<p>下面来写一个简单的 Webpack 配置文件。</p>
<blockquote>
<p>文件：webpcak.config.js</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    module.exports = &#123;</span><br><span class="line">    mode: &quot;development&quot;,</span><br><span class="line">    entry: &quot;import.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;bundle.js&quot;,</span><br><span class="line">        path: __dirname</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: &quot;babel-loader&quot;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [</span><br><span class="line">                        &quot;env&quot;,</span><br><span class="line">                    ],</span><br><span class="line">                    plugins: [</span><br><span class="line">                        // 插件：不使用插件打包注释掉该行即可</span><br><span class="line">                        [&quot;my-import&quot;, &#123; libararyName: &quot;element-ui&quot; &#125;]</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了防止 <code>babel</code> 相关的依赖升级 <code>7.0</code> 后出现一些问题导致 Webpack 无法启动，再此贴出 <code>package.json</code> 文件，按照对应版本下载依赖保证上面 Webpack 配置生效。</p>
<blockquote>
<p>文件：package.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;: &quot;ast-lesson&quot;,</span><br><span class="line"> &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line"> &quot;description&quot;: &quot;tree-starking&quot;,</span><br><span class="line"> &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line"> &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">   &#125;,</span><br><span class="line"> &quot;keywords&quot;: [],</span><br><span class="line"> &quot;author&quot;: &quot;&quot;,</span><br><span class="line"> &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line"> &quot;dependencies&quot;: &#123;</span><br><span class="line"> &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line"> &quot;babel-loader&quot;: &quot;^7.1.5&quot;,</span><br><span class="line"> &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,</span><br><span class="line"> &quot;babel-types&quot;: &quot;^6.26.0&quot;,</span><br><span class="line"> &quot;escodegen&quot;: &quot;^1.10.0&quot;,</span><br><span class="line"> &quot;esprima&quot;: &quot;^4.0.0&quot;,</span><br><span class="line"> &quot;estraverse&quot;: &quot;^4.2.0&quot;,</span><br><span class="line"> &quot;webpack&quot;: &quot;^4.16.0&quot;,</span><br><span class="line"> &quot;webpack-cli&quot;: &quot;^3.0.8&quot;</span><br><span class="line">   &#125;,</span><br><span class="line"> &quot;devDependencies&quot;: &#123;</span><br><span class="line"> &quot;vue&quot;: &quot;^2.5.17&quot;,</span><br><span class="line"> &quot;element-ui&quot;: &quot;^2.4.6&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="对比使用插件前后的出口文件"><a href="#对比使用插件前后的出口文件" class="headerlink" title="对比使用插件前后的出口文件"></a>对比使用插件前后的出口文件</h2><p>接下来分别在使用插件和不使用插件时执行打包命令，查看出口文件 <code>bondle.js</code> 的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>babel-plugin-my-import</code> 前：</p>
<p><a href="/2018/07/26/20180726122146/before-babel-plugin.jpg"><img src="/2018/10/25/解密webpack-tree-starking/before-babel-plugin.jpg" alt="使用 tree-starking 之前"></a></p>
<p>使用 <code>babel-plugin-my-import</code> 后：</p>
<p><a href="/2018/07/26/20180726122146/after-babel-plugin.jpg"><img src="/2018/10/25/解密webpack-tree-starking/after-babel-plugin.jpg" alt="使用 tree-starking 之后"></a></p>
<p>通过对比，可以看到使用 <code>tree-sharking</code> 即我们自己实现的 <code>babel-plugin-my-import</code> 插件后，打包的出口文件大大减小，其原因是将引入第三方库没有使用的代码全都过滤掉了，只打包了有效代码。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面对 Webpack 的 <code>tree-sharking</code> 进行了分析，并模拟 <code>babel-plugin-import</code> 简易的实现了一版 <code>tree-sharking</code> 的优化插件，这个过程中相信大家已经了解了 <code>tree-sharking</code> 的原理以及实现类似插件的思路，并已经具备了开发类似插件的基本条件，最后还有一点需要补充，<code>tree-sharking</code> 优化的方式是根据 ES6 语法 <code>import</code> “静态” 引入的特性实现的，如果要说 <code>tree-sharking</code> 很强大，还不如说 ES6 模块化规范 “静态” 引入的特性强大，正由于是基于 “静态” 引入，所以目前 <code>tree-sharking</code> 只支持遍历一层 <code>import</code> 关键字。</p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/24/async-并发执行和继发执行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/24/async-并发执行和继发执行/" itemprop="url">async 并发执行和继发执行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-24T19:50:49+08:00">
                2018-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong> 面试题继发执行 : 1s后执行10，等1s后输出20，再等1s后输出30 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			function Pro(val) &#123;</span><br><span class="line">				return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">					setTimeout(function() &#123;</span><br><span class="line">						resolve(val)</span><br><span class="line">					&#125;, 1000)</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			async function log(arrs) &#123;</span><br><span class="line">				for(const item of arrs) &#123;</span><br><span class="line">					var response = await Pro(item);</span><br><span class="line">					console.log(response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			log([10, 20, 30])</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>问题：给定一个 URL 数组，如何实现接口的继发和并发？</strong></p>
<h3 id="async-继发实现："><a href="#async-继发实现：" class="headerlink" title="async 继发实现："></a>async 继发实现：</h3><h4 id="继发一"><a href="#继发一" class="headerlink" title="继发一"></a>继发一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function loadData() &#123;</span><br><span class="line">  var res1 = await fetch(url1);</span><br><span class="line">  var res2 = await fetch(url2);</span><br><span class="line">  var res3 = await fetch(url3);</span><br><span class="line">  return&quot;whew all done&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继发二"><a href="#继发二" class="headerlink" title="继发二"></a>继发二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function loadData(urls) &#123;</span><br><span class="line">  for (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async-并发实现："><a href="#async-并发实现：" class="headerlink" title="async 并发实现："></a>async 并发实现：</h3><h4 id="并发一"><a href="#并发一" class="headerlink" title="并发一"></a>并发一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function loadData() &#123;</span><br><span class="line">  var res = awaitPromise.all([fetch(url1), fetch(url2), fetch(url3)]);</span><br><span class="line">  return&quot;whew all done&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并发二"><a href="#并发二" class="headerlink" title="并发二"></a>并发二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function loadData(urls) &#123;</span><br><span class="line">  // 并发读取 url</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    return response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  for (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/js获取深层次属性-一道很经典的面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/js获取深层次属性-一道很经典的面试题/" itemprop="url">js获取深层次属性,一道很经典的面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T21:09:05+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："><a href="#题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：" class="headerlink" title="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："></a>题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; a: &#123; b: &#123; c: &apos;ScriptOJ&apos; &#125; &#125; &#125;</span><br><span class="line">data.a.b.c // =&gt; scriptoj</span><br><span class="line">data.a.b.c.d // =&gt; 报错，代码停止执行console.log(&apos;ScriptOJ&apos;) // =&gt; 不会被执行</span><br></pre></td></tr></table></figure>
<p>请你完成一个 safeGet 函数，可以安全的获取无限多层次的数据，一旦数据不存在不会报错，会返回 undefined，<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123; a: &#123; b: &#123; c: &apos;ScriptOJ&apos; &#125; &#125; &#125;</span><br><span class="line">safeGet(data, &apos;a.b.c&apos;) // =&gt; scriptoj</span><br><span class="line">safeGet(data, &apos;a.b.c.d&apos;) // =&gt; 返回 undefined</span><br><span class="line">safeGet(data, &apos;a.b.c.d.e.f.g&apos;) // =&gt; 返回 undefined</span><br></pre></td></tr></table></figure></p>
<p>答案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const safeGet = (o, path) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return path.split(&apos;.&apos;).reduce((o, k) =&gt; o[k], o)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    return void 666</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/23/Web-安全攻防总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/23/Web-安全攻防总结/" itemprop="url">Web 安全攻防总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-23T20:02:04+08:00">
                2018-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Web 安全的对于 Web 从业人员来说是一个非常重要的课题，所以在这里总结一下 Web 相关的安全攻防知识，希望以后不要再踩雷，也希望对看到这篇文章的同学有所帮助。今天这边文章主要的内容就是分析几种常见的攻击的类型以及防御的方法。</p>
<blockquote>
<p>也许你对所有的安全问题都有一定的认识，但最主要的还是在编码设计的过程中时刻绷紧安全那根弦，需要反复推敲每个实现细节，安全无小事。</p>
<p>本文代码 Demo 都是基于 Node.js 讲解，其他服务端语言同样可以参考。</p>
</blockquote>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。</p>
<p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。</p>
<h3 id="非持久型-XSS"><a href="#非持久型-XSS" class="headerlink" title="非持久型 XSS"></a>非持久型 XSS</h3><p>非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br><img src="/2018/10/23/Web-安全攻防总结/xss1.jpg" alt="非持久型 XSS"><br>举一个例子，比如你的 Web 页面中包含有以下代码：</p>
<pre><code>&lt;select&gt;
    &lt;script&gt;
        document.write(&apos;&apos;
                + &apos;&lt;optionvalue=1&gt;&apos;
                +     location.href.substring(location.href.indexOf(&apos;default=&apos;) + 8)
                + &apos;&lt;/option&gt;&apos;
            );
            document.write(&apos;&lt;optionvalue=2&gt;English&lt;/option&gt;&apos;);
    &lt;/script&gt;
&lt;/select&gt;
</code></pre><p>攻击者可以直接通过 URL (类似： </p>
<pre><code>https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;
</code></pre><p>注入可执行的脚本代码。</p>
<p>非持久型 XSS 漏洞攻击有以下几点<strong>特征</strong>：</p>
<ul>
<li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li>
<li>攻击者需要诱骗点击</li>
<li>反馈率低，所以较难发现和响应修复</li>
<li>盗取用户敏感保密信息</li>
</ul>
<p>为了<strong>防止出现非持久型 XSS 漏洞</strong>，需要确保这么几件事情：</p>
<ul>
<li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li>
<li>尽量不要从 URL，<code>document.referrer</code>，<code>document.forms</code> 等这种 DOM API 中获取数据直接渲染。</li>
<li>尽量不要使用 <code>eval</code>, <code>new Function()</code>，<code>document.write()</code>，<code>document.writeln()</code>，<code>window.setInterval()</code>，<code>window.setTimeout()</code>，<code>innerHTML</code>，<code>document.creteElement()</code> 等可执行字符串的方法。</li>
<li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li>
<li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li>
</ul>
<blockquote>
<p>escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 <code>&lt;</code>，<code>&gt;</code>，<code>空格</code> 等，转义成 <code>&amp;lt;</code>，<code>&amp;gt;</code>，<code>&amp;nbsp;</code> 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。</p>
</blockquote>
<h3 id="持久型-XSS"><a href="#持久型-XSS" class="headerlink" title="持久型 XSS"></a>持久型 XSS</h3><p>持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>
<p>主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。攻击成功需要同时满足以下几个条件：</p>
<ul>
<li>POST 请求提交表单后端没做转义直接入库。</li>
<li>后端从数据库中取出数据没做转义直接输出给前端。</li>
<li>前端拿到后端数据没做转义直接渲染成 DOM。</li>
</ul>
<p>持久型 XSS 有以下几个<strong>特点</strong>：</p>
<ul>
<li>持久性，植入在数据库中</li>
<li>危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。</li>
<li>盗取用户敏感私密信息</li>
</ul>
<p>为了<strong>防止持久型 XSS 漏洞</strong>，需要前后端共同努力：</p>
<ul>
<li>后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。</li>
<li>后端在输出给前端数据统一进行转义处理。</li>
<li>前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</li>
</ul>
<h3 id="基于字符集的-XSS"><a href="#基于字符集的-XSS" class="headerlink" title="基于字符集的 XSS"></a>基于字符集的 XSS</h3><p>其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。</p>
<p>以基于 utf-7 的 XSS 为例</p>
<p>utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。</p>
<p>这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。</p>
<pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;
      可以被解释为：
+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4-
</code></pre><p>可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。</p>
<p>所以我们有什么办法避免这种 XSS 呢？</p>
<ul>
<li>记住指定 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></li>
<li>XML 中不仅要指定字符集为 utf-8，而且标签要闭合</li>
<li>牛文推荐：<a href="http://drops.wooyun.org/papers/1327" target="_blank" rel="noopener">http://drops.wooyun.org/papers/1327</a> （这个讲的很详细）</li>
</ul>
<h3 id="基于-Flash-的跨站-XSS"><a href="#基于-Flash-的跨站-XSS" class="headerlink" title="基于 Flash 的跨站 XSS"></a>基于 Flash 的跨站 XSS</h3><p>基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。</p>
<p>避免方法：</p>
<ul>
<li>严格管理 cookie 的读写权限</li>
<li>对 Flash 能接受用户输入的参数进行过滤 escape 转义处理</li>
</ul>
<h3 id="未经验证的跳转-XSS"><a href="#未经验证的跳转-XSS" class="headerlink" title="未经验证的跳转 XSS"></a>未经验证的跳转 XSS</h3><p>有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。</p>
<p>这时候需要通过以下方式来防止这类漏洞：</p>
<ul>
<li>对待跳转的 URL 参数做白名单或者某种规则过滤</li>
<li>后端注意对敏感信息的保护, 比如 cookie 使用来源验证。</li>
</ul>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF（Cross-Site Request Forgery），中文名称：跨站请求伪造攻击</p>
<p>那么 CSRF 到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。攻击者只要借助少许的社会工程学的诡计，例如通过 QQ 等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使 Web 应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。</p>
<p>所以遇到 CSRF 攻击时，将对终端用户的数据和操作指令构成严重的威胁。当受攻击的终端用户具有管理员帐户的时候，CSRF 攻击将危及整个 Web 应用程序。</p>
<h3 id="CSRF-原理"><a href="#CSRF-原理" class="headerlink" title="CSRF 原理"></a>CSRF 原理</h3><p>下图大概描述了 CSRF 攻击的原理，可以理解为有一个小偷在你配钥匙的地方得到了你家的钥匙，然后拿着要是去你家想偷什么偷什么。<br><img src="/2018/10/23/Web-安全攻防总结/csrf.jpg" alt="csrf原理"><br>完成 CSRF 攻击必须要有三个条件：</p>
<ol>
<li>用户已经登录了站点 A，并在本地记录了 cookie</li>
<li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。</li>
<li>站点 A 没有做任何 CSRF 防御</li>
</ol>
<p>你也许会问：「如果我不满足以上三个条件中的任意一个，就不会受到 CSRF 的攻击」。其实可以这么说的，但你不能保证以下情况不会发生：</p>
<ul>
<li>你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站，特别现在浏览器都是支持多 tab 的。</li>
<li>你不能保证你关闭浏览器了后，你本地的 cookie 立刻过期，你上次的会话已经结束。</li>
<li>上图中所谓的攻击网站 B，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li>
</ul>
<h3 id="预防-CSRF"><a href="#预防-CSRF" class="headerlink" title="预防 CSRF"></a>预防 CSRF</h3><p>CSRF 的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的 CSRF 防御也都在服务端进行。服务端的预防 CSRF 攻击的方式方法有多种，但思路上都是差不多的，主要从以下两个方面入手：</p>
<ul>
<li>正确使用 GET，POST 请求和 cookie</li>
<li>在非 GET 请求中增加 token</li>
</ul>
<p>一般而言，普通的 Web 应用都是以 GET、POST 请求为主，还有一种请求是 cookie 方式。我们一般都是按照如下规则设计应用的请求：</p>
<ul>
<li>GET 请求常用在查看，列举，展示等不需要改变资源属性的时候（数据库 query 查询的时候）</li>
<li>POST 请求常用在 From 表单提交，改变一个资源的属性或者做其他一些事情的时候（数据库有 insert、update、delete 的时候）</li>
</ul>
<p>当正确的使用了 GET 和 POST 请求之后，剩下的就是在非 GET 方式的请求中增加随机数，这个大概有三种方式来进行：</p>
<ul>
<li><p><strong>为每个用户生成一个唯一的 cookie token</strong>，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的 cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。</p>
</li>
<li><p><strong>每个 POST 请求使用验证码</strong>，这个方案算是比较完美的，但是需要用户多次输入验证码，用户体验比较差，所以不适合在业务中大量运用。</p>
</li>
<li><p><strong>渲染表单的时候，为每一个表单包含一个 csrfToken</strong>，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。</p>
</li>
</ul>
<p>CSRF 的防御可以根据应用场景的不同自行选择。CSRF 的防御工作确实会在正常业务逻辑的基础上带来很多额外的开发量，但是这种工作量是值得的，毕竟用户隐私以及财产安全是产品最基础的根本。</p>
<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p>
<p>而造成 SQL 注入的原因是因为程序没有有效的转义过滤用户的输入，使攻击者成功的向服务器提交恶意的 SQL 查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p>
<p>很多 Web 开发者没有意识到 SQL 查询是可以被篡改的，从而把 SQL 查询当作可信任的命令。殊不知，SQL 查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过 SQL 查询去运行主机系统级的命令。</p>
<h3 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a>SQL 注入原理</h3><p>下面将通过一些真实的例子来详细讲解 SQL 注入的方式的原理。</p>
<p>考虑以下简单的管理员登录表单：</p>
<pre><code>&lt;formaction=&quot;/login&quot;method=&quot;POST&quot;&gt;
&lt;p&gt;Username: &lt;inputtype=&quot;text&quot;name=&quot;username&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Password: &lt;inputtype=&quot;password&quot;name=&quot;password&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;inputtype=&quot;submit&quot;value=&quot;登陆&quot; /&gt;&lt;/p&gt;
&lt;/form&gt;
</code></pre><p>后端的 SQL 语句可能是如下这样的：</p>
<pre><code>let querySQL = `
    SELECT *
    FROM user
    WHERE username=&apos;${username}&apos;
    AND psw=&apos;${password}&apos;
`;
// 接下来就是执行 sql 语句...
</code></pre><p>目的就是来验证用户名和密码是不是正确，按理说乍一看上面的 SQL 语句也没什么毛病，确实是能够达到我们的目的，可是你只是站在用户会老老实实按照你的设计来输入的角度来看问题，如果有一个恶意攻击者输入的用户名是 <code>zoumiaojiang&#39; OR 1 = 1 --</code>，密码随意输入，就可以直接登入系统了。WFT!</p>
<p>冷静下来思考一下，我们之前预想的真实 SQL 语句是:</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;AND psw=&apos;mypassword&apos;
</code></pre><p>可以恶意攻击者的奇怪用户名将你的 SQL 语句变成了如下形式：</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1--&apos; AND psw=&apos;xxxx&apos;
</code></pre><p>在 SQL 中，<code>--</code> 是注释后面的内容的意思，所以查询语句就变成了：</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1
</code></pre><p>这条 SQL 语句的查询条件永远为真，所以意思就是恶意攻击者不用我的密码，就可以登录进我的账号，然后可以在里面为所欲为，然而这还只是最简单的注入，牛逼的 SQL 注入高手甚至可以通过 SQL 查询去运行主机系统级的命令，将你主机里的内容一览无余，这里我也没有这个能力讲解的太深入，毕竟不是专业研究这类攻击的，但是通过以上的例子，已经了解了 SQL 注入的原理，我们基本已经能找到防御 SQL 注入的方案了。</p>
<h3 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h3><p>防止 SQL 注入主要是不能允许用户输入的内容影响正常的 SQL 语句的逻辑，当用户的输入的信息将要用来拼接 SQL 语句的话，我们应该永远选择不相信，任何内容都必须进行转义过滤，当然做到这个还是不够的，下面列出防御 SQL 注入的几点注意事项：</p>
<ul>
<li><p><strong>严格限制Web应用的数据库的操作权限</strong>，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p>
</li>
<li><p><strong>后端代码检查输入的数据是否符合预期</strong>，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>
</li>
<li><p><strong>对进入数据库的特殊字符（<code>&#39;</code>，<code>&quot;</code>，<code>\</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&amp;</code>，<code>*</code>，<code>;</code> 等）进行转义处理</strong>，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 <code>lodash._escapehtmlchar</code> 库。</p>
</li>
<li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口</strong>，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 <code>query</code> 方法中的 <code>?</code> 占位参数。</p>
</li>
</ul>
<pre><code>mysql.query(`SELECT * FROM user WHERE username = ? AND psw = ?`, [username, psw]);
</code></pre><ul>
<li><p><strong>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测</strong>，以及时修补被发现的 SQL 注入漏洞。网上有很多这方面的开源工具，例如 sqlmap、SQLninja 等。</p>
</li>
<li><p><strong>避免网站打印出 SQL 错误信息</strong>，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。</p>
</li>
<li><p><strong>不要过于细化返回的错误信息</strong>，如果目的是方便调试，就去使用后端日志，不要在接口上过多的暴露出错信息，毕竟真正的用户不关心太多的技术细节，只要话术合理就行。</p>
</li>
</ul>
<p>碰到要操作的数据库的代码，一定要慎重，小心使得万年船，多找几个人多来几次 code review，将问题都暴露出来，而且要善于利用工具，操作数据库相关的代码属于机密，没事不要去各种论坛晒自家站点的 SQL 语句，万一被人盯上了呢？</p>
<h2 id="命令行注入"><a href="#命令行注入" class="headerlink" title="命令行注入"></a>命令行注入</h2><p>命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令，听起来好像匪夷所思，这往往是 Web 开发者最容易忽视但是却是最危险的一个漏洞之一，看一个实例：</p>
<p>假如现在需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去产出一个结果返回给用户，接口的部分实现如下：</p>
<pre><code>// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo
const exec = require(&apos;mz/child_process&apos;).exec;
let params = {/* 用户输入的参数 */};

exec(`git clone ${params.repo} /some/path`);
</code></pre><p>这段代码确实能够满足业务需求，正常的用户也确实能从指定的 git repo 上下载到想要的代码，可是和 SQL 注入一样，这段代码在恶意攻击者眼中，简直就是香饽饽。</p>
<p>如果 <code>params.repo</code> 传入的是 <code>https://github.com/zoumiaojiang/zoumiaojiang.github.io.git</code> 当然没问题了。</p>
<p>可是如果 <code>params.repo</code> 传入的是 <code>https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;</code> 恰好你的服务是用 root 权限起的就惨了。</p>
<p>具体恶意攻击者能用命令行注入干什么也像 SQL 注入一样，手法是千变万化的，比如「<a href="http://wiki.bash-hackers.org/howto/redirection_tutorial" target="_blank" rel="noopener">反弹 shell 注入</a>」等，但原理都是一样的，我们绝对有能力防止命令行注入发生。防止命令行注入需要做到以下几件事情：</p>
<ul>
<li>后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。</li>
<li>在调用系统命令前对所有传入参数进行命令行参数转义过滤。</li>
<li>不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 <code>shell-escape</code> npm 包。</li>
</ul>
<p>还是前面的例子，我们可以做到如下：</p>
<pre><code>const exec = require(&apos;mz/child_process&apos;).exec;

// 借助 shell-escape npm 包解决参数转义过滤问题
const shellescape = require(&apos;shell-escape&apos;);

let params = {/* 用户输入的参数 */};

// 先过滤一下参数，让参数符合预期
if (!/正确的表达式/.test(params.repo)) {
return;
}

let cmd = shellescape([
&apos;git&apos;,
&apos;clone&apos;,
    params.repo,
&apos;/some/path&apos;
]);

// cmd 的值: git clone &apos;https://github.com/xx/xx.git &amp;&amp; rm -rf / &amp;&amp;&apos; /some/path
// 这样就不会被注入成功了。
exec(cmd);
</code></pre><blockquote>
<p>无论是在何种后端语言环境中，凡是涉及到代码调用系统 shell 命令的时候都一定要谨慎。</p>
</blockquote>
<h2 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h2><p>DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用，这个攻击应该不能算是安全问题，这应该算是一个另类的存在，因为这种攻击根本就是耍流氓的存在，「伤敌一千，自损八百」的行为。出于保护 Web App 不受攻击的攻防角度，还是介绍一下 DDoS 攻击吧，毕竟也是挺常见的。</p>
<p>DDoS 攻击可以理解为：「你开了一家店，隔壁家点看不惯，就雇了一大堆黑社会人员进你店里干坐着，也不消费，其他客人也进不来，导致你营业惨淡」。为啥说 DDoS 是个「伤敌一千，自损八百」的行为呢？毕竟隔壁店还是花了不少钱雇黑社会但是啥也没得到不是？DDoS 攻击的目的基本上就以下几个：</p>
<ul>
<li>深仇大恨，就是要干死你</li>
<li>敲诈你，不给钱就干你</li>
<li>忽悠你，不买我防火墙服务就会有“人”继续干你</li>
</ul>
<p>也许你的站点遭受过 DDoS 攻击，具体什么原因怎么解读见仁见智。DDos 攻击从层次上可分为网络层攻击与应用层攻击，从攻击手法上可分为快型流量攻击与慢型流量攻击，但其原理都是造成资源过载，导致服务不可用。</p>
<h3 id="网络层-DDoS"><a href="#网络层-DDoS" class="headerlink" title="网络层 DDoS"></a>网络层 DDoS</h3><p>网络层 DDos 攻击包括 <code>SYN Flood</code>、<code>ACK Flood</code>、<code>UDP Flood</code>、<code>ICMP Flood</code> 等。</p>
<p><strong>SYN Flood 攻击</strong></p>
<p>SYN flood 攻击主要利用了 TCP 三次握手过程中的 Bug，我们都知道 TCP 三次握手过程是要建立连接的双方发送 SYN，SYN + ACK，ACK 数据包，而当攻击方随意构造源 IP 去发送 SYN 包时，服务器返回的 SYN + ACK 就不能得到应答（因为 IP 是随意构造的），此时服务器就会尝试重新发送，并且会有至少 30s 的等待时间，导致资源饱和服务不可用，此攻击属于慢型 DDoS 攻击。</p>
<p><strong>ACK Flood 攻击</strong></p>
<p>ACK Flood 攻击是在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。</p>
<p><strong>UDP Flood 攻击</strong></p>
<p>UDP flood 攻击是由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。</p>
<p><strong>ICMP Flood 攻击</strong></p>
<p>ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。</p>
<h3 id="网络层-DDoS-防御"><a href="#网络层-DDoS-防御" class="headerlink" title="网络层 DDoS 防御"></a>网络层 DDoS 防御</h3><p>网络层的 DDoS 攻击究其本质其实是无法防御的，我们能做得就是不断优化服务本身部署的网络架构，以及提升网络带宽。当然，还是做好以下几件事也是有助于缓解网络层 DDoS 攻击的冲击：</p>
<ul>
<li>网络架构上做好优化，采用负载均衡分流。</li>
<li>确保服务器的系统文件是最新的版本，并及时更新系统补丁。</li>
<li>添加抗 DDos 设备，进行流量清洗。</li>
<li>限制同时打开的 SYN 半连接数目，缩短 SYN 半连接的 Timeout 时间。</li>
<li>限制单 IP 请求频率。</li>
<li>防火墙等防护设置禁止 ICMP 包等。</li>
<li>严格限制对外开放的服务器的向外访问。</li>
<li>运行端口映射程序或端口扫描程序，要认真检查特权端口和非特权端口。</li>
<li>关闭不必要的服务。</li>
<li>认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更,那这台机器就可能遭到了攻击。</li>
<li>限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。</li>
<li>加钱堆机器。。</li>
<li>报警。。</li>
</ul>
<h3 id="应用层-DDoS"><a href="#应用层-DDoS" class="headerlink" title="应用层 DDoS"></a>应用层 DDoS</h3><p>应用层 DDoS 攻击不是发生在网络层，是发生在 TCP 建立握手成功之后，应用程序处理请求的时候，现在很多常见的 DDoS 攻击都是应用层攻击。应用层攻击千变万化，目的就是在网络应用层耗尽你的带宽，下面列出集中典型的攻击类型。</p>
<p><strong>CC 攻击</strong></p>
<p>当时绿盟为了防御 DDoS 攻击研发了一款叫做 <code>Collapasar</code> 的产品，能够有效的防御 SYN Flood 攻击。黑客为了挑衅，研发了一款 <code>Challenge Collapasar</code> 攻击工具（简称 CC）。</p>
<p>CC 攻击的原理，就是针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。因此在发送 CC 攻击前，我们需要寻找加载比较慢，消耗资源比较多的网页，比如需要查询数据库的页面、读写硬盘文件的等。通过 CC 攻击，使用爬虫对某些加载需要消耗大量资源的页面发起 HTTP 请求。</p>
<p><strong>DNS Flood</strong></p>
<p>DNS Flood 攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名，被攻击的DNS 服务器在接收到域名解析请求的时候首先会在服务器上查找是否有对应的缓存，如果查找不到并且该域名无法直接由服务器解析的时候，DNS 服务器会向其上层 DNS 服务器递归查询域名信息。域名解析的过程给服务器带来了很大的负载，每秒钟域名解析请求超过一定的数量就会造成 DNS 服务器解析域名超时。</p>
<p>根据微软的统计数据，一台 DNS 服务器所能承受的动态域名查询的上限是每秒钟 9000 个请求。而我们知道，在一台 P3 的 PC 机上可以轻易地构造出每秒钟几万个域名解析请求，足以使一台硬件配置极高的 DNS 服务器瘫痪，由此可见 DNS 服务器的脆弱性。</p>
<p><strong>HTTP 慢速连接攻击</strong></p>
<p>针对 HTTP 协议，先建立起 HTTP 连接，设置一个较大的 Conetnt-Length，每次只发送很少的字节，让服务器一直以为 HTTP 头部没有传输完成，这样连接一多就很快会出现连接耗尽。</p>
<h3 id="应用层-DDoS-防御"><a href="#应用层-DDoS-防御" class="headerlink" title="应用层 DDoS 防御"></a>应用层 DDoS 防御</h3><ul>
<li>判断 User-Agent 字段（不可靠，因为可以随意构造）</li>
<li>针对 IP + cookie，限制访问频率（由于 cookie 可以更改，IP 可以使用代理，或者肉鸡，也不可靠)</li>
<li>关闭服务器最大连接数等，合理配置中间件，缓解 DDoS 攻击。</li>
<li>请求中添加验证码，比如请求中有数据库操作的时候。</li>
<li>编写代码时，尽量实现优化，并合理使用缓存技术，减少数据库的读取操作。</li>
<li>加钱堆机器。。</li>
<li>报警。。</li>
</ul>
<p>应用层的防御有时比网络层的更难，因为导致应用层被 DDoS 攻击的因素非常多，有时往往是因为程序员的失误，导致某个页面加载需要消耗大量资源，有时是因为中间件配置不当等等。而应用层 DDoS 防御的核心就是区分人与机器（爬虫），因为大量的请求不可能是人为的，肯定是机器构造的。因此如果能有效的区分人与爬虫行为，则可以很好地防御此攻击。</p>
<h3 id="其他-DDoS-攻击"><a href="#其他-DDoS-攻击" class="headerlink" title="其他 DDoS 攻击"></a>其他 DDoS 攻击</h3><p>发起 DDoS 也是需要大量的带宽资源的，但是互联网就像森林，林子大了什么鸟都有，DDoS 攻击者也能找到其他的方式发起廉价并且极具杀伤力的 DDoS 攻击。</p>
<p><strong>利用 XSS</strong></p>
<p>举个例子，如果 12306 页面有一个 XSS 持久型漏洞被恶意攻击者发现，只需在春节抢票期间在这个漏洞中执行脚本使得往某一个小站点随便发点什么请求，然后随着用户访问的增多，感染用户增多，被攻击的站点自然就会迅速瘫痪了。这种 DDoS 简直就是无本万利，不用惊讶，现在大站有 XSS 漏洞的不要太多。</p>
<p><strong>来自 P2P 网络攻击</strong></p>
<p>大家都知道，互联网上的 P2P 用户和流量都是一个极为庞大的数字。如果他们都去一个指定的地方下载数据，成千上万的真实 IP 地址连接过来，没有哪个设备能够支撑住。拿 BT 下载来说，伪造一些热门视频的种子，发布到搜索引擎，就足以骗到许多用户和流量了，但是这只是基础攻击。</p>
<p>高级的 P2P 攻击，是直接欺骗资源管理服务器。如迅雷客户端会把自己发现的资源上传到资源管理服务器，然后推送给其它需要下载相同资源的用户，这样，一个链接就发布出去。通过协议逆向，攻击者伪造出大批量的热门资源信息通过资源管理中心分发出去，瞬间就可以传遍整个 P2P 网络。更为恐怖的是，这种攻击是无法停止的，即使是攻击者自身也无法停止，攻击一直持续到 P2P 官方发现问题更新服务器且下载用户重启下载软件为止。</p>
<blockquote>
<p>最后总结下，DDoS 不可能防的住，就好比你的店只能容纳 50 人，黑社会有 100 人，你就换一家大店，能容纳 500 人，然后黑社会又找来了 1000 人，这种堆人头的做法就是 DDoS 本质上的攻防之道，「道高一尺，魔高一丈，魔高一尺，道高一丈」，讲真，必要的时候就答应勒索你的人的条件吧，实在不行就报警吧。</p>
</blockquote>
<h2 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h2><p>流量劫持应该算是黑产行业的一大经济支柱了吧？简直是让人恶心到吐，不吐槽了，还是继续谈干货吧，流量劫持基本分两种：<code>DNS 劫持</code> 和 <code>HTTP 劫持</code>，目的都是一样的，就是当用户访问 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 的时候，给你展示的并不是或者不完全是 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 提供的 “内容”。</p>
<h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持，也叫做域名劫持，可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了</strong>」，DNS 的作用是把网络地址域名对应到真实的计算机能够识别的 IP 地址，以便计算机能够进一步通信，传递网址和内容等。如果当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。<br><img src="/2018/10/23/Web-安全攻防总结/dns.jpg" alt="dns劫持"><br>这类劫持，要不就是网络运营商搞的鬼，一般小的网络运营商与黑产勾结会劫持 DNS，要不就是电脑中毒，被恶意篡改了路由器的 DNS 配置，基本上做为开发者或站长却是很难察觉的，除非有用户反馈，现在升级版的 DNS 劫持还可以对特定用户、特定区域等使用了用户画像进行筛选用户劫持的办法，另外这类广告显示更加随机更小，一般站长除非用户投诉否则很难觉察到，就算觉察到了取证举报更难。无论如何，如果接到有 DNS 劫持的反馈，一定要做好以下几件事：</p>
<ul>
<li>取证很重要，时间、地点、IP、拨号账户、截屏、URL 地址等一定要有。</li>
<li>可以跟劫持区域的电信运营商进行投诉反馈。</li>
<li>如果投诉反馈无效，直接去工信部投诉，一般来说会加白你的域名。</li>
</ul>
<h3 id="HTTP-劫持"><a href="#HTTP-劫持" class="headerlink" title="HTTP 劫持"></a>HTTP 劫持</h3><p>HTTP 劫持您可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告</strong>」，HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面，轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私。能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。</p>
<p>HTTPS 协议就是一种基于 SSL 协议的安全加密网络应用层协议，可以很好的防止 HTTP 劫持。这里有篇 <a href="https://www.jianshu.com/p/13a1b955d095" target="_blank" rel="noopener">文章</a> 讲的不错。HTTPS 在这就不深讲了，后面有机会我会单独好好讲讲 HTTPS。如果不想站点被 HTTP 劫持，赶紧将你的站点全站改造成 HTTPS 吧。</p>
<h2 id="服务器漏洞"><a href="#服务器漏洞" class="headerlink" title="服务器漏洞"></a>服务器漏洞</h2><p>服务器除了以上提到的那些大名鼎鼎的漏洞和臭名昭著的攻击以外，其实还有很多其他的漏洞，往往也很容易被忽视，在这个小节也稍微介绍几种。</p>
<h3 id="越权操作漏洞"><a href="#越权操作漏洞" class="headerlink" title="越权操作漏洞"></a>越权操作漏洞</h3><p>如果你的系统是有登录控制的，那就要格外小心了，因为很有可能你的系统越权操作漏洞，越权操作漏洞可以简单的总结为 「<strong>A 用户能看到或者操作 B 用户的隐私内容</strong>」，如果你的系统中还有权限控制就更加需要小心了。所以每一个请求都需要做 userid 的判断</p>
<p>以下是一段有漏洞的后端示意代码：</p>
<pre><code>// ctx 为请求的 context 上下文
let msgId = ctx.params.msgId;

mysql.query(
&apos;SELECT * FROM msg_table WHERE msg_id = ?&apos;,
    [msgId]
);
</code></pre><p>以上代码是任何人都可以查询到任何用户的消息，只要有 msg_id 就可以，这就是比较典型的越权漏洞，需要如下这么改进一下：</p>
<pre><code>// ctx 为请求的 context 上下文
let msgId = ctx.params.msgId;
let userId = ctx.session.userId; // 从会话中取出当前登陆的 userId

mysql.query(
&apos;SELECT * FROM msg_table WHERE msg_id = ? AND user_id = ?&apos;,
    [msgId, userId]
);
</code></pre><p>嗯，大概就是这个意思，如果有更严格的权限控制，那在每个请求中凡是涉及到数据库的操作都需要先进行严格的验证，并且在设计数据库表的时候需要考虑进 userId 的账号关联以及权限关联。</p>
<h3 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h3><p>目录遍历漏洞指通过在 URL 或参数中构造 <code>../</code>，<code>./</code> 和类似的跨父目录字符串的 ASCII 编码、unicode 编码等，完成目录跳转，读取操作系统各个目录下的敏感文件，也可以称作「任意文件读取漏洞」。</p>
<p>目录遍历漏洞原理：程序没有充分过滤用户输入的 <code>../</code> 之类的目录跳转符，导致用户可以通过提交目录跳转来遍历服务器上的任意文件。使用多个<code>..</code> 符号，不断向上跳转，最终停留在根 <code>/</code>，通过绝对路径去读取任意文件。</p>
<p>目录遍历漏洞几个示例和测试，一般构造 URL 然后使用浏览器直接访问，或者使用 Web 漏洞扫描工具检测，当然也可以自写程序测试。</p>
<pre><code>http://somehost.com/../../../../../../../../../etc/passwd
http://somehost.com/some/path?file=../../Windows/system.ini

# 借助 %00 空字符截断是一个比较经典的攻击手法
http://somehost.com/some/path?file=../../Windows/system.ini%00.js

# 使用了 IIS 的脚本目录来移动目录并执行指令
http://somehost.com/scripts/..%5c../Windows/System32/cmd.exe?/c+dir+c:\
</code></pre><p><strong>防御</strong> 方法就是需要对 URL 或者参数进行 <code>../</code>，<code>./</code> 等字符的转义过滤。</p>
<h3 id="物理路径泄漏"><a href="#物理路径泄漏" class="headerlink" title="物理路径泄漏"></a>物理路径泄漏</h3><p>物理路径泄露属于低风险等级缺陷，它的危害一般被描述为「攻击者可以利用此漏洞得到信息，来对系统进一步地攻击」，通常都是系统报错 500 的错误信息直接返回到页面可见导致的漏洞。得到物理路径有些时候它能给攻击者带来一些有用的信息，比如说：可以大致了解系统的文件目录结构；可以看出系统所使用的第三方软件；也说不定会得到一个合法的用户名（因为很多人把自己的用户名作为网站的目录名）。</p>
<p>防止这种泄漏的方法就是做好后端程序的出错处理，定制特殊的 500 报错页面。</p>
<h3 id="源码暴露漏洞"><a href="#源码暴露漏洞" class="headerlink" title="源码暴露漏洞"></a>源码暴露漏洞</h3><p>和物理路径泄露类似，就是攻击者可以通过请求直接获取到你站点的后端源代码，然后就可以对系统进一步研究攻击。那么导致源代码暴露的原因是什么呢？基本上就是发生在服务器配置上了，服务器可以设置哪些路径的文件才可以被直接访问的，这里给一个 koa 服务起的例子，正常的 koa 服务器可以通过 koa-static 中间件去指定静态资源的目录，好让静态资源可以通过路径的路由访问。比如你的系统源代码目录是这样的：</p>
<pre><code>|- project
    |- src
    |- static
    |- ...
|- server.js
</code></pre><p>你想要将 static 的文件夹配成静态资源目录，你应该会在 <code>server.js</code> 做如下配置：</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const serve = require(&apos;koa-static&apos;);
const app = new Koa();

app.use(serve(__dirname + &apos;/project/static&apos;));
</code></pre><p>但是如果配错了静态资源的目录，可能就出大事了，比如：</p>
<pre><code>// ...
app.use(serve(__dirname + &apos;/project&apos;));
</code></pre><p>这样所有的源代码都可以通过路由访问到了，所有的服务器都提供了静态资源机制，所以在通过服务器配置静态资源目录和路径的时候，一定要注意检验，不然很可能产生漏洞。</p>
<p>最后，希望 Web 开发者们能够管理好自己的代码隐私，注意代码安全问题，比如不要将产品的含有敏感信息的代码放到第三方外部站点或者暴露给外部用户，尤其是前端代码，私钥类似的保密性的东西不要直接输出在代码里或者页面中。也许还有很多值得注意的点，但是归根结底还是绷住安全那根弦，对待每一行代码都要多多推敲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/21/compose-串联中间件实现-洋葱模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/21/compose-串联中间件实现-洋葱模型/" itemprop="url">compose-串联中间件实现(洋葱模型)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-21T12:41:27+08:00">
                2018-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Koa</code> 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 <code>Express</code> 支持了异步，所以编码时经常使用 <code>async/await</code>，提高了可读性，使代码变得更优雅，上一篇文章 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.pandashen.com%2F2018%2F09%2F02%2F20180902141819%2F" target="_blank" rel="noopener">NodeJS 进阶 —— Koa 源码分析</a>，也对 “洋葱模型” 和实现它的 <code>compose</code> 进行分析，由于个人觉得 <code>compose</code> 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 <code>compose</code>。</p>
<h2 id="洋葱模型案例"><a href="#洋葱模型案例" class="headerlink" title="洋葱模型案例"></a>洋葱模型案例</h2><p>如果你已经使用 <code>Koa</code> 对 “洋葱模型” 这个词一定不陌生，它就是 <code>Koa</code> 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。</p>
<pre><code>const Koa = require(&quot;koa&quot;);

const app = new Koa();

app.use(asycn (ctx, next) =&gt; {
    console.log(1);
    await next();
    console.log(2);
});

app.use(asycn (ctx, next) =&gt; {
    console.log(3);
    await next();
    console.log(4);
});

app.use(asycn (ctx, next) =&gt; {
    console.log(5);
    await next();
    console.log(6);
});

app.listen(3000);

// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>上面的写法我们按照官方推荐，使用了 <code>async/await</code>，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 <code>next</code>，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 <code>Koa</code> 源码中，这一功能是靠一个 <code>compose</code> 方法实现的，我们本文四种实现 <code>compose</code> 的方式中实现同步和异步，并附带对应的案例来验证。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在真正创建 <code>compose</code> 方法之前应该先做些准备工作，比如创建一个 <code>app</code> 对象来顶替 <code>Koa</code> 创建出的实例对象，并添加 <code>use</code> 方法和管理中间件的数组 <code>middlewares</code>。</p>
<p>文件：app.js</p>
<pre><code>// 模拟 Koa 创建的实例
const app = {
    middlewares: []
};

// 创建 use 方法
app.use = function(fn) {
    app.middlewares.push(fn);
};

// app.compose.....

module.exports = app;
</code></pre><p>上面的模块中导出了 <code>app</code> 对象，并创建了存储中间件函数的 <code>middlewares</code> 和添加中间件的 <code>use</code> 方法，因为无论用哪种方式实现 <code>compose</code> 这些都是需要的，只是 <code>compose</code> 逻辑的不同，所以后面的代码块中会只写 <code>compose</code> 方法。</p>
<h2 id="Koa-中-compose-的实现方式"><a href="#Koa-中-compose-的实现方式" class="headerlink" title="Koa 中 compose 的实现方式"></a>Koa 中 compose 的实现方式</h2><p>首先介绍的是 <code>Koa</code> 源码中的实现方式，在 <code>Koa</code> 源码中其实是通过 <code>koa-compose</code> 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 <code>compose</code> 的原理，所以 <code>ctx</code> 参数就被去掉了，因为我们不会使用它，重点是 <code>next</code> 参数。</p>
<h3 id="1、同步的实现"><a href="#1、同步的实现" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    // 递归函数
    function dispatch(index) {
        // 如果所有中间件都执行完跳出
        if (index === app.middlewares.length) return;

        // 取出第 index 个中间件并执行
        const route = app.middlewares[index];
        return route(() =&gt; dispatch(index + 1));
    }

    // 取出第一个中间件函数执行
    dispatch(0);
};
</code></pre><p>上面是同步的实现，通过递归函数 <code>dispatch</code> 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 <code>dispatch</code>，传入的参数 <code>+1</code>，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 <code>1 3 5 6 4 2</code> 的情况执行，测试例子如下（同步上、异步下）。</p>
<p>文件：sync-test.js</p>
<pre><code>const app = require(&quot;./app&quot;);

app.use(next =&gt; {
    console.log(1);
    next();
    console.log(2);
});

app.use(next =&gt; {
    console.log(3);
    next();
    console.log(4);
});

app.use(next =&gt; {
    console.log(5);
    next();
    console.log(6);
});

app.compose();
// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>文件：async-test.js</p>
<pre><code>const app = require(&quot;./app&quot;);

// 异步函数
functionfn() {
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
            resolve();
            console.log(&quot;hello&quot;);
        }, 3000);
    });
}

app.use(async next =&gt; {
    console.log(1);
    await next();
    console.log(2);
});

app.use(async next =&gt; {
    console.log(3);
    await fn(); // 调用异步函数
    await next();
    console.log(4);
});

app.use(async next =&gt; {
    console.log(5);
    await next();
    console.log(6);
});

app.compose();
</code></pre><p>我们发现如果案例中按照 <code>Koa</code> 的推荐写法，即使用 <code>async</code> 函数，都会通过，但是在给 <code>use</code> 传参时可能会传入普通函数或 <code>async</code> 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 <code>Koa</code> 中 <code>compose</code> 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。</p>
<p>注意：后面 <code>compose</code> 的其他实现方式中，都是使用 <code>sync-test.js</code> 和 <code>async-test.js</code> 验证，所以后面就不再重复了。</p>
<h3 id="2、升级为支持异步"><a href="#2、升级为支持异步" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    // 递归函数
    function dispatch(index) {
        // 如果所有中间件都执行完跳出，并返回一个 Promise
        if (index === app.middlewares.length) return Promise.resolve();

        // 取出第 index 个中间件并执行
        const route = app.middlewares[index];

        // 执行后返回成功态的 Promise
        return Promise.resolve(route(() =&gt; dispatch(index + 1)));
    }

    // 取出第一个中间件函数执行
    dispatch(0);
};
</code></pre><p>我们知道 <code>async</code> 函数中 <code>await</code> 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 <code>async-test.js</code>进行测试，发现结果为 <code>1 3 hello(3s后) 5 6 4 2</code>。</p>
<h2 id="Redux-旧版本-compose-的实现方式"><a href="#Redux-旧版本-compose-的实现方式" class="headerlink" title="Redux 旧版本 compose 的实现方式"></a>Redux 旧版本 compose 的实现方式</h2><h3 id="1、同步的实现-1"><a href="#1、同步的实现-1" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    return app.middlewares.reduceRight((a, b) =&gt; () =&gt; b(a), () =&gt; {})();
};
</code></pre><p>上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 <code>middlewares</code> 中存储的三个中间件函数分别为 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于使用的是 <code>reduceRight</code> 方法，所以是逆序归并，第一次 <code>a</code> 代表初始值（空函数），<code>b</code> 代表 <code>fn3</code>，而执行 <code>fn3</code> 返回了一个函数，这个函数再作为下一次归并的 <code>a</code>，而 <code>fn2</code> 作为 <code>b</code>，依次类推，过程如下。</p>
<pre><code>// 第 1 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn3(() =&gt; {});

// 第 2 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn2(() =&gt; fn3(() =&gt; {}));

// 第 3 次 reduceRight 的返回值，下一次将作为 a
() =&gt; fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {})));
</code></pre><p>由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 <code>fn1</code>，如果调用 <code>next</code> 则会执行 <code>fn2</code>，如果同样调用 <code>next</code> 则会执行 <code>fn3</code>，<code>fn3</code> 已经是最后一个中间件函数了，再次调 <code>next</code> 会执行我们最初传入的空函数，这也是为什么要将 <code>reduceRight</code> 的初始值设置成一个空函数，就是防止最后一个中间件调用 <code>next</code> 而报错。</p>
<p>经过测试上面的代码不会出现顺序错乱的情况，但是在 <code>compose</code> 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 <code>use</code> 的中间件函数既可以是普通函数，又可以是 <code>async</code> 函数，这就要我们的 <code>compose</code> 完全支持异步。</p>
<h3 id="2、升级为支持异步-1"><a href="#2、升级为支持异步-1" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    return Promise.resolve(
        app.middlewares.reduceRight(
            (a, b) =&gt; () =&gt; Promise.resolve(b(a)),
            () =&gt; Promise.resolve();
        )()
    );
};
</code></pre><p>参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 <code>next</code> 后又调用了 <code>then</code>），都处理成了 Promise，保证了 <code>reduceRight</code> 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 <code>async</code> 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 <code>compose</code> 就可以调用 <code>then</code> 方法执行后续逻辑。</p>
<h2 id="Redux-新版本-compose-的实现方式"><a href="#Redux-新版本-compose-的实现方式" class="headerlink" title="Redux 新版本 compose 的实现方式"></a>Redux 新版本 compose 的实现方式</h2><h3 id="1、同步的实现-2"><a href="#1、同步的实现-2" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p>
<pre><code>app.compose = function() {
    return app.middlewares.reduce((a, b) =&gt; arg =&gt; a(() =&gt; b(arg)))(() =&gt; {});
};
</code></pre><p><code>Redux</code> 新版本中将 <code>compose</code> 的逻辑做了些改动，将原本的 <code>reduceRight</code> 换成 <code>reduce</code>，也就是说将逆序归并改为了正序，我们不一定和 <code>Redux</code> 源码完全相同，是根据相同的思路来实现串行中间件的需求。</p>
<p>个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于 <code>reduce</code> 并没有传入初始值，所以此时 <code>a</code> 为 <code>fn1</code>，<code>b</code> 为 <code>fn2</code>。</p>
<pre><code>// 第 1 次 reduce 的返回值，下一次将作为 a
arg =&gt; fn1(() =&gt; fn2(arg));

// 第 2 次 reduce 的返回值，下一次将作为 a
arg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg));

// 等价于...
arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg)));

// 执行最后返回的函数连接中间件，返回值等价于...
fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {})));
</code></pre><p>所以在调用 <code>reduce</code> 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 <code>fn3</code>，也就是第三个中间件，这样保证了在最后一个中间件调用 <code>next</code> 时不会报错。</p>
<h3 id="2、升级为支持异步-2"><a href="#2、升级为支持异步-2" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。</p>
<p>文件：app.js</p>
<pre><code>app.compose = function() {
    return Promise.resolve(
        app.middlewares.reduce((a, b) =&gt; arg =&gt;
            Promise.resolve(a(() =&gt; b(arg)))
        )(() =&gt; Promise.resolve())
    );
};
</code></pre><p>实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 <code>compose</code> 也返回 Promise。</p>
<h2 id="使用-async-函数实现"><a href="#使用-async-函数实现" class="headerlink" title="使用 async 函数实现"></a>使用 async 函数实现</h2><p>这个版本是我在之前在学习 <code>Koa</code> 源码时偶然在一位大佬的一篇分析 <code>Koa</code> 原理的文章中看到的（翻了半天实在没找到链接），在这里也拿出来和大家分享一下，由于是利用 <code>async</code> 函数实现的，所以默认就是支持异步的，因为 <code>async</code> 函数会返回一个 Promise。</p>
<p>文件：app.js</p>
<pre><code>app.compose = function() {
    // 自执行 async 函数返回 Promise
    return (async function () {
        // 定义默认的 next，最后一个中间件内执行的 next
        let next = async () =&gt; Promise.resolve();

        // middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next
        // 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题
        function createNext(middleware, oldNext) {
            return async () =&gt; {
                await middleware(oldNext);
            }
        }

        // 反向遍历中间件数组，先把 next 传给最后一个中间件函数
        // 将新的中间件函数存入 next 变量
        // 调用下一个中间件函数，将新生成的 next 传入
        for (let i = app.middlewares.length - 1; i &gt;= 0; i--) {
            next = createNext(app.middlewares[i], next);
        }

        await next();
    })();
};
</code></pre><p>上面代码中的 <code>next</code> 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 <code>next</code>，而数组 <code>middlewares</code> 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 <code>createNext</code>作用是返回一个新的可以执行数组中最后一个中间件的 <code>async</code> 函数，并传入了初始的 <code>next</code>，这个返回的 <code>async</code> 函数作为新的 <code>next</code>，再取到倒数第二个中间件，调用 <code>createNext</code>，又返回了一个 <code>async</code> 函数，函数内依然是倒数第二个中间件的执行，传入的 <code>next</code> 就是上次新生成的 <code>next</code>，这样依次类推到第一个中间件。</p>
<p>因此执行第一个中间件返回的 <code>next</code> 则会执行传入的上一个生成的 <code>next</code> 函数，就会执行第二个中间件，就会执行第二个中间件中的 <code>next</code>，就这样直到执行完最初定义的的 <code>next</code>，通过案例的验证，执行结果与洋葱模型完全相同。</p>
<p>至于异步的问题，每次执行的 <code>next</code> 都是 <code>async</code> 函数，执行后返回的都是 Promise，而最外层的自执行 <code>async</code> 函数返回的也是 Promise，也就是说 <code>compose</code> 最后返回的是 Promise，因此完全支持异步。</p>
<p>这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>或许你看完这几种方式会觉得，还是 <code>Koa</code> 对于 <code>compose</code> 的实现方式最容易理解，你也可能和我一样在感慨 <code>Redux</code> 的两种实现方式和 <code>async</code> 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想，写出 <code>compose</code> 这种优雅又高逼格的代码，路漫漫其修远兮，愿你在技术的路上 “一去不复返”。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/10/koa-bodyparser中间件模拟/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/10/koa-bodyparser中间件模拟/" itemprop="url">koa-bodyparser中间件模拟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-10T23:05:34+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Koa 2.x</code> 版本是当下最流行的 NodeJS 框架，<code>Koa 2.0</code> 的源码特别精简，不像 <code>Express</code> 封装的功能那么多，所以大部分的功能都是由 <code>Koa</code> 开发团队（同 <code>Express</code> 是一家出品）和社区贡献者针对 <code>Koa</code> 对 NodeJS 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 <code>Koa</code> 的 <code>use</code> 方法使用在对应的位置，这样就可以通过在内部操作 <code>ctx</code> 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 <code>Koa</code> 中间件供自己和别人使用。</p>
<h2 id="Koa-的洋葱模型介绍"><a href="#Koa-的洋葱模型介绍" class="headerlink" title="Koa 的洋葱模型介绍"></a>Koa 的洋葱模型介绍</h2><p>我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 API 的使用方式及洋葱模型分析中间件是如何工作的。</p>
<pre><code>// 洋葱模型特点// 引入 Koa
const Koa = require(&quot;koa&quot;);

// 创建服务
const app = new Koa();

app.use(async (ctx, next) =&gt; {
    console.log(1);
    await next();
    console.log(2);
});

app.use(async (ctx, next) =&gt; {
    console.log(3);
    await next();
    console.log(4);
});

app.use(async (ctx, next) =&gt; {
    console.log(5);
    await next();
    console.log(6);
});

// 监听服务
app.listen(3000);

// 1
// 3
// 5
// 6
// 4
// 2
</code></pre><p>我们知道 <code>Koa</code> 的 <code>use</code> 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 <code>next</code> 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 <code>Koa</code> 中都是建议使用 <code>async/await</code> 的，引入的中间件都是在 <code>use</code> 方法中调用，由此我们可以分析出每一个 <code>Koa</code> 的中间件都是返回一个 <code>async</code> 函数的。</p>
<h2 id="koa-bodyparser-中间件模拟"><a href="#koa-bodyparser-中间件模拟" class="headerlink" title="koa-bodyparser 中间件模拟"></a>koa-bodyparser 中间件模拟</h2><p>想要分析 <code>koa-bodyparser</code> 的原理首先需要知道用法和作用，<code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值，使用前需提前安装。</p>
<blockquote>
<p>npm install koa koa-bodyparser</p>
</blockquote>
<p><strong>koa-bodyparser 具体用法如下：</strong></p>
<pre><code>// koa-bodyparser 的用法
const Koa = require(&quot;koa&quot;);
const bodyParser = require(&quot;koa-bodyparser&quot;);

const app = new Koa();

// 使用中间件
app.use(bodyParser());

app.use(async (ctx, next) =&gt; {
    if (ctx.path === &quot;/&quot; &amp;&amp; ctx.method === &quot;POST&quot;) {
        // 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据
        console.log(ctx.request.body);
    }
});

app.listen(3000);
</code></pre><p>根据用法我们可以看出 <code>koa-bodyparser</code> 中间件引入的其实是一个函数，我们把它放在了 <code>use</code> 中执行，根据 <code>Koa</code> 的特点，我们推断出 <code>koa-bodyparser</code> 的函数执行后应该给我们返回了一个 <code>async</code> 函数，下面是我们模拟实现的代码。</p>
<pre><code>// 文件：my-koa-bodyparser.js
const querystring = require(&quot;querystring&quot;);

module.exports = functionbodyParser() {
    returnasync (ctx, next) =&gt; {
        await new Promise((resolve, reject) =&gt; {
            // 存储数据的数组
            let dataArr = [];

            // 接收数据
            ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data));

            // 整合数据并使用 Promise 成功
            ctx.req.on(&quot;end&quot;, () =&gt; {
                // 获取请求数据的类型 json 或表单
                let contentType = ctx.get(&quot;Content-Type&quot;);

                // 获取数据 Buffer 格式
                let data = Buffer.concat(dataArr).toString();

                if (contentType === &quot;application/x-www-form-urlencoded&quot;) {
                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body
                    ctx.request.body = querystring.parse(data);
                } elseif (contentType === &quot;applaction/json&quot;) {
                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body
                    ctx.request.body = JSON.parse(data);
                }

                // 执行成功的回调
                resolve();
            });
        });

        // 继续向下执行
        await next();
    };
};
</code></pre><p>在上面代码中由几点是需要我们注意的，即 <code>next</code> 的调用以及为什么通过流接收数据、处理数据和将数据挂在 <code>ctx.request.body</code> 要在 Promise 中进行。</p>
<p><strong>首先是 <code>next</code> 的调用，我们知道 <code>Koa</code> 的 <code>next</code> 执行，其实就是在执行下一个中间件的函数，即下一个 <code>use</code> 中的 <code>async</code> 函数，为了保证后面的异步代码执行完毕后再继续执行当前的代码，所以我们需要使用 <code>await</code> 进行等待，其次就是数据从接收到挂在 <code>ctx.request.body</code> 都在 Promise 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 <code>ctx.request.body</code> 上，可以保证我们在下一个 <code>use</code> 的 <code>async</code> 函数中可以在 <code>ctx.request.body</code> 上拿到数据，所以我们使用 <code>await</code> 等待一个 Promise 成功后再执行 <code>next</code>。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">108</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


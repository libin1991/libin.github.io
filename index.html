<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>LuckDay</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/JavaScript-中的-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/02/JavaScript-中的-this/" itemprop="url">JavaScript 中的 this !</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T22:53:27+08:00">
                2018-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/vue2-0模板渲染底层思想/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/02/vue2-0模板渲染底层思想/" itemprop="url">vue2.0模板渲染底层思想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T22:34:21+08:00">
                2018-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>初衷</p>
<p>在使用vue2.0的过程，有时看API很难理解vue作者的思想，这促使我想要去深入了解vue底层的思想，了解完底层的一些思想，才能更好的用活框架，虽然网上已经有很多源码解析的文档，但我觉得只有自己动手了，才能更加深印象。</p>
<p>vue2.0和1.0模板渲染的区别</p>
<p>Vue 2.0 中模板渲染与 Vue 1.0 完全不同，1.0 中采用的 DocumentFragment （<a href="https://link.zhihu.com/?target=https%3A//juejin.im/entry/59116fa6a0bb9f0058aaaa4c" target="_blank" rel="noopener">想了解可以观看这篇文章</a>），而 2.0 中借鉴 React 的 Virtual DOM。基于 Virtual DOM，2.0 还可以支持服务端渲染（SSR），也支持 JSX 语法（改良版的 render 函数）。</p>
<p>知识普及</p>
<p>在开始阅读源码之前，先了解一些相关的知识：AST 数据结构，VNode 数据结构，createElement 的问题，render函数。</p>
<p>AST 数据结构</p>
<p>AST 的全称是 Abstract Syntax Tree（抽象语法树），是源代码的抽象语法结构的树状表现形式，计算机学科中编译原理的概念。而vue就是将模板代码映射为AST数据结构，进行语法解析。</p>
<p>我们看一下 Vue 2.0 源码中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/flow/compiler.js%23L63-L142" target="_blank" rel="noopener">AST 数据结构</a> 的定义：</p>
<pre><code>declare type ASTNode = ASTElement | ASTText | ASTExpression
declare type ASTElement = { // 有关元素的一些定义
  type: 1;
  tag: string;
  attrsList: Array&lt;{ name: string; value: string }&gt;;
  attrsMap: { [key: string]: string | null };
  parent: ASTElement | void;
  children: Array&lt;ASTNode&gt;;
  //......
}
declare type ASTExpression = {
  type: 2;
  expression: string;
  text: string;
  static?: boolean;
}
declare type ASTText = {
  type: 3;
  text: string;
  static?: boolean;
}
</code></pre><p>我们看到 ASTNode 有三种形式：ASTElement，ASTText，ASTExpression。用属性 type 区分。</p>
<p>VNode数据结构</p>
<p>下面是 Vue 2.0 源码中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/vdom/vnode.js%23L23-L50" target="_blank" rel="noopener">VNode 数据结构</a> 的定义 (带注释的跟下面介绍的内容有关)：</p>
<pre><code>constructor {
  this.tag = tag   //元素标签
  this.data = data  //属性
  this.children = children  //子元素列表
  this.text = text
  this.elm = elm  //对应的真实 DOM 元素
  this.ns = undefined
  this.context = context 
  this.functionalContext = undefined
  this.key = data &amp;&amp; data.key
  this.componentOptions = componentOptions
  this.componentInstance = undefined
  this.parent = undefined
  this.raw = false
  this.isStatic = false //是否被标记为静态节点
  this.isRootInsert = true
  this.isComment = false
  this.isCloned = false
  this.isOnce = false
}
</code></pre><p>真实DOM存在什么问题，为什么要用虚拟DOM</p>
<p>我们为什么不直接使用原生 DOM 元素，而是使用真实 DOM 元素的简化版 VNode，最大的原因就是 document.createElement 这个方法创建的真实 DOM 元素会带来性能上的损失。我们来看一个 document.createElement 方法的例子</p>
<pre><code>let div = document.createElement(&apos;div&apos;);
for(let k in div) {
  console.log(k);
}
</code></pre><p>打开 console 运行一下上面的代码，会发现打印出来的属性多达 228 个，而这些属性有 90% 多对我们来说都是无用的。VNode 就是简化版的真实 DOM 元素，关联着真实的dom，比如属性elm，只包括我们需要的属性，并新增了一些在 diff 过程中需要使用的属性，例如 isStatic。</p>
<p>render函数</p>
<p>这个函数是通过编译模板文件得到的，其运行结果是 VNode。render 函数 与 JSX 类似，Vue 2.0 中除了 Template 也支持 JSX 的写法。大家可以使用 <a href="https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/api/%3F%23Vue-compile" target="_blank" rel="noopener">Vue.compile(template)</a>方法编译下面这段模板。</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;I am a template!&lt;/h1&gt;
  &lt;/header&gt;
  &lt;p v-if=&quot;message&quot;&gt;
    {{ message }}
  &lt;/p&gt;
  &lt;p v-else&gt;
    No message.
  &lt;/p&gt;
&lt;/div&gt;
</code></pre><p>方法会返回一个对象，对象中有 render 和 staticRenderFns 两个值。看一下生成的 render函数</p>
<pre><code>(function() {
  with(this){
    return _c(&apos;div&apos;,{   //创建一个 div 元素
      attrs:{&quot;id&quot;:&quot;app&quot;}  //div 添加属性 id
      },[
        _m(0),  //静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render 函数
        _v(&quot; &quot;), //空的文本节点
        (message) //三元表达式，判断 message 是否存在
         //如果存在，创建 p 元素，元素里面有文本，值为 toString(message)
        ?_c(&apos;p&apos;,[_v(&quot;\n    &quot;+_s(message)+&quot;\n  &quot;)])
        //如果不存在，创建 p 元素，元素里面有文本，值为 No message. 
        :_c(&apos;p&apos;,[_v(&quot;\n    No message.\n  &quot;)])
      ]
    )
  }
})
</code></pre><p>要看懂上面的 render函数，只需要了解 _c，_m，_v，_s 这几个函数的定义，其中 _c 是 createElement（创建元素），_m 是 renderStatic（渲染静态节点），_v 是 createTextVNode（创建文本dom），_s 是 toString （转换为字符串）</p>
<p>除了 render 函数，还有一个 staticRenderFns 数组，这个数组中的函数与 VDOM 中的 diff 算法优化相关，我们会在编译阶段给后面不会发生变化的 VNode 节点打上 static 为 true 的标签，那些被标记为静态节点的 VNode 就会单独生成 staticRenderFns 函数</p>
<pre><code>(function() { //上面 render 函数 中的 _m(0) 会调用这个方法
  with(this){
    return _c(&apos;header&apos;,[_c(&apos;h1&apos;,[_v(&quot;I&apos;m a template!&quot;)])])
  }
})
</code></pre><p>模板渲染过程（重要的函数介绍）</p>
<p>了解完一些基础知识后，接下来我们讲解下模板的渲染过程</p>
<p><img src="https://pic2.zhimg.com/v2-4a8793499b4d1a5395f2b5f7d0584a4b_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-4a8793499b4d1a5395f2b5f7d0584a4b_hd.jpg" alt=""><br><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/entries/web-runtime-with-compiler.js%23L14-L67" target="_blank" rel="noopener">$mount</a> 函数，主要是获取 template，然后进入 compileToFunctions 函数。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/platforms/web/compiler/index.js%23L36-L84" target="_blank" rel="noopener">compileToFunctions</a> 函数，主要将 template 编译成 render 函数。首先读缓存，没有缓存就调用 compile 方法拿到 render 函数 的字符串形式，再通过 new Function 的方式生成 render 函数。</p>
<pre><code>// 有缓存的话就直接在缓存里面拿
const key = options &amp;&amp; options.delimiters
            ? String(options.delimiters) + template
            : template
if (cache[key]) {
    return cache[key]
}
const res = {}
const compiled = compile(template, options) // compile 后面会详细讲
res.render = makeFunction(compiled.render) //通过 new Function 的方式生成 render 函数并缓存
const l = compiled.staticRenderFns.length
res.staticRenderFns = new Array(l)
for (let i = 0; i &lt; l; i++) {
    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i])
}
......
}
return (cache[key] = res) // 记录至缓存中
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/index.js" target="_blank" rel="noopener">compile</a> 函数就是将 template 编译成 render 函数的字符串形式，后面一小节我们会详细讲到。</p>
<p>完成render方法的生成后，会进入 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/instance/lifecycle.js%23L38-L75" target="_blank" rel="noopener">_mount</a> 中进行DOM更新。该方法的核心逻辑如下：</p>
<pre><code>// 触发 beforeMount 生命周期钩子
callHook(vm, &apos;beforeMount&apos;)
// 重点：新建一个 Watcher 并赋值给 vm._watcher
vm._watcher = new Watcher(vm, function updateComponent () {
  vm._update(vm._render(), hydrating)
}, noop)
hydrating = false
// manually mounted instance, call mounted on self
// mounted is called for render-created child components in its inserted hook
if (vm.$vnode == null) {
  vm._isMounted = true
  callHook(vm, &apos;mounted&apos;)
}
return vm
</code></pre><p>首先会new一个watcher对象（主要是将模板与数据建立联系），在watcher对象创建后，会运行传入的方法 vm._update(vm._render(), hydrating) 。其中的vm._render()主要作用就是运行前面compiler生成的render方法，并返回一个vNode对象。vm.update() 则会对比新的 vdom 和当前 vdom，并把差异的部分渲染到真正的 DOM 树上。<br>（想深入了解watcher的背后实现原理的，可以观看这篇文章 <a href="https://link.zhihu.com/?target=http%3A//zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/" target="_blank" rel="noopener">Vue2.0 源码阅读：响应式原理</a>）</p>
<p>compile</p>
<p>上文中提到 compile 函数就是将 template 编译成 render 函数 的字符串形式。</p>
<pre><code>export function compile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const AST = parse(template.trim(), options) //1. parse
  optimize(AST, options)  //2.optimize
  const code = generate(AST, options) //3.generate
  return {
    AST,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
}
</code></pre><p>这个函数主要有三个步骤组成：parse，optimize 和 generate，分别输出一个包含 AST，staticRenderFns 的对象和 render函数 的字符串。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/parser/index.js" target="_blank" rel="noopener">parse</a> 函数，主要功能是将 template字符串解析成 AST。前面定义了ASTElement的数据结构，parse 函数就是将template里的结构（指令，属性，标签等）转换为AST形式存进ASTElement中，最后解析生成AST。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/optimizer.js%23L21-L29" target="_blank" rel="noopener">optimize</a> 函数（src/compiler/optimizer.js）主要功能就是标记静态节点，为后面 patch 过程中对比新旧 VNode 树形结构做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js%23L22-L47" target="_blank" rel="noopener">generate</a> 函数（src/compiler/codegen/index.js）主要功能就是根据 AST 结构拼接生成 render 函数的字符串。</p>
<pre><code>const code = AST ? genElement(AST) : &apos;_c(&quot;div&quot;)&apos; 
staticRenderFns = prevStaticRenderFns
onceCount = prevOnceCount
return {
    render: `with(this){return ${code}}`, //最外层包一个 with(this) 之后返回
    staticRenderFns: currentStaticRenderFns
}
</code></pre><p>其中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js%23L49-L83" target="_blank" rel="noopener">genElement</a> 函数（src/compiler/codegen/index.js）是会根据 AST 的属性调用不同的方法生成字符串返回。</p>
<pre><code>function genElement (el: ASTElement): string {
  if (el.staticRoot &amp;&amp; !el.staticProcessed) {
    return genStatic(el)
  } else if (el.once &amp;&amp; !el.onceProcessed) {
    return genOnce(el)
  } else if (el.for &amp;&amp; !el.forProcessed) {
    return genFor(el)
  } else if (el.if &amp;&amp; !el.ifProcessed) {
    return genIf(el)
  } else if (el.tag === &apos;template&apos; &amp;&amp; !el.slotTarget) {
    return genChildren(el) || &apos;void 0&apos;
  } else if (el.tag === &apos;slot&apos;) {
  }
    return code
  }
}
</code></pre><p>以上就是 compile 函数中三个核心步骤的介绍，compile 之后我们得到了 render 函数 的字符串形式，后面通过 new Function 得到真正的渲染函数。数据发现变化后，会执行 Watcher 中的 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/instance/lifecycle.js%23L77-L114" target="_blank" rel="noopener">_update</a> 函数（src/core/instance/lifecycle.js），_update 函数会执行这个渲染函数，输出一个新的 VNode 树形结构的数据。然后在调用 patch 函数，拿这个新的 VNode 与旧的 VNode 进行对比，只有发生了变化的节点才会被更新到真实 DOM 树上。</p>
<p>patch</p>
<p>patch.js 就是新旧 VNode 对比的 diff 函数，主要是为了优化dom，通过算法使操作dom的行为降到最低，diff 算法来源于 snabbdom，是 VDOM 思想的核心。snabbdom 的算法为了 DOM 操作跨层级增删节点较少的这一目标进行优化，它只会在同层级进行, 不会跨层级比较。</p>
<p>想更加深入VNode diff算法原理的，可以观看（<a href="https://link.zhihu.com/?target=https%3A//github.com/aooy/blog/issues/2" target="_blank" rel="noopener">解析vue2.0的diff算法</a>）</p>
<p>总结</p>
<ul>
<li>compile 函数主要是将 template 转换为 AST，优化 AST，再将 AST 转换为 render函数；</li>
<li>render函数 与数据通过 Watcher 产生关联；</li>
<li>在数据发生变化时调用 patch 函数，执行此 render 函数，生成新 VNode，与旧 VNode 进行 diff，最终更新 DOM 树。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/Git-必知必会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/Git-必知必会/" itemprop="url">Git 必知必会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T22:32:36+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Git是目前世界上最先进的分布式版本控制系统。</p>
<p>参考文章：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a54386af265da3e3b7a6317" target="_blank" rel="noopener">如何优雅地使用 Git - 掘金</a></p>
<h2 id="GIT-常见命令学习整理"><a href="#GIT-常见命令学习整理" class="headerlink" title="GIT 常见命令学习整理"></a><a href="https://link.zhihu.com/?target=https%3A//blog.ihoey.com/posts/Git/2017-04-23-git.html" target="_blank" rel="noopener">GIT 常见命令学习整理</a></h2><h2 id="GIT常用命令备忘"><a href="#GIT常用命令备忘" class="headerlink" title="GIT常用命令备忘"></a><a href="https://link.zhihu.com/?target=http%3A//stormzhang.com/git/2014/01/27/git-common-command/" target="_blank" rel="noopener">GIT常用命令备忘</a></h2><h2 id="Git远程操作详解"><a href="#Git远程操作详解" class="headerlink" title="Git远程操作详解"></a><a href="https://link.zhihu.com/?target=https%3A//microzz.com/2017/05/06/git/" target="_blank" rel="noopener">Git远程操作详解</a></h2><h2 id="一篇文章，教你学会Git"><a href="#一篇文章，教你学会Git" class="headerlink" title="一篇文章，教你学会Git"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/599e14875188251240632702" target="_blank" rel="noopener">一篇文章，教你学会Git</a></h2><h2 id="如何在-Git-中使用撤消操作"><a href="#如何在-Git-中使用撤消操作" class="headerlink" title="如何在 Git 中使用撤消操作"></a><a href="https://link.zhihu.com/?target=https%3A//egoist.moe/2015/10/04/how-to-undo-with-git/" target="_blank" rel="noopener">如何在 Git 中使用撤消操作</a></h2><h2 id="git使用中碰到的问题，持续更新"><a href="#git使用中碰到的问题，持续更新" class="headerlink" title="git使用中碰到的问题，持续更新"></a><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/a420344/article/details/51792303" target="_blank" rel="noopener">git使用中碰到的问题，持续更新</a></h2><h2 id="Git-的-4-个阶段的撤销更改"><a href="#Git-的-4-个阶段的撤销更改" class="headerlink" title="Git 的 4 个阶段的撤销更改"></a><a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/akvB2DO_1dpUrf-ol77MwQ" target="_blank" rel="noopener">Git 的 4 个阶段的撤销更改</a></h2><p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a30c1786fb9a045211eb218" target="_blank" rel="noopener">Git提交历史的修改删除合并 - 掘金</a></p>
<h2 id="IDEA中分支切换error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout"><a href="#IDEA中分支切换error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout" class="headerlink" title="IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout"></a><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/tongxinxiao/article/details/43988773" target="_blank" rel="noopener">IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout</a></h2><pre><code>直接执行git clean -d -fx即可。

可能很多人都不明白-d，-fx到底是啥意思，
其实git clean -d -fx表示：删除 一些 没有 git add 的 文件；
    git clean 参数 

    -n 显示将要删除的文件和目录；

    -x -----删除忽略文件已经对git来说不识别的文件

    -d -----删除未被添加到git的路径中的文件

    -f -----强制运行

    git clean -n

    git clean -df

    git clean -f
</code></pre><p><img src="https://pic3.zhimg.com/v2-81f3b33c3cb53387c97135459b92ab3f_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81f3b33c3cb53387c97135459b92ab3f_hd.jpg" alt=""></p>
<pre><code>git reflog        //该指令输出详细的操作历史，包括提交，操作，修改等
修改注释
git commit --amend 或 git commit --amend -m &quot;Fixes bug #42&quot;

gitk 字符集编码：
git config --global gui.encoding utf-8    //在git GUI中使用UTF-8编码 

配置
git config --global user.name &quot;ihoey&quot;           # 设置git用户名
git config --global user.email &quot;mail@ihoey.com&quot; # 设置git邮箱
git config --global color.ui true               # 为true是终端着色

git config --global alias.co checkout           # 配置checkout的别名
git config --global alias.ci commit             # 配置commit的别名
git config --global alias.cm commit             # 配置commit的别名
git config --global alias.st status             # 配置status的别名
git config --global alias.br branch             # 配置branch的别名
git config --global alias.cp cherry-pick        # 配置cherry-pick的别名
 git config --global alias.rb rebase            # 配置rebase的别名

git config --global core.editor &quot;mate -w&quot;       # 设置Editor使用textmate
git config -l                                   # 列举所有配置
#用户的git配置文件~/.gitconfig

SSH 秘钥
ssh-keygen -t rsa -C &quot;mail@ihoey.com&quot;
# 连续3个回车。如果不需要密码的话。
# 最后得到了两个文件：id_rsa和id_rsa.pub，在~/.ssh/文件夹下面
# id_rsa为你的私钥，不可以告诉别人
# id_rsa.pub为你的公钥，一般会放在你的服务器做ssh登录，或者放在github上面

基本命令
创建git仓库 git init
添加文件到暂存区 git add fileName / git add .
提交文件到仓库 git commit -m &quot;版本提交信息&quot;
查看文件提交状态 git status
查看文件修改的信息 git diff readme.txt

git help &lt;command&gt;          # 显示command的help
git show                    # 显示某次提交的内容
git show $id
git checkout  -- &lt;file&gt;     # 抛弃工作区修改
git checkout  .             # 抛弃工作区修改
git add &lt;file&gt;              # 将工作文件修改提交到本地暂存区
git add .                   # 将所有修改过的工作文件提交暂存区
git rm &lt;file&gt;               # 从版本库中删除文件
git rm &lt;file&gt; --cached      # 从版本库中删除文件，但不删除文件
git reset &lt;file&gt;            # 从暂存区恢复到工作文件
git reset -- .              # 从暂存区恢复到工作文件
git reset --hard            # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改
git reset SHA1 ID           # 恢复指定提交
git commit -m &quot;some comments&quot;
git revert &lt;$id&gt;            # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象
git revert HEAD             # 恢复最后一次提交的状态

查看文件
git diff &lt;file&gt;                 # 比较当前文件和暂存区文件差异
git diff
git diff &lt;$id1&gt; &lt;$id2&gt;          # 比较两次提交之间的差异
git diff &lt;branch1&gt;..&lt;branch2&gt;   # 在两个分支之间比较
git diff --staged               # 比较暂存区和版本库差异
git diff --cached               # 比较暂存区和版本库差异
git diff --stat                 # 仅仅比较统计信息

查看提交记录
git log
git log &lt;file&gt;      # 查看该文件每次提交记录
git log -p &lt;file&gt;   # 查看每次详细修改内容的diff
git log -p -2       # 查看最近两次详细修改内容的diff
git log --stat      # 查看提交统计信息

分支管理
git branch -l                           # 查看本地分支
git branch -r                           # 查看远程分支
git branch &lt;new_branch&gt;                 # 创建新的分支
git branch -v                           # 查看各个分支最后提交信息
git branch --merged                     # 查看已经被合并到当前分支的分支
git branch --no-merged                  # 查看尚未被合并到当前分支的分支
git checkout &lt;branch&gt;                   # 切换到某个分支
git checkout -b &lt;new_branch&gt;            # 创建新的分支，并且切换过去
git checkout -b &lt;new_branch&gt; &lt;branch&gt;   # 基于branch创建新的new_branch
git checkout $id       # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除
git checkout $id -b &lt;new_branch&gt;        # 把某次历史提交记录checkout出来，创建成一个分支
git branch -d &lt;branch&gt;                  # 删除某个分支
git branch -D &lt;branch&gt;    # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)

强行切换分支
git checkout -f branch_name

强制checkout分支覆盖本地文件
git checkout -f branchname

分支合并和rebase
git merge &lt;branch&gt;               # 将branch分支合并到当前分支
git merge --no-ff &lt;branch&gt;       # 不要Fast-Foward合并，这样可以生成merge提交
git rebase master &lt;branch&gt;       # 将master rebase到branch，相当于：
git checkout &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge &lt;branch&gt;
</code></pre><ul>
<li>在我们操作过程中。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit 就可以了。</li>
<li><p>而rebase 操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行git rebase –continue继续操作，或者git rebase –skip忽略冲突。</p>
<p>  Git暂存管理<br>  git stash                        # 暂存<br>  git stash pop                    # 恢复暂存<br>  git stash list                   # 列所有stash<br>  git stash apply                  # 恢复暂存的内容<br>  git stash drop                   # 删除暂存区</p>
<p>  git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区<br>  git stash list：查看储藏队列(Stash lists)<br>  git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes))<br>  git stash clear：清空储藏队列<br>  git stash save “name of the stash”：为储藏设置命名<br>  git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏<br>  git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏)</p>
<p>  远程分支管理<br>  git pull                         # 抓取远程仓库所有分支更新并合并到本地<br>  git pull –no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并<br>  git fetch origin                 # 抓取远程仓库更新<br>  git merge origin/master          # 将远程主分支合并到本地当前分支<br>  git checkout –track origin/branch     # 跟踪某个远程分支创建相应的本地分支<br>  git checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;  # 基于远程分支创建本地分支，功能同上<br>  git push                         # push所有分支<br>  git push origin master           # 将本地主分支推到远程主分支<br>  git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)<br>  git push origin &lt;local_branch&gt;   # 创建远程分支， origin是远程仓库名<br>  git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支<br>  git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d <branch>)，然后再push删除远程分支</branch></p>
<p>  git删除远程分支<br>  git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限</p>
<p>  清空git暂存区<br>  git reset HEAD  //可以清空之前git add 的内容</p>
<p>  Git远程仓库管理<br>  git remote -v                    # 查看远程服务器地址和仓库名称<br>  git remote show origin           # 查看远程服务器仓库状态<br>  git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ihoey/blog.git     # 添加远程仓库地址<br>  git remote set-url origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ihoey/blog.git # 设置远程仓库地址(用于修改远程仓库地址)<br>  git remote rm <repository>       # 删除远程仓库</repository></p>
<p>  创建远程仓库<br>  git clone –bare ihoey.com blog.git     # 用带版本的项目创建纯版本仓库<br>  scp -r my_blog.git <a href="mailto:git@ihoey.com" target="_blank" rel="noopener">git@ihoey.com</a>:~      # 将纯仓库上传到服务器上<br>  mkdir blog.git &amp;&amp; cd blog.git &amp;&amp; git –bare init # 在服务器创建纯仓库<br>  git push -u origin master         # 客户端首次提交<br>  git push -u origin develop        # 首次将本地develop分支提交到远程develop分支，并且track<br>  git remote set-head origin master # 设置远程仓库的HEAD指向master分支</p>
<p>  设置跟踪远程库和本地库<br>  git branch –set-upstream master origin/master      #master<br>  git branch –set-upstream develop origin/develop    #develop</p>
<p>  其他命令<br>  mkdir XX    #(创建一个空目录 XX指目录名)<br>  pwd         #显示当前目录的路径。<br>  cat XX      #查看XX文件内容<br>  rm  XX      #删除文件</p>
</li>
</ul>
<p>命令别名设置:</p>
<pre><code>gitk --all &amp;   //打开git 图形化界面
git fetch --all  //刷新工作区    
git remote -v  //查看远端地址
git checkout -b dbg_master  -t origin/master   //基于远端master分支创建dbg_master分支
git merge --squash &lt;branch&gt;：将多次提交合并成一个，然后git add .;git commit -m &quot;XXXXX&quot;;git push origin XXXX...

git push                         # push所有分支
git push origin master           # 将本地主分支推到远程主分支
git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)
git push origin &lt;local_branch&gt;   # 创建远程分支， origin是远程仓库名
git push origin local-branch     #将当前local-branch 分支推送一个远程local-branch分支，本地分支和远程分支同名
git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支，将local_branch代码推送到remote_branch分支
git push origin :&lt;remote_branch&gt;  #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支

 对最近一次commit的进行修改：git commit -a –amend

 Git pull 强制覆盖本地文件
  git fetch --all  
  git reset --hard origin/master 
  git pull

git remote add origin https://git.oschina.net/duandaoke/os.git要求服务已经建立同名仓库
git remote # 显示远程仓库
git remote -v # 显示远程仓库详情
git remote show origin # 显示 origin 远程库的详情



rebase的冲突解决

   解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存） 
      git add -u   //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。
   然后执行下面命令继续rebase：
      git rebase --continue     //有冲突继续解决，重复这这些步骤，直到rebase完成。
   如果中间遇到某个补丁不需要应用，可以用下面命令忽略：
      git rebase --skip 
   如果想回到rebase执行之前的状态，可以执行：
      git rebase --abort    //放弃rebase  
   注：rebase之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。



cherry-pick的冲突解决

   解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存） 
      git add -u   //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。
   然后执行下面命令继续rebase：
      git cherry-pick --continue     //有冲突继续解决，重复这这些步骤，直到cherry-pick完成。
   如果中间遇到某个补丁不需要应用，可以用下面命令忽略：
      git cherry-pick --skip 
   如果想回到rebase执行之前的状态，可以执行：
      git cherry-pick  --abort    //放弃cherry-pick
   注：cherry-pick之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。


       手动编辑冲突的文件，使其内容和master_mlc分支上的内容一致， 
       然后git add此文件，最后执行git cherry-pick –continue即可。 


1、git删除远程分支
git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限
2、清空git暂存区
git reset HEAD  //可以清空之前git add 的内容


git clean命令用来从你的工作目录中删除所有没有tracked过的文件.
    git clean经常和git reset --hard一起结合使用. 记住reset只影响被track过的文件, 所以需要clean来删除没有track过的文件. 结合使用这两个命令能让你的工作目录完全回到一个指定的&lt;commit&gt;的状态.
用法


删除当前目录下没有被track过的文件和文件夹.
    git clean -xf


下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发.
git reset --hard
git clean -df
运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态, git status会告诉你这是一个干净的工作目录, 又是一个新的开始了.


git config --global gui.encoding utf-8    //在git GUI中使用UTF-8编码     
//git 回滚到之前某一commit
git reset –hard 8ff24a6803173208f3e606e32dfcf82db9ac84d8


在使用Git的时候,经过几次提交后,发现需要回退到早些时候的状态.例如: 
7edb8524a xxxxxxxxxxxxxxxxxx 
83dae5691 xxxxxxxxxxxxxxxxxx 
45eadd642 xxxxxxxxxxxxxxxxxx 
657834ade xxxxxxxxxxxxxxxxxx
假设现在处于7edb8524a 状态,现在我想回退到657834ade时的状态,此时可以 
git reset –hard 7edb8524a 
然后 
git reset –soft 657834ade 
会将之间的修改全部进行revert,然后在进行add commit操作就行了.
另外权限足够的话,可以从657834ade 拉一个分支出来,然后将远程分支 
删除,再将拉出来的分支push到远程仓库上,成为原来的分支,也可以实现回退到 
657834ade 的目的.此方法不会保留中间的各种修改信息和状态.


根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:
    git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息
    git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可
    git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容

已经push
对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令

revert
git revert用于反转提交,执行evert命令时要求工作树必须是干净的.
git revert用一个新提交来消除一个历史提交所做的任何修改.
revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)

revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.
git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61
通常,前几位即可
git revert c011eb3

git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit
看似达到的效果是一样的,其实完全不同.
</code></pre><p>合理的命令别名设置可以大大减少输入，有助于提高工作效率，建议遵守下述别名设置：</p>
<pre><code>git config --global alias.ci commit
git config --global alias.co checkout
git config --global alias.st status
git config --global alias.rb rebase
git config --global alias.ll “log --oneline --decorate --color”
git config --global alias.lc “log --graph --color”          
</code></pre><p>正确的回车换行设置，避免 Unix 和 Windows 下开发的回车换行的转换问题。</p>
<pre><code>(Windows  下)
git config --global core.autocrlf true
git config --global core. safecrlf warn

(Linux  下)
git config --global core.autocrlf input
git config --global core. safecrlf warn
</code></pre><p>基本命令</p>
<pre><code>git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;youremail@example.com&quot;
git config --global core.editor &lt;your favorite editor here&gt;
Ex: git config --global core.editor vim

git init：初始化一个repo，初始化本地git仓库（创建新仓库）
</code></pre><p>Commit 结构</p>
<pre><code>git status(gst)：查看 repo 状态
工作区：
.git 目录
暂存区
工作目录
</code></pre><p><img src="https://pic4.zhimg.com/v2-44aed332eb50ca594deeca86186012a8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-44aed332eb50ca594deeca86186012a8_hd.jpg" alt=""></p>
<pre><code>git add &lt;filename&gt;(ga)：添加一个文件到暂存区
git add .(gaa)：添加所有文件到暂存区
git add *.js：添加所有后缀为js的文件到暂存区
git rm --cached &lt;file&gt;：从暂存区删除一个新文件
git commit -m &quot;My first commit&quot;(gcmsg)：创建一次带 message 的提交
git commit -v -a(gca)：
-v是 verbose 的缩写，会在底部显示差异信息和更多有意义的信息
-a 类似于 git add .，会添加所有被修改和删除的文件，但会忽略新创建的文件

git help &lt;command&gt;：查看对应命令的帮助手册
git log(glg,glgg,glo, glog)：查看项目的提交历史
</code></pre><p>暂存区管理</p>
<pre><code>git reset HEAD &lt;filename&gt;(grh)：从暂存区删除一个被修改的文件
git reset HEAD(grh)：从暂存区删除所有被修改的文件
git checkout &lt;filename&gt;(gco)：从暂存区删除一个被修改的文件，并撤销文件的更改     //  git checkout .
git commit -m &quot;My first commit&quot; --amend：添加文件/更改在暂存区的最后一次提交
git commit -v -a --amend(gca!)：添加文件/更改在暂存区的最后一次提交
.gitignore：告诉git，哪些文件不被加入版本跟踪
可以使用 git add &lt;filename&gt; -f 命令添加一个不被版本跟踪的文件


git diff &lt;filename&gt;(gd)：查看基于当前文件的最后一次提交的更改差异
git diff (gd)：查看基于所有文件的最后一次提交的更改差异
git reset HEAD~2 --soft：从项目提交历史中删除最近两次提交，但不丢弃文件的更改
git reset HEAD~2 --hard：从项目提交历史中删除最近两次提交，但会丢弃文件的更改和在(最后两次)提交中创建的新文件
git reset &lt;commit&gt; --soft --hard：
--soft：将所有被更改的文件回溯到“待提交”状态
--hard：commit 之后，对被git追踪的文件的任何更改都被丢弃


git reflog：显示包括&quot;被撤销&quot;在内的所有提交
git merge &lt;commit hash&gt;：重新提交(restore the commit)
git clean -f：删除工作目录中不被git进行版本追踪的文件
</code></pre><p>Stashed &amp; BranchesStash</p>
<pre><code>git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区
git stash list：查看储藏队列(Stash lists)
git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes))
git stash clear：清空储藏队列
git stash save &quot;name of the stash&quot;：为储藏设置命名
git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏
git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏)
</code></pre><p>Branch</p>
<pre><code>git checkout -b dev(gco)：创建 dev 分支并从当前分支切换到 dev 分支      //  git checkout -b dbg_master  -t origin/master   //基于master分支创建dbg_master分支
git branch(gb)：查看所有分支
git checkout master(gcm)：切换到主分支
git merge &lt;branch&gt;(gm)：合并分支
git rebase master：先将 master 上的更改合并到当前分支，再添加当前分支的更改。如果有冲突，解决冲突后加 --continue 参数继续合并
git branch -d &lt;branch&gt;： 删除分支，-D 则强制删除分支
git merge &lt;branch&gt; --squash：将多次提交合并成一个，其流程如下：



# Go to the `master` branch
git checkout master
# Create a temp branch
git checkout -b temp
# Merge the feature/x branch into the temp using --squash
git merge feature/x --squash
# See the new modifications/files in the Staging Area
git status
# Create the unified commit
git commit -m &quot;Add feature/x&quot;
# Delete the feature/x branch
git branch -D feature/x
</code></pre><ul>
<li><p>rebase 和 merge 的区别：</p>
<p>  rebase:<br>  提交历史(的展示)是线性的<br>  缺点：会删除最近一个 commit，然后创建一次新的 commit<br>  如果已提交到远程，不要使用 rebase</p>
<p>  merge:<br>  提交历史(的展示)是分叉的<br>  对于两个分支的合并，会创建一个次新的 commit</p>
</li>
</ul>
<p>远程仓库管理</p>
<pre><code>git remote add &lt;name&gt; &lt;url&gt;：添加一个将被追踪的远程仓库
git remote rm &lt;name&gt;：移除一个远程仓库
git push &lt;remote&gt; &lt;remote-branch&gt;(gp,ggp)：将当前分支的本地 commit 推送到远程仓库
git fetch &lt;remote&gt; &lt;remote-branch&gt;：拉取远程仓库的最新 commit 到当前(本地)分支(&lt;remote&gt;/&lt;branch&gt;)，不会合并
git pull &lt;remote&gt; &lt;remote-branch&gt;(gl,ggl)：拉取远程仓库的最新 commit 到当前(本地)分支，并自动 merge
git pull --rebase(gup)：以 rebase 的方式进行合并，而不是 merge
</code></pre><p>其它有用的命令</p>
<pre><code>git tag &lt;name&gt;：创建一个 tag(如：v1.3)
git push --tags：将本地 tags 推送到远程仓库
git push &lt;tag&gt;：推送指定的本地 tag 到远程


展示帮助信息
git help -g

回到远程仓库的状态
抛弃本地所有的修改，回到远程仓库的状态。
git fetch --all &amp;&amp; git reset --hard origin/master

重设第一个commit
也就是把所有的改动都重新放回工作区，并清空所有的commit，这样就可以重新提交第一个commit了
git update-ref -d HEAD

展示工作区和暂存区的不同
输出工作区和暂存区的different(不同)。
git diff

还可以展示本地仓库中任意两个commit之间的文件变动：
git diff &lt;commit-id&gt; &lt;commit-id&gt;

展示暂存区和最近版本的不同
输出暂存区和本地最近的版本(commit)的different(不同)。
git diff --cached

展示暂存区、工作区和最近版本的不同
输出工作区、暂存区 和本地最近的版本(commit)的different(不同)。
git diff HEAD

快速切换分支
git checkout -

删除已经合并到master的分支
git branch --merged master | grep -v &apos;^\*\|  master&apos; | xargs -n 1 git branch -d

展示本地分支关联远程仓库的情况
git branch -vv

关联远程分支
关联之后，git branch -vv就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。
git branch -u origin/mybranch

或者在push时加上-u参数
git push origin/mybranch -u

列出所有本地分支
-l参数相当于：local
git branch -l

列出所有远程分支
-r参数相当于：remote
git branch -r

列出本地和远程分支
-a参数相当于：all
git branch -a

创建并切换到本地分支
git checkout -b &lt;branch-name&gt;

创建并切换到远程分支
git checkout -b &lt;branch-name&gt; -t origin/&lt;branch-name&gt;

删除本地分支
git branch -d &lt;local-branchname&gt;

删除远程分支
git push origin --delete &lt;remote-branchname&gt;
或者
git push origin :&lt;remote-branchname&gt;

重命名本地分支
git branch -m &lt;new-branch-name&gt;
git branch -m &lt;oldbranchname&gt; &lt;newbranchname&gt;：尝试修改
git branch -M &lt;oldbranchname&gt; &lt;newbranchname&gt;：强制修改

查看标签
git tag

展示当前分支的最近的tag
git describe --tags --abbrev=0

本地创建标签
git tag &lt;version-number&gt;

默认tag是打在最近的一次commit上，如果需要指定commit打tag：
$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;

推送标签到远程仓库
首先要保证本地创建好了标签才可以推送标签到远程仓库：
git push origin &lt;local-version-number&gt;

一次性推送所有标签，同步到远程仓库：
git push origin --tags

删除本地标签
git tag -d &lt;tag-name&gt;

删除远程标签
删除远程标签需要先删除本地标签，再执行下面的命令：
git push origin :refs/tags/&lt;tag-name&gt;

切回到某个标签
一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：
git checkout -b branch_name tag_name

放弃工作区的修改
git checkout &lt;file-name&gt;

放弃所有修改：
git checkout .

恢复删除的文件
git rev-list -n 1 HEAD -- &lt;file_path&gt; #得到 deleting_commit
git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态

回到某一个commit的状态，并重新增添一个commit  //回退，有记录
git revert &lt;commit-id&gt;

回到某个commit的状态，并删除后面的commit
和revert的区别：reset命令会抹去某个commit id之后的所有commit
git reset &lt;commit-id&gt;

修改上一个commit的描述
git commit --amend

查看commit历史
git log

查看某段代码是谁写的
blame的意思为‘责怪’，你懂的。
git blame &lt;file-name&gt;

显示本地执行过git命令
就像shell的history一样
git reflog

修改作者名
git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos;

修改远程仓库的url
git remote set-url origin &lt;URL&gt;

增加远程仓库
git remote add origin &lt;remote-url&gt;

列出所有远程仓库
git remote    //  git remote -v

查看两个星期内的改动
git whatchanged --since=&apos;2 weeks ago&apos;

把A分支的某一个commit，放到B分支上
这个过程需要cherry-pick命令，参考
git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;

给git命令起别名
简化命令
git config --global alias.&lt;handle&gt; &lt;command&gt;
比如：git status 改成 git st，这样可以简化命令
git config --global alias.st status

存储当前的修改，但不用提交commit
详解可以参考廖雪峰老师的git教程

git stash
保存当前状态，包括untracked的文件

untracked文件：新建的文件
git stash -u

展示所有stashes
git stash list

回到某个stash的状态
git stash apply &lt;stash@{n}&gt;

回到最后一个stash的状态，并删除这个stash
git stash pop

删除所有的stash
git stash clear

从stash中拿出某个文件的修改
git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt;

展示所有tracked的文件
git ls-files -t

展示所有untracked的文件
git ls-files --others

展示所有忽略的文件
git ls-files --others -i --exclude-standard

强制删除untracked的文件
可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。clean命令，注意两点：
clean后，删除的文件无法找回
不会影响tracked的文件的改动，只会删除untracked的文件git clean &lt;file-name&gt; -f
强制删除untracked的目录
可以用来删除新建的目录，注意:这个命令也可以用来删除untracked的文件。详情见上一条
git clean &lt;directory-name&gt; -df

展示简化的commit历史
git log --pretty=oneline --graph --decorate --all
把某一个分支到导出成一个文件
git bundle create &lt;file&gt; &lt;branch-name&gt;
从包中导入分支
新建一个分支，分支内容就是上面git bundle create命令导出的内容
git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;
执行rebase之前自动stash
git rebase --autostash
从远程仓库根据ID，拉下某一状态，到本地分支
git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;
详细展示一行中的修改
git diff --word-diff
清除gitignore文件中记录的文件
git clean -X -f
展示所有alias和configs
注意： config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config
git config --local --list (当前目录)
git config --global --list (全局)
展示忽略的文件
git status --ignored
commit历史中显示Branch1有的，但是Branch2没有commit
git log Branch1 ^Branch2
在commit log中显示GPG签名
git log --show-signature
删除全局设置
git config --global --unset &lt;entry-name&gt;
新建并切换到新分支上，同时这个分支没有任何commit
相当于保存修改，但是重写commit历史
git checkout --orphan &lt;branch-name&gt;
展示任意分支某一文件的内容
git show &lt;branch-name&gt;:&lt;file-name&gt;
clone下来指定的单一分支
git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git
忽略某个文件的改动
关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动
git update-index --assume-unchanged path/to/file

恢复 track 指定文件的改动
git update-index --no-assume-unchanged path/to/file

忽略文件的权限变化
不再将文件的权限变化视作改动
git config core.fileMode false
展示本地所有的分支的commit
最新的放在最上面
git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/
在commit log中查找相关内容
通过grep查找，given-text：所需要查找的字段
git log --all --grep=&apos;&lt;given-text&gt;&apos;
把暂存区的指定file放到工作区中
git reset &lt;file-name&gt;

强制推送
git push -f &lt;remote-name&gt; &lt;branch-name&gt;列出所有远程分支
-r参数相当于：remote
git branch -r

更新到本地
# 源 + 分支名
git pull origin master
</code></pre><p>初始化本地git仓库（创建新仓库）</p>
<pre><code>git init                                               
# 初始化 git 项目
git init
安装好 Git 之后，配置你的资料:
# 配置用户名
git config --global user.name &quot;Your Real Name&quot;
# 配置邮箱地址
git config --global user.email you@email.address
</code></pre><p>配置用户名</p>
<pre><code>git config --global user.name &quot;xxx&quot;                       
</code></pre><p>配置邮件</p>
<pre><code>git config --global user.email &quot;xxx@xxx.com&quot;              
</code></pre><p>git status等命令自动着色</p>
<pre><code>git config --global color.ui true                         
git config --global color.status auto
git config --global color.diff auto
git config --global color.branch auto
git config --global color.interactive auto
</code></pre><p>clone远程仓库</p>
<pre><code>git clone git+ssh://git@192.168.53.168/VT.git             
</code></pre><p>查看当前版本状态（是否修改）</p>
<pre><code>git status                                                
</code></pre><p>添加xyz文件至index</p>
<pre><code>git add xyz                                               
</code></pre><p>增加当前子目录下所有更改过的文件至index</p>
<pre><code>git add .                                                 
</code></pre><p>提交</p>
<pre><code>git commit -m &apos;xxx&apos;                                       
</code></pre><p>合并上一次提交（用于反复修改）</p>
<pre><code>git commit --amend -m &apos;xxx&apos;                               
</code></pre><p>将add和commit合为一步</p>
<pre><code>git commit -am &apos;xxx&apos;                                      
</code></pre><p>删除index中的文件</p>
<pre><code>git rm xxx                                                
</code></pre><p>递归删除</p>
<pre><code>git rm -r *                                               
</code></pre><p>显示提交日志</p>
<pre><code>git log                                                   
</code></pre><p>显示1行日志 -n为n行</p>
<pre><code>git log -1                                                
</code></pre><p>git log -5</p>
<p>显示提交日志及相关变动文件</p>
<pre><code>git log --stat                                            
</code></pre><p>git log -p -m</p>
<p>显示某个提交的详细内容</p>
<pre><code>git show dfb02e6e4f2f7b573337763e5c0013802e392818         
</code></pre><p>可只用commitid的前几位</p>
<pre><code>git show dfb02                                            
</code></pre><p>显示HEAD提交日志</p>
<pre><code>git show HEAD                                             
</code></pre><p>显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</p>
<pre><code>git show HEAD^                                            
</code></pre><p>显示已存在的tag</p>
<pre><code>git tag                                                   
</code></pre><p>增加v2.0的tag</p>
<pre><code>git tag -a v2.0 -m &apos;xxx&apos;                                  
</code></pre><p>显示v2.0的日志及详细内容</p>
<pre><code>git show v2.0                                             
</code></pre><p>显示v2.0的日志</p>
<pre><code>git log v2.0                                              
</code></pre><p>显示所有未添加至index的变更</p>
<pre><code>git diff                                                  
</code></pre><p>显示所有已添加index但还未commit的变更</p>
<pre><code>git diff --cached                                         
</code></pre><p>比较与上一个版本的差异</p>
<pre><code>git diff HEAD^                                            
</code></pre><p>比较与HEAD版本lib目录的差异</p>
<pre><code>git diff HEAD -- ./lib                                    
</code></pre><p>比较远程分支master上有本地分支master上没有的</p>
<pre><code>git diff origin/master..master                            
</code></pre><p>只显示差异的文件，不显示具体内容</p>
<pre><code>git diff origin/master..master --stat                     
</code></pre><p>增加远程定义（用于push/pull/fetch）</p>
<pre><code>git remote add origin git+ssh://git@192.168.53.168/VT.git 
</code></pre><p>显示本地分支</p>
<pre><code>git branch                                                
</code></pre><p>显示包含提交50089的分支</p>
<pre><code>git branch --contains 50089                               
</code></pre><p>显示所有分支</p>
<pre><code>git branch -a                                             
</code></pre><p>显示所有原创分支</p>
<pre><code>git branch -r                                             
</code></pre><p>显示所有已合并到当前分支的分支</p>
<pre><code>git branch --merged                                       
</code></pre><p>显示所有未合并到当前分支的分支</p>
<pre><code>git branch --no-merged                                    
</code></pre><p>本地分支改名</p>
<pre><code>git branch -m master master_copy                          
</code></pre><p>从当前分支创建新分支master_copy并检出</p>
<pre><code>git checkout -b master_copy                               
</code></pre><p>上面的完整版</p>
<pre><code>git checkout -b master master_copy                        
</code></pre><p>检出已存在的features/performance分支</p>
<pre><code>git checkout features/performance                         
</code></pre><p>检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</p>
<pre><code>git checkout --track hotfixes/BJVEP933                    
</code></pre><p>检出版本v2.0</p>
<pre><code>git checkout v2.0                                         
</code></pre><p>从远程分支develop创建新本地分支devel并检出</p>
<pre><code>git checkout -b devel origin/develop                      
</code></pre><p>检出head版本的README文件（可用于修改错误回退）</p>
<pre><code>git checkout -- README                                    
</code></pre><p>合并远程master分支至当前分支</p>
<pre><code>git merge origin/master                                   
</code></pre><p>合并提交ff44785404a8e的修改</p>
<pre><code>git cherry-pick ff44785404a8e                             
</code></pre><p>将当前分支push到远程master分支</p>
<pre><code>git push origin master                                    
</code></pre><p>删除远程仓库的hotfixes/BJVEP933分支</p>
<pre><code>git push origin :hotfixes/BJVEP933                        
</code></pre><p>把所有tag推送到远程仓库</p>
<pre><code>git push --tags                                           
</code></pre><p>获取所有远程分支（不更新本地分支，另需merge）</p>
<pre><code>git fetch                                                 
</code></pre><p>获取所有原创分支并清除服务器上已删掉的分支</p>
<pre><code>git fetch --prune                                         
</code></pre><p>获取远程分支master并merge到当前分支</p>
<pre><code>git pull origin master                                    
</code></pre><p>重命名文件README为README2</p>
<pre><code>git mv README README2                                     
</code></pre><p>将当前版本重置为HEAD（通常用于merge失败回退）</p>
<pre><code>git reset --hard HEAD                                     
</code></pre><p>git rebase</p>
<p>删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</p>
<pre><code>git branch -d hotfixes/BJVEP933                           
</code></pre><p>强制删除分支hotfixes/BJVEP933</p>
<pre><code>git branch -D hotfixes/BJVEP933                           
</code></pre><p>列出git index包含的文件</p>
<pre><code>git ls-files                                              
</code></pre><p>图示当前分支历史</p>
<pre><code>git show-branch                                           
</code></pre><p>图示所有分支历史</p>
<pre><code>git show-branch --all                                     
</code></pre><p>显示提交历史对应的文件修改</p>
<pre><code>git whatchanged                                           
</code></pre><p>撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</p>
<pre><code>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       
</code></pre><p>内部命令：显示某个git对象</p>
<pre><code>git ls-tree HEAD                                          
</code></pre><p>内部命令：显示某个ref对于的SHA1 HASH</p>
<pre><code>git rev-parse v2.0                                        
</code></pre><p>显示所有提交，包括孤立节点</p>
<pre><code>git reflog                                                
</code></pre><p>git show HEAD@{5}</p>
<p>显示master分支昨天的状态</p>
<pre><code>git show master@{yesterday}                               
</code></pre><p>图示提交日志</p>
<pre><code>git log --pretty=format:&apos;%h %s&apos; --graph                   
git show HEAD~3
git show -s --pretty=raw 2be7fcb476
</code></pre><p>暂存当前修改，将所有至为HEAD状态</p>
<pre><code>git stash                                                 
</code></pre><p>查看所有暂存</p>
<pre><code>git stash list                                            
</code></pre><p>参考第一次暂存</p>
<pre><code>git stash show -p stash@{0}                               
</code></pre><p>应用第一次暂存</p>
<pre><code>git stash apply stash@{0}                                 
</code></pre><p>文件中搜索文本“delete from”</p>
<pre><code>git grep &quot;delete from&quot;                                    
git grep -e &apos;#define&apos; --and -e SORT_DIRENT

git gc
git fsck
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/09/JavaScript进阶提高必读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/09/JavaScript进阶提高必读/" itemprop="url">JavaScript进阶提高必读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-09T22:40:40+08:00">
                2018-09-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="冴羽写博客的地方"><a href="#冴羽写博客的地方" class="headerlink" title="冴羽写博客的地方"></a><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">冴羽写博客的地方</a></h2><p><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/17" target="_blank" rel="noopener">JavaScript深入系列15篇正式完结！</a></p>
<h2 id="深入系列目录"><a href="#深入系列目录" class="headerlink" title="深入系列目录"></a>深入系列目录</h2><ol>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScirpt深入之从原型到原型链</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript深入之执行上下文栈</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript深入之变量对象</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">JavaScript深入之作用域链</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">JavaScript深入之从ECMAScript规范解读this</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">JavaScript深入之执行上下文</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">JavaScript深入之闭包</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/10" target="_blank" rel="noopener">JavaScript深入之参数按值传递</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">JavaScript深入之类数组对象与arguments</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/15" target="_blank" rel="noopener">JavaScript深入之创建对象的多种方式以及优缺点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">JavaScript深入之继承的多种方式以及优缺点</a></li>
</ol>
<h2 id="专题系列目录"><a href="#专题系列目录" class="headerlink" title="专题系列目录"></a>专题系列目录</h2><ol>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">JavaScript专题之跟着underscore学防抖</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">JavaScript专题之跟着underscore学节流</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/27" target="_blank" rel="noopener">JavaScript专题之数组去重</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">JavaScript专题之类型判断(上)</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/30" target="_blank" rel="noopener">JavaScript专题之类型判断(下)</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener">JavaScript专题之深浅拷贝</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/33" target="_blank" rel="noopener">JavaScript专题之从零实现jQuery的extend</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/35" target="_blank" rel="noopener">JavaScript专题之如何求数组的最大值和最小值</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/36" target="_blank" rel="noopener">JavaScript专题之数组扁平化</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/37" target="_blank" rel="noopener">JavaScript专题之学underscore在数组中查找指定元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/40" target="_blank" rel="noopener">JavaScript专题之jQuery通用遍历方法each的实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/41" target="_blank" rel="noopener">JavaScript专题之如何判断两个对象相等</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript专题之函数柯里化</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/43" target="_blank" rel="noopener">JavaScript专题之偏函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/44" target="_blank" rel="noopener">JavaScript专题之惰性函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/45" target="_blank" rel="noopener">JavaScript专题之函数组合</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/46" target="_blank" rel="noopener">JavaScript专题之函数记忆</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/49" target="_blank" rel="noopener">JavaScript专题之递归</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/51" target="_blank" rel="noopener">JavaScript专题之乱序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/52" target="_blank" rel="noopener">JavaScript专题之解读 v8 排序源码</a></li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>深入系列文章部分是有先后顺序的，按照目录结构顺序阅读效果最好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/JS之call和apply-bind的模拟实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/JS之call和apply-bind的模拟实现/" itemprop="url">JS之call和apply,bind的模拟实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T22:39:16+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>一句话介绍 call：</p>
<blockquote>
<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
</blockquote>
<p>举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
</code></pre><p>注意两点：</p>
<ol>
<li>call 改变了 this 的指向，指向到 foo</li>
<li>bar 函数执行了</li>
</ol>
<h2 id="模拟实现第一步"><a href="#模拟实现第一步" class="headerlink" title="模拟实现第一步"></a>模拟实现第一步</h2><p>那么我们该怎么模拟实现这两个效果呢？</p>
<p>试想当调用 call 的时候，把 foo 对象改造成如下：</p>
<pre><code>var foo = {
    value: 1,
    bar: function() {
        console.log(this.value)
    }
};

foo.bar(); // 1
</code></pre><p>这个时候 this 就指向了 foo，是不是很简单呢？</p>
<p>但是这样却给 foo 对象本身添加了一个属性，这可不行呐！</p>
<p>不过也不用担心，我们用 delete 再删除它不就好了~</p>
<p>所以我们模拟的步骤可以分为：</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<p>以上个例子为例，就是：</p>
<pre><code>// 第一步
foo.fn = bar
// 第二步
foo.fn()
// 第三步
delete foo.fn
</code></pre><p>fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。</p>
<p>根据这个思路，我们可以尝试着去写第一版的 call2 函数：</p>
<pre><code>// 第一版
Function.prototype.call2 = function(context) {
    // 首先要获取调用call的函数，用this可以获取
    context.fn = this;
    context.fn();
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call2(foo); // 1
</code></pre><p>正好可以打印 1 哎！是不是很开心！(～￣▽￣)～</p>
<h2 id="模拟实现第二步"><a href="#模拟实现第二步" class="headerlink" title="模拟实现第二步"></a>模拟实现第二步</h2><p>最一开始也讲了，call 函数还能给定参数执行函数。举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call(foo, &apos;kevin&apos;, 18);
// kevin
// 18
// 1
</code></pre><p>注意：传入的参数并不确定，这可咋办？</p>
<p>不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。</p>
<p>比如这样：</p>
<pre><code>// 以上个例子为例，此时的arguments为：
// arguments = {
//      0: foo,
//      1: &apos;kevin&apos;,
//      2: 18,
//      length: 3
// }
// 因为arguments是类数组对象，所以可以用for循环
var args = [];
for(var i = 1, len = arguments.length; i &lt; len; i++) {
    args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
}

// 执行后 args为 [foo, &apos;kevin&apos;, 18]
</code></pre><p>不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。</p>
<pre><code>// 将数组里的元素作为多个参数放进函数的形参里
context.fn(args.join(&apos;,&apos;))
// (O_o)??
// 这个方法肯定是不行的啦！！！
</code></pre><p>也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样：</p>
<pre><code>eval(&apos;context.fn(&apos; + args +&apos;)&apos;)
</code></pre><p>这里 args 会自动调用 Array.toString() 这个方法。</p>
<p>所以我们的第二版克服了两个大问题，代码如下：</p>
<pre><code>// 第二版
Function.prototype.call2 = function(context) {
    context.fn = this;
    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }
    eval(&apos;context.fn(&apos; + args +&apos;)&apos;);
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call2(foo, &apos;kevin&apos;, 18); 
// kevin
// 18
// 1
</code></pre><p>(๑•̀ㅂ•́) ✧</p>
<h2 id="模拟实现第三步"><a href="#模拟实现第三步" class="headerlink" title="模拟实现第三步"></a>模拟实现第三步</h2><p>模拟代码已经完成 80%，还有两个小点要注意：</p>
<p>1.this 参数可以传 null，当为 null 的时候，视为指向 window</p>
<p>举个例子：</p>
<pre><code>var value = 1;

function bar() {
    console.log(this.value);
}

bar.call(null); // 1
</code></pre><p>虽然这个例子本身不使用 call，结果依然一样。</p>
<p>2.函数是可以有返回值的！</p>
<p>举个例子：</p>
<pre><code>var obj = {
    value: 1
}

function bar(name, age) {
    return {
        value: this.value,
        name: name,
        age: age
    }
}

console.log(bar.call(obj, &apos;kevin&apos;, 18));
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>不过都很好解决，让我们直接看第三版也就是最后一版的代码：</p>
<pre><code>// 第三版
Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);

    delete context.fn
    return result;
}

// 测试一下
var value = 2;

var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call(null); // 2

console.log(bar.call2(obj, &apos;kevin&apos;, 18));
// 1
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ</p>
<h2 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h2><p>apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现：</p>
<pre><code>Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push(&apos;arr[&apos; + i + &apos;]&apos;);
        }
        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)
    }

    delete context.fn
    return result;
}
</code></pre><p><img src="https://pic1.zhimg.com/v2-23784bc5e0ab2bdcb4b879e5d28617c6_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-23784bc5e0ab2bdcb4b879e5d28617c6_hd.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-9374916fd3f03dab5836b9fc4057070a_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-9374916fd3f03dab5836b9fc4057070a_hd.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-7fe454d5cfd72880650f53a4f50c93cd_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-7fe454d5cfd72880650f53a4f50c93cd_hd.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-4f15656852b764a859194a3d7156ea99_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-4f15656852b764a859194a3d7156ea99_hd.jpg" alt=""></p>
<pre><code>类数组转对象
在上面的例子中已经提到了一种类数组转数组的方法，再补充三个：
var arrayLike = {0: &apos;name&apos;, 1: &apos;age&apos;, 2: &apos;sex&apos;, length: 3 }
// 1. slice
Array.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 2. splice
Array.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 3. ES6 Array.from
Array.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 4. apply
Array.prototype.concat.apply([], arrayLike)   




要说到类数组对象，Arguments 对象就是一个类数组对象。
在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。


传递参数
将参数从一个函数传递到另一个函数
// 使用 apply 将 foo 的参数传递给 bar
function foo() {
    bar.apply(this, arguments);
}
function bar(a, b, c) {
   console.log(a, b, c);
}

foo(1, 2, 3)




强大的ES6
使用ES6的 ... 运算符，我们可以轻松转成数组。
function func(...arguments) {
    console.log(arguments); // [1, 2, 3]
}

func(1, 2, 3);
</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>一句话介绍 bind:</p>
<blockquote>
<p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p>
</blockquote>
<p>由此我们可以首先得出 bind 函数的两个特点：</p>
<ol>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ol>
<h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><p>从第一个特点开始，我们举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

// 返回了一个函数
var bindFoo = bar.bind(foo); 

bindFoo(); // 1
</code></pre><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">《JavaScript深入之call和apply的模拟实现》</a>。我们来写第一版的代码：</p>
<pre><code>// 第一版
Function.prototype.bind2 = function (context) {
    var self = this;
    return function () {
        self.apply(context);
    }

}
</code></pre><h2 id="传参的模拟实现"><a href="#传参的模拟实现" class="headerlink" title="传参的模拟实现"></a>传参的模拟实现</h2><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(this.value);
    console.log(name);
    console.log(age);

}

var bindFoo = bar.bind(foo, &apos;daisy&apos;);
bindFoo(&apos;18&apos;);
// 1
// daisy
// 18
</code></pre><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p>
<p>这可咋办？不急，我们用 arguments 进行处理：</p>
<pre><code>// 第二版
Function.prototype.bind2 = function (context) {

    var self = this;
    // 获取bind2函数从第二个参数到最后一个参数
    var args = Array.prototype.slice.call(arguments, 1);

    return function () {
        // 这个时候的arguments是指bind返回的函数传入的参数
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(context, args.concat(bindArgs));
    }

}
</code></pre><h2 id="构造函数效果的模拟实现"><a href="#构造函数效果的模拟实现" class="headerlink" title="构造函数效果的模拟实现"></a>构造函数效果的模拟实现</h2><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p>
<blockquote>
<p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
</blockquote>
<p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p>
<pre><code>var value = 2;

var foo = {
    value: 1
};

function bar(name, age) {
    this.habit = &apos;shopping&apos;;
    console.log(this.value);
    console.log(name);
    console.log(age);
}

bar.prototype.friend = &apos;kevin&apos;;

var bindFoo = bar.bind(foo, &apos;daisy&apos;);

var obj = new bindFoo(&apos;18&apos;);
// undefined
// daisy
// 18
console.log(obj.habit);
console.log(obj.friend);
// shopping
// kevin
</code></pre><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p>
<p>(哈哈，我这是为我的下一篇文章<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">《JavaScript深入系列之new的模拟实现》</a>打广告)。</p>
<p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p>
<pre><code>// 第三版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
        self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
    }
    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
    fBound.prototype = this.prototype;
    return fBound;
}
</code></pre><p>如果对原型链稍有困惑，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">《JavaScript深入之从原型到原型链》</a>。</p>
<h2 id="构造函数效果的优化实现"><a href="#构造函数效果的优化实现" class="headerlink" title="构造函数效果的优化实现"></a>构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p>
<pre><code>// 第四版
Function.prototype.bind2 = function (context) {

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
</code></pre><p>到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ</p>
<h2 id="三个小问题"><a href="#三个小问题" class="headerlink" title="三个小问题"></a>三个小问题</h2><p>接下来处理些小问题:</p>
<p>1.apply 这段代码跟 MDN 上的稍有不同</p>
<p>在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：</p>
<pre><code>self.apply(this instanceof self ? this : context || this, args.concat(bindArgs))
</code></pre><p>多了一个关于 context 是否存在的判断，然而这个是错误的！</p>
<p>举个例子：</p>
<pre><code>var value = 2;
var foo = {
    value: 1,
    bar: bar.bind(null)
};

function bar() {
    console.log(this.value);
}

foo.bar() // 2
</code></pre><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！</p>
<p>所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！</p>
<p>2.调用 bind 的不是函数咋办？</p>
<p>不行，我们要报错！</p>
<pre><code>if (typeof this !== &quot;function&quot;) {
  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}
</code></pre><p>3.我要在线上用</p>
<p>那别忘了做个兼容：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function () {
    ……
};
</code></pre><p>当然最好是用 <a href="https://link.zhihu.com/?target=https%3A//github.com/es-shims/es5-shim" target="_blank" rel="noopener">es5-shim</a> 啦。</p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>所以最最后的代码就是：</p>
<pre><code>Function.prototype.bind2 = function (context) {

    if (typeof this !== &quot;function&quot;) {
      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/08/HTML5的Websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/08/HTML5的Websocket/" itemprop="url">HTML5的Websocket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-08T22:18:50+08:00">
                2018-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>先请来TA的邻居：*<br>http：无状态、基于tcp请求/响应模式的应用层协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么）tcp：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) 传输层协议。（看啊，大阅兵，如此规整有秩序）</li>
</ul>
</blockquote>
<h2 id="为什么要引入Websocket："><a href="#为什么要引入Websocket：" class="headerlink" title="为什么要引入Websocket："></a>为什么要引入Websocket：</h2><blockquote>
<p>RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。</p>
</blockquote>
<p>long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。</p>
<p><img src="https://pic3.zhimg.com/v2-b900392bfe564de524ec5460a2b5d235_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b900392bfe564de524ec5460a2b5d235_hd.jpg" alt=""></p>
<p>从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p>
<p>这个时候，Websocket出现了。</p>
<h2 id="Websocket是什么："><a href="#Websocket是什么：" class="headerlink" title="Websocket是什么："></a>Websocket是什么：</h2><blockquote>
<p>RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。</p>
</blockquote>
<p>对，划重点：双向通信</p>
<p>Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以主动向客户端推送消息。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。</p>
<p>其特点：</p>
<p>（1）握手阶段采用 HTTP 协议，默认端口是80和443</p>
<p>（2）建立在TCP协议基础之上，和http协议同属于应用层</p>
<p>（4）可以发送文本，也可以发送二进制数据</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信</p>
<p>（6）协议标识符是ws（如果加密，为wss），如ws://localhost:8023</p>
<p>简单来说，Websocket协议分为两部分：握手和数据传输。</p>
<p><img src="https://pic2.zhimg.com/v2-5b1e92b99d352ba977f69cbe28604ecf_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5b1e92b99d352ba977f69cbe28604ecf_hd.jpg" alt=""></p>
<h2 id="Websocket-API："><a href="#Websocket-API：" class="headerlink" title="Websocket API："></a>Websocket API：</h2><blockquote>
<p>这里是指客户端 API。</p>
</blockquote>
<h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><ol>
<li><code>通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。</code></li>
<li><code>const ws =`</code>new<code></code>WebSocket(‘ws://localhost:8023’);`</li>
</ol>
<h2 id="Websocket事件"><a href="#Websocket事件" class="headerlink" title="Websocket事件"></a>Websocket事件</h2><ol>
<li><code>WebSocket`</code>是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。`</li>
</ol>
<p>open:</p>
<p>服务端响应WebSocket连接请求，就会触发open事件。onopen是响应的回调函数。</p>
<p><code>// 连接请求open事件处理：</code></p>
<pre><code>ws.onopen=e=&gt;{
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果要指定多个回调函数，可以使用addEventListener方法。</p>
<pre><code>ws.addEventListener(&apos;open&apos;, e =&gt; {
 ws.send(`Hello ${e}`);
});
</code></pre><p>当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。</p>
<p>Message:</p>
<p>收到服务器数据，会触发消息事件，onmessage是响应的回调函数。如下：</p>
<pre><code>// 接受文本消息的事件处理：
ws.onmessage = e =&gt; {
const data = e.data;
if (typeof data === &quot;string&quot;) {
       console.log(&quot;Received string message &quot;,data);
} else if (data instanceof Blob) {
       console.log(&quot;Received blob message &quot;, data);
}
};
</code></pre><p>服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p>
<p>Error</p>
<p>发生错误会触发error事件, onerror是响应的回调函数, 会导致连接关闭。</p>
<pre><code>//异常处理
ws.onerror = e =&gt; {
   console.log(&quot;WebSocket Error: &quot; , e);
   handleErrors(e);
};
</code></pre><p>当连接关闭时触发close事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再通信。</p>
<p>WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧）</p>
<pre><code>//关闭连接处理
ws.onclose = e =&gt; {
const code = e.code;
const reason = e.reason;
   console.log(&quot;Connection close&quot;, code, reason);
};
</code></pre><h2 id="WebSocket-方法："><a href="#WebSocket-方法：" class="headerlink" title="WebSocket 方法："></a>WebSocket 方法：</h2><blockquote>
<p>WebSocket 对象有两个方法：send 和 close</p>
</blockquote>
<p>send:</p>
<p>客户端和服务器建立连接后，可以调用send方法去发送消息。</p>
<pre><code>//发送一个文本消息
ws.send(&quot;this is websocket&quot;);
</code></pre><p>在open事件的回调中调用send()方法传送数据：</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;);
ws.onopen = e =&gt; {
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState.</p>
<p>close</p>
<p>close方法用来关闭连接。调用close方法后，将不能发送数据。close方法可以传入两个可选的参数，code 和reason, 以告诉服务端为什么终止连接。</p>
<pre><code>ws.close();

//1000是状态码，代表正常结束。
ws.close(1000, &quot;Closing normally&quot;);
</code></pre><h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><ul>
<li>readyState：</li>
</ul>
<p>readyState值表示连接状态，是只读属性。它有以下四个值：</p>
<blockquote>
<p>WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开</p>
</blockquote>
<p>除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。</p>
<pre><code>function bindEventHandler(data) {
if (ws.readyState === WebSocket.OPEN) {
       ws.send(data);
} else {
//do something
}
} 
</code></pre><p>bufferedAmount：</p>
<p>当客户端传输大量数据时，浏览器会缓存将要流出的数据，bufferedAmount属性可判断有多少字节的二进制数据没有发送出去，发送是否结束。</p>
<pre><code>ws.onopen = function () {
   setInterval( function() {
//缓存未满的时候发送
if (ws.bufferedAmount &lt; 1024 * 5) {
           ws.send(data);
}
}, 2000);
};
</code></pre><p>protocol：</p>
<p>protocol代表客户端使用的WebSocket协议。当握手协议未成功，这个属性是空。</p>
<ul>
<li>接下来，我们说说握手阶段过程。*</li>
</ul>
<p>当我们创建Websocket实例对象与服务器建立连接时，</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;)；
</code></pre><p>首先客户端向服务器发起一个握手请求，其请求报文的内容如下：</p>
<pre><code>GET /game HTTP/1.1
Host: 10.242.17.102:8023
Cache-Control: no-cache
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Protocol: game
Sec-WebSocket-Version: 10
Origin: http://192.168.185.16
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
</code></pre><p>从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。</p>
<ul>
<li>Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。</li>
<li>Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信</li>
<li>Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议</li>
<li>Sec-WebSocket-Version: 通知服务器所使用的协议版本</li>
</ul>
<p>服务器响应：</p>
<pre><code>当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。 
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ=
</code></pre><ul>
<li>101 状态码，表示要转换协议啦</li>
<li>Upgrde: 通知客户端将要升级成Websocket协议</li>
<li>Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-05e821d0db32cf8cb5ebf51625870cb1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-05e821d0db32cf8cb5ebf51625870cb1_hd.jpg" alt=""></p>
<p>至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/29/从Vue-js源码看nextTick机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/29/从Vue-js源码看nextTick机制/" itemprop="url">从Vue.js源码看nextTick机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-29T22:30:13+08:00">
                2018-07-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://link.zhihu.com/?target=https%3A//chuckliu.me/%23%21/posts/58bd08a2b5187d2fb51c04f9" target="_blank" rel="noopener">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></p>
<h2 id="可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。"><a href="#可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。" class="headerlink" title="可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。"></a>可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。</h2><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>在使用vue.js的时候，有时候因为一些特定的业务场景，不得不去操作DOM，比如这样：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: &apos;begin&apos;
        };
    },
    methods () {
        handleClick () {
            this.test = &apos;end&apos;;
            console.log(this.$refs.test.innerText);//打印“begin”
        }
    }
}
</code></pre><p>打印的结果是begin，为什么我们明明已经将test设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“begin”呢？</p>
<h2 id="Watcher队列"><a href="#Watcher队列" class="headerlink" title="Watcher队列"></a>Watcher队列</h2><p>带着疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。</p>
<pre><code>update () {
    /* istanbul ignore else */
    if (this.lazy) {
        this.dirty = true
    } else if (this.sync) {
        /*同步则执行run直接渲染视图*/
        this.run()
    } else {
        /*异步推送到观察者队列中，下一个tick时调用。*/
        queueWatcher(this)
    }
}
</code></pre><p>我们发现Vue.js默认是使用<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fguide%252Freactivity.html%2523%25E5%25BC%2582%25E6%25AD%25A5%25E6%259B%25B4%25E6%2596%25B0%25E9%2598%259F%25E5%2588%2597" target="_blank" rel="noopener">异步执行DOM更新</a>。<br>当异步执行update的时候，会调用queueWatcher函数。</p>
<pre><code>/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/
export function queueWatcher (watcher: Watcher) {
  /*获取watcher的id*/
  const id = watcher.id
  /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      /*如果没有flush掉，直接push到队列中即可*/
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i &gt;= 0 &amp;&amp; queue[i].id &gt; watcher.id) {
        i--
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
</code></pre><p>查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</p>
<p>那么，什么是下一个tick？</p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>vue.js提供了一个<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fapi%252F%2523Vue-nextTick" target="_blank" rel="noopener">nextTick</a>函数，其实也就是上面调用的nextTick。</p>
<p>nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion，看一下源码：</p>
<pre><code>/**
 * Defer a task to execute it asynchronously.
 */
 /*
    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function
    这个函数的作用是在task或者microtask中推入一个timerFunc，
    在当前调用栈执行完以后以此执行直到执行到timerFunc
    目的是延迟到当前调用栈执行完以后执行
*/
export const nextTick = (function () {
  /*存放异步执行的回调*/
  const callbacks = []
  /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/
  let pending = false
  /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/
  let timerFunc

  /*下一个tick时的回调*/
  function nextTickHandler () {
    /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/
    pending = false
    /*执行所有callback*/
    const copies = callbacks.slice(0)
    callbacks.length = 0
    for (let i = 0; i &lt; copies.length; i++) {
      copies[i]()
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */

  /*
    这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法
    优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。
    如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
    参考：https://www.zhihu.com/question/55364497
  */
  if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) {
    /*使用Promise*/
    var p = Promise.resolve()
    var logError = err =&gt; { console.error(err) }
    timerFunc = () =&gt; {
      p.then(nextTickHandler).catch(logError)
      // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn&apos;t being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.
      if (isIOS) setTimeout(noop)
    }
  } else if (typeof MutationObserver !== &apos;undefined&apos; &amp;&amp; (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === &apos;[object MutationObserverConstructor]&apos;
  )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/
    var counter = 1
    var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, {
      characterData: true
    })
    timerFunc = () =&gt; {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
    }
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    /*使用setTimeout将回调推入任务队列尾部*/
    timerFunc = () =&gt; {
      setTimeout(nextTickHandler, 0)
    }
  }

  /*
    推送到队列中下一个tick时执行
    cb 回调函数
    ctx 上下文
  */
  return function queueNextTick (cb?: Function, ctx?: Object) {
    let _resolve
    /*cb存到callbacks中*/
    callbacks.push(() =&gt; {
      if (cb) {
        try {
          cb.call(ctx)
        } catch (e) {
          handleError(e, ctx, &apos;nextTick&apos;)
        }
      } else if (_resolve) {
        _resolve(ctx)
      }
    })
    if (!pending) {
      pending = true
      timerFunc()
    }
    if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) {
      return new Promise((resolve, reject) =&gt; {
        _resolve = resolve
      })
    }
  }
})()
</code></pre><p>它是一个立即执行函数,返回一个queueNextTick接口。</p>
<p>传入的cb会被push进callbacks中存放起来，然后执行timerFunc（pending是一个状态标记，保证timerFunc在下一个tick之前只执行一次）。</p>
<p>timerFunc是什么？</p>
<p>看了源码发现timerFunc会检测当前环境而不同实现，其实就是按照Promise，MutationObserver，setTimeout优先级，哪个存在使用哪个，最不济的环境下使用setTimeout。</p>
<p>两者的具体实现</p>
<ul>
<li>macrotasks: setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染</li>
<li>microtasks: Promise， process.nextTick， Object.observe， MutationObserver</li>
</ul>
<p>再简单点可以总结为：<br><img src="https://pic1.zhimg.com/v2-e92a4f5f686d115832b63b9b9e3ac2cd_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-e92a4f5f686d115832b63b9b9e3ac2cd_hd.jpg" alt=""></p>
<ol>
<li>在 macrotask 队列中执行最早的那个 task ，然后移出</li>
<li>再执行 microtask 队列中所有可用的任务，然后移出</li>
<li><p>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</p>
<p>  这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。</p>
<pre><code>优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。
如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
</code></pre></li>
</ol>
<p>为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到：</p>
<blockquote>
<p>  JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。<br>setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、   MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。<br>       要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。<br>       实在不行，只能用 setTimeout 创建 task 了。<br>       为啥要用 microtask？<br>       根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。<br>       反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</p>
</blockquote>
<p>首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调，</p>
<p>MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。</p>
<p>至于 MutationObserver 如何模拟 nextTick 这点，直接看源码，其实就是创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容：    var counter = 1</p>
<pre><code>var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, {
      characterData: true
    })
    timerFunc = () =&gt; {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
    }
</code></pre><p>   setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行：</p>
<pre><code>setTimeout(function(){
    console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;);
},0);
</code></pre><p>它会将回调函数加入task中，等到执行。<br><img src="https://pic2.zhimg.com/v2-59cf9f88d7daac690d39edfb9fffc8b8_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-59cf9f88d7daac690d39edfb9fffc8b8_hd.jpg" alt=""></p>
<pre><code>setTimeout(function(){console.log(4)},0);
new Promise(function(resolve){
    console.log(1)
    for( var i=0 ; i&lt;10000 ; i++ ){
        i==9999 &amp;&amp; resolve()
    }
    console.log(2)
}).then(function(){
    console.log(5)
});
console.log(3);
结果是：
1,2,3,5,4
</code></pre><p>再看这个，两个自执行同时执行：</p>
<pre><code>&lt;script&gt;
(function test() {
  setTimeout(function () {
    console.log(4)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(1);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(2);
  }).then(function() {
    console.log(5);
  });
  console.log(3);
})()

(function test2() {
  setTimeout(function () {
    console.log(42)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(12);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(22);
  }).then(function() {
    console.log(52);
  });
  console.log(32);
})()
&lt;/script&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-cd18c572eb05069895ede7e34388bb8d_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-cd18c572eb05069895ede7e34388bb8d_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-afcb6fa6fb862818359f757107b769ab_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-afcb6fa6fb862818359f757107b769ab_hd.jpg" alt=""><br>整个执行过程是一个 main thread 【<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/link%3Furl%3DCV-egCVH8yK1w-ilUqGsztryG8s2mbuhAliIC_L1n_-BSZ_KJ16tAfaNkmbcRtU8" target="_blank" rel="noopener">主线程</a>】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的 <code>setTimeout</code> 进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。</p>
<pre><code>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：
</code></pre><p>   1.先执行 macrotasks：I/O -》 UI渲染</p>
<p>   2.再执行 microtasks ：process.nextTick  -》 Promise  -》MutationObserver -&gt;Object.observe</p>
<p>   3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：</p>
<p>setTimeout ，setInterval –》setImmediate</p>
<pre><code>  综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。

setImmediate(function(){
    console.log(1);
},0);
setTimeout(function(){
    console.log(2);
},0);
new Promise(function(resolve){
    console.log(3);
    resolve();
    console.log(4);
}).then(function(){
    console.log(5);
});
console.log(6);
process.nextTick(function(){
    console.log(7);
});
console.log(8);
结果是：3 4 6 8 7 5 2 1
</code></pre><h2 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h2><pre><code>/*Github:https://github.com/answershuto*/
/**
 * Flush both queues and run the watchers.
 */
 /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component&apos;s user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component&apos;s watcher run,
  //    its watchers can be skipped.
  /*
    给queue排序，这样做可以保证：
    1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。
    2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建
    3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。
  */
  queue.sort((a, b) =&gt; a.id - b.id)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/
  for (index = 0; index &lt; queue.length; index++) {
    watcher = queue[index]
    id = watcher.id
    /*将has的标记删除*/
    has[id] = null
    /*执行watcher*/
    watcher.run()
    // in dev build, check and stop circular updates.
    /*
      在测试环境中，检测watch是否在死循环中
      比如这样一种情况
      watch: {
        test () {
          this.test++;
        }
      }
      持续执行了一百次watch代表可能存在死循环
    */
    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] &gt; MAX_UPDATE_COUNT) {
        warn(
          &apos;You may have an infinite update loop &apos; + (
            watcher.user
              ? `in watcher with expression &quot;${watcher.expression}&quot;`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  /**/
  /*得到队列的拷贝*/
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  /*重置调度者的状态*/
  resetSchedulerState()

  // call component updated and activated hooks
  /*使子组件状态都改编成active同时调用activated钩子*/
  callActivatedHooks(activatedQueue)
  /*调用updated钩子*/
  callUpdateHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools &amp;&amp; config.devtools) {
    devtools.emit(&apos;flush&apos;)
  }
}
</code></pre><p>flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图</p>
<h2 id="为什么要异步更新视图"><a href="#为什么要异步更新视图" class="headerlink" title="为什么要异步更新视图"></a>为什么要异步更新视图</h2><p>来看一下下面这一段代码</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;{{test}}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: 0
        };
    },
    created () {
      for(let i = 0; i &lt; 1000; i++) {
        this.test++;
      }
    }
}
</code></pre><p>现在有这样的一种情况，created的时候test的值会被++循环执行1000次。<br>每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。<br>如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。<br>所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。<br>保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</p>
<h2 id="访问真实DOM节点更新后的数据"><a href="#访问真实DOM节点更新后的数据" class="headerlink" title="访问真实DOM节点更新后的数据"></a>访问真实DOM节点更新后的数据</h2><p>所以我们需要在修改data中的数据后访问真实的DOM节点更新后的数据，只需要这样，我们把文章第一个例子进行修改。</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: &apos;begin&apos;
        };
    },
    methods () {
        handleClick () {
            this.test = &apos;end&apos;;
            this.$nextTick(() =&gt; {
                console.log(this.$refs.test.innerText);//打印&quot;end&quot;
            });
            console.log(this.$refs.test.innerText);//打印“begin”
        }
    }
}
</code></pre><p>使用Vue.js的global API的$nextTick方法，即可在回调中获取已经更新好的DOM实例了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/26/CSS-defer和async的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/26/CSS-defer和async的区别/" itemprop="url">CSS defer和async的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-26T22:46:19+08:00">
                2018-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
<p>然后从实用角度来说呢，首先把所有脚本都丢到  之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p>
<p>接着，我们来看一张图咯：</p>
<p><img src="https://pic3.zhimg.com/v2-256ddc294b88b9a082b3b2aafe193728_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-256ddc294b88b9a082b3b2aafe193728_hd.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-244a0c3246f534e96ce88124e3978261_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-244a0c3246f534e96ce88124e3978261_hd.jpg" alt=""></p>
<h2 id="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】"><a href="#蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】" class="headerlink" title="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】"></a>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】</h2><p>此图告诉我们以下几个要点：</p>
<ol>
<li>defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>
<li>它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的</li>
<li>关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>
<li>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>
<li>仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/15/nodejs几种文件路径及path模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/15/nodejs几种文件路径及path模块/" itemprop="url">Node.js几种文件路径及path模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-15T22:24:49+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在写一篇weex的webpack配置，刚刚踩坑了，weekpack中会用到path模块，而对于这个模块，我想抽离出来看一下，因为这个用到的还是比较多的,喜欢的朋友可以点个喜欢，或者去我的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Flaihuamin%252FJS-total" target="_blank" rel="noopener">github</a>点个star也行，谢谢支持，举起小手指点一点哦😯，写的不对的地方，评论拍砖，谢谢。</p>
<h2 id="node中的路径分类"><a href="#node中的路径分类" class="headerlink" title="node中的路径分类"></a>node中的路径分类</h2><p>node中的路径大致分5类，dirname,filename,process.cwd(),./,../,其中前三个都是绝对路径</p>
<p>我们先来看一个简单点的例子</p>
<p>假如，我有一个文件的目录结构如下：</p>
<pre><code>editor/
  - dist/
  - src/
      - task.js
</code></pre><p>然后我们在task.js文件中写入一下代码</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(__dirname);
console.log(__filename);
console.log(process.cwd());
console.log(path.resolve(&apos;./&apos;));
</code></pre><p>在editor目录下运行node src/task.js，我们可以看到结果如下：</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src/task.js
/Users/laihuamin/Documents/richEditor/editor
/Users/laihuamin/Documents/richEditor/editor
</code></pre><p>然后我们有可以在src目录下运行这个文件，node task.js,运行结果如下：</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src/task.js
/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src
</code></pre><p>对比两个输出结果，我们可以归纳一下几点：</p>
<p>1.<strong>dirname:返回的是这个文件所在文件夹的位置<br>2.</strong>filename:你运行命令代表的是文件所在的位置，不管你运行什么命令，都是指向文件<br>3.process.cwd():你运行node命令所在文件夹的位置，比如你在src目录下运行，那么就是输出到src为止，下面的同理。</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>讲完前面三个绝对路径，我倒是挺想来聊聊path这个模块的，这个node模块在很多地方都有应用，所以，对于我们来说，掌握他，对我们以后的发展更有利，不用每次看webpack的配置文件还要去查询一下这个api是干什么用的，很影响我们的效率</p>
<p><a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fnodejs.org%252Fapi%252Fpath.html" target="_blank" rel="noopener">nodeJS/path</a></p>
<p>上面那个网站有详细的api，但是我们这里不用都掌握吧，我就讲几个我遇到过的，我觉得webpack等工程配置中会用到的</p>
<h2 id="path-normalize"><a href="#path-normalize" class="headerlink" title="path.normalize"></a>path.normalize</h2><p>这个方法就是把不规范的路径规范化，比如看下面的例子</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;));
</code></pre><p>输出结果：</p>
<pre><code>/foo/bar/baz/asdf
</code></pre><h2 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h2><pre><code>const path = require(&apos;path&apos;);
console.log(path.join(&apos;src&apos;, &apos;task.js&apos;));

const path = require(&apos;path&apos;);
console.log(path.join(&apos;dist&apos;, &apos;task.js&apos;));

const path = require(&apos;path&apos;);
console.log(path.join(&apos;&apos;));
</code></pre><p>这么两个的输出结果是：</p>
<pre><code>src/task.js
dist/task.js
.
</code></pre><p>他的作用也就显而易见，他有一下几条规则：<br>1.传入的参数是字符串的路径片段，可以是一个，也可以是多个</p>
<p>2.返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，Unix系统是”/“，Windows系统是”\“，那么你在两个系统下看到的返回结果就不一样。</p>
<p>3.如果返回的路径字符串长度为零，那么他会返回一个’.’，代表当前的文件夹。</p>
<p>4.如果传入的参数中有不是字符串的，那就直接会报错</p>
<h2 id="path-parse"><a href="#path-parse" class="headerlink" title="path.parse"></a>path.parse</h2><p>我们先来看个例子，在src目录下的task.js写入</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor&apos;));
</code></pre><p>然后运行node src/task.js之后,输出的结果如下：</p>
<pre><code>{ 
  root: &apos;/&apos;,
  dir: &apos;/Users/laihuamin/Documents/richEditor&apos;,
  base: &apos;editor&apos;,
  ext: &apos;&apos;,
  name: &apos;editor&apos; 
}
</code></pre><p>他返回的是一个对象，那么我们来把这么几个名词熟悉一下：</p>
<p><img src="https://pic3.zhimg.com/v2-b7c5d496b89fde98f097a4a6e2ba7d03_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b7c5d496b89fde98f097a4a6e2ba7d03_hd.jpg" alt=""></p>
<p>这个表格应该展示的很形象，但是我们还是来解释一下这些名词：<br>1.root：代表根目录<br>2.dir：代表文件所在的文件夹<br>3.base：代表整一个文件<br>4.name：代表文件名<br>5.ext: 代表文件的后缀名</p>
<p>那我们根据下面的规则，来看一下下面这个例子，最好自己脑子做一遍</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果：</p>
<pre><code>{ 
  root: &apos;/&apos;,
  dir: &apos;/Users/laihuamin/Documents/richEditor/editor/src&apos;,
  base: &apos;task.js&apos;,
  ext: &apos;.js&apos;,
  name: &apos;task&apos; 
}
</code></pre><p>你做对了么？0.0</p>
<h2 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename"></a>path.basename</h2><p>那有了前面这个铺垫，想必这个接口猜也能猜的到了。。。。我们看下面这个例子</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果是：</p>
<pre><code>task.js
</code></pre><p>我们还是简单介绍一下，接收两个参数，一个是path,还有一个是ext（可选参数）.</p>
<pre><code>const path = require(&apos;path&apos;)
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;, &apos;.js&apos;));
</code></pre><p>输出结果:</p>
<pre><code>task
</code></pre><h2 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname"></a>path.dirname</h2><p>这个接口比basename还要简单，我就不多说了，看例子，看结果</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果:</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
</code></pre><p>注意一下，接收的参数是字符串类型</p>
<h2 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname"></a>path.extname</h2><p>这个就是展示文件的扩展名，我们得注意几种情况</p>
<pre><code>const path = require(&apos;path&apos;);
path.extname(&apos;index.html&apos;);
path.extname(&apos;index.coffee.md&apos;);
path.extname(&apos;index.&apos;);
path.extname(&apos;index&apos;);
path.extname(&apos;.index&apos;);
</code></pre><p>输出的结果是：</p>
<pre><code>.html
.md
.
&apos;&apos;
&apos;&apos;
</code></pre><p>自己注意一下这几个情况</p>
<h2 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h2><p>我们通过下面这几个例子先来熟悉一下：</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.resolve(&apos;/foo/bar&apos;, &apos;/bar/faa&apos;, &apos;..&apos;, &apos;a/../c&apos;));
</code></pre><p>输出的结果是</p>
<pre><code>/bar/c
</code></pre><p>他就相当于一堆cd操作，我们一步一步看</p>
<pre><code>cd /foo/bar/    //这是第一步, 现在的位置是/foo/bar/
cd /bar/faa     //这是第二步，这里和第一步有区别，他是从/进入的，也就时候根目录，现在的位置是/bar/faa
cd ..       //第三步，从faa退出来，现在的位置是 /bar
cd a/../c   //第四步，进入a，然后在推出，在进入c，最后位置是/bar/c
</code></pre><p>但是这个操作和cd还是有区别的，这个路径不一定要存在，而且最后的可以是文件</p>
<h2 id="path-relative"><a href="#path-relative" class="headerlink" title="path.relative"></a>path.relative</h2><p>这个返回的是from到to的相对路径，什么意思呢，我们看下面的例子就知道了.</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.relative(&apos;src/bar/baz&apos;, &apos;src/aaa/bbb&apos;));
</code></pre><p>输出的结果是：</p>
<pre><code>../../aaa/bbb
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些比较实用的方法，分享给大家，自己还是老老实实去看weektool的webpack的配置文件了，喜欢的朋友可以点个喜欢，或者去我的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Flaihuamin%252FJS-total" target="_blank" rel="noopener">github</a>点个star也行，谢谢支持，举起小手指点一点哦😯。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/ES6-实现自己的-Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/ES6-实现自己的-Promise/" itemprop="url">ES6实现自己的 Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T22:15:53+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、JavaScript异步编程背景"><a href="#一、JavaScript异步编程背景" class="headerlink" title="一、JavaScript异步编程背景"></a>一、JavaScript异步编程背景</h2><p>从去年ES2015发布至今，已经过去了一年多，ES2015发布的新的语言特性中最为流行的也就莫过于Promise了，Promise使得如今JavaScript异步编程如此轻松惬意，甚至慢慢遗忘了曾经那不堪回首的痛楚。其实从JavaScript诞生，JavaScript中的异步编程就已经出现，例如点击鼠标、敲击键盘这些事件的处理函数都是异步的，时间到了2009年，Node.js横空出世，在整个Node.js的实现中，将回调模式的异步编程机制发挥的淋漓尽致，Node的流行也是的越来越多的JavaScripter开始了异步编程，但是回调模式的副作用也慢慢展现在人们眼前，错误处理不够优雅以及嵌套回调带来的“回调地狱”。这些副作用使得人们从回调模式的温柔乡中慢慢清醒过来，开始寻找更为优雅的异步编程模式，路漫漫其修远兮、吾将上下而求索。时间到了2015年，Promise拯救那些苦苦探索的先驱。行使它历史使命的时代似乎已经到来。</p>
<p>每个事物的诞生有他的历史使命，更有其历史成因，促进其被那些探索的先驱们所发现。了解nodejs或者熟悉浏览器的人都知道，JavaScript引擎是基于事件循环或单线程这两个特性的。更为甚者在浏览器中，更新UI(也就是浏览器重绘、重拍页面布局)和执行JavaScript代码也在一个单线程中，可想而知，一个线程就相当于只有一条马路，如果一辆马车抛锚在路上了阻塞了马路，那么别的马车也就拥堵在了那儿，这个单线程容易被阻塞是一个道理，单线程也只能允许某一时间点只能够执行一段代码。同时，JavaScript没有想它的哥哥姐姐们那么财大气粗，像Java或者C++，一个线程不够，那么再加一个线程，这样就能够同时执行多段代码了，但是这样就会带来的隐患就是状态不容易维护，JavaScript选择了单线程非阻塞式的方式，也就是异步编程的方式，就像上面的马车抛锚在了路上，那么把马车推到路边的维修站，让其他马车先过去，等马车修好了再回到马路上继续行驶，这就是单线程非阻塞方式。正如Promise的工作方式一样，通过Promise去向服务器发起一个请求，毕竟请求有网络开销，不可能马上就返回请求结果的，这个时候Promise就处于pending状态，但是其并不会阻塞其他代码的执行，当请求返回时，修改Promise状态为fulfilled或者rejected（失败请求）。同时执行绑定到这两个状态上面的“处理函数”。这就是异步编程的模式，也就是Promise兢兢业业的工作方式，在下面一个部分将详细讨论Promise。</p>
<h2 id="二、Promise基础"><a href="#二、Promise基础" class="headerlink" title="二、Promise基础"></a>二、Promise基础</h2><p>怎么一句话解释Promise呢？Promise可以代指那些尚未完成的一些操作，但是其在未来的某个时间会返回某一特定的结果。</p>
<p>当创建一个Promise实例后，其代表一个未知的值，在将来的某个时间会返回一个成功的返回值，或者失败的返回值，我们可以为这些返回值添加处理函数，当值返回时，处理函数被调用。Promise总是处于下面三种状态之一：</p>
<ul>
<li>pending： Promise的初始状态，也就是未被fulfilled或者rejected的状态。</li>
<li>fulfilled： 意味着promise代指的操作已经成功完成。</li>
<li>rejected：意味着promise代指的操作由于某些原因失败。</li>
</ul>
<p>一个处于pending状态的promise可能由于某个成功返回值而发展为fulfilled状态，也有可能因为某些错误而进入rejected状态，无论是进入fulfilled状态或者rejected状态，绑定到这两种状态上面的处理函数就会被执行。并且进入fulfilled或者rejected状态也就不能再返回pending状态了。<br><img src="https://pic4.zhimg.com/v2-cf3e4ae1a35caad7c2d8d7bdd8c763d2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-cf3e4ae1a35caad7c2d8d7bdd8c763d2_hd.jpg" alt=""></p>
<h2 id="三、边学边写"><a href="#三、边学边写" class="headerlink" title="三、边学边写"></a>三、边学边写</h2><p>上面说了那么多，其实都是铺垫。接下来我们就开始实现自己的Promise对象。go go go！！！</p>
<h2 id="第一步：Promise构造函数"><a href="#第一步：Promise构造函数" class="headerlink" title="第一步：Promise构造函数"></a>第一步：Promise构造函数</h2><p>Promise有三种状态，pending、fulfilled、rejected。</p>
<pre><code>const PENDING = &apos;PENDING&apos; // Promise 的 初始状态
const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态
const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态
</code></pre><p>有了三种状态后，那么我们怎么创建一个Promise实例呢？</p>
<blockquote>
<p>const promise = new Promise(executor) // 创建Promise的语法</p>
</blockquote>
<p>通过上面生成promise语法我们知道，Promise实例是调用Promise构造函数通过new操作符生成的。这个构造函数我们可以先这样写：</p>
<pre><code>class Promise {
    constructor(executor) {
        this.status = PENDING // 创建一个promise时，首先进行状态初始化。pending
        this.result = undefined // result属性用来缓存promise的返回结果，可以是成功的返回结果，或失败的返回结果
    }
}
</code></pre><p>我们可以看到上面构造函数接受的参数executor。它是一个函数，并且接受其他两个函数（resolve和reject）作为参数，当resolve函数调用后，promise的状态转化为fulfilled，并且执行成功返回的处理函数（不用着急后面会说到怎么添加处理函数）。当reject函数调用后，promise状态转化为rejected，并且执行失败返回的处理函数。</p>
<p>现在我们的代码大概是这样的：</p>
<pre><code>class Promise {
    constructor(executor) {
        this.status = PENDING 
        this.result = undefined
        executor(data =&gt; resolveProvider(this, data), err =&gt; rejectProvider(this, err))
    }
}

function resolveProvider(promise, data) {
    if (promise.status !== PENDING) return false
    promise.status = FULFILLED
}
function rejectProvider(promise, data) {
    if (promise.status !== PENDING) return false
    promise.status = FULFILLED
}
</code></pre><p>Dont Repeat Yourselt！！！我们可以看到上面代码后面两个函数基本相同，其实我们可以把它整合成一个函数，在结合高阶函数的使用。</p>
<pre><code>const statusProvider = (promise, status) =&gt; data =&gt; {
    if (promise.status !== PENDING) return false
    promise.status = status
    promise.result = data
}
class Promise {
    constructor(executor) {
        this.status = PENDING 
        this.result = undefined
        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
    }
}
</code></pre><p>现在我们的代码就看上去简洁多了。</p>
<h2 id="第二步：为Promise添加处理函数"><a href="#第二步：为Promise添加处理函数" class="headerlink" title="第二步：为Promise添加处理函数"></a>第二步：为Promise添加处理函数</h2><p>其实通过 <code>new Promise(executor)</code>已经可以生成一个Promise实例了，甚至我们可以通过传递到executor中的resolve和reject方法来改变promise状态，但是！现在的promise依然没啥卵用！！！因为我们并没有给它添加成功和失败返回的处理函数。</p>
<p>首先我们需要给我们的promise增加两个属性，successListener和failureListener用来分别缓存成功处理函数和失败处理函数。</p>
<pre><code>class Promise {
    constructor(executor) {
        this.status = PENDING
         this.successListener = []
         this.failureListener = []
        this.result = undefined
        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
    }
}
</code></pre><p>怎么添加处理函数呢？ECMASCRIPT标准中说到，我们可以通过promise原型上面的then方法为promise添加成功处理函数和失败处理函数，可以通过catch方法为promise添加失败处理函数。</p>
<pre><code>const statusProvider = (promise, status) =&gt; data =&gt; {
    if (promise.status !== PENDING) return false
    promise.status = status
    promise.result = data
    switch(status) {
        case FULFILLED: return promise.successListener.forEach(fn =&gt; fn(data))
        case REJECTED: return promise.failurelistener.forEach(fn =&gt; fn(data))
    }
}
class Promise {
    constructor(executor) {
        this.status = PENDING
        this.successListener = []
        this.failurelistener = []
        this.result = undefined
        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
    }
    /**
     * Promise原型上面的方法
     */
    then(...args) {
        switch (this.status) {
            case PENDING: {
                this.successListener.push(args[0])
                this.failurelistener.push(args[1])
                break
            }
            case FULFILLED: {
                args[0](this.result)
                break
            }
            case REJECTED: {
                args[1](this.result)
            }
        }
    }
    catch(arg) {
        return this.then(undefined, arg)
    }
}
</code></pre><p>我们现在的Promise基本初具雏形了。甚至可以运用到一些简单的场景中了。举个例子。</p>
<pre><code>/*创建一个延时resolve的pormise*/
new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; resolve(5), 2000)}).then(data =&gt; console.log(data)) // 5
/*创建一个及时resolve的promise*/
new Promise((resolve, reject) =&gt; resolve(5)).then(data =&gt; console.log(data)) // 5
/*链式调用then方法还不能够使用！*/
new Promise(resolve=&gt; resolve(5)).then(data =&gt; data).then(data =&gt; console.log(data))
// Uncaught TypeError: Cannot read property &apos;then&apos; of undefined
</code></pre><h2 id="第三步：Promise的链式调用"><a href="#第三步：Promise的链式调用" class="headerlink" title="第三步：Promise的链式调用"></a>第三步：Promise的链式调用</h2><p>Promise需要实现链式调用，我们需要再次回顾下then方法的定义：</p>
<blockquote>
<p>then方法为pormise添加成功和失败的处理函数，同时then方法返回一个新的promise对象，这个新的promise对象resolve处理函数的返回值，或者当没有提供处理函数时直接resolve原始的值。</p>
</blockquote>
<p>可以看出，promise能够链式调用归功于then方法返回一个全新的promise，并且resolve处理函数的返回值，当然，如果then方法的处理函数本身就返回一个promise，那么久不用我们自己手动生成一个promise了。了解了这些，就开始动手写代码了。</p>
<pre><code>const isPromise = object =&gt; object &amp;&amp; object.then &amp;&amp; typeof object.then === &apos;function&apos;
const noop = () =&gt; {}

const statusProvider = (promise, status) =&gt; data =&gt; {
    // 同上面代码
}

class Promise {
    constructor(executor) {
        // 同上面代码
    }
    then(...args) {
        const child = new this.constructor(noop)

        const handler = fn =&gt; data =&gt; {
            if (typeof fn === &apos;function&apos;) {
                const result = fn(data)
                if (isPromise(result)) {
                    Object.assign(child, result)
                } else {
                    statusProvider(child, FULFILLED)(result)
                }   
            } else if(!fn) {
                statusProvider(child, this.status)(data)
            }
        }
        switch (this.status) {
            case PENDING: {
                this.successListener.push(handler(args[0]))
                this.failurelistener.push(handler(args[1]))
                break
            }
            case FULFILLED: {
                handler(args[0])(this.result)
                break
            }
            case REJECTED: {
                handler(args[1])(this.result)
                break
            }
        }
        return child
    }
    catch(arg) {
        return this.then(undefined, arg)
    }
}
</code></pre><p>首先我们写了一个isPromise方法，用于判断一个对象是否是promise。就是判断对象是否有一个<code>then</code>方法，免责声明为了实现上的简单，我们不区分thenable和promise的区别，但是我们应该是知道。所有的promise都是thenable的，而并不是所有的thenable对象都是promise。（thenable对象是指带有一个then方法的对象，该then方法其实就是一个executor。）isPromise的作用就是用于判断then方法返回值是否是一个promise，如果是promise，就直接返回该promise，如果不是，就新生成一个promise并返回该promise。</p>
<p>由于需要链式调用，我们对successListener和failureListener中处理函数进行了重写，并不是直接push进去then方法接受的参数函数了，因为then方法需要返回一个promise，所以当then方法里面的处理函数被执行的同时，我们也需要对then方法返回的这个promise进行处理，要么resolve，要么reject掉。当然，大部分情况都是需要resolve掉的，只有当then方法没有添加第二个参数函数，同时调用then方法的promise就是rejected的时候，才需要把then方法返回的pormise进行reject处理，也就是调用<code>statusProvider(child, REJECTED)(data)</code>.</p>
<p>toy Promise实现的完整代码：</p>
<pre><code>const PENDING = &apos;PENDING&apos; // Promise 的 初始状态
const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态
const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态

const isPromise = object =&gt; object &amp;&amp; object.then &amp;&amp; typeof object.then === &apos;function&apos;
const noop = () =&gt; {}

const statusProvider = (promise, status) =&gt; data =&gt; {
    if (promise.status !== PENDING) return false
    promise.status = status
    promise.result = data
    switch(status) {
        case FULFILLED: return promise.successListener.forEach(fn =&gt; fn(data))
        case REJECTED: return promise.failurelistener.forEach(fn =&gt; fn(data))
    }
}

class Promise {
    constructor(executor) {
        this.status = PENDING
        this.successListener = []
        this.failurelistener = []
        this.result = undefined 
        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
    }
    /**
     * Promise原型上面的方法
     */
    then(...args) {
        const child = new this.constructor(noop)

        const handler = fn =&gt; data =&gt; {
            if (typeof fn === &apos;function&apos;) {
                const result = fn(data)
                if (isPromise(result)) {
                    Object.assign(child, result)
                } else {
                    statusProvider(child, FULFILLED)(result)
                }   
            } else if(!fn) {
                statusProvider(child, this.status)(data)
            }
        }
        switch (this.status) {
            case PENDING: {
                this.successListener.push(handler(args[0]))
                this.failurelistener.push(handler(args[1]))
                break
            }
            case FULFILLED: {
                handler(args[0])(this.result)
                break
            }
            case REJECTED: {
                handler(args[1])(this.result)
                break
            }
        }
        return child
    }
    catch(arg) {
        return this.then(undefined, arg)
    }
}
</code></pre><h2 id="四、怎么让我们的toy-Promise变强健"><a href="#四、怎么让我们的toy-Promise变强健" class="headerlink" title="四、怎么让我们的toy Promise变强健"></a>四、怎么让我们的toy Promise变强健</h2><ol>
<li>在ECMAScript标准中，Promise构造函数上面还提供了一些静态方法，比如<code>Promise.resolve</code>、<code>Promise.reject</code>、<code>Promsie.all</code>、<code>Promise.race</code>。当我们有了上面的基础实现后，为我们的toy Promise添加上面这些新的功能一定能让其更加实用。</li>
<li>在我们的基本实现中，我们并没有区分thenable对象，其实<code>Promise.resolve</code>和<code>then</code>方法都可以接受一个thenable对象，并把该thenable对象转化为一个promise对象，如果想让我们的toy Promise用于生产的话，这也是要考虑的。</li>
<li>为了让我们的toy Promise变得更强壮，我们需要拥有强健的错误处理机制，比如验证executor必须是一个函数、then方法的参数只能是函数或者undefined或null，又比如executor和then方法中抛出的错误并不能够被window.onerror监测到，而只能够通过错误处理函数来处理，这也是需要考虑的因素。</li>
<li>如果我们的Promise polyfill是考虑支持多平台，那么首要考虑的就是浏览器环境或Node.js环境，其实在这两个平台，原生Promise都是支持两个事件的。就拿浏览器端举例：</li>
</ol>
<ul>
<li><code>unhandledrejection</code>: 在一个事件循环中，如果我们没有对promise返回的错误进行处理，那么就会在window对象上面触发该事件。</li>
<li><code>rejectionhandled</code>:如果在一个事件循环后，我们才去对promise返回的错误进行处理，那么就会在window对象上面监听到此事件。</li>
</ul>
<p>关于这两个事件以及node.js平台上面类似的事件请参考Nicholas C. Zakas新书</p>
<p>Promise能够很棒的处理异步编程，要想学好它我认为最好的方法就是亲自动手去实现一个自己的Promise。</p>
<p>完整code：</p>
<pre><code>/**
 * 2016.09.19
 */
const PENDING = &apos;PENDING&apos; // Promise 的初始状态
const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态
const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态

const isThenable = data =&gt; data &amp;&amp; data.then &amp;&amp; typeof data.then === &apos;function&apos;
const isPromise = object =&gt; isThenable(object) &amp;&amp; (&apos;catch&apos; in object) &amp;&amp; typeof object.catch === &apos;function&apos;
const noop = () =&gt; {}
const range = n =&gt; n === 0 ? [] : [n, ...range(n - 1)]

// resolve function
const statusProvider = (promise, status) =&gt; data =&gt; {
    if (promise.status !== PENDING) return false
    promise.status = status
    promise.result = data
    promise.listeners[status].forEach(fn =&gt; fn(data))
}

class APromise {
    constructor(executor) {
        if (typeof executor !== &apos;function&apos;) {
            throw new TypeError(`Promise resolver ${executor.toString()} is not a function`)
        }
        this.status = PENDING
        this.listeners = {
            FULFILLED: [],
            REJECTED: []
        }
        this.result = undefined

        try {
            executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
        } catch (e) {
            statusProvider(this, REJECTED)(e)
        }
    }
    // prototype method
    then(...args) {
        const child = new this.constructor(noop)

        const handler = fn =&gt; data =&gt; {
            if (typeof fn === &apos;function&apos;) {
                try {
                    const result = fn(data)
                    if (isThenable(result)) {
                        isPromise(result) ? Object.assign(child, result) : Object.assign(child, new this.constructor(result.then))
                    } else {
                        statusProvider(child, FULFILLED)(result)
                    }
                } catch (e) {
                    statusProvider(child, REJECTED)(e)
                }
            } else if (!fn) {
                statusProvider(child, this.status)(data)
            }
        }
        switch (this.status) {
            case PENDING: {
                this.listeners[FULFILLED].push(handler(args[0]))
                this.listeners[REJECTED].push(handler(args[1]))
                break
            }
            case FULFILLED: {
                handler(args[0])(this.result)
                break
            }
            case REJECTED: {
                handler(args[1])(this.result)
                break
            }
        }
        return child
    }

    catch(arg) {
        return this.then(undefined, arg)
    }
}

APromise.resolve = data =&gt; {
    if (isPromise(data)) return data
    return isThenable(data) ? new APromise(data.then) : new APromise((resolve, reject) =&gt; resolve(data))
}

APromise.reject = err =&gt; new APromise((resolve, reject) =&gt; reject(err))

APromise.all = promises =&gt; {
    const length = promises.length
    const result = new APromise(noop)
    let count = 0
    const values = range(length)

    promises.forEach((p, i) =&gt; {
        p.then(data =&gt; {
            values[i] = data
            count++
            if (count === length) statusProvider(result, FULFILLED)(values)
        }, statusProvider(result, REJECTED))
    })
    return result
}

APromise.race = promises =&gt; {
    const result = new APromise(noop)
    promises.forEach((p, i) =&gt; {
        p.then(statusProvider(result, FULFILLED), statusProvider(result, REJECTED))
    })
    return result
}

export default APromise
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


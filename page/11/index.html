<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/11/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/04/JavaScript核武库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/04/JavaScript核武库/" itemprop="url">JavaScript核武库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-04T16:24:04+08:00">
                2015-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下是个人总结，也有一些是copy大神的，现在放到一起，方便以后查阅（有不对的地方，还望大家能够提出，我会尽快加以改正）。</p>
<h2 id="强制转boolean"><a href="#强制转boolean" class="headerlink" title="!!强制转boolean"></a>!!强制转<code>boolean</code></h2><p>根据真值，假值 判断，返回<code>true</code>，<code>false</code>假值：  0     “”  null   undefined  false NaN</p>
<pre><code>例如：
var nu=null;
var nul=&quot;&quot;;
var str=&quot;abcd&quot;;

console.log(!!nu)     // false;
console.log(!!nul)    // false;
console.log(!!str)    // true;
</code></pre><h2 id="obj-强制转Number"><a href="#obj-强制转Number" class="headerlink" title="+obj 强制转Number"></a>+obj 强制转<code>Number</code></h2><p> 将对象强制转<code>number</code>,如果是纯数字的“88”字符串，可转为<code>number</code></p>
<pre><code>var a=&quot;88&quot;;
console.log(+a)   =&gt;88
//但是如果是混合类型的字符串，则会转为NaN
var b=&quot;1606e&quot;;
console.log(+b)  =&gt; NaN
</code></pre><h2 id="强制取整"><a href="#强制取整" class="headerlink" title="~~ 强制取整"></a>~~ 强制取整</h2><pre><code>~~ 12.34
 12
~~ 12.88
 12
</code></pre><h2 id="不可靠的undefined-可靠的void-0"><a href="#不可靠的undefined-可靠的void-0" class="headerlink" title="不可靠的undefined 可靠的void 0"></a>不可靠的<code>undefined</code> 可靠的<code>void 0</code></h2><p>在<code>JavaScript</code>中，假设我们想判断一个是否是 <code>undefined</code>，那么我们通常会这样写：</p>
<pre><code>if(a === undefined){
  dosomething
}
</code></pre><p>//但是在<code>javascript</code>中，<code>undefined</code>是不可靠的</p>
<p>例如：<br>当undefined在函数内，并且是在局部变量是可以赋上值</p>
<pre><code>function foo2(){
 var undefined=1;
 console.log(undefined)
}
foo2();  =&gt;1;
</code></pre><p>但是当在函数内定义一个全局变量，并不能给赋上值</p>
<pre><code>var undefined;
function foo2(){
undefined=1;
 console.log(undefined)
}
foo2()  // undefined
void 0或者 void (0)：
</code></pre><p>最常见的用法是通过<code>void 0</code> 运算来获得 <code>undefined</code>，表达式为 0 时的运算开销最小：<br>那在以后需要判断值为<code>undefined</code>的时候，可以直接用<code>void 0</code>或者<code>void (0)</code></p>
<h2 id="字符串也是有length属性的！"><a href="#字符串也是有length属性的！" class="headerlink" title="字符串也是有length属性的！"></a>字符串也是有<code>length</code>属性的！</h2><p>我们知道所有的<code>array</code>都是有<code>length</code>,属性，就算事空数组，<code>length</code> 是0，那么字符串有没有呢？接下来我们来验证一下：</p>
<pre><code>var str=&quot;sdfsd5565s6dfsd65sd6+d5fd5&quot;;
console.log(str.length)      // 26
</code></pre><p>结果是有的，所以我们在判断类型时，不能单纯拿有没有<code>length</code>属性来判断是不是数组了，我们可以用下面的方法：</p>
<pre><code>var obj=[1,2] ;
console.log(toString.call(obj) === &apos;[object Array]&apos;);
</code></pre><h2 id="生成一个随机数组-创建数组，sort排序"><a href="#生成一个随机数组-创建数组，sort排序" class="headerlink" title="生成一个随机数组(创建数组，sort排序)"></a>生成一个随机数组(创建数组，<code>sort</code>排序)</h2><p>在项目中有时候我们需要一个随机打乱的数组，那么下面我们来实现以下：<br>先来创建一个数组：</p>
<pre><code>var arr=[];
for(var i=0;i&lt;10;i++){
   arr.push(i)
}
console.log(arr)    //  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p>接下来我们来打乱它：</p>
<pre><code>arr.sort(()=&gt;{
 return Math.random() - 0.5
})                 // [1, 0, 2, 3, 4, 6, 8, 5, 7, 9] 
</code></pre><p>第二种打乱方法：</p>
<pre><code>arr.sort((a,b)=&gt;{
　　　return a&gt;Math.random()*10;
})               //  [1, 2, 0, 6, 4, 3, 8, 9, 7, 5]
</code></pre><p>我们以前的正常排序是这样的：</p>
<pre><code>arr.sort(function(a,b){
   return b-a
});
</code></pre><p>解析：<br>先说正常的排序：<br>a,b表示数组中的任意两个元素，若<code>return &gt; 0</code> b前a后；<code>reutrn &lt; 0</code> a前b后；<code>a=b</code>时存在浏览器兼容 ，<br><code>a-b</code>输出从小到大排序，<code>b-a</code>输出从大到小排序。<br>然后再说我们打乱的方法：<br>创建数组不用说，接下来就是用js的sort方法 来实现，<code>Math.random()</code>实现一个随机<code>0-1</code>之间的小数 然后再减去<code>0.5</code>，这时就会根据return比较后得到的值排，所以说就会生成不是正常从大到小或者从小到大的排序。</p>
<p>第二个打乱的方法同样是遵循<code>sort</code>的方法，将<code>a,b</code>传进去 然后和随机数做比较，关于比较的方法不太清楚。</p>
<h2 id="去除前后、前、后-所有空格"><a href="#去除前后、前、后-所有空格" class="headerlink" title="去除前后、前、后 所有空格"></a>去除前后、前、后 所有空格</h2><p> 这是专门为去除空格写的一套方法，适用于各种情况，所有空格,前后空格，前空格，后空格。</p>
<p>var strr=”    1 ad dertasdf sdfASDFDF DFG SDFG    “<br>//  type 1-所有空格  2-前后空格  3-前空格 4-后空格</p>
<pre><code>function trim(str,type){
    switch (type){
        case 1:return str.replace(/\s+/g,&quot;&quot;);
        case 2:return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
        case 3:return str.replace(/(^\s*)/g, &quot;&quot;);
        case 4:return str.replace(/(\s*$)/g, &quot;&quot;);
        default:return str;
    }
}
console.log( trim(strr,1))      //  &quot;1addertasdfsdfASDFDFDFGSDFG&quot;
</code></pre><p>解析：<br>  这个方法用的是正则的匹配格式,后面我会把正则单独拿出来总结一个系列，敬请期待！！！</p>
<pre><code>\s ： 空格符，Tab,换页符，换行符
  \S ： 非\s的所有内容
  /g :  全局匹配
  ^  :  匹配在行首
  $  :  匹配在行尾
  +  ： 重复次数&gt;0
  *  ： 重复次数&gt;=0
  |  :  或者
</code></pre><p><code>replace(a,b)</code>： 方法用于在字符创中用一些字符替换另一些字符, 会传入两个值，将逗号前面的值<code>a</code>替换成逗号后面的值<code>b</code></p>
<h2 id="字母大小写切换（正则匹配，replace）"><a href="#字母大小写切换（正则匹配，replace）" class="headerlink" title="字母大小写切换（正则匹配，replace）"></a>字母大小写切换（正则匹配，<code>replace</code>）</h2><p>这个方法主要是给一些需要大小写转换提供的方法，主要有首字母大写，首字母小写，大小写转换，全部转大写和全部转小写。</p>
<pre><code>type：
　　1:首字母大写
　　2：首页母小写
　　3：大小写转换
　　4：全部大写
　　5：全部小写
</code></pre><p>原始字符串：</p>
<pre><code>var str=&quot;sdfwwerasfddffddeerAasdgFegqer&quot;;

function changeCase(str,type) {

   //这个函数是第三个大小写转换的方法
    function ToggleCase(str) {
        var itemText = &quot;&quot;
        str.split(&quot;&quot;).forEach(
                function (item) {
                 // 判断循环字符串中每个字符是否以a-z之间开头的并且重复大于0次
                    if (/^([a-z]+)/.test(item)) {
                    //  如果是小写，转换成大写
                        itemText += item.toUpperCase();
                    }
                //  判断循环字符串中每个字符是否以A-Z之间开头的并且重复大于0次
                    else if (/^([A-Z]+)/.test(item)) {
                   //   如果是大写，转换成小写
                        itemText += item.toLowerCase();
                    }
                    else{
                  //  如果都不符合，返回其本身
                        itemText += item;
                    }
                });
        return itemText;
    }
  //下面主要根据传入的type值来匹配各个场景
    switch (type) {
         //当匹配
        case 1:
            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {
                 //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer
                return v1.toUpperCase() + v2.toLowerCase();
            });
        case 2:
            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {
                //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer
                return v1.toLowerCase() + v2.toUpperCase();
            });
        case 3:
            return ToggleCase(str);
        case 4:
            return str.toUpperCase();
        case 5:
            return str.toLowerCase();
        default:
            return str;
    }

}

 console.log(changeCase(str,1)) =&gt;SdfwwerasfddffddeerAasdgFegqer
</code></pre><p>解析：</p>
<pre><code>split：用于把一个字符串分割成字符串数组
\w: 数字0-9或字母a-z及A-Z,或下划线
\W: 非\w，除以上的特殊符号等   
toUpperCase：转大写
toLowerCase：转小写
replace第二个参数可以是函数，函数的参数中，第一个是本身，第二个是正则匹配内容，第三个匹配剩下的内容
</code></pre><p>下面我们就通过小实验来验证一下：<br>网上有说replace是可以有4个参数的，但是我并没有验证到第四个代表的意义，前三个已经验证，第一个参数为验证本身，第二个正则匹配结果，第三为第二个匹配完剩下的值。</p>
<h2 id="循环n次传入的字符串str为传入随意字符串，count为循环的次数"><a href="#循环n次传入的字符串str为传入随意字符串，count为循环的次数" class="headerlink" title="循环n次传入的字符串str为传入随意字符串，count为循环的次数"></a>循环n次传入的字符串<code>str</code>为传入随意字符串，<code>count</code>为循环的次数</h2><pre><code>var str=&quot;abc&quot;;
 var number=555;

function repeatStr(str, count) {
    //声明一个空字符串，用来保存生成后的新字符串
    var text = &apos;&apos;;
    //循环传入的count值，即循环的次数
    for (var i = 0; i &lt; count; i++) {
       //循环一次就把字符串+到我们事先准备好的空字符串上
        text += str;
    }
    return text;
}

  console.log(repeatStr(str, 3))         // &quot;abcabcabc&quot;

  console.log(repeatStr(number, 3))      // &quot;555555555&quot;
</code></pre><p>解析：根据count循环的次数，在循环体内复制，return 返回+=后的值</p>
<h2 id="查找字符串的A内容替换成B内容"><a href="#查找字符串的A内容替换成B内容" class="headerlink" title="查找字符串的A内容替换成B内容"></a>查找字符串的A内容替换成B内容</h2><pre><code>let str=&quot;abacdasdfsd&quot; function replaceAll(str,AFindText,ARepText){
   raRegExp = new RegExp(AFindText,&quot;g&quot;);
   return str.replace(raRegExp,ARepText);
}
console.log(replaceAll(str,&quot;a&quot;,&quot;x&quot;))  // xbxcdxsdfsd
str：需要编辑的字符串本身
AFindText:需要替换的内容
ARepText:被替换成的内容
</code></pre><p>解析：创建正则，匹配内容，替换</p>
<h2 id="检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"><a href="#检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证" class="headerlink" title="检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"></a>检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证</h2><pre><code>function checkType (str, type) {
    switch (type) {
        case &apos;email&apos;:
            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);
        case &apos;phone&apos;:
            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);
        case &apos;tel&apos;:
            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);
        case &apos;number&apos;:
            return /^[0-9]$/.test(str);
        case &apos;english&apos;:
            return /^[a-zA-Z]+$/.test(str);
        case &apos;chinese&apos;:
            return /^[\u4E00-\u9FA5]+$/.test(str);
        case &apos;lower&apos;:
            return /^[a-z]+$/.test(str);
        case &apos;upper&apos;:
            return /^[A-Z]+$/.test(str);
        default :
            return true;
    }
}
console.log(checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;))   //false
</code></pre><p>解析：</p>
<pre><code>checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;)&apos;需要验证的字符串&apos;，&apos;匹配的格式&apos;
email：验证邮箱
phone：验证手机号
tel：验证座机号
number：验证数字
english：验证英文字母
chinese：验证中文字
lower：验证小写
upper：验证大写
</code></pre><p>JS返回浏览器历史第一页：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.xiejiahe.com/detail/5a18f8f5c7431c02ef43bca9" target="_blank" rel="noopener">JS返回浏览器历史第一页</a></p>
<p>我在浏览器控制台敲了 window.history 其实我想看看还有哪些API，他输出了以下信息，我看到length 这个属性让我眼前一亮，其他2个我不关心。</p>
<pre><code>{
    length: 2,
    scrollRestoration: &quot;auto&quot;,
    state: null
}
</code></pre><p>我尝试用length 去回退， 不成功！</p>
<pre><code>window.history.go(-2);
</code></pre><p>我再尝试用length去减1, 成功了， 我猜应该是跟新标签页有关吧。 那我不管了，我已经有答案了</p>
<pre><code>window.history.go(-1);
</code></pre><p>最后代码</p>
<pre><code>var historyLen = window.history;
window.history.go(-(historyLen - 1));
</code></pre><p>测试了3个浏览器， 都是第一次打开浏览器测试</p>
<pre><code>Chrome 会直接返回到新标签页
Safari 我这里测试是返回到百度，可能是我的设置问题
Firefox 直接关闭浏览器 
</code></pre><p>作为战斗在业务一线的前端，要想少加班，就要想办法提高工作效率。这里提一个小点，我们在业务开发过程中，经常会重复用到<code>日期格式化</code>、<code>url参数转对象</code>、<code>浏览器类型判断</code>、<code>节流函数</code>等一类函数，这些工具类函数，基本上在每个项目都会用到，为避免不同项目多次复制粘贴的麻烦，我们可以统一封装，发布到<code>npm</code>，以提高开发效率。</p>
<p>这里，笔者已经封装并发布了自己的武器库 <a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener">outils</a>，如果你对本项目感兴趣，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。当然你也可以在本项目的基础上封装自己的武器库。</p>
<p>常用函数汇总</p>
<h2 id="这里先分类整理下，之前项目中多次用到的工具函数。"><a href="#这里先分类整理下，之前项目中多次用到的工具函数。" class="headerlink" title="这里先分类整理下，之前项目中多次用到的工具函数。"></a>这里先分类整理下，之前项目中多次用到的工具函数。</h2><h2 id="1-Array"><a href="#1-Array" class="headerlink" title="1.Array"></a>1.Array</h2><h2 id="1-1-arrayEqual"><a href="#1-1-arrayEqual" class="headerlink" title="1.1 arrayEqual"></a>1.1 arrayEqual</h2><pre><code>/**
 * 
 * @desc 判断两个数组是否相等
 * @param {Array} arr1 
 * @param {Array} arr2 
 * @return {Boolean}
 */ function arrayEqual(arr1, arr2) {
    if (arr1 === arr2) return true;
    if (arr1.length != arr2.length) return false;
    for (var i = 0; i &lt; arr1.length; ++i) {
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
</code></pre><h2 id="2-Class"><a href="#2-Class" class="headerlink" title="2.Class"></a>2.Class</h2><h2 id="2-1-addClass"><a href="#2-1-addClass" class="headerlink" title="2.1 addClass"></a>2.1 addClass</h2><pre><code>/**
 * 
 * @desc   为元素添加class
 * @param  {HTMLElement} ele 
 * @param  {String} cls 
 */ 
var hasClass = require(&apos;./hasClass&apos;);
function addClass(ele, cls) {
    if (!hasClass(ele, cls)) {
        ele.className += &apos; &apos; + cls;
    }
}
</code></pre><p>2.2 hasClass</p>
<pre><code>/**
 * 
 * @desc 判断元素是否有某个class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 * @return {Boolean}
 */ 
function hasClass(ele, cls) {
    return (new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;)).test(ele.className);
}
</code></pre><p>2.3 removeClass</p>
<pre><code>/**
 * 
 * @desc 为元素移除class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 */ 
var hasClass = require(&apos;./hasClass&apos;);
function removeClass(ele, cls) {
    if (hasClass(ele, cls)) {
        var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;);
        ele.className = ele.className.replace(reg, &apos; &apos;);
    }
}
</code></pre><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h2><h2 id="3-1-getCookie"><a href="#3-1-getCookie" class="headerlink" title="3.1 getCookie"></a>3.1 getCookie</h2><pre><code>/**
 * 
 * @desc 根据name读取cookie
 * @param  {String} name 
 * @return {String}
 */ 
function getCookie(name) {
    var arr = document.cookie.replace(/\s/g, &quot;&quot;).split(&apos;;&apos;);
    for (var i = 0; i &lt; arr.length; i++) {
        var tempArr = arr[i].split(&apos;=&apos;);
        if (tempArr[0] == name) {
            return decodeURIComponent(tempArr[1]);
        }
    }
    return &apos;&apos;;
}
</code></pre><p>3.2 removeCookie</p>
<pre><code>var setCookie = require(&apos;./setCookie&apos;);
/**
 * 
 * @desc 根据name删除cookie
 * @param  {String} name 
 */
 function removeCookie(name) {
    // 设置已过期，系统会立刻删除cookie
    setCookie(name, &apos;1&apos;, -1);
}
</code></pre><p>3.3 setCookie</p>
<pre><code>/**
 * 
 * @desc  设置Cookie
 * @param {String} name 
 * @param {String} value 
 * @param {Number} days 
 */ 
function setCookie(name, value, days) {
    var date = new Date();
    date.setDate(date.getDate() + days);
    document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + date;
}
</code></pre><h2 id="4-Device"><a href="#4-Device" class="headerlink" title="4.Device"></a>4.Device</h2><h2 id="4-1-getExplore"><a href="#4-1-getExplore" class="headerlink" title="4.1 getExplore"></a>4.1 getExplore</h2><pre><code>/**
 * 
 * @desc 获取浏览器类型和版本
 * @return {String} 
 */ 
function getExplore() {
    var sys = {},
        ua = navigator.userAgent.toLowerCase(),
        s;
    (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:
        (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :
        (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :
        (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :
        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :
        (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :
        (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;
    // 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie)
    if (sys.edge) return (&apos;EDGE: &apos; + sys.edge)
    if (sys.firefox) return (&apos;Firefox: &apos; + sys.firefox)
    if (sys.chrome) return (&apos;Chrome: &apos; + sys.chrome)
    if (sys.opera) return (&apos;Opera: &apos; + sys.opera)
    if (sys.safari) return (&apos;Safari: &apos; + sys.safari)
    return &apos;Unkonwn&apos;
}
</code></pre><p>4.2 getOS</p>
<pre><code>/**
 * 
 * @desc 获取操作系统类型
 * @return {String} 
 */ 
function getOS() {
    var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;;
    var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;;
    var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;;

    if (/mac/i.test(appVersion)) return &apos;MacOSX&apos; if (/win/i.test(appVersion)) return &apos;windows&apos; if (/linux/i.test(appVersion)) return &apos;linux&apos; if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos; if (/android/i.test(userAgent)) return &apos;android&apos; if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos;
}
</code></pre><h2 id="5-Dom"><a href="#5-Dom" class="headerlink" title="5.Dom"></a>5.Dom</h2><h2 id="5-1-getScrollTop"><a href="#5-1-getScrollTop" class="headerlink" title="5.1 getScrollTop"></a>5.1 getScrollTop</h2><pre><code>/**
 * 
 * @desc 获取滚动条距顶部的距离
 */ 
function getScrollTop() {
    return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;
}
</code></pre><p>5.2 offset</p>
<pre><code>/**
 * 
 * @desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()
 * @param {HTMLElement} ele 
 * @returns { {left: number, top: number} }
 */ 
function offset(ele) {
    var pos = {
        left: 0,
        top: 0
    };
    while (ele) {
        pos.left += ele.offsetLeft;
        pos.top += ele.offsetTop;
        ele = ele.offsetParent;
    };
    return pos;
}
</code></pre><h2 id="5-3-scrollTo"><a href="#5-3-scrollTo" class="headerlink" title="5.3 scrollTo"></a>5.3 scrollTo</h2><pre><code>var getScrollTop = require(&apos;./getScrollTop&apos;);
var setScrollTop = require(&apos;./setScrollTop&apos;);
var requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 60);
        };
})();
/**
 * 
 * @desc  在${duration}时间内，滚动条平滑滚动到${to}指定位置
 * @param {Number} to 
 * @param {Number} duration 
 */ 
function scrollTo(to, duration) {
    if (duration &lt; 0) {
        setScrollTop(to);
        return
    }
    var diff = to - getScrollTop();
    if (diff === 0) return var step = diff / duration * 10;
    requestAnimationFrame(
        function () {
            if (Math.abs(step) &gt; Math.abs(diff)) {
                setScrollTop(getScrollTop() + diff);
                return;
            }
            setScrollTop(getScrollTop() + step);
            if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) {
                return;
            }
            scrollTo(to, duration - 16);
        });
}
</code></pre><h2 id="5-4-setScrollTop"><a href="#5-4-setScrollTop" class="headerlink" title="5.4 setScrollTop"></a>5.4 setScrollTop</h2><pre><code>/**
 * 
 * @desc 设置滚动条距顶部的距离
 */ 
function setScrollTop(value) {
    window.scrollTo(0, value);
    return value;
}
</code></pre><h2 id="6-Keycode"><a href="#6-Keycode" class="headerlink" title="6.Keycode"></a>6.Keycode</h2><h2 id="6-1-getKeyName"><a href="#6-1-getKeyName" class="headerlink" title="6.1 getKeyName"></a>6.1 getKeyName</h2><pre><code>var keyCodeMap = {
    8: &apos;Backspace&apos;,
    9: &apos;Tab&apos;,
    13: &apos;Enter&apos;,
    16: &apos;Shift&apos;,
    17: &apos;Ctrl&apos;,
    18: &apos;Alt&apos;,
    19: &apos;Pause&apos;,
    20: &apos;Caps Lock&apos;,
    27: &apos;Escape&apos;,
    32: &apos;Space&apos;,
    33: &apos;Page Up&apos;,
    34: &apos;Page Down&apos;,
    35: &apos;End&apos;,
    36: &apos;Home&apos;,
    37: &apos;Left&apos;,
    38: &apos;Up&apos;,
    39: &apos;Right&apos;,
    40: &apos;Down&apos;,
    42: &apos;Print Screen&apos;,
    45: &apos;Insert&apos;,
    46: &apos;Delete&apos;,

    48: &apos;0&apos;,
    49: &apos;1&apos;,
    50: &apos;2&apos;,
    51: &apos;3&apos;,
    52: &apos;4&apos;,
    53: &apos;5&apos;,
    54: &apos;6&apos;,
    55: &apos;7&apos;,
    56: &apos;8&apos;,
    57: &apos;9&apos;,

    65: &apos;A&apos;,
    66: &apos;B&apos;,
    67: &apos;C&apos;,
    68: &apos;D&apos;,
    69: &apos;E&apos;,
    70: &apos;F&apos;,
    71: &apos;G&apos;,
    72: &apos;H&apos;,
    73: &apos;I&apos;,
    74: &apos;J&apos;,
    75: &apos;K&apos;,
    76: &apos;L&apos;,
    77: &apos;M&apos;,
    78: &apos;N&apos;,
    79: &apos;O&apos;,
    80: &apos;P&apos;,
    81: &apos;Q&apos;,
    82: &apos;R&apos;,
    83: &apos;S&apos;,
    84: &apos;T&apos;,
    85: &apos;U&apos;,
    86: &apos;V&apos;,
    87: &apos;W&apos;,
    88: &apos;X&apos;,
    89: &apos;Y&apos;,
    90: &apos;Z&apos;,

    91: &apos;Windows&apos;,
    93: &apos;Right Click&apos;,

    96: &apos;Numpad 0&apos;,
    97: &apos;Numpad 1&apos;,
    98: &apos;Numpad 2&apos;,
    99: &apos;Numpad 3&apos;,
    100: &apos;Numpad 4&apos;,
    101: &apos;Numpad 5&apos;,
    102: &apos;Numpad 6&apos;,
    103: &apos;Numpad 7&apos;,
    104: &apos;Numpad 8&apos;,
    105: &apos;Numpad 9&apos;,
    106: &apos;Numpad *&apos;,
    107: &apos;Numpad +&apos;,
    109: &apos;Numpad -&apos;,
    110: &apos;Numpad .&apos;,
    111: &apos;Numpad /&apos;,

    112: &apos;F1&apos;,
    113: &apos;F2&apos;,
    114: &apos;F3&apos;,
    115: &apos;F4&apos;,
    116: &apos;F5&apos;,
    117: &apos;F6&apos;,
    118: &apos;F7&apos;,
    119: &apos;F8&apos;,
    120: &apos;F9&apos;,
    121: &apos;F10&apos;,
    122: &apos;F11&apos;,
    123: &apos;F12&apos;,

    144: &apos;Num Lock&apos;,
    145: &apos;Scroll Lock&apos;,
    182: &apos;My Computer&apos;,
    183: &apos;My Calculator&apos;,
    186: &apos;;&apos;,
    187: &apos;=&apos;,
    188: &apos;,&apos;,
    189: &apos;-&apos;,
    190: &apos;.&apos;,
    191: &apos;/&apos;,
    192: &apos;`&apos;,
    219: &apos;[&apos;,
    220: &apos;\\&apos;,
    221: &apos;]&apos;,
    222: &apos;\&apos;&apos;
};
/**
 * @desc 根据keycode获得键名
 * @param  {Number} keycode 
 * @return {String}
 */ 
function getKeyName(keycode) {
    if (keyCodeMap[keycode]) {
        return keyCodeMap[keycode];
    } else {
        console.log(&apos;Unknow Key(Key Code:&apos; + keycode + &apos;)&apos;);
        return &apos;&apos;;
    }
};
</code></pre><h2 id="7-Object"><a href="#7-Object" class="headerlink" title="7.Object"></a>7.Object</h2><h2 id="7-1-deepClone"><a href="#7-1-deepClone" class="headerlink" title="7.1 deepClone"></a>7.1 deepClone</h2><pre><code>/**
 * @desc 深拷贝，支持常见类型
 * @param {Any} values
 */ 
function deepClone(values) {
    var copy;

    // Handle the 3 simple types, and null or undefined if (null == values || &quot;object&quot; != typeof values) return values;

    // Handle Date if (values instanceof Date) {
        copy = new Date();
        copy.setTime(values.getTime());
        return copy;
    }

    // Handle Array if (values instanceof Array) {
        copy = [];
        for (var i = 0, len = values.length; i &lt; len; i++) {
            copy[i] = deepClone(values[i]);
        }
        return copy;
    }

    // Handle Object if (values instanceof Object) {
        copy = {};
        for (var attr in values) {
            if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);
        }
        return copy;
    }

    throw new Error(&quot;Unable to copy values! Its type isn&apos;t supported.&quot;);
}
</code></pre><h2 id="7-2-isEmptyObject"><a href="#7-2-isEmptyObject" class="headerlink" title="7.2 isEmptyObject"></a>7.2 isEmptyObject</h2><pre><code>/**
 * 
 * @desc   判断`obj`是否为空
 * @param  {Object} obj
 * @return {Boolean}
 */ 
function isEmptyObject(obj) {
    if (!obj || typeof obj !== &apos;object&apos; || Array.isArray(obj))
        return false return !Object.keys(obj).length
}
</code></pre><h2 id="8-Random"><a href="#8-Random" class="headerlink" title="8.Random"></a>8.Random</h2><h2 id="8-1-randomColor"><a href="#8-1-randomColor" class="headerlink" title="8.1 randomColor"></a>8.1 randomColor</h2><pre><code>/**
 * 
 * @desc 随机生成颜色
 * @return {String} 
 */ 
function randomColor() {
    return &apos;#&apos; + (&apos;00000&apos; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);
}
</code></pre><h2 id="8-2-randomNum"><a href="#8-2-randomNum" class="headerlink" title="8.2 randomNum"></a>8.2 randomNum</h2><pre><code>/**
 * 
 * @desc 生成指定范围随机数
 * @param  {Number} min 
 * @param  {Number} max 
 * @return {Number} 
 */ 
function randomNum(min, max) {
    return Math.floor(min + Math.random() * (max - min));
}
</code></pre><h2 id="9-Regexp"><a href="#9-Regexp" class="headerlink" title="9.Regexp"></a>9.Regexp</h2><h2 id="9-1-isEmail"><a href="#9-1-isEmail" class="headerlink" title="9.1 isEmail"></a>9.1 isEmail</h2><pre><code>/**
 * 
 * @desc   判断是否为邮箱地址
 * @param  {String}  str
 * @return {Boolean} 
 */ 
function isEmail(str) {
    return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str);
}
</code></pre><h2 id="9-2-isIdCard"><a href="#9-2-isIdCard" class="headerlink" title="9.2 isIdCard"></a>9.2 isIdCard</h2><pre><code>/**
 * 
 * @desc  判断是否为身份证号
 * @param  {String|Number} str 
 * @return {Boolean}
 */ 
function isIdCard(str) {
    return /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/.test(str)
}
</code></pre><h2 id="9-3-isPhoneNum"><a href="#9-3-isPhoneNum" class="headerlink" title="9.3 isPhoneNum"></a>9.3 isPhoneNum</h2><pre><code>/**
 * 
 * @desc   判断是否为手机号
 * @param  {String|Number} str 
 * @return {Boolean} 
 */
 function isPhoneNum(str) {
    return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/.test(str)
}
</code></pre><h2 id="9-4-isUrl"><a href="#9-4-isUrl" class="headerlink" title="9.4 isUrl"></a>9.4 isUrl</h2><pre><code>/**
 * 
 * @desc   判断是否为URL地址
 * @param  {String} str 
 * @return {Boolean}
 */ 
function isUrl(str) {
    return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str);
}
</code></pre><h2 id="10-String"><a href="#10-String" class="headerlink" title="10.String"></a>10.String</h2><h2 id="10-1-digitUppercase"><a href="#10-1-digitUppercase" class="headerlink" title="10.1 digitUppercase"></a>10.1 digitUppercase</h2><pre><code>/**
 * 
 * @desc   现金额转大写
 * @param  {Number} n 
 * @return {String}
 */
 function digitUppercase(n) {
    var fraction = [&apos;角&apos;, &apos;分&apos;];
    var digit = [
        &apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;,
        &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos;
    ];
    var unit = [
        [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;],
        [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;]
    ];
    var head = n &lt; 0 ? &apos;欠&apos; : &apos;&apos;;
    n = Math.abs(n);
    var s = &apos;&apos;;
    for (var i = 0; i &lt; fraction.length; i++) {
        s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;);
    }
    s = s || &apos;整&apos;;
    n = Math.floor(n);
    for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) {
        var p = &apos;&apos;;
        for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) {
            p = digit[n % 10] + unit[1][j] + p;
            n = Math.floor(n / 10);
        }
        s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s;
    }
    return head + s.replace(/(零.)*零元/, &apos;元&apos;)
        .replace(/(零.)+/g, &apos;零&apos;)
        .replace(/^整$/, &apos;零元整&apos;);
};
</code></pre><h2 id="11-Support"><a href="#11-Support" class="headerlink" title="11.Support"></a>11.Support</h2><h2 id="11-1-isSupportWebP"><a href="#11-1-isSupportWebP" class="headerlink" title="11.1 isSupportWebP"></a>11.1 isSupportWebP</h2><pre><code>/**
 * 
 * @desc 判断浏览器是否支持webP格式图片
 * @return {Boolean} 
 */ 
function isSupportWebP() {
    return !![].map &amp;&amp; document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0;
}
</code></pre><h2 id="12-Time"><a href="#12-Time" class="headerlink" title="12.Time"></a>12.Time</h2><h2 id="12-1-formatPassTime"><a href="#12-1-formatPassTime" class="headerlink" title="12.1 formatPassTime"></a>12.1 formatPassTime</h2><pre><code>/**
 * @desc   格式化${startTime}距现在的已过时间
 * @param  {Date} startTime 
 * @return {String}
 */ 
function formatPassTime(startTime) {
    var currentTime = Date.parse(new Date()),
        time = currentTime - startTime,
        day = parseInt(time / (1000 * 60 * 60 * 24)),
        hour = parseInt(time / (1000 * 60 * 60)),
        min = parseInt(time / (1000 * 60)),
        month = parseInt(day / 30),
        year = parseInt(month / 12);
    if (year) return year + &quot;年前&quot; if (month) return month + &quot;个月前&quot; if (day) return day + &quot;天前&quot; if (hour) return hour + &quot;小时前&quot; if (min) return min + &quot;分钟前&quot; else return &apos;刚刚&apos;
}
</code></pre><h2 id="12-2-formatRemainTime"><a href="#12-2-formatRemainTime" class="headerlink" title="12.2 formatRemainTime"></a>12.2 formatRemainTime</h2><pre><code>/**
 * 
 * @desc   格式化现在距${endTime}的剩余时间
 * @param  {Date} endTime  
 * @return {String}
 */ function formatRemainTime(endTime) {
    var startDate = new Date(); //开始时间 var endDate = new Date(endTime); //结束时间 var t = endDate.getTime() - startDate.getTime(); //时间差 var d = 0,
        h = 0,
        m = 0,
        s = 0;
    if (t &gt;= 0) {
        d = Math.floor(t / 1000 / 3600 / 24);
        h = Math.floor(t / 1000 / 60 / 60 % 24);
        m = Math.floor(t / 1000 / 60 % 60);
        s = Math.floor(t / 1000 % 60);
    }
    return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;;
}
</code></pre><h2 id="13-Url"><a href="#13-Url" class="headerlink" title="13.Url"></a>13.Url</h2><h2 id="13-1-parseQueryString"><a href="#13-1-parseQueryString" class="headerlink" title="13.1 parseQueryString"></a>13.1 parseQueryString</h2><pre><code>/**
 * 
 * @desc   url参数转对象
 * @param  {String} url  default: window.location.href
 * @return {Object} 
 */ 
function parseQueryString(url) {
    url = url == null ? window.location.href : url
    var search = url.substring(url.lastIndexOf(&apos;?&apos;) + 1)
    if (!search) {
        return {}
    }
    return JSON.parse(&apos;{&quot;&apos; + decodeURIComponent(search).replace(/&quot;/g, &apos;\\&quot;&apos;).replace(/&amp;/g, &apos;&quot;,&quot;&apos;).replace(/=/g, &apos;&quot;:&quot;&apos;) + &apos;&quot;}&apos;)
}
</code></pre><h2 id="13-2-stringfyQueryString"><a href="#13-2-stringfyQueryString" class="headerlink" title="13.2 stringfyQueryString"></a>13.2 stringfyQueryString</h2><pre><code>/**
 * 
 * @desc   对象序列化
 * @param  {Object} obj 
 * @return {String}
 */ function stringfyQueryString(obj) {
    if (!obj) return &apos;&apos;;
    var pairs = [];

    for (var key in obj) {
        var value = obj[key];

        if (value instanceof Array) {
            for (var i = 0; i &lt; value.length; ++i) {
                pairs.push(encodeURIComponent(key + &apos;[&apos; + i + &apos;]&apos;) + &apos;=&apos; + encodeURIComponent(value[i]));
            }
            continue;
        }

        pairs.push(encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(obj[key]));
    }

    return pairs.join(&apos;&amp;&apos;);
}
</code></pre><h2 id="14-Function"><a href="#14-Function" class="headerlink" title="14.Function"></a>14.Function</h2><h2 id="14-1-throttle"><a href="#14-1-throttle" class="headerlink" title="14.1 throttle"></a>14.1 throttle</h2><pre><code>/**
 * @desc   函数节流。
 * 适用于限制`resize`和`scroll`等函数的调用频率
 *
 * @param  {Number}    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}   noTrailing     可选，默认为false。
 *                                    如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。
 *                                    如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次.
 *                                    （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位）
 * @param  {Function}  callback       延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                    执行去节流功能时，调用`callback`。
 * @param  {Boolean}   debounceMode   如果`debounceMode`为true，`clear`在`delay`ms后执行。
 *                                    如果debounceMode是false，`callback`在`delay` ms之后执行。
 *
 * @return {Function}  新的节流函数
 */ function throttle(delay, noTrailing, callback, debounceMode) {

    // After wrapper has stopped being called, this timeout ensures that // `callback` is executed at the proper times in `throttle` and `end` // debounce modes. var timeoutID;

    // Keep track of the last time `callback` was executed. var lastExec = 0;

    // `noTrailing` defaults to falsy. if (typeof noTrailing !== &apos;boolean&apos;) {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing // functionality and when executed will limit the rate at which `callback` // is executed. function wrapper() {

        var self = this;
        var elapsed = Number(new Date()) - lastExec;
        var args = arguments;

        // Execute `callback` and update the `lastExec` timestamp. function exec() {
            lastExec = Number(new Date());
            callback.apply(self, args);
        }

        // If `debounceMode` is true (at begin) this is used to clear the flag // to allow future `callback` executions. function clear() {
            timeoutID = undefined;
        }

        if (debounceMode &amp;&amp; !timeoutID) {
            // Since `wrapper` is being called for the first time and // `debounceMode` is true (at begin), execute `callback`.
            exec();
        }

        // Clear any existing timeout. if (timeoutID) {
            clearTimeout(timeoutID);
        }

        if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) {
            // In throttle mode, if `delay` time has been exceeded, execute // `callback`.
            exec();

        } else if (noTrailing !== true) {
            // In trailing throttle mode, since `delay` time has not been // exceeded, schedule `callback` to execute `delay` ms after most // recent execution. // // If `debounceMode` is true (at begin), schedule `clear` to execute // after `delay` ms. // // If `debounceMode` is false (at end), schedule `callback` to // execute after `delay` ms.
            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
        }

    }

    // Return the wrapper function. return wrapper;

};
</code></pre><h2 id="14-2-debounce"><a href="#14-2-debounce" class="headerlink" title="14.2 debounce"></a>14.2 debounce</h2><pre><code>/**
 * @desc 函数防抖 
 * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次，
 * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。
 * @example 适用场景：如在线编辑的自动存储防抖。
 * @param  {Number}   delay         0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}  atBegin       可选，默认为false。
 *                                  如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。
                                    如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行
 * @param  {Function} callback      延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                  执行去抖动功能时，，调用`callback`。
 *
 * @return {Function} 新的防抖函数。
 */ 
var throttle = require(&apos;./throttle&apos;);
function debounce(delay, atBegin, callback) {
    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
};
</code></pre><p>封装</p>
<p>除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用<code>webpack</code>统一打包成<code>UMD</code> 通用模块规范，支持<code>webpack</code>、<code>RequireJS</code>、<code>SeaJS</code>等模块加载器，亦或直接通过<code>&lt;script&gt;</code>标签引入。</p>
<p>但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持按需引入吧</p>
<p>1.目录结构说明</p>
<pre><code>│  .babelrc
│  .gitignore
│  .travis.yml
│  LICENSE
│  package.json
│  README.md
│  setCookie.js  // 拷贝到根路径的函数模块，方便按需加载
│  setScrollTop.js
│  stringfyQueryString.js
│   ...
│   ...
│  
├─min
│      outils.min.js  // 所有函数统一打包生成的全量压缩包
│      
├─script  // 本项目开发脚本目录
│      build.js  // 打包构建脚本
│      test.js  // 测试脚本
│      webpack.conf.js  // webpack打包配置文件
│      
├─src // 源码目录
│  │  index.js  // webpack入口文件
│  │  
│  ├─array
│  │      
│  ├─class
│  │      
│  ├─cookie
│  │      
│  ├─device
│  │      
│  ├─dom
│  │      
│  ├─keycode
│  │      
│  ├─object
│  │      
│  ├─random
│  │      
│  ├─regexp
│  │      
│  ├─string
│  │      
│  ├─support
│  │      
│  ├─time
│  │      
│  └─url
│          
└─test // 测试用例目录
    │  array.test.js
    │  class.test.js
    │  cookie.test.js
    │  device.test.js
    │  dom.test.js
    │  index.html
    │  keycode.test.js
    │  object.test.js
    │  random.test.js
    │  regexp.test.js
    │  string.test.js
    │  support.test.js
    │  time.test.js
    │  url.test.js
    │  
    └─_lib // 测试所用到的第三方库
            mocha.css
            mocha.js
            power-assert.js
</code></pre><p>2.构建脚本</p>
<p>这里主要说明一下项目中<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fbuild.js" target="_blank" rel="noopener"> build.js </a>的构建过程<br>第一步，构建全量压缩包，先删除<code>min</code>目录中之前的<code>outils.min.js</code>，后通过<code>webpack</code>打包并保存新的压缩包至<code>min</code>目录中：</p>
<pre><code>......
 ......
 // 删除旧的全量压缩包
 rm(path.resolve(rootPath, &apos;min&apos;, `${pkg.name}.min.js`), err =&gt; {
     if (err) throw (err)
     webpack(config, function (err, stats) {
         if (err) throw (err)
         building.stop()
         process.stdout.write(stats.toString({
             colors: true,
             modules: false,
             children: false,
             chunks: false,
             chunkModules: false
         }) + &apos;\n\n&apos;)
         resolve()
         console.log(chalk.cyan(&apos;  Build complete.\n&apos;))
     })
 })
 ......
 ......
</code></pre><p>第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝<code>src</code>下面一层目录的所有<code>js</code>文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接<code>require(&#39;outils/&lt;方法名&gt;&#39;)</code>即可，缩短引入的路径，也算是提高点效率。</p>
<pre><code>// 替换模块文件
    ......
    ......
    // 先删除根目录中之前的函数模块
    rm(&apos;*.js&apos;, err =&gt; {
        if (err) throw (err)
        let folderList = fs.readdirSync(path.resolve(rootPath, &apos;src&apos;))
        folderList.forEach((item, index) =&gt; {
            // 拷贝`src`下面一层目录的所有`js`文件至根目录
            copy(`src/${item}/*.js`, rootPath, function (err, files) {
                if (err) throw err;
                if (index === folderList.length - 1) {
                    console.log(chalk.cyan(&apos;  Copy complete.\n&apos;))
                    copying.stop()
                }
            })
        })
    })
    ......
    ......
</code></pre><p>3.书写测试用例</p>
<p>俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。</p>
<p>但是因为时间关系，本项目暂时通过项目中的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Ftest.js" target="_blank" rel="noopener"> test.js </a>，启动了一个<code>koa</code>静态服务器，来加载<code>mocha</code>网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。<br>但是后续将使用<code>travis-ci</code>配合<code>Github</code>来做持续化构建，自动发布到<code>npm</code>。改用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>做单元测试，使用<code>Coverage</code>测试覆盖率。这一部分，后续更新。</p>
<p>这里给大家推荐一个好用的断言库<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252Fpackage%252Fpower-assert" target="_blank" rel="noopener"> power-assert </a>，这个库记住<code>assert(value, [message])</code>一个API就基本无敌，从此再也不用担心记不住断言库的API。</p>
<p>本项目的所有测试用例都在<code>test</code>目录下，大家可以作一定参考。</p>
<p>更新：单元测试，已使用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>，使用<code>Coverage</code>测试覆盖率，并集成<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Ftravis-ci.org%252F" target="_blank" rel="noopener"> travis-ci </a>配合<code>Github</code>来做持续化构建，可以参考本项目的<code>travis</code>配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252F.travis.yml" target="_blank" rel="noopener"> .travis.yml </a>和<code>karma</code>的配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fkarma.conf.js" target="_blank" rel="noopener"> karma.conf.js </a>。</p>
<blockquote>
<p>发布</p>
</blockquote>
<p>首先放到<code>Github</code>托管一下，当然你也可以直接<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252F" target="_blank" rel="noopener">fork</a>本项目，然后再加入你自己的函数。<br>以笔者项目，举个栗子:</p>
<p>1.添加自己的函数</p>
<p>在<code>src</code>目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。</p>
<pre><code>/**
 * 
 * @desc   判断是否NaN
 * @param  {Any} value 
 * @return {Boolean}
 */ 
function isNaN(value) {    
    return value !== value;
};

modules.export = isNaN
</code></pre><p>然后记得在src/index.js文件中暴露isNaN函数</p>
<p>2.单元测试</p>
<p>在<code>test</code>文件新建测试用例</p>
<pre><code>describe(&apos;#isNaN()&apos;, function () {
    it(`outils.isNaN(NaN) should return true`, function () {
        assert(outils.isNaN(NaN))
    })
    it(`outils.isNaN(&apos;value&apos;) should return false`, function () {
        assert.notEqual(outils.isNaN(NaN))
    })
})
</code></pre><p>然后记得在<code>test/index.html</code>中引入之前创建的测试用例脚本。</p>
<p>3.测试并打包</p>
<p>执行<code>npm run test</code>，看所有的测试用例是否通过。如果没有问题，执行<code>npm run build</code>构建，之后提交到个人的 github 仓库即可。</p>
<p>4.发布到<code>npm</code></p>
<p>在<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>注册账号，修改本地<code>package.json</code>中的<code>name</code>、<code>version</code>、<code>author</code>等信息，最后<code>npm publish</code>就大功告成了。<br>注意：向<code>npm</code>发包，要把镜像源切到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>，使用<code>cnpm</code>等第三方镜像源会报错。</p>
<p>使用</p>
<p>1.浏览器</p>
<p>直接下载<code>min</code>目录下的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fmin%252Foutils.min.js" target="_blank" rel="noopener"> outils.min.js </a>，通过<code>&lt;script&gt;</code>标签引入。</p>
<pre><code>&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var OS = outils.getOS()
  &lt;/script&gt;
</code></pre><p>注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Freleases" target="_blank" rel="noopener"> github Release </a>页面下载对应版本号的代码。</p>
<p>2.Webpack、RequireJS、SeaJS等模块加载器</p>
<p>先使用<code>npm</code>安装<code>outils</code>。</p>
<pre><code>$ npm install --save-dev outils
// 完整引入 const outils = require(&apos;outils&apos;)
const OS = outils.getOS()
推荐使用方法 
// 按需引入require(&apos;outils/&lt;方法名&gt;&apos;) const getOS = require(&apos;outils/getOS&apos;)
const OS = getOS()
</code></pre><p>当然，你的开发环境有<code>babel</code>编译<code>ES6</code>语法的话，也可以这样使用：</p>
<pre><code>import getOS from &apos;outils/getOS&apos; // 或 import { getOS } from &quot;outils&quot;;
</code></pre><p>总结</p>
<p>这里只是简单封装，发布到<code>npm</code>上，省去下次复制粘贴的功夫，或者直接Goole的时间。如果笔者的库中，没有你常用的函数，或者你有更好的建议，欢迎来本项目的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fissues" target="_blank" rel="noopener"> Github Issues </a>交流，如果觉得不错，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。</p>
<p>当然，更好的建议是<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> fork </a>本项目，或者直接新建自己的项目，添加自己 想要的 、常用的 、记不住的 函数，甚至是可以抽象出来的功能，封装成自己顺手、熟悉的库。 这样才能打造出你自己的武器库，瞬间提高你的单兵作战（开发）能力。</p>
<h2 id="libraries-：https-github-com-wuxianqiang-libraries"><a href="#libraries-：https-github-com-wuxianqiang-libraries" class="headerlink" title="libraries ：https://github.com/wuxianqiang/libraries"></a>libraries ：<a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries" target="_blank" rel="noopener">https://github.com/wuxianqiang/libraries</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectcreate%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.create()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADstringtrim%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中String.trim()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarrayreduce%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.reduce()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectkeys%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.keys()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADfunctionbind%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Function.bind()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarraymap%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.map()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFmathmax%25E6%2596%25B9%25E6%25B3%2595%25E4%25B8%258D%25E5%25AE%259A%25E5%25AE%259E%25E5%258F%2582%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿Math.max()方法实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFstringmatch%25E6%2596%25B9%25E6%25B3%2595%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">仿String.match()方法实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFhtml5%25E7%259A%2584classlist%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">仿HTML5的classList属性实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2587%25BD%25E6%2595%25B0%25E7%259A%2584%25E5%2590%258D%25E5%25AD%2597" target="_blank" rel="noopener">仿Function.name属性实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E5%25B1%2582%25E7%25A5%2596%25E5%2585%2588%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n层祖先元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%2585%2584%25E5%25BC%259F%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个兄弟元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%25AD%2590%25E4%25BB%25A3%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个子代元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB1" target="_blank" rel="noopener">原生JS实现CSS动画之震动</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB2" target="_blank" rel="noopener">原生JS实现CSS动画之隐藏</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E6%2595%25B0%25E7%25BB%2584%25E4%25B8%25AD%25E6%259F%25A5%25E6%2589%25BE%25E6%2589%2580%25E6%259C%2589%25E5%2587%25BA%25E7%258E%25B0%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E6%2596%25B9%25E6%25B3%2595" target="_blank" rel="noopener">在数组中查找所有出现的元素方法</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E6%258D%25AE%25E7%25B1%25BB%25E5%259E%258B%25E6%25A3%2580%25E6%25B5%258B%25E7%2589%25B9%25E6%25AE%258A%25E6%2583%2585%25E5%2586%25B5%25E7%2589%25B9%25E6%25AE%258A%25E5%25A4%2584%25E7%2590%2586" target="_blank" rel="noopener">数据类型检测之特殊情况特殊处理</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0outerhtml%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">使用innerHTML实现outerHTML属性</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258F%2592%25E5%2585%25A5%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">插入节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2580%2592%25E5%25BA%258F%25E6%258E%2592%25E5%2588%2597%25E5%25AD%2590%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">倒序排列子节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E6%25BB%259A%25E5%258A%25A8%25E6%259D%25A1%25E7%259A%2584%25E4%25BD%258D%25E7%25BD%25AE" target="_blank" rel="noopener">查询窗口滚动条的位置</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E7%259A%2584%25E8%25A7%2586%25E5%258F%25A3%25E5%25B0%25BA%25E5%25AF%25B8" target="_blank" rel="noopener">查询窗口的视口尺寸</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25A1%25A8%25E6%25A0%25BC%25E7%259A%2584%25E8%25A1%258C%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">表格的行排序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E7%2594%259F%25E6%2588%2590%25E7%259B%25AE%25E5%25BD%2595%25E8%25A1%25A8" target="_blank" rel="noopener">生成目录表</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E7%25BB%2584%25E5%258E%25BB%25E9%2587%258D" target="_blank" rel="noopener">数组去重</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">冒泡排序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%258Eurl%25E8%25A7%25A3%25E6%259E%2590%25E5%258F%2582%25E6%2595%25B0" target="_blank" rel="noopener">从URL解析参数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%258E%25B7%25E5%258F%2596%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">获取纯文本的元素内容</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2589%258B%25E5%2586%2599%25E4%25B8%2580%25E4%25B8%25AAjsonp%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">手写一个JSONP实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E5%25BD%25A2%25E5%25BC%258F%25E7%259A%2584%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">查询纯文本形式的内容</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E6%2589%25BE%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E5%2590%258E%25E4%25BB%25A3%25E4%25B8%25AD%25E8%258A%2582%25E7%2582%25B9%25E4%25B8%25AD%25E7%259A%2584%25E6%2589%2580%25E6%259C%2589text%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">查找元素的后代中节点中的所有Text节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0insertadjacenthtml" target="_blank" rel="noopener">使用innerHTML实现insertAdjacentHTML</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258B%2596%25E6%258B%25BD" target="_blank" rel="noopener">拖拽</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E8%25B0%25B7%25E6%25AD%258C%25E5%259C%25B0%25E5%259B%25BE%25E4%25B8%258A%25E6%2598%25BE%25E7%25A4%25BA%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E4%25BF%25A1%25E6%2581%25AF" target="_blank" rel="noopener">在谷歌地图上显示地理位置信息</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8%25E6%2589%2580%25E6%259C%2589%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E7%2589%25B9%25E6%2580%25A7" target="_blank" rel="noopener">使用所有地理位置特性</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BC%2598%25E9%259B%2585%25E7%259A%2584%25E5%259B%25BE%25E7%2589%2587%25E7%25BF%25BB%25E8%25BD%25AC%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">优雅的图片翻转实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E5%25A4%259A%25E8%25BE%25B9%25E5%25BD%25A2" target="_blank" rel="noopener">使用canvas绘制多边形</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E9%259B%25AA%25E8%258A%25B1" target="_blank" rel="noopener">使用canvas绘制雪花</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8web-worker%25E4%25B8%25AD%25E5%258F%2591%25E8%25B5%25B7%25E5%2590%258C%25E6%25AD%25A5xmlhtttprequest" target="_blank" rel="noopener">在Web Worker中发起同步XMLHtttpRequest</a></li>
</ul>
<h2 id="仿ECMAScript5中Object-create-函数"><a href="#仿ECMAScript5中Object-create-函数" class="headerlink" title="仿ECMAScript5中Object.create()函数"></a>仿ECMAScript5中Object.create()函数</h2><pre><code>function inherit(obj) {
            if (obj === null) throw TypeError();
            if (Object.create) return Object.create(obj);
            var t = typeof obj;
            if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) throw TypeError();
            function Fn() {};
            Fn.prototype = obj;
            return new Fn();
        }
</code></pre><h2 id="仿ECMAScript5中String-trim-函数"><a href="#仿ECMAScript5中String-trim-函数" class="headerlink" title="仿ECMAScript5中String.trim()函数"></a>仿ECMAScript5中String.trim()函数</h2><pre><code>String.prototype.mytrim = function () {
            String.prototype.trim || function () {
                if (!this) return this; //空字符串不做处理
                return this.replace(/^\s+|\s+$/g, &quot;&quot;) //使用正则表达式经行空格替换
            }
        }
</code></pre><h2 id="仿ECMAScript5中Array-reduce-函数"><a href="#仿ECMAScript5中Array-reduce-函数" class="headerlink" title="仿ECMAScript5中Array.reduce()函数"></a>仿ECMAScript5中Array.reduce()函数</h2><pre><code>var reduce = Array.prototype.reduce ? function (ary, fn, initial) {
            if (arguments.length &gt; 2) { //如果reduce()方法存在的话
                return ary.reduce(fn, initial); //如果传入了一个初始值
            } else {
                return ary.reduce(fn); //否则初始值
            }
        } : function (ary, fn, initial) { //以特定的初始值开始，否则第一个值取自ary
            var i = 0,
                len = ary.length,
                accumulator;
            if (arguments.length &gt; 2) {
                accumulator = initial;
            } else { //找到数组中第一个已经定义的索引
                if (len == 0) throw TypeError();
                while (i &lt; len) {
                    if (i in ary) {
                        accumulator = ary[i++];
                        break;
                    } else {
                        i++;
                    }
                }
                if (i == len) throw TypeError();
            }
            while (i &lt; len) { //对于数组中剩下的元素依次调用fn
                if (i in ary) {
                    accumulator = fn.call(undefined, accumulator, ary[i], i, ary)
                }
                i++;
            }
            return accumulator;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在数组中查找所有出现的元素方法"><a href="#在数组中查找所有出现的元素方法" class="headerlink" title="在数组中查找所有出现的元素方法"></a>在数组中查找所有出现的元素方法</h2><pre><code>function findAll(ary, ele) {
            var results = [],
                len = ary.length,
                pos = 0;
            while (pos &lt; len) {
                pos = ary.indexOf(ele, pos);
                if (pos === -1) break;
                results.push(pos);
                pos++;
            }
            return results;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="数据类型检测，特殊情况特殊处理"><a href="#数据类型检测，特殊情况特殊处理" class="headerlink" title="数据类型检测，特殊情况特殊处理"></a>数据类型检测，特殊情况特殊处理</h2><pre><code>function classOf(obj) {
            if (obj === null) return &quot;Null&quot;;
            if (obj === undefined) return &apos;Undefined&apos;;
            return Object.prototype.toString.call(obj).slice(8, -1);
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Object-keys-函数"><a href="#仿ECMAScript5中Object-keys-函数" class="headerlink" title="仿ECMAScript5中Object.keys()函数"></a>仿ECMAScript5中Object.keys()函数</h2><pre><code>function keys(obj) {
            if (typeof obj !== &quot;object&quot;) {
                throw TypeError();
            }
            var result = [];
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    result.push(prop);
                }
            }
            return result;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿Math-max方法（不定实参函数）"><a href="#仿Math-max方法（不定实参函数）" class="headerlink" title="仿Math.max方法（不定实参函数）"></a>仿Math.max方法（不定实参函数）</h2><pre><code>function max() {
            var max = Number.NEGATIVE_INFINITY;
            for (var i = 0; i &lt; arguments.length; i++) {
                if (arguments[i] &gt; max) max = arguments[i];
            }
            return max;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Function-bind-函数"><a href="#仿ECMAScript5中Function-bind-函数" class="headerlink" title="仿ECMAScript5中Function.bind()函数"></a>仿ECMAScript5中Function.bind()函数</h2><pre><code>if (!Function.prototype.bind) {
            Function.prototype.bind = function (obj) {
                var self = this,
                    boundArgs = arguments;
                return function () {
                    var args = [],
                        i;
                    for (i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);
                    for (i = 1; i &lt; arguments.length; i++) args.push(arguments[i]);
                    return self.apply(obj, args);
                }
            }
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Array-map-函数"><a href="#仿ECMAScript5中Array-map-函数" class="headerlink" title="仿ECMAScript5中Array.map()函数"></a>仿ECMAScript5中Array.map()函数</h2><pre><code>var map = Array.prototype.map ? function (ary, fn) {
            return ary.map(fn);
        } : function (ary, fn) {
            var results = [];
            for (var i = 0, len = ary.length; i &lt; len; i++) {
                if (i in ary) {
                    results[i] = fn.call(null, ary[i], i, ary);
                }
            }
            return results;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code>Array.prototype.unique = function unique() {
            var obj = {};
            for (var i = 0; i &lt; this.length; i++) {
                var current = this[i];
                if (obj[current] === current) {
                    current = this[this.length - 1];
                    this.length--;
                    i--;
                    continue;
                }
                obj[current] = current
            }
            obj = null;
            return this;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>Array.prototype.bubbleSort = function bubbleSort() {
            var temp = null;
            for (var i = 0; i &lt; this.length - 1; i++) {
                for (var k = 0; k &lt; this.length - 1 - i; k++) {
                    if (this[k] &gt; this[k + 1]) {
                        temp = this[k];
                        this[k] = this[k + 1];
                        this[k + 1] = temp;
                    }
                }
            }
            return this;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿String-match-方法实现"><a href="#仿String-match-方法实现" class="headerlink" title="仿String.match()方法实现"></a>仿String.match()方法实现</h2><pre><code>String.prototype.mymatch = function (reg) {
         var ary = [];
         var res = reg.exec(this);
         while (res) {
            ary.push(res[0]);
            res = reg.exec(this);
         }
         return ary;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n层祖先元素"><a href="#返回元素的第n层祖先元素" class="headerlink" title="返回元素的第n层祖先元素"></a>返回元素的第n层祖先元素</h2><pre><code>/**
        *返回元素ele的第n层祖先元素，如果不存在此类祖先或祖先不是Element，
        *（例如Document或者DocumentFragment）则返回null
        *如果n为0，则返回e本身。如果n为1（或省略），则返回其父元素
        *如果n为2，则返回其祖父元素，依次类推
        */
        function parent(ele, n) {
            if (n === nudefined) n = 1;
            while (n-- &amp;&amp; ele) {
                ele = ele.parentNode;
            }
            if (!ele || ele.nodeTope !== 1) return null;
            return ele;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n个兄弟元素"><a href="#返回元素的第n个兄弟元素" class="headerlink" title="返回元素的第n个兄弟元素"></a>返回元素的第n个兄弟元素</h2><pre><code>/**
 *返回元素ele的第n个兄弟元素
 *如果n为正，返回后续的第n个兄弟元素
 *如果n为负，返回前面的第n个兄弟元素
 *如果n为零，返回ele本身
 */
function sibling(ele, n) {
    while (ele &amp;&amp; n !== 0) { //如果ele未定义，即刻返回它
        if (n &gt; 0) { //查找后续的兄弟元素
            if (ele.nextElementSibling) {
                ele = ele.nextElementSibling;
            } else {
                for (ele = ele.nextSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;
            }
            n--;
        } else { //查找前面的兄弟元素
            if (ele.previousElementSibing) {
                ele = ele.previousElementSibling;
            } else {
                for (ele = ele.previousSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;
            }
            n++;
        }
    }
    return ele;
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n个子代元素"><a href="#返回元素的第n个子代元素" class="headerlink" title="返回元素的第n个子代元素"></a>返回元素的第n个子代元素</h2><pre><code>/**
 *返回元素ele的第n代子元素，如果不存在则为null
 *负值n代表从后往前计数。0表示第一个子元素，而-1代表最后一个，-2代表倒数第二个，依次类推
 */
function child(ele, n) {
    if (ele.children) { //如果children数组存在
        if (n &lt; 0) n += ele.children.length; //转换负的n为数组索引
        if (n &lt; 0) return null; //如果它仍然为负，说明没有子元素
        return ele.children[n]; //返回指定的子元素
    }
    //如果e没有children数组，找到第一个子元素并向前数，或找到最后一个子元素并往回数
    if (n &gt;= 0) { //n非负：从第一个子元素向前数
        //找到元素e的第一个子元素
        if (ele.firstElementChild) {
            ele = ele.firstElementChild;
        } else {
            for (ele = ele.firstChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;
        }
        return sibling(ele, n); //返回第一个子元素的第n个兄弟元素
    } else { //n为负：从最后一个子元素往回数
        if (ele.lastElementChild) {
            ele = ele.lastElementChild;
        } else {
            for (ele = ele.lastChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;
        }
        return sibling(ele, n + 1); //+1来转化最后1个子元素为最后1个兄弟元素
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="表格的行排序"><a href="#表格的行排序" class="headerlink" title="表格的行排序"></a>表格的行排序</h2><pre><code>//根据指定表格每行第n个单元格的值，对第一个＜tbody＞中的行进行排序
//如果存在comparator函数则使用它，否则按字母表顺序比较
function sortrows(table, n, comparator) {
    var tbody = table.tBodies[0]; //第一个＜tbody＞，可能是隐式创建的
    var rows = tbody.getElementsByTagName(&quot;tr&quot;); //tbody中的所有行
    rows = Array.prototype.slice.call(rows, 0); //真实数组中的快照
    //基于第n个＜td＞元素的值对行排序
    rows.sort(function (row1, row2) {
        var cell1 = row1.getElementsByTagName(&quot;td&quot;)[n]; //获得第n个单元格
        var cell2 = row2.getElementsByTagName(&quot;td&quot;)[n]; //两行都是
        var val1 = cell1.textContent || cell1.innerText; //获得文本内容
        var val2 = cell2.textContent || cell2.innerText; //两单元格都是
        if (comparator) return comparator(val1, val2); //进行比较
        if (val1 &lt; val2) {
            return -1;
        } else if (val1 &gt; val2) {
            return 1;
        } else {
            return 0;
        }
    }); //在tbody中按它们的顺序把行添加到最后
    //这将自动把它们从当前位置移走，故没必要预先删除它们
    //如果＜tbody＞还包含了除了＜tr＞的任何其他元素，这些节点将会悬浮到顶部位置
    for (var i = 0; i &lt; rows.length; i++) tbody.appendChild(rows[i]);
}
//查找表格的＜th＞元素（假设只有一行），让它们可单击，
//以便单击列标题，按该列对行排序
function makeSortable(table) {
    var headers = table.getElementsByTagName(&quot;th&quot;);
    for (var i = 0; i &lt; headers.length; i++) {
        (function (n) { //嵌套函数来创建本地作用域
            headers[i].onclick = function () {
                sortrows(table, n);
            };
        }(i)); //将i的值赋给局部变量n
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="生成目录表"><a href="#生成目录表" class="headerlink" title="生成目录表"></a>生成目录表</h2><pre><code>/**
 *
 *这个模块注册一个可在页面加载完成后自动运行的匿名函数。当执行这个函数时会去文档中查找
 *id为&quot;TOC&quot;的元素。如果这个元素不存在，就创建一个元素
 *
 *生成的TOC目录应当具有自己的CSS样式。整个目录区域的样式className设置为&quot;TOCEntry&quot;
 *同样我们为不同层级的目录标题定义不同的样式。＜h1＞标签生成的标题
 *className为&quot;TOCLevel1&quot;，＜h2＞标签生成的标题className为&quot;TOCLevel2&quot;，以此类推
 *段编号的样式为&quot;TOCSectNum&quot;
 *
 *完整的CSS样式代码如下:
 *
 *#TOC{border:solid black 1px;margin:10px;padding:10px;}
 *.TOCEntry{font-family:sans-serif;}
 *.TOCEntry a{text-decoration:none;}
 *.TOCLevel1{font-size:16pt;font-weight:bold;}
 *.TOCLevel2{font-size:12pt;margin-left:.5in;}
 *.TOCSectNum:after{content:&quot;:&quot;;}
 *
 *这段代码的最后一行表示每个段编号之后都有一个冒号和空格符。要想隐藏段编号，
 *请使用这行代码：
 *.TOCSectNum{display:none}
 *
 **/
(function () { //匿名函数定义了一个局部作用域
    //查找TOC容器元素
    //如果不存在，则在文档开头处创建一个
    var toc = document.getElementById(&quot;TOC&quot;);
    if (!toc) {
        toc = document.createElement(&quot;div&quot;);
        toc.id = &quot;TOC&quot;;
        document.body.insertBefore(toc, document.body.firstChild);
    }
    //查找所有的标题元素
    var headings;
    if (document.querySelectorAll) //我们是否能用这个简单的方法？
        headings = document.querySelectorAll(&quot;h1,h2,h3,h4,h5,h6&quot;);
    else //否则，查找方法稍微麻烦一些
        headings = findHeadings(document.body, []); //递归遍历document的body，查找标题元素
    function findHeadings(root, sects) {
        for (var c = root.firstChild; c != null; c = c.nextSibling) {
            if (c.nodeType !== 1) continue;
            if (c.tagName.length == 2 &amp;&amp; c.tagName.charAt(0) == &quot;H&quot;)
                sects.push(c);
            else
                findHeadings(c, sects);
        }
        return sects;
    }
    //初始化一个数组来保持跟踪章节号
    var sectionNumbers = [0, 0, 0, 0, 0, 0]; //现在，循环已找到的标题元素
    for (var h = 0; h &lt; headings.length; h++) {
        var heading = headings[h]; //跳过在TOC容器中的标题元素
        if (heading.parentNode == toc) continue; //判定标题的级别
        var level = parseInt(heading.tagName.charAt(1));
        if (isNaN(level) || level &lt; 1 || level &gt; 6) continue; //对于该标题级别增加sectionNumbers对应的数字
        //重置所有标题比它级别低的数字为零
        sectionNumbers[level - 1]++;
        for (var i = level; i &lt; 6; i++) sectionNumbers[i] = 0; //现在，将所有标题级别的章节号组合产生一个章节号， 如2 .3 .1
        var sectionNumber = sectionNumbers.slice(0, level).join(&quot;.&quot;) //为标题级别增加章节号
        //把数字放在＜span＞中，使得其可以用样式修饰
        var span = document.createElement(&quot;span&quot;);
        span.className = &quot;TOCSectNum&quot;;
        span.innerHTML = sectionNumber;
        heading.insertBefore(span, heading.firstChild); //用命名的锚点将标题包起来，以便为它增加链接
        var anchor = document.createElement(&quot;a&quot;);
        anchor.name = &quot;TOC&quot; + sectionNumber;
        heading.parentNode.insertBefore(anchor, heading);
        anchor.appendChild(heading); //现在为该节创建一个链接
        var link = document.createElement(&quot;a&quot;);
        link.href = &quot;#TOC&quot; + sectionNumber; //链接的目标地址
        link.innerHTML = heading.innerHTML; //链接文本与实际标题一致
        //将链接放在一个div中，div用基于级别名字的样式修饰
        var entry = document.createElement(&quot;div&quot;);
        entry.className = &quot;TOCEntry TOCLevel&quot; + level;
        entry.appendChild(link); //该div添加到TOC容器中
        toc.appendChild(entry);
    }
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="从URL解析参数"><a href="#从URL解析参数" class="headerlink" title="从URL解析参数"></a>从URL解析参数</h2><pre><code>/*
 *这个函数用来解析来自URL的查询串中的name=value参数对
 *它将name=value对存储在一个对象的属性中，并返回该对象
 *这样来使用它
 *
 *var args=urlArgs();//从URL中解析参数
 *var q=args.q||&quot;&quot;;//如果参数定义了的话就使用参数；否则使用一个默认值
 *var n=args.n?parseInt(args.n):10;
 */
function urlArgs() {
    var args = {}; //定义一个空对象
    var query = location.search.substring(1); //查找到查询串，并去掉&apos;?&apos;
    var pairs = query.split(&quot;&amp;&quot;); //根据&quot;&amp;&quot;符号将查询字符串分隔开
    for (var i = 0; i &lt; pairs.length; i++) { //对于每个片段
        var pos = pairs[i].indexOf(&apos;=&apos;); //查找&quot;name=value&quot;
        if (pos == -1) continue; //如果没有找到的话，就跳过
        var name = pairs[i].substring(0, pos); //提取name
        var value = pairs[i].substring(pos + 1); //提取value
        value = decodeURIComponent(value); //对value进行解码
        args[name] = value; //存储为属性
    }
    return args; //返回解析后的参数
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="获取纯文本的元素内容"><a href="#获取纯文本的元素内容" class="headerlink" title="获取纯文本的元素内容"></a>获取纯文本的元素内容</h2><pre><code>/**
 *一个参数，返回元素的textContent或innerText
 *两个参数，用value参数的值设置元素的textContent或innerText
 */
function textContent(element, value) {
    var content = element.textContent; //检测textContent是否有定义
    if (value === undefined) { //没传递value，因此返回当前文本
        if (content !== undefined) {
            return content;
        } else {
            return element.innerText;
        }
    } else { //传递了value，因此设置文本
        if (content !== undefined) {
            element.textContent = value;
        } else {
            element.innerText = value;
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="手写一个JSONP实现"><a href="#手写一个JSONP实现" class="headerlink" title="手写一个JSONP实现"></a>手写一个JSONP实现</h2><pre><code>//根据指定的URL发送一个JSONP请求
//然后把解析得到的响应数据传递给回调函数
//在URL中添加一个名为jsonp的查询参数，用于指定该请求的回调函数的名称
function getJSONP(url, callback) { //为本次请求创建一个唯一的回调函数名称
    var cbnum = &quot;cb&quot; + getJSONP.counter++; //每次自增计数器
    var cbname = &quot;getJSONP.&quot; + cbnum; //作为JSONP函数的属性
    //将回调函数名称以表单编码的形式添加到URL的查询部分中
    //使用jsonp作为参数名，一些支持JSONP的服务
    //可能使用其他的参数名，比如callback
    if (url.indexOf(&quot;?&quot;) === -1) //URL没有查询部分
        url += &quot;?jsonp=&quot; + cbname; //作为查询部分添加参数
    else //否则
        url += &quot;＆jsonp=&quot; + cbname; //作为新的参数添加它
    //创建script元素用于发送请求
    var script = document.createElement(&quot;script&quot;); //定义将被脚本执行的回调函数
    getJSONP[cbnum] = function (response) {
        try {
            callback(response); //处理响应数据
        } finally { //即使回调函数或响应抛出错误
            delete getJSONP[cbnum]; //删除该函数
            script.parentNode.removeChild(script); //移除script元素
        }
    }; //立即触发HTTP请求
    script.src = url; //设置脚本的URL
    document.body.appendChild(script); //把它添加到文档中
}
getJSONP.counter = 0; //用于创建唯一回调函数名称的计数器
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><pre><code>//将child节点插入到parent中，使其成为第n个子节点
function insertAt(parent, child, n) {
    if (n &lt; 0 || n &gt; parent.childNodes.length) {
        throw new Error(&quot;invalid index&quot;);
    } else if (n == parent.childNodes.length) {
        parent.appendChild(child);
    } else {
        parent.insertBefore(child, parent.childNodes[n]);
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用innerHTML实现outerHTML属性"><a href="#使用innerHTML实现outerHTML属性" class="headerlink" title="使用innerHTML实现outerHTML属性"></a>使用innerHTML实现outerHTML属性</h2><pre><code>//为那些不支持它的浏览器实现outerHTML属性
//假设浏览器确实支持innerHTML，并有个可扩展的Element.prototype，
//并且可以定义getter和setter
(function () { //如果outerHTML存在，则直接返回
    if (document.createElement(&quot;div&quot;).outerHTML) return; //返回this所引用元素的外部HTML
    function outerHTMLGetter() {
        var container = document.createElement(&quot;div&quot;); //虚拟元素
        container.appendChild(this.cloneNode(true)); //复制到该虚拟节点
        return container.innerHTML; //返回虚拟节点的innerHTML
    }
    //用指定的值设置元素的外部HTML
    function outerHTMLSetter(value) { //创建一个虚拟元素，设置其内容为指定的值
        var container = document.createElement(&quot;div&quot;);
        container.innerHTML = value; //将虚拟元素中的节点全部移动到文档中
        while (container.firstChild) //循环，直到container没有子节点为止
            this.parentNode.insertBefore(container.firstChild, this); //删除所被取代的节点
        this.parentNode.removeChild(this);
    }
    //现在使用这两个函数作为所有Element对象的outerHTML属性的getter和setter
    //如果它存在则使用ES5的Object.defineProperty()方法，
    //否则，退而求其次，使用__defineGetter__()和__defineSetter__()
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, &quot;outerHTML&quot;, {
            get: outerHTMLGetter,
            set: outerHTMLSetter,
            enumerable: false,
            configurable: true
        });
    } else {
        Element.prototype.__defineGetter__(&quot;outerHTML&quot;, outerHTMLGetter);
        Element.prototype.__defineSetter__(&quot;outerHTML&quot;, outerHTMLSetter);
    }
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="倒序排列子节点"><a href="#倒序排列子节点" class="headerlink" title="倒序排列子节点"></a>倒序排列子节点</h2><pre><code>//倒序排列节点n的子节点
function reverse(n) { //创建一个DocumentFragment作为临时容器
    var f = document.createDocumentFragment(); //从后至前循环子节点，将每一个子节点移动到文档片段中
    //n的最后一个节点变成f的第一个节点，反之亦然
    //注意，给f添加一个节点，该节点自动地会从n中删除
    while (n.lastChild) f.appendChild(n.lastChild); //最后，把f的所有子节点一次性全部移回n中
    n.appendChild(f);
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询窗口滚动条的位置"><a href="#查询窗口滚动条的位置" class="headerlink" title="查询窗口滚动条的位置"></a>查询窗口滚动条的位置</h2><pre><code>//以一个对象的x和y属性的方式返回滚动条的偏移量
function getScrollOffsets(w) { //使用指定的窗口，如果不带参数则使用当前窗口
    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用
    if (w.pageXOffset != null) return {
        x: w.pageXOffset,
        y: w.pageYOffset
    }; //对标准模式下的IE（或任何浏览器）
    var d = w.document;
    if (document.compatMode == &quot;CSS1Compat&quot;)
        return {
            x: d.documentElement.scrollLeft,
            y: d.documentElement.scrollTop
        }; //对怪异模式下的浏览器
    return {
        x: d.body.scrollLeft,
        y: d.body.scrollTop
    };
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询窗口的视口尺寸"><a href="#查询窗口的视口尺寸" class="headerlink" title="查询窗口的视口尺寸"></a>查询窗口的视口尺寸</h2><pre><code>//作为一个对象的w和h属性返回视口的尺寸
function getViewportSize(w) { //使用指定的窗口，如果不带参数则使用当前窗口
    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用
    if (w.innerWidth != null) return {
        w: w.innerWidth,
        h: w.innerHeight
    }; //对标准模式下的IE（或任何浏览器）
    var d = w.document;
    if (document.compatMode == &quot;CSS1Compat&quot;)
        return {
            w: d.documentElement.clientWidth,
            h: d.documentElement.clientHeight
        }; //对怪异模式下的浏览器
    return {
        w: d.body.clientWidth,
        h: d.body.clientWidth
    };
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回函数的名字"><a href="#返回函数的名字" class="headerlink" title="返回函数的名字"></a>返回函数的名字</h2><pre><code>Function.prototype.getName = function () {
    return this.name || this.toString().match(/function\s*(\w*)\s*\(/)[1];
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="原生JS实现CSS动画1"><a href="#原生JS实现CSS动画1" class="headerlink" title="原生JS实现CSS动画1"></a>原生JS实现CSS动画1</h2><pre><code>//将e转化为相对定位的元素，使之左右&quot;震动&quot;
//第一个参数可以是元素对象或者元素的id
//如果第二个参数是函数，以e为参数，它将在动画结束时调用
//第三个参数指定e震动的距离，默认是5像素
//第四个参数指定震动多久，默认是500毫秒
function shake(e, oncomplete, distance, time) { //句柄参数
    if (typeof e === &quot;string&quot;) e = document.getElementById(e);
    if (!time) time = 500;
    if (!distance) distance = 5;
    var originalStyle = e.style.cssText; //保存e的原始style
    e.style.position = &quot;relative&quot;; //使e相对定位
    var start = (new Date()).getTime(); //注意，动画的开始时间
    animate(); //动画开始
    //函数检查消耗的时间，并更新e的位置
    //如果动画完成，它将e还原为原始状态
    //否则，它更新e的位置，安排它自身重新运行
    function animate() {
        var now = (new Date()).getTime(); //得到当前时间
        var elapsed = now - start; //从开始以来消耗了多长时间？
        var fraction = elapsed / time; //是总时间的几分之几？
        if (fraction &lt; 1) { //如果动画未完成
            //作为动画完成比例的函数，计算e的x位置
            //使用正弦函数将完成比例乘以4pi
            //所以，它来回往复两次
            var x = distance * Math.sin(fraction * 4 * Math.PI);
            e.style.left = x + &quot;px&quot;; //在25毫秒后或在总时间的最后尝试再次运行函数
            //目的是为了产生每秒40帧的动画
            setTimeout(animate, Math.min(25, time - elapsed));
        } else { //否则，动画完成
            e.style.cssText = originalStyle //恢复原始样式
            if (oncomplete) oncomplete(e); //调用完成后的回调函数
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="原生JS实现CSS动画2"><a href="#原生JS实现CSS动画2" class="headerlink" title="原生JS实现CSS动画2"></a>原生JS实现CSS动画2</h2><pre><code>function fadeOut(e, oncomplete, time) {
    if (typeof e === &quot;string&quot;) e = document.getElementById(e);
    if (!time) time = 500; //使用Math.sqrt作为一个简单的“缓动函数”来创建动画
    //精巧的非线性：一开始淡出得比较快，然后缓慢了一些
    var ease = Math.sqrt;
    var start = (new Date()).getTime(); //注意：动画开始的时间
    animate(); //动画开始
    function animate() {
        var elapsed = (new Date()).getTime() - start; //消耗的时间
        var fraction = elapsed / time; //总时间的几分之几？
        if (fraction &lt; 1) { //如果动画未完成
            var opacity = 1 - ease(fraction); //计算元素的不透明度
            e.style.opacity = String(opacity); //设置在e上
            setTimeout(animate, //调度下一帧
                Math.min(25, time - elapsed));
        } else { //否则，动画完成
            e.style.opacity = &quot;0&quot;; //使e完全透明
            if (oncomplete) oncomplete(e); //调用完成后的回调函数
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿HTML5的classList属性"><a href="#仿HTML5的classList属性" class="headerlink" title="仿HTML5的classList属性"></a>仿HTML5的classList属性</h2><pre><code>/*
 *如果e有classList属性则返回它。否则，返回一个为e模拟DOMTokenList API的对象
 *返回的对象有contains()、add()、remove()、toggle()和toString()等方法
 *来检测和修改元素e的类集合。如果classList属性是原生支持的，
 *返回的类数组对象有length和数组索引属性。模拟DOMTokenList不是类数组对象，
 *但是它有一个toArray()方法来返回一个含元素类名的纯数组快照
 */
function classList(e) {
    if (e.classList) return e.classList; //如果e.classList存在，则返回它
    else return new CSSClassList(e); //否则，就伪造一个
}
//CSSClassList是一个模拟DOMTokenList的JavaScript类
function CSSClassList(e) {
    this.e = e;
} //如果e.className包含类名c则返回true否则返回false
CSSClassList.prototype.contains = function (c) { //检查c是否是合法的类名
    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)
        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //首先是常规检查
    var classes = this.e.className;
    if (!classes) return false; //e不含类名
    if (classes === c) return true; //e有一个完全匹配的类名
    //否则，把c自身看做一个单词，利用正则表达式搜索c
    //\b在正则表达式里代表单词的边界
    return classes.search(&quot;\\b&quot; + c + &quot;\\b&quot;) != -1;
}; //如果c不存在，将c添加到e.className中
CSSClassList.prototype.add = function (c) {
    if (this.contains(c)) return; //如果存在，什么都不做
    var classes = this.e.className;
    if (classes &amp;&amp; classes[classes.length - 1] != &quot;&quot;)
        c = &quot;&quot; + c; //如果需要加一个空格
    this.e.className += c; //将c添加到className中
}; //将在e.className中出现的所有c都删除
CSSClassList.prototype.remove = function (c) { //检查c是否是合法的类名
    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)
        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //将所有作为单词的c和多余的尾随空格全部删除
    var pattern = new RegExp(&quot;\\b&quot; + c + &quot;\\b\\s*&quot;, &quot;g&quot;);
    this.e.className = this.e.className.replace(pattern, &quot;&quot;);
}; //如果c不存在，将c添加到e.className中，并返回true
//否则，将在e.className中出现的所有c都删除，并返回false
CSSClassList.prototype.toggle = function (c) {
    if (this.contains(c)) { //如果e.className包含c
        this.remove(c); //删除它
        return false;
    } else { //否则
        this.add(c); //添加它
        return true;
    }
}; //返回e.className本身
CSSClassList.prototype.toString = function () {
    return this.e.className;
}; //返回在e.className中的类名
CSSClassList.prototype.toArray = function () {
    return this.e.className.match(/\b\w+\b/g) || [];
};
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询纯文本形式的内容"><a href="#查询纯文本形式的内容" class="headerlink" title="查询纯文本形式的内容"></a>查询纯文本形式的内容</h2><pre><code>/**
 *一个参数，返回元素的textContent或innerText
 *两个参数，用value参数的值设置元素的textContent或innerText
 */
function textContent(element, value) {
    var content = element.textContent; //检测textContent是否有定义
    if (value === undefined) { //没传递value，因此返回当前文本
        if (content !== undefined) return content;
        else return element.innerText;
    } else { //传递了value，因此设置文本
        if (content !== undefined) element.textContent = value;
        else element.innerText = value;
    }
}
</code></pre><p>textContent属性在除了IE的所有当前的浏览器中都支持。在IE中，可以用Element的innerText属性来代替。 <a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查找元素的后代中节点中的所有Text节点"><a href="#查找元素的后代中节点中的所有Text节点" class="headerlink" title="查找元素的后代中节点中的所有Text节点"></a>查找元素的后代中节点中的所有Text节点</h2><pre><code>//返回元素e的纯文本内容，递归进入其子元素
//该方法的效果类似于textContent属性
function textContent(e) {
    var child, type, s = &quot;&quot;; //s保存所有子节点的文本
    for (child = e.firstChild; child != null; child = child.nextSibling) {
        type = child.nodeType;
        if (type === 3 || type === 4) //Text和CDATASection节点
            s += child.nodeValue;
        else if (type === 1) //递归Element节点
            s += textContent(child);
    }
    return s;
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用innerHTML实现insertAdjacentHTML"><a href="#使用innerHTML实现insertAdjacentHTML" class="headerlink" title="使用innerHTML实现insertAdjacentHTML()"></a>使用innerHTML实现insertAdjacentHTML()</h2><pre><code>//本模块为不支持它的浏览器定义了Element.insertAdjacentHTML
//还定义了一些可移植的HTML插入函数，它们的名字比insertAdjacentHTML更符合逻辑：
//Insert.before()、Insert.after()、Insert.atStart()和Insert.atEnd()
var Insert = (function () { //如果元素有原生的insertAdjacentHTML，
    //在4个函数名更明了的HTML插入函数中使用它
    if (document.createElement(&quot;div&quot;).insertAdjacentHTML) {
        return {
            before: function (e, h) {
                e.insertAdjacentHTML(&quot;beforebegin&quot;, h);
            },
            after: function (e, h) {
                e.insertAdjacentHTML(&quot;afterend&quot;, h);
            },
            atStart: function (e, h) {
                e.insertAdjacentHTML(&quot;afterbegin&quot;, h);
            },
            atEnd: function (e, h) {
                e.insertAdjacentHTML(&quot;beforeend&quot;, h);
            }
        };
    }
    //否则，无原生的insertAdjacentHTML
    //实现同样的4个插入函数，并使用它们来定义insertAdjacentHTML
    //首先，定义一个工具函数，传入HTML字符串，返回一个DocumentFragment，
    //它包含了解析后的HTML的表示
    function fragment(html) {
        var elt = document.createElement(&quot;div&quot;); //创建空元素
        var frag = document.createDocumentFragment(); //创建空文档片段
        elt.innerHTML = html; //设置元素内容
        while (elt.firstChild) //移动所有的节点
            frag.appendChild(elt.firstChild); //从elt到frag
        return frag; //然后返回frag
    }
    var Insert = {
        before: function (elt, html) {
            elt.parentNode.insertBefore(fragment(html), elt);
        },
        after: function (elt, html) {
            elt.parentNode.insertBefore(fragment(html), elt.nextSibling);
        },
        atStart: function (elt, html) {
            elt.insertBefore(fragment(html), elt.firstChild);
        },
        atEnd: function (elt, html) {
            elt.appendChild(fragment(html));
        }
    }; //基于以上函数实现insertAdjacentHTML
    Element.prototype.insertAdjacentHTML = function (pos, html) {
        switch (pos.toLowerCase()) {
            case &quot;beforebegin&quot;:
                return Insert.before(this, html);
            case &quot;afterend&quot;:
                return Insert.after(this, html);
            case &quot;afterbegin&quot;:
                return Insert.atStart(this, html);
            case &quot;beforeend&quot;:
                return Insert.atEnd(this, html);
        }
    };
    return Insert; //最后返回4个插入函数
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><pre><code>/**
 *Drag.js：拖动绝对定位的HTML元素
 *
 *这个模块定义了一个drag()函数，它用于mousedown事件处理程序的调用
 *随后的mousemove事件将移动指定元素，mouseup事件将终止拖动
 *这些实现能同标准和IE两种事件模型一起工作
 *
 *参数：
 *
 *elementToDrag：接收mousedown事件的元素或某些包含元素
 *它必须是定位的元素,元素的样式必须是行内样式
 *它的style.left和style.top值将随着用户的拖动而改变
 *
 *event：mousedown事件对象
 **/
function drag(elementToDrag, event) { //初始鼠标位置，转换为文档坐标
    var startX = event.clientX;
    var startY = event.clientY; //在文档坐标下，待拖动元素的初始位置
    //因为elementToDrag是绝对定位的，
    //所以我们可以假设它的offsetParent就是文档的body元素
    var origX = parseFloat(elementToDrag.style.left);
    var origY = parseFloat(elementToDrag.style.top); //计算mousedown事件和元素左上角之间的距离
    //我们将它另存为鼠标移动的距离
    if (document.addEventListener) { //标准事件模型
        //在document对象上注册捕获事件处理程序
        document.addEventListener(&quot;mousemove&quot;, moveHandler, true);
        document.addEventListener(&quot;mouseup&quot;, upHandler, true);
    } else if (document.attachEvent) { //用于IE5～8的IE事件模型
        //在IE事件模型中，
        //捕获事件是通过调用元素上的setCapture()捕获它们
        elementToDrag.setCapture();
        elementToDrag.attachEvent(&quot;onmousemove&quot;, moveHandler);
        elementToDrag.attachEvent(&quot;onmouseup&quot;, upHandler); //作为mouseup事件看待鼠标捕获的丢失
        elementToDrag.attachEvent(&quot;onlosecapture&quot;, upHandler);
    }
    //我们处理了这个事件，不让任何其他元素看到它
    if (event.stopPropagation) event.stopPropagation(); //标准模型
    else event.cancelBubble = true; //IE
    //现在阻止任何默认操作
    if (event.preventDefault) event.preventDefault(); //标准模型
    else event.returnValue = false; //IE
    /**
     * 当元素正在被拖动时， 这就是捕获mousemove事件的处理程序
     *它用于移动这个元素 
     **/
    function moveHandler(e) {
        if (!e) e = window.event; //IE事件模型
        //移动这个元素到当前鼠标位置，
        //通过滚动条的位置和初始单击的偏移量来调整
        var targetLeft = e.clientX - startX + origX;
        var targetTop = e.clientY - startY + origY;
        var minLeft = 0;
        var minTop = 0;
        var maxLeft = (document.documentElement.clientWidth || document.body.clientWidth) - elementToDrag.offsetWidth;
        var maxTop = (document.documentElement.clientHeight || document.body.clientHeight) - elementToDrag.offsetHeight;
        targetLeft = targetLeft &gt; maxLeft ? maxLeft : (targetLeft &lt; minLeft ? minLeft : targetLeft);
        targetTop = targetTop &gt; maxTop ? maxTop : (targetTop &lt; minTop ? minTop : targetTop);
        elementToDrag.style.left = targetLeft + &quot;px&quot;;
        elementToDrag.style.top = targetTop + &quot;px&quot;;
        if (e.stopPropagation) e.stopPropagation(); //标准
        else e.cancelBubble = true; //IE
    }
    /**
     *这是捕获在拖动结束时发生的最终mouseup事件的处理程序
     **/
    function upHandler(e) {
        if (!e) e = window.event; //IE事件模型
        //注销捕获事件处理程序
        if (document.removeEventListener) { //DOM事件模型
            document.removeEventListener(&quot;mouseup&quot;, upHandler, true);
            document.removeEventListener(&quot;mousemove&quot;, moveHandler, true);
        } else if (document.detachEvent) { //IE 5+事件模型
            elementToDrag.detachEvent(&quot;onlosecapture&quot;, upHandler);
            elementToDrag.detachEvent(&quot;onmouseup&quot;, upHandler);
            elementToDrag.detachEvent(&quot;onmousemove&quot;, moveHandler);
            elementToDrag.releaseCapture();
        }
        //并且不让事件进一步传播
        if (e.stopPropagation) e.stopPropagation(); //标准模型
        else e.cancelBubble = true; //IE
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在谷歌地图上显示地理位置信息"><a href="#在谷歌地图上显示地理位置信息" class="headerlink" title="在谷歌地图上显示地理位置信息"></a>在谷歌地图上显示地理位置信息</h2><pre><code>//获取当前位置然后通过Google地图显示
//如果当前浏览器不支持地理位置API，则抛出一个错误
function getmap() { //检查是否支持地理位置API
    if (!navigator.geolocation) throw &quot;Geolocation not supported&quot;; //开始请求地理位置信息，
    navigator.geolocation.getCurrentPosition(setMapURL);
    function setMapURL(pos) { //从参数对象（pos）中获取位置信息
        var latitude = pos.coords.latitude; //经度
        var longitude = pos.coords.longitude; //纬度
        var accuracy = pos.coords.accuracy; //米
        var scale = 10; //比例
        //构造一个URL，用于跳转到Google地图
        var url = &quot;https://www.google.com/maps/@&quot; + latitude + &quot;,&quot; + longitude + &quot;,&quot; + scale + &quot;z&quot;; //设置一个大致的缩放级别
        location = url;
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用所有地理位置特性"><a href="#使用所有地理位置特性" class="headerlink" title="使用所有地理位置特性"></a>使用所有地理位置特性</h2><pre><code>//异步的获取我的位置，并在指定的元素中展示出来
function whereami(elt) { //将此对象作为第三个参数传递给getCurrentPosition()方法
    var options = { //设置为true，表示如果可以的话
        //获取高精度的位置信息（例如，通过GPS获取）
        //但是，要注意的是，这会影响电池寿命
        enableHighAccuracy: false, //可以近似：这是默认值
        //如果获取缓存过的位置信息就足够的话，可以设置此属性
        //默认值为0,表示强制检查新的位置信息
        maximumAge: 300000, //5分钟左后
        //愿意等待多长时间来获取位置信息？
        //默认值为无限长 [2] ，getCurrentPosition()方法永不超时
        timeout: 15000 //不要超过15秒
    };
    if (navigator.geolocation) //如果支持的话，就获取位置信息
        navigator.geolocation.getCurrentPosition(success, error, options);
    else
        elt.innerHTMl = &quot;Geolocation not supported in this browser&quot;; //当获取位置信息失败的时候，会调用此函数

    function error(e) { //error对象包含一些数字编码和文本消息，如下所示：
        //1:用户不允许分享他/她的位置信息
        //2:浏览器无法确定位置
        //3:发生超时
        elt.innerHTML = &quot;Geolocation error&quot; + e.code + &quot;:&quot; + e.message;
    }
    //当获取位置信息成功的时候，会调用此函数
    function success(pos) { //总是可以获取如下这些字段
        //但是要注意的是时间戳信息在outer对象中，而不在inner、coords对象中
        var msg = &quot;时间是&quot; +
            new Date(pos.timestamp).toLocaleString() + &quot;地理位置是&quot; +
            pos.coords.accuracy + &quot;米范围内经度是&quot; +
            pos.coords.latitude + &quot;纬度是&quot; +
            pos.coords.longitude + &quot;.&quot;; //如果设备还返回了海拔信息，则将其添加进去
        if (pos.coords.altitude) {
            msg += &quot;海拔是&quot; + pos.coords.altitude + &quot;±&quot; +
                pos.coords.altitudeAccuracy + &quot;千米.&quot;;
        }
        //如果设备还返回了速度和航向信息，也将它们添加进去
        if (pos.coords.speed) {
            msg += &quot;速度是&quot; +
                pos.coords.speed + &quot;m/s方向是&quot; +
                pos.coords.heading + &quot;.&quot;;
        }
        elt.innerHTML = msg; //显示所有的位置信息
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="优雅的图片翻转实现"><a href="#优雅的图片翻转实现" class="headerlink" title="优雅的图片翻转实现"></a>优雅的图片翻转实现</h2><pre><code>/**
 *优雅的图片翻转实现方式
 *
 *要创建图片翻转效果，将此模块引入到HTML文件中
 *然后在任意＜img＞元素上使用data-rollover属性来指定翻转图片的URL即可
 *如下所示:
 *
 *&lt;img src=&quot;normal_image.png &quot;data-rollover=&quot;rollover_image.png&quot;&gt;
 *
 */
function changeImage() { //所有处理逻辑都在一个匿名函数中:不定义任何符号
    //遍历所有的图片，查找data-rollover属性
    for (var i = 0; i &lt; document.images.length; i++) {
        var img = document.images[i];
        var rollover = img.getAttribute(&quot;data-rollover&quot;);
        if (!rollover) continue; //跳过没有data-rollover属性的图片
        //确保将翻转的图片缓存起来
        (new Image()).src = rollover; //定义一个属性来标识默认的图片URL
        img.setAttribute(&quot;data-rollout&quot;, img.src); //注册事件处理函数来创建翻转效果
        img.onmouseover = function () {
            this.src = this.getAttribute(&quot;data-rollover&quot;);
        };
        img.onmouseout = function () {
            this.src = this.getAttribute(&quot;data-rollout&quot;);
        };
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用canvas绘制多边形"><a href="#使用canvas绘制多边形" class="headerlink" title="使用canvas绘制多边形"></a>使用canvas绘制多边形</h2><pre><code>//定义一个以(x,y)为中心，半径为r的规则n边形,c可以通过调用画布getContext()方法得到
//每个顶点都是均匀分布在圆周上
//将第一个顶点放置在最上面，或者指定一定角度
//除非最后一个参数是true，否则顺时针旋转
function polygon(c, n, x, y, r, angle, counterclockwise) {
    angle = angle || 0;
    counterclockwise = counterclockwise || false;
    c.moveTo(x + r * Math.sin(angle), //从第一个顶点开始一条新的子路径
        y - r * Math.cos(angle)); //使用三角法计算位置
    var delta = 2 * Math.PI / n; //两个顶点之间的夹角
    for (var i = 1; i &lt; n; i++) { //循环剩余的每个顶点
        angle += counterclockwise ? -delta : delta; //调整角度
        c.lineTo(x + r * Math.sin(angle), //以下个顶点为端点添加线段
            y - r * Math.cos(angle));
    }
    c.closePath(); //将最后一个顶点和起点连接起来
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用canvas绘制雪花"><a href="#使用canvas绘制雪花" class="headerlink" title="使用canvas绘制雪花"></a>使用canvas绘制雪花</h2><pre><code>var deg = Math.PI / 180; //用于角度制到弧度制的转换
//在画布的上下文c中，以左下角的点(x,y)和边长len，绘制一个n级别的科赫雪花分形
function snowflake(c, n, x, y, len) {
    c.save(); //保存当前变换
    c.translate(x, y); //变换原点为起始点
    c.moveTo(0, 0); //从新的原点开始一条新的子路径
    leg(n); //绘制雪花的第一条边
    c.rotate(-120 * deg); //现在沿着逆时针方向旋转120 o
    leg(n); //绘制第二条边
    c.rotate(-120 * deg); //再次旋转
    leg(n); //画最后一条边
    c.closePath(); //闭合子路径
    c.restore(); //恢复初始的变换
    //绘制n级别的科赫雪花的一条边
    //此函数在画完一条边的时候就离开当前点，
    //然后通过坐标系变换将当前点又转换成(0,0,)
    //这意味着画完一条边之后可以很简单地调用rotate()进行旋转
    function leg(n) {
        c.save(); //保存当前坐标系变换
        if (n == 0) { //不需要递归的情况下:
            c.lineTo(len, 0); //就绘制一条水平线段
        } else { //递归情况下：绘制4条子边，类似这个样子： - \/ -
            c.scale(1 / 3, 1 / 3); //子边长度为原边长的1/3
            leg(n - 1); //递归第一条子边
            c.rotate(60 * deg); //顺时针旋转60 o
            leg(n - 1); //第二条子边
            c.rotate(-120 * deg); //逆时针旋转120 o
            leg(n - 1); //第三条子边
            c.rotate(60 * deg); //通过旋转回到初始状态
            leg(n - 1); //最后一条边
        }
        c.restore(); //恢复坐标系变换
        c.translate(len, 0); //但是通过转换使得边的结束点为(0,0)
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在Web-Worker中发起同步XMLHtttpRequest"><a href="#在Web-Worker中发起同步XMLHtttpRequest" class="headerlink" title="在Web Worker中发起同步XMLHtttpRequest"></a>在Web Worker中发起同步XMLHtttpRequest</h2><pre><code>//此文件会通过一个新的Worker()来载入，因此，它是运行在独立的线程中的，
//可以放心地使用同步XMLHttpRequest API
//消息是URL数组的形式。以字符串形式同步获取每个URL指定的内容，
//并将这些字符串数组传递回去。
onmessage = function (e) {
    var urls = e.data; //输入：要获取的URL
    var contents = []; //输出：URL指定的内容
    for (var i = 0; i &lt; urls.length; i++) {
        var url = urls[i]; //每个URL
        var xhr = new XMLHttpRequest(); //开始一个HTTP请求
        xhr.open(&quot;GET&quot;, url, false); //false则表示进行同步请求
        xhr.send(); //阻塞住，一直到响应完成
        if (xhr.status !== 200) //如果请求失败则抛出错误
            throw Error(xhr.status + &quot; &quot; + xhr.statusText + &quot;: &quot; + url);
        contents.push(xhr.responseText); //否则，存储通过URL获取得到的内容
    }
    //最后，将这些URL内容以数组的形式传递回主线程
    postMessage(contents);
}
</code></pre><p>善于利用JS中的小技巧，不仅可以使代码更加简洁，而且逼格更高。</p>
<h2 id="使用-模拟Boolean-函数"><a href="#使用-模拟Boolean-函数" class="headerlink" title="使用!!模拟Boolean()函数"></a>使用!!模拟Boolean()函数</h2><p>原理：逻辑非操作一个数据对象时，会先将数据对象转换为布尔值，然后取反，两个!!重复取反，就实现了转换为布尔值的效果。</p>
<h2 id="使用一元加-模拟Number-函数"><a href="#使用一元加-模拟Number-函数" class="headerlink" title="使用一元加(+)模拟Number()函数"></a>使用一元加(+)模拟Number()函数</h2><p>原理：对非数值类型的数据使用一元加(+)，会起到与Number()函数相同的效果。</p>
<p>null转换为0</p>
<p>undefined转换为NaN</p>
<p>false转换为0，true转换为1</p>
<p>对于字符串： </p>
<p>空字串转换为0</p>
<p>含有数字或者浮点数或者十六进制格式的数据(11, 0.3, 0xfe等)，转换为相应的数值</p>
<p>含有其他格式字符，无法转换为数值的字符串，转换为NaN</p>
<p>对于对象，先调用valueOf()方法，在转换，若结果为NaN，那么再调用toString()方法，之后再转换</p>
<h2 id="使用逻辑与-amp-amp-进行短路操作"><a href="#使用逻辑与-amp-amp-进行短路操作" class="headerlink" title="使用逻辑与(&amp;&amp;)进行短路操作"></a>使用逻辑与(&amp;&amp;)进行短路操作</h2><pre><code>if(connected){
    login();
}
</code></pre><p>以上代码可以简写为:</p>
<p><code>connected &amp;&amp; login();</code></p>
<p>也可用这种方法来检查对象中是否拥有某个属性</p>
<pre><code>user &amp;&amp; user.name
</code></pre><p>原理：逻辑与(&amp;&amp;)会首先对第一个操作数进行求值，只有求值结果为true时才会对第二个操作数求值。connected &amp;&amp; login()中，若判断connected不为true,则不再进行下一步操作。<br>所谓的短路操作即第一个操作数可以决定结果，则不再对第二个操作数进行求值。</p>
<h2 id="使用逻辑或-设置默认值"><a href="#使用逻辑或-设置默认值" class="headerlink" title="使用逻辑或(||)设置默认值"></a>使用逻辑或(||)设置默认值</h2><p>逻辑或(||)也属于短路操作，即当第一个操作数可以决定结果时，不再对第二个操作数进行求值。利用这个特点，我们可以给赋值语句设置默认值。只有当第一个操作数为null或者undefined时，才会把第二个操作数赋值给目标。</p>
<pre><code>function User(name, age){
    this.name = name || &quot;Liming&quot;;
}
</code></pre><p>上述代码中，如果函数中没有传入name参数，name的值为undefined，那么就会给this.name赋值为”Liming”。<br>ES6中可以为函数设置默认值，所以这种方法可能要成为过去式，但是其他地方还是很有用的。<br>ES6 写法 简洁了许多</p>
<pre><code>let User = (name=&quot;Liming&quot;, age) =&gt; { }
</code></pre><h2 id="获取数组最后n个元素"><a href="#获取数组最后n个元素" class="headerlink" title="获取数组最后n个元素"></a>获取数组最后n个元素</h2><p>可以使用以下代码获取数组中最后n个元素</p>
<pre><code>var array = [1, 2, 3, 4, 5, 6];
console.log(array.slice(-1));  //[6]
console.log(array.slice(-2));  //[5, 6]
</code></pre><p>原理:Array.prototype.slice(begin,end)可以用来裁剪数组，第二个参数的默认值是数组的长度值。若值传入一个参数，则会返回从指定索引开始到数组结尾的所有值。<br>而slice()方法还可以接收负值，当传入负值时，会自动加上数组的长度值使其转换为正值，于是便得到了最后的n个值。</p>
<h2 id="合并大数组"><a href="#合并大数组" class="headerlink" title="合并大数组"></a>合并大数组</h2><p>常用的合并数组的方式是使用Array.concat()函数。该函数会创建一个新数组，将两个数组连接起来存储到新数组中，这会大量消耗内存。可以使用Array.push.apply(arr1, arr2)，它不会创建新数组，而是将第二个数组合并到第一个数组中，以减少内存的消耗。</p>
<pre><code>var a = [1,2];
var b = [3,4];
console.log(a.push.apply(a, b));      // [1,2,3,4]
//或者
Array.prototype.push.apply(a, b);      // a变成了[1,2,3,4]
console.log(a); //[1,2,3,4]
</code></pre><p>原理: Array.push()是在数组的末尾增加元素，但是如果使用a.push(b)会把整个数组b当作一个元素添加到数组a中。<br>而apply()方法，则允许将某个方法的参数以数组的形式传入，所以起到了将数组b中的元素追加到数组a中的效果。</p>
<h2 id="NodeList转换为数组"><a href="#NodeList转换为数组" class="headerlink" title="NodeList转换为数组"></a>NodeList转换为数组</h2><p>使用document.querySelectorAll(‘div’)返回的是NodeList对象，虽然它很像数组，但是并不能使用诸如sort()，filter()等方法。你可以将其转换为真正的数组。</p>
<pre><code>var eles = document.querySelectorAll(&apos;p&apos;);  //NodeList
var arrayElements = [].slice.call(eles);       //转化为数组
// 或者
var arrayElements = Array.prototype.slice.call(eles);
// 或者
var arrayElements = Array.from(eles); 
</code></pre><p>原理:</p>
<p>[].slice.call(eles):<br>首先创建了一个空数组[]，然后调用他的slice()方法，但是在slice()方法的执行中，把this对象指向了eles,所以会对eles进行裁减，由于对slice()方法没有传入参数，所以相当于slice(0,eles.length),会按照元长度返回一个数组。</p>
<p>Array.prototype.slice.call(eles): 原理与上面相似，只不过这次没有创建空数组，而是直接使用了原型中的方法 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/03/浅谈-instanceof-和-typeof-的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/03/浅谈-instanceof-和-typeof-的实现原理/" itemprop="url">浅谈 instanceof 和 typeof 的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-03T13:17:32+08:00">
                2015-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="typeof-实现原理"><a href="#typeof-实现原理" class="headerlink" title="typeof 实现原理"></a>typeof 实现原理</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number</code>, <code>string</code>, <code>object</code>, <code>boolean</code>, <code>function</code>, <code>undefined</code>,<code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code> 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如👉</p>
<pre><code>let s =newString(&apos;abc&apos;);
typeof s ===&apos;object&apos;// true
s instanceofString// true
</code></pre><p>要想判断一个数据具体是哪一种 object 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p>
<p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p>
<p>其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">000：对象</span><br><span class="line"></span><br><span class="line">010：浮点数</span><br><span class="line"></span><br><span class="line">100：字符串</span><br><span class="line"></span><br><span class="line">110：布尔</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1：整数</li>
</ul>
<p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p>
<p><code>null</code>：所有机器码均为0</p>
<p><code>undefined</code>：用 −2^30 整数来表示</p>
<p>所以，<code>typeof</code> 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为0，因此直接被当做了对象来看待。</p>
<p>然而用 <code>instanceof</code> 来判断的话👉</p>
<pre><code>nullinstanceofnull// TypeError: Right-hand side of &apos;instanceof&apos; is not an object
</code></pre><p><code>null</code> 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。</p>
<p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括<code>symbol</code>），避免对 null 的判断。</p>
<p>还有一个不错的判断类型的方法，就是<strong><font color="#dd0000">Object.prototype.toString</font></strong>，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p>
<pre><code>Object.prototype.toString.call(1)// &quot;[object Number]&quot;
Object.prototype.toString.call(&apos;hi&apos;)// &quot;[object String]&quot;
Object.prototype.toString.call({a:&apos;hi&apos;})// &quot;[object Object]&quot;
Object.prototype.toString.call([1,&apos;a&apos;])// &quot;[object Array]&quot;
Object.prototype.toString.call(true)// &quot;[object Boolean]&quot;
Object.prototype.toString.call(()=&gt;{})// &quot;[object Function]&quot;
Object.prototype.toString.call(null)// &quot;[object Null]&quot;
Object.prototype.toString.call(undefined)// &quot;[object Undefined]&quot;
Object.prototype.toString.call(Symbol(1))// &quot;[object Symbol]&quot;
</code></pre><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 <code>instanceof</code> 来判断对象的具体类型，其实 <code>instanceof</code> 主要的作用就是判断一个实例是否属于某种类型</p>
<pre><code>let person =function(){
}
let nicole =new person()
nicole instanceof person // true
</code></pre><p>当然，<code>instanceof</code> 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p>
<pre><code>let person =function(){
}
let programmer =function(){
}
programmer.prototype =new person()
let nicole =new programmer()
nicole instanceof person // true
nicole instanceof programmer // true
</code></pre><p>这是 <code>instanceof</code> 的用法，但是 <code>instanceof</code> 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p>
<pre><code>function new_instance_of(leftVaule, rightVaule){
    let rightProto = rightVaule.prototype;// 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__;// 取左表达式的__proto__值
    while(true){
        if(leftVaule ===null){
            returnfalse;    
        }
        if(leftVaule === rightProto){
            returntrue;    
        }
        leftVaule = leftVaule.__proto__ 
    }
}
</code></pre><p><font color="#dd0000">其实 <code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。<br></font><br><br>看几个很有趣的例子</p>
<pre><code>functionFoo(){
}
Object instanceof Object// true
Function instanceof Function// true
Function instanceof Object// true
Foo instanceof Foo// false
Foo instanceof Object// true
Foo instanceof Function// true
</code></pre><p>要想全部理解 <code>instanceof</code> 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。</p>
<p>关于原型继承的原理，我简单用一张图来表示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/meG6Vo0MevjCzDE6dwt2qtltaDsSluC9M8KmmeZsLSJnFTgdTtcCRToR3zWJFYicViaUlvyAGdfwEzADj8Jk8kzQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""><br>我们知道每个 JavaScript 对象均有一个隐式的 <code>__proto__</code> 原型属性，而显式的原型属性是 <code>prototype</code>，只有 <code>Object.prototype.__proto__</code> 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 <code>instanceof</code> 使用的例子。</p>
<p><code>Object instanceof Object</code></p>
<p>由图可知，Object 的 <code>prototype</code> 属性是 <code>Object.prototype</code>, 而由于 Object 本身是一个函数，由 Function 所创建，所以 <code>Object.__proto__</code> 的值是 <code>Function.prototype</code>，而 <code>Function.prototype</code> 的 <code>__proto__</code> 属性是 <code>Object.prototype</code>，所以我们可以判断出，<code>Object instanceof Object</code> 的结果是 true 。用代码简单的表示一下</p>
<pre><code>leftValue =Object.__proto__ =Function.prototype;
rightValue =Object.prototype;
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true
</code></pre><p><code>Function instanceof Function</code> 和 <code>Function instanceof Object</code> 的运行过程与 <code>Object instanceof Object</code> 类似，故不再详说。</p>
<p><code>Foo instanceof Foo</code></p>
<p>Foo 函数的 <code>prototype</code> 属性是 <code>Foo.prototype</code>，而 Foo 的 <code>__proto__</code> 属性是 <code>Function.prototype</code>，由图可知，Foo 的原型链上并没有 <code>Foo.prototype</code> ，因此 <code>Foo instanceof Foo</code> 也就返回 false 。</p>
<p>我们用代码简单的表示一下</p>
<pre><code>leftValue =Foo, rightValue =Foo
leftValue =Foo.__proto =Function.prototype
rightValue =Foo.prototype
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue != rightValue
leftValue =Object.prototype =null
// 第三次判断
leftValue ===null
// 返回 false
</code></pre><p><code>Foo instanceof Object</code></p>
<pre><code>leftValue =Foo, rightValue =Object
leftValue =Foo.__proto__ =Function.prototype
rightValue =Object.prototype
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true 
</code></pre><p><code>Foo instanceof Function</code></p>
<pre><code>leftValue =Foo, rightValue =Function
leftValue =Foo.__proto__ =Function.prototype
rightValue =Function.prototype
// 第一次判断
leftValue === rightValue
// 返回 true 
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 <code>null</code> 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/29/浅说-XSS-和-CSRF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/29/浅说-XSS-和-CSRF/" itemprop="url">浅说 XSS 和 CSRF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-29T12:06:38+08:00">
                2015-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Web 安全领域中，XSS 和 CSRF 是最常见的攻击方式。本文将会简单介绍 XSS 和 CSRF 的攻防问题。</p>
<blockquote>
<p>声明：本文的示例仅用于演示相关的攻击原理</p>
</blockquote>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。</p>
<p>XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p>
<p>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。</p>
<p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p>
<h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。</p>
<p>看一个示例。我先准备一个如下的静态页：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720000-30a9b93a-8752-11e8-879b-edd8519f4e3e.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720000-30a9b93a-8752-11e8-879b-edd8519f4e3e.png" alt="反射型xss1"></a></p>
<p>恶意链接的地址指向了 <code>localhost:8001/?q=111&amp;p=222</code>。然后，我再启一个简单的 Node 服务处理恶意链接的请求：</p>
<pre><code>consthttp=require(&apos;http&apos;);
functionhandleReequest(req, res) {
    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);
    res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;});
    res.write(&apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;);
    res.end();
}

constserver=newhttp.Server();
server.listen(8001, &apos;127.0.0.1&apos;);
server.on(&apos;request&apos;, handleReequest);
</code></pre><p>当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720046-ee5a3f40-8752-11e8-8cc5-8b464414864a.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720046-ee5a3f40-8752-11e8-8cc5-8b464414864a.png" alt="执行脚本"></a></p>
<p>这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。</p>
<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。</p>
<p>比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</p>
<p>举一个示例。</p>
<p>先准备一个输入页面：</p>
<pre><code>&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;
&lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt;   

&lt;script&gt;
    const input = document.getElementById(&apos;input&apos;);
    const btn = document.getElementById(&apos;btn&apos;);

    let val;

    input.addEventListener(&apos;change&apos;, (e) =&gt; {
        val = e.target.value;
    }, false);

    btn.addEventListener(&apos;click&apos;, (e) =&gt; {
        fetch(&apos;http://localhost:8001/save&apos;, {
            method: &apos;POST&apos;,
            body: val
        });
    }, false);
&lt;/script&gt;     
</code></pre><p>启动一个 Node 服务监听 <code>save</code> 请求。为了简化，用一个变量来保存用户的输入：</p>
<pre><code>consthttp=require(&apos;http&apos;);

let userInput =&apos;&apos;;

functionhandleReequest(req, res) {
    constmethod=req.method;
    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);
    res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type&apos;)

    if (method ===&apos;POST&apos;&amp;&amp;req.url===&apos;/save&apos;) {
        let body =&apos;&apos;;
        req.on(&apos;data&apos;, chunk=&gt; {
            body += chunk;
        });

        req.on(&apos;end&apos;, () =&gt; {
            if (body) {
                userInput = body;
            }
            res.end();
        });
    } else {
        res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;});
        res.write(userInput);
        res.end();
    }
}

constserver=newhttp.Server();
server.listen(8001, &apos;127.0.0.1&apos;);

server.on(&apos;request&apos;, handleReequest);
</code></pre><p>当用户点击提交按钮将输入信息提交到服务端时，服务端通过 <code>userInput</code> 变量保存了输入内容。当用户通过 <code>http://localhost:8001/${id}</code> 访问时，服务端会返回与 <code>id</code> 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720476-eb71a5c8-8759-11e8-8763-eb08b3480201.gif" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720476-eb71a5c8-8759-11e8-8763-eb08b3480201.gif" alt="存储型xss"></a></p>
<h4 id="基于DOM"><a href="#基于DOM" class="headerlink" title="基于DOM"></a>基于DOM</h4><p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p>
<p>看如下代码：</p>
<pre><code>&lt;h2&gt;XSS: &lt;/h2&gt;
&lt;inputtype=&quot;text&quot;id=&quot;input&quot;&gt;
&lt;buttonid=&quot;btn&quot;&gt;Submit&lt;/button&gt;
&lt;divid=&quot;div&quot;&gt;&lt;/div&gt;
&lt;script&gt;constinput=document.getElementById(&apos;input&apos;);constbtn=document.getElementById(&apos;btn&apos;);constdiv=document.getElementById(&apos;div&apos;);let val;input.addEventListener(&apos;change&apos;, (e) =&gt; {        val =e.target.value;    }, false);btn.addEventListener(&apos;click&apos;, () =&gt; {div.innerHTML=`&lt;ahref=${val}&gt;testLink&lt;/a&gt;`    }, false);&lt;/script&gt;
</code></pre><p>点击 <code>Submit</code> 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：</p>
<pre><code>&apos;&apos; onclick=alert(/xss/)
</code></pre><p>用户提交之后，页面代码就变成了：</p>
<pre><code>&lt;ahrefonlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;
</code></pre><p>此时，用户点击生成的链接，就会执行对应的脚本：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42721109-cb7ce572-8766-11e8-96d9-9ada8a787827.gif" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42721109-cb7ce572-8766-11e8-96d9-9ada8a787827.gif" alt="dom-xss"></a></p>
<h3 id="XSS-攻击的防范"><a href="#XSS-攻击的防范" class="headerlink" title="XSS 攻击的防范"></a>XSS 攻击的防范</h3><p>现在主流的浏览器内置了防范 XSS 的措施，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">CSP</a>。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。</p>
<h4 id="HttpOnly-防止劫取-Cookie"><a href="#HttpOnly-防止劫取-Cookie" class="headerlink" title="HttpOnly 防止劫取 Cookie"></a>HttpOnly 防止劫取 Cookie</h4><p>HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。</p>
<p>上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>
<h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p><strong>不要相信用户的任何输入。</strong> 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</p>
<p>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 <code>&lt;</code>，<code>&gt;</code> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。</p>
<p>而在一些前端框架中，都会有一份 <code>decodingMap</code>， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <code>&lt;</code>，<code>&gt;</code>，<code>script</code>，防止 XSS 攻击：</p>
<pre><code>// vuejs 中的 decodingMap
// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  &apos;&amp;lt;&apos;: &apos;&lt;&apos;,
  &apos;&amp;gt;&apos;: &apos;&gt;&apos;,
  &apos;&amp;quot;&apos;: &apos;&quot;&apos;,
  &apos;&amp;amp;&apos;: &apos;&amp;&apos;,
  &apos;&amp;#10;&apos;: &apos;\n&apos;
}
</code></pre><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 <a href="https://github.com/punkave/sanitize-html" target="_blank" rel="noopener">sanitize-html</a> 对输出内容进行有规则的过滤之后再输出到页面中。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p>
<p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p>
<p>在举例子之前，先说说浏览器的 Cookie 策略。</p>
<h3 id="浏览器的-Cookie-策略"><a href="#浏览器的-Cookie-策略" class="headerlink" title="浏览器的 Cookie 策略"></a>浏览器的 Cookie 策略</h3><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
</ul>
<p>而浏览器所持有的 Cookie 分为两种：</p>
<ul>
<li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。</li>
<li><p>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p>
<p>  res.setHeader(‘Set-Cookie’, [‘mycookie=222’, ‘test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;’]);</p>
</li>
</ul>
<p>上述代码创建了两个 Cookie：<code>mycookie</code> 和 <code>test</code>，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 <code>Expires</code> 属性值会不一样：</p>
<p>Firefox：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png" alt="firefox cookie"></a></p>
<p>Chrome:</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png" alt="chrome cookie"></a></p>
<p>此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 <code>donmain</code> 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。</p>
<h3 id="通过-Cookie-进行-CSRF-攻击"><a href="#通过-Cookie-进行-CSRF-攻击" class="headerlink" title="通过 Cookie 进行 CSRF 攻击"></a>通过 Cookie 进行 CSRF 攻击</h3><p>假设有一个 bbs 站点：<code>http://www.c.com</code>，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：</p>
<pre><code>http://www.c.com:8002/content/delete/:id
</code></pre><p>如发起 <code>http://www.c.com:8002/content/delete/87343</code> 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：</p>
<pre><code>res.setHeader(&apos;Set-Cookie&apos;, [&apos;user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&apos;]);
</code></pre><p><a href="https://user-images.githubusercontent.com/7871813/42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png" alt="user"></a></p>
<p><code>user</code> 对应的值是用户 ID。然后构造一个页面 A：</p>
<pre><code>&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;
&lt;img src=&quot;http://www.c.com:8002/content/delete/87343&quot;&gt;
</code></pre><p>页面 A 使用了一个 <code>img</code> 标签，其地址指向了删除用户帖子的链接：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png" alt="A"></a></p>
<p>可以看到，当登录用户访问攻击者的网站时，会向 <code>www.c.com</code> 发起一个删除用户帖子的请求。此时若用户在切换到 <code>www.c.com</code> 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。</p>
<p>由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p>
<p>但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。</p>
<h3 id="CSRF-攻击的防范"><a href="#CSRF-攻击的防范" class="headerlink" title="CSRF 攻击的防范"></a>CSRF 攻击的防范</h3><p>当前，对 CSRF 攻击的防范措施主要有如下几种方式。</p>
<h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。</p>
<p>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</p>
<p>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p>
<h4 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。</p>
<p>比如，如果用户要删除自己的帖子，那么先要登录 <code>www.c.com</code>，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 <code>http://www.c.com</code>；当请求是从 <code>www.a.com</code> 发起时，Referer 的值是 <code>http://www.a.com</code> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 <code>www.c.com</code> 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</p>
<p>针对上文的例子，可以在服务端增加如下代码：</p>
<pre><code>if (req.headers.referer!==&apos;http://www.c.com:8002/&apos;) {
    res.write(&apos;csrf 攻击&apos;);
    return;
}
</code></pre><p><a href="https://user-images.githubusercontent.com/7871813/42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png" alt="referer check"></a></p>
<p>Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。</p>
<h4 id="添加-token-验证"><a href="#添加-token-验证" class="headerlink" title="添加 token 验证"></a>添加 token 验证</h4><p>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 XSS 和 CSRF 的攻击原理和防御措施。当然，在 Web 安全领域，除了这两种常见的攻击方式，也存在这 SQL 注入等其它攻击方式，这不在本文的讨论范围之内，如果你对其感兴趣，可以阅读<a href="https://zhuanlan.zhihu.com/p/23569276" target="_blank" rel="noopener">SQL注入技术专题</a>的专栏详细了解相关信息。最后，总结一下 XSS 攻击和 CSRF 攻击的常见防御措施：</p>
<ol>
<li>防御 XSS 攻击</li>
</ol>
<ul>
<li>HttpOnly 防止劫取 Cookie</li>
<li>用户的输入检查</li>
<li>服务端的输出检查</li>
</ul>
<ol start="2">
<li>防御 CSRF 攻击</li>
</ol>
<ul>
<li>验证码</li>
<li>Referer Check</li>
<li>Token 验证</li>
</ul>
<p>&lt;完&gt;</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">Cross-site scripting</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html" target="_blank" rel="noopener">CSRF 攻击的应对之道</a></li>
<li>《白帽子讲 Web 安全》</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/08/requestAnimationFrame/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/08/requestAnimationFrame/" itemprop="url">requestAnimationFrame</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-08T21:01:22+08:00">
                2015-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Web应用中，实现动画效果的方法比较多，JavaScript 中可以通过定时器 setTimeout 来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。除此之外，html5 还提供一个专门用于请求动画的 API，即  requestAnimationFrame（rAF），顾名思义就是 “请求动画帧”<strong>。 </strong>为了深入理解  rAF 背后的原理（后文的 rAF 均指的是 requestAnimationFrame），我们首先需要了解一下与之相关的几个概念：</p>
<h3 id="屏幕绘制频率"><a href="#屏幕绘制频率" class="headerlink" title="屏幕绘制频率"></a>屏幕绘制频率</h3><p>即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是60Hz， 可以在桌面上 右键 &gt; 屏幕分辨率 &gt; 高级设置 &gt; 监视器 中查看和设置。这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响，原则上设置成让眼睛看着舒适的值都行。</p>
<p>市面上常见的显示器有两种，即 <strong>CRT </strong>和 <strong>LCD</strong>， CRT 就是传统显示器，LCD 就是我们常说的液晶显示器。</p>
<p>CRT 是一种使用阴极射线管的显示器，屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。<strong>电子束每秒击打荧光粉的次数就是屏幕绘制频率。</strong></p>
<p>而对于 LCD 来说，则不存在绘制频率的问题，因为 LCD 中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以 LCD 不会有电子束击打荧光粉而引起的闪烁现象。</p>
<p>因此，<strong>当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像</strong>。为什么你感觉不到这个变化？ 那是因为人的眼睛有<strong>视觉停留效应</strong>，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</p>
<h3 id="CSS-动画原理"><a href="#CSS-动画原理" class="headerlink" title="CSS 动画原理"></a>CSS 动画原理</h3><p>根据上面的原理我们知道，你眼前所看到图像正在以每秒 60 次的频率绘制，由于频率很高，所以你感觉不到它在绘制。而 <strong>动画本质就是要让人眼看到图像被绘制而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。</strong> 那怎么样才能做到这种效果呢？ </p>
<p>60Hz 的屏幕每 16.7ms 绘制一次，如果在屏幕每次绘制前，将元素的位置向左移动一个像素，即1px，这样一来，屏幕每次绘制出来的图像位置都比前一个要差1px，你就会看到图像在移动；而由于人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，这样你所看到的效果就是，图像在流畅的移动。这就是视觉效果上形成的动画。 </p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h3><p>理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：</p>
<ul>
<li>setTimeout 的执行时间并不是确定的。在JavaScript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 <strong>setTimeout 的实际执行时机一般要比其设定的时间晚一些。</strong></li>
<li>刷新频率受 <strong>屏幕分辨率 </strong>和 <strong>屏幕尺寸 </strong>的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li>
</ul>
<p>以上两种情况都会导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起<strong>丢帧</strong>现象。 那为什么步调不一致就会引起丢帧呢？ </p>
<p>首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：</p>
<ul>
<li>第    0  ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；</li>
<li>第   10 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；</li>
<li>第 16.7 ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；</li>
<li>第   20 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;</li>
<li>第   30 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;</li>
<li>第33.4 ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；</li>
<li>…</li>
</ul>
<p>从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。</p>
<h3 id="rAF"><a href="#rAF" class="headerlink" title="rAF"></a>rAF</h3><p>与 setTimeout 相比，rAF 最大的优势是 <strong>由系统来决定回调函数的执行时机。</strong>具体一点讲就是，<strong>系统每次绘制之前会主动调用 rAF 中的回调函数</strong>，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，rAF 的执行步伐跟着系统的绘制频率走。<strong>它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次</strong>，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p>
<p>这个API的调用很简单，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var progress = 0;</span><br><span class="line">//回调函数</span><br><span class="line">function render() &#123;</span><br><span class="line">    progress += 1; //修改图像的位置</span><br><span class="line"> </span><br><span class="line">    if (progress &lt; 100) &#123;</span><br><span class="line">           //在动画没有结束前，递归渲染</span><br><span class="line">           window.requestAnimationFrame(render);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//第一帧渲染</span><br><span class="line">window.requestAnimationFrame(render);</span><br></pre></td></tr></table></figure></p>
<p>除此之外，rAF 还有以下两个优势：</p>
<blockquote>
<p><strong>CPU节能</strong>：使用 setTimeout 实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。</p>
</blockquote>
<blockquote>
<p><strong>函数节流</strong>：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。</p>
</blockquote>
<h3 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h3><p>由于 rAF 目前还存在兼容性问题，而且不同的浏览器还需要带不同的前缀。因此需要通过优雅降级的方式对 rAF 进行封装，优先使用高级特性，然后再根据不同浏览器的情况进行回退，直止只能使用 setTimeout 的情况，因此可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.requestAnimFrame = (function()&#123;</span><br><span class="line">  return  window.requestAnimationFrame       ||</span><br><span class="line">          window.webkitRequestAnimationFrame ||</span><br><span class="line">          window.mozRequestAnimationFrame    ||</span><br><span class="line">          function( callback )&#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">          &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>但这种写法没有考虑 cancelAnimationFrame 的兼容性，并且不是所有的设备绘制时间间隔都是1000/60，下面的代码是比较全的一个 polyfill，详情介绍请参考： <a href="https://github.com/darius/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if (!Date.now)</span><br><span class="line">    Date.now = function() &#123; return new Date().getTime(); &#125;;</span><br><span class="line"> </span><br><span class="line">(function() &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">     </span><br><span class="line">    var vendors = [&apos;webkit&apos;, &apos;moz&apos;];</span><br><span class="line">    for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) &#123;</span><br><span class="line">        var vp = vendors[i];</span><br><span class="line">        window.requestAnimationFrame = window[vp+&apos;RequestAnimationFrame&apos;];</span><br><span class="line">        window.cancelAnimationFrame = (window[vp+&apos;CancelAnimationFrame&apos;]</span><br><span class="line">                                   || window[vp+&apos;CancelRequestAnimationFrame&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy</span><br><span class="line">        || !window.requestAnimationFrame || !window.cancelAnimationFrame) &#123;</span><br><span class="line">        var lastTime = 0;</span><br><span class="line">        window.requestAnimationFrame = function(callback) &#123;</span><br><span class="line">            var now = Date.now();</span><br><span class="line">            var nextTime = Math.max(lastTime + 16, now);</span><br><span class="line">            return setTimeout(function() &#123; callback(lastTime = nextTime); &#125;,</span><br><span class="line">                              nextTime - now);</span><br><span class="line">        &#125;;</span><br><span class="line">        window.cancelAnimationFrame = clearTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/07/你所知道或不知道的CSS-content属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/07/你所知道或不知道的CSS-content属性/" itemprop="url">你所知道或不知道的CSS content属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-07T20:17:55+08:00">
                2015-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>css博大精深，很多属性，往往都是看似熟悉，但是似乎又不能将其特性和用法完整地说出来。</p>
<p>content属性，的确是很眼熟，也许很多童鞋和我一样，和它初次见面，是在清除浮动的时候：</p>
<pre><code>.clearfix:after{
    content: &quot;.&quot;;
    display: block;
    height: 0;
    clear: both;
    visibility: hidden
}
</code></pre><p>如上所示，content 属性与 :before 及 :after 伪元素配合使用，并可以接受一个字符串作为值。</p>
<p>然而，除了字符串之外，还能接受什么样的值呢？</p>
<h2 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h2><blockquote>
<p>content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容。</p>
<p>该属性用于定义元素之前或之后放置的生成内容。默认是行内内容，不过可以用属性 display 控制。</p>
</blockquote>
<h2 id="可能的值"><a href="#可能的值" class="headerlink" title="可能的值"></a>可能的值</h2><p>none、normal、inherit、string、url()、attr()、[no-]open-quote、[no-]close-quote、counter[s]</p>
<p>其中none、normal、inherit这三个和大多数属性类似，故不做介绍。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是常见的，上面清除浮动的例子，就是其中之一。</p>
<h3 id="url"><a href="#url" class="headerlink" title="url()"></a>url()</h3><p>url的用法，和background属性有点类似，可以接受一个图片url。不一样的是，content属性无法控制图片的大小。</p>
<pre><code>&lt;div class=&quot;logo&quot;&gt;Google&lt;/div&gt;

.logo:before{
    content: url(https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png);
}
</code></pre><p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/1.jpg" alt=""></p>
<h3 id="attr"><a href="#attr" class="headerlink" title="attr"></a>attr</h3><p>attr，顾名思义，就是将content内容设置为对应元素的某一属性。</p>
<pre><code>&lt;p&gt;
    &lt;span data-text=&apos;半&apos;&gt;半&lt;/span&gt;
    &lt;span data-text=&apos;边&apos;&gt;边&lt;/span&gt;
    &lt;span data-text=&apos;效&apos;&gt;效&lt;/span&gt;
    &lt;span data-text=&apos;果&apos;&gt;果&lt;/span&gt;
&lt;/p&gt;

span{
    font-size: 100px;
    font-weight: bold;
    position: relative;
    color: #000;
}
span:before{
    content: attr(data-text);
    color: #F00;
    position: absolute;
    left: 0;
    top: 0;
    width: 50%;
    overflow: hidden;
}
</code></pre><p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/2.png" alt=""></p>
<h3 id="quote-·-引号"><a href="#quote-·-引号" class="headerlink" title="quote · 引号"></a>quote · 引号</h3><p>[no-]open-quote、[no-]close-quote，这四个值，常用于给元素前后加上引号，配合quotes 属性一起使用。</p>
<pre><code>&lt;p&gt;鲁迅曾经说过: &lt;span&gt;能用CSS解决的问题就不要使用JS。&lt;span&gt;呵呵，谁说的？&lt;span class=&quot;no-quote&quot;&gt;呵呵，谁说的？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

span {
    quotes: &apos;“&apos;&apos;”&apos;&apos;‘&apos;&apos;’&apos;&apos;&quot;&apos;&apos;&quot;&apos;;
}
span:before { 
    content: open-quote;
}
span:after {
    content: close-quote;
}
.no-quote:after{
    content: no-close-quote;
}
</code></pre><p>其中，quotes属性定义要使用的引号。两两一组，前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。如此类推。</p>
<p>需要注意的是，只有当伪元素:before设置content的值为open-quote才会有效果。</p>
<p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/3.png" alt=""></p>
<h3 id="counter-s-·-计数器"><a href="#counter-s-·-计数器" class="headerlink" title="counter[s] · 计数器"></a>counter[s] · 计数器</h3><p>这是一个很强大的东西，不妨先来体验一下其强大的力量，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;strong&gt;请选择你所使用的技术：&lt;/strong&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item1&quot;&gt;&lt;label for=&quot;item1&quot;&gt;PHP&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item2&quot;&gt;&lt;label for=&quot;item2&quot;&gt;Javascript&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item3&quot;&gt;&lt;label for=&quot;item3&quot;&gt;Java&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item4&quot;&gt;&lt;label for=&quot;item4&quot;&gt;HTML&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item5&quot;&gt;&lt;label for=&quot;item5&quot;&gt;CSS&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item6&quot;&gt;&lt;label for=&quot;item6&quot;&gt;nodejs&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item7&quot;&gt;&lt;label for=&quot;item7&quot;&gt;go&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">总共选择了 &lt;strong class=&quot;total&quot;&gt;&lt;/strong&gt; 项！</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ol&#123;</span><br><span class="line">	counter-reset: n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input:checked &#123;</span><br><span class="line">	counter-increment: n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.total:after &#123;</span><br><span class="line">	content: counter(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/4.png" alt=""><br>与其搭配使用的，还有counter-reset、counter-increment两个属性。</p>
<h4 id="counter-reset"><a href="#counter-reset" class="headerlink" title="counter-reset"></a>counter-reset</h4><p>用来标识计数器的作用域，值包括两部分：第一部分为计数器的名字；第二部分为计数器的起始值，默认为0。此外，counter-reset还可以同时声明多个计数器</p>
<pre><code>counter-reset: n 0
counter-reset: n 2 
counter-reset: n 0 m 0 p 0
</code></pre><h4 id="counter-increment"><a href="#counter-increment" class="headerlink" title="counter-increment"></a>counter-increment</h4><p>用来表明计数器实际用到的范围，值包括两部分：第一部分为计数器的名字；第二部分为计数器的递增的值，默认为1。如：</p>
<pre><code>counter-increment: n 2
counter-increment: n -1 /*递减*/
</code></pre><p>那counter和counters有什么不一样呢？</p>
<h4 id="counter"><a href="#counter" class="headerlink" title="counter()"></a>counter()</h4><p>counter方法可以接收两个参数。第一个是计数器的名字，必填；第二个是计数器的样式，也就是list-style-type，其支持的关键字值，就是list-style-type支持的那些值，比如disc | circle | square之类等等。</p>
<pre><code>content: counter(n)

content: counter(m, circle)
</code></pre><h4 id="counters"><a href="#counters" class="headerlink" title="counters()"></a>counters()</h4><p>counters方法主要用于嵌套计数，可以接收三个参数。第一个是计数器的名字，必填；第二个是字符串，用于嵌套计数的分隔符，如1.1中的“.”；第三个参数是计数器的样式，与counter一样。其中，前两个参数为必填</p>
<pre><code>content: counters(n, &apos;-&apos;);
</code></pre><p>说了这么多，还是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;li&gt;none&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;normal&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;inherit&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;string&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;url&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;attr&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;quote</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li&gt;open-quote&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;close-quote&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;no-open-quote&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;no-close-quote&lt;/li&gt;</span><br><span class="line">		&lt;/ul&gt;</span><br><span class="line">	&lt;/li&gt;		</span><br><span class="line">	&lt;li&gt;counter[s]</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li&gt;counter&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;counters&lt;/li&gt;</span><br><span class="line">		&lt;/ul&gt;</span><br><span class="line">	&lt;/li&gt;	</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">   counter-reset: n;</span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">   list-style-type: none;</span><br><span class="line">	counter-increment: n;</span><br><span class="line">&#125;</span><br><span class="line">li:before&#123;</span><br><span class="line">	content: counters(n, &apos;-&apos;) &apos;.&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/5.jpg" alt=""></p>
<p>实在不得不感叹css的博大精深！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/26/Ajax与Comet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/26/Ajax与Comet/" itemprop="url">Ajax与Comet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-26T20:19:20+08:00">
                2015-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>下述内存主要讲述了《JavaScript高级程序设计（第3版）》第21章关于“Ajax与Comet”。</p>
</blockquote>
<p><strong>Ajax（Asynchronous JavaScript + XML的简写）</strong>可以向服务器请求数据而无需卸载（刷新）页面，带来更好的用户体验。<br><strong>Ajax技术的核心是XMLHttpRequest对象（简称XHR）。</strong></p>
<h3 id="一、XMLHttpRequest对象"><a href="#一、XMLHttpRequest对象" class="headerlink" title="一、XMLHttpRequest对象"></a>一、XMLHttpRequest对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 兼容IE早期版本 */</span><br><span class="line">function createXHR()&#123;</span><br><span class="line">    if (typeof XMLHttpRequest != &quot;undefined&quot;)&#123;</span><br><span class="line">        return new XMLHttpRequest();</span><br><span class="line">    &#125; else if (typeof ActiveXObject != &quot;undefined&quot;)&#123;    // 适用于IE7之前的版本</span><br><span class="line">        if (typeof arguments.callee.activeXString != &quot;string&quot;)&#123;</span><br><span class="line">            var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;,</span><br><span class="line">                            &quot;MSXML2.XMLHttp&quot;],</span><br><span class="line">                i, len;</span><br><span class="line"></span><br><span class="line">            for (i=0,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    new ActiveXObject(versions[i]);</span><br><span class="line">                    arguments.callee.activeXString = versions[i];</span><br><span class="line">                    break;</span><br><span class="line">                &#125; catch (ex)&#123;</span><br><span class="line">                    //skip</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ActiveXObject(arguments.callee.activeXString);</span><br><span class="line">    &#125; else &#123;  // XHR对象和ActiveX对象都不存在，则抛出错误 </span><br><span class="line">        throw new Error(&quot;No XHR object available.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-XHR的用法"><a href="#1-XHR的用法" class="headerlink" title="1. XHR的用法"></a>1. XHR的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;请求的类型get|post等&quot;, &quot;请求的URL&quot;, &quot;是否异步发送请求&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>（1）URL相对于执行代码的当前页面（当然也可以使用绝对路径）<br>（2）open()方法并不会真正发送请求，而只是启动一个请求以备发送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(&quot;请求主体发送的数据&quot;);</span><br></pre></td></tr></table></figure></p>
<p><strong>说明：</strong><br>（1）如果不需要通过请求主体发送数据（比如get请求），则必须传入null，因为这个参数对有些浏览器来说是必需的<br>（2）调用send()之后，请求就会被分派到服务器</p>
<p><strong>补充</strong>：xhr.open()方法为“false”，即同步请求，JavaScript代码会等到服务器响应后再继续执行；否则，继续执行后续代码。</p>
<p>在收到服务器响应后，相应的数据会自动填充XHR对象的属性。</p>
<ul>
<li>responseText：作为响应主体被返回的文本</li>
<li>responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM文档</li>
<li>status：响应的HTTP状态</li>
<li>statusText：HTTP状态的说明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 为确保接收到适当的响应 200:成功；304:资源未被修改</span><br><span class="line">if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>说明</strong>：<br>（1）有的浏览器会错误的报告成功状态码为204<br>（2）无论内容类型是什么，响应主体的内容都会保存到responseText属性中；而对于XML数据而言，responseXML同时也将被赋值，否则其值为null</p>
<p><strong>对于异步请求，可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段</strong></p>
<ul>
<li>0：未初始化。尚未调用open()方法</li>
<li>1：启动。已经调用open()方法，但尚未调用send()方法</li>
<li>2：发送。已经调用send()方法，但尚未接收到响应</li>
<li>3：接收。已经接收到部分响应数据</li>
<li>4：完成。已经接收全部响应数据，而且已经可以在客户端使用了。</li>
</ul>
<p>readyState属性的值发生变化，都会触发<strong>readystatechange</strong>事件。可以利用这个事件来检测每次状态变化后<strong>readyState</strong>的值。不过，<em>必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。</em></p>
<pre><code>var xhr = createXHR();        
xhr.onreadystatechange = function(event){
    // 不要使用this，作用域会产生问题，在部分浏览器中会执行失败
    if (xhr.readyState == 4){
        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
            console.log(xhr.responseText);
        } else {
            console.log(&quot;Request was unsuccessful: &quot; + xhr.status);
        }
    }
};
xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);
xhr.send(null);
</code></pre><p>在接收到响应数据之前可以调用abort()方法来取消异步请求：</p>
<pre><code>xhr.abort();
xhr =null; // 解除引用，释放内存
</code></pre><h4 id="2-HTTP头部信息"><a href="#2-HTTP头部信息" class="headerlink" title="2. HTTP头部信息"></a>2. HTTP头部信息</h4><p><strong>setRequestHeader()</strong>：设置自定义的请求头信息。必须在调用open()方法之后且调用send()方法之前调用。<br><strong>getResponseHeader() getAllResponseHeaders()</strong>：可以获取指定（全部）响应头信息。</p>
<pre><code>var xhr = createXHR();        
xhr.onreadystatechange = function(){};
xhr.open(&quot;get&quot;, &quot;example.php&quot;, true);
xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;);
xhr.send(null);
</code></pre><h4 id="3-GET请求"><a href="#3-GET请求" class="headerlink" title="3. GET请求"></a>3. GET请求</h4><p><strong>open()</strong>方法的URL尾部的查询字符串必须经过正确的编码</p>
<pre><code>functionaddURLParam(url, name, value) {
    url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;);
    url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);
    return url;
}

var url = &quot;http://test.com&quot;;
url = addURLParam(url, &quot;uid&quot; , 5);
url = addURLParam(url, &quot;siteid&quot;, 123);  // &quot;http://test.com?uid=5&amp;siteid=123&quot;
xhr.open(&quot;get&quot;, url, true);
xhr.send(null);
</code></pre><h4 id="4-POST请求"><a href="#4-POST请求" class="headerlink" title="4. POST请求"></a>4. POST请求</h4><p>POST请求将数据作为请求的主体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/* 序列化表单 */</span><br><span class="line">function serialize(form)&#123;        </span><br><span class="line">    var parts = new Array();</span><br><span class="line">    var field = null;</span><br><span class="line"></span><br><span class="line">    for (var i=0, len=form.elements.length; i &lt; len; i++)&#123;</span><br><span class="line">        field = form.elements[i];</span><br><span class="line"></span><br><span class="line">        switch(field.type)&#123;</span><br><span class="line">            case &quot;select-one&quot;:</span><br><span class="line">            case &quot;select-multiple&quot;:</span><br><span class="line">                for (var j=0, optLen = field.options.length; j &lt; optLen; j++)&#123;</span><br><span class="line">                    var option = field.options[j];</span><br><span class="line">                    if (option.selected)&#123;</span><br><span class="line">                        var optValue = &quot;&quot;;</span><br><span class="line">                        if (option.hasAttribute)&#123;</span><br><span class="line">                            optValue = (option.hasAttribute(&quot;value&quot;) ? </span><br><span class="line">                                        option.value : option.text);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            optValue = (option.attributes[&quot;value&quot;].specified ? </span><br><span class="line">                                        option.value : option.text);</span><br><span class="line">                        &#125;</span><br><span class="line">                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; + </span><br><span class="line">                                   encodeURIComponent(optValue));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case undefined:     //fieldset</span><br><span class="line">            case &quot;file&quot;:        //file input</span><br><span class="line">            case &quot;submit&quot;:      //submit button</span><br><span class="line">            case &quot;reset&quot;:       //reset button</span><br><span class="line">            case &quot;button&quot;:      //custom button</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &quot;radio&quot;:       //radio button</span><br><span class="line">            case &quot;checkbox&quot;:    //checkbox</span><br><span class="line">                if (!field.checked)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                /* falls through */              </span><br><span class="line">            default:</span><br><span class="line">                parts.push(encodeURIComponent(field.name) + &quot;=&quot; + </span><br><span class="line">                    encodeURIComponent(field.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    return parts.join(&quot;&amp;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 发送请求 */</span><br><span class="line">function submitData()&#123;</span><br><span class="line">    var xhr = createXHR();        </span><br><span class="line">    xhr.onreadystatechange = function(event)&#123;</span><br><span class="line">        if (xhr.readyState == 4)&#123;</span><br><span class="line">            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">                alert(xhr.responseText);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);</span><br><span class="line">    // 表单提交的内容类型</span><br><span class="line">    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">    var form = document.getElementById(&quot;user-info&quot;);   </span><br><span class="line">    // 请求主体为数据         </span><br><span class="line">    xhr.send(serialize(form));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、XMLHttpRequest-2级"><a href="#二、XMLHttpRequest-2级" class="headerlink" title="二、XMLHttpRequest 2级"></a>二、XMLHttpRequest 2级</h3><p>XMLHttpRequest 1级只是把已有的XHR对象的实现细节描述了出来。而XMLHttpRequest 2级则进一步发展了XHR。并非所有浏览器都完整地实现了XMLHttpRequest 2级规范，但所有浏览器都实现了它规定的部分内容。</p>
<h4 id="1-FormData"><a href="#1-FormData" class="headerlink" title="1. FormData"></a>1. FormData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建FormData对象</span><br><span class="line">var data=new FormData();</span><br><span class="line">data.append(&quot;name&quot;, &quot;ligang&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 用表单元素填充</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);</span><br><span class="line">var form = document.getElementById(&quot;user-info&quot;);</span><br><span class="line">// 使用FormData的方便之处在于不必明确地在XHR对象上设置请求头。</span><br><span class="line">// xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.send(new FormData(form));</span><br></pre></td></tr></table></figure>
<h4 id="2-超时设定"><a href="#2-超时设定" class="headerlink" title="2. 超时设定"></a>2. 超时设定</h4><p>IE8为XHR对象添加了一个timeout属性，表示请求在等待响应多少毫秒后就终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);</span><br><span class="line">xhr.timeout = 60 * 1000;</span><br><span class="line">xhr.ontimeout = function()&#123;</span><br><span class="line">    alert(&quot;Request did not return in a second.&quot;);</span><br><span class="line">&#125;;        </span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></p>
<p>对于其他浏览器的兼容做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);</span><br><span class="line">xhr.onreadystatechange = function(event)&#123;if (xhr.readyState == 4)&#123;</span><br><span class="line">        // 清除定时器</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">            console.log(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置超时时间 1分钟</span><br><span class="line">var timeout = setTimeout(function() &#123;</span><br><span class="line">    xmlHttpRequest.abort();</span><br><span class="line">    xmlHttpRequest = null;</span><br><span class="line">&#125;, 60 * 1000);</span><br><span class="line">xmlHttpRequest.send(null);</span><br></pre></td></tr></table></figure></p>
<h4 id="3-overrideMimeType-方法"><a href="#3-overrideMimeType-方法" class="headerlink" title="3. overrideMimeType()方法"></a>3. overrideMimeType()方法</h4><p>重写XHR响应的MIME类型，<em>必须在send()方法之前</em>。</p>
<p>如果，服务器返回的MIME类型是text/plain，但数据中实际包含的是XML。根据MIME类型，responseXML属性中仍然是null。此时，通过<strong>overrideMimeType()</strong>方法，可以保证把响应当作XML而非纯文本来处理（即，responseXML中被赋值）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;text.php&quot;, true);</span><br><span class="line">xhr.overrideMimeType(&quot;text/xml&quot;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></p>
<h3 id="三、进度事件"><a href="#三、进度事件" class="headerlink" title="三、进度事件"></a>三、进度事件</h3><p>6个进度事件：</p>
<ul>
<li>loadstart：在接收到响应数据的第一个字节时触发。</li>
<li>progress：在接收响应期间持续不断地触发。</li>
<li>error：在请求发生错误时触发。</li>
<li>abort：在因为调用abort()方法而终止时触发。</li>
<li>load：在接收到完整的响应数据时触发。</li>
<li>loadend：在通信完成或者触发error、abort或load事件后触发。<br><img src="/2015/04/26/Ajax与Comet/20160419113844270.png" alt="图 进度事件"></li>
</ul>
<h4 id="1-load事件"><a href="#1-load事件" class="headerlink" title="1. load事件"></a>1. load事件</h4><p>可以代替readystatechagne事件。其处理程序会接收到一个event对象，其target属性指向XHR对象实例，因而可以访问到XHR对象的所有方法和属性。然而，并非所有浏览器都实现了事件对象。</p>
<h4 id="2-progress事件"><a href="#2-progress事件" class="headerlink" title="2. progress事件"></a>2. progress事件</h4><p>其处理程序会接收一个event对象，其target属性指向XHR对象实例，但包含着三个额外的属性</p>
<ul>
<li>lengthComputable：是一个表示进度信息是否可用的布尔值</li>
<li>position：表示已经接收的字节数</li>
<li>totalSize：根据content-length响应头确定的预期字节数<br><strong>注意</strong>：<em>其必须在调用open()方法之前添加</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();        </span><br><span class="line">xhr.onload = function(event)&#123;</span><br><span class="line">    // event.target存在兼容性问题，所以只能使用xhr</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) ||  xhr.status == 304)&#123;</span><br><span class="line">        console.log(xhr.responseText);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.onprogress = function(event)&#123;</span><br><span class="line">    var divStatus = document.getElementById(&quot;status&quot;);</span><br><span class="line">    if (event.lengthComputable)&#123;</span><br><span class="line">        divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize + &quot; bytes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="四、跨源资源共享"><a href="#四、跨源资源共享" class="headerlink" title="四、跨源资源共享"></a>四、跨源资源共享</h3><p><strong>CORS（Cross-Origin Resource Sharing）</strong>背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
<p>在发送请求时，给其附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。</p>
<pre><code>Origin: http://www.test.com
</code></pre><p>如果服务认为这个请求可以接受，在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发”*”）。</p>
<pre><code>Access-Control-Allow-Origin: http://www.test.com
</code></pre><p><strong>注意</strong>：请求和响应都不包含cookie信息。</p>
<h4 id="1-IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。"><a href="#1-IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。" class="headerlink" title="1. IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。"></a>1. IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。</h4><h4 id="2-其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open-方法传入绝对地址。支持同步请求。"><a href="#2-其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open-方法传入绝对地址。支持同步请求。" class="headerlink" title="2. 其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open()方法传入绝对地址。支持同步请求。"></a>2. 其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open()方法传入绝对地址。支持同步请求。</h4><p>跨域XHR对象的安全限制： </p>
<p>（1）不能使用setRequestHeader()设置自定义头部。 </p>
<p>（2）不能发送和接收cookie。 </p>
<p>（3）调用getAllResponseHeaders()方法总会返回空字符串。</p>
<p><strong>建议</strong>：访问本地资源，最好使用相对URL；访问远程资源，使用绝对URL。</p>
<h4 id="3-跨浏览器的CORS"><a href="#3-跨浏览器的CORS" class="headerlink" title="3. 跨浏览器的CORS"></a>3. 跨浏览器的CORS</h4><pre><code>functioncreateCORSRequest(method, url){var xhr = new XMLHttpRequest();
    if (&quot;withCredentials&quot;in xhr){    // 检测XHR是否支持CORS的简单方式，就是检测是否存在withCredentials属性
        xhr.open(method, url, true);
    } elseif (typeof XDomainRequest != &quot;undefined&quot;){    // IE XDR
        xhr = new XDomainRequest();
        xhr.open(method, url);
    } else {
        xhr = null;
    }
    return xhr;
}

var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/xdr.php&quot;);
if (request){
    request.onload = function(){//do something with request.responseText
    };
    request.send();
}
</code></pre><h3 id="五、其他跨域技术"><a href="#五、其他跨域技术" class="headerlink" title="五、其他跨域技术"></a>五、其他跨域技术</h3><p>利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求，其不需要修改服务器端代码。</p>
<h4 id="1-图像Ping"><a href="#1-图像Ping" class="headerlink" title="1. 图像Ping"></a>1. 图像Ping</h4><p><code>&lt;img&gt;</code>标签，可以从任何网页中加载图像，无需关注是否跨域。这也是广告跟踪浏览量的主要方式。 </p>
<p>图像Ping是与服务器进行简单、单向的跨域通信的一种方式。浏览器得不到任何具体的数据。但通过监听load和error事件，可以知道响应是什么时间接收到的。</p>
<pre><code>var img = new Image();
img.onload = img.error = function() {
    console.log(&quot;Done!&quot;);
};
img.src = &quot;http://www.test.com/getImage?id=1&quot;;
</code></pre><p><strong>缺点</strong>: </p>
<p>（1）只能发送Get请求 </p>
<p>（2）无法访问服务器的响应文本</p>
<h4 id="2-JSONP（JSON-with-padding）"><a href="#2-JSONP（JSON-with-padding）" class="headerlink" title="2. JSONP（JSON with padding）"></a>2. JSONP（JSON with padding）</h4><p>两部分组成：回调函数和数据。 </p>
<p>回调函数是当响应到来时应该在页面调用的函数。回到函数的名字一般是在请求中指定的。而数据是传入回调函数中的JSON数据。 </p>
<p>JSONP是通过动态<code>&lt;script&gt;</code>元素来使用的</p>
<pre><code>function handleResponse(response){
    alert(&quot;You&apos;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);
}

var script = document.createElement(&quot;script&quot;);
script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;
document.body.insertBefore(script, document.body.firstChild);
</code></pre><p><strong>优点</strong>：能够直接访问响应文本，支持在浏览器与服务器之间双向通信。<br><strong>缺点</strong>： </p>
<p>（1）JSONP是从其他域中加载代码执行，其安全性无法确保。 </p>
<p>（2）不能很容易的确定JSONP请求是否失败。</p>
<h4 id="3-Comet"><a href="#3-Comet" class="headerlink" title="3. Comet"></a>3. Comet</h4><p>更高级的Ajax技术，服务器向页面推送数据。 </p>
<p>Comet 本质上和 C/S 中的通信并不一样，它是通过长连接来模拟推送的。也就是说，在没有数据的时候，这个连接挂起，直到有数据来了（推送），服务器端返回响应，该连接结束，客户端的 JS 重新建立下一个等待连接。</p>
<p>这种方式并不像 C/S 通信建立长期使用的通道，只是长期“等待”而已，避免了在数据更新频率不大的情况下轮询的开销：试想如果五分钟才一次更新，那么轮询方式在此期间几秒钟就要发生一次请求&amp;响应，而这些请求响应都是没有价值的，因为它们并没有传输有用数据。Comet 避免的是这方面的浪费，不再有空请求，因为挂起的连接直到数据更新了才结束。</p>
<p>性能方面，对于数据量不大但需要实时更新的应用来说，Comet 能更有效利用连接，同时因为没有轮询的心跳频率，Comet 会比轮询更加实时——因为只消耗响应的网络传输时间。</p>
<p>但是 Comet 本身并不能在数据传输方面提供比轮询更高的效率，仅仅避免了轮询的空请求浪费。所以 Comet 和 web socket 之类的通讯方式差距还是有的。</p>
<p>大型网站的应用方面，知乎、QQ 邮箱都有用到 Comet，还有新浪微博的私信（聊天）。使用 Comet 主要需要是服务器端的支持，因为使用长连接，所以要有一定负载量一般得使用异步的网络框架，Python 的 tornado、gevent 和 JavaScript 的 node.js 都是此列。</p>
<p>两种实现Comet的方式：长轮询和流。<br><img src="/2015/04/26/Ajax与Comet/20160419114753780.png" alt="Ajax与Comet-Comet长轮询"></p>
<p>（1）长轮询：页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。【区别：短轮询，服务器立即发送响应，无论是否有效，而长轮询是等待发送响应。】</p>
<p>（2）HTTP流：生命周期内只使用一个HTTP连接。浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。</p>
<pre><code>/**
 * progress：接收数据时调用的函数
 * finished：关闭连接时调用的函数
 */
function createStreamingClient(url, progress, finished){
 var xhr = new XMLHttpRequest(),
        received = 0;

    xhr.open(&quot;get&quot;, url, true);
    xhr.onreadystatechange = function(){var result;
        if (xhr.readyState == 3){
            //get only the new data and adjust counter
            result = xhr.responseText.substring(received);
            received += result.length;

            //call the progress callback
            progress(result);
        } elseif (xhr.readyState == 4){
            finished(xhr.responseText);
        }
    };
    xhr.send(null);
    return xhr;
}

var client = createStreamingClient(&quot;streaming.php&quot;,function(data){alert(&quot;Received: &quot; + data);}, function(data){alert(&quot;Done!&quot;);});
</code></pre><p>服务器发送事件：SSE和事件流</p>
<h4 id="4-Web-Sockets"><a href="#4-Web-Sockets" class="headerlink" title="4. Web Sockets"></a>4. Web Sockets</h4><p>目标是在一个单独的持久连接上提供全双工、双向通信。 </p>
<p>优点：能够在客户端和服务器之间发送非常少量的数据，而不必担心HTTP那样字节级的开销。 </p>
<p>缺点：制定协议的时间比制定JavaScript API的时间还要长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 必须给WebSocket构造函数传入绝对URL</span><br><span class="line">var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);</span><br><span class="line">// 向服务器发送数据（只能发送纯文本，其他数据需要序列化）</span><br><span class="line">socket.send(&quot;Hello&quot;);</span><br><span class="line">// 接收服务器的响应数据</span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">    var data = event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其他事件：</p>
<ul>
<li>open：在成功建立连接时触发。</li>
<li>error：在发生错误时触发，连接不能持续。</li>
<li>close：在连接关闭时触发。</li>
</ul>
<p><strong>注意</strong>：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/02/十大经典排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/02/十大经典排序算法/" itemprop="url">十大经典排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-02T19:53:53+08:00">
                2015-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><p>十种常见排序算法可以分为两大类：</p>
<blockquote>
<p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。<br><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 </p>
</blockquote>
<p><img src="/2015/01/02/十大经典排序算法/849589-20180402132530342-980121409.png" alt=""></p>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20180402133438219-1946132192.png" alt=""></p>
<p><strong>相关概念</strong></p>
<blockquote>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。<br><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </p>
</blockquote>
<h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p>
<h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<p><strong>1.2 动图演示</strong></p>
<p><img src="/2015/01/02/十大经典排序算法/849589-20171015223238449-2146169197.gif" alt=""></p>
<h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015224719590-1433219824.gif" alt=""></p>
<h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数</span><br><span class="line">                minIndex = j;                 // 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h4><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015225645277-1151100000.gif" alt=""></p>
<h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var preIndex, current;</span><br><span class="line">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h4><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h3 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20180331170017421-364506073.gif" alt=""></p>
<h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = 1;</span><br><span class="line">    while (gap &lt; len / 3) &#123;          // 动态定义间隔序列</span><br><span class="line">        gap = gap * 3 + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123;</span><br><span class="line">        for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p>
<h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015230557043-37375010.gif" alt=""></p>
<h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(arr) &#123;  // 采用自上而下的递归方法</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    if (len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line"> </span><br><span class="line">    while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;</span><br><span class="line">        if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>
<h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015230936371-1413523412.gif" alt=""></p>
<h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != &apos;number&apos; ? 0 : left,</span><br><span class="line">        right = typeof right != &apos;number&apos; ? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-1);</span><br><span class="line">        quickSort(arr, partitionIndex+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function partition(arr, left ,right) &#123;     // 分区操作</span><br><span class="line">    var pivot = left,                      // 设定基准值（pivot）</span><br><span class="line">        index = pivot + 1;</span><br><span class="line">    for (var i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - 1);</span><br><span class="line">    return index-1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015231308699-356134237.gif" alt=""></p>
<h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"> </span><br><span class="line">function buildMaxHeap(arr) &#123;   // 建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function heapify(arr, i) &#123;     // 堆调整</span><br><span class="line">    var left = 2 * i + 1,</span><br><span class="line">        right = 2 * i + 2,</span><br><span class="line">        largest = i;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"> </span><br><span class="line">    for (var i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015231740840-6968181.gif" alt=""></p>
<h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket = new Array(maxValue + 1),</span><br><span class="line">        sortedIndex = 0;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + 1;</span><br><span class="line"> </span><br><span class="line">    for (var i = 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (var j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。 </li>
</ul>
<h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015232107090-1920702011.png" alt=""></p>
<h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length === 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  </span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = 0;</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p>
<h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015232453668-1397662527.gif" alt=""> </p>
<h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// LSD Radix Sort</span><br><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            if(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            if(counter[j]!=null) &#123;</span><br><span class="line">                while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">107</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">78</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


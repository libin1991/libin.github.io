<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/11/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/10/03/浅谈-instanceof-和-typeof-的实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/03/浅谈-instanceof-和-typeof-的实现原理/" itemprop="url">浅谈 instanceof 和 typeof 的实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-03T13:17:32+08:00">
                2015-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="typeof-实现原理"><a href="#typeof-实现原理" class="headerlink" title="typeof 实现原理"></a>typeof 实现原理</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number</code>, <code>string</code>, <code>object</code>, <code>boolean</code>, <code>function</code>, <code>undefined</code>,<code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code> 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如👉</p>
<pre><code>let s =newString(&apos;abc&apos;);
typeof s ===&apos;object&apos;// true
s instanceofString// true
</code></pre><p>要想判断一个数据具体是哪一种 object 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p>
<p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p>
<p>其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">000：对象</span><br><span class="line"></span><br><span class="line">010：浮点数</span><br><span class="line"></span><br><span class="line">100：字符串</span><br><span class="line"></span><br><span class="line">110：布尔</span><br></pre></td></tr></table></figure></p>
<ul>
<li>1：整数</li>
</ul>
<p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p>
<p><code>null</code>：所有机器码均为0</p>
<p><code>undefined</code>：用 −2^30 整数来表示</p>
<p>所以，<code>typeof</code> 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为0，因此直接被当做了对象来看待。</p>
<p>然而用 <code>instanceof</code> 来判断的话👉</p>
<pre><code>nullinstanceofnull// TypeError: Right-hand side of &apos;instanceof&apos; is not an object
</code></pre><p><code>null</code> 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。</p>
<p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括<code>symbol</code>），避免对 null 的判断。</p>
<p>还有一个不错的判断类型的方法，就是<strong><font color="#dd0000">Object.prototype.toString</font></strong>，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p>
<pre><code>Object.prototype.toString.call(1)// &quot;[object Number]&quot;
Object.prototype.toString.call(&apos;hi&apos;)// &quot;[object String]&quot;
Object.prototype.toString.call({a:&apos;hi&apos;})// &quot;[object Object]&quot;
Object.prototype.toString.call([1,&apos;a&apos;])// &quot;[object Array]&quot;
Object.prototype.toString.call(true)// &quot;[object Boolean]&quot;
Object.prototype.toString.call(()=&gt;{})// &quot;[object Function]&quot;
Object.prototype.toString.call(null)// &quot;[object Null]&quot;
Object.prototype.toString.call(undefined)// &quot;[object Undefined]&quot;
Object.prototype.toString.call(Symbol(1))// &quot;[object Symbol]&quot;
</code></pre><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 <code>instanceof</code> 来判断对象的具体类型，其实 <code>instanceof</code> 主要的作用就是判断一个实例是否属于某种类型</p>
<pre><code>let person =function(){
}
let nicole =new person()
nicole instanceof person // true
</code></pre><p>当然，<code>instanceof</code> 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p>
<pre><code>let person =function(){
}
let programmer =function(){
}
programmer.prototype =new person()
let nicole =new programmer()
nicole instanceof person // true
nicole instanceof programmer // true
</code></pre><p>这是 <code>instanceof</code> 的用法，但是 <code>instanceof</code> 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p>
<pre><code>function new_instance_of(leftVaule, rightVaule){
    let rightProto = rightVaule.prototype;// 取右表达式的 prototype 值
    leftVaule = leftVaule.__proto__;// 取左表达式的__proto__值
    while(true){
        if(leftVaule ===null){
            returnfalse;    
        }
        if(leftVaule === rightProto){
            returntrue;    
        }
        leftVaule = leftVaule.__proto__ 
    }
}
</code></pre><p><font color="#dd0000">其实 <code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。<br></font><br><br>看几个很有趣的例子</p>
<pre><code>functionFoo(){
}
Object instanceof Object// true
Function instanceof Function// true
Function instanceof Object// true
Foo instanceof Foo// false
Foo instanceof Object// true
Foo instanceof Function// true
</code></pre><p>要想全部理解 <code>instanceof</code> 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。</p>
<p>关于原型继承的原理，我简单用一张图来表示</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/meG6Vo0MevjCzDE6dwt2qtltaDsSluC9M8KmmeZsLSJnFTgdTtcCRToR3zWJFYicViaUlvyAGdfwEzADj8Jk8kzQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""><br>我们知道每个 JavaScript 对象均有一个隐式的 <code>__proto__</code> 原型属性，而显式的原型属性是 <code>prototype</code>，只有 <code>Object.prototype.__proto__</code> 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 <code>instanceof</code> 使用的例子。</p>
<p><code>Object instanceof Object</code></p>
<p>由图可知，Object 的 <code>prototype</code> 属性是 <code>Object.prototype</code>, 而由于 Object 本身是一个函数，由 Function 所创建，所以 <code>Object.__proto__</code> 的值是 <code>Function.prototype</code>，而 <code>Function.prototype</code> 的 <code>__proto__</code> 属性是 <code>Object.prototype</code>，所以我们可以判断出，<code>Object instanceof Object</code> 的结果是 true 。用代码简单的表示一下</p>
<pre><code>leftValue =Object.__proto__ =Function.prototype;
rightValue =Object.prototype;
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true
</code></pre><p><code>Function instanceof Function</code> 和 <code>Function instanceof Object</code> 的运行过程与 <code>Object instanceof Object</code> 类似，故不再详说。</p>
<p><code>Foo instanceof Foo</code></p>
<p>Foo 函数的 <code>prototype</code> 属性是 <code>Foo.prototype</code>，而 Foo 的 <code>__proto__</code> 属性是 <code>Function.prototype</code>，由图可知，Foo 的原型链上并没有 <code>Foo.prototype</code> ，因此 <code>Foo instanceof Foo</code> 也就返回 false 。</p>
<p>我们用代码简单的表示一下</p>
<pre><code>leftValue =Foo, rightValue =Foo
leftValue =Foo.__proto =Function.prototype
rightValue =Foo.prototype
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue != rightValue
leftValue =Object.prototype =null
// 第三次判断
leftValue ===null
// 返回 false
</code></pre><p><code>Foo instanceof Object</code></p>
<pre><code>leftValue =Foo, rightValue =Object
leftValue =Foo.__proto__ =Function.prototype
rightValue =Object.prototype
// 第一次判断
leftValue != rightValue
leftValue =Function.prototype.__proto__ =Object.prototype
// 第二次判断
leftValue === rightValue
// 返回 true 
</code></pre><p><code>Foo instanceof Function</code></p>
<pre><code>leftValue =Foo, rightValue =Function
leftValue =Foo.__proto__ =Function.prototype
rightValue =Function.prototype
// 第一次判断
leftValue === rightValue
// 返回 true 
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 <code>null</code> 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/29/浅说-XSS-和-CSRF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/29/浅说-XSS-和-CSRF/" itemprop="url">浅说 XSS 和 CSRF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-29T12:06:38+08:00">
                2015-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Web 安全领域中，XSS 和 CSRF 是最常见的攻击方式。本文将会简单介绍 XSS 和 CSRF 的攻防问题。</p>
<blockquote>
<p>声明：本文的示例仅用于演示相关的攻击原理</p>
</blockquote>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。</p>
<p>XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p>
<p>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。</p>
<p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p>
<h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。</p>
<p>看一个示例。我先准备一个如下的静态页：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720000-30a9b93a-8752-11e8-879b-edd8519f4e3e.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720000-30a9b93a-8752-11e8-879b-edd8519f4e3e.png" alt="反射型xss1"></a></p>
<p>恶意链接的地址指向了 <code>localhost:8001/?q=111&amp;p=222</code>。然后，我再启一个简单的 Node 服务处理恶意链接的请求：</p>
<pre><code>consthttp=require(&apos;http&apos;);
functionhandleReequest(req, res) {
    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);
    res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;});
    res.write(&apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;);
    res.end();
}

constserver=newhttp.Server();
server.listen(8001, &apos;127.0.0.1&apos;);
server.on(&apos;request&apos;, handleReequest);
</code></pre><p>当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720046-ee5a3f40-8752-11e8-8cc5-8b464414864a.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720046-ee5a3f40-8752-11e8-8cc5-8b464414864a.png" alt="执行脚本"></a></p>
<p>这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。</p>
<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。</p>
<p>比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</p>
<p>举一个示例。</p>
<p>先准备一个输入页面：</p>
<pre><code>&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;
&lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt;   

&lt;script&gt;
    const input = document.getElementById(&apos;input&apos;);
    const btn = document.getElementById(&apos;btn&apos;);

    let val;

    input.addEventListener(&apos;change&apos;, (e) =&gt; {
        val = e.target.value;
    }, false);

    btn.addEventListener(&apos;click&apos;, (e) =&gt; {
        fetch(&apos;http://localhost:8001/save&apos;, {
            method: &apos;POST&apos;,
            body: val
        });
    }, false);
&lt;/script&gt;     
</code></pre><p>启动一个 Node 服务监听 <code>save</code> 请求。为了简化，用一个变量来保存用户的输入：</p>
<pre><code>consthttp=require(&apos;http&apos;);

let userInput =&apos;&apos;;

functionhandleReequest(req, res) {
    constmethod=req.method;
    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);
    res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type&apos;)

    if (method ===&apos;POST&apos;&amp;&amp;req.url===&apos;/save&apos;) {
        let body =&apos;&apos;;
        req.on(&apos;data&apos;, chunk=&gt; {
            body += chunk;
        });

        req.on(&apos;end&apos;, () =&gt; {
            if (body) {
                userInput = body;
            }
            res.end();
        });
    } else {
        res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;});
        res.write(userInput);
        res.end();
    }
}

constserver=newhttp.Server();
server.listen(8001, &apos;127.0.0.1&apos;);

server.on(&apos;request&apos;, handleReequest);
</code></pre><p>当用户点击提交按钮将输入信息提交到服务端时，服务端通过 <code>userInput</code> 变量保存了输入内容。当用户通过 <code>http://localhost:8001/${id}</code> 访问时，服务端会返回与 <code>id</code> 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720476-eb71a5c8-8759-11e8-8763-eb08b3480201.gif" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720476-eb71a5c8-8759-11e8-8763-eb08b3480201.gif" alt="存储型xss"></a></p>
<h4 id="基于DOM"><a href="#基于DOM" class="headerlink" title="基于DOM"></a>基于DOM</h4><p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p>
<p>看如下代码：</p>
<pre><code>&lt;h2&gt;XSS: &lt;/h2&gt;
&lt;inputtype=&quot;text&quot;id=&quot;input&quot;&gt;
&lt;buttonid=&quot;btn&quot;&gt;Submit&lt;/button&gt;
&lt;divid=&quot;div&quot;&gt;&lt;/div&gt;
&lt;script&gt;constinput=document.getElementById(&apos;input&apos;);constbtn=document.getElementById(&apos;btn&apos;);constdiv=document.getElementById(&apos;div&apos;);let val;input.addEventListener(&apos;change&apos;, (e) =&gt; {        val =e.target.value;    }, false);btn.addEventListener(&apos;click&apos;, () =&gt; {div.innerHTML=`&lt;ahref=${val}&gt;testLink&lt;/a&gt;`    }, false);&lt;/script&gt;
</code></pre><p>点击 <code>Submit</code> 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：</p>
<pre><code>&apos;&apos; onclick=alert(/xss/)
</code></pre><p>用户提交之后，页面代码就变成了：</p>
<pre><code>&lt;ahrefonlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;
</code></pre><p>此时，用户点击生成的链接，就会执行对应的脚本：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42721109-cb7ce572-8766-11e8-96d9-9ada8a787827.gif" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42721109-cb7ce572-8766-11e8-96d9-9ada8a787827.gif" alt="dom-xss"></a></p>
<h3 id="XSS-攻击的防范"><a href="#XSS-攻击的防范" class="headerlink" title="XSS 攻击的防范"></a>XSS 攻击的防范</h3><p>现在主流的浏览器内置了防范 XSS 的措施，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">CSP</a>。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。</p>
<h4 id="HttpOnly-防止劫取-Cookie"><a href="#HttpOnly-防止劫取-Cookie" class="headerlink" title="HttpOnly 防止劫取 Cookie"></a>HttpOnly 防止劫取 Cookie</h4><p>HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。</p>
<p>上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>
<h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p><strong>不要相信用户的任何输入。</strong> 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</p>
<p>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 <code>&lt;</code>，<code>&gt;</code> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。</p>
<p>而在一些前端框架中，都会有一份 <code>decodingMap</code>， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <code>&lt;</code>，<code>&gt;</code>，<code>script</code>，防止 XSS 攻击：</p>
<pre><code>// vuejs 中的 decodingMap
// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  &apos;&amp;lt;&apos;: &apos;&lt;&apos;,
  &apos;&amp;gt;&apos;: &apos;&gt;&apos;,
  &apos;&amp;quot;&apos;: &apos;&quot;&apos;,
  &apos;&amp;amp;&apos;: &apos;&amp;&apos;,
  &apos;&amp;#10;&apos;: &apos;\n&apos;
}
</code></pre><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 <a href="https://github.com/punkave/sanitize-html" target="_blank" rel="noopener">sanitize-html</a> 对输出内容进行有规则的过滤之后再输出到页面中。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p>
<p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p>
<p>在举例子之前，先说说浏览器的 Cookie 策略。</p>
<h3 id="浏览器的-Cookie-策略"><a href="#浏览器的-Cookie-策略" class="headerlink" title="浏览器的 Cookie 策略"></a>浏览器的 Cookie 策略</h3><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
</ul>
<p>而浏览器所持有的 Cookie 分为两种：</p>
<ul>
<li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。</li>
<li><p>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p>
<p>  res.setHeader(‘Set-Cookie’, [‘mycookie=222’, ‘test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;’]);</p>
</li>
</ul>
<p>上述代码创建了两个 Cookie：<code>mycookie</code> 和 <code>test</code>，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 <code>Expires</code> 属性值会不一样：</p>
<p>Firefox：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png" alt="firefox cookie"></a></p>
<p>Chrome:</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png" alt="chrome cookie"></a></p>
<p>此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 <code>donmain</code> 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。</p>
<h3 id="通过-Cookie-进行-CSRF-攻击"><a href="#通过-Cookie-进行-CSRF-攻击" class="headerlink" title="通过 Cookie 进行 CSRF 攻击"></a>通过 Cookie 进行 CSRF 攻击</h3><p>假设有一个 bbs 站点：<code>http://www.c.com</code>，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：</p>
<pre><code>http://www.c.com:8002/content/delete/:id
</code></pre><p>如发起 <code>http://www.c.com:8002/content/delete/87343</code> 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：</p>
<pre><code>res.setHeader(&apos;Set-Cookie&apos;, [&apos;user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&apos;]);
</code></pre><p><a href="https://user-images.githubusercontent.com/7871813/42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png" alt="user"></a></p>
<p><code>user</code> 对应的值是用户 ID。然后构造一个页面 A：</p>
<pre><code>&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;
&lt;img src=&quot;http://www.c.com:8002/content/delete/87343&quot;&gt;
</code></pre><p>页面 A 使用了一个 <code>img</code> 标签，其地址指向了删除用户帖子的链接：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png" alt="A"></a></p>
<p>可以看到，当登录用户访问攻击者的网站时，会向 <code>www.c.com</code> 发起一个删除用户帖子的请求。此时若用户在切换到 <code>www.c.com</code> 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。</p>
<p>由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p>
<p>但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。</p>
<h3 id="CSRF-攻击的防范"><a href="#CSRF-攻击的防范" class="headerlink" title="CSRF 攻击的防范"></a>CSRF 攻击的防范</h3><p>当前，对 CSRF 攻击的防范措施主要有如下几种方式。</p>
<h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。</p>
<p>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</p>
<p>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p>
<h4 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。</p>
<p>比如，如果用户要删除自己的帖子，那么先要登录 <code>www.c.com</code>，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 <code>http://www.c.com</code>；当请求是从 <code>www.a.com</code> 发起时，Referer 的值是 <code>http://www.a.com</code> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 <code>www.c.com</code> 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</p>
<p>针对上文的例子，可以在服务端增加如下代码：</p>
<pre><code>if (req.headers.referer!==&apos;http://www.c.com:8002/&apos;) {
    res.write(&apos;csrf 攻击&apos;);
    return;
}
</code></pre><p><a href="https://user-images.githubusercontent.com/7871813/42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png" alt="referer check"></a></p>
<p>Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。</p>
<h4 id="添加-token-验证"><a href="#添加-token-验证" class="headerlink" title="添加 token 验证"></a>添加 token 验证</h4><p>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 XSS 和 CSRF 的攻击原理和防御措施。当然，在 Web 安全领域，除了这两种常见的攻击方式，也存在这 SQL 注入等其它攻击方式，这不在本文的讨论范围之内，如果你对其感兴趣，可以阅读<a href="https://zhuanlan.zhihu.com/p/23569276" target="_blank" rel="noopener">SQL注入技术专题</a>的专栏详细了解相关信息。最后，总结一下 XSS 攻击和 CSRF 攻击的常见防御措施：</p>
<ol>
<li>防御 XSS 攻击</li>
</ol>
<ul>
<li>HttpOnly 防止劫取 Cookie</li>
<li>用户的输入检查</li>
<li>服务端的输出检查</li>
</ul>
<ol start="2">
<li>防御 CSRF 攻击</li>
</ol>
<ul>
<li>验证码</li>
<li>Referer Check</li>
<li>Token 验证</li>
</ul>
<p>&lt;完&gt;</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">Cross-site scripting</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html" target="_blank" rel="noopener">CSRF 攻击的应对之道</a></li>
<li>《白帽子讲 Web 安全》</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/31/JavaScript-中的-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/31/JavaScript-中的-this/" itemprop="url">JavaScript 中的 this !</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-31T22:53:27+08:00">
                2015-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 js 中，this 这个上下文总是变化莫测，很多时候出现 bug 总是一头雾水，其实，只要分清楚不同的情况下如何执行就 ok 了。</p>
<p><img src="https://pic4.zhimg.com/v2-3068deaab983c4e925d5b325985ce9e9_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3068deaab983c4e925d5b325985ce9e9_hd.jpg" alt=""></p>
<h2 id="全局执行"><a href="#全局执行" class="headerlink" title="全局执行"></a>全局执行</h2><p>首先，我们在全局环境中看看它的 this 是什么：</p>
<p>first. 浏览器：</p>
<pre><code>console.log(this);

// Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}
</code></pre><p>可以看到打印出了 window 对象；</p>
<p>second. node：</p>
<pre><code>console.log(this);

// global
</code></pre><p>可以看到打印出了 global 对象；</p>
<p>总结：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。</p>
<h2 id="函数中执行"><a href="#函数中执行" class="headerlink" title="函数中执行"></a>函数中执行</h2><h2 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h2><p>这是最普通的函数使用方法了：</p>
<pre><code>function test() {
  console.log(this);
};

test();

// Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}
</code></pre><p>我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象；</p>
<p>严格模式 ‘use strict’;</p>
<p>如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为：</p>
<pre><code>&apos;use strict&apos;;
function test() {
  console.log(this);
};

test();

// undefined
</code></pre><p>当然，把它放在一个立即执行函数中会更好，避免了污染全局：</p>
<pre><code>(function (){
  &quot;use strict&quot;;
　console.log(this);
})();

// undefined
</code></pre><h2 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h2><p>当一个函数被当作一个对象的方法调用的时候：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this.name);
  }
}

obj.foo();

// &apos;qiutc&apos;
</code></pre><p>这时候，this 指向当前的这个对象；</p>
<p>当然，我们还可以这么做：</p>
<pre><code>function test() {
  console.log(this.name);
}
var obj = {
  name: &apos;qiutc&apos;,
  foo: test
}

obj.foo();

// &apos;qiutc&apos;
</code></pre><p>同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 test ，它只是一个函数名，函数的引用，它指向这个函数，当 foo = test，foo 同样也指向了这个函数。</p>
<p>如果把对象的方法赋值给一个变量，然后直接调用这个变量呢：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  }
}

var test = obj.foo;
test();

// Window
</code></pre><p>可以看到，这时候 this 执行了全局，当我们把 test = obj.foo ，test 直接指向了一个函数的引用，这时候，其实和 obj 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，this 指向全局对象。</p>
<p>一些坑</p>
<p>我们经常在回调函数里面会遇到一些坑：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);   //Object {name: &quot;qiutc&quot;...}
    setTimeout(this.foo, 1000);   // window 对象
  }
}

obj.foo2();
</code></pre><p><img src="https://pic1.zhimg.com/v2-2099857fcaab02a66d655f172d12cf82_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-2099857fcaab02a66d655f172d12cf82_hd.jpg" alt=""></p>
<p>执行这段代码我们会发现两次打印出来的 this 是不一样的：</p>
<p>关于setTimeout的this指向：<a href="https://link.zhihu.com/?target=https%3A//www.talkingcoder.com/article/6356947525374513523" target="_blank" rel="noopener">https://www.talkingcoder.com/article/6356947525374513523</a></p>
<pre><code>第一次是 foo2 中直接打印 this，这里指向 obj 这个对象，我们毋庸置疑；
</code></pre><p>但是在 setTimeout 中执行的 this.foo，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑；<br>其实，setTimeout 也只是一个函数而已，函数必然有可能需要参数，我们把 this.foo 当作一个参数传给 setTimeout 这个函数，就像它需要一个 fun 参数，在传入参数的时候，其实做了个这样的操作 fun = this.foo，看到没有，这里我们直接把 fun 指向 this.foo 的引用；执行的时候其实是执行了 fun() 所以已经和 obj 无关了，它是被当作普通函数直接调用的，因此 this 指向全局对象。</p>
<p>这个问题是很多异步回调函数中普遍会碰到的；</p>
<p>解决</p>
<p>为了解决这个问题，我们可以利用 闭包 的特性来处理：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);
    var _this = this;
    setTimeout(function() {
      console.log(this);  // Window

      console.log(_this);  // Object {name: &quot;qiutc&quot;}
    }, 1000);
  }
}

obj.foo2();
</code></pre><p>可以看到直接用 this 仍然是 Window；因为 foo2 中的 this 是指向 obj，我们可以先用一个变量 _this 来储存，然后在回调函数中使用 _this，就可以指向当前的这个对象了；</p>
<p>setTimeout 的另一个坑</p>
<p>之前啊说过，如果直接执行回调函数而没有绑定作用域，那么它的 this 是指向全局对象(window)，在严格模式下会指向 undefined，然而在 setTimeout 中的回调函数在严格模式下却表现出不同：</p>
<pre><code>&apos;use strict&apos;;

function foo() {
  console.log(this);
}

setTimeout(foo, 1);

// window
</code></pre><p>按理说我们加了严格模式，foo 调用也没有指定 this，应该是出来 undefined，但是这里仍然出现了全局对象，难道是严格模式失效了吗？</p>
<p>并不，即使在严格模式下，setTimeout 方法在调用传入函数的时候，如果这个函数没有指定了的 this，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 foo.apply(window) 而非 foo()；</p>
<p>当然，如果我们在传入函数的时候已经指定 this，那么就不会被注入全局对象，比如： setTimeout(foo.bind(obj), 1);；</p>
<p><a href="https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code" target="_blank" rel="noopener">http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code</a></p>
<h2 id="作为一个构造函数使用"><a href="#作为一个构造函数使用" class="headerlink" title="作为一个构造函数使用"></a>作为一个构造函数使用</h2><p>在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 new 这个关键字：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var p = new Person(&apos;qiutc&apos;);

// Person {name: &quot;qiutc&quot;}
</code></pre><p>我们可以看到当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象；</p>
<p>当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var p = Person(&apos;qiutc&apos;);

// Window
</code></pre><p>其区别在于，如何调用函数（new）。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 this 的指向了，还记得在上文中（作为对象的方法调用-一些坑-解决）我们使用闭包来解决 this 的指向问题吗，如果用上了箭头函数就可以更完美的解决了：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);
    setTimeout(() =&gt; {
      console.log(this);  // Object {name: &quot;qiutc&quot;}
    }, 1000);
  }
}

obj.foo2();
</code></pre><p>可以看到，在 setTimeout 执行的函数中，本应该打印出在 Window，但是在这里 this 却指向了 obj，原因就在于，给 setTimeout 传入的函数（参数）是一个箭头函数：</p>
<blockquote>
<p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
</blockquote>
<p>根据例子我们理解一下这句话：<br>在 obj.foo2() 执行的时候，当前的 this 指向 obj；在执行 setTimeout 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 this 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 this，也就是 obj.foo2 中的 this，即 obj；所以在执行箭头函数的时候，它的 this -&gt; obj.foo2 中的 this -&gt; obj；</p>
<p>简单来说， 箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。</p>
<h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h2><p>在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向：</p>
<ul>
<li>call</li>
</ul>
<p>fun.call(thisArg[, arg1[, arg2[, …]]])</p>
<p>它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，后面的参数是执行函数需要传入的参数；</p>
<ul>
<li>apply</li>
</ul>
<p>fun.apply(thisArg[, [arg1, arg2, …]])</p>
<p>它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）；</p>
<ul>
<li>bind</li>
</ul>
<p>var foo = fun.bind(thisArg[, arg1[, arg2[, …]]]);</p>
<p>它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数；</p>
<p>这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this），我们以 call 函数为例；</p>
<p>为一个普通函数指定 this</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;
};

function foo() {
  console.log(this);
}

foo.call(obj);

// Object {name: &quot;qiutc&quot;}
</code></pre><p>可以看到，在执行 foo.call(obj) 的时候，函数内的 this 指向了 obj 这个对象，成功；</p>
<p>为对象中的方法指定一个 this</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function () {
    console.log(this);
  }
}

var obj2 = {
  name: &apos;tcqiu222222&apos;
};

obj.foo.call(obj2);

// Object {name: &quot;tcqiu222222&quot;}
</code></pre><p>可以看到，执行函数的时候这里的 this 指向了 obj2，成功；</p>
<p>为构造函数指定 this</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var p = new Person.call(obj, &apos;qiutc&apos;);

// Uncaught TypeError: Person.call is not a constructor(…)
</code></pre><p>这里报了个错，原因是我们去 new 了 Person.call 函数，而非 Person ，这里的函数不是一个构造函数；</p>
<p>换成 bind 试试：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var Person2 = Person.bind(obj);

var p = new Person2(&apos;qiutc&apos;);

// Person {name: &quot;qiutc&quot;}

console.log(obj);

// Object {name: &quot;qiutc2222222&quot;}
</code></pre><p>打印出来的是 Person 实例化出来的对象，而和 obj 没有关系，而 obj 也没有发生变化，说明，我们给 Person 指定 this 上下文并没有生效；</p>
<p>因此可以得出： 使用 bind 给一个构造函数指定 this，在 new 这个构造函数的时候，bind 函数所指定的 this 并不会生效；</p>
<p>当然 bind 不仅可以指定 this ，还能传入参数，我们来试试这个操作：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var Person2 = Person.bind(obj, &apos;qiutc111111&apos;);

var p = new Person2(&apos;qiutc&apos;);

// Person {name: &quot;qiutc111111&quot;}
</code></pre><p>可以看到，虽然指定 this 不起作用，但是传入参数还是起作用了；</p>
<p>为箭头函数指定 this</p>
<p>我们来定义一个全局下的箭头函数，因此这个箭头函数中的 this 必然会指向全局对象，如果用 call 方法改变 this 呢：</p>
<pre><code>var afoo = (a) =&gt; {
  console.log(a);
  console.log(this);
}

afoo(1);

// 1
// Window

var obj = {
  name: &apos;qiutc&apos;
};

afoo.call(obj, 2);

// 2
// Window
</code></pre><p>可以看到，这里的 call 指向 this 的操作并没有成功，所以可以得出： 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this。</p>
<p>只要记住箭头函数大法好，不变的 this。</p>
<p>Function.prototype.call</p>
<ul>
<li>格式:fx.call( thisArg [，arg1，arg2，… ] );</li>
</ul>
<ol>
<li><p>call的传参个数不限,第一个数表示调用函数(fx)函数体内this的指向.从第二个参数开始依次按序传入函数.</p>
<p> var age = 40;<br> var xiaoMing = {</p>
<pre><code>age:30
</code></pre><p> };<br> var xiaoLi = {</p>
<pre><code>age: 20
</code></pre><p> };<br> var getAge = function(){</p>
<pre><code>console.log(this.age);
</code></pre><p> };<br>  getAge.call( xiaoMing );  //30 表示函数this指向xiaoMing<br> getAge.call(xiaoLi);  //20  表示函数this指向xiaoLi<br> getAge.call(undefined);//40  getAge.call(undefined)==getAge.call(null)<br> getAge.call(null);//40<br> getAge(); //40</p>
</li>
</ol>
<p>如果我们传入fx.call()的第一个参数数为null,那么表示函数fx体内this指向宿主对象,在浏览器是Window对象,这也解释了getAge.call(undefined);//40。</p>
<p>在此基础我们可以理解为 getAge()相当于getAge.call(null/undefined),扩展到所有函数,<br>fx()==fx.call(null) == fx.call(undefined)</p>
<p>值得注意的是严格模式下有点区别: this指向null</p>
<pre><code>var getAge = function(){
&apos;use strict&apos;
console.log(this.age);
};
getAge(null);//报错 age未定义
</code></pre><p>再来理解this的使用</p>
<p>this的常用场景:</p>
<ul>
<li><p>this位于一个对象的方法内,此时this指向该对象</p>
<p>  var name = ‘window’;</p>
<p>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {
    console.log(this == Student); //true
    console.log(this.name);  //kobe
}
</code></pre><p>  }</p>
<p>  Student.getName();</p>
<p>  var name = ‘window’;<br>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {
            var name=100;
    console.log(this == Student); //true
    console.log(this.name);  //kobe
}
</code></pre><p>  }<br>  Student.getName();   //getName取得是Student 的name</p>
</li>
</ul>
<ul>
<li><p>this位于一个普通的函数内,表示this指向全局对象,(浏览器是window)</p>
<p>  var name = ‘window’;</p>
<p>  var getName = function () {</p>
<pre><code>var name = &apos;kobe&apos;;  //迷惑性而已
return this.name;
</code></pre><p>  }</p>
<p>  console.log(  getName() ); //window</p>
</li>
</ul>
<ul>
<li><p>this使用在构造函数(构造器)里面,表示this指向的是那个返回的对象.</p>
<p>  var name = ‘window’;<br>  //构造器<br>  var Student = function () {</p>
<pre><code>this.name = &apos;student&apos;;
</code></pre><p>  }</p>
<p>  var s1 = new Student();<br>  console.log(s1.name);  //student</p>
</li>
</ul>
<p>注意: 如果构造器返回的也是一个Object的对象(其他类型this指向不变遵循之前那个规律),这时候this指的是返回的这个Objec.</p>
<pre><code>var name = &apos;window&apos;;
//构造器
var Student = function () {
    this.name = &apos;student&apos;;
    return {
        name: &apos;boyStudent&apos;
    }
}

var s1 = new Student();
console.log(s1.name);  //boyStudent
</code></pre><ul>
<li><p>this指向失效问题</p>
<p>  var name = ‘window’;</p>
<p>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {        
    console.log(this.name);  
}
</code></pre><p>  }</p>
<p>  Student.getName(); // kobe<br>  var s1 = Student.getName;<br>  s1(); //window</p>
</li>
</ul>
<p>原因: 此时s1是一个函数</p>
<pre><code>function () {        
        console.log(this.name);  
    }
</code></pre><p>对一个基本的函数,前面提过this在基本函数中指的是window.</p>
<ul>
<li>在开发中我们经常使用的this缓存法 ,缓存当前作用域下this到另外一个环境域下使用</li>
</ul>
<blockquote>
<p>最后理解apply的用法 Function.prototype.apply</p>
</blockquote>
<p>格式: fx.apply(thisArg [，argArray] ); // 参数数组，argArray</p>
<ol>
<li>apply与call的作用是一样的,只是传参方式不同,</li>
<li><p>apply接受两个参数,第一个也是fx函数体内this的指向,用法与call第一个参数一致.第二个参数是数组或者类数组,apply就是把这个数组元素传入函数fx.</p>
<p> var add = function (a ,b ,c) {</p>
<pre><code>console.log(a +b +c);
</code></pre><p> }</p>
<p> add.apply(null , [1,2,3]); // 6</p>
</li>
</ol>
<p>再吃透这个题目就ok</p>
<pre><code>var a=10;
var foo={
  a:20,
  bar:function(){
      var a=30;
      return this.a;
    }
}
foo.bar()
//20
(foo.bar)()
//20
(foo.bar=foo.bar)()
//10
(foo.bar,foo.bar)()
//10
</code></pre><p>上题注解：</p>
<h2 id="时刻牢记：作用域链查找遵循”就近原则”；"><a href="#时刻牢记：作用域链查找遵循”就近原则”；" class="headerlink" title="时刻牢记：作用域链查找遵循”就近原则”；"></a>时刻牢记：作用域链查找遵循”就近原则”；</h2><h2 id="this谁调用就指向谁。"><a href="#this谁调用就指向谁。" class="headerlink" title="this谁调用就指向谁。"></a>this谁调用就指向谁。</h2><pre><code>var a=10;
var foo={
  a:20,
  bar:function(){
      var a=30;  //this 指向 foo  ：console.log( this == foo) //true
      return this.a;
    }
}


foo.bar()   
//20
// foo.bar()    // foo调用，this指向foo , 此时的 this 指的是foo，所以是20 


(foo.bar)()
//20
//第一步：
(function(){
   var a=30; 
   return this.a;
})()    //作用域链向上查找,this 指向外一层的对象foo



(foo.bar=foo.bar)()
//10
foo.bar=foo.bar,【睁大眼睛，是单等号赋值】就是普通的复制,一个匿名函数赋值给一个全局变量,你可以把右边的foo.bar换成b,
即(b = foo.bar)(),博客里面【this指向失效问题】说过普通的函数里面的this指向window,自然this.a == 10





(foo.bar,foo.bar)()  //逗号表达式
//10
//(foo.bar,foo.bar)是一个小括号表达式,小括号表达式会依次创建两个匿名函数,并返回最后一个的匿名函数值,
(foo.bar,foo.bar) 得到的是这个函数
 function(){
     var a=30;
     console.log( this == foo); //如果不是很了解this的指向就加这个代码进行检测
     return this.a;
   }
 ,这个是匿名函数,匿名函数的this指的是widnow,那么this.a = 10


this可谓是JavaScript中的开发神器，使用得当的话不仅有事半功倍的效果，而且代码的逼格也更高。但是既然是神器，如果你没有足够的功力的话，那么就不要使用它，否则就有可能自毁身亡。曾几何时，我偶然得到这个神器，之后，，，自残，，，自残，，，再自残...再自残了那么多次后，终于可以拥有强大功力持此神器行走江湖了。接下来，我就为大家来传授传说中神器的使用秘诀。
咳咳。。
入正题。
this是什么？this表示当前运行方法的主体。
注意：函数中的this指向和当前函数在哪定义的话或者在哪执行都没有任何的关系。为啥这样说，请仔细阅读下面的秘籍大全。
神器秘籍大全：

秘籍一：自制行函数里面的this永远都是window
var inner = &quot;window&quot;;
var obj = {inner : &quot;obj&quot;,
          fn : (function () {console.log(this.inner)})()
}


上面浏览器在运行该程序时，会自动运行obj.fn里面的方法，因为obj.fn是一个自制行函数，当执行该函数时，程序会输出window。
额，为什么输出不是obj？
因为人家规定自制行函数里面的this是window,所以其实this.inner就是window.inner，因此这个inner是定义在全局变量的，它的值是&quot;window&quot;。

秘籍二：元素绑定事件驱动方法运行，方法里的this表示当前绑定的元素
var oDiv = document.getElementsByTagName(&quot;div&quot;)[0];
oDiv.onclick=function(){
    console.log(this);   //当用鼠标点击该元素，则输出oDiv元素的集合
 };
这个好理解，元素绑定某个行为执行的方法，就相当于把这个方法也绑定在这个元素上，所以this也就指向元素本身。

秘籍三：方法执行，看方法名前面是否有&quot;.&quot;，有的话&quot;.&quot;前面是谁this就是谁，没有的话this就是window

var obj={fn:fn};
function fn(){console.log(this)}
fn.prototype.aa=function(){console.log(this)};
var f=new fn;
fn();  //window..
obj.fn(); //Object..
fn.prototype.aa(); //fn.prototype
f.aa(); //f

记住此秘籍！！！

秘籍四：在构造函数模式中,函数体中的this是当前类的一个实例
function Fn(){
    this.x = 100;
    console.log(this);  // 实例 f
}
var f = new Fn;
构造函数生成的实例，故构造函数里的this当然是指向当前这个实例了。

秘籍五（大招）：call/apply来改变this的指向
var oDiv = document.getElementsByTagName(&quot;div&quot;)[0];
function fn() {
    console.log(this);
}
fn.call(oDiv);
fn.call(oDiv); //执行这个语句后，fn里面的this指向oDiv元素，applay用法与call类似。
此大招一出来，上面四个秘籍都无效了。
</code></pre><h2 id="五个典型的-JavaScript-面试题"><a href="#五个典型的-JavaScript-面试题" class="headerlink" title="五个典型的 JavaScript 面试题"></a>五个典型的 JavaScript 面试题</h2><h2 id="问题1-范围（Scope）"><a href="#问题1-范围（Scope）" class="headerlink" title="问题1: 范围（Scope）"></a>问题1: 范围（Scope）</h2><p>思考以下代码：<br><img src="https://pic4.zhimg.com/v2-3427ee7904e86825dc800f37b5dd76a1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3427ee7904e86825dc800f37b5dd76a1_hd.jpg" alt=""></p>
<p>控制台（console）会打印出什么？</p>
<p>答案</p>
<p>上述代码会打印出5。</p>
<p>这个问题的陷阱就是，在立即执行函数表达式（IIFE）中，有两个命名，但是其中变量是通过关键词var来声明的。这就意味着a是这个函数的局部变量。与此相反，b是在全局作用域下的。</p>
<p>这个问题另一个陷阱就是，在函数中他没有使用”严格模式” (‘use strict’;)。如果 严格模式 开启，那么代码就会报出未捕获引用错误（Uncaught ReferenceError）：b没有定义。记住，严格模式要求你在需要使用全局变量时，明确地引用该变量。因此，你需要像下面这么写：<br><img src="https://pic3.zhimg.com/v2-d2990958fbb99d5fe5b7c2f99fd67fc1_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-d2990958fbb99d5fe5b7c2f99fd67fc1_hd.jpg" alt=""></p>
<h2 id="问题2-创建-“原生（native）”-方法"><a href="#问题2-创建-“原生（native）”-方法" class="headerlink" title="问题2: 创建 “原生（native）” 方法"></a>问题2: 创建 “原生（native）” 方法</h2><p>在String对象上定义一个repeatify函数。这个函数接受一个整数参数，来明确字符串需要重复几次。这个函数要求字符串重复指定的次数。举个例子：<br><img src="https://pic2.zhimg.com/v2-9a26df01a60f8a3020e339a2cdc022dc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-9a26df01a60f8a3020e339a2cdc022dc_hd.jpg" alt=""></p>
<p>应该打印出hellohellohello.</p>
<p>答案</p>
<p>一种可能的实现如下所示：<br><img src="https://pic3.zhimg.com/v2-323205969d7c319efb3257e962fc0e13_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-323205969d7c319efb3257e962fc0e13_hd.jpg" alt=""></p>
<p>这个问题测试了开发人员对于JavaScript中继承的掌握，以及prototype这个属性。这也验证了开发人员是否有能力扩展原生数据类型的功能（虽然不应该这么做）。</p>
<p>这个问题的另一个重点是验证你是否意识到并知道如何避免覆盖已经存在的函数。这可以通过在自定义函数之前判断该函数是否存在来做到。<br><img src="https://pic3.zhimg.com/v2-145aeeefc3c8949329552b22fa9434b3_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-145aeeefc3c8949329552b22fa9434b3_hd.jpg" alt=""></p>
<p>当你需要为旧浏览器实现向后兼容的函数时，这一技巧十分有用。</p>
<h2 id="问题3-变量提升（Hoisting）"><a href="#问题3-变量提升（Hoisting）" class="headerlink" title="问题3: 变量提升（Hoisting）"></a>问题3: 变量提升（Hoisting）</h2><p>执行以下代码会有什么结果？为什么？<br><img src="https://pic2.zhimg.com/v2-76ce0e2d75c2302991e408d087476a59_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-76ce0e2d75c2302991e408d087476a59_hd.jpg" alt=""></p>
<p>答案</p>
<p>这段代码的执行结果是 undefined 和 2。</p>
<p>这个结果的原因是，变量和函数都被提升了（hoisted）。因此，在a被打印的时候，它已经在函数作用域中存在（即它已经被声明了），但是它的值依然是 undefined。换言之，上述代码和以下代码是等价的。<br><img src="https://pic4.zhimg.com/v2-e5d341549dabe574215e26dbf0535ae8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-e5d341549dabe574215e26dbf0535ae8_hd.jpg" alt=""></p>
<h2 id="问题4-this-在-JavaScript-中是如何工作的"><a href="#问题4-this-在-JavaScript-中是如何工作的" class="headerlink" title="问题4: this 在 JavaScript 中是如何工作的"></a>问题4: this 在 JavaScript 中是如何工作的</h2><p>以下代码的结果是什么？请解释你的答案。<br><img src="https://pic4.zhimg.com/v2-c7109c7158a7800b48c57ce5fcfd889a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c7109c7158a7800b48c57ce5fcfd889a_hd.jpg" alt=""></p>
<p>答案</p>
<p>上面的代码打印出 Aurelio De Rosa 和 John Doe。原因是在 JavaScript 中，一个函数的上下文环境，也就是this关键词所引用对象，是依赖于函数是如何被调用的，而不是依赖于函数如何被定义的。</p>
<p>在第一个 console.log() 调用中， getFullname() 是作为 obj.prop 的函数被调用的。因此，这里的上下文环境指向后者并且函数返回this对象的 fullname 属性。相反，当 getFullname() 被赋为test变量的值时，那个语境指向全局对象(window)。这是因为，test被隐式设置为全局对象的属性。因此，函数调用返回 window 的 fullname 属性值，在此段代码中，这个值是通过第一行赋值语句设置的。</p>
<h2 id="问题5-call-和-apply"><a href="#问题5-call-和-apply" class="headerlink" title="问题5: call() 和 apply()"></a>问题5: call() 和 apply()</h2><p>修复上一个问题，让最后一个 console.log() 打印出 Aurelio De Rosa。</p>
<p>答案</p>
<p>要解决这个问题，可以通过为函数 call() 或者 apply() 强制函数调用的上下文环境。如果你不知道 call() 和 apply() 之间的区别，我推荐阅读文章“ function.call 和 function.apply 之间有和区别?”。在以下代码中，我会用 call()，但是在这里，用 apply() 也可以获得相同的结果：<br><img src="https://pic4.zhimg.com/v2-6dd929db46959a48071adb146a84ba56_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6dd929db46959a48071adb146a84ba56_hd.jpg" alt=""></p>
<h2 id="常见面试："><a href="#常见面试：" class="headerlink" title="常见面试："></a>常见面试：</h2><pre><code>下面列举一些简单的实例 总结一下this的一些用法：


1.方法中的this会指向当前执行该方法的对象 如：

var name = &quot;window&quot;

var Tom = {

  name:&quot;Tom&quot;;

  show:function(){alert(this.name)}

}

Tom.show();   //Tom



2.方法中的this不会指向声明它的对象 如下


var Bob={
  name:&quot;Bob&quot;,
  show:function(){alert(this.name);}
  };

var Tom={
  name:&quot;Tom&quot;,
  show:Bob.show
  };

Tom.show() ;   //Tom

因为尽管alert(this.name)是在Bob对象环境中声明的


但该方法是由Tom对象调用执行所以this总是会指向当前执行的对象，而不是声明的对象





3.将方法复制给变量时，执行时仍然会以Tom对象区调用该方法


var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;.
  show:function(){alert(this.name)}
  };

var fun=Tom.show();
fun();              //Tom

可以看出赋值后再调用，并不影响调用其方法的对象



4.将对象赋值给变量后，再调用方法，执行的对象仍然是Tom

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){
             var that=this;
             that.show();
         }
  };

Tom.wait();  //Tom

这里that赋值了当前执行的对象，并让它继续调用show，
所以show方法中alert(this.name)自然而然的指向了Tom
可以把上面的 &quot;that赋值对象 然后调用方法&quot; 这个过程看做成执行对象
的延迟，就是让Tom加班的意思




 5.另一种 指明调用方法的对象 的办法 如下：


var name = &quot;window&quot;;
var Bob= {
    name:&quot;Bob&quot;,
    show:function(){alert(this.name);}
    };

 var Tom= {name: &quot;Tom&quot;};
 Bob.show();                   //Bob
 Bob.show.apply();             //window
 Bob.show.apply(Tom);          //Tom

 当然call()也差不多类似



6.下面来个特殊的例子

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){
             var fun=this.show;
             fun();
         }
  };

Tom.wait();  //window

上面也是赋值方法后，再调用，可是执行的对象却改成了window对象

解释：

在函数体内把方法赋值给变量再调用会导致对象更改为Window对象
执行fun时，可以看做是一种方法调用的延迟行为，延迟调用方法会使得执行的对象
变为全局对象也就是window对象


下面我们来看看其他几种延迟方式，导致对象被更改为window的例子



7.匿名函数的延迟

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){!function(call){call();}(this.show)}
  }

Tom.wait();    //Window




8.setTimeout、setInterval函数延迟
这里只以setTimeout为例子

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){setTimeout(this.show,1000)}
  }

Tom.wait();    //window



9. 在延迟的环境下 尝试让Tom加班（对象也跟着延迟）

var name=&quot;window&quot;;
var Tom={  name:&quot;Tom&quot;,
show:function(){alert(this.name)},
wait:function(){setTimeout(Tom.show,1000)}  }

Tom.wait();    //window  



上面中this对象改成了Tom，尝试让Tom加班，但是结果仍然为Window对象
因为Tom.show放在第一个参数里，延迟的执行使得执行的对象变为window对象
而不再是Tom对象，如何让执行对象Tom在延迟当不被变更呢？下面给你答案


 10.虽然延迟会导致方法的执行对象被更改为Window 但也有办法防止执行对象更改 如下


var name=&quot;window&quot;
var  Tom ={  
    name : &quot;Tom&quot;,  
    show : function(){alert(this.name);},  
    wait:  function(){
    var that=this;
    setTimeout(function(){that.show()},1000)}  
          }

Tom.wait();    //Tom 

如果不能理解上面的代码，你就当做Tom对象也跟着函数一起延迟就好了
而第9个例子没有成功延迟，是因为没有变量保存对象使得执行对象没有跟着延迟





11.eval函数的延迟

对于eval比较特殊

在eval环境下，执行的对象就是当前作用域的对象 如下


var name=&quot;window&quot;;
var Bob={
  name:&quot;Bob&quot;,
  showName: function(){ eval(&quot;alert(this.name)&quot;); }
  };

Bob.showName(); //Bob








12.eval函数的环境下，不会受到延迟而影响函数执行的对象

之所以eval特殊是因为eval不受延迟的影响

var name=&quot;window&quot;;
var that;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){that=this;setTimeout(&quot;that.show()&quot;,1000)}
  }

Tom.wait();    //Tom



也许你会觉得上面的代码没有eval函数的身影
其实setTimeout函数的第一个参数就是eval环境
他会指向当前执行作用域的执行对象，忽略延迟方法延迟调用



如果能把上面12个例子都理解了，那么this将成为你的一把有力的刀，挥舞在你代码中
当然如果不能理解，那么像闭包一样 尽量的少用！
</code></pre><p>函数是JavaScript世界里的第一公民，换句话来说，就是我们如果可以精通JavaScript函数的使用，那么对JavaScript的运用可以更游刃有余了。熟悉JavaScript的人应该都知道，同样的函数，以不同的方式调用的话，受影响最大的应该是  this 。下面我们来说说JavaScript函数的各种调用模式。</p>
<p>一、普通函数的调用模式</p>
<p>　　所谓普通函数的调用模式，也是JavaScript函数的最简单的一种调用模式，直接就是函数名后接一个  ()  实现调用，看下面代码：</p>
<pre><code>function func(){
    console.log(this === window);  //true
}
func();
</code></pre><p>　　上面代码，我们用function关键字声明了一个 func 函数，并且在函数体内打印 this===window，然后我们直接调用函数func，我们可以看到控制台是直接打印出 true ，也就是说，函数的这种普通调用模式，函数体内的  this  是指向全局环境 window 的。不清楚这点的同学，可以能会遇到这样的一个bug：</p>
<pre><code>var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        function func1(){
            console.log(this.color);  //gg
        }
        func1();
    }
}
obj.show(); 
</code></pre><p>　　我们在全局环境下声明了一个变量 color 和一个对象 obj ，在对象 obj 里面我们还声明了一个 color 属性 为 ‘red’，一个 show 方法。而且在 show 方法里面呢，我们还声明了一个函数 func1 并且调用了 func1，func1 的作用是打印 this.color。最后我们运行代码  obj.show();   调用obj里面的show方法。不清楚函数的普通调用模式的特点的同学可能会认为此时在控制台答应出来的会是  ‘red’ 。实际上此时在控制台答应出来的应该是  gg  。因为函数  func1  的调用模式是 普通函数调用模式（即使它是在  obj  的  show  方法里面调用的），所以此时函数体内的  this  是指向 全局环境window 的，所以就打印了全局环境下的变量  color 。</p>
<p>　　可能有些同学会问：如果我们希望  func1  函数打印出来的是 ‘red’ 呢，应该怎么改？其实很简单，因为  obj.color  才是 ‘red’ ，所以我们只需要把  指向  obj  的  this 引入到函数 func1  里面就行了： </p>
<pre><code>var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        var that = this;
        function func1(){
            console.log(that.color);  //red
        }
        func1();
    }
}
obj.show();
var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        var func1=function(){
            console.log(this.color);  //red
        }.bind(this);
        func1();
    }
}
obj.show();
</code></pre><p>　　在上面的代码中，因为  show  里面的   this  指向   obj   的，所以我们在  show  里面声明一个变量  that = this;用来把指向  obj  的  this  引入到  func1 中，然后再把 func1 函数体内的  this.color  改为  that.color ,此时在控制台打印出来的就是我们想要的 ‘red’ 了。</p>
<p>　　可能现在又有同学会问：为什么   show   里面的  this  是指向  obj 的呢？这就是我们要说的JavaScript函数的第二种调用模式：方法调用模式</p>
<p>二、方法调用模式</p>
<p>　　方法调用模式，简单来说就是把一个 JavaScript函数作为一个对象的方法来调用，当一个函数被保存为一个对象的属性是，我们就把它称为方法，例如上文的  obj  对象里的  show  ，当一个方法被调用时，函数体里面的   this  就会绑定到这个对象，例如上文的 show 里面的  this  。方法调用模式也很容易辨别：obj.show()，对象名 . 属性名 () ；代码的话可以参考上文的  obj  代码 ，博主就不多写了。记住：方法的调用是可以在函数体内通过  this  访问自己所属的那个对象的。</p>
<p>三、构造器调用模式</p>
<p>博主认为构造器调用模式是相对于其他模式来说较为复杂点的调用模式了。通过关键字  new  可以把一个函数作为构造器来调用。关键字  new  可以改变函数的返回值：</p>
<pre><code>function func2(name){
    this.name = name;
}

name;   //undefined

//普通函数调用模式
var foo = func2(&apos;afei&apos;);
foo;  //undefined
name;   //afei


//构造器调用模式
var bar = new func2(&apos;lizefei&apos;);
bar.__proto__ === func2.prototype;  //true
bar;  //{name:&apos;lizefei&apos;}
bar.name;  //&apos;lizefei&apos;
</code></pre><p>　　在上示代码中我们声明了一个函数 func2 ，分别用两种不同的调用模式去调用它。因为函数  func2  并没有显式返回值，所以作为普通函数去调用时，它什么也没有返回，所以  foo  的值是  undefined  。因为普通调用模式的   this   是指向 全局环境   window  的，所以  func2(‘afei’);  后，全局环境下就多了一个  name 变量且等于 ‘afei’。</p>
<p>　　func2  作为构造器调用时，我们可以看到，它返回的是一个对象，因为关键字  new  使得函数在调用是发生了如下的特殊变化：</p>
<ol>
<li>　　创建了一个新对象，而且这个新对象是链接到 func2  的  prototype  属性的</li>
<li>　　把函数里的  this  指向了这个新对象</li>
<li>　　如果没有显式的返回值，新对象作为构造器func2的返回值进行返回（所以bar 是 {name:’lizefei’}）</li>
</ol>
<p>这样子我们就可以看出构造器的作用：通过函数的调用来初始化新创建出来的对象。在JavaScript的面向对象编程里面，这个可是相当重要的。</p>
<p>　　因为在函数的声明上，在未来作为构造器调用的函数和普通函数的声明没什么区别，所以导致后来的开发者很容易因为调用模式的错误导致程序出问题。所以开发者们都默契地约定，用来做构造器调用的函数的函数名的第一个字符应该大写，例如：Person，People。这样子后来的开发者一看到函数名就知道要用构造器调用模式调用此函数了。</p>
<p>四、使用apply()和call()方法调用</p>
<p>　　这种调用的模式是为了更灵活控制函数运行的上下文环境而诞生的。简单的说就是为了灵活控制函数体内  this  的值。</p>
<p>　　apply 和 call这两个方法的第一个参数都是要传递被函数上下文的对象（简单点说就是要绑定给函数  this  的对象）。其他参数就有所不同了：</p>
<p>　　apply方法的第二个参数是一个数组，数组里面的值将作为函数调用的参数；</p>
<p>　　call方法，从第二个参数起（包括第二个参数），剩下的参数都是作为函数调用的参数；</p>
<p>　　让我们看看栗子：</p>
<pre><code>var obj = {
    name :&apos;afei&apos;
}
function say(ag1,ag2){
    console.log(ag1+&apos;:&apos;+ag2+&quot; &quot;+ this.name);
}
say.apply(obj,[&apos;apply方法&apos;,&apos;hello&apos;]); //apply方法:hello afei
say.call(obj,&apos;call方法&apos;,&apos;hi&apos;); //call方法:hi afei
</code></pre><p>　　正如栗子所示，我们把对象 obj  作为函数  say  的上下文来调用函数  say  ，所以函数里的  this  是指向 对象  obj  的。在apply方法里，我们通过数组  [‘apply方法’,’hello’]  给  say  方法传递了两个参数（’apply方法’ 和 ‘hello’），所以打印出来是：  apply方法:hello afei。</p>
<p>　　同理  call 也是一样，而且函数传递的方式通过上面的代码也一目了然我，博主就不多做解释了。</p>
<p>　　另外，博主还听说apply和call这两个方法除了传递参数的方式不一样，执行的速度还是apply 比 call 要快呢。不过博主就没有实验过。</p>
<p>五、总结</p>
<p>　　在JavaScript里面，函数只要的调用模式就是这几种了（在ES6里面还有一种很奇怪很特殊的函数调用模式，叫做’标签模板‘，在这里博主也不多说了，有空另更），只要掌握了这几种主要的调用模式，那么日后再也不用担心  this 的值变来变去了。</p>
<p>　　上文如果有漏的、有错误的地方，望各位小伙伴指出，小弟虚心向学。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/30/JS中的this的七种使用场景/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/30/JS中的this的七种使用场景/" itemprop="url">JS中的this的七种使用场景</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-30T19:54:45+08:00">
                2015-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Javascript 中的 this，有时候让人迷惑，所以总结了一下关于this指向的问题。</p>
<p>在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。</p>
<blockquote>
<p>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。</p>
</blockquote>
<h2 id="关于-this-的取值，大体上可以分为以下七种情况："><a href="#关于-this-的取值，大体上可以分为以下七种情况：" class="headerlink" title="关于 this 的取值，大体上可以分为以下七种情况："></a>关于 this 的取值，大体上可以分为以下七种情况：</h2><blockquote>
<p>由于严格模式下，禁止this指向全局对象，所以以下示例均运行在非严格模式下</p>
</blockquote>
<h2 id="情况一：全局-amp-调用普通函数"><a href="#情况一：全局-amp-调用普通函数" class="headerlink" title="情况一：全局 &amp; 调用普通函数"></a>情况一：全局 &amp; 调用普通函数</h2><p>在全局环境中，this 永远指向 window。</p>
<pre><code>console.log(this === window);     //true
</code></pre><p>普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。</p>
<pre><code>var x = 10;
function foo(){
    console.log(this);     //Window
    console.log(this.x);   //10
}
foo();
</code></pre><h2 id="情况二：构造函数"><a href="#情况二：构造函数" class="headerlink" title="情况二：构造函数"></a>情况二：构造函数</h2><p>所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。</p>
<pre><code>function Foo(){
    this.x = 10;
    console.log(this);    //Foo {x:10}
}
var foo = new Foo();
console.log(foo.x);      //10
</code></pre><p>上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。</p>
<p>但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。</p>
<pre><code>function Foo(){
    this.x = 10;
    console.log(this);    //Window
}
var foo = Foo();
</code></pre><h2 id="情况三：对象方法"><a href="#情况三：对象方法" class="headerlink" title="情况三：对象方法"></a>情况三：对象方法</h2><p>如果函数作为对象的方法时，方法中的 this 指向该对象。</p>
<pre><code>var obj = {
    x: 10,
    foo: function () {
        console.log(this);        //Object
        console.log(this.x);      //10
    }
};
obj.foo();
</code></pre><p>注意：若是在对象方法中定义函数，那么情况就不同了。</p>
<pre><code>var obj = {
    x: 10,
    foo: function () {
        function f(){
            console.log(this);      //Window
            console.log(this.x);    //undefined
        }
        f();
    }
}
obj.foo();
</code></pre><p>可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。</p>
<p>在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。</p>
<pre><code>var obj = {
    x: 10,
    foo: function () {
        var self = this;
        function f(){
            console.log(self);      //{x: 10}
            console.log(self.x);    //10
        }
        f();
    }
}
obj.foo();
</code></pre><p>如果 foo 函数不作为对象方法被调用：</p>
<pre><code>var obj = {
    x: 10,
    foo: function () {
        console.log(this);       //Window
        console.log(this.x);     //undefined
    }
};
var fn = obj.foo;
fn();
</code></pre><p>obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。</p>
<h2 id="情况四：构造函数-prototype-属性"><a href="#情况四：构造函数-prototype-属性" class="headerlink" title="情况四：构造函数 prototype 属性"></a>情况四：构造函数 prototype 属性</h2><pre><code>function Foo(){
    this.x = 10;
}
Foo.prototype.getX = function () {
    console.log(this);        //Foo {x: 10, getX: function}
    console.log(this.x);      //10
}
var foo = new Foo();
foo.getX();
</code></pre><p>在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。</p>
<h2 id="情况五：函数用-call、apply或者-bind-调用。"><a href="#情况五：函数用-call、apply或者-bind-调用。" class="headerlink" title="情况五：函数用 call、apply或者 bind 调用。"></a>情况五：函数用 call、apply或者 bind 调用。</h2><pre><code>var obj = {
    x: 10
}
function foo(){
    console.log(this);     //{x: 10}
    console.log(this.x);   //10
}
foo.call(obj);
foo.apply(obj);
foo.bind(obj)();
</code></pre><p>当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。</p>
<h2 id="情况六：DOM-event-this"><a href="#情况六：DOM-event-this" class="headerlink" title="情况六：DOM event this"></a>情况六：DOM event this</h2><p>在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：</p>
<pre><code>function Listener(){   
    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;, this.handleClick);     //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this
}
Listener.prototype.handleClick = function (event) {
    console.log(this);    //&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;
}
var listener = new Listener();
document.getElementById(&apos;foo&apos;).click();
</code></pre><p>这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：</p>
<pre><code>var obj = {
    x: 10,
    fn: function() {
        console.log(this);         //Window
        console.log(this.x);       //undefined
    }
};
function foo(fn) {
    fn();
} 
foo(obj.fn);
</code></pre><p>你也可以用通过 bind 切换上下文:</p>
<pre><code>function  Listener(){
    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;,this.handleClick.bind(this));      
}
Listener.prototype.handleClick = function (event) {
    console.log(this);    //Listener {}
}
var listener = new Listener();
document.getElementById(&apos;foo&apos;).click();
</code></pre><p>前六种情况其实可以总结为： this 指向调用该方法的对象。</p>
<h2 id="情况七：箭头函数中的-this"><a href="#情况七：箭头函数中的-this" class="headerlink" title="情况七：箭头函数中的 this"></a>情况七：箭头函数中的 this</h2><p>当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。</p>
<pre><code>var obj = {
    x: 10,
    foo: function() {
        var fn = () =&gt; {
            return () =&gt; {
                return () =&gt; {
                    console.log(this);      //Object {x: 10}
                    console.log(this.x);    //10
                }
            }
        }
        fn()()();
    }
}
obj.foo();
</code></pre><p>现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。</p>
<p>如果使用箭头函数，以前的这种 hack 写法：</p>
<pre><code>var self = this;
</code></pre><p>就不再需要了。</p>
<pre><code>var obj = {
    x: 10,
    foo: function() {
        var fn = () =&gt; {
            return () =&gt; {
                return () =&gt; {
                    console.log(this);    // Object {x: 10}
                    console.log(this.x);  //10
                }
            }
        }
        fn.bind({x: 14})()()();
        fn.call({x: 14})()();
    }
}
obj.foo();
</code></pre><p>由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/08/requestAnimationFrame/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/08/requestAnimationFrame/" itemprop="url">requestAnimationFrame</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-08T21:01:22+08:00">
                2015-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在Web应用中，实现动画效果的方法比较多，JavaScript 中可以通过定时器 setTimeout 来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。除此之外，html5 还提供一个专门用于请求动画的 API，即  requestAnimationFrame（rAF），顾名思义就是 “请求动画帧”<strong>。 </strong>为了深入理解  rAF 背后的原理（后文的 rAF 均指的是 requestAnimationFrame），我们首先需要了解一下与之相关的几个概念：</p>
<h3 id="屏幕绘制频率"><a href="#屏幕绘制频率" class="headerlink" title="屏幕绘制频率"></a>屏幕绘制频率</h3><p>即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是60Hz， 可以在桌面上 右键 &gt; 屏幕分辨率 &gt; 高级设置 &gt; 监视器 中查看和设置。这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响，原则上设置成让眼睛看着舒适的值都行。</p>
<p>市面上常见的显示器有两种，即 <strong>CRT </strong>和 <strong>LCD</strong>， CRT 就是传统显示器，LCD 就是我们常说的液晶显示器。</p>
<p>CRT 是一种使用阴极射线管的显示器，屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。<strong>电子束每秒击打荧光粉的次数就是屏幕绘制频率。</strong></p>
<p>而对于 LCD 来说，则不存在绘制频率的问题，因为 LCD 中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以 LCD 不会有电子束击打荧光粉而引起的闪烁现象。</p>
<p>因此，<strong>当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像</strong>。为什么你感觉不到这个变化？ 那是因为人的眼睛有<strong>视觉停留效应</strong>，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</p>
<h3 id="CSS-动画原理"><a href="#CSS-动画原理" class="headerlink" title="CSS 动画原理"></a>CSS 动画原理</h3><p>根据上面的原理我们知道，你眼前所看到图像正在以每秒 60 次的频率绘制，由于频率很高，所以你感觉不到它在绘制。而 <strong>动画本质就是要让人眼看到图像被绘制而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。</strong> 那怎么样才能做到这种效果呢？ </p>
<p>60Hz 的屏幕每 16.7ms 绘制一次，如果在屏幕每次绘制前，将元素的位置向左移动一个像素，即1px，这样一来，屏幕每次绘制出来的图像位置都比前一个要差1px，你就会看到图像在移动；而由于人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，这样你所看到的效果就是，图像在流畅的移动。这就是视觉效果上形成的动画。 </p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h3><p>理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：</p>
<ul>
<li>setTimeout 的执行时间并不是确定的。在JavaScript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 <strong>setTimeout 的实际执行时机一般要比其设定的时间晚一些。</strong></li>
<li>刷新频率受 <strong>屏幕分辨率 </strong>和 <strong>屏幕尺寸 </strong>的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li>
</ul>
<p>以上两种情况都会导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起<strong>丢帧</strong>现象。 那为什么步调不一致就会引起丢帧呢？ </p>
<p>首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：</p>
<ul>
<li>第    0  ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；</li>
<li>第   10 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；</li>
<li>第 16.7 ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；</li>
<li>第   20 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;</li>
<li>第   30 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;</li>
<li>第33.4 ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；</li>
<li>…</li>
</ul>
<p>从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。</p>
<h3 id="rAF"><a href="#rAF" class="headerlink" title="rAF"></a>rAF</h3><p>与 setTimeout 相比，rAF 最大的优势是 <strong>由系统来决定回调函数的执行时机。</strong>具体一点讲就是，<strong>系统每次绘制之前会主动调用 rAF 中的回调函数</strong>，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，rAF 的执行步伐跟着系统的绘制频率走。<strong>它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次</strong>，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p>
<p>这个API的调用很简单，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var progress = 0;</span><br><span class="line">//回调函数</span><br><span class="line">function render() &#123;</span><br><span class="line">    progress += 1; //修改图像的位置</span><br><span class="line"> </span><br><span class="line">    if (progress &lt; 100) &#123;</span><br><span class="line">           //在动画没有结束前，递归渲染</span><br><span class="line">           window.requestAnimationFrame(render);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//第一帧渲染</span><br><span class="line">window.requestAnimationFrame(render);</span><br></pre></td></tr></table></figure></p>
<p>除此之外，rAF 还有以下两个优势：</p>
<blockquote>
<p><strong>CPU节能</strong>：使用 setTimeout 实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。</p>
</blockquote>
<blockquote>
<p><strong>函数节流</strong>：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。</p>
</blockquote>
<h3 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h3><p>由于 rAF 目前还存在兼容性问题，而且不同的浏览器还需要带不同的前缀。因此需要通过优雅降级的方式对 rAF 进行封装，优先使用高级特性，然后再根据不同浏览器的情况进行回退，直止只能使用 setTimeout 的情况，因此可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.requestAnimFrame = (function()&#123;</span><br><span class="line">  return  window.requestAnimationFrame       ||</span><br><span class="line">          window.webkitRequestAnimationFrame ||</span><br><span class="line">          window.mozRequestAnimationFrame    ||</span><br><span class="line">          function( callback )&#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">          &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>但这种写法没有考虑 cancelAnimationFrame 的兼容性，并且不是所有的设备绘制时间间隔都是1000/60，下面的代码是比较全的一个 polyfill，详情介绍请参考： <a href="https://github.com/darius/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if (!Date.now)</span><br><span class="line">    Date.now = function() &#123; return new Date().getTime(); &#125;;</span><br><span class="line"> </span><br><span class="line">(function() &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">     </span><br><span class="line">    var vendors = [&apos;webkit&apos;, &apos;moz&apos;];</span><br><span class="line">    for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) &#123;</span><br><span class="line">        var vp = vendors[i];</span><br><span class="line">        window.requestAnimationFrame = window[vp+&apos;RequestAnimationFrame&apos;];</span><br><span class="line">        window.cancelAnimationFrame = (window[vp+&apos;CancelAnimationFrame&apos;]</span><br><span class="line">                                   || window[vp+&apos;CancelRequestAnimationFrame&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy</span><br><span class="line">        || !window.requestAnimationFrame || !window.cancelAnimationFrame) &#123;</span><br><span class="line">        var lastTime = 0;</span><br><span class="line">        window.requestAnimationFrame = function(callback) &#123;</span><br><span class="line">            var now = Date.now();</span><br><span class="line">            var nextTime = Math.max(lastTime + 16, now);</span><br><span class="line">            return setTimeout(function() &#123; callback(lastTime = nextTime); &#125;,</span><br><span class="line">                              nextTime - now);</span><br><span class="line">        &#125;;</span><br><span class="line">        window.cancelAnimationFrame = clearTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/07/你所知道或不知道的CSS-content属性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/05/07/你所知道或不知道的CSS-content属性/" itemprop="url">你所知道或不知道的CSS content属性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-05-07T20:17:55+08:00">
                2015-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>css博大精深，很多属性，往往都是看似熟悉，但是似乎又不能将其特性和用法完整地说出来。</p>
<p>content属性，的确是很眼熟，也许很多童鞋和我一样，和它初次见面，是在清除浮动的时候：</p>
<pre><code>.clearfix:after{
    content: &quot;.&quot;;
    display: block;
    height: 0;
    clear: both;
    visibility: hidden
}
</code></pre><p>如上所示，content 属性与 :before 及 :after 伪元素配合使用，并可以接受一个字符串作为值。</p>
<p>然而，除了字符串之外，还能接受什么样的值呢？</p>
<h2 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h2><blockquote>
<p>content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容。</p>
<p>该属性用于定义元素之前或之后放置的生成内容。默认是行内内容，不过可以用属性 display 控制。</p>
</blockquote>
<h2 id="可能的值"><a href="#可能的值" class="headerlink" title="可能的值"></a>可能的值</h2><p>none、normal、inherit、string、url()、attr()、[no-]open-quote、[no-]close-quote、counter[s]</p>
<p>其中none、normal、inherit这三个和大多数属性类似，故不做介绍。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是常见的，上面清除浮动的例子，就是其中之一。</p>
<h3 id="url"><a href="#url" class="headerlink" title="url()"></a>url()</h3><p>url的用法，和background属性有点类似，可以接受一个图片url。不一样的是，content属性无法控制图片的大小。</p>
<pre><code>&lt;div class=&quot;logo&quot;&gt;Google&lt;/div&gt;

.logo:before{
    content: url(https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png);
}
</code></pre><p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/1.jpg" alt=""></p>
<h3 id="attr"><a href="#attr" class="headerlink" title="attr"></a>attr</h3><p>attr，顾名思义，就是将content内容设置为对应元素的某一属性。</p>
<pre><code>&lt;p&gt;
    &lt;span data-text=&apos;半&apos;&gt;半&lt;/span&gt;
    &lt;span data-text=&apos;边&apos;&gt;边&lt;/span&gt;
    &lt;span data-text=&apos;效&apos;&gt;效&lt;/span&gt;
    &lt;span data-text=&apos;果&apos;&gt;果&lt;/span&gt;
&lt;/p&gt;

span{
    font-size: 100px;
    font-weight: bold;
    position: relative;
    color: #000;
}
span:before{
    content: attr(data-text);
    color: #F00;
    position: absolute;
    left: 0;
    top: 0;
    width: 50%;
    overflow: hidden;
}
</code></pre><p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/2.png" alt=""></p>
<h3 id="quote-·-引号"><a href="#quote-·-引号" class="headerlink" title="quote · 引号"></a>quote · 引号</h3><p>[no-]open-quote、[no-]close-quote，这四个值，常用于给元素前后加上引号，配合quotes 属性一起使用。</p>
<pre><code>&lt;p&gt;鲁迅曾经说过: &lt;span&gt;能用CSS解决的问题就不要使用JS。&lt;span&gt;呵呵，谁说的？&lt;span class=&quot;no-quote&quot;&gt;呵呵，谁说的？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

span {
    quotes: &apos;“&apos;&apos;”&apos;&apos;‘&apos;&apos;’&apos;&apos;&quot;&apos;&apos;&quot;&apos;;
}
span:before { 
    content: open-quote;
}
span:after {
    content: close-quote;
}
.no-quote:after{
    content: no-close-quote;
}
</code></pre><p>其中，quotes属性定义要使用的引号。两两一组，前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。如此类推。</p>
<p>需要注意的是，只有当伪元素:before设置content的值为open-quote才会有效果。</p>
<p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/3.png" alt=""></p>
<h3 id="counter-s-·-计数器"><a href="#counter-s-·-计数器" class="headerlink" title="counter[s] · 计数器"></a>counter[s] · 计数器</h3><p>这是一个很强大的东西，不妨先来体验一下其强大的力量，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;strong&gt;请选择你所使用的技术：&lt;/strong&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item1&quot;&gt;&lt;label for=&quot;item1&quot;&gt;PHP&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item2&quot;&gt;&lt;label for=&quot;item2&quot;&gt;Javascript&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item3&quot;&gt;&lt;label for=&quot;item3&quot;&gt;Java&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item4&quot;&gt;&lt;label for=&quot;item4&quot;&gt;HTML&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item5&quot;&gt;&lt;label for=&quot;item5&quot;&gt;CSS&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item6&quot;&gt;&lt;label for=&quot;item6&quot;&gt;nodejs&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item7&quot;&gt;&lt;label for=&quot;item7&quot;&gt;go&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">总共选择了 &lt;strong class=&quot;total&quot;&gt;&lt;/strong&gt; 项！</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ol&#123;</span><br><span class="line">	counter-reset: n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input:checked &#123;</span><br><span class="line">	counter-increment: n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.total:after &#123;</span><br><span class="line">	content: counter(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/4.png" alt=""><br>与其搭配使用的，还有counter-reset、counter-increment两个属性。</p>
<h4 id="counter-reset"><a href="#counter-reset" class="headerlink" title="counter-reset"></a>counter-reset</h4><p>用来标识计数器的作用域，值包括两部分：第一部分为计数器的名字；第二部分为计数器的起始值，默认为0。此外，counter-reset还可以同时声明多个计数器</p>
<pre><code>counter-reset: n 0
counter-reset: n 2 
counter-reset: n 0 m 0 p 0
</code></pre><h4 id="counter-increment"><a href="#counter-increment" class="headerlink" title="counter-increment"></a>counter-increment</h4><p>用来表明计数器实际用到的范围，值包括两部分：第一部分为计数器的名字；第二部分为计数器的递增的值，默认为1。如：</p>
<pre><code>counter-increment: n 2
counter-increment: n -1 /*递减*/
</code></pre><p>那counter和counters有什么不一样呢？</p>
<h4 id="counter"><a href="#counter" class="headerlink" title="counter()"></a>counter()</h4><p>counter方法可以接收两个参数。第一个是计数器的名字，必填；第二个是计数器的样式，也就是list-style-type，其支持的关键字值，就是list-style-type支持的那些值，比如disc | circle | square之类等等。</p>
<pre><code>content: counter(n)

content: counter(m, circle)
</code></pre><h4 id="counters"><a href="#counters" class="headerlink" title="counters()"></a>counters()</h4><p>counters方法主要用于嵌套计数，可以接收三个参数。第一个是计数器的名字，必填；第二个是字符串，用于嵌套计数的分隔符，如1.1中的“.”；第三个参数是计数器的样式，与counter一样。其中，前两个参数为必填</p>
<pre><code>content: counters(n, &apos;-&apos;);
</code></pre><p>说了这么多，还是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;li&gt;none&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;normal&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;inherit&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;string&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;url&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;attr&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;quote</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li&gt;open-quote&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;close-quote&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;no-open-quote&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;no-close-quote&lt;/li&gt;</span><br><span class="line">		&lt;/ul&gt;</span><br><span class="line">	&lt;/li&gt;		</span><br><span class="line">	&lt;li&gt;counter[s]</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li&gt;counter&lt;/li&gt;</span><br><span class="line">			&lt;li&gt;counters&lt;/li&gt;</span><br><span class="line">		&lt;/ul&gt;</span><br><span class="line">	&lt;/li&gt;	</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">   counter-reset: n;</span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">   list-style-type: none;</span><br><span class="line">	counter-increment: n;</span><br><span class="line">&#125;</span><br><span class="line">li:before&#123;</span><br><span class="line">	content: counters(n, &apos;-&apos;) &apos;.&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2015/05/07/你所知道或不知道的CSS-content属性/5.jpg" alt=""></p>
<p>实在不得不感叹css的博大精深！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/04/26/Ajax与Comet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/04/26/Ajax与Comet/" itemprop="url">Ajax与Comet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-04-26T20:19:20+08:00">
                2015-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>下述内存主要讲述了《JavaScript高级程序设计（第3版）》第21章关于“Ajax与Comet”。</p>
</blockquote>
<p><strong>Ajax（Asynchronous JavaScript + XML的简写）</strong>可以向服务器请求数据而无需卸载（刷新）页面，带来更好的用户体验。<br><strong>Ajax技术的核心是XMLHttpRequest对象（简称XHR）。</strong></p>
<h3 id="一、XMLHttpRequest对象"><a href="#一、XMLHttpRequest对象" class="headerlink" title="一、XMLHttpRequest对象"></a>一、XMLHttpRequest对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 兼容IE早期版本 */</span><br><span class="line">function createXHR()&#123;</span><br><span class="line">    if (typeof XMLHttpRequest != &quot;undefined&quot;)&#123;</span><br><span class="line">        return new XMLHttpRequest();</span><br><span class="line">    &#125; else if (typeof ActiveXObject != &quot;undefined&quot;)&#123;    // 适用于IE7之前的版本</span><br><span class="line">        if (typeof arguments.callee.activeXString != &quot;string&quot;)&#123;</span><br><span class="line">            var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;,</span><br><span class="line">                            &quot;MSXML2.XMLHttp&quot;],</span><br><span class="line">                i, len;</span><br><span class="line"></span><br><span class="line">            for (i=0,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    new ActiveXObject(versions[i]);</span><br><span class="line">                    arguments.callee.activeXString = versions[i];</span><br><span class="line">                    break;</span><br><span class="line">                &#125; catch (ex)&#123;</span><br><span class="line">                    //skip</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ActiveXObject(arguments.callee.activeXString);</span><br><span class="line">    &#125; else &#123;  // XHR对象和ActiveX对象都不存在，则抛出错误 </span><br><span class="line">        throw new Error(&quot;No XHR object available.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-XHR的用法"><a href="#1-XHR的用法" class="headerlink" title="1. XHR的用法"></a>1. XHR的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;请求的类型get|post等&quot;, &quot;请求的URL&quot;, &quot;是否异步发送请求&quot;);</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>（1）URL相对于执行代码的当前页面（当然也可以使用绝对路径）<br>（2）open()方法并不会真正发送请求，而只是启动一个请求以备发送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(&quot;请求主体发送的数据&quot;);</span><br></pre></td></tr></table></figure></p>
<p><strong>说明：</strong><br>（1）如果不需要通过请求主体发送数据（比如get请求），则必须传入null，因为这个参数对有些浏览器来说是必需的<br>（2）调用send()之后，请求就会被分派到服务器</p>
<p><strong>补充</strong>：xhr.open()方法为“false”，即同步请求，JavaScript代码会等到服务器响应后再继续执行；否则，继续执行后续代码。</p>
<p>在收到服务器响应后，相应的数据会自动填充XHR对象的属性。</p>
<ul>
<li>responseText：作为响应主体被返回的文本</li>
<li>responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM文档</li>
<li>status：响应的HTTP状态</li>
<li>statusText：HTTP状态的说明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 为确保接收到适当的响应 200:成功；304:资源未被修改</span><br><span class="line">if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>说明</strong>：<br>（1）有的浏览器会错误的报告成功状态码为204<br>（2）无论内容类型是什么，响应主体的内容都会保存到responseText属性中；而对于XML数据而言，responseXML同时也将被赋值，否则其值为null</p>
<p><strong>对于异步请求，可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段</strong></p>
<ul>
<li>0：未初始化。尚未调用open()方法</li>
<li>1：启动。已经调用open()方法，但尚未调用send()方法</li>
<li>2：发送。已经调用send()方法，但尚未接收到响应</li>
<li>3：接收。已经接收到部分响应数据</li>
<li>4：完成。已经接收全部响应数据，而且已经可以在客户端使用了。</li>
</ul>
<p>readyState属性的值发生变化，都会触发<strong>readystatechange</strong>事件。可以利用这个事件来检测每次状态变化后<strong>readyState</strong>的值。不过，<em>必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。</em></p>
<pre><code>var xhr = createXHR();        
xhr.onreadystatechange = function(event){
    // 不要使用this，作用域会产生问题，在部分浏览器中会执行失败
    if (xhr.readyState == 4){
        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){
            console.log(xhr.responseText);
        } else {
            console.log(&quot;Request was unsuccessful: &quot; + xhr.status);
        }
    }
};
xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);
xhr.send(null);
</code></pre><p>在接收到响应数据之前可以调用abort()方法来取消异步请求：</p>
<pre><code>xhr.abort();
xhr =null; // 解除引用，释放内存
</code></pre><h4 id="2-HTTP头部信息"><a href="#2-HTTP头部信息" class="headerlink" title="2. HTTP头部信息"></a>2. HTTP头部信息</h4><p><strong>setRequestHeader()</strong>：设置自定义的请求头信息。必须在调用open()方法之后且调用send()方法之前调用。<br><strong>getResponseHeader() getAllResponseHeaders()</strong>：可以获取指定（全部）响应头信息。</p>
<pre><code>var xhr = createXHR();        
xhr.onreadystatechange = function(){};
xhr.open(&quot;get&quot;, &quot;example.php&quot;, true);
xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;);
xhr.send(null);
</code></pre><h4 id="3-GET请求"><a href="#3-GET请求" class="headerlink" title="3. GET请求"></a>3. GET请求</h4><p><strong>open()</strong>方法的URL尾部的查询字符串必须经过正确的编码</p>
<pre><code>functionaddURLParam(url, name, value) {
    url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;);
    url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);
    return url;
}

var url = &quot;http://test.com&quot;;
url = addURLParam(url, &quot;uid&quot; , 5);
url = addURLParam(url, &quot;siteid&quot;, 123);  // &quot;http://test.com?uid=5&amp;siteid=123&quot;
xhr.open(&quot;get&quot;, url, true);
xhr.send(null);
</code></pre><h4 id="4-POST请求"><a href="#4-POST请求" class="headerlink" title="4. POST请求"></a>4. POST请求</h4><p>POST请求将数据作为请求的主体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/* 序列化表单 */</span><br><span class="line">function serialize(form)&#123;        </span><br><span class="line">    var parts = new Array();</span><br><span class="line">    var field = null;</span><br><span class="line"></span><br><span class="line">    for (var i=0, len=form.elements.length; i &lt; len; i++)&#123;</span><br><span class="line">        field = form.elements[i];</span><br><span class="line"></span><br><span class="line">        switch(field.type)&#123;</span><br><span class="line">            case &quot;select-one&quot;:</span><br><span class="line">            case &quot;select-multiple&quot;:</span><br><span class="line">                for (var j=0, optLen = field.options.length; j &lt; optLen; j++)&#123;</span><br><span class="line">                    var option = field.options[j];</span><br><span class="line">                    if (option.selected)&#123;</span><br><span class="line">                        var optValue = &quot;&quot;;</span><br><span class="line">                        if (option.hasAttribute)&#123;</span><br><span class="line">                            optValue = (option.hasAttribute(&quot;value&quot;) ? </span><br><span class="line">                                        option.value : option.text);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            optValue = (option.attributes[&quot;value&quot;].specified ? </span><br><span class="line">                                        option.value : option.text);</span><br><span class="line">                        &#125;</span><br><span class="line">                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; + </span><br><span class="line">                                   encodeURIComponent(optValue));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case undefined:     //fieldset</span><br><span class="line">            case &quot;file&quot;:        //file input</span><br><span class="line">            case &quot;submit&quot;:      //submit button</span><br><span class="line">            case &quot;reset&quot;:       //reset button</span><br><span class="line">            case &quot;button&quot;:      //custom button</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &quot;radio&quot;:       //radio button</span><br><span class="line">            case &quot;checkbox&quot;:    //checkbox</span><br><span class="line">                if (!field.checked)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                /* falls through */              </span><br><span class="line">            default:</span><br><span class="line">                parts.push(encodeURIComponent(field.name) + &quot;=&quot; + </span><br><span class="line">                    encodeURIComponent(field.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    return parts.join(&quot;&amp;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 发送请求 */</span><br><span class="line">function submitData()&#123;</span><br><span class="line">    var xhr = createXHR();        </span><br><span class="line">    xhr.onreadystatechange = function(event)&#123;</span><br><span class="line">        if (xhr.readyState == 4)&#123;</span><br><span class="line">            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">                alert(xhr.responseText);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);</span><br><span class="line">    // 表单提交的内容类型</span><br><span class="line">    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">    var form = document.getElementById(&quot;user-info&quot;);   </span><br><span class="line">    // 请求主体为数据         </span><br><span class="line">    xhr.send(serialize(form));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、XMLHttpRequest-2级"><a href="#二、XMLHttpRequest-2级" class="headerlink" title="二、XMLHttpRequest 2级"></a>二、XMLHttpRequest 2级</h3><p>XMLHttpRequest 1级只是把已有的XHR对象的实现细节描述了出来。而XMLHttpRequest 2级则进一步发展了XHR。并非所有浏览器都完整地实现了XMLHttpRequest 2级规范，但所有浏览器都实现了它规定的部分内容。</p>
<h4 id="1-FormData"><a href="#1-FormData" class="headerlink" title="1. FormData"></a>1. FormData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建FormData对象</span><br><span class="line">var data=new FormData();</span><br><span class="line">data.append(&quot;name&quot;, &quot;ligang&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 用表单元素填充</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);</span><br><span class="line">var form = document.getElementById(&quot;user-info&quot;);</span><br><span class="line">// 使用FormData的方便之处在于不必明确地在XHR对象上设置请求头。</span><br><span class="line">// xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.send(new FormData(form));</span><br></pre></td></tr></table></figure>
<h4 id="2-超时设定"><a href="#2-超时设定" class="headerlink" title="2. 超时设定"></a>2. 超时设定</h4><p>IE8为XHR对象添加了一个timeout属性，表示请求在等待响应多少毫秒后就终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);</span><br><span class="line">xhr.timeout = 60 * 1000;</span><br><span class="line">xhr.ontimeout = function()&#123;</span><br><span class="line">    alert(&quot;Request did not return in a second.&quot;);</span><br><span class="line">&#125;;        </span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></p>
<p>对于其他浏览器的兼容做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);</span><br><span class="line">xhr.onreadystatechange = function(event)&#123;if (xhr.readyState == 4)&#123;</span><br><span class="line">        // 清除定时器</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">            console.log(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置超时时间 1分钟</span><br><span class="line">var timeout = setTimeout(function() &#123;</span><br><span class="line">    xmlHttpRequest.abort();</span><br><span class="line">    xmlHttpRequest = null;</span><br><span class="line">&#125;, 60 * 1000);</span><br><span class="line">xmlHttpRequest.send(null);</span><br></pre></td></tr></table></figure></p>
<h4 id="3-overrideMimeType-方法"><a href="#3-overrideMimeType-方法" class="headerlink" title="3. overrideMimeType()方法"></a>3. overrideMimeType()方法</h4><p>重写XHR响应的MIME类型，<em>必须在send()方法之前</em>。</p>
<p>如果，服务器返回的MIME类型是text/plain，但数据中实际包含的是XML。根据MIME类型，responseXML属性中仍然是null。此时，通过<strong>overrideMimeType()</strong>方法，可以保证把响应当作XML而非纯文本来处理（即，responseXML中被赋值）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;text.php&quot;, true);</span><br><span class="line">xhr.overrideMimeType(&quot;text/xml&quot;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></p>
<h3 id="三、进度事件"><a href="#三、进度事件" class="headerlink" title="三、进度事件"></a>三、进度事件</h3><p>6个进度事件：</p>
<ul>
<li>loadstart：在接收到响应数据的第一个字节时触发。</li>
<li>progress：在接收响应期间持续不断地触发。</li>
<li>error：在请求发生错误时触发。</li>
<li>abort：在因为调用abort()方法而终止时触发。</li>
<li>load：在接收到完整的响应数据时触发。</li>
<li>loadend：在通信完成或者触发error、abort或load事件后触发。<br><img src="/2015/04/26/Ajax与Comet/20160419113844270.png" alt="图 进度事件"></li>
</ul>
<h4 id="1-load事件"><a href="#1-load事件" class="headerlink" title="1. load事件"></a>1. load事件</h4><p>可以代替readystatechagne事件。其处理程序会接收到一个event对象，其target属性指向XHR对象实例，因而可以访问到XHR对象的所有方法和属性。然而，并非所有浏览器都实现了事件对象。</p>
<h4 id="2-progress事件"><a href="#2-progress事件" class="headerlink" title="2. progress事件"></a>2. progress事件</h4><p>其处理程序会接收一个event对象，其target属性指向XHR对象实例，但包含着三个额外的属性</p>
<ul>
<li>lengthComputable：是一个表示进度信息是否可用的布尔值</li>
<li>position：表示已经接收的字节数</li>
<li>totalSize：根据content-length响应头确定的预期字节数<br><strong>注意</strong>：<em>其必须在调用open()方法之前添加</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();        </span><br><span class="line">xhr.onload = function(event)&#123;</span><br><span class="line">    // event.target存在兼容性问题，所以只能使用xhr</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) ||  xhr.status == 304)&#123;</span><br><span class="line">        console.log(xhr.responseText);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.onprogress = function(event)&#123;</span><br><span class="line">    var divStatus = document.getElementById(&quot;status&quot;);</span><br><span class="line">    if (event.lengthComputable)&#123;</span><br><span class="line">        divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize + &quot; bytes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="四、跨源资源共享"><a href="#四、跨源资源共享" class="headerlink" title="四、跨源资源共享"></a>四、跨源资源共享</h3><p><strong>CORS（Cross-Origin Resource Sharing）</strong>背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p>
<p>在发送请求时，给其附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。</p>
<pre><code>Origin: http://www.test.com
</code></pre><p>如果服务认为这个请求可以接受，在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发”*”）。</p>
<pre><code>Access-Control-Allow-Origin: http://www.test.com
</code></pre><p><strong>注意</strong>：请求和响应都不包含cookie信息。</p>
<h4 id="1-IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。"><a href="#1-IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。" class="headerlink" title="1. IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。"></a>1. IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。</h4><h4 id="2-其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open-方法传入绝对地址。支持同步请求。"><a href="#2-其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open-方法传入绝对地址。支持同步请求。" class="headerlink" title="2. 其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open()方法传入绝对地址。支持同步请求。"></a>2. 其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open()方法传入绝对地址。支持同步请求。</h4><p>跨域XHR对象的安全限制： </p>
<p>（1）不能使用setRequestHeader()设置自定义头部。 </p>
<p>（2）不能发送和接收cookie。 </p>
<p>（3）调用getAllResponseHeaders()方法总会返回空字符串。</p>
<p><strong>建议</strong>：访问本地资源，最好使用相对URL；访问远程资源，使用绝对URL。</p>
<h4 id="3-跨浏览器的CORS"><a href="#3-跨浏览器的CORS" class="headerlink" title="3. 跨浏览器的CORS"></a>3. 跨浏览器的CORS</h4><pre><code>functioncreateCORSRequest(method, url){var xhr = new XMLHttpRequest();
    if (&quot;withCredentials&quot;in xhr){    // 检测XHR是否支持CORS的简单方式，就是检测是否存在withCredentials属性
        xhr.open(method, url, true);
    } elseif (typeof XDomainRequest != &quot;undefined&quot;){    // IE XDR
        xhr = new XDomainRequest();
        xhr.open(method, url);
    } else {
        xhr = null;
    }
    return xhr;
}

var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/xdr.php&quot;);
if (request){
    request.onload = function(){//do something with request.responseText
    };
    request.send();
}
</code></pre><h3 id="五、其他跨域技术"><a href="#五、其他跨域技术" class="headerlink" title="五、其他跨域技术"></a>五、其他跨域技术</h3><p>利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求，其不需要修改服务器端代码。</p>
<h4 id="1-图像Ping"><a href="#1-图像Ping" class="headerlink" title="1. 图像Ping"></a>1. 图像Ping</h4><p><code>&lt;img&gt;</code>标签，可以从任何网页中加载图像，无需关注是否跨域。这也是广告跟踪浏览量的主要方式。 </p>
<p>图像Ping是与服务器进行简单、单向的跨域通信的一种方式。浏览器得不到任何具体的数据。但通过监听load和error事件，可以知道响应是什么时间接收到的。</p>
<pre><code>var img = new Image();
img.onload = img.error = function() {
    console.log(&quot;Done!&quot;);
};
img.src = &quot;http://www.test.com/getImage?id=1&quot;;
</code></pre><p><strong>缺点</strong>: </p>
<p>（1）只能发送Get请求 </p>
<p>（2）无法访问服务器的响应文本</p>
<h4 id="2-JSONP（JSON-with-padding）"><a href="#2-JSONP（JSON-with-padding）" class="headerlink" title="2. JSONP（JSON with padding）"></a>2. JSONP（JSON with padding）</h4><p>两部分组成：回调函数和数据。 </p>
<p>回调函数是当响应到来时应该在页面调用的函数。回到函数的名字一般是在请求中指定的。而数据是传入回调函数中的JSON数据。 </p>
<p>JSONP是通过动态<code>&lt;script&gt;</code>元素来使用的</p>
<pre><code>function handleResponse(response){
    alert(&quot;You&apos;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);
}

var script = document.createElement(&quot;script&quot;);
script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;
document.body.insertBefore(script, document.body.firstChild);
</code></pre><p><strong>优点</strong>：能够直接访问响应文本，支持在浏览器与服务器之间双向通信。<br><strong>缺点</strong>： </p>
<p>（1）JSONP是从其他域中加载代码执行，其安全性无法确保。 </p>
<p>（2）不能很容易的确定JSONP请求是否失败。</p>
<h4 id="3-Comet"><a href="#3-Comet" class="headerlink" title="3. Comet"></a>3. Comet</h4><p>更高级的Ajax技术，服务器向页面推送数据。 </p>
<p>Comet 本质上和 C/S 中的通信并不一样，它是通过长连接来模拟推送的。也就是说，在没有数据的时候，这个连接挂起，直到有数据来了（推送），服务器端返回响应，该连接结束，客户端的 JS 重新建立下一个等待连接。</p>
<p>这种方式并不像 C/S 通信建立长期使用的通道，只是长期“等待”而已，避免了在数据更新频率不大的情况下轮询的开销：试想如果五分钟才一次更新，那么轮询方式在此期间几秒钟就要发生一次请求&amp;响应，而这些请求响应都是没有价值的，因为它们并没有传输有用数据。Comet 避免的是这方面的浪费，不再有空请求，因为挂起的连接直到数据更新了才结束。</p>
<p>性能方面，对于数据量不大但需要实时更新的应用来说，Comet 能更有效利用连接，同时因为没有轮询的心跳频率，Comet 会比轮询更加实时——因为只消耗响应的网络传输时间。</p>
<p>但是 Comet 本身并不能在数据传输方面提供比轮询更高的效率，仅仅避免了轮询的空请求浪费。所以 Comet 和 web socket 之类的通讯方式差距还是有的。</p>
<p>大型网站的应用方面，知乎、QQ 邮箱都有用到 Comet，还有新浪微博的私信（聊天）。使用 Comet 主要需要是服务器端的支持，因为使用长连接，所以要有一定负载量一般得使用异步的网络框架，Python 的 tornado、gevent 和 JavaScript 的 node.js 都是此列。</p>
<p>两种实现Comet的方式：长轮询和流。<br><img src="/2015/04/26/Ajax与Comet/20160419114753780.png" alt="Ajax与Comet-Comet长轮询"></p>
<p>（1）长轮询：页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。【区别：短轮询，服务器立即发送响应，无论是否有效，而长轮询是等待发送响应。】</p>
<p>（2）HTTP流：生命周期内只使用一个HTTP连接。浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。</p>
<pre><code>/**
 * progress：接收数据时调用的函数
 * finished：关闭连接时调用的函数
 */
function createStreamingClient(url, progress, finished){
 var xhr = new XMLHttpRequest(),
        received = 0;

    xhr.open(&quot;get&quot;, url, true);
    xhr.onreadystatechange = function(){var result;
        if (xhr.readyState == 3){
            //get only the new data and adjust counter
            result = xhr.responseText.substring(received);
            received += result.length;

            //call the progress callback
            progress(result);
        } elseif (xhr.readyState == 4){
            finished(xhr.responseText);
        }
    };
    xhr.send(null);
    return xhr;
}

var client = createStreamingClient(&quot;streaming.php&quot;,function(data){alert(&quot;Received: &quot; + data);}, function(data){alert(&quot;Done!&quot;);});
</code></pre><p>服务器发送事件：SSE和事件流</p>
<h4 id="4-Web-Sockets"><a href="#4-Web-Sockets" class="headerlink" title="4. Web Sockets"></a>4. Web Sockets</h4><p>目标是在一个单独的持久连接上提供全双工、双向通信。 </p>
<p>优点：能够在客户端和服务器之间发送非常少量的数据，而不必担心HTTP那样字节级的开销。 </p>
<p>缺点：制定协议的时间比制定JavaScript API的时间还要长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 必须给WebSocket构造函数传入绝对URL</span><br><span class="line">var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);</span><br><span class="line">// 向服务器发送数据（只能发送纯文本，其他数据需要序列化）</span><br><span class="line">socket.send(&quot;Hello&quot;);</span><br><span class="line">// 接收服务器的响应数据</span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">    var data = event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>其他事件：</p>
<ul>
<li>open：在成功建立连接时触发。</li>
<li>error：在发生错误时触发，连接不能持续。</li>
<li>close：在连接关闭时触发。</li>
</ul>
<p><strong>注意</strong>：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/02/十大经典排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/02/十大经典排序算法/" itemprop="url">十大经典排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-02T19:53:53+08:00">
                2015-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><p>十种常见排序算法可以分为两大类：</p>
<blockquote>
<p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。<br><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 </p>
</blockquote>
<p><img src="/2015/01/02/十大经典排序算法/849589-20180402132530342-980121409.png" alt=""></p>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20180402133438219-1946132192.png" alt=""></p>
<p><strong>相关概念</strong></p>
<blockquote>
<p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。<br><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </p>
</blockquote>
<h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p>
<h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<p><strong>1.2 动图演示</strong></p>
<p><img src="/2015/01/02/十大经典排序算法/849589-20171015223238449-2146169197.gif" alt=""></p>
<h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p>
<h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015224719590-1433219824.gif" alt=""></p>
<h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数</span><br><span class="line">                minIndex = j;                 // 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h4><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p>
<h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015225645277-1151100000.gif" alt=""></p>
<h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var preIndex, current;</span><br><span class="line">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h4><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h3 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20180331170017421-364506073.gif" alt=""></p>
<h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = 1;</span><br><span class="line">    while (gap &lt; len / 3) &#123;          // 动态定义间隔序列</span><br><span class="line">        gap = gap * 3 + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123;</span><br><span class="line">        for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p>
<h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015230557043-37375010.gif" alt=""></p>
<h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(arr) &#123;  // 采用自上而下的递归方法</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    if (len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line"> </span><br><span class="line">    while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;</span><br><span class="line">        if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p>
<h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015230936371-1413523412.gif" alt=""></p>
<h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != &apos;number&apos; ? 0 : left,</span><br><span class="line">        right = typeof right != &apos;number&apos; ? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-1);</span><br><span class="line">        quickSort(arr, partitionIndex+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function partition(arr, left ,right) &#123;     // 分区操作</span><br><span class="line">    var pivot = left,                      // 设定基准值（pivot）</span><br><span class="line">        index = pivot + 1;</span><br><span class="line">    for (var i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - 1);</span><br><span class="line">    return index-1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul>
<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>
<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>
</ul>
<h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015231308699-356134237.gif" alt=""></p>
<h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"> </span><br><span class="line">function buildMaxHeap(arr) &#123;   // 建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function heapify(arr, i) &#123;     // 堆调整</span><br><span class="line">    var left = 2 * i + 1,</span><br><span class="line">        right = 2 * i + 2,</span><br><span class="line">        largest = i;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"> </span><br><span class="line">    for (var i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015231740840-6968181.gif" alt=""></p>
<h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket = new Array(maxValue + 1),</span><br><span class="line">        sortedIndex = 0;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + 1;</span><br><span class="line"> </span><br><span class="line">    for (var i = 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (var j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。 </li>
</ul>
<h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015232107090-1920702011.png" alt=""></p>
<h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length === 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  </span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = 0;</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p>
<h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015232453668-1397662527.gif" alt=""> </p>
<h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// LSD Radix Sort</span><br><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            if(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            if(counter[j]!=null) &#123;</span><br><span class="line">                while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/01/01/JS原生常用API大全/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/01/01/JS原生常用API大全/" itemprop="url">JS原生常用API大全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-01-01T21:11:22+08:00">
                2015-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="原生JS-API"><a href="#原生JS-API" class="headerlink" title="原生JS API"></a>原生JS API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br></pre></td><td class="code"><pre><span class="line">一、节点</span><br><span class="line">1.1 节点属性</span><br><span class="line">Node.nodeName   //返回节点名称，只读</span><br><span class="line">Node.nodeType   //返回节点类型的常数值，只读</span><br><span class="line">Node.nodeValue  //返回Text或Comment节点的文本值，只读</span><br><span class="line">Node.textContent  //返回当前节点和它的所有后代节点的文本内容，可读写</span><br><span class="line">Node.baseURI    //返回当前网页的绝对路径</span><br><span class="line"></span><br><span class="line">Node.ownerDocument  //返回当前节点所在的顶层文档对象，即document</span><br><span class="line">Node.nextSibling  //返回紧跟在当前节点后面的第一个兄弟节点</span><br><span class="line">Node.previousSibling  //返回当前节点前面的、距离最近的一个兄弟节点</span><br><span class="line">Node.parentNode   //返回当前节点的父节点</span><br><span class="line">Node.parentElement  //返回当前节点的父Element节点</span><br><span class="line">Node.childNodes   //返回当前节点的所有子节点</span><br><span class="line">Node.firstChild  //返回当前节点的第一个子节点</span><br><span class="line">Node.lastChild   //返回当前节点的最后一个子节点</span><br><span class="line"></span><br><span class="line">//parentNode接口</span><br><span class="line">Node.children  //返回指定节点的所有Element子节点</span><br><span class="line">Node.firstElementChild  //返回当前节点的第一个Element子节点</span><br><span class="line">Node.lastElementChild   //返回当前节点的最后一个Element子节点</span><br><span class="line">Node.childElementCount  //返回当前节点所有Element子节点的数目。</span><br><span class="line">1.2 操作</span><br><span class="line">Node.appendChild(node)   //向节点添加最后一个子节点</span><br><span class="line">Node.hasChildNodes()   //返回布尔值，表示当前节点是否有子节点</span><br><span class="line">Node.cloneNode(true);  // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)</span><br><span class="line">Node.insertBefore(newNode,oldNode)  // 在指定子节点之前插入新的子节点</span><br><span class="line">Node.removeChild(node)   //删除节点，在要删除节点的父节点上操作</span><br><span class="line">Node.replaceChild(newChild,oldChild)  //替换节点</span><br><span class="line">Node.contains(node)  //返回一个布尔值，表示参数节点是否为当前节点的后代节点。</span><br><span class="line">Node.compareDocumentPosition(node)   //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系</span><br><span class="line">Node.isEqualNode(noe)  //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</span><br><span class="line">Node.normalize()   //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。</span><br><span class="line"></span><br><span class="line">//ChildNode接口</span><br><span class="line">Node.remove()  //用于删除当前节点</span><br><span class="line">Node.before()  //</span><br><span class="line">Node.after()</span><br><span class="line">Node.replaceWith()</span><br><span class="line">1.3 Document节点</span><br><span class="line">1.3.1 Document节点的属性</span><br><span class="line">document.doctype   //</span><br><span class="line">document.documentElement  //返回当前文档的根节点</span><br><span class="line">document.defaultView   //返回document对象所在的window对象</span><br><span class="line">document.body   //返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head   //返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement  //返回当前文档中获得焦点的那个元素。</span><br><span class="line"></span><br><span class="line">//节点集合属性</span><br><span class="line">document.links  //返回当前文档的所有a元素</span><br><span class="line">document.forms  //返回页面中所有表单元素</span><br><span class="line">document.images  //返回页面中所有图片元素</span><br><span class="line">document.embeds  //返回网页中所有嵌入对象</span><br><span class="line">document.scripts  //返回当前文档的所有脚本</span><br><span class="line">document.styleSheets  //返回当前网页的所有样式表</span><br><span class="line"></span><br><span class="line">//文档信息属性</span><br><span class="line">document.documentURI  //表示当前文档的网址</span><br><span class="line">document.URL  //返回当前文档的网址</span><br><span class="line">document.domain  //返回当前文档的域名</span><br><span class="line">document.lastModified  //返回当前文档最后修改的时间戳</span><br><span class="line">document.location  //返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer  //返回当前文档的访问来源</span><br><span class="line">document.title    //返回当前文档的标题</span><br><span class="line">document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。</span><br><span class="line">document.readyState  //返回当前文档的状态</span><br><span class="line">document.designMode  //控制当前文档是否可编辑，可读写</span><br><span class="line">document.compatMode  //返回浏览器处理文档的模式</span><br><span class="line">document.cookie   //用来操作Cookie</span><br><span class="line">1.3.2 Document节点的方法</span><br><span class="line">（1）读写方法</span><br><span class="line">document.open()   //用于新建并打开一个文档</span><br><span class="line">document.close()   //不安比open方法所新建的文档</span><br><span class="line">document.write()   //用于向当前文档写入内容</span><br><span class="line">document.writeIn()  //用于向当前文档写入内容，尾部添加换行符。</span><br><span class="line">（2）查找节点</span><br><span class="line">document.querySelector(selectors)   //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。</span><br><span class="line">document.querySelectorAll(selectors)  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。</span><br><span class="line">document.getElementsByTagName(tagName)  //返回所有指定HTML标签的元素</span><br><span class="line">document.getElementsByClassName(className)   //返回包括了所有class名字符合指定条件的元素</span><br><span class="line">document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）</span><br><span class="line">document.getElementById(id)   //返回匹配指定id属性的元素节点。</span><br><span class="line">document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。</span><br><span class="line">（3）生成节点</span><br><span class="line">document.createElement(tagName)   //用来生成HTML元素节点。</span><br><span class="line">document.createTextNode(text)   //用来生成文本节点</span><br><span class="line">document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。</span><br><span class="line">document.createDocumentFragment()  //生成一个DocumentFragment对象</span><br><span class="line">（4）事件方法</span><br><span class="line">document.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span><br><span class="line">document.addEventListener(type,listener,capture)  //注册事件</span><br><span class="line">document.removeEventListener(type,listener,capture)  //注销事件</span><br><span class="line">document.dispatchEvent(event)  //触发事件</span><br><span class="line">（5）其他</span><br><span class="line">document.hasFocus()   //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</span><br><span class="line">document.adoptNode(externalNode)  //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。</span><br><span class="line">document.importNode(externalNode, deep)   //从外部文档拷贝指定节点，插入当前文档。</span><br><span class="line">1.4 Element节点</span><br><span class="line">1.4.1 Element节点的属性</span><br><span class="line">（1）特性属性</span><br><span class="line">Element.attributes  //返回当前元素节点的所有属性节点</span><br><span class="line">Element.id  //返回指定元素的id属性，可读写</span><br><span class="line">Element.tagName  //返回指定元素的大写标签名</span><br><span class="line">Element.innerHTML   //返回该元素包含的HTML代码，可读写</span><br><span class="line">Element.outerHTML  //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写</span><br><span class="line">Element.className  //返回当前元素的class属性，可读写</span><br><span class="line">Element.classList  //返回当前元素节点的所有class集合</span><br><span class="line">Element.dataset   //返回元素节点中所有的data-*属性。</span><br><span class="line">（2）尺寸属性</span><br><span class="line">Element.clientHeight   //返回元素节点可见部分的高度</span><br><span class="line">Element.clientWidth   //返回元素节点可见部分的宽度</span><br><span class="line">Element.clientLeft   //返回元素节点左边框的宽度</span><br><span class="line">Element.clientTop   //返回元素节点顶部边框的宽度</span><br><span class="line">Element.scrollHeight  //返回元素节点的总高度</span><br><span class="line">Element.scrollWidth  //返回元素节点的总宽度</span><br><span class="line">Element.scrollLeft   //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置</span><br><span class="line">Element.scrollTop   //返回元素节点的垂直滚动向下滚动的像素数值</span><br><span class="line">Element.offsetHeight   //返回元素的垂直高度(包含border,padding)</span><br><span class="line">Element.offsetWidth    //返回元素的水平宽度(包含border,padding)</span><br><span class="line">Element.offsetLeft    //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移</span><br><span class="line">Element.offsetTop   //返回水平位移</span><br><span class="line">Element.style  //返回元素节点的行内样式</span><br><span class="line">（3）节点相关属性</span><br><span class="line">Element.children   //包括当前元素节点的所有子元素</span><br><span class="line">Element.childElementCount   //返回当前元素节点包含的子HTML元素节点的个数</span><br><span class="line">Element.firstElementChild  //返回当前节点的第一个Element子节点  </span><br><span class="line">Element.lastElementChild   //返回当前节点的最后一个Element子节点  </span><br><span class="line">Element.nextElementSibling  //返回当前元素节点的下一个兄弟HTML元素节点</span><br><span class="line">Element.previousElementSibling  //返回当前元素节点的前一个兄弟HTML节点</span><br><span class="line">Element.offsetParent   //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。</span><br><span class="line">1.4.2 Element节点的方法</span><br><span class="line">（1）位置方法</span><br><span class="line">getBoundingClientRect()  </span><br><span class="line">// getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高</span><br><span class="line">// top 元素上外边界距窗口最上面的距离</span><br><span class="line">// right 元素右外边界距窗口最上面的距离</span><br><span class="line">// bottom 元素下外边界距窗口最上面的距离</span><br><span class="line">// left 元素左外边界距窗口最上面的距离</span><br><span class="line">// width 元素自身宽(包含border,padding) </span><br><span class="line">// height 元素自身高(包含border,padding) </span><br><span class="line"></span><br><span class="line">getClientRects()   //返回当前元素在页面上形参的所有矩形。</span><br><span class="line"></span><br><span class="line">// 元素在页面上的偏移量  </span><br><span class="line">var rect = el.getBoundingClientRect()  </span><br><span class="line">return &#123;   </span><br><span class="line">  top: rect.top + document.body.scrollTop,   </span><br><span class="line">  left: rect.left + document.body.scrollLeft  </span><br><span class="line">&#125;</span><br><span class="line">（2）属性方法</span><br><span class="line">Element.getAttribute()：读取指定属性  </span><br><span class="line">Element.setAttribute()：设置指定属性  </span><br><span class="line">Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  </span><br><span class="line">Element.removeAttribute()：移除指定属性</span><br><span class="line">（3）查找方法</span><br><span class="line">Element.querySelector()  </span><br><span class="line">Element.querySelectorAll()  </span><br><span class="line">Element.getElementsByTagName()  </span><br><span class="line">Element.getElementsByClassName()</span><br><span class="line">（4）事件方法</span><br><span class="line">Element.addEventListener()：添加事件的回调函数  </span><br><span class="line">Element.removeEventListener()：移除事件监听函数  </span><br><span class="line">Element.dispatchEvent()：触发事件</span><br><span class="line"></span><br><span class="line">//ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line"></span><br><span class="line">// event对象  </span><br><span class="line">var event = window.event||event;    </span><br><span class="line"></span><br><span class="line">// 事件的目标节点  </span><br><span class="line">var target = event.target || event.srcElement;</span><br><span class="line"></span><br><span class="line">// 事件代理  </span><br><span class="line">ul.addEventListener(&apos;click&apos;, function(event) &#123;   </span><br><span class="line">  if (event.target.tagName.toLowerCase() === &apos;li&apos;) &#123;   </span><br><span class="line">    console.log(event.target.innerHTML)   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);</span><br><span class="line">（5）其他</span><br><span class="line">Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域</span><br><span class="line"></span><br><span class="line">//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。</span><br><span class="line">Element.insertAdjacentHTML(where, htmlString); </span><br><span class="line">Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入  </span><br><span class="line">Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 </span><br><span class="line">Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 </span><br><span class="line">Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入</span><br><span class="line"></span><br><span class="line">Element.remove()  //用于将当前元素节点从DOM中移除</span><br><span class="line">Element.focus()   //用于将当前页面的焦点，转移到指定元素上</span><br><span class="line">二、CSS操作</span><br><span class="line">（1）类名操作</span><br><span class="line">//ie8以下</span><br><span class="line">Element.className  //获取元素节点的类名</span><br><span class="line">Element.className += &apos; &apos; + newClassName  //新增一个类名</span><br><span class="line"></span><br><span class="line">//判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;</span><br><span class="line">  return new RegExp(className,&apos;gi&apos;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除class</span><br><span class="line">function removeClass(element,className)&#123;</span><br><span class="line">  element.className = element.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ie10 </span><br><span class="line">element.classList.add(className)  //新增</span><br><span class="line">element.classList.remove(className)  //删除</span><br><span class="line">element.classList.contains(className)  //是否包含</span><br><span class="line">element.classList.toggle(className)  //toggle class</span><br><span class="line">（2）style操作</span><br><span class="line">element.setAttribute(&apos;style&apos;,&apos;&apos;)</span><br><span class="line"></span><br><span class="line">element.style.backgroundColor = &apos;red&apos;</span><br><span class="line"></span><br><span class="line">element.style.cssText //用来读写或删除整个style属性</span><br><span class="line"></span><br><span class="line">element.style.setProperty(propertyName,value)  //设置css属性</span><br><span class="line">element.style.getPropertyValue(property)  //获取css属性</span><br><span class="line">element.style.removeProperty(property)  //删除css属性</span><br><span class="line">操作非内联样式</span><br><span class="line">//ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">//ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName] </span><br><span class="line">window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">//伪类</span><br><span class="line">window.getComputedStyle(el,&apos;:after&apos;)[attrName]</span><br><span class="line">三、对象</span><br><span class="line">3.1 Object对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var o = new Object()</span><br><span class="line">（2）属性</span><br><span class="line">Object.prototype   //返回原型对象</span><br><span class="line">（3）方法</span><br><span class="line">Object.keys(o)   //遍历对象的可枚举属性</span><br><span class="line">Object.getOwnPropertyName(o)   //遍历对象不可枚举的属性</span><br><span class="line">对象实例的方法</span><br><span class="line">valueOf()：返回当前对象对应的值。  </span><br><span class="line">toString()：返回当前对象对应的字符串形式。  </span><br><span class="line">toLocaleString()：返回当前对象对应的本地字符串形式。  </span><br><span class="line">hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 </span><br><span class="line">isPrototypeOf()：判断当前对象是否为另一个对象的原型。</span><br><span class="line">propertyIsEnumerable()：判断某个属性是否可枚举。</span><br><span class="line">3.2 Array对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var a = new Array()</span><br><span class="line">（2）属性</span><br><span class="line">a.length  //长度</span><br><span class="line">（3）Array.isArray()</span><br><span class="line">Array.isArray(a)   //用来判断一个值是否为数组</span><br><span class="line">（4）Array实例的方法</span><br><span class="line"></span><br><span class="line">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</span><br><span class="line"></span><br><span class="line">a.valueof()   //返回数组本身</span><br><span class="line">a.toString()  //返回数组的字符串形式</span><br><span class="line">a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。</span><br><span class="line">pop()   //用于删除数组的最后一个元素，并返回该元素</span><br><span class="line">join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。</span><br><span class="line">concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。</span><br><span class="line">shift()  //用于删除数组的第一个元素，并返回该元素。</span><br><span class="line">unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</span><br><span class="line">reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组</span><br><span class="line">slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。</span><br><span class="line">splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</span><br><span class="line">sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。</span><br><span class="line">map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。</span><br><span class="line">map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。</span><br><span class="line">forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。</span><br><span class="line">filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</span><br><span class="line">some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。</span><br><span class="line">every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。</span><br><span class="line">reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）</span><br><span class="line">reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）</span><br><span class="line">indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置</span><br><span class="line">lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">3.3 Number对象</span><br><span class="line">（1）生成对象</span><br><span class="line">var n = new Number()</span><br><span class="line">（2）Number对象的属性</span><br><span class="line">Number.POSITIVE_INFINITY：正的无限，指向Infinity。  </span><br><span class="line">Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。  </span><br><span class="line">Number.NaN：表示非数值，指向NaN。  </span><br><span class="line">Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。  </span><br><span class="line">Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。  </span><br><span class="line">Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。  </span><br><span class="line">Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</span><br><span class="line">（4）Number对象实例的方法</span><br><span class="line">toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</span><br><span class="line">toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。</span><br><span class="line">toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。</span><br><span class="line">toPrecision()  //用于将一个数转为指定位数的有效数字。</span><br><span class="line">3.4 String 对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var s = new String()</span><br><span class="line">（2）String对象的属性</span><br><span class="line">s.length   //返回字符串的长度</span><br><span class="line">（3）方法</span><br><span class="line">s.chatAt(index)   //返回指定位置的字符    //&quot;123456&quot;[0] == &quot;1&quot;</span><br><span class="line">s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。</span><br><span class="line">s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）</span><br><span class="line">s.concat(s2)  //用于连接两个字符串</span><br><span class="line">s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</span><br><span class="line">s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。</span><br><span class="line">s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</span><br><span class="line">s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 </span><br><span class="line">s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">s.trim()  //用于去除字符串两端的空格，返回一个新字符串</span><br><span class="line">s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。</span><br><span class="line">s.toUpperCase()  //全部转为大写</span><br><span class="line">s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</span><br><span class="line">s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</span><br><span class="line">s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</span><br><span class="line">s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</span><br><span class="line">s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。</span><br><span class="line">3.5 Math对象</span><br><span class="line">（1）属性</span><br><span class="line">Math.E：常数e。  </span><br><span class="line">Math.LN2：2的自然对数。  </span><br><span class="line">Math.LN10：10的自然对数。  </span><br><span class="line">Math.LOG2E：以2为底的e的对数。  </span><br><span class="line">Math.LOG10E：以10为底的e的对数。  </span><br><span class="line">Math.PI：常数Pi。  </span><br><span class="line">Math.SQRT1_2：0.5的平方根。  </span><br><span class="line">Math.SQRT2：2的平方根。</span><br><span class="line">（2）数学方法</span><br><span class="line">Math.abs()：返回参数的绝对值  </span><br><span class="line">Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 </span><br><span class="line">Math.floor()：向下取整  </span><br><span class="line">Math.max(n,n1,...)：可接受多个参数，返回最大值  </span><br><span class="line">Math.min(n,n1,..)：可接受多个参数，返回最小值  </span><br><span class="line">Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 </span><br><span class="line">Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。  </span><br><span class="line">Math.log()：返回以e为底的自然对数值。</span><br><span class="line">Math.exp()：返回e的指数，也就是常数e的参数次方。</span><br><span class="line">Math.round()：四舍五入  </span><br><span class="line">Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</span><br><span class="line">（3）三角函数方法</span><br><span class="line">Math.sin()：返回参数的正弦  </span><br><span class="line">Math.cos()：返回参数的余弦  </span><br><span class="line">Math.tan()：返回参数的正切  </span><br><span class="line">Math.asin()：返回参数的反正弦（弧度值）  </span><br><span class="line">Math.acos()：返回参数的反余弦（弧度值）  </span><br><span class="line">Math.atan()：返回参数的反正切（弧度值）</span><br><span class="line">3.6 JSON对象</span><br><span class="line">（1）方法</span><br><span class="line">JSON.stringify()   </span><br><span class="line">//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。</span><br><span class="line">//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</span><br><span class="line">//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</span><br><span class="line"></span><br><span class="line">JSON.parse()   //用于将JSON字符串转化成对象。</span><br><span class="line">3.7 console对象</span><br><span class="line">（1）方法</span><br><span class="line">console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</span><br><span class="line">console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。</span><br><span class="line">console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。</span><br><span class="line">console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；</span><br><span class="line">console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈</span><br><span class="line">console.table()  //可以将复合类型的数据转为表格显示。</span><br><span class="line">console.count()  //用于计数，输出它被调用了多少次。</span><br><span class="line">console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</span><br><span class="line">console.dirxml()  //用于以目录树的形式，显示DOM节点。</span><br><span class="line">console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</span><br><span class="line"></span><br><span class="line">//这两个方法用于计时，可以算出一个操作所花费的准确时间。</span><br><span class="line">console.time()</span><br><span class="line">console.timeEnd()</span><br><span class="line">//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。</span><br><span class="line"></span><br><span class="line">console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。</span><br><span class="line">console.profileEnd()  //用来结束正在运行的性能测试器。</span><br><span class="line"></span><br><span class="line">console.group()</span><br><span class="line">console.groupend()</span><br><span class="line">//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</span><br><span class="line">console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</span><br><span class="line"></span><br><span class="line">console.trace()  //显示当前执行的代码在堆栈中的调用路径。</span><br><span class="line">console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正则表达式：</span><br><span class="line">只允许输入汉字：onkeyup=&quot;value=value.replace(/[^\u4E00-\u9FA5]/g,&apos;&apos;)&quot; </span><br><span class="line">只允许输入数字：onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot;</span><br><span class="line">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure>
<h3 id="setTimeout-fn-0-的作用"><a href="#setTimeout-fn-0-的作用" class="headerlink" title="setTimeout(fn, 0) 的作用"></a>setTimeout(fn, 0) 的作用</h3><blockquote>
<p>setTimeout（0）单线程和异步队列<br>setTimeout和setInterval是JS内置的两个定时器，使用很简单，但这两个方法背后的原理却不简单。<br>我们知道，JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，<br>主线程会形成一个全局执行环境，执行环境采用栈的方式将待执行任务按顺序依次来执行。<br>但在浏览器中有一些任务是非常耗时的，比如http请求、定时器、事件回调等，为了保证其他任务的执行效率不被影响，<br>JS在执行环境中维护了一个异步队列(也叫工作线程)，并将这些任务放入队列中进行等待，这些任务的执行时机并不确定，<br>只有当主线程的任务执行完成以后，才会去检查异步队列中的任务是否需要开始执行。这就是为什么setTimeout(fn,0)<br> 始终要等到最后执行的原因。关于单线程和异步队列问题请参考：setTimeout（0）</p>
</blockquote>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(p, c) &#123;</span><br><span class="line">  var c = c || &#123;&#125;;</span><br><span class="line">  for (var i in p) &#123;</span><br><span class="line">    if (typeof p[i] === &apos;object&apos;) &#123;</span><br><span class="line">      c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class="line">      deepCopy(p[i], c[i]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="POST和GET的区别，HTTP状态码"><a href="#POST和GET的区别，HTTP状态码" class="headerlink" title="POST和GET的区别，HTTP状态码"></a>POST和GET的区别，HTTP状态码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST和GET的区别</span><br><span class="line">GET在浏览器回退时是无害的，而POST会再次提交请求</span><br><span class="line">GET产生的URL地址可以被收藏，而POST不可以</span><br><span class="line">GET请求会被浏览器主动缓存，而POST不会，除非手动设置</span><br><span class="line">GET请求只能进行URL编码，而POST支持多种编码方式</span><br><span class="line">GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</span><br><span class="line">GET请求在URL中传送的参数是有长度限制的，而POST没有长度限制</span><br><span class="line">对参数的数据类型，GET只能请求ASCII字符，而POST没有限制</span><br><span class="line">GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传敏感信息</span><br><span class="line">GET参数通过URL传递，POST放在Request body中</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP状态码</span><br><span class="line">1XX：指示信息-表示请求已接受，继续处理</span><br><span class="line">2XX：成功-表示请求已被成功接收200 OK ：客户端请求成功</span><br><span class="line">206 Partial Content：客户发送一个带有Range头的GET请求，服务器完成了它 播放视频和音频</span><br><span class="line">3XX：重定向-要完成请求必须进行更进一步的操作301 Move Permanently：所请求的页面已经转移至新的URL</span><br><span class="line">302 Found：所请求的页面已经临时转移到新的URL</span><br><span class="line">304 Not Modified：客户端有缓冲的文档并发出一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用</span><br><span class="line">4XX：客户端错误-请求有语法错误或请求无法实现400 Bad Request：客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class="line">403 Forbidden：对被请求页面的访问被禁止</span><br><span class="line">404 Not Found：请求资源不存在</span><br><span class="line">5XX：服务错误-服务器未能实现合法的请求500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</span><br><span class="line">503 Server Unavailable：请求未完成，服务器临时过载或当机，一段事件后恢复正常</span><br></pre></td></tr></table></figure>
<h3 id="301和302"><a href="#301和302" class="headerlink" title="301和302"></a>301和302</h3><blockquote>
<font color="#ff0000"><strong> 301与302：二者都是进行重定向，前者为永久重定向，后者为临时重定向。301，302对用户来说没有区别，他们看到效果只是一个跳转，浏览器中旧的URL变成了新的URL。实际工作中，当我们的前一个域名被永久性停止使用，并且不希望用户还能访问以前的域名时，我们会用到301。</strong></font>
</blockquote>
<blockquote>
<font color="#0000ff">301和302状态码都表示重定向，<span style="border-bottom:2px solid red;">就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。</span>他们的不同在于:301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了）， 搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问）， 这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</font>
</blockquote>
<p><strong> 301重定向和302重定向的区别: </strong></p>
<ul>
<li>302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。</li>
<li>而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">301适合永久重定向</span><br><span class="line">　　301比较常用的场景是使用域名跳转。</span><br><span class="line">       比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，</span><br><span class="line">        发送请求之后，就会返回301状态码，</span><br><span class="line">       然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。 </span><br><span class="line">　　注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。</span><br><span class="line">　    或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。</span><br><span class="line"></span><br><span class="line">302用来做临时跳转</span><br><span class="line">　　比如未登陆的用户访问用户中心重定向到登录页面。</span><br><span class="line">　　访问404页面会重新定向到首页。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">301—永久移动。被请求的资源已被永久移动位置； 【永久重定向】</span><br><span class="line">302—请求的资源现在临时从不同的 URI 响应请求；  【临时重定向】</span><br><span class="line">305—使用代理。被请求的资源必须通过指定的代理才能被访问； </span><br><span class="line">307—临时跳转。被请求的资源在临时从不同的URL响应请求； </span><br><span class="line">400—错误请求； </span><br><span class="line">402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付； </span><br><span class="line">403—禁止访问。服务器已经理解请求，但是拒绝执行它； </span><br><span class="line">404—找不到对象。请求失败，资源不存在； </span><br><span class="line">406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体； </span><br><span class="line">408—请求超时； </span><br><span class="line">409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成； </span><br><span class="line">410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址； </span><br><span class="line">413—响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。 </span><br><span class="line">417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足； </span><br><span class="line">418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现； </span><br><span class="line">420—方法失效。 </span><br><span class="line">422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应； </span><br><span class="line">500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理；</span><br></pre></td></tr></table></figure>
<h3 id="JS返回所有子节点对象childNodes"><a href="#JS返回所有子节点对象childNodes" class="headerlink" title="JS返回所有子节点对象childNodes"></a>JS返回所有子节点对象childNodes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mylist = document.getElementById(&apos;myid&apos;);</span><br><span class="line">for(var i=0,i&lt;mylist.childNodes.length;i++)&#123;</span><br><span class="line">console.log(mylist.childNodes[i]);</span><br><span class="line">&#125;</span><br><span class="line">firstChild返回第一个子节点</span><br><span class="line">lastChild返回最后一个子节点</span><br><span class="line">parentNode返回父节点对象</span><br><span class="line">nextSibling返回下一个兄弟节点对象</span><br><span class="line">previousSibling返回前一个兄弟节点对象</span><br><span class="line">nodeName返回节点的HTML标记名称</span><br></pre></td></tr></table></figure>
<h3 id="insertBefore-插入节点（父节点内容的最前面）"><a href="#insertBefore-插入节点（父节点内容的最前面）" class="headerlink" title="insertBefore()插入节点（父节点内容的最前面）"></a>insertBefore()插入节点（父节点内容的最前面）</h3><p>注意：insertBefore()有两个参数，第一个是插入的节点，第二个是插入的位置</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = document.getElementById(&apos;myList&apos;);</span><br><span class="line">list.insertBefore(newItem,list.childNodes[1]);</span><br><span class="line">//插入新节点newItem到list的第二个子节点</span><br></pre></td></tr></table></figure></p>
<h3 id="Element-matches-精确匹配"><a href="#Element-matches-精确匹配" class="headerlink" title="Element.matches 精确匹配"></a>Element.matches 精确匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;list&apos;).addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  var event = e || window.event;</span><br><span class="line">  var target = event.target || event.srcElement;</span><br><span class="line">  if (target.matches(&apos;li.class-1&apos;)) &#123;</span><br><span class="line">    console.log(&apos;the content is: &apos;, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="移动端touch事件-区分webkit-和-winphone"><a href="#移动端touch事件-区分webkit-和-winphone" class="headerlink" title="移动端touch事件(区分webkit 和 winphone)"></a>移动端touch事件(区分webkit 和 winphone)</h3><blockquote>
<p>当用户手指放在移动设备在屏幕上滑动会触发的touch事件,以下支持webkit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指</span><br><span class="line">touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动</span><br><span class="line">touchend——当手指离开屏幕时触发</span><br><span class="line">touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用TouchEvent</span><br><span class="line">touches：屏幕上所有手指的信息</span><br><span class="line">targetTouches：手指在目标区域的手指信息</span><br><span class="line">changedTouches：最近一次触发该事件的手指信息</span><br><span class="line">touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息参数信息(changedTouches[0])</span><br><span class="line">clientX、clientY在显示区的坐标</span><br><span class="line">target：当前元素</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="全局错误监控"><a href="#全局错误监控" class="headerlink" title="全局错误监控"></a>全局错误监控</h3><p>监听window上的error事件，过滤事件代理的error。</p>
<h3 id="手动触发一个dom事件，需要3步，如果你对document-createEvent-�不是很熟悉，可以点击查看。"><a href="#手动触发一个dom事件，需要3步，如果你对document-createEvent-�不是很熟悉，可以点击查看。" class="headerlink" title="手动触发一个dom事件，需要3步，如果你对document.createEvent,�不是很熟悉，可以点击查看。"></a>手动触发一个dom事件，需要3步，如果你对document.createEvent,�不是很熟悉，可以点击查看。</h3><p>创建一个事件对象 document.createEvent(event)<br>初始化事件对象 event.initEvent(type, bubbles, true)<br>分发事件 dom.dispatchEvent(event)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Object.preventExtensions(obj)  让一个对象变的不可扩展，也就是永远不能再添加新的属性。</span><br><span class="line">Object.isExtensible(obj) 判断一个对象是否是可扩展的</span><br><span class="line">Object.seal(obj)让一个对象密封(只能读写 不能新增)</span><br><span class="line">Object.isSealed(obj)判断一个对象是否密封</span><br><span class="line">Object.isFrozen(arr)  让一个对象被冻结(只能读)</span><br><span class="line">Object.isFrozen(obj)：判断一个对象是否被冻结</span><br><span class="line">Object.keys(obj) 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组</span><br><span class="line">Object.getOwnPropertyNames(obj)：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组</span><br><span class="line">Object.is(value1, value2)：判断两个值是否是同一个值,Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</span><br><span class="line">Object.create(proto [, propertiesObject ]) 是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个参数是对象的属性描述符，这个参数是可选的。</span><br><span class="line">Object.assign 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。【浅复制】</span><br><span class="line">//var copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">Object.defineProperty() 定义单个对象属性或方法(可以设置读写可枚举)</span><br><span class="line">Object.defineProperties() 定义多个对象属性或方法(可以设置读写可枚举)</span><br><span class="line"></span><br><span class="line">Object.assign() //浅拷贝，类似&#123;...obj1,...obj2&#125; 都是浅拷贝</span><br><span class="line">Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）</span><br><span class="line"></span><br><span class="line">var target = &#123; a: 1 &#125;;</span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br><span class="line"></span><br><span class="line">//如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</span><br><span class="line"></span><br><span class="line">Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br><span class="line"></span><br><span class="line">对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</span><br><span class="line">var target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;</span><br><span class="line">var source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line">Object.assign(target, source)</span><br><span class="line">// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line"></span><br><span class="line">停止jq中的ajax请求用abort()函数  </span><br><span class="line">  </span><br><span class="line">var currentAjax = null;  </span><br><span class="line">	functionstartAjax()&#123;  </span><br><span class="line">	    //方法就是将XHR对象指向currentAjax，再调用currentAjax的.abort()来中止请求  </span><br><span class="line">	    currentAjax = $.ajax(&#123;  </span><br><span class="line">	           type:&apos;POST&apos;,  </span><br><span class="line">	           beforeSend:function()&#123;&#125;,  </span><br><span class="line">	           url:&apos;test.php&apos;,  </span><br><span class="line">	           data:&apos;username=xxx&apos;,  </span><br><span class="line">	           dataType:&apos;JSON&apos;,  </span><br><span class="line">	           error:function()&#123;alert(&apos;error&apos;)&#125;,  </span><br><span class="line">	           success:function(data)&#123;alert(data)&#125;  </span><br><span class="line">	    &#125;);  </span><br><span class="line">	&#125;  </span><br><span class="line">	functionstopAjax()&#123;  </span><br><span class="line">	    //如若上一次AJAX请求未完成，则中止请求  </span><br><span class="line">	    if(currentAjax) &#123;currentAjax.abort();&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSONP 超时：</span><br><span class="line"></span><br><span class="line">  设置超时标志位flag=false，当超时后将flag=true;</span><br><span class="line">  异步加载JS文件并执行回调函数：</span><br><span class="line">  </span><br><span class="line">  function loadJS(src, callback)&#123;</span><br><span class="line">    var script = document.createElement(&apos;script&apos;);</span><br><span class="line">    var head = document.getElementsByTagName(&apos;head&apos;)[0];</span><br><span class="line">    var loaded;</span><br><span class="line">    script.src = src;</span><br><span class="line">    if(typeof callback === &apos;function&apos;)&#123;</span><br><span class="line">        script.onload = script.onreadystatechange = function()&#123;</span><br><span class="line">            if(!loaded &amp;&amp; (!script.readyState || /loaded|complete/.test(script.readyState)))&#123;</span><br><span class="line">                script.onload = script.onreadystatechange = null;</span><br><span class="line">                loaded = true;</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取元素的绝对位置"><a href="#获取元素的绝对位置" class="headerlink" title="获取元素的绝对位置"></a>获取元素的绝对位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getPosition(node) &#123;</span><br><span class="line">	var width = node.offsetWidth; //元素宽度</span><br><span class="line">	var height = node.offsetHeight; //元素高度</span><br><span class="line">	var left = node.offsetLeft; //获取元素相对于其根元素的left值var left</span><br><span class="line">	var top = node.offsetTop; //获取元素相对于其根元素的top值var top</span><br><span class="line">	current = node.offsetParent; // 取得元素的offsetParent</span><br><span class="line"></span><br><span class="line">	// 一直循环直到根元素　　</span><br><span class="line">	while(current != null) &#123;　　</span><br><span class="line">		left += current.offsetLeft;　　</span><br><span class="line">		top += current.offsetTop;　　</span><br><span class="line">		current = current.offsetParent;　　</span><br><span class="line">	&#125;</span><br><span class="line">	return &#123;</span><br><span class="line">		&quot;width&quot;: width,</span><br><span class="line">		&quot;height&quot;: height,</span><br><span class="line">		&quot;left&quot;: left,</span><br><span class="line">		&quot;top&quot;: top</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动画结束时事件"><a href="#动画结束时事件" class="headerlink" title="动画结束时事件"></a>动画结束时事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">o.addEventListener(&quot;webkitAnimationEnd&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画结束&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">-webkit-animation动画有三个事件：</span><br><span class="line">开始事件: webkitAnimationStart</span><br><span class="line">结束事件:  webkitAnimationEnd</span><br><span class="line">重复运动事件: webkitAnimationIteration// 动画开始时事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o.addEventListener(&quot;webkitAnimationStart&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画开始&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 动画重复运动时事件</span><br><span class="line">o.addEventListener(&quot;webkitAnimationIteration&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画重复运动&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 动画结束时事件</span><br><span class="line">o.addEventListener(&quot;webkitAnimationEnd&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画结束&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="解决键盘弹出遮挡："><a href="#解决键盘弹出遮挡：" class="headerlink" title="解决键盘弹出遮挡："></a>解决键盘弹出遮挡：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 解决键盘弹出后挡表单的问题</span><br><span class="line">		window.addEventListener(&apos;resize&apos;, function() &#123;</span><br><span class="line">			if(</span><br><span class="line">				document.activeElement.tagName === &apos;INPUT&apos; ||</span><br><span class="line">				document.activeElement.tagName === &apos;TEXTAREA&apos;</span><br><span class="line">			) &#123;</span><br><span class="line">				window.setTimeout(function() &#123;</span><br><span class="line">					if(&apos;scrollIntoView&apos; in document.activeElement) &#123;</span><br><span class="line">						document.activeElement.scrollIntoView();</span><br><span class="line">					&#125; else &#123;</span><br><span class="line">						document.activeElement.scrollIntoViewIfNeeded();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, 0);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="单个for循环实现排序："><a href="#单个for循环实现排序：" class="headerlink" title="单个for循环实现排序："></a>单个for循环实现排序：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [12, 13, 65, 54, 86, 21, 37, 1, 95, 4];</span><br><span class="line">var l=a.length;</span><br><span class="line">		for(var i = 0; i &lt; l; i++) &#123;</span><br><span class="line">			if(a[i] &gt; a[i + 1]) &#123;</span><br><span class="line">				var tem = a[i];</span><br><span class="line">				a[i] = a[i + 1];</span><br><span class="line">				a[i + 1] = tem;</span><br><span class="line">			&#125;</span><br><span class="line">			if(i == l - 1) &#123;</span><br><span class="line">				i = -1;</span><br><span class="line">				l--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		console.log(a);</span><br></pre></td></tr></table></figure>
<h3 id="Object-assign实现"><a href="#Object-assign实现" class="headerlink" title="Object.assign实现:"></a>Object.assign实现:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">if (!Object.assign) &#123;</span><br><span class="line">    // 定义assign方法</span><br><span class="line">  Object.defineProperty(Object, &apos;assign&apos;, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">    value: function(target) &#123; // assign方法的第一个参数</span><br><span class="line">      &apos;use strict&apos;;</span><br><span class="line">      // 第一个参数为空，则抛错</span><br><span class="line">      if (target === undefined || target === null) &#123;</span><br><span class="line">        throw new TypeError(&apos;Cannot convert first argument to object&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var to = Object(target);</span><br><span class="line">      // 遍历剩余所有参数</span><br><span class="line">      for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        var nextSource = arguments[i];</span><br><span class="line">        // 参数为空，则跳过，继续下一个</span><br><span class="line">        if (nextSource === undefined || nextSource === null) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        nextSource = Object(nextSource);</span><br><span class="line"></span><br><span class="line">        // 获取改参数的所有key值，并遍历</span><br><span class="line">        var keysArray = Object.keys(nextSource);</span><br><span class="line">        for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) &#123;</span><br><span class="line">          var nextKey = keysArray[nextIndex];</span><br><span class="line">          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);</span><br><span class="line">          // 如果不为空且可枚举，则直接浅拷贝赋值</span><br><span class="line">          if (desc !== undefined &amp;&amp; desc.enumerable) &#123;</span><br><span class="line">            to[nextKey] = nextSource[nextKey];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript中巧用位运算"><a href="#JavaScript中巧用位运算" class="headerlink" title="JavaScript中巧用位运算"></a>JavaScript中巧用位运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">日常前端开发中我们很少用到位运算，容易让人遗忘，让我们一起回顾下一下js中的位运算。</span><br><span class="line">位运算详细说明查看JavaScript|MDN</span><br><span class="line">下面主要回顾一下一些常用的位运算的巧用。</span><br><span class="line">将十进制转化为二进制</span><br><span class="line">var number = 3;</span><br><span class="line">var result = number.toString(2);</span><br><span class="line"></span><br><span class="line">var result2 = 14..toString(2); // &quot;1110&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们使用位运算来代替Math.floor()来向下取整</span><br><span class="line">var data = 2.2352524535;</span><br><span class="line">var result = data | 0; // 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var re2 = ~~data; // 2</span><br></pre></td></tr></table></figure>
<h3 id="将颜色从RGA转换为Hex格式"><a href="#将颜色从RGA转换为Hex格式" class="headerlink" title="将颜色从RGA转换为Hex格式"></a>将颜色从RGA转换为Hex格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var color = &#123;r: 186, g: 218, b: 85&#125;;</span><br><span class="line"></span><br><span class="line">// RGB to HEX</span><br><span class="line">var rgb2hex = function(r, g, b) &#123;</span><br><span class="line">    return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).substr(1);</span><br><span class="line">&#125;</span><br><span class="line">rgb2hex(color.r, color.g, color.b);//&quot;#bada55&quot;</span><br></pre></td></tr></table></figure>
<h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">/*========================常用函数========================*/</span><br><span class="line"></span><br><span class="line">/*时间格式化*/</span><br><span class="line">Date.prototype.Format = function (fmt) &#123;</span><br><span class="line">    var o = &#123;</span><br><span class="line">        &quot;M+&quot;: this.getMonth() + 1, /*月份*/</span><br><span class="line">        &quot;d+&quot;: this.getDate(), /*日*/</span><br><span class="line">        &quot;h+&quot;: this.getHours(), /*小时*/</span><br><span class="line">        &quot;m+&quot;: this.getMinutes(), /*分*/</span><br><span class="line">        &quot;s+&quot;: this.getSeconds(), /*秒*/</span><br><span class="line">        &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), /*季度*/</span><br><span class="line">        &quot;S&quot;: this.getMilliseconds() /*毫秒*/</span><br><span class="line">    &#125;;</span><br><span class="line">    if (/(y+)/.test(fmt))</span><br><span class="line">        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));</span><br><span class="line">    for (var k in o)</span><br><span class="line">        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))</span><br><span class="line">            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));</span><br><span class="line">    return fmt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*IE浏览器不支持date(time),所以用此方法转换*/</span><br><span class="line">function NewDate(fmt) &#123;</span><br><span class="line">    /*首先将日期分隔 ，获取到日期部分 和 时间部分*/</span><br><span class="line">    var day = fmt.split(&apos; &apos;);</span><br><span class="line">    /*获取日期部分的年月日*/</span><br><span class="line">    var days = day[0].split(&apos;-&apos;);</span><br><span class="line">    /*获取时间部分的 时分秒*/</span><br><span class="line">    var mi = day[day.length - 1].split(&apos;:&apos;);</span><br><span class="line">    /*获取当前date类型日期*/</span><br><span class="line">    var date = new Date();</span><br><span class="line">    /*给date赋值  年月日*/</span><br><span class="line">    date.setUTCFullYear(days[0], days[1] - 1, days[2]);</span><br><span class="line">    /*给date赋值 时分秒  首先转换utc时区 ：+8*/</span><br><span class="line">    date.setUTCHours(mi[0] - 8, mi[1], mi[2]);</span><br><span class="line">    return date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*为空判断*/</span><br><span class="line">function isEmpty(s) &#123;</span><br><span class="line">    switch (typeof(s)) &#123;</span><br><span class="line">        case &apos;string&apos;:</span><br><span class="line">            return !s.length;</span><br><span class="line">            break;</span><br><span class="line">        case &apos;array&apos;:</span><br><span class="line">        case &apos;object&apos;:</span><br><span class="line">            for (var i in s) return false;</span><br><span class="line">            return true;</span><br><span class="line">            break;</span><br><span class="line">        case &apos;undefined&apos;:</span><br><span class="line">            return true;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return !s;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*数字判断*/</span><br><span class="line">function isNumber(s) &#123;</span><br><span class="line">    return typeof(s) == &apos;number&apos; ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*整数判断*/</span><br><span class="line">function isInt(s) &#123;</span><br><span class="line">    var re = /^-?\d*$/;</span><br><span class="line">    return re.test(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*正整数判断*/</span><br><span class="line">function isUInt(s) &#123;</span><br><span class="line">    var re = /^\d*$/;</span><br><span class="line">    return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*小数判断*/</span><br><span class="line">function isDecimal(s, bit) &#123;</span><br><span class="line">    if (!arguments[1]) bit = -1;</span><br><span class="line">    if (bit == -1) &#123;</span><br><span class="line">        var re = /^-?\d*.?\d*$/;</span><br><span class="line">        return re.test(s);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var re = new RegExp(&apos;^-?\\d*.?\\d&#123;0,&apos; + bit + &apos;&#125;$&apos;);</span><br><span class="line">        return re.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*正小数判断*/</span><br><span class="line">function isUDecimal(s, bit) &#123;</span><br><span class="line">    if (!arguments[1]) bit = -1;</span><br><span class="line">    if (bit == -1) &#123;</span><br><span class="line">        var re = /^\d*.?\d*$/;</span><br><span class="line">        return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var re = new RegExp(&apos;^\\d*.?\\d&#123;0,&apos; + bit + &apos;&#125;$&apos;);</span><br><span class="line">        return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*字符串判断*/</span><br><span class="line">function isString(s) &#123;</span><br><span class="line">    return typeof(s) == &apos;string&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*========================/常用函数========================*/</span><br><span class="line"></span><br><span class="line">js onkeyup replace 自动替换</span><br><span class="line"></span><br><span class="line">检测浮点数 只能是整数或者小数 </span><br><span class="line">多余的就replace 掉 的表单验证</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function checkFloatNum(obj)</span><br><span class="line">&#123;</span><br><span class="line">    //先把非数字的都替换掉，除了数字和.</span><br><span class="line">    obj.value = obj.value.replace(/[^\d.]/g,&quot;&quot;);</span><br><span class="line">    //必须保证第一个为数字而不是.</span><br><span class="line">    obj.value = obj.value.replace(/^\./g,&quot;&quot;);</span><br><span class="line">    //保证只有出现一个.而没有多个.</span><br><span class="line">    obj.value = obj.value.replace(/\.&#123;2,&#125;/g,&quot;.&quot;);</span><br><span class="line">    //保证.只出现一次，而不能出现两次以上</span><br><span class="line">    obj.value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(function() &#123;</span><br><span class="line"></span><br><span class="line">	handleAddListener(&apos;load&apos;, getTiming)</span><br><span class="line"></span><br><span class="line">	function handleAddListener(type, fn) &#123;</span><br><span class="line">		if(window.addEventListener) &#123;</span><br><span class="line">			window.addEventListener(type, fn)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			window.attachEvent(&apos;on&apos; + type, fn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function getTiming() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			var time = performance.timing;</span><br><span class="line">			var timingObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">			var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;</span><br><span class="line"></span><br><span class="line">			if(loadTime &lt; 0) &#123;</span><br><span class="line">				setTimeout(function() &#123;</span><br><span class="line">					getTiming();</span><br><span class="line">				&#125;, 200);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000;</span><br><span class="line">			timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000;</span><br><span class="line">			timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000;</span><br><span class="line">			timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000;</span><br><span class="line">			timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000;</span><br><span class="line">			timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000;</span><br><span class="line">			timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000;</span><br><span class="line">			timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;</span><br><span class="line">			timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000;</span><br><span class="line">			timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]);</span><br><span class="line"></span><br><span class="line">			for(item in timingObj) &#123;</span><br><span class="line">				console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			console.log(performance.timing);</span><br><span class="line"></span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			console.log(timingObj)</span><br><span class="line">			console.log(performance.timing);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default class Cookie &#123;</span><br><span class="line">	//写cookies</span><br><span class="line">	static setCookie = (name, value) =&gt; &#123;</span><br><span class="line">		var Days = 30;</span><br><span class="line">		var exp = new Date();</span><br><span class="line">		exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000);</span><br><span class="line">		document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">	&#125;</span><br><span class="line">	//读取cookies </span><br><span class="line">	static getCookie = (name) =&gt; &#123;</span><br><span class="line">		var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;);</span><br><span class="line">		if(arr = document.cookie.match(reg))</span><br><span class="line">			return unescape(arr[2]);</span><br><span class="line">		else</span><br><span class="line">			return null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//删除cookies </span><br><span class="line">	static delCookie = (name) =&gt; &#123;</span><br><span class="line">		var exp = new Date();</span><br><span class="line">		exp.setTime(exp.getTime() - 1);</span><br><span class="line">		var cval = getCookie(name);</span><br><span class="line">		if(cval != null)</span><br><span class="line">			document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    function jsonp(objects)&#123;</span><br><span class="line">        objects = objects || &#123;&#125;;</span><br><span class="line">        if(!objects.url || !objects.callback)&#123;</span><br><span class="line">            throw new Error(&apos;参数不合法&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建script标签并插入</span><br><span class="line">        var callbackName =  (&apos;jsonp_&apos; + Math.random()).replace(&quot;.&quot;, &quot;&quot;);//随机生成callbackName</span><br><span class="line"></span><br><span class="line">        var script = document.createElement(&apos;script&apos;);</span><br><span class="line">        var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line">        body.appendChild(script);</span><br><span class="line"></span><br><span class="line">        window[callbackName] = function (json) &#123;</span><br><span class="line">            body.removeChild(script);</span><br><span class="line">            clearTimeout(script.timer);</span><br><span class="line">            window[callbackName] = null;</span><br><span class="line">            objects.callback &amp;&amp; objects.callback(json);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //发出请求</span><br><span class="line">        script.src = objects.url + callbackName;</span><br><span class="line"></span><br><span class="line">        //响应时间</span><br><span class="line">        if(objects.time)&#123;</span><br><span class="line">            script.timer = setTimeout(function () &#123;</span><br><span class="line">                window[callbackName] = null;</span><br><span class="line">                body.removeChild(script);</span><br><span class="line">                objects.fail &amp;&amp; objects.fail(&apos;超时&apos;);</span><br><span class="line">            &#125;, objects.time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="js判断DOM是否包含另一个DOM"><a href="#js判断DOM是否包含另一个DOM" class="headerlink" title="js判断DOM是否包含另一个DOM"></a>js判断DOM是否包含另一个DOM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">			.first&#123;</span><br><span class="line">				width: 200px;</span><br><span class="line">				height: 200px;</span><br><span class="line">				background: red;</span><br><span class="line">			&#125;</span><br><span class="line">			.first-child&#123;</span><br><span class="line">				width: 100px;</span><br><span class="line">				height: 100px;</span><br><span class="line">				background: green;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div class=&quot;first&quot;&gt;</span><br><span class="line">			&lt;div class=&quot;first-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;div class=&quot;second&quot;&gt;</span><br><span class="line">			&lt;div class=&quot;second-child&quot;&gt;</span><br><span class="line">				&lt;div class=&quot;second-child-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			var first = document.querySelector(&apos;.first&apos;);</span><br><span class="line">			var firstchild = document.querySelector(&apos;.first-child&apos;);</span><br><span class="line">			</span><br><span class="line">			var second = document.querySelector(&apos;.second&apos;);</span><br><span class="line">			var secondchild = document.querySelector(&apos;.second-child&apos;);</span><br><span class="line">			var secondchildchild = document.querySelector(&apos;.second-child-child&apos;);</span><br><span class="line">			 </span><br><span class="line">			</span><br><span class="line"></span><br><span class="line">			function isChildOf(child, parent) &#123;</span><br><span class="line">				var parentNode;</span><br><span class="line">				if(child &amp;&amp; parent) &#123;</span><br><span class="line">					parentNode = child.parentNode;</span><br><span class="line">					while(parentNode) &#123;</span><br><span class="line">						if(parent === parentNode) &#123;</span><br><span class="line">							return true;</span><br><span class="line">						&#125;</span><br><span class="line">						parentNode = parentNode.parentNode;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			console.log(isChildOf(firstchild, first));</span><br><span class="line">			console.log(isChildOf(secondchild, second));</span><br><span class="line">			console.log(isChildOf(secondchildchild, secondchild));</span><br><span class="line">			console.log(isChildOf(secondchildchild, second));</span><br><span class="line">			</span><br><span class="line">			console.log(isChildOf(secondchildchild, first));</span><br><span class="line">			</span><br><span class="line">			console.log(document.documentElement.contains(document.body));</span><br><span class="line">			console.log(second.contains(secondchildchild));</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="回到顶部带动画"><a href="#回到顶部带动画" class="headerlink" title="回到顶部带动画"></a>回到顶部带动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">/* 滚动条动画：</span><br><span class="line"> * 移动端:document.body.scrollTop</span><br><span class="line">   PC端：document.documentElement.scrollTop</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //使用:gotoTop(400,callBack)</span><br><span class="line">   gotoTop(durations,  callback = undefined) &#123;</span><br><span class="line">      const doc = document.documentElement</span><br><span class="line">      const scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)</span><br><span class="line">      for (var i = 60; i &gt;= 0; i--) &#123;</span><br><span class="line">        setTimeout((i =&gt; &#123;</span><br><span class="line">          return () =&gt; &#123;</span><br><span class="line">            doc.scrollTop = scrollTop * i / 60</span><br><span class="line">            if (i === 0 &amp;&amp; typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">              callback()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i), durations * (1 - i / 60))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"> * */</span><br><span class="line">var requestAnimFrame = (function() &#123;</span><br><span class="line">	return window.requestAnimationFrame ||</span><br><span class="line">		window.webkitRequestAnimationFrame ||</span><br><span class="line">		window.mozRequestAnimationFrame ||</span><br><span class="line">		function(callback) &#123;</span><br><span class="line">			window.setTimeout(callback, 1000 / 60);</span><br><span class="line">		&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var cancelAnimationFrame = (function() &#123;</span><br><span class="line">	return window.cancelAnimationFrame ||</span><br><span class="line">		window.webkitCancelAnimationFrame ||</span><br><span class="line">		window.mozCancelAnimationFrame ||</span><br><span class="line">		window.oCancelAnimationFrame ||</span><br><span class="line">		function(id) &#123;</span><br><span class="line">			window.clearTimeout(id)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// Tween中的方法接受4个参数t,b,c,d 。t为初始时间 b、c、d三个参数（即初始值，变化量，持续时间）。返回值为当前位置</span><br><span class="line">// t =&gt; time(初始记步次数)  b =&gt; begin(初始位置)   c =&gt; change(变化量)   d =&gt; duration(持续次数)</span><br><span class="line"></span><br><span class="line">var tween = &#123;</span><br><span class="line">	linear: function(t, b, c, d) &#123;</span><br><span class="line">		return c * t / d + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeIn: function(t, b, c, d) &#123;</span><br><span class="line">		return c * (t /= d) * t + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	strongEaseIn: function(t, b, c, d) &#123;</span><br><span class="line">		return c * (t /= d) * t * t * t * t + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	strongEaseOut: function(t, b, c, d) &#123;</span><br><span class="line">		return c * ((t = t / d - 1) * t * t * t * t + 1) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	sineaseIn: function(t, b, c, d) &#123;</span><br><span class="line">		return c * (t /= d) * t * t + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	sineaseOut: function(t, b, c, d) &#123;</span><br><span class="line">		return c * ((t = t / d - 1) * t * t + 1) + b;</span><br><span class="line">	&#125;,</span><br><span class="line">	easeInOutQuad: function(t, b, c, d) &#123;</span><br><span class="line">		t /= d / 2;</span><br><span class="line">		if(t &lt; 1) return c / 2 * t * t + b;</span><br><span class="line">		t--;</span><br><span class="line">		return -c / 2 * (t * (t - 2) - 1) + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var myReq; </span><br><span class="line">export var animatedScrollTo = function(element, to, duration, callback, Bzr = &apos;linear&apos;) &#123;</span><br><span class="line">	var start = element.scrollTop,</span><br><span class="line">		change = to - start,</span><br><span class="line">		animationStart = +new Date();</span><br><span class="line">	var animating = true;</span><br><span class="line">	var lastpos = null;</span><br><span class="line"></span><br><span class="line">	var animateScroll = function() &#123;</span><br><span class="line">		if(!animating) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		myReq=requestAnimFrame(animateScroll);</span><br><span class="line">		var now = +new Date();</span><br><span class="line">		var val = Math.floor(tween[Bzr](now - animationStart, start, change, duration));</span><br><span class="line"></span><br><span class="line">		if(lastpos) &#123;</span><br><span class="line">			if(lastpos === element.scrollTop) &#123;</span><br><span class="line">				lastpos = val;</span><br><span class="line">				element.scrollTop = val;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				animating = false;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			lastpos = val;</span><br><span class="line">			element.scrollTop = val;</span><br><span class="line">		&#125;</span><br><span class="line">		if(now &gt; animationStart + duration) &#123;</span><br><span class="line">			element.scrollTop = to;</span><br><span class="line">			animating = false;</span><br><span class="line">			cancelAnimationFrame(myReq);   //清除定时器动画</span><br><span class="line">			callback&amp;&amp;callback();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	myReq=requestAnimFrame(animateScroll);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用js唤起Native下的App"><a href="#使用js唤起Native下的App" class="headerlink" title="使用js唤起Native下的App"></a>使用js唤起Native下的App</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 浏览器的相关信息</span><br><span class="line"> */</span><br><span class="line">var Browser = /** @class */ (function() &#123;</span><br><span class="line">	function Browser() &#123;&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 获取浏览器数据</span><br><span class="line">	 */</span><br><span class="line">	Browser.getBrowser = function() &#123;</span><br><span class="line">		var UA = navigator.userAgent || &apos;&apos;</span><br><span class="line">		var isAndroid = (function() &#123;</span><br><span class="line">			return UA.match(/Android/i) ? true : false</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isQQ = (function() &#123;</span><br><span class="line">			return /(iPad|iPhone|iPod).*? (IPad)?QQ\/([\d\.]+)/.test(UA) || /\bV1_AND_SQI?_([\d\.]+)(.*? QQ\/([\d\.]+))?/.test(UA)</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isIOS = (function() &#123;</span><br><span class="line">			return UA.match(/iPhone|iPad|iPod/i) ? true : false</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isSafari = (function() &#123;</span><br><span class="line">			return /iPhone|iPad|iPod\/([\w.]+).*(safari).*/i.test(UA)</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isWx = (function() &#123;</span><br><span class="line">			return UA.match(/micromessenger/i) ? true : false</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isWb = (function() &#123;</span><br><span class="line">			return UA.match(/weibo/i) ? true : false</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isAndroidChrome = (function() &#123;</span><br><span class="line">			return(UA.match(/Chrome\/([\d.]+)/) || UA.match(/CriOS\/([\d.]+)/)) &amp;&amp; isAndroid &amp;&amp; !isQQ</span><br><span class="line">		&#125;)()</span><br><span class="line">		var isQZ = (function() &#123;</span><br><span class="line">			return UA.indexOf(&apos;Qzone/&apos;) !== -1</span><br><span class="line">		&#125;)()</span><br><span class="line">		var browser = &#123;</span><br><span class="line">			isAndroid: isAndroid,</span><br><span class="line">			isIOS: isIOS,</span><br><span class="line">			isSafari: isSafari,</span><br><span class="line">			isQQ: isQQ,</span><br><span class="line">			isWb: isWb,</span><br><span class="line">			isWx: isWx,</span><br><span class="line">			isQZ: isQZ,</span><br><span class="line">			isAndroidChrome: isAndroidChrome</span><br><span class="line">		&#125;</span><br><span class="line">		return browser</span><br><span class="line">	&#125;</span><br><span class="line">	return Browser</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * AppLink:H5唤起APP的所有方法</span><br><span class="line"> */</span><br><span class="line">var AppLink = /** @class */ (function() &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 类的contructor方法</span><br><span class="line">	 * @param config IAppLink类型的config文件</span><br><span class="line">	 */</span><br><span class="line">	function AppLink(config) &#123;</span><br><span class="line">		/**</span><br><span class="line">		 * UA</span><br><span class="line">		 */</span><br><span class="line">		this.UA = &#123;&#125;</span><br><span class="line">		/**</span><br><span class="line">		 * 传入的config数据，以接口约束</span><br><span class="line">		 */</span><br><span class="line">		this.config = &#123;&#125;</span><br><span class="line">		this.UA = navigator.userAgent || &apos;&apos;</span><br><span class="line">		this.config = config</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 跳转函数</span><br><span class="line">	 * @param url 链接</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.go = function(url) &#123;</span><br><span class="line">		window.location.href = url</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 检查是否唤起</span><br><span class="line">	 * @param cb 回调函数</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.checkOpen = function(cb) &#123;</span><br><span class="line">		var inter = null</span><br><span class="line">		var statue = false</span><br><span class="line">		var count = 0</span><br><span class="line">		inter = window.setInterval(function() &#123;</span><br><span class="line">			count++</span><br><span class="line">			statue = document.hidden || document.webkitHidden</span><br><span class="line">			if(statue || count &gt; 40) &#123;</span><br><span class="line">				cb(statue)</span><br><span class="line">				clearInterval(inter)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, 50)</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 外部调用的入口函数</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.open = function() &#123;</span><br><span class="line">		var _this = this</span><br><span class="line">		var browser = Browser.getBrowser()</span><br><span class="line">		var config = this.config</span><br><span class="line">		// 微信直接跳 应用宝</span><br><span class="line">		if(browser.isWx) &#123;</span><br><span class="line">			this.go(this.config.yyb)</span><br><span class="line">		&#125; else if(browser.isQQ) &#123;</span><br><span class="line">			if(browser.isIOS) &#123;</span><br><span class="line">				// 没有下载</span><br><span class="line">				this.checkOpen(function(isSuccess) &#123;</span><br><span class="line">					if(!isSuccess) &#123;</span><br><span class="line">						_this.go(_this.config.appstore)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			// iOS跳到AppStore</span><br><span class="line">			if(browser.isAndroid) &#123;</span><br><span class="line">				// 使用scheme唤起</span><br><span class="line">				this.tryCallApp(this.config.schema)</span><br><span class="line">				// 唤起失败 跳到应用宝</span><br><span class="line">				this.checkOpen(function(isSuccess) &#123;</span><br><span class="line">					if(!isSuccess) &#123;</span><br><span class="line">						_this.go(_this.config.yyb)</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if(browser.isWb) &#123;</span><br><span class="line">			// 使用scheme唤起</span><br><span class="line">			this.tryCallApp(this.config.schema)</span><br><span class="line">			// 微博：唤起失败，也不跳转，会有引导功能</span><br><span class="line">		&#125; else if(browser.isSafari) &#123;</span><br><span class="line">			var version = this.getIOSVersion()</span><br><span class="line">			// iOS10以下不支持直接跳转到AppStore，跳到应用宝</span><br><span class="line">			if(version &lt; 10) &#123;</span><br><span class="line">				this.go(this.config.yyb)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				this.go(this.config.appstore)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			// 其他情况，直接跳应用宝</span><br><span class="line">			this.go(this.config.yyb)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 下载按钮的url地址</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.getDownloadUrl = function() &#123;</span><br><span class="line">		var browser = Browser.getBrowser()</span><br><span class="line">		var config = this.config</span><br><span class="line">		var url = &apos;&apos;</span><br><span class="line">		if(browser.isQQ) &#123;</span><br><span class="line">			if(browser.isIOS) &#123;</span><br><span class="line">				url = this.config.appstore</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				url = this.config.yyb</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if(browser.isSafari) &#123;</span><br><span class="line">			var version = this.getIOSVersion()</span><br><span class="line">			if(version &lt; 10) &#123;</span><br><span class="line">				url = this.config.yyb</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				url = this.config.appstore</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if(browser.isWb) &#123;</span><br><span class="line">			url = &apos;&apos;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			url = this.config.yyb</span><br><span class="line">		&#125;</span><br><span class="line">		return url</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 尝试唤起APP</span><br><span class="line">	 * @param scheme 唤起的scheme</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.tryCallApp = function(scheme) &#123;</span><br><span class="line">		var aLink = document.createElement(&apos;a&apos;),</span><br><span class="line">			body = document.body</span><br><span class="line">		aLink.href = scheme</span><br><span class="line">		body.appendChild(aLink)</span><br><span class="line">		aLink.click()</span><br><span class="line">	&#125;</span><br><span class="line">	/**</span><br><span class="line">	 * 判断iOS版本</span><br><span class="line">	 */</span><br><span class="line">	AppLink.prototype.getIOSVersion = function() &#123;</span><br><span class="line">		var ver = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)</span><br><span class="line">		var version = parseInt(ver[1], 10)</span><br><span class="line">		return version</span><br><span class="line">	&#125;</span><br><span class="line">	return AppLink</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">		function add(...x) &#123;</span><br><span class="line">			var sum = x.reduce((a,b)=&gt;a+b,0)</span><br><span class="line">			var tmp = function(...y) &#123;</span><br><span class="line">				sum =sum+y.reduce((a,b)=&gt;a+b,0)</span><br><span class="line">				return tmp;</span><br><span class="line">			&#125;;</span><br><span class="line">			tmp.toString = function() &#123;</span><br><span class="line">				return sum;</span><br><span class="line">			&#125;;</span><br><span class="line">			return tmp;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		console.log(+add(1)(2)(3))   // 6</span><br><span class="line">		console.log(+add(1)(2,3))    // 6</span><br><span class="line">		console.log(+add(1,2)(3))    // 6</span><br><span class="line">		console.log(+add(1)(2)(3,4))   //10</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		add(1)(2)(3).valueOf</span><br><span class="line">		//ƒ valueOf() &#123; [native code] &#125;</span><br><span class="line">		add(1)(2)(3).valueOf()</span><br><span class="line">		//ƒ 6</span><br><span class="line">		+add(1)(2)(3).valueOf()</span><br><span class="line">		//6</span><br><span class="line">		+&quot;&quot;+add(1)(2)(3).valueOf()</span><br><span class="line">		//6</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="add-2-3-add-2-3-输出5"><a href="#add-2-3-add-2-3-输出5" class="headerlink" title="add(2)(3)(),add(2,3)()输出5"></a>add(2)(3)(),add(2,3)()输出5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			function sum() &#123;</span><br><span class="line">				var cur = Array.prototype.slice.call(arguments).reduce(function(a, b) &#123;</span><br><span class="line">					return a + b;</span><br><span class="line">				&#125;, 0);</span><br><span class="line"></span><br><span class="line">				function add() &#123;</span><br><span class="line">					return arguments.length == 0 ? cur : (cur += Array.prototype.slice.call(arguments).reduce(function(a, b) &#123;</span><br><span class="line">						return a + b</span><br><span class="line">					&#125;, 0), add);</span><br><span class="line">				&#125;;</span><br><span class="line">				return arguments.length == 0 ? 0 : add;</span><br><span class="line">		&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="获取CSS样式"><a href="#获取CSS样式" class="headerlink" title="获取CSS样式"></a>获取CSS样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getStyle(obj, attr) &#123;</span><br><span class="line">	if(obj.currentStyle) &#123;</span><br><span class="line">		return obj.currentStyle[attr]; //IE678</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return window.getComputedStyle(obj, null)[attr];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function rgbToRgba(rgbValue) &#123;</span><br><span class="line">	const rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);</span><br><span class="line">	return rgb ? `rgba($&#123;rgb[1]&#125;,1)` : rgbValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hexToRgba(hexValue) &#123;</span><br><span class="line">	const rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;</span><br><span class="line">	const hex = hexValue.replace(rgx, (m, r, g, b) =&gt; r + r + g + g + b + b);</span><br><span class="line">	const rgb = /^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i.exec(hex);</span><br><span class="line">	const r = parseInt(rgb[1], 16);</span><br><span class="line">	const g = parseInt(rgb[2], 16);</span><br><span class="line">	const b = parseInt(rgb[3], 16);</span><br><span class="line">	return `rgba($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;,1)`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hslToRgba(hslValue) &#123;</span><br><span class="line">	const hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);</span><br><span class="line">	const h = parseInt(hsl[1]) / 360;</span><br><span class="line">	const s = parseInt(hsl[2]) / 100;</span><br><span class="line">	const l = parseInt(hsl[3]) / 100;</span><br><span class="line">	const a = hsl[4] || 1;</span><br><span class="line"></span><br><span class="line">	function hue2rgb(p, q, t) &#123;</span><br><span class="line">		if(t &lt; 0) t += 1;</span><br><span class="line">		if(t &gt; 1) t -= 1;</span><br><span class="line">		if(t &lt; 1 / 6) return p + (q - p) * 6 * t;</span><br><span class="line">		if(t &lt; 1 / 2) return q;</span><br><span class="line">		if(t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;</span><br><span class="line">		return p;</span><br><span class="line">	&#125;</span><br><span class="line">	let r, g, b;</span><br><span class="line">	if(s == 0) &#123;</span><br><span class="line">		r = g = b = l;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;</span><br><span class="line">		const p = 2 * l - q;</span><br><span class="line">		r = hue2rgb(p, q, h + 1 / 3);</span><br><span class="line">		g = hue2rgb(p, q, h);</span><br><span class="line">		b = hue2rgb(p, q, h - 1 / 3);</span><br><span class="line">	&#125;</span><br><span class="line">	return `rgba($&#123;r * 255&#125;,$&#123;g * 255&#125;,$&#123;b * 255&#125;,$&#123;a&#125;)`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function colorToRgb(val) &#123;</span><br><span class="line">	if(is.rgb(val)) return rgbToRgba(val);</span><br><span class="line">	if(is.hex(val)) return hexToRgba(val);</span><br><span class="line">	if(is.hsl(val)) return hslToRgba(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="750rem"><a href="#750rem" class="headerlink" title="750rem"></a>750rem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function(doc, win) &#123;</span><br><span class="line">	var docEl = doc.documentElement,</span><br><span class="line">		resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,</span><br><span class="line">		recalc = function() &#123;</span><br><span class="line">			var clientWidth = docEl.clientWidth;</span><br><span class="line">			if(!clientWidth) return;</span><br><span class="line">			if(clientWidth &gt;= 750) &#123;</span><br><span class="line">				docEl.style.fontSize = &apos;100px&apos;;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				docEl.style.fontSize = 100 * (clientWidth / 750) + &apos;px&apos;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	if(!doc.addEventListener) return;</span><br><span class="line">	win.addEventListener(resizeEvt, recalc, false);</span><br><span class="line">	doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure>
<h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static checkType = (str, type) =&gt; &#123;</span><br><span class="line">	switch(type) &#123;</span><br><span class="line">		case &apos;email&apos;:</span><br><span class="line">			return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);</span><br><span class="line">		case &apos;phone&apos;:</span><br><span class="line">			return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str);</span><br><span class="line">		case &apos;tel&apos;:</span><br><span class="line">			return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str);</span><br><span class="line">		case &apos;number&apos;:</span><br><span class="line">			return /^[0-9]$/.test(str);</span><br><span class="line">		case &apos;english&apos;:</span><br><span class="line">			return /^[a-zA-Z]+$/.test(str);</span><br><span class="line">		case &apos;chinese&apos;:</span><br><span class="line">			return /^[\u4E00-\u9FA5]+$/.test(str);</span><br><span class="line">		case &apos;lower&apos;:</span><br><span class="line">			return /^[a-z]+$/.test(str);</span><br><span class="line">		case &apos;upper&apos;:</span><br><span class="line">			return /^[A-Z]+$/.test(str);</span><br><span class="line">		default:</span><br><span class="line">			return true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="navigator帮助类"><a href="#navigator帮助类" class="headerlink" title="navigator帮助类"></a>navigator帮助类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">class navigatorUtil &#123;</span><br><span class="line">	/**</span><br><span class="line">	 * 头部信息</span><br><span class="line">	 * @type &#123;[type]&#125;</span><br><span class="line">	 */</span><br><span class="line">	static userAgent = navigator.userAgent;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 是否为ipad</span><br><span class="line">	 */</span><br><span class="line">	static isIPad = () =&gt; &#123;</span><br><span class="line">		return(navigatorUtil.userAgent.indexOf(&quot;iPad&quot;) &gt; -1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 是否为iphone</span><br><span class="line">	 * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line">	 * @return &#123;Boolean&#125;           [description]</span><br><span class="line">	 */</span><br><span class="line">	static isIPhone = () =&gt; &#123;</span><br><span class="line">		return(navigatorUtil.userAgent.indexOf(&quot;iPhone&quot;) &gt; -1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 是否为ios系统</span><br><span class="line">	 * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line">	 * @return &#123;Boolean&#125;           [description]</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	static isIOS = () =&gt; &#123;</span><br><span class="line">		return navigatorUtil.isIPad(navigatorUtil.userAgent) || navigatorUtil.isIPhone(</span><br><span class="line">			navigatorUtil.userAgent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 是否为Android系统</span><br><span class="line">	 * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line">	 * @return &#123;Boolean&#125;           [description]</span><br><span class="line">	 */</span><br><span class="line">	static isAndroid = () =&gt; &#123;</span><br><span class="line">		return(navigatorUtil.userAgent.indexOf(&quot;Android&quot;) &gt; -1) ||</span><br><span class="line">			(navigatorUtil.userAgent.indexOf(&quot;Linux&quot;) &gt; -1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 判断是否为微信</span><br><span class="line">	 */</span><br><span class="line">	static isWeixin = () =&gt; &#123;</span><br><span class="line">		return(navigatorUtil.userAgent.indexOf(&quot;MicroMessenger&quot;) &gt; -1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @desc 获取浏览器类型和版本</span><br><span class="line">	 * @return &#123;String&#125; </span><br><span class="line">	 */</span><br><span class="line">	static getExplore = () =&gt; &#123;</span><br><span class="line">		var sys = &#123;&#125;,</span><br><span class="line">			ua = navigator.userAgent.toLowerCase(),</span><br><span class="line">			s;</span><br><span class="line">		(s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:</span><br><span class="line">			(s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :</span><br><span class="line">			(s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :</span><br><span class="line">			(s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :</span><br><span class="line">			(s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :</span><br><span class="line">			(s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :</span><br><span class="line">			(s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;</span><br><span class="line">		// 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie)</span><br><span class="line">		if(sys.edge) return(&apos;EDGE: &apos; + sys.edge)</span><br><span class="line">		if(sys.firefox) return(&apos;Firefox: &apos; + sys.firefox)</span><br><span class="line">		if(sys.chrome) return(&apos;Chrome: &apos; + sys.chrome)</span><br><span class="line">		if(sys.opera) return(&apos;Opera: &apos; + sys.opera)</span><br><span class="line">		if(sys.safari) return(&apos;Safari: &apos; + sys.safari)</span><br><span class="line">		return &apos;Unkonwn&apos;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * </span><br><span class="line">	 * @desc 获取操作系统类型</span><br><span class="line">	 * @return &#123;String&#125; </span><br><span class="line">	 */</span><br><span class="line">	static getOS = () =&gt; &#123;</span><br><span class="line">		var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;;</span><br><span class="line">		var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;;</span><br><span class="line">		var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;;</span><br><span class="line"></span><br><span class="line">		if(/mac/i.test(appVersion)) return &apos;MacOSX&apos;</span><br><span class="line">		if(/win/i.test(appVersion)) return &apos;windows&apos;</span><br><span class="line">		if(/linux/i.test(appVersion)) return &apos;linux&apos;</span><br><span class="line">		if(/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos;</span><br><span class="line">		if(/android/i.test(userAgent)) return &apos;android&apos;</span><br><span class="line">		if(/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//进入全屏模式,  判断各种浏览器，找到正确的方法</span><br><span class="line">	static launchFullScreen = (element) =&gt; &#123;</span><br><span class="line">		if(element.requestFullscreen) &#123;</span><br><span class="line">			element.requestFullscreen();</span><br><span class="line">		&#125; else if(element.mozRequestFullScreen) &#123;</span><br><span class="line">			element.mozRequestFullScreen();</span><br><span class="line">		&#125; else if(element.webkitRequestFullscreen) &#123;</span><br><span class="line">			element.webkitRequestFullscreen();</span><br><span class="line">		&#125; else if(element.msRequestFullscreen) &#123;</span><br><span class="line">			element.msRequestFullscreen();</span><br><span class="line">		&#125;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	//退出全屏模式</span><br><span class="line">	static exitFullScreen = () =&gt; &#123;</span><br><span class="line">		if(document.exitFullscreen) &#123;</span><br><span class="line">			document.exitFullscreen();</span><br><span class="line">		&#125; else if(document.mozCancelFullScreen) &#123;</span><br><span class="line">			document.mozCancelFullScreen();</span><br><span class="line">		&#125; else if(document.webkitExitFullscreen) &#123;</span><br><span class="line">			document.webkitExitFullscreen();</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">function Promise(task) &#123;</span><br><span class="line">	let self = this; //缓存this</span><br><span class="line">	self.status = &apos;pending&apos;; //默认状态为pending</span><br><span class="line">	self.value = undefined; //存放着此promise的结果</span><br><span class="line">	self.onResolvedCallbacks = []; //存放着所有成功的回调函数</span><br><span class="line">	self.onRejectedCallbacks = []; //存放着所有的失败的回调函数</span><br><span class="line"></span><br><span class="line">	// 调用resolve方法可以把promise状态变成成功态</span><br><span class="line">	function resolve(value) &#123;</span><br><span class="line">		if(value instanceof Promise) &#123;</span><br><span class="line">			return value.then(resolve, reject)</span><br><span class="line">		&#125;</span><br><span class="line">		setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line">			// 如果当前状态是初始态（pending），则转成成功态</span><br><span class="line">			// 此处这个写判断的原因是因为resolved和rejected两个状态只能由pending转化而来，两者不能相互转化</span><br><span class="line">			if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">				self.value = value;</span><br><span class="line">				self.status = &apos;resolved&apos;;</span><br><span class="line">				self.onResolvedCallbacks.forEach(item =&gt; item(self.value));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 调用reject方法可以把当前的promise状态变成失败态</span><br><span class="line">	function reject(value) &#123;</span><br><span class="line">		setTimeout(function() &#123;</span><br><span class="line">			if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">				self.value = value;</span><br><span class="line">				self.status = &apos;rejected&apos;;</span><br><span class="line">				self.onRejectedCallbacks.forEach(item =&gt; item(value));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 立即执行传入的任务</span><br><span class="line">	try &#123;</span><br><span class="line">		task(resolve, reject);</span><br><span class="line">	&#125; catch(e) &#123;</span><br><span class="line">		reject(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * resolvePromise函数的目的是与原生Promise相兼容，可以互相调用</span><br><span class="line"> */</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">	// 将返回的promise不停的调用执行，直到失败或者返回一个普通的数据类型</span><br><span class="line">	if(promise2 === x) &#123;</span><br><span class="line">		return reject(new TypeError(&apos;循环引用&apos;));</span><br><span class="line">	&#125;</span><br><span class="line">	let then, called;</span><br><span class="line"></span><br><span class="line">	if(x != null &amp;&amp; ((typeof x == &apos;object&apos; || isFunction(x)))) &#123;</span><br><span class="line">		// promise</span><br><span class="line">		try &#123;</span><br><span class="line">			then = x.then;</span><br><span class="line">			if(isFunction(then)) &#123;</span><br><span class="line">				then.call(x, function(value) &#123;</span><br><span class="line">					if(called) return;</span><br><span class="line">					called = true;</span><br><span class="line">					resolvePromise(promise2, value, resolve, reject);</span><br><span class="line">				&#125;, function(reason) &#123;</span><br><span class="line">					if(called) return;</span><br><span class="line">					called = true;</span><br><span class="line">					reject(reason);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				resolve(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			if(called) return;</span><br><span class="line">			called = true;</span><br><span class="line">			reject(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		resolve(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * onFulfilled成功的回调，onReject失败的回调</span><br><span class="line"> */</span><br><span class="line">Promise.prototype.then = function(onFulfilled, onRejected) &#123;</span><br><span class="line">	let self = this;</span><br><span class="line">	// 当调用时没有写函数给它一个默认函数值</span><br><span class="line">	onFulfilled = isFunction(onFulfilled) ? onFulfilled : function(value) &#123;</span><br><span class="line">		return value</span><br><span class="line">	&#125;;</span><br><span class="line">	onRejected = isFunction(onRejected) ? onRejected : function(value) &#123;</span><br><span class="line">		throw value</span><br><span class="line">	&#125;;</span><br><span class="line">	let promise2;</span><br><span class="line">	if(self.status == &apos;resolved&apos;) &#123;</span><br><span class="line">		promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">			setTimeout(function() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					let x = onFulfilled(self.value);</span><br><span class="line">					resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">				&#125; catch(e) &#123;</span><br><span class="line">					reject(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(self.status == &apos;rejected&apos;) &#123;</span><br><span class="line">		promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">			setTimeout(function() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					let x = onRejected(self.value);</span><br><span class="line">					resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">				&#125; catch(e) &#123;</span><br><span class="line">					reject(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">		promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">			self.onResolvedCallbacks.push(function(value) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					let x = onFulfilled(value);</span><br><span class="line">					resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">				&#125; catch(e) &#123;</span><br><span class="line">					reject(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			self.onRejectedCallbacks.push(function(value) &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					let x = onRejected(value);</span><br><span class="line">					resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">				&#125; catch(e) &#123;</span><br><span class="line">					reject(e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	return promise2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * catch实际上是then的一个简写,成功回调传空值即可</span><br><span class="line"> */</span><br><span class="line">Promise.prototype.catch = function(onRejected) &#123;</span><br><span class="line">	return this.then(null, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Promise.reject(error)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。</span><br><span class="line"> */</span><br><span class="line">Promise.resolve = function(value) &#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		if(typeof value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; isFunction(value.then)) &#123;</span><br><span class="line">			value.then();</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			resolve(value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.reject = function(reason) &#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		reject(reason);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * all方法，可以传入多个promise，全部执行完后会将结果以数组的方式返回，如果有一个失败就返回失败</span><br><span class="line"> */</span><br><span class="line">Promise.all = function(promises) &#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		let result = []; // all方法最终返回的结果</span><br><span class="line">		let count = 0; // 完成的数量</span><br><span class="line">		for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">			promises[i].then(function(data) &#123;</span><br><span class="line">				result[i] = data;</span><br><span class="line">				if(++count == promises.length) &#123;</span><br><span class="line">					resolve(result);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;, function(err) &#123;</span><br><span class="line">				reject(err);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * race方法，可以传入多个promise，返回的是第一个执行完的resolve的结果，如果有一个失败就返回失败</span><br><span class="line"> */</span><br><span class="line">Promise.race = function(promises) &#123;</span><br><span class="line">	return new Promise(function(resolve, reject) &#123;</span><br><span class="line">		for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">			promises[i].then(function(data) &#123;</span><br><span class="line">				resolve(data);</span><br><span class="line">			&#125;, function(err) &#123;</span><br><span class="line">				reject(err);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = function() &#123;</span><br><span class="line">	var defer = &#123;&#125;;</span><br><span class="line">	defer.promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">		defer.resolve = resolve;</span><br><span class="line">		defer.reject = reject;</span><br><span class="line">	&#125;)</span><br><span class="line">	return defer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一些会多次使用的复用功能函数</span><br><span class="line"> */</span><br><span class="line">function isFunction(obj) &#123;</span><br><span class="line">	return typeof obj === &quot;function&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最后可以通过以下命令安装一个promises测试插件，用插件来测试自己实现的promise符不符合规范</span><br><span class="line"> * npm(cnpm) i -g promises-aplus-tests</span><br><span class="line"> * promises-aplus-tests Promise.js</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = Promise;</span><br></pre></td></tr></table></figure>
<h3 id="ES6-promise"><a href="#ES6-promise" class="headerlink" title="ES6 promise"></a>ES6 promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">class es6Promise &#123;</span><br><span class="line">	constructor(task) &#123;</span><br><span class="line">		let self = this; //缓存this</span><br><span class="line">		self.status = &apos;pending&apos;; //默认状态为pending</span><br><span class="line">		self.value = undefined; //存放着此promise的结果</span><br><span class="line">		self.onResolvedCallbacks = []; //存放着所有成功的回调函数</span><br><span class="line">		self.onRejectedCallbacks = []; //存放着所有的失败的回调函数</span><br><span class="line"></span><br><span class="line">		// 调用resolve方法可以把promise状态变成成功态</span><br><span class="line">		function resolve(value) &#123;</span><br><span class="line">			if(value instanceof Promise) &#123;</span><br><span class="line">				return value.then(resolve, reject)</span><br><span class="line">			&#125;</span><br><span class="line">			setTimeout(() =&gt; &#123; // 异步执行所有的回调函数</span><br><span class="line">				// 如果当前状态是初始态（pending），则转成成功态</span><br><span class="line">				// 此处这个写判断的原因是因为resolved和rejected两个状态只能由pending转化而来，两者不能相互转化</span><br><span class="line">				if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">					self.value = value;</span><br><span class="line">					self.status = &apos;resolved&apos;;</span><br><span class="line">					self.onResolvedCallbacks.forEach(item =&gt; item(self.value));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 调用reject方法可以把当前的promise状态变成失败态</span><br><span class="line">		function reject(value) &#123;</span><br><span class="line">			setTimeout(() =&gt; &#123;</span><br><span class="line">				if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">					self.value = value;</span><br><span class="line">					self.status = &apos;rejected&apos;;</span><br><span class="line">					self.onRejectedCallbacks.forEach(item =&gt; item(value));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 立即执行传入的任务</span><br><span class="line">		try &#123;</span><br><span class="line">			task(resolve, reject);</span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			reject(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * onFulfilled成功的回调，onReject失败的回调</span><br><span class="line">	 * 原型链方法</span><br><span class="line">	 */</span><br><span class="line">	then(onFulfilled, onRejected) &#123;</span><br><span class="line">		let self = this;</span><br><span class="line">		// 当调用时没有写函数给它一个默认函数值</span><br><span class="line">		onFulfilled = isFunction(onFulfilled) ? onFulfilled : value =&gt; value;</span><br><span class="line">		onRejected = isFunction(onRejected) ? onRejected : value =&gt; &#123;</span><br><span class="line">			throw value</span><br><span class="line">		&#125;;</span><br><span class="line">		let promise2;</span><br><span class="line">		if(self.status == &apos;resolved&apos;) &#123;</span><br><span class="line">			promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">				setTimeout(() =&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						let x = onFulfilled(self.value);</span><br><span class="line">						resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">					&#125; catch(e) &#123;</span><br><span class="line">						reject(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(self.status == &apos;rejected&apos;) &#123;</span><br><span class="line">			promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">				setTimeout(() =&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						let x = onRejected(self.value);</span><br><span class="line">						resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">					&#125; catch(e) &#123;</span><br><span class="line">						reject(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">			promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">				self.onResolvedCallbacks.push(value =&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						let x = onFulfilled(value);</span><br><span class="line">						resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">					&#125; catch(e) &#123;</span><br><span class="line">						reject(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				self.onRejectedCallbacks.push(value =&gt; &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						let x = onRejected(value);</span><br><span class="line">						resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">					&#125; catch(e) &#123;</span><br><span class="line">						reject(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		return promise2;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * catch实际上是then的一个简写,成功回调传空值即可</span><br><span class="line">	 * 原型链方法</span><br><span class="line">	 */</span><br><span class="line">	catch(onRejected) &#123;</span><br><span class="line">		return this.then(null, onRejected);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Promise.reject(err)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。</span><br><span class="line">	 * 静态方法为类自己的方法，不在原型链上</span><br><span class="line">	 */</span><br><span class="line">	static resolve(value) &#123;</span><br><span class="line">		return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			if(typeof value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; isFunction(value.then)) &#123;</span><br><span class="line">				value.then();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				resolve(value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	static reject(err) &#123;</span><br><span class="line">		return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			reject(err);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * all方法，可以传入多个promise，全部执行完后会将结果以数组的方式返回，如果有一个失败就返回失败</span><br><span class="line">	 * 静态方法为类自己的方法，不在原型链上</span><br><span class="line">	 */</span><br><span class="line">	static all(promises) &#123;</span><br><span class="line">		return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			let result = []; // all方法最终返回的结果</span><br><span class="line">			let count = 0; // 完成的数量</span><br><span class="line">			for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">				promises[i].then(data =&gt; &#123;</span><br><span class="line">					result[i] = data;</span><br><span class="line">					if(++count == promises.length) &#123;</span><br><span class="line">						resolve(result);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, err =&gt; &#123;</span><br><span class="line">					reject(err);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * race方法，可以传入多个promise，返回的是第一个执行完的resolve的结果，如果有一个失败就返回失败</span><br><span class="line">	 *  静态方法为类自己的方法，不在原型链上</span><br><span class="line">	 */</span><br><span class="line">	static race(promises) &#123;</span><br><span class="line">		return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">			for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">				promises[i].then(data =&gt; &#123;</span><br><span class="line">					resolve(data);</span><br><span class="line">				&#125;, err =&gt; &#123;</span><br><span class="line">					reject(err);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * resolvePromise函数的目的是与原生Promise相兼容，可以互相调用</span><br><span class="line"> */</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">	// 将返回的promise不停的调用执行，直到失败或者返回一个普通的数据类型</span><br><span class="line">	if(promise2 === x) &#123;</span><br><span class="line">		return reject(new TypeError(&apos;循环引用&apos;));</span><br><span class="line">	&#125;</span><br><span class="line">	let then;</span><br><span class="line">	let called;</span><br><span class="line"></span><br><span class="line">	if(x != null &amp;&amp; ((typeof x == &apos;object&apos; || isFunction(x)))) &#123;</span><br><span class="line">		// promise</span><br><span class="line">		try &#123;</span><br><span class="line">			then = x.then;</span><br><span class="line">			if(isFunction(then)) &#123;</span><br><span class="line">				then.call(x, value =&gt; &#123;</span><br><span class="line">					if(called) return;</span><br><span class="line">					called = true;</span><br><span class="line">					resolvePromise(promise2, value, resolve, reject);</span><br><span class="line">				&#125;, reason =&gt; &#123;</span><br><span class="line">					if(called) return;</span><br><span class="line">					called = true;</span><br><span class="line">					reject(reason);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				resolve(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			if(called) return;</span><br><span class="line">			called = true;</span><br><span class="line">			reject(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		resolve(x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = () =&gt; &#123;</span><br><span class="line">	const defer = &#123;&#125;;</span><br><span class="line">	defer.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">		defer.resolve = resolve;</span><br><span class="line">		defer.reject = reject;</span><br><span class="line">	&#125;)</span><br><span class="line">	return defer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一些会多次使用的复用功能函数</span><br><span class="line"> */</span><br><span class="line">function isFunction(obj) &#123;</span><br><span class="line">	return typeof obj === &quot;function&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最后可以通过以下命令安装一个promises测试插件，用插件来测试自己实现的promise符不符合规范</span><br><span class="line"> * npm(cnpm) i -g promises-aplus-tests</span><br><span class="line"> * promises-aplus-tests es6Promise.js</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = es6Promise;</span><br></pre></td></tr></table></figure>
<h3 id="使用promise手动封装ajax函数"><a href="#使用promise手动封装ajax函数" class="headerlink" title="使用promise手动封装ajax函数"></a>使用promise手动封装ajax函数</h3><blockquote>
<p>跨浏览器实现Ajax兼容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var createXMLHttpRequest = function () &#123;</span><br><span class="line">  if ( window.XMLHttpRequest ) &#123;</span><br><span class="line">      return new XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( window.ActiveXObject ) &#123;</span><br><span class="line">      return new ActiveXObject(&apos;Microsoft.XMLHttp&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ajax的xhr对象有如下常用API</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onloadstart                     开始send触发</span><br><span class="line">onprogress                      从服务器上下载数据每50ms触发一次,判断进度</span><br><span class="line">onload                          得到响应</span><br><span class="line">onerror                         服务器异常</span><br><span class="line">open                            xhr.open(&apos;GET&apos;, url, true)  请求方式,请求url, true(默认)异步请求 </span><br><span class="line">onloadend                       请求结束，无论成功失败</span><br><span class="line">onreadystatechange              xhr.readyState改变使触发</span><br><span class="line">onabort                         调用xhr.abort时触发</span><br><span class="line">ontimeout                       超时触发</span><br><span class="line">setRequestHeader                设置RequestHeader，eg：xhr.setRequestHeader(&apos;Accept&apos;,&apos;application/json&apos;);</span><br><span class="line">                                xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.getAllResponseHeaders()     返回全部头信息,string</span><br><span class="line">getResponseHeader               获取Response头信息，eg：xhr.getResponseHeader(&apos;date&apos;);</span><br><span class="line">                                xhr.getResponseHeader(&apos;content-type&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>readyState上面都是静态函数。而readyState表示了请求的状态:</p>
</blockquote>
<ul>
<li>value=0,open()方法还未被调用</li>
<li>value=1,open()调用,send()方法还未被调用</li>
<li>value=2,send()方法已经被调用，响应头和响应状态已经返回</li>
<li>value=3,响应体下载中，responseText中已经获取了部分数据</li>
<li>value=4,请求完成，整个请求过程已经完毕。</li>
</ul>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getJSON (url) &#123;</span><br><span class="line">    return new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;, url, true)</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">            //if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304))</span><br><span class="line">            if (xhr.readyState === 4) &#123;</span><br><span class="line">                if (xhr.status === 200) &#123;</span><br><span class="line">                    resolve(this.responseText, this)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    var resJson = &#123; code: this.status, response: this.response &#125;</span><br><span class="line">                    reject(resJson, this)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function postJSON(url, data) &#123;</span><br><span class="line">    return new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&quot;POST&quot;, url, true)</span><br><span class="line">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">             //if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304))</span><br><span class="line">            if (xhr.readyState === 4) &#123;</span><br><span class="line">                if (xhr.status === 200) &#123;</span><br><span class="line">                    resolve(JSON.parse(this.responseText), this)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    var resJson = &#123; code: this.status, response: this.response &#125;</span><br><span class="line">                    reject(resJson, this)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(JSON.stringify(data))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">// ajax函数的默认参数</span><br><span class="line">var ajaxOptions = &#123;</span><br><span class="line">    url: &apos;#&apos;,</span><br><span class="line">    method: &apos;GET&apos;,</span><br><span class="line">    async: true,</span><br><span class="line">    timeout: 0,</span><br><span class="line">    data: null,</span><br><span class="line">    dataType: &apos;text&apos;,</span><br><span class="line">    headers: &#123;&#125;,</span><br><span class="line">    onprogress: function () &#123; &#125;,</span><br><span class="line">    onuploadprogress: function () &#123; &#125;,</span><br><span class="line">    xhr: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ajax函数，返回一个promise对象</span><br><span class="line"> * @param &#123;Object&#125; optionsOverride 参数设置，支持的参数如下</span><br><span class="line"> *   url:                     url地址，默认&quot;#&quot;</span><br><span class="line"> *   method:                  请求方法，仅支持GET,POST,默认GET</span><br><span class="line"> *   async:                   是否异步，默认true</span><br><span class="line"> *   timeout:                 请求时限，超时将在promise中调用reject函数</span><br><span class="line"> *   data:                    发送的数据，该函数不支持处理数据，将会直接发送</span><br><span class="line"> *   dataType:                接受的数据的类型，默认为text</span><br><span class="line"> *   headers:                 一个对象，包含请求头信息</span><br><span class="line"> *   onprogress:              处理onprogress的函数</span><br><span class="line"> *   ouploadprogress:         处理.upload.onprogress的函数</span><br><span class="line"> *   xhr:                     允许在函数外部创建xhr对象传入，但必须不能是使用过的</span><br><span class="line"> </span><br><span class="line"> * @return &#123;Promise&#125; </span><br><span class="line"> *   该函数注册xhr.onloadend回调函数，判断xhr.status是否属于 [200,300)&amp;&amp;304 ，</span><br><span class="line"> *   如果属于则promise引发resolve状态，允许拿到xhr对象</span><br><span class="line"> *   如果不属于，或已经引发了ontimeout,onabort,则引发reject状态，允许拿到xhr对象</span><br><span class="line"> * </span><br><span class="line"> * 关于reject</span><br><span class="line"> *   返回一个对象，包含</span><br><span class="line"> *     errorType:错误类型，</span><br><span class="line"> *     abort_error:   xhr对象调用abort函数</span><br><span class="line"> *     timeout_error: 请求超时</span><br><span class="line"> *     onerror:       xhr对象触发了onerror事件</span><br><span class="line"> *     send_error:    发送请求出现错误</span><br><span class="line"> *     status_error:  响应状态不属于 [200,300)&amp;&amp;304</span><br><span class="line"> */</span><br><span class="line">function ajax(optionsOverride) &#123;</span><br><span class="line">    // 将传入的参数与默认设置合并</span><br><span class="line">    var options = &#123;&#125;;</span><br><span class="line">    for (var k in ajaxOptions) &#123;</span><br><span class="line">        options[k] = optionsOverride[k] || ajaxOptions[k];</span><br><span class="line">    &#125;</span><br><span class="line">    options.async = options.async === false ? false : true;</span><br><span class="line">    var xhr = options.xhr = options.xhr || new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        xhr.open(options.method, options.url, options.async);</span><br><span class="line">        xhr.timeout = options.timeout;</span><br><span class="line"></span><br><span class="line">        //设置请求头</span><br><span class="line">        for (var k in options.headers) &#123;</span><br><span class="line">            xhr.setRuquestHeader(k, options.headers[k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 注册xhr对象事件</span><br><span class="line">        xhr.onprogress = options.onprogress;</span><br><span class="line">        xhr.upload.onprogress = options.onuploadprogress;</span><br><span class="line">        xhr.responseType = options.dataType;</span><br><span class="line"></span><br><span class="line">        xhr.onabort = function () &#123;</span><br><span class="line">            reject(new Error(&#123;</span><br><span class="line">                errorType: &apos;abort_error&apos;,</span><br><span class="line">                xhr: xhr</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.ontimeout = function () &#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &apos;timeout_error&apos;,</span><br><span class="line">                xhr: xhr</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onerror = function () &#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &apos;onerror&apos;,</span><br><span class="line">                xhr: xhr</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onloadend = function () &#123;</span><br><span class="line">            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304)</span><br><span class="line">                resolve(xhr);</span><br><span class="line">            else&#123;</span><br><span class="line">	                reject(&#123;</span><br><span class="line">	                    errorType: &apos;status_error&apos;,</span><br><span class="line">	                    xhr: xhr</span><br><span class="line">	                &#125;)</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            xhr.send(options.data);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (e) &#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &apos;send_error&apos;,</span><br><span class="line">                error: e</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><blockquote>
<p>非递归算法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function binary_search(arr,key)&#123;</span><br><span class="line">  var low=0,</span><br><span class="line">  high=arr.length-1;</span><br><span class="line">  while(low&lt;=high)&#123;</span><br><span class="line">     var mid=parseInt((high+low)/2);</span><br><span class="line">     if(key==arr[mid])&#123;</span><br><span class="line">        return mid;</span><br><span class="line">     &#125;else if(key&gt;arr[mid])&#123;</span><br><span class="line">        low=mid+1;</span><br><span class="line">     &#125;else if(key&lt;arr[mid])&#123;</span><br><span class="line">        high=mid-1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var arr=[1,2,3,4,5,6,7,8,9,10,11,23,44,86];</span><br><span class="line">var result=binary_search(arr,10);</span><br><span class="line">alert(result); // 9 返回目标元素的索引值</span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归算法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function binary_search(arr,low,high,key)&#123;</span><br><span class="line">  if(low&gt;high)&#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  var mid=parseInt((high+low)/2);</span><br><span class="line">  if(arr[mid]==key)&#123;</span><br><span class="line">    return mid;</span><br><span class="line">  &#125;else if(arr[mid]&gt;key)&#123;</span><br><span class="line">    high=mid-1;</span><br><span class="line">    return binary_search(arr,low,high,key);</span><br><span class="line">  &#125;else if(arr[mid]&lt;key)&#123;</span><br><span class="line">    low=mid+1;</span><br><span class="line">    return binary_search(arr,low,high,key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var arr=[1,2,3,4,5,6,7,8,9,10,11,23,44,86];</span><br><span class="line">var result=binary_search(arr,0,13,10);</span><br><span class="line">alert(result); // 9 返回目标元素的索引值</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p>冒泡排序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = i+1; j &lt; len -1; j++) &#123;</span><br><span class="line">            arr[i] &gt; arr[j] ? [arr[i],arr[j]]= [arr[j],arr[i]]:null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bubbleSort([1,2,4,7,2,8,0,9,11,32,17])</span><br><span class="line">           [0, 1, 2, 2, 4, 7, 8, 9, 11, 32, 17]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bubble_sort(arr)&#123;</span><br><span class="line">  for(var i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">    for(var j=0;j&lt;arr.length-i-1;j++)&#123;</span><br><span class="line">      if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">        var swap=arr[j];</span><br><span class="line">        arr[j]=arr[j+1];</span><br><span class="line">        arr[j+1]=swap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr=[3,1,5,7,2,4,9,6,10,8];</span><br><span class="line">bubble_sort(arr);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>快速排序</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function quick_sort(arr)&#123;</span><br><span class="line">  if(arr.length&lt;=1)&#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  var pivotIndex=Math.floor(arr.length/2);</span><br><span class="line">  var pivot=arr.splice(pivotIndex,1)[0];</span><br><span class="line"></span><br><span class="line">  var left=[];</span><br><span class="line">  var right=[];</span><br><span class="line">  for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(arr[i]&lt;pivot)&#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return quick_sort(left).concat([pivot],quick_sort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr=[5,6,2,1,3,8,7,1,2,3,4,7];</span><br><span class="line">console.log(quick_sort(arr));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function qSort(arr) &#123;</span><br><span class="line">      if (arr.length==0) &#123;</span><br><span class="line">          return [];</span><br><span class="line">      &#125;</span><br><span class="line">      var left = [];</span><br><span class="line">      var right = [];</span><br><span class="line">      var pivot = arr[0];</span><br><span class="line">      for (var i =1; i &lt;arr.length; i++) &#123; // 注意这里的起始值，因为有一个作为flag了</span><br><span class="line">         if (arr[i] &lt; pivot) &#123;</span><br><span class="line">               left.push(arr[i]);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              right.push(arr[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return qSort(left).concat(pivot, qSort(right));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="当我们-new-一个类的时候-都发生了什么"><a href="#当我们-new-一个类的时候-都发生了什么" class="headerlink" title="当我们 new 一个类的时候 都发生了什么"></a>当我们 new 一个类的时候 都发生了什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * new2 new关键字的代码实现演示</span><br><span class="line"> * @param &#123;function&#125; func 被new的类 (构造函数)</span><br><span class="line"> */</span><br><span class="line">function new2(func) &#123;</span><br><span class="line">    // 创建了一个实例对象 o，并且这个对象__proto__指向func这个类的原型对象 </span><br><span class="line">    let o = Object.create(func.prototype); </span><br><span class="line">    // (在构造函数中this指向当前实例)让这个类作为普通函数值行 并且里面this为实例对象 </span><br><span class="line">    let k = func.call(o);</span><br><span class="line">    // 最后再将实例对象返回 如果你在类中显示指定返回值k，</span><br><span class="line">    // 注意如果返回的是引用类型则将默认返回的实例对象o替代掉</span><br><span class="line">    return typeof k === &apos;object&apos; ? k : o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实验</span><br><span class="line">functionM() &#123; // 即将被new的类</span><br><span class="line">    this.name = &apos;liwenli&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let m = new2(M); // 等价于 new M 这里只是模拟</span><br><span class="line">console.log(m instanceof M); // instanceof 检测实例</span><br><span class="line">console.log(m instanceof Object);</span><br><span class="line">console.log(m.__proto__.constructor === M);</span><br></pre></td></tr></table></figure>
<h3 id="Object-create-兼容实现"><a href="#Object-create-兼容实现" class="headerlink" title="Object.create 兼容实现"></a>Object.create 兼容实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;id: 1&#125;;</span><br><span class="line">        Object._create = (o) =&gt; &#123;</span><br><span class="line">            let Fn = function() &#123;&#125;; // 临时的构造函数</span><br><span class="line">            Fn.prototype = o;</span><br><span class="line">            return new Fn;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let obj2 = Object._create(obj1);</span><br><span class="line">        console.log(obj2.__proto__ === obj1); // true</span><br><span class="line">        console.log(obj2.id); // 1</span><br><span class="line"></span><br><span class="line">        // 原生的Object.create</span><br><span class="line">        let obj3 = Object.create(obj1);</span><br><span class="line">        console.log(obj3.__proto__ === obj1); // true</span><br><span class="line">        console.log(obj3.id); // 1</span><br></pre></td></tr></table></figure>
<h3 id="curry-将多参数函数转换为接收单一参数的函数"><a href="#curry-将多参数函数转换为接收单一参数的函数" class="headerlink" title="curry 将多参数函数转换为接收单一参数的函数"></a>curry 将多参数函数转换为接收单一参数的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let fn = function(a, b, c) &#123; // 多参数函数</span><br><span class="line">           return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">        function curry(fn) &#123;</span><br><span class="line">            let args = []; // 收集参数</span><br><span class="line">            let len = fn.length;</span><br><span class="line">            returnfunctionfe() &#123;</span><br><span class="line">                args = args.concat([].slice.call(arguments, 0));</span><br><span class="line">                if (args.length === len) &#123;</span><br><span class="line">                    return fn.apply(null, args);</span><br><span class="line">                &#125;</span><br><span class="line">                return fe;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        console.log(curry(fn)(1)(2)(3)); // 6</span><br></pre></td></tr></table></figure>
<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><blockquote>
<p>throttle 策略的电梯。保证如果电梯第一个人进来后，50毫秒后准时运送一次，不等待。如果没有人，则待机。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let throttle = (fn, delay = 50) =&gt; &#123; // 节流 控制执行间隔时间 防止频繁触发 scroll resize mousemove</span><br><span class="line">            let stattime = 0;</span><br><span class="line">            returnfunction (...args) &#123;</span><br><span class="line">                let curTime = new Date();</span><br><span class="line">                if (curTime - stattime &gt;= delay) &#123;</span><br><span class="line">                    fn.apply(this, args);</span><br><span class="line">                    stattime = curTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="防抖动"><a href="#防抖动" class="headerlink" title="防抖动"></a>防抖动</h3><blockquote>
<p>debounce 策略的电梯。如果电梯里有人进来，等待50毫秒。如果又人进来，50毫秒等待重新计时，直到50毫秒超时，开始运送。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let debounce = (fn, time = 50) =&gt; &#123; // 防抖动 控制空闲时间 用户输入频繁</span><br><span class="line">            let timer;</span><br><span class="line">            returnfunction (...args) &#123;</span><br><span class="line">                let that = this;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                timer = setTimeout(fn.bind(that, ...args), time);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Function的bind实现"><a href="#Function的bind实现" class="headerlink" title="Function的bind实现"></a>Function的bind实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype._bind = function(context) &#123;</span><br><span class="line">    let func = this;</span><br><span class="line">    let params = [].slice.call(arguments, 1);</span><br><span class="line">    returnfunction() &#123;</span><br><span class="line">        params = params.concat([].slice.call(arguments, 0));</span><br><span class="line">        func.apply(context, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;id: 24&#125;</span><br><span class="line"></span><br><span class="line">function fn1(a) &#123;</span><br><span class="line">    console.log(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">let foo = fn1._bind(obj, obj.id);</span><br></pre></td></tr></table></figure>
<h3 id="函数组合串联compose（koa-reduce中间件）"><a href="#函数组合串联compose（koa-reduce中间件）" class="headerlink" title="函数组合串联compose（koa reduce中间件）"></a>函数组合串联compose（koa reduce中间件）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 组合串联</span><br><span class="line">let fn1 = (a) =&gt; a + 1;</span><br><span class="line">let fn2 = (b) =&gt; b + 2;</span><br><span class="line">let fn3 = (c) =&gt; c + 3;</span><br><span class="line"></span><br><span class="line">let funs = [fn1, fn2, fn3];</span><br><span class="line"></span><br><span class="line">let compose = (func) =&gt; &#123;</span><br><span class="line">    return arg =&gt; func.reduceRight((composed, fn) =&gt; fn(composed), arg);</span><br><span class="line">&#125;</span><br><span class="line">console.log(compose(funs)(100)); // 相当于fn1(fn2(fn3(100)))</span><br></pre></td></tr></table></figure>
<h3 id="co函数"><a href="#co函数" class="headerlink" title="co函数"></a>co函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function* fn(a) &#123;</span><br><span class="line">  a = yield a;</span><br><span class="line">  let b = yield 2;</span><br><span class="line">  let c = yield 3;</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function co(fn, ...args) &#123;</span><br><span class="line">  let g = fn(...args);</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    function next(lastValue) &#123;</span><br><span class="line">        let &#123; value, done &#125; = g.next(lastValue);</span><br><span class="line">        if (done) &#123;</span><br><span class="line">          resolve(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         if (value instanceof Promise) &#123;</span><br><span class="line">           value.then(next, (val) =&gt; reject(val));</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           next(value)</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">co(fn, 100).then(value =&gt; &#123;</span><br><span class="line">    console.log(value); // 105</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="如何主动中止Promise调用链"><a href="#如何主动中止Promise调用链" class="headerlink" title="如何主动中止Promise调用链"></a>如何主动中止Promise调用链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123; // 异步操作</span><br><span class="line">      resolve(&apos;start&apos;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then((result) =&gt; &#123;</span><br><span class="line">   console.log(&apos;a&apos;, result); </span><br><span class="line">   return Promise.reject(&apos;中断后续调用&apos;); // 此时rejected的状态将直接跳到catch里，剩下的调用不会再继续</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">   console.log(&apos;b&apos;, result);</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">   console.log(&apos;c&apos;, result);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">   console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// a start</span><br><span class="line">// 中断后续调用</span><br></pre></td></tr></table></figure>
<h3 id="window-requestAnimationFrame兼容性处理"><a href="#window-requestAnimationFrame兼容性处理" class="headerlink" title="window.requestAnimationFrame兼容性处理"></a>window.requestAnimationFrame兼容性处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window._requestAnimationFrame = (function()&#123;</span><br><span class="line">  return  window.requestAnimationFrame       ||</span><br><span class="line">          window.webkitRequestAnimationFrame ||</span><br><span class="line">          window.mozRequestAnimationFrame    ||</span><br><span class="line">          function(callback)&#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">          &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="字符串是否符合回文规则"><a href="#字符串是否符合回文规则" class="headerlink" title="字符串是否符合回文规则"></a>字符串是否符合回文规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;My age is 0, 0 si ega ym.&apos;;</span><br><span class="line"></span><br><span class="line">方法一</span><br><span class="line">function palindrome(params) &#123;</span><br><span class="line">  params = params.replace(/[\W\s_]/ig, &apos;&apos;);</span><br><span class="line"> return params.toLowerCase()  === params.split(&apos;&apos;).reverse().join(&apos;&apos;).toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line">console.log(palindrome(str));</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">function palindrome(params) &#123;</span><br><span class="line">  params = params.replace(/[\W\s_]/ig, &apos;&apos;).toLowerCase();</span><br><span class="line">  for (var i = 0, j = params.length-1; i&lt;j; i++, j--) &#123;</span><br><span class="line">    if (params[i] !== params[j]) &#123;</span><br><span class="line">      returnfalse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  returntrue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解构-将-destructuringArray-1-2-3-4-“-a-b-c-”-gt-a-1-b-2-c-4"><a href="#解构-将-destructuringArray-1-2-3-4-“-a-b-c-”-gt-a-1-b-2-c-4" class="headerlink" title="解构:将 destructuringArray([1, [2, 3], 4], “[a, [b], c]”) =&gt; {a: 1, b: 2, c: 4}"></a>解构:将 destructuringArray([1, [2, 3], 4], “[a, [b], c]”) =&gt; {a: 1, b: 2, c: 4}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 将 destructuringArray([1, [2, 3], 4], &quot;[a, [b], c]&quot;) =&gt; &#123;a: 1, b: 2, c: 4&#125;</span><br><span class="line">const targetArray = [1, [2, 3], 4];</span><br><span class="line">const formater = &quot;[a, [b], c]&quot;;</span><br><span class="line"></span><br><span class="line">const destructuringArray = (values, keys) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const obj = &#123;&#125;;</span><br><span class="line">    if (typeof keys === &apos;string&apos;) &#123;</span><br><span class="line">      keys = JSON.parse(keys.replace(/\w+/g, &apos;&quot;$&amp;&quot;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const iterate = (values, keys) =&gt;</span><br><span class="line">      keys.forEach((key, i) =&gt; &#123;</span><br><span class="line">        if(Array.isArray(key)) iterate(values[i], key)</span><br><span class="line">        else obj[key] = values[i]</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    iterate(values, keys)</span><br><span class="line">    </span><br><span class="line">    return obj;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组展平"><a href="#数组展平" class="headerlink" title="数组展平"></a>数组展平</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">将[[1, 2], 3, [[[4], 5]]] 展平为 [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">let arr = [[1, 2], 3, [[[4], 5]]]; // 数组展平</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return [].concat(</span><br><span class="line">        ...arr.map(x =&gt; Array.isArray(x) ? flatten(x) : x)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出数组中重复出现过的元素"><a href="#找出数组中重复出现过的元素" class="headerlink" title="找出数组中重复出现过的元素"></a>找出数组中重复出现过的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 例如：[1，2，4，4，3，3，1，5，3]</span><br><span class="line">// 输出：[1，3，4]</span><br><span class="line">let arr = [1, 2, 4, 4, 3, 3, 1, 5, 3];</span><br><span class="line"></span><br><span class="line">// 方法一</span><br><span class="line">function repeat1(arr)&#123;</span><br><span class="line">	var result = [], map = &#123;&#125;;</span><br><span class="line">	arr.map(function(num)&#123;</span><br><span class="line">	if(map[num] === 1) result.push(num); // 等于1说明之前出现过一次 这次重复出现了</span><br><span class="line">		map[num] = (map[num] || 0) + 1; // 微妙之处 开始第一次出现无值 记为 0 + 1 = 1 下一次从1开始累加</span><br><span class="line">	&#125;);</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(repeat1(arr));</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line"></span><br><span class="line">function repeat(arr) &#123;</span><br><span class="line">    let result = arr.filter((x, i, self) =&gt; &#123;</span><br><span class="line">        return self.indexOf(x) === i &amp;&amp; self.lastIndexOf(x) !== i</span><br><span class="line">    &#125;); // </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(repeat(arr));</span><br></pre></td></tr></table></figure>
<h3 id="将数组中按照数字重复出现的次数进行排序"><a href="#将数组中按照数字重复出现的次数进行排序" class="headerlink" title="将数组中按照数字重复出现的次数进行排序"></a>将数组中按照数字重复出现的次数进行排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 如果次数相同 则按照值排序 比如  2, 2, 2和 1, 1, 1  应排序为 [1, 1, 1, 2, 2, 2]</span><br><span class="line">// 比如 [1,2,1,2,1,3,4,5,4,5,5,2,2] =&gt; [3, 4, 4, 1, 1, 1, 5, 5, 5, 2, 2, 2, 2]</span><br><span class="line"></span><br><span class="line">let arr = [9, 7, 7, 1, 2, 1, 2, 1, 3, 4, 5, 4, 5, 5, 2, 2];</span><br><span class="line">function sortArray(arr) &#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    let newArr = [];</span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      let cur = arr[i];</span><br><span class="line">      if(obj[cur])&#123;</span><br><span class="line">        obj[cur].push(cur);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      obj[cur] = [cur];</span><br><span class="line">    &#125;</span><br><span class="line">    for(let k in obj) &#123;</span><br><span class="line">      if(obj.hasOwnProperty(k)) &#123;</span><br><span class="line">        newArr.push(obj[k])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newArr.sort((a, b) =&gt; &#123;</span><br><span class="line">      if(a.length === b.length)&#123;</span><br><span class="line">        return a[0] - b[0];</span><br><span class="line">      &#125;</span><br><span class="line">        return a.length - b.length;</span><br><span class="line">    &#125;);</span><br><span class="line">    newArr = newArr.reduce((prev, cur) =&gt; prev.concat(cur));</span><br><span class="line">    return newArr;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(sortArray(arr)); // [ 3, 9, 4, 4, 7, 7, 1, 1, 1, 5, 5, 5, 2, 2, 2, 2 ]</span><br></pre></td></tr></table></figure>
<h3 id="移动端关闭虚拟键盘"><a href="#移动端关闭虚拟键盘" class="headerlink" title="移动端关闭虚拟键盘"></a>移动端关闭虚拟键盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.activeElement.blur();</span><br></pre></td></tr></table></figure>
<h3 id="解决setInterval在浏览器切换中的问题"><a href="#解决setInterval在浏览器切换中的问题" class="headerlink" title="解决setInterval在浏览器切换中的问题"></a>解决setInterval在浏览器切换中的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.onvisibilitychange=function()&#123;</span><br><span class="line">  if(document.visibilityState==&quot;visible&quot;)&#123;</span><br><span class="line">      timer=setInterval(slidemove, 1000);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-透传"><a href="#Promise-透传" class="headerlink" title="Promise 透传"></a>Promise 透传</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1).then(2).then((a)=&gt;console.log(a))</span><br><span class="line"> 1</span><br><span class="line">Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不用循环，创建一个长度为-100-的数组，并且每个元素的值等于它的下标"><a href="#不用循环，创建一个长度为-100-的数组，并且每个元素的值等于它的下标" class="headerlink" title="不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标"></a>不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">es6版：</span><br><span class="line">Array.from(Array(100).keys()) </span><br><span class="line">或者</span><br><span class="line">[...Array(100).keys()]</span><br><span class="line"></span><br><span class="line">Array(100).fill(0).map((t,i)=&gt;i)</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</span><br><span class="line"></span><br><span class="line">（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</span><br><span class="line"></span><br><span class="line">（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</span><br><span class="line"></span><br><span class="line">（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</span><br><span class="line"></span><br><span class="line">上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br><span class="line">// id: 42</span><br></pre></td></tr></table></figure>
<h3 id="异步加载的区别"><a href="#异步加载的区别" class="headerlink" title="异步加载的区别"></a>异步加载的区别</h3><ul>
<li>defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行</li>
<li>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关<br>async和defer<br><img src="/2015/01/01/JS原生常用API大全/640.webp" alt=""></li>
</ul>
<h3 id="html-触底的条件是："><a href="#html-触底的条件是：" class="headerlink" title="html 触底的条件是："></a>html 触底的条件是：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement.scrollHeight ===</span><br><span class="line">document.documentElement.clientHeight + document.documentElement.scrollTop</span><br></pre></td></tr></table></figure>
<h3 id="雅虎十四条优化"><a href="#雅虎十四条优化" class="headerlink" title="雅虎十四条优化"></a>雅虎十四条优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 尽可能的减少 HTTP 的请求数	content</span><br><span class="line">2. 使用 CDN（Content Delivery Network）	server</span><br><span class="line">3. 添加 Expires 头(或者 Cache-control )	server</span><br><span class="line">4. Gzip 组件	server</span><br><span class="line">5. 将 CSS 样式放在页面的上方	css</span><br><span class="line">6. 将脚本移动到底部（包括内联的）	javascript</span><br><span class="line">7. 避免使用 CSS 中的 Expressions	css</span><br><span class="line">8. 将 JavaScript 和 CSS 独立成外部文件	javascript css</span><br><span class="line">9. 减少 DNS 查询	content</span><br><span class="line">10. 压缩 JavaScript 和 CSS (包括内联的)	javascript css</span><br><span class="line">11. 避免重定向	server</span><br><span class="line">12. 移除重复的脚本	javascript</span><br><span class="line">13. 配置实体标签（ETags）	css</span><br><span class="line">14. 使 AJAX 缓存</span><br><span class="line">15. DNS预读取 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://data.dadaabc.com/&quot;&gt;</span><br><span class="line">16. 多域名分发静态资源   同域下浏览器能并发的请求有限，为了增加并发，尤其是一些静态资源上，可以使用多个域名。</span><br><span class="line">17. 最小化重排和重绘</span><br><span class="line">18. 函数防抖和函数节流</span><br></pre></td></tr></table></figure>
<h3 id="微任务有两种-nextTick和then-那么这两个谁快呢？"><a href="#微任务有两种-nextTick和then-那么这两个谁快呢？" class="headerlink" title="微任务有两种 nextTick和then 那么这两个谁快呢？"></a>微任务有两种 nextTick和then 那么这两个谁快呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;123&apos;).then(res=&gt;&#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"> process.nextTick(() =&gt; console.log(&apos;nextTick&apos;))</span><br><span class="line"> </span><br><span class="line"> //顺序  nextTick 123</span><br><span class="line"> //很明显  nextTick快</span><br></pre></td></tr></table></figure>
<h3 id="setTimeout第三个参数"><a href="#setTimeout第三个参数" class="headerlink" title="setTimeout第三个参数"></a>setTimeout第三个参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function(...list)&#123;</span><br><span class="line">				console.log(list);    //  [1, 2, 3, 4, 5]</span><br><span class="line">			&#125;,100,1,2,3,4,5)</span><br></pre></td></tr></table></figure>
<h3 id="Object和Function之间最让人琢磨不透的"><a href="#Object和Function之间最让人琢磨不透的" class="headerlink" title="Object和Function之间最让人琢磨不透的"></a>Object和Function之间最让人琢磨不透的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object instanceof Object // true</span><br><span class="line">Object instanceof Function // true</span><br><span class="line">Function instanceof Function // true</span><br><span class="line">Function instanceof Object // true</span><br><span class="line"></span><br><span class="line">const o = &#123;&#125;</span><br><span class="line">o instanceof Object //true</span><br><span class="line">o instanceof Function // false</span><br><span class="line"></span><br><span class="line">function F () &#123;&#125;</span><br><span class="line">F instanceof Object //true</span><br><span class="line">F instanceof Function //true</span><br></pre></td></tr></table></figure>
<h3 id="文件上传进度提示使用Javascript的XMLHttpRequest的progress事件"><a href="#文件上传进度提示使用Javascript的XMLHttpRequest的progress事件" class="headerlink" title="文件上传进度提示使用Javascript的XMLHttpRequest的progress事件"></a>文件上传进度提示使用Javascript的XMLHttpRequest的progress事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">使用Javascript的XMLHttpRequest的progress事件，实现示例代码为：</span><br><span class="line"></span><br><span class="line">var formData = new FormData(); </span><br><span class="line">formData.append(&quot;file&quot;, document.getElementById(&apos;file&apos;).files[0]); </span><br><span class="line">formData.append(&quot;token&quot;, token_value); // 其他参数按这样子加入</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;POST&apos;, &apos;/uploadurl&apos;);</span><br><span class="line">// 上传完成后的回调函数</span><br><span class="line">xhr.onload = function () &#123;</span><br><span class="line">  if (xhr.status === 200) &#123;</span><br><span class="line">　　console.log(&apos;上传成功&apos;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  　console.log(&apos;上传出错&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 获取上传进度</span><br><span class="line">xhr.upload.onprogress = function (event) &#123;</span><br><span class="line">  if (event.lengthComputable) &#123;</span><br><span class="line">    var percent = Math.floor(event.loaded / event.total * 100) ;</span><br><span class="line">    // 设置进度显示</span><br><span class="line">    $(&quot;#J_upload_progress&quot;).progress(&apos;set progress&apos;, percent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			function A(obj) &#123;</span><br><span class="line">				obj.s = &quot;哈&quot;</span><br><span class="line">				obj = &#123;                     //obj 重新赋值，并且是一个对象，此时obj指向a的指针指向这个赋值对象</span><br><span class="line">					&quot;name&quot;: 2,</span><br><span class="line">					&quot;city&quot;: &quot;亚洲&quot;</span><br><span class="line">				&#125;</span><br><span class="line">				return obj</span><br><span class="line">			&#125;</span><br><span class="line">			var a = &#123;</span><br><span class="line">				&quot;name&quot;: 1,</span><br><span class="line">				&quot;city&quot;: &quot;中国&quot;</span><br><span class="line">			&#125;</span><br><span class="line">			var b = A(a);</span><br><span class="line">			console.log(b);   //&#123;name: 2, city: &quot;亚洲&quot;&#125;</span><br><span class="line">			console.log(a);   //&#123;name: 1, city: &quot;中国&quot;, s: &quot;哈&quot;&#125;</span><br><span class="line">		&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="LESS和SASS"><a href="#LESS和SASS" class="headerlink" title="LESS和SASS"></a>LESS和SASS</h3><table>
<thead>
<tr>
<th>语言</th>
<th>实现</th>
<th>特性</th>
<th>赋值</th>
<th>缩进</th>
</tr>
</thead>
<tbody>
<tr>
<td>Sass</td>
<td>Ruby</td>
<td>变量$开头</td>
<td>$var: value</td>
<td>不需要</td>
</tr>
<tr>
<td>Less</td>
<td>JavaSript</td>
<td>变量@开头</td>
<td>@var: value</td>
<td>不需要</td>
</tr>
<tr>
<td>Stylus</td>
<td>NodeJs</td>
<td>不能使用@开头</td>
<td>var:10</td>
<td>都可以</td>
</tr>
</tbody>
</table>
<h3 id="创造纯净的对象"><a href="#创造纯净的对象" class="headerlink" title="创造纯净的对象"></a>创造纯净的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">你可以创造100%纯净的对象，它不会从Object类继承任何方法（例如：构造函数、toString() 等）。</span><br><span class="line"></span><br><span class="line">const pureObject =Object.create(null);</span><br><span class="line">console.log(pureObject);//=&gt; &#123;&#125;</span><br><span class="line">console.log(pureObject.constructor);//=&gt; undefined</span><br><span class="line">console.log(pureObject.toString);//=&gt; undefined</span><br><span class="line">console.log(pureObject.hasOwnProperty);//=&gt; undefined</span><br></pre></td></tr></table></figure>
<h3 id="将一个任意长的数字变成逗号分割的格式"><a href="#将一个任意长的数字变成逗号分割的格式" class="headerlink" title="将一个任意长的数字变成逗号分割的格式"></a>将一个任意长的数字变成逗号分割的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"></span><br><span class="line">// 保留三位小数</span><br><span class="line">parseToMoney(1234.56); // return &apos;1,234.56&apos;</span><br><span class="line">parseToMoney(123456789); // return &apos;123,456,789&apos;</span><br><span class="line">parseToMoney(1087654.321); // return &apos;1,087,654.321&apos;</span><br><span class="line">答：</span><br><span class="line"></span><br><span class="line">functionparseToMoney(num) &#123;</span><br><span class="line">  num = parseFloat(num.toFixed(3));</span><br><span class="line">  let [integer, decimal] = String.prototype.split.call(num, &apos;.&apos;);</span><br><span class="line">  integer = integer.replace(/\d(?=(\d&#123;3&#125;)+$)/g, &apos;$&amp;,&apos;);</span><br><span class="line">  return integer + &apos;.&apos; + (decimal ? decimal : &apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检测对象中属性的存在"><a href="#检测对象中属性的存在" class="headerlink" title="检测对象中属性的存在"></a>检测对象中属性的存在</h3><blockquote>
<p>使用in关键字。</p>
</blockquote>
<p>该方法可以判断对象的自有属性和继承来的属性是否存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;x:1&#125;;</span><br><span class="line">&quot;x&quot; in o;            //true，自有属性存在</span><br><span class="line">&quot;y&quot; in o;            //false</span><br><span class="line">&quot;toString&quot; in o;     //true，是一个继承属性</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用对象的hasOwnProperty()方法。</p>
</blockquote>
<p>该方法只能判断自有属性是否存在，对于继承属性会返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;x:1&#125;;</span><br><span class="line">o.hasOwnProperty(&quot;x&quot;);    　　 //true，自有属性中有x</span><br><span class="line">o.hasOwnProperty(&quot;y&quot;);    　　 //false，自有属性中不存在y</span><br><span class="line">o.hasOwnProperty(&quot;toString&quot;); //false，这是一个继承属性，但不是自有属性</span><br></pre></td></tr></table></figure></p>
<h3 id="n"><a href="#n" class="headerlink" title="n!"></a>n!</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">functionfactorial(number)&#123;</span><br><span class="line">    if(number==1) &#123;</span><br><span class="line">      return number;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return number*factorial(number-1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="斐波那契数列-1-1-2-3-5-8-13-21-34-55-89-144-…-求第n个数是多少"><a href="#斐波那契数列-1-1-2-3-5-8-13-21-34-55-89-144-…-求第n个数是多少" class="headerlink" title="斐波那契数列:1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, … 求第n个数是多少"></a>斐波那契数列:1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, … 求第n个数是多少</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionfibonacci(number) &#123;</span><br><span class="line">     if (number &lt;=2) &#123;</span><br><span class="line">       return1;</span><br><span class="line">     &#125;</span><br><span class="line">     returnfibonacci(number-1) +fibonacci(number -2)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务端推送的几种方式"><a href="#服务端推送的几种方式" class="headerlink" title="服务端推送的几种方式"></a>服务端推送的几种方式</h3><p>服务端推送是现今<code>Web</code>开发过程中最常见的需求。例如：</p>
<ul>
<li>即时聊天工具</li>
<li>H5网络游戏</li>
<li>消息通知</li>
</ul>
<p>一般的服务器推送包括：</p>
<ul>
<li>最简单的是客户端轮询的方式，在客户端创建一个定时器，每隔一定的时间去请求服务端，每次请求检查状态变化以判断服务端是否有新数据更新。</li>
<li>基于 AJAX 的长轮询（<code>long-polling</code>）方式，服务器在一段时间后再返回信息；</li>
<li><code>HTTP Streaming</code>，通过<code>iframe</code>和<code>&lt;script&gt;</code>标签完成数据的传输；</li>
<li><code>TCP</code>长连接/<code>WebSocket</code>，可以实现服务器主动发送数据至网页端，它和<code>HTTP</code>一样，是一个基于<code>HTTP</code>的应用层协议，跑的是<code>TCP</code>，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像<code>HTTP</code>的请求和响应</li>
<li><code>SSE: Server-Sent Events</code>，【webpack】这是通过<code>http</code>协议变通实现的，通过服务端向客户端声明，接下来是要发送的是流信息，本质上就是完成一次耗时长的下载。</li>
</ul>
<hr>
<h3 id="JavaScript进阶提高必读"><a href="#JavaScript进阶提高必读" class="headerlink" title="JavaScript进阶提高必读"></a><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">JavaScript进阶提高必读</a></h3><h3 id="JavaScript常用七种继承方案"><a href="#JavaScript常用七种继承方案" class="headerlink" title="JavaScript常用七种继承方案"></a><a href="https://juejin.im/post/5bcb2e295188255c55472db0" target="_blank" rel="noopener">JavaScript常用七种继承方案</a></h3><h3 id="JS-面试原生常用api-方法大全"><a href="#JS-面试原生常用api-方法大全" class="headerlink" title="JS 面试原生常用api 方法大全"></a><a href="https://github.com/libin1991/libin_Blog/issues/476?from=timeline" target="_blank" rel="noopener">JS 面试原生常用api 方法大全</a></h3><h3 id="JS代码手写题"><a href="#JS代码手写题" class="headerlink" title="JS代码手写题"></a><a href="https://github.com/libin1991/libin_Blog/issues/388?from=timeline" target="_blank" rel="noopener">JS代码手写题</a></h3><h3 id="PM2来部署nodejs服务器永久开启"><a href="#PM2来部署nodejs服务器永久开启" class="headerlink" title="PM2来部署nodejs服务器永久开启"></a><a href="https://www.cnblogs.com/lxg0/p/7771229.html?from=timeline" target="_blank" rel="noopener">PM2来部署nodejs服务器永久开启</a></h3><h3 id="JavaScript设计模式"><a href="#JavaScript设计模式" class="headerlink" title="JavaScript设计模式"></a><a href="http://techblog.sishuxuefu.com/" target="_blank" rel="noopener">JavaScript设计模式</a></h3><h3 id="URL-解析"><a href="#URL-解析" class="headerlink" title="URL 解析"></a><a href="https://juejin.im/post/5bce96bff265da0ae801513c" target="_blank" rel="noopener">URL 解析</a></h3><h3 id="JavaScript专题"><a href="#JavaScript专题" class="headerlink" title="JavaScript专题"></a><a href="https://juejin.im/user/58f980918d6d8100587ea7f4/posts" target="_blank" rel="noopener">JavaScript专题</a></h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="https://www.cnblogs.com/jiqing9006/category/461295.html" target="_blank" rel="noopener">数据结构</a></h3><h3 id="轻松理解JavaScript原型及原型链"><a href="#轻松理解JavaScript原型及原型链" class="headerlink" title="轻松理解JavaScript原型及原型链"></a><a href="https://juejin.im/post/5be42b34f265da61616e3056" target="_blank" rel="noopener">轻松理解JavaScript原型及原型链</a></h3><h3 id="H5-移动调试全攻略"><a href="#H5-移动调试全攻略" class="headerlink" title="H5 移动调试全攻略"></a><a href="http://jartto.wang/2018/11/01/mobile-debug/" target="_blank" rel="noopener">H5 移动调试全攻略</a></h3><h3 id="JS-面试原生常用api-方法大全-1"><a href="#JS-面试原生常用api-方法大全-1" class="headerlink" title="JS 面试原生常用api 方法大全"></a><a href="https://github.com/libin1991/libin_Blog/issues/476" target="_blank" rel="noopener">JS 面试原生常用api 方法大全</a></h3><h3 id="javascript-原生常用API大全"><a href="#javascript-原生常用API大全" class="headerlink" title="javascript 原生常用API大全"></a><a href="https://github.com/libin1991/libin_Blog/issues/412" target="_blank" rel="noopener">javascript 原生常用API大全</a></h3><hr>
<p><img src="/2015/01/01/JS原生常用API大全/62002d6d0dab2d26a897d9591bb64efd.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/20181109201728.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201653.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201814.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201821.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201850.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201858.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201910.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202057.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202113.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202129.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202148.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202207.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202213.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202237.jpg" alt=""></p>
<h3 id="preload、prefetch"><a href="#preload、prefetch" class="headerlink" title="preload、prefetch"></a>preload、prefetch</h3><p>现在的网络情况虽然很乐观，但是</p>
<h2 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h2><p>当浏览器碰到 script 脚本的时候：</p>
<p><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>
<p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
<p><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p>
<p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p>
<p><code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code></p>
<p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
<p>然后从实用角度来说呢，首先把所有脚本都丢到 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p>
<p>接着，我们来看一张图咯：</p>
<p><img src="/2015/01/01/JS原生常用API大全/640.webp" alt=""></p>
<p>此图告诉我们以下几个要点：</p>
<ol>
<li><p>defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</p>
</li>
<li><p>它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的</p>
</li>
<li><p>关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</p>
</li>
<li><p>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</p>
</li>
<li><p>仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，</p>
</li>
</ol>
<h2 id="preload和refetch"><a href="#preload和refetch" class="headerlink" title="preload和refetch"></a>preload和refetch</h2><p><code>preload</code>通常在页面中，我们需要加载一些脚本和样式，而使用 preload 可以对当前页面所需的脚本、样式等资源进行预加载，而无需等到解析到 script 和 link 标签时才进行加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。</p>
<p>使用方式<br>将 link 标签的 rel 属性的值设为 preload，as 属性的值为资源类型（如脚本为 script，样式表为 style）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> &lt;head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;title&gt;</span><br><span class="line">		preload example</span><br><span class="line">	&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 对 style.css 和 index.js 进行预加载 --&gt;</span><br><span class="line"></span><br><span class="line">	&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;link rel=&quot;preload&quot; href=&quot;index.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<font color="#dd0000"> <code>prefetch</code>与 <code>preload</code> 一样，都是对资源进行预加载，但是 prefetch 加载的资源一般不是用于当前页面的，即未来很可能用到的这样一些资源，简单点说就是其他页面会用到的资源。当然，prefetch 不会像 preload 一样，在页面渲染的时候加载资源，而是利用浏览器空闲时间来下载。当进入下一页面，就可直接从 disk cache 里面取，既不影响当前页面的渲染，又提高了其他页面加载渲染的速度。</font>

<p>使用方式<br>同 <code>preload</code> 很相似，无需指定 as 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> &lt;head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;title&gt;</span><br><span class="line">		preload example</span><br><span class="line">	&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 对 style.css 和 index.js 进行 preload 预加载 --&gt;</span><br><span class="line"></span><br><span class="line">	&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;link rel=&quot;preload&quot; href=&quot;index.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 对资源进行 prefetch 预加载 --&gt;</span><br><span class="line"></span><br><span class="line">	&lt;link rel=&quot;prefetch&quot; href=&quot;next.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;link rel=&quot;prefetch&quot; href=&quot;next.js&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<table><tr><td bgcolor="#FF0000"><font color="#fff"><strong>总结:对当前页面需要的资源，使用 preload 进行预加载，对其它页面需要的资源进行 prefetch 预加载。</strong></font></td></tr></table>


<h2 id="Subresource和Prerender"><a href="#Subresource和Prerender" class="headerlink" title="Subresource和Prerender"></a>Subresource和Prerender</h2><p><code>subresource</code>可以用来指定资源是最高优先级的。比如，在Chrome和Opera中我们可以加上下面的代码：</p>
<p><code>&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;</code></p>
<blockquote>
<p>Chromium的文档这么解释：<br>和 “Link rel=prefetch”的语义不同，”Link rel=subresource”是一种新的连接关系。rel=prefetch指定了下载后续页面用到资源的低优先级，而rel=subresource则是指定当前页面资源的提前加载。</p>
</blockquote>
<p>所以，如果资源是在当前页面需要，或者马上就会用到，则推荐用subresource，否则还是用prefetch。</p>
<p><code>prerender</code>是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。</p>
<p><code>&lt;link rel=&quot;prerender&quot; href=&quot;/thenextpage.html&quot; /&gt;</code></p>
<blockquote>
<p>Steve Souders的文章详细解释了这个技术：<br>prerender就像是在后台打开了一个隐藏的tab，会下载所有的资源、创建DOM、渲染页面、执行JS等等。如果用户进入指定的链接，隐藏的这个页面就会进入马上进入用户的视线。Google Search多年前就利用了这个特性实现了Instant Pages功能。微软最近也宣布会让Bing在IE11上用类似prerender的技术。</p>
</blockquote>
<h3 id="Axios拦截器"><a href="#Axios拦截器" class="headerlink" title="Axios拦截器"></a>Axios拦截器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import &#123; throwErr &#125; from &apos;@/utils&apos; //utils 捕捉服务端http状态码的方法</span><br><span class="line">import store from &apos;@/store&apos;   //引入vuex的相关操作</span><br><span class="line">import &#123; Message &#125; from &apos;element-ui&apos; //element Toast的提示</span><br><span class="line">import router from &apos;@/router&apos;</span><br><span class="line"></span><br><span class="line">//过滤请求</span><br><span class="line">axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">  //config 为请求的一些配置 例如：请求头 请求时间 Token  可以根据自己的项目需求个性化配置，参考axios的中文说明手册  自己多动动手</span><br><span class="line"> //由于我们项目的后端大大给力，很多东西在服务端帮我们处理好了所以请求阶段只要传好参数就好了</span><br><span class="line">  config.timeout = 10 * 1000 //请求响应时间</span><br><span class="line">  return config</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line">// 添加响应拦截器</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">    if (response.data.code === 0) &#123;   //服务端定义的响应code码为0时请求成功</span><br><span class="line">      return Promise.resolve(response.data) //使用Promise.resolve 正常响应</span><br><span class="line">    &#125; else if (response.data.code === 1401) &#123; //服务端定义的响应code码为1401时为未登录</span><br><span class="line">      store.dispatch(&apos;setUserInfo&apos;, &#123;&#125;)</span><br><span class="line">      Message(&#123;</span><br><span class="line">        message: &apos;未登录&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">      // router.push(&apos;/login&apos;)</span><br><span class="line">      return Promise.reject(response.data)    //使用Promise.reject 抛出错误和异常</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return Promise.reject(response.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    if (error &amp;&amp; error.response) &#123;</span><br><span class="line">      let res = &#123;&#125;</span><br><span class="line">      res.code = error.response.status</span><br><span class="line">      res.msg = throwErr(error.response.status, error.response) //throwErr 捕捉服务端的http状态码 定义在utils工具类的方法</span><br><span class="line">      return Promise.reject(res)</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">export default function request(method, url, data) &#123;  //暴露 request 给我们好API 管理</span><br><span class="line">  method = method.toLocaleLowerCase()   //封装RESTful API的各种请求方式 以 post get delete为例</span><br><span class="line">  if (method === &apos;post&apos;) &#123;</span><br><span class="line">    return axios.post(url, data)    //axios的post 默认转化为json格式</span><br><span class="line">  &#125; else if (method === &apos;get&apos;) &#123;     </span><br><span class="line">    return axios.get(url, &#123;</span><br><span class="line">      params: data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else if (method === &apos;delete&apos;) &#123;</span><br><span class="line">    return axios.delete(url, &#123;</span><br><span class="line">      params: data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript的值传递和引用传递"><a href="#JavaScript的值传递和引用传递" class="headerlink" title="*JavaScript的值传递和引用传递"></a>*<a href="https://juejin.im/post/5beb934df265da61797460fd" target="_blank" rel="noopener">JavaScript的值传递和引用传递</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function changeAgeAndReference(person) &#123;</span><br><span class="line">    person.age = 25;</span><br><span class="line">    person = &#123;</span><br><span class="line">        name: &apos;John&apos;,</span><br><span class="line">        age: 50</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br><span class="line">var personObj1 = &#123;</span><br><span class="line">    name: &apos;Alex&apos;,</span><br><span class="line">    age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var personObj2 = changeAgeAndReference(personObj1);</span><br><span class="line">console.log(personObj1); // -&gt; &#123;name: &quot;Alex&quot;, age: 25&#125;</span><br><span class="line">console.log(personObj2); // -&gt; &#123;name: &quot;John&quot;, age: 50&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JSONP-【JSONP百度搜索框】"><a href="#JSONP-【JSONP百度搜索框】" class="headerlink" title="JSONP 【JSONP百度搜索框】"></a>JSONP 【JSONP百度搜索框】</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">		&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">			ul,</span><br><span class="line">			li &#123;</span><br><span class="line">				margin: 0;</span><br><span class="line">				padding: 0;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			.search &#123;</span><br><span class="line">				display: block;</span><br><span class="line">				margin: 0 auto;</span><br><span class="line">				height: 22px;</span><br><span class="line">				position: relative;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">			.search-out &#123;</span><br><span class="line">				position: absolute;</span><br><span class="line">				width: 200px;</span><br><span class="line">				height: 300px;</span><br><span class="line">				z-index: 10;</span><br><span class="line">				top: 23px;</span><br><span class="line">				color: #7e8c8d;</span><br><span class="line">				overflow-x: hidden;</span><br><span class="line">				overflow-y: auto;</span><br><span class="line">				margin-top: 5px;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			.search-out ul li &#123;</span><br><span class="line">				font-size: 12px;</span><br><span class="line">				height: 25px;</span><br><span class="line">				/*li溢出省略*/</span><br><span class="line">				overflow: hidden;</span><br><span class="line">				text-overflow: ellipsis;</span><br><span class="line">				white-space: nowrap;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			.search-out ul li:hover &#123;</span><br><span class="line">				background-color: #edf0f1;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			window.onload = function() &#123;</span><br><span class="line"></span><br><span class="line">				let input = document.getElementById(&apos;input&apos;),</span><br><span class="line">					body = document.getElementsByClassName(&apos;search&apos;)[0],</span><br><span class="line">					btn = document.getElementsByTagName(&quot;button&quot;)[0],</span><br><span class="line">					ul = document.getElementById(&apos;ul&apos;);</span><br><span class="line">				var globalData = [&apos;历史1&apos;, &apos;历史2&apos;]; //globalData数据，存储历史搜索</span><br><span class="line"></span><br><span class="line">				input.addEventListener(&apos;focus&apos;, function() &#123;</span><br><span class="line">					var htmlText = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">					for(var i = 0; i &lt; globalData.length; i++) &#123;</span><br><span class="line">						htmlText += &apos;&lt;li&gt;&apos; + globalData[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">					&#125;</span><br><span class="line">					ul.innerHTML = htmlText;</span><br><span class="line">					ul.style.border = &quot;solid 1px #dee6e8&quot;;</span><br><span class="line">					ul.style.background = &quot;white&quot;;</span><br><span class="line">				&#125;);</span><br><span class="line">				btn.addEventListener(&quot;click&quot;, function() &#123; //当点击搜索按钮把输入框数据添加至历史数组</span><br><span class="line">					if(input.value) &#123;</span><br><span class="line">						globalData.push(input.value);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">				input.addEventListener(&apos;blur&apos;, function() &#123; //离开输入框隐藏历史下拉列表</span><br><span class="line">					ul.style.border = &quot;&quot;;</span><br><span class="line">					ul.style.background = &quot;&quot;;</span><br><span class="line">					ul.innerHTML = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">				//监听input事件</span><br><span class="line">				input.addEventListener(&apos;input&apos;, function() &#123;</span><br><span class="line">					console.log(input.value)</span><br><span class="line">					if(!input.value) &#123;</span><br><span class="line">						var htmlText = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">						for(var i = 0; i &lt; globalData.length; i++) &#123;</span><br><span class="line">							htmlText += &apos;&lt;li&gt;&apos; + globalData[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">						&#125;</span><br><span class="line">						ul.innerHTML = htmlText;</span><br><span class="line">						ul.style.border = &quot;solid 1px #dee6e8&quot;;</span><br><span class="line">						ul.style.background = &quot;white&quot;;</span><br><span class="line"></span><br><span class="line">						return false;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					var val = encodeURI(input.value);</span><br><span class="line">					ul.innerHTML = &apos;&apos;; //清空上一次请求所插入的li</span><br><span class="line">					jsonp(&#123;</span><br><span class="line">						url: &apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&apos; + val + &apos;&amp;cb=&apos;,</span><br><span class="line">						time: 3000,</span><br><span class="line">						callback: function(json) &#123;</span><br><span class="line">							var htmlText = &apos;&apos;;</span><br><span class="line">							for(var i = 0; i &lt; json.s.length; i++) &#123;</span><br><span class="line">								htmlText += &apos;&lt;li&gt;&apos; + json[&apos;s&apos;][i] + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">							&#125;</span><br><span class="line">							ul.innerHTML = htmlText;</span><br><span class="line">						&#125;,</span><br><span class="line">						fail: function(mes) &#123;</span><br><span class="line">							alert(mes);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">				&#125;);</span><br><span class="line"></span><br><span class="line">				function jsonp(objects) &#123;</span><br><span class="line">					objects = objects || &#123;&#125;;</span><br><span class="line">					if(!objects.url || !objects.callback) &#123;</span><br><span class="line">						throw new Error(&apos;参数不合法&apos;);</span><br><span class="line">					&#125;</span><br><span class="line">					//创建script标签并插入</span><br><span class="line">					var callbackName = (&apos;jsonp_&apos; + Math.random()).replace(&quot;.&quot;, &quot;&quot;); //随机生成callbackName</span><br><span class="line">					var script = document.createElement(&apos;script&apos;);</span><br><span class="line">					var body = document.getElementsByClassName(&apos;search&apos;)[0];</span><br><span class="line">					body.appendChild(script);</span><br><span class="line">					window[callbackName] = function(json) &#123;</span><br><span class="line">						body.removeChild(script);</span><br><span class="line">						clearTimeout(script.timer);</span><br><span class="line">						window[callbackName] = null;</span><br><span class="line">						objects.callback &amp;&amp; objects.callback(json);</span><br><span class="line">					&#125;;</span><br><span class="line"></span><br><span class="line">					//发出请求</span><br><span class="line">					script.src = objects.url + callbackName;</span><br><span class="line"></span><br><span class="line">					//响应时间</span><br><span class="line">					if(objects.time) &#123;</span><br><span class="line">						script.timer = setTimeout(function() &#123;</span><br><span class="line">							window[callbackName] = null;</span><br><span class="line">							body.removeChild(script);</span><br><span class="line">							objects.fail &amp;&amp; objects.fail(&apos;超时&apos;);</span><br><span class="line">						&#125;, objects.time);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div class=&quot;search&quot;&gt;</span><br><span class="line">			&lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;搜索材质&quot;&gt;</span><br><span class="line">			&lt;span&gt;</span><br><span class="line">				&lt;button&gt;搜索&lt;/button&gt;</span><br><span class="line">			&lt;/span&gt;</span><br><span class="line">			&lt;div class=&quot;search-out&quot;&gt;</span><br><span class="line">				&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;</span><br><span class="line">			&lt;/div&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Math-round-，Math-ceil-，Math-floor-的区别"><a href="#Math-round-，Math-ceil-，Math-floor-的区别" class="headerlink" title="Math.round()，Math.ceil()，Math.floor()的区别"></a>Math.round()，Math.ceil()，Math.floor()的区别</h3><p>1.Math.round()：根据“round”的字面意思“附近、周围”，可以猜测该函数是求一个附近的整数，看下面几个例子就明白。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">小数点后第一位&lt;5</span><br><span class="line">正数：Math.round(11.46)=11</span><br><span class="line">负数：Math.round(-11.46)=-11</span><br><span class="line"> </span><br><span class="line">小数点后第一位&gt;5</span><br><span class="line">正数：Math.round(11.68)=12</span><br><span class="line">负数：Math.round(-11.68)=-12</span><br><span class="line"> </span><br><span class="line">小数点后第一位=5</span><br><span class="line">正数：Math.round(11.5)=12</span><br><span class="line">负数：Math.round(-11.5)=-11</span><br><span class="line">总结：（小数点后第一位）大于五全部加，等于五正数加，小于五全不加。</span><br></pre></td></tr></table></figure></p>
<p>2.Math.ceil()：根据“ceil”的字面意思“天花板”去理解；<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(11.46)=Math.ceil(11.68)=Math.ceil(11.5)=12</span><br><span class="line">Math.ceil(-11.46)=Math.ceil(-11.68)=Math.ceil(-11.5)=-11</span><br></pre></td></tr></table></figure></p>
<p>3.Math.floor()：根据“floor”的字面意思“地板”去理解；<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(11.46)=Math.ceil(11.68)=Math.ceil(11.5)=11</span><br><span class="line">Math.ceil(-11.46)=Math.ceil(-11.68)=Math.ceil(-11.5)=-12</span><br></pre></td></tr></table></figure></p>
<h3 id="Math-random-函数生成n到m间的随机数字"><a href="#Math-random-函数生成n到m间的随机数字" class="headerlink" title="Math.random()函数生成n到m间的随机数字"></a>Math.random()函数生成n到m间的随机数字</h3><p>Math.random()函数返回0和1之间的伪随机数，可能为0，但总是小于1，[0,1)</p>
<blockquote>
<p>生成n-m，包含n但不包含m的整数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步算出 m-n的值，假设等于w</span><br><span class="line"></span><br><span class="line">第二步Math.random()*w</span><br><span class="line"></span><br><span class="line">第三步Math.random()*w+n</span><br><span class="line"></span><br><span class="line">第四步parseInt(Math.random()*w+n, 10)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成n-m，不包含n但包含m的整数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步算出 m-n的值，假设等于w</span><br><span class="line"></span><br><span class="line">第二步Math.random()*w</span><br><span class="line"></span><br><span class="line">第三步Math.random()*w+n</span><br><span class="line"></span><br><span class="line">第四步Math.floor(Math.random()*w+n) + 1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成n-m，不包含n和m的整数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步算出 m-n-2的值，假设等于w</span><br><span class="line"></span><br><span class="line">第二步Math.random()*w</span><br><span class="line"></span><br><span class="line">第三步Math.random()*w+n +1</span><br><span class="line"></span><br><span class="line">第四步Math.round(Math.random()*w+n+1) 或者 Math.ceil(Math.random()*w+n+1)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>生成n-m，包含n和m的随机数：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步算出 m-n的值，假设等于w</span><br><span class="line"></span><br><span class="line">第二步Math.random()*w</span><br><span class="line"></span><br><span class="line">第三步Math.random()*w+n</span><br><span class="line"></span><br><span class="line">第四步Math.round(Math.random()*w+n) 或者 Math.ceil(Math.random()*w+n)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">109</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


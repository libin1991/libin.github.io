<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/11/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/11/">





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/31/JavaScript进阶提高必读/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/31/JavaScript进阶提高必读/" itemprop="url">JavaScript进阶提高必读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-31T23:40:40+08:00">
                2016-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="冴羽写博客的地方"><a href="#冴羽写博客的地方" class="headerlink" title="冴羽写博客的地方"></a><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">冴羽写博客的地方</a></h2><h2 id="vue源码-内部运行机制剖析"><a href="#vue源码-内部运行机制剖析" class="headerlink" title="vue源码-内部运行机制剖析"></a><a href="https://github.com/DIVIBEAR/vue" target="_blank" rel="noopener">vue源码-内部运行机制剖析</a></h2><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>JavaScript深入系列 15 篇已完结。</p>
<p>JavaScript专题系列 20 篇已完结。</p>
<p>underscore 系列 8 篇已完结。</p>
<h2 id="深入系列目录"><a href="#深入系列目录" class="headerlink" title="深入系列目录"></a>深入系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScirpt深入之从原型到原型链</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript深入之执行上下文栈</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript深入之变量对象</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">JavaScript深入之作用域链</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">JavaScript深入之从ECMAScript规范解读this</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">JavaScript深入之执行上下文</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">JavaScript深入之闭包</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/10" target="_blank" rel="noopener">JavaScript深入之参数按值传递</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">JavaScript深入之类数组对象与arguments</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/15" target="_blank" rel="noopener">JavaScript深入之创建对象的多种方式以及优缺点</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">JavaScript深入之继承的多种方式以及优缺点</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/17" target="_blank" rel="noopener">JavaScript深入系列15篇正式完结！</a></li>
</ol>
<h2 id="专题系列目录"><a href="#专题系列目录" class="headerlink" title="专题系列目录"></a>专题系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">JavaScript专题之跟着underscore学防抖</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">JavaScript专题之跟着underscore学节流</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/27" target="_blank" rel="noopener">JavaScript专题之数组去重</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">JavaScript专题之类型判断(上)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/30" target="_blank" rel="noopener">JavaScript专题之类型判断(下)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener">JavaScript专题之深浅拷贝</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/33" target="_blank" rel="noopener">JavaScript专题之从零实现jQuery的extend</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/35" target="_blank" rel="noopener">JavaScript专题之如何求数组的最大值和最小值</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/36" target="_blank" rel="noopener">JavaScript专题之数组扁平化</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/37" target="_blank" rel="noopener">JavaScript专题之学underscore在数组中查找指定元素</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/40" target="_blank" rel="noopener">JavaScript专题之jQuery通用遍历方法each的实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/41" target="_blank" rel="noopener">JavaScript专题之如何判断两个对象相等</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript专题之函数柯里化</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/43" target="_blank" rel="noopener">JavaScript专题之偏函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/44" target="_blank" rel="noopener">JavaScript专题之惰性函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/45" target="_blank" rel="noopener">JavaScript专题之函数组合</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/46" target="_blank" rel="noopener">JavaScript专题之函数记忆</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/49" target="_blank" rel="noopener">JavaScript专题之递归</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/51" target="_blank" rel="noopener">JavaScript专题之乱序</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/52" target="_blank" rel="noopener">JavaScript专题之解读 v8 排序源码</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/53" target="_blank" rel="noopener">JavaScript专题系列20篇正式完结！</a></li>
</ol>
<h2 id="underscore-系列目录"><a href="#underscore-系列目录" class="headerlink" title="underscore 系列目录"></a>underscore 系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/56" target="_blank" rel="noopener">underscore 系列之如何写自己的 underscore</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/57" target="_blank" rel="noopener">underscore 系列之链式调用</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/58" target="_blank" rel="noopener">underscore 系列之内部函数 cb 和 optimizeCb</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/60" target="_blank" rel="noopener">underscore 系列之内部函数 restArgs</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/62" target="_blank" rel="noopener">underscore 系列之防冲突与 Utility Functions</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/63" target="_blank" rel="noopener">underscore 系列之实现一个模板引擎(上)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/70" target="_blank" rel="noopener">underscore 系列之实现一个模板引擎(下)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/77" target="_blank" rel="noopener">underscore 系列之字符实体与 _.escape</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/79" target="_blank" rel="noopener">underscore 的源码该如何阅读？</a></li>
</ol>
<h2 id="ES6-系列目录"><a href="#ES6-系列目录" class="headerlink" title="ES6 系列目录"></a>ES6 系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/82" target="_blank" rel="noopener">ES6 系列之 let 和 const</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/84" target="_blank" rel="noopener">ES6 系列之模板字符串</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/85" target="_blank" rel="noopener">ES6 系列之箭头函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/87" target="_blank" rel="noopener">ES6 系列之模拟实现 Symbol 类型</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/90" target="_blank" rel="noopener">ES6 系列之迭代器与 for of</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/91" target="_blank" rel="noopener">ES6 系列之模拟实现一个 Set 数据结构</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/92" target="_blank" rel="noopener">ES6 系列之 WeakMap</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/98" target="_blank" rel="noopener">ES6 系列之我们来聊聊 Promise</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/99" target="_blank" rel="noopener">ES6 系列之 Generator 的自动执行</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/22/JavaScript-模块化解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/22/JavaScript-模块化解析/" itemprop="url">JavaScript 模块化解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T19:47:32+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="WEB-前端模块化都有什么？"><a href="#WEB-前端模块化都有什么？" class="headerlink" title="WEB 前端模块化都有什么？"></a><a href="https://juejin.im/post/5bf4f6515188251a8266038b" target="_blank" rel="noopener">WEB 前端模块化都有什么？</a></h3><p>随着 JavasScript 语言逐渐发展，JavaScript 应用从简单的表单验证，到复杂的网站交互，再到服务端，移动端，PC 客户端的语言支持。JavaScript 应用领域变的越来越广泛，工程代码变得越来越庞大，代码的管理变得越来越困难，于是乎 JavaScript 模块化方案在社区中应声而起，其中一些优秀的模块化方案，逐渐成为 JavaScript 的语言规范，下面我们就 JavaScript 模块化这个话题展开讨论，本文的主要包含以几部分内容。</p>
<ul>
<li>什么是模块</li>
<li>为什么需要模块化</li>
<li>JavaScript 模块化之 CommonJS</li>
<li>JavaScript 模块化之 AMD</li>
<li>JavaScript 模块化之 CMD</li>
<li>JavaScript 模块化之 ES Module</li>
<li>总结</li>
</ul>
<ol>
<li>根据平台划分</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">平台</th>
<th style="text-align:center">规范</th>
<th style="text-align:right">特性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">浏览器</td>
<td style="text-align:center">AMD、CMD</td>
<td style="text-align:right">存在网络瓶颈，使用异步加载</td>
</tr>
<tr>
<td style="text-align:left">非浏览器</td>
<td style="text-align:center">CommonJS</td>
<td style="text-align:right">直接操作 IO，同步加载</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>特性</th>
<th style="text-align:left">规范</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步加载</td>
<td style="text-align:left">CommonJS</td>
</tr>
<tr>
<td>异步加载</td>
<td style="text-align:left">AMD、CMD</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">规范</th>
<th style="text-align:center">约束条件</th>
<th style="text-align:right">代表作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">AMD</td>
<td style="text-align:center">依赖前置</td>
<td style="text-align:right">requirejs</td>
</tr>
<tr>
<td style="text-align:left">CMD</td>
<td style="text-align:center">就近依赖</td>
<td style="text-align:right">seajs</td>
</tr>
</tbody>
</table>
<h2 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h2><p>模块，又称构件，是能够单独命名并独立地完成一定功能的程序语句的集合 (即程序代码和数据结构的集合体)。它具有两个基本的特征：外部特征和内部特征。外部特征是指模块跟外部环境联系的接口 (即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量) 和模块的功能，内部特征是指模块的内部环境具有的特点 (即该模块的局部数据和程序代码)。简而言之，模块就是一个具有独立作用域，对外暴露特定功能接口的代码集合。</p>
<h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><p>首先让我们回到过去，看看原始 JavaScript 模块文件的写法。</p>
<pre><code>// add.jsfunctionadd(a, b) {
  return a + b;
}
// decrease.jsfunctiondecrease(a, b) {
  return a - b;
}

// formula.jsfunctionsquare_difference(a, b) {
  return add(a, b) * decrease(a, b);
}
</code></pre><p>上面我们在三个 JavaScript 文件里面，实现了几个功能函数。其中，第三个功能函数需要依赖第一个和第二个 JavaScript 文件的功能函数，所以我们在使用的时候，一般会这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">		&lt;head&gt;</span><br><span class="line">		  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">		  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">		  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">		&lt;/head&gt;</span><br><span class="line">		&lt;body&gt;</span><br><span class="line">		    &lt;script src=&quot;add.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;script src=&quot;decrease.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;script src=&quot;formula.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;!--使用--&gt;</span><br><span class="line">		    &lt;script&gt;</span><br><span class="line">		       var result = square_difference(3, 4);</span><br><span class="line">		    &lt;/script&gt;</span><br><span class="line">		&lt;/body&gt;</span><br><span class="line">	&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这样的管理方式会造成以下几个问题：</span><br><span class="line"></span><br><span class="line">- 模块的引入顺序可能会出错</span><br><span class="line">- 会污染全局变量</span><br><span class="line">- 模块之间的依赖关系不明显</span><br><span class="line"></span><br><span class="line">基于上述的原因，就有了对上述问题的解决方案，即是 JavaScript 模块化规范，目前主流的有 CommonJS，AMD，CMD，ES6 Module 这四种规范。</span><br><span class="line"></span><br><span class="line">## Javascript 模块化之 CommonJS</span><br><span class="line"></span><br><span class="line">CommonJS 规范的主要内容有，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中，下面讲述一下 NodeJs 中 CommonJS 的模块化机制。</span><br><span class="line"></span><br><span class="line">### 使用方式</span><br><span class="line"></span><br><span class="line">    // 模块定义 add.jsmodule.eports.add = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 模块定义 decrease.jsmodule.exports.decrease = function(a, b) &#123;</span><br><span class="line">      return a - b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // formula.js,模块使用，利用 require() 方法加载模块,require 导出的即是 module.exports 的内容const add = require(&quot;./add.js&quot;).add;</span><br><span class="line">    const decrease = require(&quot;./decrease.js&quot;).decrease;</span><br><span class="line">    module.exports.square_difference = function(a, b) &#123;</span><br><span class="line">      return add(a, b) * decrease(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### exports 和 module.exports</span><br><span class="line"></span><br><span class="line">exports 和 module.exports 是指向同一个东西的变量，即是 module.exports = exports = &#123;&#125;，所以你也可以这样导出模块</span><br><span class="line"></span><br><span class="line">    //add.js</span><br><span class="line">    exports.add = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是如果直接修改 exports 的指向是无效的，例如:</span><br><span class="line"></span><br><span class="line">    // add.js</span><br><span class="line">    exports = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    // main.jsvar add = require(&quot;./add.js&quot;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">此时得到的 add 是一个空对象，因为 require 导入的是，对应模块的 module.exports 的内容，在上面的代码中，虽然一开始 exports = module.exports，但是当执行如下代码的时候，其实就将 exports 指向了 function,而 module.exports 的内容并没有改变，所以这个模块的导出为空对象。</span><br><span class="line"></span><br><span class="line">    exports = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### CommonJS 在 NodeJs 中的模块加载机制</span><br><span class="line"></span><br><span class="line">以下根据 [NodeJs 中 CommonJS 模块加载源码](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnodejs%2Fnode%2Fblob%2Fmaster%2Flib%2Finternal%2Fmodules%2Fcjs%2Floader.js) 来分析 NodeJS 中模块的加载机制。</span><br><span class="line"></span><br><span class="line">在 NodeJs 中引入模块 (require)，需要经历如下 3 个步骤：</span><br><span class="line"></span><br><span class="line">1. 路径分析</span><br><span class="line">2. 文件定位</span><br><span class="line">3. 编译执行</span><br><span class="line"></span><br><span class="line">与前端浏览器会缓存静态脚本文件以提高性能一样，NodeJs 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的是，浏览器仅缓存文件，而在 NodeJs 中缓存的是编译和执行后的对象。</span><br><span class="line"></span><br><span class="line">#### 路径分析 + 文件定位</span><br><span class="line"></span><br><span class="line">其流程如下图所示：</span><br><span class="line">#### 模块编译</span><br><span class="line"></span><br><span class="line">在定位到文件后，首先会检查该文件是否有缓存，有的话直接读取缓存，否则，会新创建一个 Module 对象，其定义如下：</span><br><span class="line"></span><br><span class="line">    functionModule(id, parent) &#123;</span><br><span class="line">      this.id = id; // 模块的识别符，通常是带有绝对路径的模块文件名。this.exports = &#123;&#125;; // 表示模块对外输出的值this.parent = parent; // 返回一个对象，表示调用该模块的模块。if (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">        this.parent.children.push(this);</span><br><span class="line">      &#125;</span><br><span class="line">      this.filename = null;</span><br><span class="line">      this.loaded = false; // 返回一个布尔值，表示模块是否已经完成加载。this.childrent = []; // 返回一个数组，表示该模块要用到的其他模块。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">require 操作代码如下所示：</span><br><span class="line"></span><br><span class="line">    Module.prototype.require = function(id) &#123;</span><br><span class="line">      // 检查模块标识符if (typeof id !== &quot;string&quot;) &#123;</span><br><span class="line">        thrownew ERR_INVALID_ARG_TYPE(&quot;id&quot;, &quot;string&quot;, id);</span><br><span class="line">      &#125;</span><br><span class="line">      if (id === &quot;&quot;) &#123;</span><br><span class="line">        thrownew ERR_INVALID_ARG_VALUE(&quot;id&quot;, id, &quot;must be a non-empty string&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 调用模块加载方法return Module._load(id, this, /* isMain */false);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">接下来是解析模块路径，判断是否有缓存，然后生成 Module 对象：</span><br><span class="line"></span><br><span class="line">    Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">      if (parent) &#123;</span><br><span class="line">        debug(&quot;Module._load REQUEST %s parent: %s&quot;, request, parent.id);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 解析文件名var filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line">    </span><br><span class="line">      var cachedModule = Module._cache[filename];</span><br><span class="line">    </span><br><span class="line">      // 判断是否有缓存，有的话返回缓存对象的 exportsif (cachedModule) &#123;</span><br><span class="line">        updateChildren(parent, cachedModule, true);</span><br><span class="line">        return cachedModule.exports;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 判断是否为原生核心模块，是的话从内存加载if (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">        debug(&quot;load native module %s&quot;, request);</span><br><span class="line">        return NativeModule.require(filename);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 生成模块对象varmodule = new Module(filename, parent);</span><br><span class="line">    </span><br><span class="line">      if (isMain) &#123;</span><br><span class="line">        process.mainModule = module;</span><br><span class="line">        module.id = &quot;.&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 缓存模块对象</span><br><span class="line">      Module._cache[filename] = module;</span><br><span class="line">    </span><br><span class="line">      // 加载模块</span><br><span class="line">      tryModuleLoad(module, filename);</span><br><span class="line">    </span><br><span class="line">      returnmodule.exports;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">tryModuleLoad 的代码如下所示：</span><br></pre></td></tr></table></figure></p>
<pre><code>functiontryModuleLoad(module, filename) {
  var threw = true;
  try {
    // 调用模块实例load方法module.load(filename);
    threw = false;
  } finally {
    if (threw) {
      // 如果加载出错，则删除缓存delete Module._cache[filename];
    }
  }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块对象执行载入操作 module.load 代码如下所示：</span><br></pre></td></tr></table></figure>
<pre><code>Module.prototype.load = function(filename) {
  debug(&quot;load %j for module %j&quot;, filename, this.id);

  assert(!this.loaded);
  this.filename = filename;

  // 解析路径this.paths = Module._nodeModulePaths(path.dirname(filename));

  // 判断扩展名，并且默认为 .js 扩展var extension = path.extname(filename) || &quot;.js&quot;;

  // 判断是否有对应格式文件的处理函数， 没有的话，扩展名改为 .jsif (!Module._extensions[extension]) extension = &quot;.js&quot;;

  // 调用相应的文件处理方法，并传入模块对象
  Module._extensions[extension](this, filename);
  this.loaded = true;

  // 处理 ES Moduleif (experimentalModules) {
    if (asyncESM === undefined) lazyLoadESM();
    const ESMLoader = asyncESM.ESMLoader;
    const url = pathToFileURL(filename);
    const urlString = `${url}`;
    const exports = this.exports;
    if (ESMLoader.moduleMap.has(urlString) !== true) {
      ESMLoader.moduleMap.set(
        urlString,
        new ModuleJob(ESMLoader, url, async () =&gt; {
          const ctx = createDynamicModule([&quot;default&quot;], url);
          ctx.reflect.exports.default.set(exports);
          return ctx;
        })
      );
    } else {
      const job = ESMLoader.moduleMap.get(urlString);
      if (job.reflect) job.reflect.exports.default.set(exports);
    }
  }
};
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这里同步读取模块，再执行编译操作：</span><br></pre></td></tr></table></figure>
<pre><code>Module._extensions[&quot;.js&quot;] = function(module, filename) {
  // 同步读取文件var content = fs.readFileSync(filename, &quot;utf8&quot;);

  // 编译代码module._compile(stripBOM(content), filename);
};
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译过程主要做了以下的操作：</span><br><span class="line"></span><br><span class="line">1. 将 JavaScript 代码用函数体包装，隔离作用域，例如：</span><br></pre></td></tr></table></figure>
<pre><code>exports.add = (function(a, b) {
  return a + b;
}
</code></pre><p><code>`</code><br>会被转换为</p>
<pre><code>(
  function(exports, require, modules, __filename, __dirname) {
    exports.add = function(a, b) {
      return a + b;
    };
  }
);
</code></pre><ol>
<li><p>执行函数，注入模块对象的 exports 属性，require 全局方法，以及对象实例，<strong>filename, </strong>dirname，然后执行模块的源码。</p>
</li>
<li><p>返回模块对象 exports 属性。</p>
</li>
</ol>
<h2 id="JavaScript-模块化之-AMD"><a href="#JavaScript-模块化之-AMD" class="headerlink" title="JavaScript 模块化之 AMD"></a>JavaScript 模块化之 AMD</h2><p>AMD, Asynchronous Module Definition，即异步模块加载机制，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句都定义在一个回调函数中，等到依赖加载完成之后，这个回调函数才会运行。</p>
<p>AMD 的诞生，就是为了解决这两个问题：</p>
<ol>
<li>实现 JavaScript 文件的异步加载，避免网页失去响应</li>
<li><p>管理模块之间的依赖性，便于代码的编写和维护</p>
<p> // 模块定义<br>  define(id?: String, dependencies?: String[], factory: Function|Object);</p>
</li>
</ol>
<p>id 是模块的名字，它是可选的参数。</p>
<p>dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数。每个依赖的模块的输出都将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。</p>
<p>factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值，如果是对象，此对象应该为模块的输出值。</p>
<p>举个例子：</p>
<pre><code>// 模块定义，add.js
define(function() {
  let add = function(a, b) {
    return a + b;
  };
  return add;
});

// 模块定义，decrease.js
define(function() {
  let decrease = function(a, b) {
    return a - b;
  };
  return decrease;
});

// 模块定义，square.js
define([&quot;./add&quot;, &quot;./decrease&quot;], function(add, decrease) {
  let square = function(a, b) {
    return add(a, b) * decrease(a, b);
  };
  return square;
});

// 模块使用，主入口文件 main.jsrequire([&quot;square&quot;], function(math) {
  console.log(square(6, 3));
});
</code></pre><p>这里用实现了 AMD 规范的 RequireJS 来分析，RequireJS 源码较为复杂，这里只对异步模块加载原理做一个分析。在加载模块的过程中， RequireJS 会调用如下函数：</p>
<pre><code>/**
 *
 * @param {Object} context the require context to find state.
 * @param {String} moduleName the name of the module.
 * @param {Object} url the URL to the module.
 */
req.load = function(context, moduleName, url) {
  var config = (context &amp;&amp; context.config) || {},
    node;
  // 判断是否为浏览器if (isBrowser) {
    // 根据模块名称和 url 创建一个 Script 标签
    node = req.createNode(config, moduleName, url);

    node.setAttribute(&quot;data-requirecontext&quot;, context.contextName);
    node.setAttribute(&quot;data-requiremodule&quot;, moduleName);

    // 对不同的浏览器 Script 标签事件监听做兼容处理if (
      node.attachEvent &amp;&amp;
      !(
        node.attachEvent.toString &amp;&amp;
        node.attachEvent.toString().indexOf(&quot;[native code&quot;) &lt; 0
      ) &amp;&amp;
      !isOpera
    ) {
      useInteractive = true;

      node.attachEvent(&quot;onreadystatechange&quot;, context.onScriptLoad);
    } else {
      node.addEventListener(&quot;load&quot;, context.onScriptLoad, false);
      node.addEventListener(&quot;error&quot;, context.onScriptError, false);
    }

    // 设置 Script 标签的 src 属性为模块路径
    node.src = url;

    if (config.onNodeCreated) {
      config.onNodeCreated(node, config, moduleName, url);
    }

    currentlyAddingScript = node;

    // 将 Script 标签插入到页面中if (baseElement) {
      head.insertBefore(node, baseElement);
    } else {
      head.appendChild(node);
    }
    currentlyAddingScript = null;

    return node;
  } elseif (isWebWorker) {
    try {
      //In a web worker, use importScripts. This is not a very//efficient use of importScripts, importScripts will block until//its script is downloaded and evaluated. However, if web workers//are in play, the expectation is that a build has been done so//that only one script needs to be loaded anyway. This may need//to be reevaluated if other use cases become common.// Post a task to the event loop to work around a bug in WebKit// where the worker gets garbage-collected after calling// importScripts(): https://webkit.org/b/153317
      setTimeout(function() {}, 0);
      importScripts(url);

      //Account for anonymous modules
      context.completeLoad(moduleName);
    } catch (e) {
      context.onError(
        makeError(
          &quot;importscripts&quot;,
          &quot;importScripts failed for &quot; + moduleName + &quot; at &quot; + url,
          e,
          [moduleName]
        )
      );
    }
  }
};

// 创建异步 Script 标签
req.createNode = function(config, moduleName, url) {
  var node = config.xhtml
    ? document.createElementNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;html:script&quot;)
    : document.createElement(&quot;script&quot;);
  node.type = config.scriptType || &quot;text/javascript&quot;;
  node.charset = &quot;utf-8&quot;;
  node.async = true;
  return node;
};
</code></pre><p>可以看出，这里主要是根据模块的 Url，创建了一个异步的 Script 标签，并将模块 id 名称添加到的标签的 data-requiremodule 上，再将这个 Script 标签添加到了 html 页面中。同时为 Script 标签的 load 事件添加了处理函数，当该模块文件被加载完毕的时候，就会触发 context.onScriptLoad。我们在 onScriptLoad 添加断点，可以看到页面结构如下图所示:<br> 由图可以看到，Html 中添加了一个 Script 标签，这也就是异步加载模块的原理。</p>
<h2 id="JavaScript-模块化之-CMD"><a href="#JavaScript-模块化之-CMD" class="headerlink" title="JavaScript 模块化之 CMD"></a>JavaScript 模块化之 CMD</h2><p>CMD (Common Module Definition) 通用模块定义，CMD 在浏览器端的实现有 SeaJS， 和 RequireJS 一样，SeaJS 加载原理也是动态创建异步 Script 标签。二者的区别主要是依赖写法上不同，AMD 推崇一开始就加载所有的依赖，而 CMD 则推崇在需要用的地方才进行依赖加载。</p>
<pre><code>// ADM 在执行以下代码的时候，RequireJS 会首先分析依赖数组，然后依次加载，直到所有加载完毕再执行回到函数
define([&quot;add&quot;, &quot;decrease&quot;], function(add, decrease) {
  let result1 = add(9, 7);
  let result2 = decrease(9, 7);
  console.log(result1 * result2);
});

// CMD 在执行以下代码的时候， SeaJS 会首先用正则匹配出代码里面所有的 require 语句，拿到依赖，然后依次加载，加载完成再执行回调函数
define(function(require) {
  let add = require(&quot;add&quot;);
  let result1 = add(9, 7);
  let add = require(&quot;decrease&quot;);
  let result2 = decrease(9, 7);
  console.log(result1 * result2);
});
</code></pre><h2 id="JavaScript-模块化之-ES-Module"><a href="#JavaScript-模块化之-ES-Module" class="headerlink" title="JavaScript 模块化之 ES Module"></a>JavaScript 模块化之 ES Module</h2><p>ES Module 是在 ECMAScript 6 中引入的模块化功能。模块功能主要由两个命令构成，分别是 export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>
<p>其使用方式如下:</p>
<pre><code>// 模块定义 add.jsexportfunctionadd(a, b) {
  return a + b;
}

// 模块使用 main.jsimport { add } from&quot;./add.js&quot;;
console.log(add(1, 2)); // 3
</code></pre><p>下面讲述几个较为重要的点。</p>
<h3 id="export-和-export-default"><a href="#export-和-export-default" class="headerlink" title="export 和 export default"></a>export 和 export default</h3><p>在一个文件或模块中，export 可以有多个，export default 仅有一个, export 类似于具名导出，而 default 类似于导出一个变量名为 default 的变量。同时在 import 的时候，对于 export 的变量，必须要用具名的对象去承接，而对于 default，则可以任意指定变量名，例如：</p>
<pre><code>// a.jsexportvar a = 2;
 exportvar b = 3 ;
// main.js 在导出的时候必须要用具名变量 a, b 且以解构的方式得到导出变量import {a, b} from&apos;a.js&apos;// √ a= 2, b = 3import a from&apos;a.js&apos;// x// b.js export default 方式const a = 3exportdefault a // 注意不能 export default const a = 3 ,因为这里 default 就相当于一个变量名// 导出import b form &apos;b.js&apos;// √import c form &apos;b.js&apos;// √ 因为 b 模块导出的是 default，对于导出的default，可以用任意变量去承接
</code></pre><h3 id="ES-Module-模块加载和导出过程"><a href="#ES-Module-模块加载和导出过程" class="headerlink" title="ES Module 模块加载和导出过程"></a>ES Module 模块加载和导出过程</h3><p>以如下代码为例子：</p>
<pre><code>// counter.jsexportlet count = 5// display.jsexportfunctionrender() {
   console.log(&apos;render&apos;)
 }
 // main.jsimport { counter } from&apos;./counter.js&apos;;
 import { render } from&apos;./display.js&apos;
 ......// more code
</code></pre><p>在模块加载模块的过程中，主要经历以下几个步骤：</p>
<h4 id="构建-Construction"><a href="#构建-Construction" class="headerlink" title="构建 (Construction)"></a>构建 (Construction)</h4><p>这个过程执行查找，下载，并将文件转化为模块记录 (Module record)。所谓的模块记录是指一个记录了对应模块的语法树，依赖信息，以及各种属性和方法 (这里不是很明白)。同样也是在这个过程对模块记录进行了缓存的操作，下图是一个模块记录表：</p>
<p>下图是缓存记录表：</p>
<h4 id="实例化-Instantiation"><a href="#实例化-Instantiation" class="headerlink" title="实例化 (Instantiation)"></a>实例化 (Instantiation)</h4><p>这个过程会在内存中开辟一个存储空间 (此时还没有填充值)，然后将该模块所有的 export 和 import 了该模块的变量指向这个内存，这个过程叫做链接。其写入 export 示意图如下所示：<br> 然后是链接 import，其示意图如下所示：</p>
<h4 id="赋值-Evaluation"><a href="#赋值-Evaluation" class="headerlink" title="赋值(Evaluation)"></a>赋值(Evaluation)</h4><p>这个过程会执行模块代码，并用真实的值填充上一阶段开辟的内存空间，此过程后 import 链接到的值就是 export 导出的真实值。</p>
<p>根据上面的过程我们可以知道。ES Module 模块 export 和 import 其实指向的是同一块内存，但有一个点需要注意的是，import 处不能对这块内存的值进行修改，而 export 可以，其示意图如下：</p>
<h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><ol>
<li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。?CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<br>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p>
</li>
<li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
</li>
</ol>
<h2 id="CMD与AMD区别"><a href="#CMD与AMD区别" class="headerlink" title="CMD与AMD区别"></a>CMD与AMD区别</h2><ul>
<li>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。</li>
<li>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；</li>
<li>而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对目前主流的 JavaScript 模块化方案 CommonJs，AMD，CMD, ES Module 进行了学习和了解，并对其中最有代表性的模块化实现 (NodeJs，RequireJS，SeaJS，ES6) 做了一个简单的分析。对于服务端的模块而言，由于其模块都是存储在本地的，模块加载方便，所以通常是采用同步读取文件的方式进行模块加载。而对于浏览器而言，其模块一般是存储在远程网络上的，模块的下载是一个十分耗时的过程，所以通常是采用动态异步脚本加载的方式加载模块文件。另外，无论是客户端还是服务端的 JavaScript 模块化实现，都会对模块进行缓存，以此减少二次加载的开销。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/12/Node-js技巧/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/12/Node-js技巧/" itemprop="url">Node.js技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-12T20:37:36+08:00">
                2016-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="将node-js的终端输出重定向到浏览器控制台中"><a href="#将node-js的终端输出重定向到浏览器控制台中" class="headerlink" title="将node.js的终端输出重定向到浏览器控制台中"></a><a href="https://blog.suisuijiang.com/in-nodejs-realize-code-hot-reload-function/" target="_blank" rel="noopener">将node.js的终端输出重定向到浏览器控制台中</a></h1><p>使用过webpack做前端的朋友大概知道, webpack有个dev-server功能, 支持在代码发生改动时自动的重启代码, 简称hot-reload. 这一特性极大地促进了开发效率, 所以下面我们通过编写代码来实现这个特性.</p>
<h2 id="创建开发目录"><a href="#创建开发目录" class="headerlink" title="创建开发目录"></a>创建开发目录</h2><p>首先创建一个<code>src</code>目录, 后面我们将监视<code>src</code>目录中的代码改动, 在<code>src</code>目录创建<code>app.js</code>做程序入口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//*app.js</span><br><span class="line">console.log(&apos;app.js&apos;);</span><br></pre></td></tr></table></figure></p>
<h2 id="使用chokidar监视目录"><a href="#使用chokidar监视目录" class="headerlink" title="使用chokidar监视目录"></a>使用chokidar监视目录</h2><p><a href="https://www.npmjs.com/package/chokidar" target="_blank" rel="noopener">chokidar</a>是一个小巧的文件监视库, 它可以获取到目录中文件的改动/新增/删除等事件. 在项目根目录创建<code>development.js</code>, <code>development.js</code>代码如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// *development.js*    </span><br><span class="line">&apos;use strict&apos;</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const chokidar = require(&apos;chokidar&apos;);</span><br><span class="line"></span><br><span class="line">const watcher = chokidar.watch(path.join(__dirname, &apos;/src&apos;));</span><br><span class="line"></span><br><span class="line">watcher.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    watcher.on(&apos;change&apos;, (path) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;&lt;---- watched file change, do something ----&gt;&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watcher.on(&apos;add&apos;, (path) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;&lt;---- watched new file add, do something ----&gt;&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watcher.on(&apos;unlink&apos;, (path) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;&lt;---- watched file remove, do something ----&gt;&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>执行<code>npm install --save chokidar</code>安装’chokidar’组件, 并执行<code>node development.js</code>运行程序, 尝试修改<code>app.js</code>的内容, 尝试在<code>src</code>目录中新建文件并删除新建的文件, 会看到如下所示输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//*console log*</span><br><span class="line"></span><br><span class="line">    ⇒  node development.js</span><br><span class="line">    </span><br><span class="line">    &lt;---- watched file change, do something ----&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;---- watched new file add, do something ----&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;---- watched file remove, do something ----&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="引入程序并在发生改动时重启"><a href="#引入程序并在发生改动时重启" class="headerlink" title="引入程序并在发生改动时重启"></a>引入程序并在发生改动时重启</h2><p>由于主进程被用来监视文件了, 所以我们要把主程序运行在子进程中, 当代码发生改动时, 我们可以结束这个子进程并创建新的子进程. 创建进程需要使用<a href="https://nodejs.org/api/child_process.html" target="_blank" rel="noopener">child_process</a>模块, 代码如下所示:</p>
<p><em>创建子进程, 启动主程序</em><br>···<br>    let appIns = cp.fork(path.join(__dirname, ‘../src/app.js’));<br>···<br><em>发生改动时杀死子进程并重启</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appIns.kill(&apos;SIGINT&apos;);</span><br><span class="line"></span><br><span class="line">appIns = cp.fork(require(&apos;path&apos;).join(__dirname, &apos;../src/app.js&apos;));</span><br></pre></td></tr></table></figure></p>
<p><em>监听SIGINT信息, 终止进程</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;SIGINT&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    process.exit(0);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>完整代码如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// *development.js*</span><br><span class="line"></span><br><span class="line">    &apos;use strict&apos;</span><br><span class="line">    </span><br><span class="line">    const path = require(&apos;path&apos;);</span><br><span class="line">    </span><br><span class="line">    const cp = require(&apos;child_process&apos;);</span><br><span class="line">    </span><br><span class="line">    const chokidar = require(&apos;chokidar&apos;);</span><br><span class="line">    </span><br><span class="line">    const watcher = chokidar.watch(path.join(__dirname, &apos;/src&apos;));</span><br><span class="line">    </span><br><span class="line">    let appIns = cp.fork(path.join(__dirname, &apos;/src/app.js&apos;));</span><br><span class="line">    </span><br><span class="line">    watcher.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">        watcher.on(&apos;change&apos;, (path) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    console.log(&apos;&lt;---- watched file change, do something ----&gt;&apos;);</span><br><span class="line">    </span><br><span class="line">            appIns = reload(appIns);</span><br><span class="line">    </span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        watcher.on(&apos;add&apos;, (path) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    console.log(&apos;&lt;---- watched new file add, do something ----&gt;&apos;);</span><br><span class="line">    </span><br><span class="line">            appIns = reload(appIns);</span><br><span class="line">    </span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        watcher.on(&apos;unlink&apos;, (path) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    console.log(&apos;&lt;---- watched file remove, do something ----&gt;&apos;);</span><br><span class="line">    </span><br><span class="line">            appIns = reload(appIns);</span><br><span class="line">    </span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    process.on(&apos;SIGINT&apos;, () =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">        process.exit(0);</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    functionreload(appIns) &#123;</span><br><span class="line">    </span><br><span class="line">        appIns.kill(&apos;SIGINT&apos;);</span><br><span class="line">    </span><br><span class="line">    return cp.fork(require(&apos;path&apos;).join(__dirname, &apos;/src/app.js&apos;));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>执行<code>node development.js</code>运行, 尝试修改<code>app.js</code>, 改为<code>console.log(&#39;app.js changed&#39;);</code>, 将看到如下输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*console log*</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ⇒  node development.js</span><br><span class="line">    </span><br><span class="line">    app.js</span><br><span class="line">    </span><br><span class="line">    &lt;---- watched file change, do something ----&gt;</span><br><span class="line">    </span><br><span class="line">    app.js changed</span><br></pre></td></tr></table></figure></p>
<p>尝试在<code>src</code>目录中创建<code>a.js</code>, 并修改<code>app.js</code>使其输出<code>a.js</code>内容, 这里不在粘贴输出, 请自行尝试.</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可以看到该实现方法十分简单, 并且适用于任何node.js开发场景, 譬如常用的express, koa后端接口开发.</p>
<p>感谢您的阅读, 欢迎留言指导讨论.</p>
<h1 id="将node-js的终端输出重定向到浏览器控制台中-1"><a href="#将node-js的终端输出重定向到浏览器控制台中-1" class="headerlink" title="将node.js的终端输出重定向到浏览器控制台中"></a><a href="https://blog.suisuijiang.com/node-js-console-log-redirect-to-browser/" target="_blank" rel="noopener">将node.js的终端输出重定向到浏览器控制台中</a></h1><p>在编写node.js代码时, 我们经常会临时的打印变量来查看内容, 对于一些基本的数据类型, 比如: <code>Number</code>, <code>String</code>, <code>Boolean</code>, 并没有什么问题, 但是当打印<code>Object</code>类型时, 如果该<code>Object</code>变量具有大量的属性, 我们会得到一个超长的输出内容, 有的时候甚至会超出终端缓冲区大小, 非常不利于观察结果. </p>
<p>使用过chrome浏览器开发者工具的朋友应该发现了, chrome的console会折叠<code>Object</code>值, 并且可以随意打开查看, 十分方便.</p>
<p> <img src="/2016/11/12/Node-js技巧/1.png" alt=""></p>
<h2 id="将输出重定向"><a href="#将输出重定向" class="headerlink" title="将输出重定向"></a>将输出重定向</h2><p>在这里, 我们使用开源组件<a href="https://www.npmjs.com/package/node-monkey" target="_blank" rel="noopener">node-monkey</a>, <code>node-monkey</code>是一款在浏览器对node.js程序进行debug和性能分析的工具.</p>
<p>执行<code>npm install --save node_monkey</code>安装组件.</p>
<p>在你的程序入口添加如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;node-monkey&apos;).start()</span><br></pre></td></tr></table></figure></p>
<p>运行你的程序, 可以看到终端中的输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*console log*</span><br><span class="line"></span><br><span class="line">    ⇒  node app.js</span><br><span class="line">    </span><br><span class="line">       info  - socket.io started</span><br><span class="line">    </span><br><span class="line">    ------------------</span><br><span class="line">    </span><br><span class="line">    NodeMonkey started</span><br><span class="line">    </span><br><span class="line">    To inspect output, open a browser to: http://127.0.0.1:50500</span><br><span class="line">    </span><br><span class="line">    ------------------</span><br></pre></td></tr></table></figure></p>
<p>打开浏览器访问<code>http://127.0.0.1:50500</code>, 打开浏览器的控制台, 可以看到你的程序的输出内容.</p>
<p> <img src="/2016/11/12/Node-js技巧/2.png" alt=""></p>
<p><code>node-monkey</code>默认关联了<code>console.log</code>, <code>console.warn</code>, <code>console.error</code>输出函数, <code>127.0.0.1:50500</code>是<code>node-monkey</code>的默认地址, 可以通过在<code>start()</code>中传入参数来修改.</p>
<h2 id="自动打开浏览器"><a href="#自动打开浏览器" class="headerlink" title="自动打开浏览器"></a>自动打开浏览器</h2><p>有个小工具可以让我们自动打开默认浏览器并跳转到指定地址, 免去手动输入的过程.</p>
<p>安装<code>opener</code>, 执行<code>npm install --save opener</code></p>
<p>在上述所添加的代码下方加上如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;opener&quot;)(&apos;http://127.0.0.1:50500&apos;);</span><br></pre></td></tr></table></figure></p>
<p>重新运行你的程序, 启动<code>node-money</code>后就自动打开到指定页面了.</p>
<p><code>node-monkey</code>还有其它可用的功能, 您可以查询文档研究它的妙用.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/31/26个精选的JavaScript面试问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/31/26个精选的JavaScript面试问题/" itemprop="url">26个精选的JavaScript面试问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-31T20:34:53+08:00">
                2016-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JavaScript中，在两个不同类型之间的转换叫做<code>coercion</code>。在JavaScript中有两种形式：显示转换和隐式转换。</p>
<p>下面是一个显示转换的例子：</p>
<pre><code>var a = &quot;42&quot;;
var b = Number( a );
a;              // &quot;42&quot;
b;              // 42 -- the number!
</code></pre><p>下面是一个隐式转换的例子：</p>
<pre><code>var a = &quot;42&quot;;
var b = a * 1;  // &quot;42&quot; implicitly coerced to 42 here
a;              // &quot;42&quot;
b;              // 42 -- the number!
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.fullstack.cafe%2F" target="_blank" rel="noopener">FullStack.Cafe</a></p>
<h3 id="Q2-JavaScript中的作用域是怎样的？"><a href="#Q2-JavaScript中的作用域是怎样的？" class="headerlink" title="Q2: JavaScript中的作用域是怎样的？"></a>Q2: JavaScript中的作用域是怎样的？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐</p>
</blockquote>
<p>在JavaScript中，每一个函数都有各自的作用域(<code>scope</code>)。作用域可以理解为是一个变量的集合以及相应的如何访问它的规则。只有在函数内部的变量才可以访问到该函数域的变量。</p>
<p>在同一个作用域内部，变量名必须要唯一。作用域可以嵌套。在最内部的作用域中，可以访问任何外部的作用域中的变量。</p>
<h3 id="Q3-请解释JavaScript中的相等判断"><a href="#Q3-请解释JavaScript中的相等判断" class="headerlink" title="Q3: 请解释JavaScript中的相等判断"></a>Q3: 请解释JavaScript中的相等判断</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐</p>
</blockquote>
<p>JavaScript中的相等判断有严格判断和带隐式转换的判断两种：</p>
<ul>
<li>严格判断(strict comparision): 比如<code>===</code>，比较的时候不会隐式转换类型；</li>
<li><p>抽象判断(abstract comparasion)：比如<code>==</code>，比较的时候会隐式转换类型。</p>
<p>  var a = “42”;<br>  var b = 42;</p>
<p>  a == b;         // true<br>  a === b;        // false</p>
</li>
</ul>
<p>一些简单的规则：</p>
<ul>
<li>如果两边都是布尔类型的值，使用<code>===</code>;</li>
<li>如果两边是0,<code>&quot;&quot;</code>,<code>[]</code>，使用<code>===</code>;</li>
<li>所有其它类型，使用<code>==</code>是安全的。而且在很多情况下会简化代码、增加可读性。</li>
</ul>
<h3 id="Q4-请解释什么叫做回调函数并提供一个简单的例子"><a href="#Q4-请解释什么叫做回调函数并提供一个简单的例子" class="headerlink" title="Q4: 请解释什么叫做回调函数并提供一个简单的例子"></a>Q4: 请解释什么叫做回调函数并提供一个简单的例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>回调函数是一个函数，它被作为参数传入另一个函数，当某些操作结束后，该函数被调用。下面是一个简单的例子，当数组被修改后，调用回调函数打印一行日志。</p>
<pre><code>functionmodifyArray(arr, callback) {
  // do something to arr here
  arr.push(100);
  // then execute the callback function that was passed
  callback();
}

var arr = [1, 2, 3, 4, 5];
modifyArray(arr, function() {
  console.log(&quot;array has been modified&quot;, arr);
});
</code></pre><h3 id="Q5-“use-strict”到底有何用处？"><a href="#Q5-“use-strict”到底有何用处？" class="headerlink" title="Q5: “use strict”到底有何用处？"></a>Q5: “use strict”到底有何用处？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p><code>use strict</code>放在文件的顶部或则函数的第一行来启动更加严格的检查来避免失误引起的错误。比如，下面的代码会抛出错误：</p>
<pre><code>functiondoSomething(val) {
  &quot;use strict&quot;; 
  x = val + 10;
}
</code></pre><p>因为x没有定义，如果使用了<code>use strict</code>，x是不会被当做全局的变量来看待。下面的代码修复了这个BUG：</p>
<pre><code>functiondoSomething(val) {
  &quot;use strict&quot;; 
  var x = val + 10;
}
</code></pre><h3 id="Q6-请解释Null和Undefined"><a href="#Q6-请解释Null和Undefined" class="headerlink" title="Q6: 请解释Null和Undefined"></a>Q6: 请解释Null和Undefined</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>JavaScript和TypeScript有两个最基本的类型<code>null</code>和<code>undefined</code>。它们的含义是不同的：</p>
<ul>
<li>如果还没有被初始化，则是<code>undefined</code>;</li>
<li>如果不可用，则可以用<code>null</code>来表示；</li>
</ul>
<h3 id="Q7-请实现如下函数"><a href="#Q7-请实现如下函数" class="headerlink" title="Q7: 请实现如下函数"></a>Q7: 请实现如下函数</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<pre><code>var addSix = createBase(6);
addSix(10); // returns 16
addSix(21); // returns 27
</code></pre><p><code>addSix</code>是一个函数，也就是说createBase函数的返回是一个函数。</p>
<pre><code>functioncreateBase(baseNumber) {
  returnfunction(N) {
    // we are referencing baseNumber here even though it was declared// outside of this function. Closures allow us to do this in JavaScriptreturn baseNumber + N;
  }
}

var addSix = createBase(6);
addSix(10);
addSix(21);
</code></pre><h3 id="Q8-请解释JavaScript中的值和类型"><a href="#Q8-请解释JavaScript中的值和类型" class="headerlink" title="Q8: 请解释JavaScript中的值和类型"></a>Q8: 请解释JavaScript中的值和类型</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>下面是JavaScript内置的可用类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null和undefined</li>
<li>object</li>
<li>symbol (ES6的新语法)</li>
</ul>
<h3 id="Q9-请解释事件冒泡以及如何阻止它？"><a href="#Q9-请解释事件冒泡以及如何阻止它？" class="headerlink" title="Q9: 请解释事件冒泡以及如何阻止它？"></a>Q9: 请解释事件冒泡以及如何阻止它？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>事件冒泡的概念是指：在最内层的元素上绑定的事件被触发后，会按照嵌套的层次由内向外逐步触发。因此，点击某个孩子节点可能会触发父节点的事件。</p>
<p>一个阻止事件冒泡的办法就是使用<code>event.stopPropagation()</code>，在IE&lt;9的浏览器上使用<code>event.cancelBubble()</code>。</p>
<p>来源：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkennymkchan" target="_blank" rel="noopener">github.com/kennymkchan</a></p>
<h3 id="Q10-请解释JavaScript中的let关键字"><a href="#Q10-请解释JavaScript中的let关键字" class="headerlink" title="Q10. 请解释JavaScript中的let关键字"></a>Q10. 请解释JavaScript中的let关键字</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>ES6允许你使用let关键字来申明块作用域(<code>{...}</code>)的变量。</p>
<p>来源: <a href="https://link.juejin.im?target=github.com%2Fgetify" target="_blank" rel="noopener">github.com/getify</a></p>
<h3 id="Q11-如何检查一个数字是否是整数？"><a href="#Q11-如何检查一个数字是否是整数？" class="headerlink" title="Q11: 如何检查一个数字是否是整数？"></a>Q11: 如何检查一个数字是否是整数？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>一个最简单的方法是判断除以1的余数是否为0.</p>
<pre><code>functionisInt(num) {
  return num % 1 === 0;
}

console.log(isInt(4)); // trueconsole.log(isInt(12.2)); // falseconsole.log(isInt(0.3)); // false
</code></pre><p>来源: <a href="https://link.juejin.im?target=coderbyte.com" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q12-什么叫IIFEs-Immediately-Invoked-Function-Expressions"><a href="#Q12-什么叫IIFEs-Immediately-Invoked-Function-Expressions" class="headerlink" title="Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)?"></a>Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)?</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>IIFE叫做立即执行表达式，顾名思义，该表达式一被创建就立即执行。</p>
<pre><code>(functionIIFE(){
    console.log( &quot;Hello!&quot; );
})();
// &quot;Hello!&quot;
</code></pre><p>该方法常用语避免污染全局的命名空间，因为所以在IIFE中使用的变量外部都无法访问。</p>
<p>来源: <a href="https://link.juejin.im?target=stackoverflow.com" target="_blank" rel="noopener">stackoverflow.com</a></p>
<h3 id="Q13-如果比较JavaScript中的两个对象？"><a href="#Q13-如果比较JavaScript中的两个对象？" class="headerlink" title="Q13: 如果比较JavaScript中的两个对象？"></a>Q13: 如果比较JavaScript中的两个对象？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>两个非基本类型的值，比如对象(包括函数和数组)都是通过引用的形式来访问。如果直接通过<code>==</code>和<code>===</code>来判断，那么只会简单的判断其引用地址是否相同，而不是它们实际对应的值。</p>
<p>如果数组和字符串做比较，那么数组会通过逗号拼接转换为字符串。通过等号判断的时候，两个相同的数组不会相等，但是和相同数据的字符串比较反而相等。</p>
<pre><code>var a = [1,2,3];
var b = [1,2,3];
var c = &quot;1,2,3&quot;;

a == c;     // true
b == c;     // true
a == b;     // false
</code></pre><p>如果要深度比较，可以使用第三方库，比如<code>deep-equal</code>或则你自己实现一个比较算法。</p>
<h3 id="Q14-请解释ES5和ES6的不同点"><a href="#Q14-请解释ES5和ES6的不同点" class="headerlink" title="Q14: 请解释ES5和ES6的不同点"></a>Q14: 请解释ES5和ES6的不同点</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<ul>
<li>ECMAScript 5 (ES5): 第5个ECMAScript版本，于2009年标准化。该标准几乎所有的浏览器都完全支持。</li>
<li>ECMAScript 6 (ES6)/ECMAScript 2015 (ES2015):  第6个ECMAScript版本，于2015年标准化。目前各大浏览器还只是部分支持。</li>
</ul>
<p>接下来介绍它们主要的区别：</p>
<ul>
<li><p>箭头函数和字符串嵌入：</p>
<p>  const greetings = (name) =&gt; {</p>
<pre><code>return`hello ${name}`;
</code></pre><p>  }</p>
</li>
</ul>
<p>甚至：</p>
<pre><code>const greetings = name =&gt;`hello ${name}`;
</code></pre><ul>
<li><p>常量声明(Const): 如同其它编程语言中的常量一样，但又有不同。这里的<code>const</code>代表了<code>constant reference</code>。也就是说，你可以修改其指向的对象的值。但是你不能修改其reference的值。</p>
<p>  const NAMES = [];<br>  NAMES.push(“Jim”);<br>  console.log(NAMES.length === 1); // true<br>  NAMES = [“Steve”, “John”]; // error</p>
</li>
<li><p>块作用域变量：ES6中的新关键字<code>let</code>允许允许开发者将变量的作用域限定在块级别。不会像<code>var</code>一样变量提升。</p>
</li>
<li><p>参数默认值：允许在函数定义的时候指定默认的值。</p>
<p>  // Basic syntaxfunctionmultiply (a, b = 2) {</p>
<pre><code>return a * b;
</code></pre><p>  }<br>  multiply(5); // 10</p>
</li>
<li><p>类定义和继承</p>
</li>
</ul>
<p>ES6开始支持定义类(使用<code>class</code>关键字)，构造函数(使用<code>constructor</code>关键字)，和<code>extend</code>关键字来实现继承。</p>
<ul>
<li>for-of操作</li>
</ul>
<p><code>for...of</code>语句用来迭代访问一个对象的所有属性。</p>
<ul>
<li><p>Spread操作符：用于对象合并</p>
<p>  const obj1 = { a: 1, b: 2 }<br>  const obj2 = { a: 2, c: 3, d: 4}<br>  const obj3 = {…obj1, …obj2}</p>
</li>
</ul>
<ul>
<li><p>Promise: Promises提供了一个处理异步操作的方法。你可以用回调函数来实现，但是Promise更加简洁和可读。</p>
<p>  const isGreater = (a, b) =&gt; {</p>
<pre><code>returnnewPromise ((resolve, reject) =&gt; {
  if(a &gt; b) {
    resolve(true)
  } else {
    reject(false)
  }
  })
</code></pre><p>  }<br>  isGreater(1, 2)</p>
<pre><code>.then(result =&gt; {
  console.log(&apos;greater&apos;)
})
</code></pre><p>   .catch(result =&gt; {</p>
<pre><code>console.log(&apos;smaller&apos;)
</code></pre><p>   })</p>
</li>
</ul>
<ul>
<li><p>模块的export和import。</p>
<p>  const myModule = { x: 1, y: () =&gt; { console.log(‘This is ES5’) }}<br>  exportdefault myModule;</p>
</li>
</ul>
<pre><code>import myModule from&apos;./myModule&apos;;
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.to%2Faershov24%2Fundefined" target="_blank" rel="noopener">Bulby.io</a></p>
<h3 id="Q15-请解释undefined和not-defined的区别"><a href="#Q15-请解释undefined和not-defined的区别" class="headerlink" title="Q15: 请解释undefined和not defined的区别"></a>Q15: 请解释<code>undefined</code>和<code>not defined</code>的区别</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<p>在JavaScript中，如果你尝试使用不存在的还未申明的变量，JavaScript会抛出错误<code>var name is not defined</code>。但是如果你用<code>typeof</code>来查看其类型，会返回<code>undefined</code>。</p>
<p>我们先来澄清一下声明和定义的区别：<code>var x</code>是一个声明，因为你并没有定义其具体的值，你只是声明其存在性。</p>
<pre><code>var x; // declaring xconsole.log(x); //output: undefined
</code></pre><p><code>var x = 1</code>同时兼具声明和定义，我们也可以叫它初始化。在JavaScript中，每一个变量和函数声明都会被提升到顶部。</p>
<p>如果我们访问一个声明了但是未定义的变量，会返回<code>undefined</code>。</p>
<pre><code>var x; // Declarationif(typeof x === &apos;undefined&apos;) // Will return true
</code></pre><blockquote>
<p>访问一个未声明未定义的变量，会返回not defined错误。</p>
</blockquote>
<pre><code>console.log(y);  // Output: ReferenceError: y is not defined
</code></pre><p>来源: <a href="https://link.juejin.im?target=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F20822022%2Fjavascript-variable-definition-declaration" target="_blank" rel="noopener">stackoverflow.com</a></p>
<h3 id="Q16-匿名函数和命名函数的区别？"><a href="#Q16-匿名函数和命名函数的区别？" class="headerlink" title="Q16: 匿名函数和命名函数的区别？"></a>Q16: 匿名函数和命名函数的区别？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<pre><code>var foo = function() { // anonymous function assigned to variable foo// ..
};

var x = functionbar(){ // named function (bar) assigned to variable x // ..
};

foo(); // actual function execution
x();
</code></pre><p>译者补充：匿名函数如果不赋值给某个变量，则无法被调用了；命名函数再次被赋值不是多此一举么。</p>
<h3 id="Q17-JavaScript中闭包是什么？请提供一个例子"><a href="#Q17-JavaScript中闭包是什么？请提供一个例子" class="headerlink" title="Q17: JavaScript中闭包是什么？请提供一个例子"></a>Q17: JavaScript中闭包是什么？请提供一个例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>闭包是一个定义在其它函数(父函数)里面的函数，它拥有对父函数里面变量的访问权。闭包拥有如下三个作用域的访问权：</p>
<ul>
<li>自身的作用域</li>
<li>父作用域</li>
<li><p>全局作用域</p>
<p>  var globalVar = “abc”;</p>
<p>  // Parent self invoking function<br>  (functionouterFunction (outerArg) { // begin of scope outerFunction// Variable declared in outerFunction function scopevar outerFuncVar = ‘x’;    </p>
<pre><code>// Closure self-invoking function
(functioninnerFunction (innerArg) { // begin of scope innerFunction// variable declared in innerFunction function scopevar innerFuncVar = &quot;y&quot;;
  console.log(         
    &quot;outerArg = &quot; + outerArg + &quot;\n&quot; +
    &quot;outerFuncVar = &quot; + outerFuncVar + &quot;\n&quot; +
    &quot;innerArg = &quot; + innerArg + &quot;\n&quot; +
    &quot;innerFuncVar = &quot; + innerFuncVar + &quot;\n&quot; +
    &quot;globalVar = &quot; + globalVar);
// end of scope innerFunction
})(5); // Pass 5 as parameter// end of scope outerFunction
</code></pre><p>  })(7); // Pass 7 as parameter</p>
</li>
</ul>
<p><code>innerFunction</code>是一个闭包，定义在<code>outerFunction</code>中，它可以访问<code>outerFunction</code>作用域的所有变量。当然，它还可以访问全局变量。</p>
<p>输出结果如下：</p>
<pre><code>outerArg = 7
outerFuncVar = x
innerArg = 5
innerFuncVar = y
globalVar = abc
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fganqqwerty%2F123-Essential-JavaScript-Interview-Question%2Fblob%2Fmaster%2FREADME.md" target="_blank" rel="noopener">github.com/ganqqwerty</a></p>
<h3 id="Q18-在JavaScript中如何创建私有变量？"><a href="#Q18-在JavaScript中如何创建私有变量？" class="headerlink" title="Q18: 在JavaScript中如何创建私有变量？"></a>Q18: 在JavaScript中如何创建私有变量？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>你可以通过在函数中声明变量来创建私有变量。因为在函数中，外部无法直接访问。</p>
<pre><code>functionfunc() {
  var priv = &quot;secret code&quot;;
}

console.log(priv); // throws error
</code></pre><p>为了访问该变量，可以构造一个帮助函数来返回该值。</p>
<pre><code>functionfunc() {
  var priv = &quot;secret code&quot;;
  returnfunction() {
    return priv;
  }
}

var getPriv = func();
console.log(getPriv()); // =&gt; secret code
</code></pre><p>来源:<a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q19-请解释原型模式-Prototype-Design-Pattern"><a href="#Q19-请解释原型模式-Prototype-Design-Pattern" class="headerlink" title="Q19: 请解释原型模式(Prototype Design Pattern)"></a>Q19: 请解释原型模式(Prototype Design Pattern)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>原型模式会创建一个新的对象，但不是创建一个未初始化的对象，而是通过拷贝原型链上的值或则被拷贝对象的值来完成初始化。传统的语言很少使用原型模式，但是JavaScript作为一个基于原型的语言，使用原型模式来创建新的对象。</p>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.dofactory.com%2Fjavascript%2Fprototype-design-pattern" target="_blank" rel="noopener">dofactory.com</a></p>
<h3 id="Q20-判断给定的字符串是否同态-isomorphic"><a href="#Q20-判断给定的字符串是否同态-isomorphic" class="headerlink" title="Q20: 判断给定的字符串是否同态(isomorphic)"></a>Q20: 判断给定的字符串是否同态(isomorphic)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>首先介绍什么叫做同态：两个字符串，如果A字符串中的每一个字符都可以在B字符串中找到唯一对应，并且顺序一一对应；如果存在这样的函数，那么A和B同态。</p>
<ul>
<li><code>paper</code>和<code>title</code>同态</li>
<li><code>egg</code>和<code>sad</code>不同态</li>
<li><p><code>dgg</code>和<code>add</code>同态</p>
<p>  isIsomorphic(“egg”, ‘add’); // true<br>  isIsomorphic(“paper”, ‘title’); // true<br>  isIsomorphic(“kick”, ‘side’); // falsefunctionisIsomorphic(firstString, secondString) {</p>
<pre><code>// Check if the same length. If not, they cannot be isomorphicif (firstString.length !== secondString.length) returnfalsevar letterMap = {};

for (var i = 0; i &lt; firstString.length; i++) {
  var letterA = firstString[i],
      letterB = secondString[i];

  // If the letter does not exist, create a map and map it to the value// of the second letterif (letterMap[letterA] === undefined) {
    letterMap[letterA] = letterB;
  } elseif (letterMap[letterA] !== letterB) {
    // Eles if letterA already exists in the map, but it does not map to// letterB, that means that A is mapping to more than one letter.returnfalse;
  }
}
// If after iterating through and conditions are satisfied, return true.// They are isomorphicreturntrue;
</code></pre><p>  }</p>
</li>
</ul>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkennymkchan%2Finterview-questions-in-javascript" target="_blank" rel="noopener">github.com/kennymkchan</a></p>
<h3 id="Q21-Transpiling代表了什么意思？"><a href="#Q21-Transpiling代表了什么意思？" class="headerlink" title="Q21: Transpiling代表了什么意思？"></a>Q21: <code>Transpiling</code>代表了什么意思？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p><code>Transpiling</code>是<code>transforming + compiling</code>的合成词。对于一些新的语法，浏览器还不支持。最好的办法就是将其变换到旧的等价的代码，这个过程通常叫做<code>transpiling</code>。</p>
<p>典型的，你可以在<code>build</code>的过程中加入<code>transpiler</code>，就如同<code>code linter</code>和<code>minifier</code>一样。</p>
<p>已经有很多知名的transpilers可供使用：</p>
<ul>
<li>Babel: 将ES6编译到ES5</li>
<li>Traceur：将ES6,ES7等编译到ES5</li>
</ul>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2Fmaster%2Fup%2520%2526%2520going%2Fch2.md" target="_blank" rel="noopener">You Don’t Know JS, Up &amp;going</a></p>
<h3 id="Q22-this关键字如何工作？请提供一些例子"><a href="#Q22-this关键字如何工作？请提供一些例子" class="headerlink" title="Q22: this关键字如何工作？请提供一些例子"></a>Q22: <code>this</code>关键字如何工作？请提供一些例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>在JavaScript中，this总是指向函数的“拥有者”(也就是指向该函数的对象)，或则拥有该函数的对象。</p>
<pre><code>functionfoo() {
    console.log( this.bar );
}

var bar = &quot;global&quot;;

var obj1 = {
    bar: &quot;obj1&quot;,
    foo: foo
};

var obj2 = {
    bar: &quot;obj2&quot;
};

foo();          // &quot;global&quot;
obj1.foo();     // &quot;obj1&quot;
foo.call( obj2 );  // &quot;obj2&quot;new foo();       // undefined
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.quirksmode.org%2Fjs%2Fthis.html" target="_blank" rel="noopener">quirksmode.org</a></p>
<h3 id="Q23-如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。"><a href="#Q23-如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。" class="headerlink" title="Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。"></a>Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<pre><code>var arr = [1, 2, 3, 4, 5];
var avg = arr.average();
console.log(avg);
</code></pre><p>JavaScript是一个基于原型的语言。也就是说对象之间通过原型链接，并继承其函数。为了给Array对象添加函数，我们可以修改其原型定义<code>Array prorotype</code>。</p>
<pre><code>Array.prototype.average = function() {
  // calculate sumvar sum = this.reduce(function(prev, cur) { return prev + cur; });
  // return sum divided by number of elementsreturn sum / this.length;
}

var arr = [1, 2, 3, 4, 5];
var avg = arr.average();
console.log(avg); // =&gt; 3
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q24-JavaScript中提升-hoisting-是什么意思？"><a href="#Q24-JavaScript中提升-hoisting-是什么意思？" class="headerlink" title="Q24: JavaScript中提升(hoisting)是什么意思？"></a>Q24: JavaScript中提升(hoisting)是什么意思？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>提升(hoisting)是指JavaScript的解释器将所有的变量和函数声明都提升到该作用域的顶部，有两种提升类型：</p>
<ul>
<li>变量提升</li>
<li>函数提升</li>
</ul>
<p>在一个作用域中通过声明的变量和函数在整个作用域中都可以使用。</p>
<pre><code>var a = 2;
foo();                 // works because `foo()`// declaration is &quot;hoisted&quot;functionfoo() {
    a = 3;
    console.log( a );   // 3var a;             // declaration is &quot;hoisted&quot;// to the top of `foo()`
}

console.log( a );   // 2
</code></pre><p>虽然<code>foo()</code>函数在后面定义，但是在前面也可以调用。</p>
<h3 id="Q25-如下代码会返回什么结果？"><a href="#Q25-如下代码会返回什么结果？" class="headerlink" title="Q25: 如下代码会返回什么结果？"></a>Q25: 如下代码会返回什么结果？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<pre><code>0.1 + 0.2 === 0.3
</code></pre><p>不要惊讶，其结果是false。因为浮点数在系统内的精确度问题，0.1+0.2的结果并不是0.3，而是0.30000000000000004。<br>要避免这个问题的方法是指定返回结果的小数位数。</p>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q26-请描述一下揭示模式-Revealing-Module-Pattern"><a href="#Q26-请描述一下揭示模式-Revealing-Module-Pattern" class="headerlink" title="Q26: 请描述一下揭示模式(Revealing Module Pattern)"></a>Q26: 请描述一下揭示模式(Revealing Module Pattern)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<p><strong>Module pattern</strong>的一个变种是<code>Revealing Module Pattern</code>。该设计模式的目的是做到很好的代码隔离，只是将需要对外公开的变量和函数暴露出来。一个直接的实现如下所示：</p>
<pre><code>var Exposer = (function() {
  var privateVariable = 10;

  var privateMethod = function() {
    console.log(&apos;Inside a private method!&apos;);
    privateVariable++;
  }

  var methodToExpose = function() {
    console.log(&apos;This is a method I want to expose!&apos;);
  }

  var otherMethodIWantToExpose = function() {
    privateMethod();
  }

  return {
      first: methodToExpose,
      second: otherMethodIWantToExpose
  };
})();

Exposer.first();        // Output: This is a method I want to expose!
Exposer.second();       // Output: Inside a private method!
Exposer.methodToExpose; // undefined
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/25/CommonJS-AMD-CMD-ES6/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/25/CommonJS-AMD-CMD-ES6/" itemprop="url">CommonJS,AMD,CMD,ES6 </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-25T21:18:27+08:00">
                2016-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CommonJS,AMD,CMD,ES6</p>
<p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>
<p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p>
<pre><code>/** AMD写法 **/
define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) { 
     // 等于在最前面声明并初始化了要用到的所有模块
    a.doSomething();
    if (false) {
        // 即便没用到某个模块 b，但 b 还是提前执行了
        b.doSomething()
    } 
});


/** CMD写法 **/
define(function(require, exports, module) {
    var a = require(&apos;./a&apos;); //在需要时申明
    a.doSomething();
    if (false) {
        var b = require(&apos;./b&apos;);
        b.doSomething();
    }
}); 
</code></pre><p>ES6 模块是动态引用:ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>
<p>ES6 模块与 CommonJS 模块的差异</p>
<ol>
<li><font color="#ff0000">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</font>,<strong>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</strong><br>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
<li><font color="#ff0000"> CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</font></li>
<li><font color="#ff0000">运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>编译时加载: ES6模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</font></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/01/JS正则表达式Regex/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/01/JS正则表达式Regex/" itemprop="url">JS正则表达式Regex</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-01T21:56:19+08:00">
                2016-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>名余曰正则兮，字余曰灵均。</p>
</blockquote>
<p><code>Regular Expressions</code>翻译成中文叫正则表达式。也不知道是谁翻译过来的，听起来就很严肃。似乎翻译成<code>通用表达式</code>更能传达其精髓，如果你不怕梦见屈原的话。</p>
<p>为什么叫通用表达式？因为它有一套和编程语言无关的文本匹配规则。很多语言都实现了正则表达式的文本匹配引擎，只不过在功能集合上略有不同。</p>
<p>我们要记住的是三点：</p>
<p>其一，正则表达式是用来提取文本的。</p>
<p>其二，正则表达式的表达能力强大到令人发指。</p>
<p>其三，正则表达式的语法对初学者不友好。</p>
<p>另外，本专题只涉及JavaScript语言的正则表达式，其他语言的规则可能略有不同。</p>
<p>我还为各位读者准备了一副宣传语，应该能让你心动(点赞)吧？</p>
<blockquote>
<p>学一门前端工具，几年就过时了。学正则表达式，受用一辈子。</p>
</blockquote>
<h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>什么叫普通字符？</p>
<p>当我们写<code>a</code>的时候，我们指的就是<code>a</code>；当我们写<code>爱</code>的时候，我们指的就是<code>爱</code>。</p>
<pre><code>&apos;hello 😀 regex&apos;.match(/😀/);
// [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined]复制代码
</code></pre><p>这就是普通字符，它在正则中的含义就是检索它本身。除了正则规定的部分字符外，其余的都是普通字符，包括各种人类语言，包括emoji，只要能够表达为字符串。</p>
<h2 id="开始与结束"><a href="#开始与结束" class="headerlink" title="开始与结束"></a>开始与结束</h2><p><code>^</code>字符的英文是<code>caret</code>，翻译成中文是<code>脱字符</code>。不要问我，又不是我翻译的。它在正则中属于元字符，通常代表的意义是文本的开始。说通常是因为当它在字符组中<code>[^abc]</code>另有含义。</p>
<p>什么叫文本的开始？就是如果它是正则主体的第一个符号，那紧跟着它的字符必须是被匹配文本的第一个字符。</p>
<pre><code>&apos;regex&apos;.match(/^r/);
// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p>问题来了，如果<code>^</code>不是正则的第一个符号呢？</p>
<pre><code>&apos;regex&apos;.match(/a^r/);
// null复制代码
</code></pre><p>所以呀，关于它有三点需要注意：</p>
<ul>
<li>作为匹配文本开始元字符的时候必须是正则主体的第一个符号，否则正则无效。</li>
<li>它匹配的是一个位置，而不是具体的文本。</li>
<li>它在其他规则中有另外的含义。</li>
</ul>
<p><code>$</code>字符与<code>^</code>正好相反。它代表文本的结束，并且没有其他含义(其实是有的，但不是在正则主体内)。同样，它必须是正则主体的最后一个符号。</p>
<pre><code>&apos;regex&apos;.match(/x$/);
// [&quot;x&quot;, index: 4, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p><code>^</code>与<code>$</code>特殊的地方在于它匹配的是一个位置。位置不像字符，它看不见，所以更不容易理解。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>我们现在已经知道<code>$</code>匹配文本的结束位置，它是元字符。但是如果我想匹配<code>$</code>本身呢？匹配一个美元符号的需求再常见不过了吧。所以我们得将它贬为庶民。</p>
<p><code>\</code>反斜杠就是干这个的。</p>
<pre><code>&apos;price: $3.6&apos;.match(/\$[0-9]+\.[0-9]+$/);
// [&quot;$3.6&quot;, index: 7, input: &quot;price: $3.6&quot;, groups: undefined]复制代码
</code></pre><p>上面的例子有点超纲了，超纲的部分先不管。</p>
<p>你可以认为<code>\</code>也是一个元字符，它跟在另一个元字符后面，就能还原它本来的含义。</p>
<p>如果有两个<code>\</code>呢？那就是转义自身了。如果有三个<code>\</code>呢？我们得分成两段去理解。以此类推。</p>
<p>普通字符前面跟了一个<code>\</code>是什么效果？首先它们是一个整体，然后普通字符转义后还是普通字符。</p>
<h2 id="带反斜杠的元字符"><a href="#带反斜杠的元字符" class="headerlink" title="带反斜杠的元字符"></a>带反斜杠的元字符</h2><p>一般来说，普通字符前面带反斜杠还是普通字符，但是有一些普通字符，带反斜杠后反而变成了元字符。</p>
<p>要怪只能怪计算机领域的常用符号太少了。<br>元字符含义\b匹配一个单词边界(boundary)\B匹配一个非单词边界\d匹配一个数字字符(digit)\D匹配一个非数字字符\s匹配一个空白字符(space)\S匹配一个非空白字符\w匹配一个字母或者一个数字或者一个下划线(word)\W匹配一个字母、数字和下划线之外的字符<br>你这么聪明，肯定一眼就看出来，大写代表反义。对，就是这么好记。</p>
<h4 id="b元字符"><a href="#b元字符" class="headerlink" title="\b元字符"></a>\b元字符</h4><p><code>\b</code>匹配的也是一个位置，而不是一个字符。单词和空格之间的位置，就是所谓单词边界。</p>
<pre><code>&apos;hello regex&apos;.match(/\bregex$/);
// [&quot;regex&quot;, index: 6, input: &quot;hello regex&quot;, groups: undefined]&apos;hello regex&apos;.match(/\Bregex$/);
// null复制代码
</code></pre><p>所谓单词边界，对中文等其他语言是无效的。</p>
<pre><code>&apos;jiangshuying gaoyuanyuan huosiyan&apos;.match(/\bgaoyuanyuan\b/);
// [&quot;gaoyuanyuan&quot;, index: 13, input: &quot;jiangshuying gaoyuanyuan huosiyan&quot;, groups: undefined]&apos;江疏影 高圆圆 霍思燕&apos;.match(/\b高圆圆\b/);
// null复制代码
</code></pre><p>所以<code>\b</code>翻译一下就是<code>^\w|\w$|\W\w|\w\W</code>。</p>
<h4 id="d元字符"><a href="#d元字符" class="headerlink" title="\d元字符"></a>\d元字符</h4><p><code>\d</code>匹配一个数字，注意，这里的数字不是指JavaScript中的数字类型，因为文本全是字符串。它指的是代表数字的字符。</p>
<pre><code>&apos;123&apos;.match(/\d/);
// [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined]复制代码
</code></pre><h4 id="s元字符"><a href="#s元字符" class="headerlink" title="\s元字符"></a>\s元字符</h4><p><code>\s</code>匹配一个空白字符。</p>
<p>这里需要解释一下什么是空白字符。</p>
<p>空白字符不是空格，它是空格的超集。很多人说它是<code>\f\n\r\t\v</code>的总和，其中<code>\f</code>是换页符，<code>\n</code>是换行符，<code>\r</code>是回车符，<code>\t</code>是水平制表符，<code>\v</code>是垂直制表符。是这样么？</p>
<pre><code>&apos;a b&apos;.match(/\w\s\w/);
// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]&apos;a b&apos;.match(/\w\f\w/);
// null&apos;a b&apos;.match(/\w\n\w/);
// null&apos;a b&apos;.match(/\w\r\w/);
// null&apos;a b&apos;.match(/\w\t\w/);
// null&apos;a b&apos;.match(/\w\v\w/);
// null&apos;a b&apos;.match(/\w \w/);
// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]复制代码
</code></pre><p>这样说的人，明显是没有做过实验。其实正确的写法是<code>空格\f\n\r\t\v</code>的总和，集合里面包含一个空格，可千万别忽略了。诶，难道空格在正则中的写法就是<code>空一格</code>么，是的，就是这样随意。</p>
<p>这个集合中很多都是不可打印字符，估计只有<code>\n</code>是我们的老朋友。所以，如果不需要区分空格和换行的话，那就大胆的用<code>\s</code>吧。</p>
<h4 id="w元字符"><a href="#w元字符" class="headerlink" title="\w元字符"></a>\w元字符</h4><p><code>\w</code>匹配一个字母或者一个数字或者一个下划线。为什么要将它们放一起？想一想JavaScript中的变量规则，包括很多应用的用户名都只能是这三样，所以把它们放一起挺方便的。</p>
<p>不过要注意，字母指的是26个英文字母，其他的不行。</p>
<pre><code>&apos;正则&apos;.match(/\w/);
// null复制代码
</code></pre><h4 id="负阴抱阳"><a href="#负阴抱阳" class="headerlink" title="负阴抱阳"></a>负阴抱阳</h4><p>如果我们将大写和小写的带反斜杠的元字符组合在一起，就能匹配任何字符。是的，不针对任何人。</p>
<pre><code>&apos;@regex&apos;.match(/[\s\S]/);
// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码
</code></pre><p>方括号的含义我们先按下不表。</p>
<h2 id="道生一"><a href="#道生一" class="headerlink" title="道生一"></a>道生一</h2><p><code>.</code>在正则中的含义仙风道骨，它匹配换行符之外的任意单个字符。</p>
<p>如果文本不存在换行符，那么<code>.</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p>
<p>如果文本存在换行符，那么<code>(.|\n)</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p>
<pre><code>&apos;@regex&apos;.match(/./);
// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码
</code></pre><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>前面我们一直在强调，一个元字符只匹配一个字符。即便强大如<code>.</code>它也只能匹配一个。</p>
<p>那匹配<code>gooooogle</code>的正则是不是得写成<code>/gooooogle/</code>呢？</p>
<p>正则冷笑，并向你发射一个蔑视。</p>
<p>如果匹配的模式有重复，我们可以声明它重复的次数。<br>量词含义?重复零次或者一次+重复一次或者多次，也就是至少一次*重复零次或者多次，也就是任意次数{n}重复n次{n,}重复n次或者更多次{n,m}重复n次到m次之间的次数，包含n次和m次<br>有三点需要注意：</p>
<ul>
<li><p><code>?</code>在诸如匹配http协议的时候非常有用，就像这样：<code>/http(s)?/</code>。它在正则中除了是量词还有别的含义，后面会提到。</p>
</li>
<li><p>我们习惯用<code>/.*/</code>来匹配若干对我们没有价值的文本，它的含义是<code>若干除换行符之外的字符</code>。比如我们需要文本两头的格式化信息，中间是什么无所谓，它就派上用场了。不过它的性能可不好。</p>
</li>
<li><p><code>{n,m}</code>之间不能有空格，空格在正则中是有含义的。</p>
</li>
</ul>
<p>关于量词最令人困惑的是：它重复什么？</p>
<p>它重复紧贴在它前面的某个集合。第一点，必须是紧贴在它前面；第二点，重复一个集合。最常见的集合就是一个字符，当然正则中有一些元字符能够将若干字符变成一个集合，后面会讲到。</p>
<pre><code>&apos;gooooogle&apos;.match(/go{2,5}gle/);
// [&quot;gooooogle&quot;, index: 0, input: &quot;gooooogle&quot;, groups: undefined]复制代码
</code></pre><p>如果一个量词紧贴在另一个量词后面会怎样？</p>
<pre><code>&apos;gooooogle&apos;.match(/go{2,5}+gle/);
// Uncaught SyntaxError: Invalid regular expression: /go{2,5}+gle/: Nothing to repeat复制代码
</code></pre><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>前面提到量词不能紧跟在另一个量词后面，马上要👋👋打脸了。</p>
<pre><code>&apos;https&apos;.match(/http(s)?/);
// [&quot;https&quot;, &quot;s&quot;, index: 0, input: &quot;https&quot;, groups: undefined]&apos;https&apos;.match(/http(s)??/);
// [&quot;http&quot;, undefined, index: 0, input: &quot;https&quot;, groups: undefined]复制代码
</code></pre><p>然而，我的脸是这么好打的？</p>
<p>紧跟在<code>?</code>后面的<code>?</code>它不是一个量词，而是一个模式切换符，从贪婪模式切换到非贪婪模式。</p>
<p>贪婪模式在正则中是默认的模式，就是在既定规则之下匹配尽可能多的文本。因为正则中有量词，它的重复次数可能是一个区间，这就有了取舍。</p>
<p>紧跟在量词之后加上<code>?</code>就可以开启非贪婪模式。怎么省事怎么来。</p>
<p>这里的要点是，<code>?</code>必须紧跟着量词，否则的话它自己就变成量词了。</p>
<h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>正则中的普通字符只能匹配它自己。如果我要匹配一个普通字符，但是我不确定它是什么，怎么办？</p>
<pre><code>&apos;grey or gray&apos;.match(/gr[ae]y/);
// [&quot;grey&quot;, index: 0, input: &quot;grey or gray&quot;, groups: undefined]复制代码
</code></pre><p>方括号在正则中表示一个区间，我们称它为字符组。</p>
<p>首先，字符组中的字符集合只是所有的可选项，最终它只能匹配一个字符。</p>
<p>然后，字符组是一个独立的世界，元字符不需要转义。</p>
<pre><code>&apos;$&apos;.match(/[$&amp;@]/);
// [&quot;$&quot;, index: 0, input: &quot;$&quot;, groups: undefined]复制代码
</code></pre><p>最后，有两个字符在字符组中有特殊含义。</p>
<p><code>^</code>在字符组中表示取反，不再是文本开始的位置了。</p>
<pre><code>&apos;regex&apos;.match(/[^abc]/);
// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p>如果我就要<code>^</code>呢？前面已经讲过了，转义。</p>
<p><code>-</code>本来是一个普通字符，在字符组中摇身一变成为连字符。</p>
<pre><code>&apos;13&apos;.match(/[1-9]3/);
// [&quot;13&quot;, index: 0, input: &quot;13&quot;, groups: undefined]复制代码
</code></pre><p>连字符的意思是匹配范围在它的左边字符和右边字符之间。</p>
<p>如果我这样呢？</p>
<pre><code>&apos;abc-3&apos;.match(/[0-z]/);
// [&quot;a&quot;, index: 0, input: &quot;abc-3&quot;, groups: undefined]复制代码

&apos;xyz-3&apos;.match(/[0-c]/);
// [&quot;3&quot;, index: 4, input: &quot;xyz-3&quot;, groups: undefined]复制代码

&apos;xyz-3&apos;.match(/[0-$]/);
// Uncaught SyntaxError: Invalid regular expression: /[0-$]/: Range out of order in character class复制代码
</code></pre><p>发现什么了没有？只有两种字符是可以用连字符的：英文字母和数字。而且英文字母可以和数字连起来，英文字母的顺序在后面。这和扑克牌<code>1 2 3 4 5 6 7 8 9 10 J Q K</code>是一个道理。</p>
<h2 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h2><p>我们已经知道量词是怎么回事了，我们也知道量词只能重复紧贴在它前面的字符。</p>
<p>如果我要重复的是一串字符呢？</p>
<pre><code>&apos;i love you very very very much&apos;.match(/i love you very +much/);
// null&apos;i love you very very very much&apos;.match(/i love you v+e+r+y+ +much/);
// null复制代码
</code></pre><p>这样肯定是不行的。是时候请圆括号出山了。</p>
<pre><code>&apos;i love you very very very much&apos;.match(/i love you (very )+much/);
// [&quot;i love you very very very much&quot;, &quot;very &quot;, index: 0, input: &quot;i love you very very very much&quot;, groups: undefined]复制代码
</code></pre><p>圆括号的意思是将它其中的字符集合打包成一个整体，然后量词就可以操作这个整体了。这和方括号的效果是完全不一样的。</p>
<p>而且默认的，圆括号的匹配结果是可以捕获的。</p>
<h4 id="正则内捕获"><a href="#正则内捕获" class="headerlink" title="正则内捕获"></a>正则内捕获</h4><p>现在我们有一个需求，匹配<code>&lt;div&gt;</code>标签。</p>
<pre><code>&apos;&lt;div&gt;hello regex&lt;/div&gt;&apos;.match(/&lt;div&gt;.*&lt;\/div&gt;/);
// [&quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, index: 0, input: &quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, groups: undefined]复制代码
</code></pre><p>这很简单。但如果我要匹配的是任意标签，包括自定义的标签呢？</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;([a-zA-Z]+)&gt;.*&lt;\/\1&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: undefined]复制代码
</code></pre><p>这时候就要用到正则的捕获特性。正则内捕获使用<code>\数字</code>的形式，分别对应前面的圆括号捕获的内容。这种捕获的引用也叫<strong>反向引用</strong>。</p>
<p>我们来看一个更复杂的情况：</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&apos;.match(/&lt;((A|a)pp)&gt;(hello regex)+&lt;\/\1&gt;&lt;p&gt;\2&lt;\/p&gt;&lt;p&gt;\3&lt;\/p&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, &quot;App&quot;, &quot;A&quot;, &quot;hello regex&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, groups: undefined]复制代码
</code></pre><p>如果有嵌套的圆括号，那么捕获的引用是先递归的，然后才是下一个顶级捕获。</p>
<h4 id="正则外捕获"><a href="#正则外捕获" class="headerlink" title="正则外捕获"></a>正则外捕获</h4><pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]RegExp.$1;
// &quot;abc&quot;复制代码
</code></pre><p>没错，<code>RegExp</code>就是构造正则的构造函数。如果有捕获组，它的实例属性<code>$数字</code>会显示对应的引用。</p>
<p>如果有多个正则呢？</p>
<pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@xyz&apos;.match(/@(xyz)/);
// [&quot;@xyz&quot;, &quot;xyz&quot;, index: 0, input: &quot;@xyz&quot;, groups: undefined]RegExp.$1;
// &quot;xyz&quot;复制代码
</code></pre><p><code>RegExp</code>构造函数的引用只显示最后一个正则的捕获。</p>
<p>另外还有一个字符串实例方法也支持正则捕获的引用，它就是<code>replace</code>方法。</p>
<pre><code>&apos;hello **regex**&apos;.replace(/\*{2}(.*)\*{2}/, &apos;&lt;strong&gt;$1&lt;/strong&gt;&apos;);
// &quot;hello &lt;strong&gt;regex&lt;/strong&gt;&quot;复制代码
</code></pre><p>实际上它才是最常用的引用捕获的方式。</p>
<h4 id="捕获命名"><a href="#捕获命名" class="headerlink" title="捕获命名"></a>捕获命名</h4><blockquote>
<p>这是ES2018的新特性。</p>
</blockquote>
<p>使用<code>\数字</code>引用捕获必须保证捕获组的顺序不变。现在开发者可以给捕获组命名了，有了名字以后，引用起来更加确定。</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;(?&lt;tag&gt;[a-zA-Z]+)&gt;.*&lt;\/\k&lt;tag&gt;&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: {tag: &quot;App&quot;}]复制代码
</code></pre><p>在捕获组内部最前面加上<code>?&lt;key&gt;</code>，它就被命名了。使用<code>\k&lt;key&gt;</code>语法就可以引用已经命名的捕获组。</p>
<p>是不是很简单？</p>
<p>通常情况下，开发者只是想在正则中将某些字符当成一个整体看待。捕获组很棒，但是它做了额外的事情，肯定需要额外的内存占用和计算资源。于是正则又有了非捕获组的概念。</p>
<pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@abc&apos;.match(/@(?:abc)/);
// [&quot;@abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]复制代码
</code></pre><p>只要在圆括号内最前面加上<code>?:</code>标识，就是告诉正则引擎：我只要这个整体，不需要它的引用，你就别费劲了。从上面的例子也可以看出来，<code>match</code>方法返回的结果有些许不一样。</p>
<p>个人观点：我觉得正则的捕获设计应该反过来，默认不捕获，加上<code>?:</code>标识后才捕获。因为大多数时候开发者是不需要捕获的，但是它又懒得加<code>?:</code>标识，会有些许性能浪费。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>有时候开发者需要在正则中使用<code>或者</code>。</p>
<pre><code>&apos;高圆圆&apos;.match(/陈乔恩|高圆圆/);
// [&quot;高圆圆&quot;, index: 0, input: &quot;高圆圆&quot;, groups: undefined]复制代码
</code></pre><p><code>|</code>就代表<code>或者</code>。字符组其实也是一个多选结构，但是它们俩有本质区别。字符组最终只能匹配一个字符，而分支匹配的是左边所有的字符或者右边所有的字符。</p>
<p>我们来看一个例子：</p>
<pre><code>&apos;我喜欢高圆圆&apos;.match(/我喜欢陈乔恩|高圆圆/);
// [&quot;高圆圆&quot;, index: 3, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码
</code></pre><p>因为<code>|</code>是将左右两边一切两半，然后匹配左边或者右边。所以上面的正则显然达不到我们想要的效果。这个时候就需要一个东西来缩小分支的范围。诶，你可能已经想到了：</p>
<pre><code>&apos;我喜欢高圆圆&apos;.match(/我喜欢(?:陈乔恩|高圆圆)/);
// [&quot;我喜欢高圆圆&quot;, index: 0, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码
</code></pre><p>没错，就是圆括号。</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>正则中有一些元字符，它不匹配字符，而是匹配一个位置。比如之前提到的<code>^</code>和<code>$</code>。<code>^</code>的意思是说这个位置应该是文本开始的位置。</p>
<p>正则还有一些比较高级的匹配位置的语法，它匹配的是：在这个位置之前或之后应该有什么内容。</p>
<p>零宽(zero-width)是什么意思？指的就是它匹配一个位置，本身没有宽度。</p>
<p>断言(assertion)是什么意思？指的是一种判断，断言之前或之后应该有什么或应该没有什么。</p>
<h4 id="零宽肯定先行断言"><a href="#零宽肯定先行断言" class="headerlink" title="零宽肯定先行断言"></a>零宽肯定先行断言</h4><p>所谓的肯定就是判断有什么，而不是判断没有什么。</p>
<p>而先行指的是向前看(lookahead)，断言的这个位置是为前面的规则服务的。</p>
<p>语法很简单：圆括号内最左边加上<code>?=</code>标识。</p>
<pre><code>&apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)/);
// [&quot;Java&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码
</code></pre><p>上面匹配的是四个字母，这四个字母要满足以下条件：紧跟着的应该是<code>Script</code>字符串，而且<code>Script</code>字符串应该是单词的结尾部分。</p>
<p>所以，零宽肯定先行断言的意思是：现在有一段正则语法，用这段语法去匹配给定的文本。但是，满足条件的文本不仅要匹配这段语法，紧跟着它的必须是一个位置，这个位置又必须满足一段正则语法。</p>
<p>说的再直白点，我要匹配一段文本，但是这段文本后面必须紧跟着另一段特定的文本。零宽肯定先行断言就是一个界碑，我要满足前面和后面所有的条件，但是我只要前面的文本。</p>
<p>我们来看另一种情况：</p>
<pre><code>&apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)\w+/);
// [&quot;JavaScript&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码
</code></pre><p>上面的例子更加直观，零宽肯定先行断言已经匹配过<code>Script</code>一次了，后面的<code>\w+</code>却还是能匹配<code>Script</code>成功，足以说明它的<code>零宽</code>特性。它为紧贴在它前面的规则服务，并且不影响后面的匹配规则。</p>
<h4 id="零宽肯定后行断言"><a href="#零宽肯定后行断言" class="headerlink" title="零宽肯定后行断言"></a>零宽肯定后行断言</h4><p>先行是向前看，那后行就是向后看(lookbehind)咯。</p>
<p>语法是圆括号内最左边加上<code>?&lt;=</code>标识。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍\S+/);
// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><p>一个正则可以有多个断言：</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍.+?(?=\s|$)/);
// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><h4 id="零宽否定先行断言"><a href="#零宽否定先行断言" class="headerlink" title="零宽否定先行断言"></a>零宽否定先行断言</h4><p>肯定是判断有什么，否定就是判断没有什么咯。</p>
<p>语法是圆括号内最左边加上<code>?!</code>标识。</p>
<pre><code>&apos;TypeScript Perl JavaScript&apos;.match(/\b\w{4}(?!Script\b)/);
// [&quot;Perl&quot;, index: 11, input: &quot;TypeScript Perl JavaScript&quot;, groups: undefined]复制代码
</code></pre><h4 id="零宽否定后行断言"><a href="#零宽否定后行断言" class="headerlink" title="零宽否定后行断言"></a>零宽否定后行断言</h4><p>语法是圆括号最左边加上<code>?&lt;!</code>标识。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;!演员)霍\S+/);
// [&quot;霍去病&quot;, index: 8, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>正则表达式除了主体语法，还有若干可选的模式修饰符。</p>
<p>写法就是将修饰符安插在正则主体的尾巴上。比如这样：<code>/abc/gi</code>。</p>
<h4 id="g修饰符"><a href="#g修饰符" class="headerlink" title="g修饰符"></a>g修饰符</h4><p><code>g</code>是<code>global</code>的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。<code>g</code>修饰符会开启全局匹配模式，找到所有匹配的结果。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/);
// [&quot;高圆圆&quot;, index: 2, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/g);
// [&quot;高圆圆&quot;, &quot;霍思燕&quot;]复制代码
</code></pre><h4 id="i修饰符"><a href="#i修饰符" class="headerlink" title="i修饰符"></a>i修饰符</h4><p><code>i</code>是<code>ignoreCase</code>的缩写。默认情况下，<code>/z/</code>是无法匹配<code>Z</code>的，所以我们有时候不得不这样写：<code>/[a-zA-Z]/</code>。<code>i</code>修饰符可以全局忽略大小写。</p>
<p>很多时候我们不在乎文本是大写、小写还是大小写混写，这个修饰符还是很有用的。</p>
<pre><code>&apos;javascript is great&apos;.match(/JavaScript/);
// null&apos;javascript is great&apos;.match(/JavaScript/i);
// [&quot;javascript&quot;, index: 0, input: &quot;javascript is great&quot;, groups: undefined]复制代码
</code></pre><h4 id="m修饰符"><a href="#m修饰符" class="headerlink" title="m修饰符"></a>m修饰符</h4><p><code>m</code>是<code>multiline</code>的缩写。这个修饰符有特定起作用的场景：它要和<code>^</code>和<code>$</code>搭配起来使用。默认情况下，<code>^</code>和<code>$</code>匹配的是文本的开始和结束，加上<code>m</code>修饰符，它们的含义就变成了行的开始和结束。</p>
<pre><code>`
abc
xyz
`.match(/xyz/);
// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]`
abc
xyz
`.match(/^xyz$/);
// null`
abc
xyz
`.match(/^xyz$/m);
// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码
</code></pre><h4 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h4><blockquote>
<p>这是ES2015的新特性。</p>
</blockquote>
<p><code>y</code>是<code>sticky</code>的缩写。<code>y</code>修饰符有和<code>g</code>修饰符重合的功能，它们都是全局匹配。所以重点在<code>sticky</code>上，怎么理解这个<code>粘连</code>呢？</p>
<p><code>g</code>修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是<code>y</code>修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。</p>
<pre><code>&apos;a bag with a tag has a mag&apos;.match(/\wag/g);
// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]&apos;a bag with a tag has a mag&apos;.match(/\wag/y);
// null&apos;bagtagmag&apos;.match(/\wag/y);
// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]&apos;bagtagmag&apos;.match(/\wag/gy);
// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]复制代码
</code></pre><p>有人肯定发现了猫腻：你不是说<code>y</code>修饰符是全局匹配么？看上面的例子，单独一个<code>y</code>修饰符用match方法怎么并不是全局匹配呢？</p>
<p>诶，这里说来就话长了。</p>
<p>长话短说呢，就涉及到<code>y</code>修饰符的本质是什么。它的本质有二：</p>
<ul>
<li>全局匹配(先别着急打我)。</li>
<li>从文本的<code>lastIndex</code>位置开始新的匹配。lastIndex是什么？它是正则表达式的一个属性，如果是全局匹配，它用来标注下一次匹配的起始点。这才是粘连的本质所在。</li>
</ul>
<p>不知道你们发现什么了没有：<strong>lastIndex是正则表达式的一个属性</strong>。而上面例子中的match方法是作用在字符串上的，都没有lastIndex属性，休怪人家工作不上心。</p>
<pre><code>const reg = /\wag/y;
reg.exec(&apos;bagtagmag&apos;);
// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]
reg.exec(&apos;bagtagmag&apos;);
// [&quot;tag&quot;, index: 3, input: &quot;bagtagmag&quot;, groups: undefined]
reg.exec(&apos;bagtagmag&apos;);
// [&quot;mag&quot;, index: 6, input: &quot;bagtagmag&quot;, groups: undefined]复制代码
</code></pre><p>咱们换成正则方法exec，多次执行，正则的lastIndex在变，匹配的结果也在变。全局匹配无疑了吧。</p>
<h4 id="s修饰符"><a href="#s修饰符" class="headerlink" title="s修饰符"></a>s修饰符</h4><blockquote>
<p>这是ES2018的新特性。</p>
</blockquote>
<p><code>s</code>不是<code>dotAll</code>的缩写。<code>s</code>修饰符要和<code>.</code>搭配使用，默认情况下，<code>.</code>匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。</p>
<p><code>s</code>修饰符的作用就是让<code>.</code>可以匹配任意单个字符。</p>
<p><code>s</code>是<code>singleline</code>的缩写。</p>
<pre><code>`
abc
xyz
`.match(/c.x/);
// null`
abc
xyz
`.match(/c.x/s);
// [&quot;c↵x&quot;, index: 3, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码
</code></pre><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><blockquote>
<p>这是ES2015的新特性。</p>
</blockquote>
<p><code>u</code>是<code>unicode</code>的缩写。有一些Unicode字符超过一个字节，正则就无法正确的识别它们。<code>u</code>修饰符就是用来处理这些不常见的情况的。</p>
<pre><code>&apos;𠮷&apos;.match(/^.$/);
// null&apos;𠮷&apos;.match(/^.$/u);
// [&quot;𠮷&quot;, index: 0, input: &quot;𠮷&quot;, groups: undefined]复制代码
</code></pre><p><code>𠮷</code>念<code>jí</code>，与<code>吉</code>同义。</p>
<p>笔者对Unicode认识尚浅，这里不过多展开。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/16/前端代码异常监控实战/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/16/前端代码异常监控实战/" itemprop="url">前端代码异常监控实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-16T11:22:33+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="把前端监控做到极致-掘金"><a href="#把前端监控做到极致-掘金" class="headerlink" title="把前端监控做到极致 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a52f138f265da3e5b32a41b" target="_blank" rel="noopener">把前端监控做到极致 - 掘金</a></h2><h2 id="线上压缩代码-定位错误-掘金"><a href="#线上压缩代码-定位错误-掘金" class="headerlink" title="线上压缩代码-定位错误 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a4f6886518825734216b352" target="_blank" rel="noopener">线上压缩代码-定位错误 - 掘金</a></h2><p>生产环境没有source-map文件，上报的错误都不好定位，这里实现一个简单的错误定位脚本</p>
<p>1、获取压缩代码错误信息（行数、列数、错误信息，错误文件）</p>
<h2 id="这里通过控制台看错误信息"><a href="#这里通过控制台看错误信息" class="headerlink" title="这里通过控制台看错误信息"></a>这里通过控制台看错误信息</h2><pre><code>window.addEventListener(&apos;error&apos;, function (e) {
    console.debug(&apos;lineno: &apos;, e.lineno, &apos; colno: &apos;, e.colno)
    console.debug(&apos;errorMessage:&apos;, e.message)
    console.debug(&apos;errorFile:&apos;, e.filename)
}, true)
</code></pre><p>我们写一段错误的代码（single.vue的片段）</p>
<pre><code>method: {
   test (option) {
        const data = option.test
        const dataTest = option.data.test
        return data + dataTest
    }
}, 
created () {
    // 设置异步错误的原因是，同步的错误会被vue捕获
    setTimeout(() =&gt; {
        this.test({
          testOption: 1
        })
    }, 300)
}
</code></pre><p>在浏览器中运行，报错结果如下<br><img src="https://pic4.zhimg.com/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_hd.jpg" alt=""></p>
<p>得到错误信息：</p>
<ul>
<li>错误行数：1</li>
<li>错误列数：59236</li>
<li>错误信息：cannot read property ‘test’ of undefined</li>
<li>错误文件：0.0a77f.js</li>
</ul>
<p>2、定位错误的node脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## 安装依赖source-map</span><br><span class="line"></span><br><span class="line"> npm install source-map</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    node脚本如下（map/index.js）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> // 读取文件</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">// souceMap处理文件</span><br><span class="line">var SourceMapConsumer = require(&apos;source-map&apos;).SourceMapConsumer</span><br><span class="line">// 启动构建进程（已构建则不需要）</span><br><span class="line">var exec = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">var lineno = process.argv[2] || 0   // 第一个参数为行数</span><br><span class="line">var columnno = process.argv[3] || 0 // 第二个参数为列数</span><br><span class="line">var fileName = process.argv[4] || &apos;&apos; // 第三个参数为错误文件（错误文件名就好）</span><br><span class="line"></span><br><span class="line">// 构建有map的线上代码</span><br><span class="line">// node build onlineMap为构建命令</span><br><span class="line">exec(&apos;node build onlineMap&apos;, function () &#123;</span><br><span class="line"> // 读取错误文件的map文件</span><br><span class="line"> var consumer = new SourceMapConsumer(fs.readFileSync(&apos;./dist/&apos; + fileName + &apos;.map&apos;, &apos;utf8&apos;))</span><br><span class="line">  // 输出map的错误信息</span><br><span class="line">  console.log(consumer.originalPositionFor(&#123;</span><br><span class="line">    line: +lineno,      // +是为了转化为数字</span><br><span class="line">    column: +columnno</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">    运行node脚本</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> node map 1 59236 0.0a77f.js</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>效果如下：</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/v2-cf68e7b673405c90fe024bf48dfb42c7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf68e7b673405c90fe024bf48dfb42c7_hd.jpg" alt=""></p>
<p>结合控制台输出的信息，就可以定位到错误代码了</p>
<p>我们再来看一下，给代码开启source-map，看错误信息是否一致</p>
<p><img src="https://pic3.zhimg.com/v2-5319b431cef161a0a07ba46f8b0e6a02_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-5319b431cef161a0a07ba46f8b0e6a02_hd.jpg" alt=""><br>错误代码的位置定位是准确的，证明可行。</p>
<p>3、后续扩展思路</p>
<h2 id="目前实现的是比较简单的脚本，所以存在一些问题："><a href="#目前实现的是比较简单的脚本，所以存在一些问题：" class="headerlink" title="目前实现的是比较简单的脚本，所以存在一些问题："></a>目前实现的是比较简单的脚本，所以存在一些问题：</h2><ul>
<li>需要当前构建内容和线上是一致的</li>
<li>操作比较繁琐</li>
</ul>
<p>优化思路如下：</p>
<p><img src="https://pic4.zhimg.com/v2-a8b63ecc364c66c8bf4bbec9880f8c23_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a8b63ecc364c66c8bf4bbec9880f8c23_hd.jpg" alt=""></p>
<p>后续优化慢慢补充~</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在对公司的前端代码脚本错误进行排查，试图降低 JS Error 的错误量，结合自己之前的经验对这方面内容进行了实践并总结，下面就此谈谈我对前端代码异常监控的一些见解。</p>
<p>本文大致围绕下面几点展开讨论：</p>
<ol>
<li>JS 处理异常的方式</li>
<li>上报方式</li>
<li>异常监控上报常见问题</li>
</ol>
<h2 id="JS-异常处理"><a href="#JS-异常处理" class="headerlink" title="JS 异常处理"></a>JS 异常处理</h2><p>对于 Javascript 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>
<ol>
<li>当前代码块将作为一个任务压入任务队列中，JS 线程会不断地从任务队列中提取任务执行。</li>
<li>当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务的执行。</li>
<li><p>JS 线程会继续从任务队列中提取下一个任务继续执行。</p>
 <script>
   error
   console.log('永远不会执行');
 </script>
 <script>
   console.log('我继续执行')
 </script>


</li>
</ol>
<p><img src="https://pic2.zhimg.com/v2-7a136ce7674914bcd7b7f42986d0c5bc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7a136ce7674914bcd7b7f42986d0c5bc_hd.jpg" alt=""></p>
<p>在对脚本错误进行上报之前，我们需要对异常进行处理，程序需要先感知到脚本错误的发生，然后再谈异常上报。</p>
<p>脚本错误一般分为两种：语法错误，运行时错误。</p>
<p>下面就谈谈几种异常监控的处理方式：</p>
<h2 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h2><p>try-catch 在我们的代码中经常见到，通过给代码块进行 try-catch 进行包装后，当代码块发生出错时 catch 将能捕捉到错误的信息，页面也将可以继续执行。</p>
<p>但是 try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误和异步错误就显得无能为力，捕捉不到。</p>
<h2 id="示例：运行时错误"><a href="#示例：运行时错误" class="headerlink" title="示例：运行时错误"></a>示例：运行时错误</h2><pre><code>try {
  error    // 未定义变量 
} catch(e) {
  console.log(&apos;我知道错误了&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-dc8ba7e4b9e56127799c11b46cf7068d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-dc8ba7e4b9e56127799c11b46cf7068d_hd.jpg" alt=""></p>
<p>然而对于语法错误和异步错误就捕捉不到了。</p>
<h2 id="示例：语法错误"><a href="#示例：语法错误" class="headerlink" title="示例：语法错误"></a>示例：语法错误</h2><pre><code>try {
  var error = &apos;error&apos;；   // 大写分号
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-8ddf6acf0f42c4b08ba8b73798b863a0_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8ddf6acf0f42c4b08ba8b73798b863a0_hd.jpg" alt=""></p>
<p>一般语法错误在编辑器就会体现出来，常表现的错误信息为： Uncaught SyntaxError: Invalid or unexpected token xxx 这样。但是这种错误会直接抛出异常，常使程序崩溃，一般在编码时候容易观察得到。</p>
<h2 id="示例：异步错误"><a href="#示例：异步错误" class="headerlink" title="示例：异步错误"></a>示例：异步错误</h2><pre><code>try {
  setTimeout(() =&gt; {
    error        // 异步错误
  })
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic4.zhimg.com/v2-0ed67a00e3c7762e74975bebbbc88274_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-0ed67a00e3c7762e74975bebbbc88274_hd.jpg" alt=""></p>
<p>除非你在 setTimeout 函数中再套上一层 try-catch，否则就无法感知到其错误，但这样代码写起来比较啰嗦。</p>
<h2 id="window-onerror-异常处理"><a href="#window-onerror-异常处理" class="headerlink" title="window.onerror 异常处理"></a>window.onerror 异常处理</h2><p>window.onerror 捕获异常能力比 try-catch 稍微强点，无论是异步还是非异步错误，onerror 都能捕获到运行时错误。</p>
<p>示例：运行时同步错误</p>
<pre><code>/**
 * @param {String}  msg    错误信息
 * @param {String}  url    出错文件
 * @param {Number}  row    行号
 * @param {Number}  col    列号
 * @param {Object}  error  错误详细信息
 */
 window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
error;
</code></pre><p>示例：异步错误</p>
<pre><code>window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道异步错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
setTimeout(() =&gt; {
  error;
});
</code></pre><p><img src="https://pic3.zhimg.com/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_hd.jpg" alt=""></p>
<p>然而 window.onerror 对于语法错误还是无能为力，所以我们在写代码的时候要尽可能避免语法错误的，不过一般这样的错误会使得整个页面崩溃，还是比较容易能够察觉到的。</p>
<p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>
<p>需要注意的是，window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。</p>
<p><img src="https://pic3.zhimg.com/v2-875235a4876ea8429f12e7aaf2f19588_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-875235a4876ea8429f12e7aaf2f19588_hd.jpg" alt=""></p>
<p>关于 window.onerror 还有两点需要值得注意</p>
<ol>
<li>对于 onerror 这种全局捕获，最好写在所有 JS 脚本的前面，因为你无法保证你写的代码是否出错，如果写在后面，一旦发生错误的话是不会被 onerror 捕获到的。</li>
<li>另外 onerror 是无法捕获到网络异常的错误。</li>
</ol>
<p>当我们遇到 <code>&lt;img src=&quot;./404.png&quot;&gt;</code> 报 404 网络请求异常的时候，onerror 是无法帮助我们捕获到异常的。</p>
<pre><code>&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道异步错误了&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot;&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-81341c443f078b6526e0c6031dd40953_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81341c443f078b6526e0c6031dd40953_hd.jpg" alt=""></p>
<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>
<pre><code>&lt;script&gt;
window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我知道 404 错误了&apos;);
  console.log(
    msg, url, row, col, error
  );
  return true;
}, true);
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot; alt=&quot;&quot;&gt;
</code></pre><p><img src="https://pic4.zhimg.com/v2-6d1c1196acd800a4a4475ee6847ee82a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6d1c1196acd800a4a4475ee6847ee82a_hd.jpg" alt=""></p>
<p>这点知识还是需要知道，要不然用户访问网站，图片 CDN 无法服务，图片加载不出来而开发人员没有察觉就尴尬了。</p>
<h2 id="Promise-错误"><a href="#Promise-错误" class="headerlink" title="Promise 错误"></a>Promise 错误</h2><p>通过 Promise 可以帮助我们解决异步回调地狱的问题，但是一旦 Promise 实例抛出异常而你没有用 catch 去捕获的话，onerror 或 try-catch 也无能为力，无法捕捉到错误。</p>
<pre><code>window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我感知不到 promise 错误&apos;);
  console.log(
    msg, url, row, col, error
  );
}, true);
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic4.zhimg.com/v2-1ce580bb2344474b1df1517f2d11aa40_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-1ce580bb2344474b1df1517f2d11aa40_hd.jpg" alt=""></p>
<p>虽然在写 Promise 实例的时候养成最后写上 catch 函数是个好习惯，但是代码写多了就容易糊涂，忘记写 catch。</p>
<p>所以如果你的应用用到很多的 Promise 实例的话，特别是你在一些基于 promise 的异步库比如 axios 等一定要小心，因为你不知道什么时候这些异步请求会抛出异常而你并没有处理它，所以你最好添加一个 Promise 全局异常捕获事件 <strong>unhandledrejection</strong>。</p>
<pre><code>window.addEventListener(&quot;unhandledrejection&quot;, function(e){
  e.preventDefault()
  console.log(&apos;我知道 promise 的错误了&apos;);
  console.log(e.reason);
  return true;
});
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic2.zhimg.com/v2-115d494f26e4f8e2172e1f3b4cb6094f_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-115d494f26e4f8e2172e1f3b4cb6094f_hd.jpg" alt=""></p>
<p>当然，如果你的应用没有做 Promise 全局异常处理的话，那很可能就像某乎首页这样：</p>
<p><img src="https://pic2.zhimg.com/v2-37c6bc3763c147a4c97bdde688a59a5c_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-37c6bc3763c147a4c97bdde688a59a5c_hd.jpg" alt=""></p>
<h2 id="异常上报方式"><a href="#异常上报方式" class="headerlink" title="异常上报方式"></a>异常上报方式</h2><p>监控拿到报错信息之后，接下来就需要将捕捉到的错误信息发送到信息收集平台上，常用的发送形式主要有两种:</p>
<ol>
<li>通过 Ajax 发送数据</li>
<li>动态创建 img 标签的形式</li>
</ol>
<p>实例 - 动态创建 img 标签进行上报</p>
<pre><code>function report(error) {
  var reportUrl = &apos;http://xxxx/report&apos;;
  new Image().src = reportUrl + &apos;error=&apos; + error;
}
</code></pre><h2 id="监控上报常见问题"><a href="#监控上报常见问题" class="headerlink" title="监控上报常见问题"></a>监控上报常见问题</h2><p>下述例子我全部放在我的 github 上，读者可以自行查阅，后面不再赘述。</p>
<pre><code>git clone https://github.com/happylindz/blog.git
cd blog/code/jserror/
npm install
</code></pre><h2 id="Script-error-脚本错误是什么"><a href="#Script-error-脚本错误是什么" class="headerlink" title="Script error 脚本错误是什么"></a>Script error 脚本错误是什么</h2><p>因为我们在线上的版本，经常做静态资源 CDN 化，这就会导致我们常访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。</p>
<p><img src="https://pic3.zhimg.com/v2-840f71bf7014767132b47ad2c6a37238_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-840f71bf7014767132b47ad2c6a37238_hd.jpg" alt=""></p>
<p>可通过 <code>npm run nocors</code> 查看效果。</p>
<p>Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。</p>
<p><img src="https://pic2.zhimg.com/v2-fc3941d89716f96374576d0426ff4ccb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-fc3941d89716f96374576d0426ff4ccb_hd.jpg" alt=""></p>
<p>这样做的目的是避免数据泄露到不安全的域中，举个简单的例子，</p>
<pre><code>&lt;script src=&quot;xxxx.com/login.html&quot;&gt;&lt;/script&gt;
</code></pre><p>上面我们并没有引入一个 js 文件，而是一个 html，这个 html 是银行的登录页面，如果你已经登录了，那 login 页面就会自动跳转到 <code>Welcome xxx...</code>，如果未登录则跳转到 <code>Please Login...</code>，那么报错也会是 <code>Welcome xxx... is not defined，Please Login... is not defined</code>，通过这些信息可以判断一个用户是否登录他的帐号，给入侵者提供了十分便利的判断渠道，这是相当不安全的。</p>
<p>介绍完背景后，那么我们应该去解决这个问题？</p>
<p>首先可以想到的方案肯定是同源化策略，将 JS 文件内联到 html 或者放到同域下，虽然能简单有效地解决 script error 问题，但是这样无法利用好文件缓存和 CDN 的优势，不推荐使用。正确的方法应该是从根本上解决 script error 的错误。</p>
<h2 id="跨源资源共享机制-CORS"><a href="#跨源资源共享机制-CORS" class="headerlink" title="跨源资源共享机制( CORS )"></a>跨源资源共享机制( CORS )</h2><p>首先为页面上的 script 标签添加 crossOrigin 属性</p>
<pre><code>// http://localhost:8080/index.html
&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;script src=&quot;http://localhost:8081/test.js&quot; crossorigin&gt;&lt;/script&gt;

// http://localhost:8081/test.js
setTimeout(() =&gt; {
  console.log(error);
});
</code></pre><p>当你修改完前端代码后，你还需要额外给后端在响应头里加上 <code>Access-Control-Allow-Origin: localhost:8080</code>，这里我以 Koa 为例。</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const path = require(&apos;path&apos;);
const cors = require(&apos;koa-cors&apos;);
const app = new Koa();

app.use(cors());
app.use(require(&apos;koa-static&apos;)(path.resolve(__dirname, &apos;./public&apos;)));

app.listen(8081, () =&gt; {
  console.log(&apos;koa app listening at 8081&apos;)
});
</code></pre><p><img src="https://pic1.zhimg.com/v2-9717062e56340cef40ee67b438b2ba95_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-9717062e56340cef40ee67b438b2ba95_hd.jpg" alt=""></p>
<p>读者可通过 <code>npm run cors</code> 详细的跨域知识我就不展开了，有兴趣可以看看我之前写的文章：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>你以为这样就完了吗？并没有，下面就说一些 Script error 你不常遇见的点：</p>
<p>我们都知道 JSONP 是用来跨域获取数据的，并且兼容性良好，在一些应用中仍然会使用到，所以你的项目中可能会用这样的代码：</p>
<pre><code>// http://localhost:8080/index.html
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，但不知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
function jsonpCallback(data) {
  console.log(data);
}
const url = &apos;http://localhost:8081/data?callback=jsonpCallback&apos;;
const script = document.createElement(&apos;script&apos;);
script.src = url;
document.body.appendChild(script);
</code></pre><p>因为返回的信息会当做脚本文件来执行，一旦返回的脚本内容出错了，也是无法捕捉到错误的信息。</p>
<p><img src="https://pic4.zhimg.com/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_hd.jpg" alt=""></p>
<p>解决办法也不难，跟之前一样，在添加动态添加脚本的时候加上 crossOrigin，并且在后端配上相应的 CORS 字段即可.</p>
<pre><code>const script = document.createElement(&apos;script&apos;);
script.crossOrigin = &apos;anonymous&apos;;
script.src = url;
document.body.appendChild(script);
</code></pre><p>读者可以通过 <code>npm run jsonp</code> 查看效果</p>
<p><img src="https://pic4.zhimg.com/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_hd.jpg" alt=""></p>
<p>知道原理之后你可能会觉得没什么，不就是给每个动态生成的脚本添加 crossOrigin 字段嘛，但是在实际工程中，你可能是面向很多库来编程，比如使用 jQuery，Seajs 或者 webpack 来异步加载脚本，许多库封装了异步加载脚本的能力，以 jQeury 为例你可能是这样来触发异步脚本。</p>
<pre><code>$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>假如这些库中没有提供 crossOrigin 的能力的话(jQuery jsonp 可能有，假装你不知道)，那你只能去修改人家写的源代码了，所以我这里提供一个思路，就是去劫持 document.createElement，从根源上去为每个动态生成的脚本添加 crossOrigin 字段。</p>
<pre><code>document.createElement = (function() {
  const fn = document.createElement.bind(document);
  return function(type) {
    const result = fn(type);
    if(type === &apos;script&apos;) {
      result.crossOrigin = &apos;anonymous&apos;;
    }
    return result;
  }
})();
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，也知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>效果也是一样的，读者可以通过 <code>npm run jsonpjq</code> 来查看效果：</p>
<p><img src="https://pic4.zhimg.com/v2-30d51a96cdb3286edd1e5a88e9f794bb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-30d51a96cdb3286edd1e5a88e9f794bb_hd.jpg" alt=""></p>
<p>这样重写 createElement 理论上没什么问题，但是入侵了原本的代码，不保证一定不会出错，在工程上还是需要多尝试下看看再使用，可能存在兼容性上问题，如果你觉得会出现什么问题的话也欢迎留言讨论下。</p>
<p>关于 Script error 的问题就写到这里，如果你理解了上面的内容，基本上绝大部分的 Script error 都能迎刃而解。</p>
<h2 id="window-onerror-能否捕获-iframe-的错误"><a href="#window-onerror-能否捕获-iframe-的错误" class="headerlink" title="window.onerror 能否捕获 iframe 的错误"></a>window.onerror 能否捕获 iframe 的错误</h2><p>当你的页面有使用 iframe 的时候，你需要对你引入的 iframe 做异常监控的处理，否则一旦你引入的 iframe 页面出现了问题，你的主站显示不出来，而你却浑然不知。</p>
<p>首先需要强调，父窗口直接使用 window.onerror 是无法直接捕获，如果你想要捕获 iframe 的异常的话，有分好几种情况。</p>
<p>如果你的 iframe 页面和你的主站是同域名的话，直接给 iframe 添加 onerror 事件即可。</p>
<pre><code>&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  window.frames[0].onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道 iframe 的错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
</code></pre><p>读者可以通过 <code>npm run iframe</code> 查看效果：</p>
<p><img src="https://pic2.zhimg.com/v2-3edcb5686e27ab11f5f3c9c1644986d0_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3edcb5686e27ab11f5f3c9c1644986d0_hd.jpg" alt=""></p>
<p>如果你嵌入的 iframe 页面和你的主站不是同个域名的，但是 iframe 内容不属于第三方，是你可以控制的，那么可以通过与 iframe 通信的方式将异常信息抛给主站接收。与 iframe 通信的方式有很多，常用的如：postMessage，hash 或者 name 字段跨域等等，这里就不展开了，感兴趣的话可以看：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>如果是非同域且网站不受自己控制的话，除了通过控制台看到详细的错误信息外，没办法捕获，这是出于安全性的考虑，你引入了一个百度首页，人家页面报出的错误凭啥让你去监控呢，这会引出很多安全性的问题。</p>
<h2 id="压缩代码如何定位到脚本异常位置"><a href="#压缩代码如何定位到脚本异常位置" class="headerlink" title="压缩代码如何定位到脚本异常位置"></a>压缩代码如何定位到脚本异常位置</h2><p>线上的代码几乎都经过了压缩处理，几十个文件打包成了一个并丑化代码，当我们收到 <code>a is not defined</code> 的时候，我们根本不知道这个变量 a 究竟是什么含义，此时报错的错误日志显然是无效的。</p>
<p>第一想到的办法是利用 sourcemap 定位到错误代码的具体位置，详细内容可以参考：<a href="https://link.zhihu.com/?target=https%3A//github.com/joeyguo/blog/issues/14" target="_blank" rel="noopener">Sourcemap 定位脚本错误</a></p>
<p>另外也可以通过在打包的时候，在每个合并的文件之间添加几行空格，并相应加上一些注释，这样在定位问题的时候很容易可以知道是哪个文件报的错误，然后再通过一些关键词的搜索，可以快速地定位到问题的所在位置。</p>
<h2 id="收集异常信息量太多，怎么办"><a href="#收集异常信息量太多，怎么办" class="headerlink" title="收集异常信息量太多，怎么办"></a>收集异常信息量太多，怎么办</h2><p>如果你的网站访问量很大，假如网页的 PV 有 1kw，那么一个必然的错误发送的信息就有 1kw 条，我们可以给网站设置一个采集率：</p>
<pre><code>Reporter.send = function(data) {
  // 只采集 30%
  if(Math.random() &lt; 0.3) {
    send(data)      // 上报错误信息
  }
}
</code></pre><p>这个采集率可以通过具体实际的情况来设定，方法多样化，可以使用一个随机数，也可以具体根据用户的某些特征来进行判定。</p>
<h3 id="错误上报的方法："><a href="#错误上报的方法：" class="headerlink" title="错误上报的方法："></a>错误上报的方法：</h3><ul>
<li>一：Ajax上传，Ajax上报就是在上文注释错误捕获的地方发起Ajax请求，来向服务器发送错误信息。</li>
<li>二：利用Image对象发送信息(new Image()).src=”<a href="http://post.error.com?data=xxx&quot;" target="_blank" rel="noopener">http://post.error.com?data=xxx&quot;</a></li>
<li>跨域js文件错误是否可以捕获：<br>   答案是可以，错误提示是   script error<br>解决办法，跨域js文件获取是有限制的，如果想获取其他域下的js错误需要在script标签里添加crossorigin属性，然后服务器端要设置header(‘Access-Control-Allow-Origin: *’),或者 指定域名。</li>
</ul>
<p>上面差不多是我对前端代码监控的一些理解，说起来容易，但是一旦在工程化运用，难免需要考虑到兼容性等种种问题，读者可以通过自己的具体情况进行调整，前端代码异常监控对于我们的网站的稳定性起着至关重要的作用。如若文中所有不对的地方，还望指正。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/14/JavaScript函数柯里化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/14/JavaScript函数柯里化/" itemprop="url">JavaScript函数柯里化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-14T20:00:52+08:00">
                2016-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h2><h2 id="官方的说法"><a href="#官方的说法" class="headerlink" title="官方的说法"></a>官方的说法</h2><p>在计算机科学中，<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%259F%25AF%25E9%2587%258C%25E5%258C%2596" target="_blank" rel="noopener">柯里化</a>（英语：<code>Currying</code>），又译为<code>卡瑞化</code>或<code>加里化</code>，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由<code>克里斯托弗·斯特雷奇</code>以逻辑学家<code>哈斯凯尔·加里</code>命名的，尽管它是<code>Moses Schönfinkel</code>和<code>戈特洛布·弗雷格发明的</code>。</p>
<p>在直觉上，柯里化声称如果你固定某些参数，你将得到接受余下参数的一个函数。</p>
<p>在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的<code>lambda</code>演算中，研究带有多个参数的函数的方式。</p>
<p>函数柯里化的对偶是<code>Uncurrying</code>，一种使用匿名单参数函数来实现多参数函数的方法。</p>
<h2 id="方便的理解"><a href="#方便的理解" class="headerlink" title="方便的理解"></a>方便的理解</h2><blockquote>
<p>Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
</blockquote>
<p>如果我们需要实现一个求三个数之和的函数：</p>
<pre><code>function add(x, y, z) {
  return x + y + z;
}
console.log(add(1, 2, 3)); // 6
var add = function(x) {
  return function(y) {
    return function(z) {
      return x + y + z;
    }
  }
}

var addOne = add(1);
var addOneAndTwo = addOne(2);
var addOneAndTwoAndThree = addOneAndTwo(3);

console.log(addOneAndTwoAndThree);
</code></pre><p>这里我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的<code>curry</code>帮助函数（<code>helper function</code>）使这类函数的定义和调用更加容易。</p>
<p>用<code>ES6</code>的箭头函数，我们可以将上面的<code>add</code>实现成这样：</p>
<pre><code>const add = x =&gt; y =&gt; z =&gt; x + y + z;
</code></pre><p>好像使用箭头函数更清晰了许多。</p>
<h2 id="偏函数？"><a href="#偏函数？" class="headerlink" title="偏函数？"></a>偏函数？</h2><p>来看这个函数：</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}
</code></pre><p>有这样的一个场景：我们需要对多个不同的接口发起<code>HTTP</code>请求，有下列两种做法：</p>
<ul>
<li>在调用<code>ajax()</code>函数时，传入全局<code>URL</code>常量。</li>
<li>创建一个已经预设<code>URL</code>实参的函数引用。</li>
</ul>
<p>下面我们创建一个新函数，其内部仍然发起<code>ajax()</code>请求，此外在等待接收另外两个实参的同时，我们手动将<code>ajax()</code>第一个实参设置成你关心的<code>API</code>地址。</p>
<p>对于第一种做法，我们可能产生如下调用方式：</p>
<pre><code>function ajaxTest1(data, callback) {
  ajax(&apos;http://www.test.com/test1&apos;, data, callback);
}

function ajaxTest2(data, callback) {
  ajax(&apos;http://www.test.com/test2&apos;, data, callback);
}
</code></pre><p>对于这两个类似的函数，我们还可以提取出如下的模式：</p>
<pre><code>function beginTest(callback) {
  ajaxTest1({
    data: GLOBAL_TEST_1,
  }, callback);
}
</code></pre><p>相信您已经看到了这样的模式：我们在函数调用现场（<code>function call-site</code>），将实参应用（<code>apply</code>） 于形参。如你所见，我们一开始仅应用了部分实参 —— 具体是将实参应用到<code>URL</code>形参 —— 剩下的实参稍后再应用。</p>
<p>上述概念即为偏函数的定义，偏函数一个减少函数参数个数的过程；这里的参数个数指的是希望传入的形参的数量。我们通过<code>ajaxTest1()</code>把原函数<code>ajax()</code>的参数个数从<code>3</code>个减少到了<code>2</code>个。</p>
<p>我们这样定义一个<code>partial()</code>函数：</p>
<pre><code>function partial(fn, ...presetArgs) {
  return function partiallyApplied(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  }
}
</code></pre><p><code>partial()</code>函数接收<code>fn</code>参数，来表示被我们偏应用实参（<code>partially apply</code>）的函数。接着，<code>fn</code>形参之后，<code>presetArgs</code>数组收集了后面传入的实参，保存起来稍后使用。</p>
<p>我们创建并<code>return</code>了一个新的内部函数（为了清晰明了，我们把它命名为<code>partiallyApplied(..)</code>），该函数中，<code>laterArgs</code>数组收集了全部实参。</p>
<p>使用箭头函数，则更为简洁：</p>
<pre><code>var partial =
  (fn, ...presetArgs) =&gt;
    (...laterArgs) =&gt;
      fn(...presetArgs, ...laterArgs);
</code></pre><p>使用偏函数的这种模式，我们重构之前的代码：</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}

var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);
var ajaxTest2 = partial(ajax, &apos;http://www.test.com/test1&apos;);
</code></pre><p>再次思考<code>beginTest()</code>函数，我们使用<code>partial()</code>来重构它应该怎么做呢？</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}

// 版本1
var beginTest = partial(ajax, &apos;http://www.test.com/test1&apos;, {
  data: GLOBAL_TEST_1,
});

// 版本2
var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);
var beginTest = partial(ajaxTest1, {
  data: GLOBAL_TEST_1,
});
</code></pre><h2 id="一次传一个"><a href="#一次传一个" class="headerlink" title="一次传一个"></a>一次传一个</h2><p>相信你已经在上述例子中看到了版本2比起版本1的优势所在了，没错，柯里化就是：将一个带有多个参数的函数转换为一次一个的函数的过程。每次调用函数时，它只接受一个参数，并返回一个函数，直到传递所有参数为止。</p>
<blockquote>
<p>The process of converting a function that takes multiple arguments into a function that takes them one at a time.</p>
<p>Each time the function is called it only accepts one argument and returns a function that takes one argument until all arguments are passed.</p>
</blockquote>
<p>假设我们已经创建了一个柯里化版本的<code>ajax()</code>函数<code>curriedAjax()</code>：</p>
<pre><code>curriedAjax(&apos;http://www.test.com/test1&apos;)
  ({
    data: GLOBAL_TEST_1,
  })
  (function callback(data) {
    // dosomething
  });
</code></pre><p>我们将三次调用分别拆解开来，这也许有助于我们理解整个过程：</p>
<pre><code>var ajaxTest1 = curriedAjax(&apos;http://www.test.com/test1&apos;);

var beginTest = ajaxTest1({
  data: GLOBAL_TEST_1,
});

var ajaxCallback = beginTest(function callback(data) {
  // dosomething
});
</code></pre><h2 id="实现柯里化"><a href="#实现柯里化" class="headerlink" title="实现柯里化"></a>实现柯里化</h2><p>那么，我们如何来实现一个自动的柯里化的函数呢？</p>
<pre><code>var currying = function(fn) {
  var args = [];

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}
</code></pre><p>调用上述<code>currying()</code>函数：</p>
<pre><code>var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = currying(cost);

cost(100); // 传入了参数，不真正求值
cost(200); // 传入了参数，不真正求值
cost(300); // 传入了参数，不真正求值

console.log(cost()); // 求值并且输出600
</code></pre><p>上述函数是我之前的<a href="http://link.zhihu.com/?target=https%3A//github.com/xingbofeng/JavaScript-design-patterns/blob/master/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0.md%23currying" target="_blank" rel="noopener">JavaScript设计模式与开发实践读书笔记之闭包与高阶函数</a>所写的<code>currying</code>版本，现在仔细思考后发现仍旧有一些问题。</p>
<blockquote>
<p>我们在使用柯里化时，要注意同时为函数预传的参数的情况。</p>
</blockquote>
<p>因此把上述柯里化函数更改如下：</p>
<pre><code>var currying = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}
</code></pre><p>使用实例：</p>
<pre><code>var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = currying(cost, 100);
cost(200); // 传入了参数，不真正求值
cost(300); // 传入了参数，不真正求值

console.log(cost()); // 求值并且输出600
</code></pre><p>你可能会觉得每次都要在最后调用一下不带参数的<code>cost()</code>函数比较麻烦，并且在<code>cost()</code>函数都要使用<code>arguments</code>参数不符合你的预期。我们知道函数都有一个<code>length</code>属性，表明函数期望接受的参数个数。因此我们可以充分利用预传参数的这个特点。</p>
<p>借鉴自<a href="http://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">mqyqingfeng</a>：</p>
<pre><code>function sub_curry(fn) {
  var args = [].slice.call(arguments, 1);
  return function() {
    return fn.apply(this, args.concat([].slice.call(arguments)));
  };
}

function curry(fn, length) {

  length = length || fn.length;

  var slice = Array.prototype.slice;

  return function() {
    if (arguments.length &lt; length) {
      var combined = [fn].concat(slice.call(arguments));
      return curry(sub_curry.apply(this, combined), length - arguments.length);
    } else {
      return fn.apply(this, arguments);
    }
  };
}
</code></pre><p>在上述函数中，我们在currying的返回函数中，每次把<code>arguments.length</code>和<code>fn.length</code>作比较，一旦<code>arguments.length</code>达到了<code>fn.length</code>的数量，我们就去调用<code>fn</code>(<code>return fn.apply(this, arguments);</code>)</p>
<p>验证：</p>
<pre><code>var fn = curry(function(a, b, c) {
  return [a, b, c];
});

fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><h2 id="bind方法的实现"><a href="#bind方法的实现" class="headerlink" title="bind方法的实现"></a>bind方法的实现</h2><p>使用柯里化，能够很方便地借用<code>call()</code>或者<code>apply()</code>实现<code>bind()</code>方法的<code>polyfill</code>。</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function(context) {
  var me = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var innerArgs = Array.prototype.slice.call(arguments);
    var finalArgs = args.concat(innerArgs);
    return me.apply(contenxt, finalArgs);
  }
}
</code></pre><p>上述函数有的问题在于不能兼容构造函数。我们通过判断this指向的对象的原型属性，来判断这个函数是否通过<code>new</code>作为构造函数调用，来使得上述<code>bind</code>方法兼容构造函数。</p>
<p><a href="http://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind() by MDN</a>如下说到：</p>
<blockquote>
<p>绑定函数适用于用new操作符 new 去构造一个由目标函数创建的新的实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。然而, 原先提供的那些参数仍然会被前置到构造函数调用的前面。</p>
</blockquote>
<p>这是<a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/10733304/" target="_blank" rel="noopener">基于MVC的JavaScript Web富应用开发</a>的<code>bind()</code>方法实现：</p>
<pre><code>Function.prototype.bind = function(oThis) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
  }

  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function() {},
    fBound = function() {
      return fToBind.apply(
        this instanceof fNOP &amp;&amp; oThis ? this : oThis || window,
        aArgs.concat(Array.prototype.slice.call(arguments))
      );
    };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
</code></pre><h2 id="反柯里化（uncurrying）"><a href="#反柯里化（uncurrying）" class="headerlink" title="反柯里化（uncurrying）"></a>反柯里化（uncurrying）</h2><p>可能遇到这种情况：拿到一个柯里化后的函数，却想要它柯里化之前的版本，这本质上就是想将类似<code>f(1)(2)(3)</code>的函数变回类似<code>g(1,2,3)</code>的函数。</p>
<p>下面是简单的<code>uncurrying</code>的实现方式：</p>
<pre><code>function uncurrying(fn) {
  return function(...args) {
    var ret = fn;

    for (let i = 0; i &lt; args.length; i++) {
      ret = ret(args[i]); // 反复调用currying版本的函数
    }

    return ret; // 返回结果
  };
}
</code></pre><blockquote>
<p>注意，不要以为uncurrying后的函数和currying之前的函数一模一样，它们只是行为类似！</p>
</blockquote>
<pre><code>var currying = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}

function uncurrying(fn) {
  return function(...args) {
    var ret = fn;

    for (let i = 0; i &lt; args.length; i++) {
      ret = ret(args[i]); // 反复调用currying版本的函数
    }

    return ret; // 返回结果
  };
}

var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var curryingCost = currying(cost);
var uncurryingCost = uncurrying(curryingCost);
console.log(uncurryingCost(100, 200, 300)()); // 600
</code></pre><h2 id="柯里化或偏函数有什么用？"><a href="#柯里化或偏函数有什么用？" class="headerlink" title="柯里化或偏函数有什么用？"></a>柯里化或偏函数有什么用？</h2><p>无论是柯里化还是偏应用，我们都能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。</p>
<p>另一个最能体现柯里化应用的的是，当函数只有一个形参时，我们能够比较容易地组合它们（<code>单一职责原则（Single responsibility principle）</code>）。因此，如果一个函数最终需要三个实参，那么它被柯里化以后会变成需要三次调用，每次调用需要一个实参的函数。当我们组合函数时，这种单元函数的形式会让我们处理起来更简单。</p>
<p>归纳下来，主要为以下常见的三个用途：</p>
<ul>
<li>延迟计算</li>
<li>参数复用</li>
<li>动态生成函数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/08/HTML5的Websocket/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/HTML5的Websocket/" itemprop="url">HTML5的Websocket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-08T22:18:50+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>先请来TA的邻居：*<br>http：无状态、基于tcp请求/响应模式的应用层协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么）tcp：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) 传输层协议。（看啊，大阅兵，如此规整有秩序）</li>
</ul>
</blockquote>
<h2 id="为什么要引入Websocket："><a href="#为什么要引入Websocket：" class="headerlink" title="为什么要引入Websocket："></a>为什么要引入Websocket：</h2><blockquote>
<p>RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。</p>
</blockquote>
<p>long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。</p>
<p><img src="https://pic3.zhimg.com/v2-b900392bfe564de524ec5460a2b5d235_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b900392bfe564de524ec5460a2b5d235_hd.jpg" alt=""></p>
<p>从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p>
<p>这个时候，Websocket出现了。</p>
<h2 id="Websocket是什么："><a href="#Websocket是什么：" class="headerlink" title="Websocket是什么："></a>Websocket是什么：</h2><blockquote>
<p>RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。</p>
</blockquote>
<p>对，划重点：双向通信</p>
<p>Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以主动向客户端推送消息。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。</p>
<p>其特点：</p>
<p>（1）握手阶段采用 HTTP 协议，默认端口是80和443</p>
<p>（2）建立在TCP协议基础之上，和http协议同属于应用层</p>
<p>（4）可以发送文本，也可以发送二进制数据</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信</p>
<p>（6）协议标识符是ws（如果加密，为wss），如ws://localhost:8023</p>
<p>简单来说，Websocket协议分为两部分：握手和数据传输。</p>
<p><img src="https://pic2.zhimg.com/v2-5b1e92b99d352ba977f69cbe28604ecf_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5b1e92b99d352ba977f69cbe28604ecf_hd.jpg" alt=""></p>
<h2 id="Websocket-API："><a href="#Websocket-API：" class="headerlink" title="Websocket API："></a>Websocket API：</h2><blockquote>
<p>这里是指客户端 API。</p>
</blockquote>
<h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><ol>
<li><code>通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。</code></li>
<li><code>const ws =`</code>new<code></code>WebSocket(‘ws://localhost:8023’);`</li>
</ol>
<h2 id="Websocket事件"><a href="#Websocket事件" class="headerlink" title="Websocket事件"></a>Websocket事件</h2><ol>
<li><code>WebSocket`</code>是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。`</li>
</ol>
<p>open:</p>
<p>服务端响应WebSocket连接请求，就会触发open事件。onopen是响应的回调函数。</p>
<p><code>// 连接请求open事件处理：</code></p>
<pre><code>ws.onopen=e=&gt;{
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果要指定多个回调函数，可以使用addEventListener方法。</p>
<pre><code>ws.addEventListener(&apos;open&apos;, e =&gt; {
 ws.send(`Hello ${e}`);
});
</code></pre><p>当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。</p>
<p>Message:</p>
<p>收到服务器数据，会触发消息事件，onmessage是响应的回调函数。如下：</p>
<pre><code>// 接受文本消息的事件处理：
ws.onmessage = e =&gt; {
const data = e.data;
if (typeof data === &quot;string&quot;) {
       console.log(&quot;Received string message &quot;,data);
} else if (data instanceof Blob) {
       console.log(&quot;Received blob message &quot;, data);
}
};
</code></pre><p>服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p>
<p>Error</p>
<p>发生错误会触发error事件, onerror是响应的回调函数, 会导致连接关闭。</p>
<pre><code>//异常处理
ws.onerror = e =&gt; {
   console.log(&quot;WebSocket Error: &quot; , e);
   handleErrors(e);
};
</code></pre><p>当连接关闭时触发close事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再通信。</p>
<p>WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧）</p>
<pre><code>//关闭连接处理
ws.onclose = e =&gt; {
const code = e.code;
const reason = e.reason;
   console.log(&quot;Connection close&quot;, code, reason);
};
</code></pre><h2 id="WebSocket-方法："><a href="#WebSocket-方法：" class="headerlink" title="WebSocket 方法："></a>WebSocket 方法：</h2><blockquote>
<p>WebSocket 对象有两个方法：send 和 close</p>
</blockquote>
<p>send:</p>
<p>客户端和服务器建立连接后，可以调用send方法去发送消息。</p>
<pre><code>//发送一个文本消息
ws.send(&quot;this is websocket&quot;);
</code></pre><p>在open事件的回调中调用send()方法传送数据：</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;);
ws.onopen = e =&gt; {
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState.</p>
<p>close</p>
<p>close方法用来关闭连接。调用close方法后，将不能发送数据。close方法可以传入两个可选的参数，code 和reason, 以告诉服务端为什么终止连接。</p>
<pre><code>ws.close();

//1000是状态码，代表正常结束。
ws.close(1000, &quot;Closing normally&quot;);
</code></pre><h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><ul>
<li>readyState：</li>
</ul>
<p>readyState值表示连接状态，是只读属性。它有以下四个值：</p>
<blockquote>
<p>WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开</p>
</blockquote>
<p>除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。</p>
<pre><code>function bindEventHandler(data) {
if (ws.readyState === WebSocket.OPEN) {
       ws.send(data);
} else {
//do something
}
} 
</code></pre><p>bufferedAmount：</p>
<p>当客户端传输大量数据时，浏览器会缓存将要流出的数据，bufferedAmount属性可判断有多少字节的二进制数据没有发送出去，发送是否结束。</p>
<pre><code>ws.onopen = function () {
   setInterval( function() {
//缓存未满的时候发送
if (ws.bufferedAmount &lt; 1024 * 5) {
           ws.send(data);
}
}, 2000);
};
</code></pre><p>protocol：</p>
<p>protocol代表客户端使用的WebSocket协议。当握手协议未成功，这个属性是空。</p>
<ul>
<li>接下来，我们说说握手阶段过程。*</li>
</ul>
<p>当我们创建Websocket实例对象与服务器建立连接时，</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;)；
</code></pre><p>首先客户端向服务器发起一个握手请求，其请求报文的内容如下：</p>
<pre><code>GET /game HTTP/1.1
Host: 10.242.17.102:8023
Cache-Control: no-cache
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Protocol: game
Sec-WebSocket-Version: 10
Origin: http://192.168.185.16
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
</code></pre><p>从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。</p>
<ul>
<li>Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。</li>
<li>Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信</li>
<li>Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议</li>
<li>Sec-WebSocket-Version: 通知服务器所使用的协议版本</li>
</ul>
<p>服务器响应：</p>
<pre><code>当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。 
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ=
</code></pre><ul>
<li>101 状态码，表示要转换协议啦</li>
<li>Upgrde: 通知客户端将要升级成Websocket协议</li>
<li>Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-05e821d0db32cf8cb5ebf51625870cb1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-05e821d0db32cf8cb5ebf51625870cb1_hd.jpg" alt=""></p>
<p>至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/25/移动端H5页面返回并且刷新页面/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/25/移动端H5页面返回并且刷新页面/" itemprop="url">移动端H5页面返回并且刷新页面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-25T20:08:31+08:00">
                2016-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目中的需求：点击浏览器中的返回按钮，要让页面重新加载资源。因为这部分的资源每次去加载的内容都不一样，如果返回的时候，还是看到原先的内容，那做这个内容块的意义就很小了；而如果用户看完了这部分内容，再返回来的时候，这个地方换成了新的内容，这样就能体现这部分的价值了。</p>
<p>而对于浏览器来说，大部分浏览器的返回是直接使用缓存的，不会执行任何的javascript代码。原因：部分浏览器在后退时不会触发onload事件，這是HTML5世代浏览器新增的特性之一——Back-Forward Cache(简称bfcache)</p>
<p><strong>什么是bfcache？</strong></p>
<p>bfcache，即back-forward cache，可称为“往返缓存”，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存不仅保存页面数据，还保存了DOM和JS的状态，实际上是将整个页面都保存在内存里。如果页面位于bfcache中，那么再次打开该页面就不会触发onload事件</p>
<h3 id="pageshow事件"><a href="#pageshow事件" class="headerlink" title="pageshow事件"></a>pageshow事件</h3><p>这个事件在用户浏览网页时触发，pageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， pageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发。</p>
<h3 id="pagehide事件"><a href="#pagehide事件" class="headerlink" title="pagehide事件"></a>pagehide事件</h3><p>该事件会在用户离开网页时触发。离开网页有多种方式。如点击一个链接，刷新页面，提交表单，关闭浏览器等。pagehide 事件有时可以替代 unload事件，但 unload 事件触发后无法缓存页面。</p>
<h3 id="persisted属性"><a href="#persisted属性" class="headerlink" title="persisted属性"></a>persisted属性</h3><p>pageshow事件和pagehide事件的event对象还包含一个名为persisted的布尔值属性。</p>
<ul>
<li>对于pageshow事件，如果页面是从bfcache中加载的，则这个属性的值为true；否则，这个属性的值为false。</li>
<li>对于pagehide事件，如果页面在卸载之后被保存在bfcache中，则这个属性的值为true；否则，这个属性的值为false。</li>
</ul>
<p>不同的浏览器在对当前窗口‘打开’历史记录中的前一个页面的表现上并不统一，这和浏览器的实现以及页面本身的设置有关系。</p>
<p><strong>解决方案：</strong></p>
<p><strong>javascript监听pageshow事件阻止页面进入bfcache</strong></p>
<pre><code> window.addEventListener(&apos;pageshow&apos;, function (e) {
     if (e.persisted) {
         window.location.reload()
     }
})
</code></pre><p>在uc和微信中测试通过，但是在某些安卓手机自带的浏览器中无效。</p>
<p><strong>javascript监听pagehide事件阻止页面进入bfcache</strong></p>
<pre><code>window.addEventListener(&apos;pagehide&apos;, function (e) {
    var dom = document.body;
    dom.children.remove();
    setTimeout(function () {
        dom.appendChild(&quot;&lt;script type=&apos;text/javascript&apos;&gt;window.location.reload();&lt;\/script&gt;&quot;);
    });
});
</code></pre><p><strong>设置meta标签，清除页面缓存</strong></p>
<pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt;
&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;
&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;
</code></pre><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下<br>Public指示响应可被任何缓存区缓存<br>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。<br>注：有些情况下设置清除缓存也没有起到作用，我自己做的这个h5页面就没有起到效果。具体情况还是要具体分析。</p>
<p><strong>我遇到的情况：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">     &lt;iframe id=&quot;iframe&quot; src=&quot;https://cpu.baidu.com/xx/xx/xxx&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个iframe中的地址每次刷新页面都会有不同的内容推送给用户。进入iframe中的内容之后，按返回按钮返回来想进行页面自动刷新，为的就是让用户看到新的内容。</p>
<p>做法：</p>
<p>使用pageshow进行整个页面刷新</p>
<pre><code>window.addEventListener(&apos;pageshow&apos;, function (e) {
    if (e.persisted) {
        window.location.reload()
    }
})
</code></pre><p>这样可以实现。</p>
<p>后面又觉得不妥，没有因为这个小部分而进行整个页面刷新，想到了另一种思路：因为这个iframe中的内容是动态的，可以对其进行定时器设置，如下：</p>
<pre><code>let iframe = document.getElementById(&apos;iframe&apos;)
setInterval(() =&gt; {
    iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
},15000)
</code></pre><p>这样也可以实现自己的功能。</p>
<p>最后可以结合一下：</p>
<pre><code>let iframe = document.getElementById(&apos;iframe&apos;)
window.addEventListener(&apos;pageshow&apos;, function (e) {
    if (e.persisted) {
        iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
    }
})
</code></pre><p>这样做也有好处，可以避免使用定时器，对网页的性能也是比较好。但是这个方法在返回的时候，可以看到iframe里面内容的重新加载，会有一个时间间隙。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tx.jpg" alt="李斌">
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">131</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">105</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


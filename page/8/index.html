<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/03/JS类型判断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/03/JS类型判断/" itemprop="url">JS类型判断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-03T22:55:27+08:00">
                2017-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="先看typeof"><a href="#先看typeof" class="headerlink" title="先看typeof"></a>先看typeof</h2><pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;

        &lt;/style&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var a;
            console.log(&quot;1:&quot; + typeof a);
            var b = null;
            console.log(&quot;2:&quot; + typeof b);
            var c = undefined;
            console.log(&quot;3:&quot; + typeof c);
            var d = new Object;
            console.log(&quot;4:&quot; + typeof d);
            var e = function() {};
            console.log(&quot;5:&quot; + typeof e);
            var f = {};
            console.log(&quot;6:&quot; + typeof f);
            var g = &apos;&apos;;
            console.log(&quot;7:&quot; + typeof g);
            var h = [];
            console.log(&quot;8:&quot; + typeof h);
            var i = true;
            console.log(&quot;9:&quot; + typeof i);
            var j = 123;
            console.log(&quot;10:&quot; + typeof j);
            var k = NaN;
            console.log(&quot;11:&quot; + typeof k);
            var l = /^[-+]?\d+$/;
            console.log(&quot;12:&quot; + typeof l);
        &lt;/script&gt;

    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>按照上面的打印结果,总结出下面要注意的几点</p>
<ul>
<li>typeof (引用类型) 除了函数, 都是 ‘object’,比如 typeof /123/</li>
<li>typeof null 为’object’</li>
<li>typeof undefined 为 ‘undefined’,通常, 如果使用两等号, null == undefined 为真.</li>
<li><p>转换为数字的常见用法 “10”-0或+”10”, 如果没有转换成功,返回NaN,由于NaN 的一个特性: NaN != NaN,故判断转换成功与否的常见做法: (这也是我参见 jQuery的源码发现的,jQuery源码读100遍都不为过)</p>
<p>(“10x” - 0) == (“10x” - 0);<br>// 结果为假!   </p>
</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-6f58d81de68683e272adaf7c340aa518_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-6f58d81de68683e272adaf7c340aa518_hd.jpg" alt=""></p>
<h2 id="再看看constructor-和-instanceof"><a href="#再看看constructor-和-instanceof" class="headerlink" title="再看看constructor 和 instanceof"></a>再看看constructor 和 instanceof</h2><pre><code>instanceof 用于判断一个变量是否某个对象的实例,或用于判断一个变量是否某个对象的实例；
constructor 用于判断一个变量的原型，constructor 属性返回对创建此对象的数组函数的引用。
Javascript中对象的prototype属性的解释是:返回对象类型原型的引用。
&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log(&quot;----------------Number---------------&quot;);
            var A = 123;
            console.log(A instanceof Number); //false
            console.log(A.constructor == Number); //true
            console.log(A.constructor);
            console.log(&quot;----------------String---------------&quot;);
            var B = &quot;javascript&quot;;
            console.log(B instanceof String); //false
            console.log(B.constructor == String); //true
            console.log(B.constructor);
            console.log(&quot;----------------Boolean---------------&quot;);
            var C = true;
            console.log(C instanceof Boolean); //false
            console.log(C.constructor == Boolean); //true
            console.log(C.constructor);
            console.log(&quot;----------------null---------------&quot;);
            var D = null;
            console.log(D instanceof Object); //false
            //console.log(D.constructor == null); //报错
            //console.log(D.constructor); //报错
            console.log(&quot;----------------undefined---------------&quot;);
            var E = undefined;
            //console.log(E instanceof undefined); // //报错
            //console.log(E.constructor == undefined); //报错
            //console.log(E.constructor); //报错
            console.log(&quot;----------------function---------------&quot;);
            var F = function() {};
            console.log(F instanceof Function);
            console.log(F.constructor == Function);
            console.log(F.constructor);
            console.log(&quot;----------------new function---------------&quot;);
            function SB() {};
            var G = new SB();
            console.log(G instanceof SB);
            console.log(G.constructor == SB);
            console.log(G.constructor);
            console.log(&quot;----------------new Object---------------&quot;);
            var H = new Object;
            console.log(H instanceof Object);
            console.log(H.constructor == Object);
            console.log(H.constructor);
            console.log(&quot;-----------------Array--------------&quot;);
            var I = [];
            console.log(I instanceof Array);
            console.log(I.constructor == Array);
            console.log(I.constructor);
            console.log(&quot;-----------------JSON--------------&quot;);
            var J = {
                &quot;good&quot;: &quot;js&quot;,
                &quot;node&quot;: &quot;very good&quot;
            };
            console.log(J instanceof Object);
            console.log(J.constructor == Object);
            console.log(J.constructor);
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic4.zhimg.com/v2-21d3ca864773ef451c189c0fd954f14a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-21d3ca864773ef451c189c0fd954f14a_hd.jpg" alt=""></p>
<h2 id="再看看-toString-call-obj"><a href="#再看看-toString-call-obj" class="headerlink" title="再看看{}.toString.call(obj)"></a>再看看{}.toString.call(obj)</h2><pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log({}.toString.call(1));
            console.log({}.toString.call(&quot;11&quot;));
            console.log({}.toString.call(/123/));
            console.log({}.toString.call({}));
            console.log({}.toString.call(function() {}));
            console.log({}.toString.call([]));
            console.log({}.toString.call(true));
            console.log({}.toString.call(new Date()));
            console.log({}.toString.call(new Error()));
            console.log({}.toString.call(null));
            console.log({}.toString.call(undefined));
            console.log(String(null));
            console.log(String(undefined));
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic1.zhimg.com/v2-2d04b5646ab716650f46286dd0be9747_b.jpg" alt=""></p>
<h2 id="使用jQuery中的方法-type"><a href="#使用jQuery中的方法-type" class="headerlink" title="使用jQuery中的方法$.type()"></a>使用jQuery中的方法$.type()</h2><p>现在看看jQuery是怎么做的</p>
<pre><code>// 先申明一个对象,目的是用来做映射
var class2type = {};
// 申明一个core_toString() 的方法,得到最原始的toString() 方法,因为在很多对象中,toStrintg() 已经被重写 
var core_toString() = class2type.toString;
// 这里为 toStrintg() 后的结果和类型名做一个映射,申明一个core_toString() 后的结果,而值就是类型名
jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) {
    class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
});


&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log($.type(1));
            console.log($.type(&quot;11&quot;));
            console.log($.type(/123/));
            console.log($.type({}));
            console.log($.type(function() {}));
            console.log($.type([]));
            console.log($.type(true));
            console.log($.type(new Date()));
            console.log($.type(new Error()));
            console.log($.type(null));
            console.log($.type(undefined));
            console.log(String(null));
            console.log(String(undefined));
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-05899b1b3bcf02e58f2eb987ef69594a_b.jpg" alt=""></p>
<p>上面的打印结果与</p>
<pre><code>class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
</code></pre><p>不谋而合!</p>
<p>这是jQuery.type 的核心方法</p>
<pre><code>type: function( obj ) {
    if ( obj == null ) {
        return String( obj );
    }
    // Support: Safari &lt;= 5.1 (functionish RegExp)
    return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
        class2type[ core_toString.call(obj) ] || &quot;object&quot; :
        typeof obj;
},
</code></pre><blockquote>
<p>注意,为什么把 null 或者 undefined 单独讨论呢,因为 在一些版本浏览器中<br>console.log(core_toString.call(null));<br>console.log(core_toString.call(undefined));</p>
</blockquote>
<pre><code>这是会报错的!


如果是对象类型,另:由于 在一些低版本的浏览器中,typeof /123/ 会返回的是 &quot;function&quot; 而不是 &quot;object&quot;,所以这里要判断是否是函数,要明白 这里的 typeof obj === function 不是为了函数讨论的,因为函数本身就可以通过typeof 来得到类型.

typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
        class2type[ core_toString.call(obj) ]
</code></pre><p>就直接返回class2type 中键值对的结果,,如果不是,那么一定就是基本类型, 通过 typeof 就可以啦.</p>
<pre><code>class2type[ core_toString.call(obj) ] || &quot;object&quot; :
// 这是防止一些未知情况的,如果未取到,就返回object
</code></pre><h2 id="但是-jQuery-type-有一个很大的缺陷"><a href="#但是-jQuery-type-有一个很大的缺陷" class="headerlink" title="但是 jQuery.type 有一个很大的缺陷"></a>但是 jQuery.type 有一个很大的缺陷</h2><p>这是一个自定义类型</p>
<pre><code>function Person() {
    this.name = &apos;pawn&apos;;
}
var p = new Person();
console.log($.type(p));
console.log({}.toString.call(p));
</code></pre><blockquote>
<p>// 注意,这里会打印 [object Object],通过上面的方法,无法得到精确的自定义类型<br>这也是 它的一个大缺陷了!</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/v2-32ad7e97fff63ad11925460861e4ef9e_b.jpg" alt=""></p>
<p>下面,我们通过构造函数的方式来获取精确类型</p>
<h2 id="通过构造函数来获取类型"><a href="#通过构造函数来获取类型" class="headerlink" title="通过构造函数来获取类型"></a>通过构造函数来获取类型</h2><p>在理解这个方法之前,需要理解两个点</p>
<p>prorotype 原型属性</p>
<pre><code>我们知道,任何对象或者函数都直接或者间接的继承自Object 或者 Function， （其实最终Function 是继承自 Object 的，这属于原型链的知识了，见下图）。那么，任何一个对象都具有原型对象 __proto__ (这个对象只在chrome 和 firefox 暴露，但是在其他浏览器中也是存在的)，这个原型对象就是这个对象的构造函数的原型属性(这里可能有点绕,直接上图).
</code></pre><p><img src="https://pic4.zhimg.com/v2-9a1d9c8359714d86fdac5b90d36547ac_b.jpg" alt=""></p>
<p>由于 任何函数都具有 原型属性prototype,并且这个原型属性具有一个默认属性 constructor,它是这个函数的引用,看下面的代码</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 console.log(Person.prototype.constructor === Person);   //true
</code></pre><p>发现,这两个东西其实一个东西</p>
<p>但是,在某些情况下,需要这么写</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 Person.protype = {
     XX: ... ,
     xx: ... ,
     ...
 }
</code></pre><p>这么做,就会覆盖原本的 protype 方法,那么construcor 就不存在了,这是,必须要显示的申明这个对象，</p>
<h2 id="construction-Person-这句话非常重要，作用是修正this指向"><a href="#construction-Person-这句话非常重要，作用是修正this指向" class="headerlink" title="construction: Person, 这句话非常重要，作用是修正this指向"></a>construction: Person, 这句话非常重要，作用是修正this指向</h2><pre><code>Person.protype = {
     construction: Person,   //这句话的作用是修正this指向
     XX: ... ,
     xx: ... ,
     ...
 }
</code></pre><p>在jQuery的中,就是这么做的,</p>
<pre><code>jQuery.fn = jQuery.prototype = {
   constructor: jQuery,
   init: function( selector, context, rootjQuery ) {
       var match, elem;
</code></pre><blockquote>
<p>关于 jQuery对象封装的方式 也是非常值得研究</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-720d122b9b125559f5fb75f2178b25f9_b.jpg" alt=""></p>
<p>注意,这里已经不是熟悉 [object Object],而是 已经重写了.</p>
<p>也就是,如果调用一个函数的toString() 方法.那么就会打印这个函数的函数体.</p>
<p><img src="https://pic3.zhimg.com/v2-b6640c61635718af42b8fb7ce00daf63_b.jpg" alt=""></p>
<p>如何通过构造函数来获得变量的类型?</p>
<p>判断是否是基本类型</p>
<pre><code>var getType = function(obj){
     if(obj == null){
        return String(obj);
     }
     if(typeof obj === &apos;object&apos; || typeof obj === &apos;fucntion&apos;){
         ...
     }else{
         // 如果不是引用类型,那么就是基本类型
         return typeof obj
     }
 }
</code></pre><p>如果是对象或者函数类型</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 var p = new Person();
 console.log(p.constructor);   //返回function Person(){...}
</code></pre><p>现在要做的事 : 如何将Person 提取出来呢?<br>毋庸置疑,字符串切割那一套肯定可以办到,但是太 low 啦!<br>这里,我使用正则将Person提取出来</p>
<pre><code>var regex = /function\s(.+?)\(/
function Person(){
  this.name = &apos;pawn&apos;;
 }
 var p = new Person();
 var c = p.constructor
 var regex = /function\s(.+?)\(/;
 console.log(&apos;|&apos; + regex.exec(c)[1] + &apos;|&apos;);
</code></pre><p><img src="https://pic1.zhimg.com/v2-798dac45bc14f57445c3f12c53a95856_b.jpg" alt=""></p>
<p>其实,除了上面的正则,每个函数还有一个name属性,返回函数名,但是ie8 是不支持的.</p>
<p>因此上面的代码可以写为:</p>
<pre><code>var getType = function(obj){
    if(obj == null){
        return String(obj);
    }
    if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){ 
        var constructor = obj.constructor;
        if(constructor &amp;&amp; constructor.name){
            return constructor.name;
        }
        var regex = /function\s(.+?)\(/;
        return regex.exec(c)[1];
    }else{
        // 如果不是引用类型,那么就是基本;类型
        return typeof obj;
    }
};
</code></pre><p>但是上面的代码太丑啦,将其简化</p>
<p>简化</p>
<pre><code>var getType = function(obj){
    if(obj == null){
        return String(obj);
    }
    if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){ 
        return obj.constructor &amp;&amp; obj.constructor.name.toLowerCase() || 
          /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase();
    }else{
        // 如果不是引用类型,那么就是基本类型
        return typeof obj;
    }
};
</code></pre><p>还是比较麻烦,继续简化</p>
<pre><code>var getType = function(obj){
    if(obj == null){
       return String(obj);
    }
    return typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos; ?
      obj.constructor &amp;&amp; obj.constructor.name &amp;&amp; obj.constructor.name.toLowerCase() ||
          /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase():
      typeof obj;
};
</code></pre><p>好了,已经全部弄完了,写个代码测试一下:</p>
<pre><code>function Person(){
    this.name = &apos;pawn&apos;;
}
var p = new Person();

console.log(getType(p));
console.log(getType(1));
console.log(getType(&quot;a&quot;));
console.log(getType(false));
console.log(getType(/123/));
console.log(getType({}));
console.log(getType(function(){}));
console.log(getType(new Date()));
console.log(getType(new Error()));
console.log(getType( null));
console.log(getType( undefined));
</code></pre><p><img src="https://pic2.zhimg.com/v2-45d3c3f08f70b60b05ed1c8885a5ada8_b.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-fe845739a4f557bdf52bc85f1e7a2823_b.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-0cb813f94a182e42c1214445bf96abf3_b.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-e97820f7d32bab80b31beee769505529_b.jpg" alt=""></p>
<h2 id="1-有时会看到Object-prototype-toString-call"><a href="#1-有时会看到Object-prototype-toString-call" class="headerlink" title="1.有时会看到Object.prototype.toString.call()"></a>1.有时会看到Object.prototype.toString.call()</h2><p><img src="https://pic1.zhimg.com/v2-2c236d4c9534822e61fca4fcab53cf40_b.jpg" alt=""></p>
<h2 id="2-toString-是一个怎样的方法-他定义在哪里？"><a href="#2-toString-是一个怎样的方法-他定义在哪里？" class="headerlink" title="2.toString()是一个怎样的方法,他定义在哪里？"></a>2.toString()是一个怎样的方法,他定义在哪里？</h2><p><img src="https://pic2.zhimg.com/v2-462bb123e83ec081f7fffca86dd9baee_b.jpg" alt=""></p>
<h2 id="3-call-apply-bind可以吗？"><a href="#3-call-apply-bind可以吗？" class="headerlink" title="3.call.apply.bind可以吗？"></a>3.call.apply.bind可以吗？</h2><p><img src="https://pic4.zhimg.com/v2-f396bb49abd0ca789e28d1741aa6360f_b.jpg" alt=""></p>
<h2 id="4-为神马要去call呢？用-Object-prototype-toString-call-obj-而不用-obj-toString-呢？"><a href="#4-为神马要去call呢？用-Object-prototype-toString-call-obj-而不用-obj-toString-呢？" class="headerlink" title="4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？"></a>4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function A(){
                this.say=function(){
                    console.log(&quot;我是1&quot;);
                }
            }
            function B(){
                this.say=function(){
                    console.log(&quot;我是2&quot;);
                }
            }
            var a=new A();
            var b=new B();
            a.say.call(b);    //我是1
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function A(){
                this.name=&apos;SB&apos;;
                this.say=function(){
                    console.log(&quot;我是1&quot;);
                }
            }
            function B(){
                A.call(this);   //B继承A，重写say方法
                this.say=function(){
                    console.log(&quot;我是2&quot;);
                }
            }
            var a=new A();
            var b=new B();
            console.log(b.name);  //SB
            b.say();         //我是2
            a.say.call(b);    //我是1
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="就是怕你重写了toString-所以才要用object-最原始的他toString-所以才去call。"><a href="#就是怕你重写了toString-所以才要用object-最原始的他toString-所以才去call。" class="headerlink" title="就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。"></a>就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。</h2><h2 id="5-Object-prototype-toString方法的原理是什么？"><a href="#5-Object-prototype-toString方法的原理是什么？" class="headerlink" title="5.Object.prototype.toString方法的原理是什么？"></a>5.Object.prototype.toString方法的原理是什么？</h2><p>参考链接：<a href="https://link.zhihu.com/?target=http%3A//www.jb51.net/article/79941.htm" target="_blank" rel="noopener">http://www.jb51.net/article/79941.htm</a></p>
<p>在JavaScript中,想要判断某个对象值属于哪种内置类型,最靠谱的做法就是通过Object.prototype.toString方法.</p>
<p>12var arr = [];console.log(Object.prototype.toString.call(arr)) //“[object Array]”</p>
<p>本文要讲的就是,toString方法是如何做到这一点的,原理是什么.</p>
<p>ECMAScript 3</p>
<p>在ES3中,Object.prototype.toString方法的规范如下:</p>
<p>115.2.4.2 Object.prototype.toString()</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<ol>
<li><p>获取this对象的[[Class]]属性的值.</p>
</li>
<li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串.</p>
</li>
<li><p>返回第二步的操作结果Result(2).</p>
</li>
</ol>
<p>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的</p>
<p>[[Class]]一个字符串值,表明了该对象的类型.</p>
<p>然后给了一段解释:</p>
<p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2).</p>
<p>也就是说,把Object.prototype.toString方法返回的字符串,去掉前面固定的”[object “和后面固定的”]”,就是内部属性[[class]]的值,也就达到了判断对象类型的目的.jQuery中的工具方法$.type(),就是干这个的.</p>
<p>在ES3中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有10种.分别是:”Array”, “Boolean”, “Date”, “Error”, “Function”, “Math”, “Number”, “Object”, “RegExp”, “String”.</p>
<p>ECMAScript 5</p>
<p>在ES5.1中,除了规范写的更详细一些以外,Object.prototype.toString方法和[[class]]内部属性的定义上也有一些变化,Object.prototype.toString方法的规范如下:</p>
<p>15.2.4.2 Object.prototype.toString ( )</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<p>如果this的值为undefined,则返回”[object Undefined]”.</p>
<p>如果this的值为null,则返回”[object Null]”.</p>
<p>让O成为调用ToObject(this)的结果.</p>
<p>让class成为O的内部属性[[Class]]的值.</p>
<p>返回三个字符串”[object “, class, 以及 “]”连接后的新字符串.</p>
<p>可以看出,比ES3多了1,2,3步.第1,2步属于新规则,比较特殊,因为”Undefined”和”Null”并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this的值才会保持undefined或null,非严格模式下会自动成为全局对象).第3步并不算是新规则,因为在ES3的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来.ES5中,[[Class]]属性的解释更加详细:</p>
<p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2).</p>
<p>和ES3对比一下,第一个差别就是[[class]]内部属性的值多了两种,成了12种,一种是arguments对象的[[class]]成了”Arguments”,而不是以前的”Object”,还有就是多个了全局对象JSON,它的[[class]]值为”JSON”.第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这12种值冲突,不过在支持ES3的浏览器中,貌似也没有发现哪些宿主对象故意使用那10个值.</p>
<p>ECMAScript 6</p>
<p>ES6目前还只是工作草案,但能够肯定的是,[[class]]内部属性没有了,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的:</p>
<p>内部属性属性值描述<br>[[NativeBrand]]枚举NativeBrand的一个成员.该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型.</p>
<p>[[NativeBrand]]属性的解释:</p>
<p>[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的ECMAScript原生对象.只有在表10中明确指出的对象类型才有[[NativeBrand]]内部属性.</p>
<p>表10 — [[NativeBrand]]内部属性的值</p>
<p>属性值对应类型<br>NativeFunctionFunction objects<br>NativeArrayArray objects<br>StringWrapperString objects<br>BooleanWrapperBoolean objects<br>NumberWrapperNumber objects<br>NativeMathThe Math object<br>NativeDateDate objects<br>NativeRegExpRegExp objects<br>NativeErrorError objects<br>NativeJSONThe JSON object<br>NativeArgumentsArguments objects<br>NativePrivateNamePrivate Name objects</p>
<p>可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]].同时,Object.prototype.toString方法的规范也改成了下面这样:</p>
<p>15.2.4.2 Object.prototype.toString ( )</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<p>如果this的值为undefined,则返回”[object Undefined]”.</p>
<p>如果this的值为null,则返回”[object Null]”.</p>
<p>让O成为调用ToObject(this)的结果.</p>
<p>如果O有[[NativeBrand]]内部属性,让tag成为表29中对应的值.</p>
<p>否则</p>
<p>让hasTag成为调用O的[[HasProperty]]内部方法后的结果,参数为@@toStringTag.</p>
<p>如果hasTag为false,则让tag为”Object”.</p>
<p>否则,</p>
<p>让tag成为调用O的[[Get]]内部方法后的结果,参数为@@toStringTag.</p>
<p>如果tag是一个abrupt completion,则让tag成为NormalCompletion(“???”).</p>
<p>让tag成为tag.[[value]].</p>
<p>如果Type(tag)不是字符串,则让tag成为”???”.</p>
<p>如果tag的值为”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”,或</p>
<p>者”String”中的任一个,则让tag成为字符串”~”和tag当前的值连接后的结果.</p>
<p>返回三个字符串”[object “, tag, and “]”连接后的新字符串.</p>
<p>表29 — [[NativeBrand]] 标志值</p>
<p>[[NativeBrand]]值标志值<br>NativeFunction”Function”<br>NativeArray”Array”<br>StringWrapper”String”<br>BooleanWrapper”Boolean”<br>NumberWrapper”Number”<br>NativeMath”Math”<br>NativeDate”Date”<br>NativeRegExp”RegExp”<br>NativeError”Error”<br>NativeJSON”JSON”<br>NativeArguments”Arguments”</p>
<p>可以看到,在规范上有了很大的变化,不过对于普通用户来说,貌似感觉不到.</p>
<p>也许你发现了,ES6里的新类型Map,Set等,都没有在表29中.它们在执行toString方法的时候返回的是什么?</p>
<p>console.log(Object.prototype.toString.call(Map())) //“[object Map]”</p>
<p>console.log(Object.prototype.toString.call(Set())) //“[object Set]”</p>
<p>其中的字符串”Map”是怎么来的呢:</p>
<p>15.14.5.13 Map.prototype.@@toStringTag</p>
<p>@@toStringTag 属性的初始值为字符串”Map”.</p>
<p>由于ES6的规范还在制定中,各种相关规定都有可能改变,所以如果想了解更多细节.看看下面这两个链接,现在只需要知道的是:[[class]]没了,使用了更复杂的机制.</p>
<p>以上所述是小编给大家分享的JavaScript中Object.prototype.toString方法的原理，希望对大家有所帮助！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/31/JavaScript进阶提高必读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/31/JavaScript进阶提高必读/" itemprop="url">JavaScript进阶提高必读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-31T23:40:40+08:00">
                2016-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="冴羽写博客的地方"><a href="#冴羽写博客的地方" class="headerlink" title="冴羽写博客的地方"></a><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">冴羽写博客的地方</a></h2><h2 id="vue源码-内部运行机制剖析"><a href="#vue源码-内部运行机制剖析" class="headerlink" title="vue源码-内部运行机制剖析"></a><a href="https://github.com/DIVIBEAR/vue" target="_blank" rel="noopener">vue源码-内部运行机制剖析</a></h2><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>JavaScript深入系列 15 篇已完结。</p>
<p>JavaScript专题系列 20 篇已完结。</p>
<p>underscore 系列 8 篇已完结。</p>
<h2 id="深入系列目录"><a href="#深入系列目录" class="headerlink" title="深入系列目录"></a>深入系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScirpt深入之从原型到原型链</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript深入之执行上下文栈</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript深入之变量对象</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">JavaScript深入之作用域链</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">JavaScript深入之从ECMAScript规范解读this</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">JavaScript深入之执行上下文</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">JavaScript深入之闭包</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/10" target="_blank" rel="noopener">JavaScript深入之参数按值传递</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">JavaScript深入之类数组对象与arguments</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/15" target="_blank" rel="noopener">JavaScript深入之创建对象的多种方式以及优缺点</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">JavaScript深入之继承的多种方式以及优缺点</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/17" target="_blank" rel="noopener">JavaScript深入系列15篇正式完结！</a></li>
</ol>
<h2 id="专题系列目录"><a href="#专题系列目录" class="headerlink" title="专题系列目录"></a>专题系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">JavaScript专题之跟着underscore学防抖</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">JavaScript专题之跟着underscore学节流</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/27" target="_blank" rel="noopener">JavaScript专题之数组去重</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">JavaScript专题之类型判断(上)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/30" target="_blank" rel="noopener">JavaScript专题之类型判断(下)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener">JavaScript专题之深浅拷贝</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/33" target="_blank" rel="noopener">JavaScript专题之从零实现jQuery的extend</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/35" target="_blank" rel="noopener">JavaScript专题之如何求数组的最大值和最小值</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/36" target="_blank" rel="noopener">JavaScript专题之数组扁平化</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/37" target="_blank" rel="noopener">JavaScript专题之学underscore在数组中查找指定元素</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/40" target="_blank" rel="noopener">JavaScript专题之jQuery通用遍历方法each的实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/41" target="_blank" rel="noopener">JavaScript专题之如何判断两个对象相等</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript专题之函数柯里化</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/43" target="_blank" rel="noopener">JavaScript专题之偏函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/44" target="_blank" rel="noopener">JavaScript专题之惰性函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/45" target="_blank" rel="noopener">JavaScript专题之函数组合</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/46" target="_blank" rel="noopener">JavaScript专题之函数记忆</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/49" target="_blank" rel="noopener">JavaScript专题之递归</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/51" target="_blank" rel="noopener">JavaScript专题之乱序</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/52" target="_blank" rel="noopener">JavaScript专题之解读 v8 排序源码</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/53" target="_blank" rel="noopener">JavaScript专题系列20篇正式完结！</a></li>
</ol>
<h2 id="underscore-系列目录"><a href="#underscore-系列目录" class="headerlink" title="underscore 系列目录"></a>underscore 系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/56" target="_blank" rel="noopener">underscore 系列之如何写自己的 underscore</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/57" target="_blank" rel="noopener">underscore 系列之链式调用</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/58" target="_blank" rel="noopener">underscore 系列之内部函数 cb 和 optimizeCb</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/60" target="_blank" rel="noopener">underscore 系列之内部函数 restArgs</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/62" target="_blank" rel="noopener">underscore 系列之防冲突与 Utility Functions</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/63" target="_blank" rel="noopener">underscore 系列之实现一个模板引擎(上)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/70" target="_blank" rel="noopener">underscore 系列之实现一个模板引擎(下)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/77" target="_blank" rel="noopener">underscore 系列之字符实体与 _.escape</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/79" target="_blank" rel="noopener">underscore 的源码该如何阅读？</a></li>
</ol>
<h2 id="ES6-系列目录"><a href="#ES6-系列目录" class="headerlink" title="ES6 系列目录"></a>ES6 系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/82" target="_blank" rel="noopener">ES6 系列之 let 和 const</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/84" target="_blank" rel="noopener">ES6 系列之模板字符串</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/85" target="_blank" rel="noopener">ES6 系列之箭头函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/87" target="_blank" rel="noopener">ES6 系列之模拟实现 Symbol 类型</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/90" target="_blank" rel="noopener">ES6 系列之迭代器与 for of</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/91" target="_blank" rel="noopener">ES6 系列之模拟实现一个 Set 数据结构</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/92" target="_blank" rel="noopener">ES6 系列之 WeakMap</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/98" target="_blank" rel="noopener">ES6 系列之我们来聊聊 Promise</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/99" target="_blank" rel="noopener">ES6 系列之 Generator 的自动执行</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/22/JavaScript-模块化解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/22/JavaScript-模块化解析/" itemprop="url">JavaScript 模块化解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T19:47:32+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着 JavasScript 语言逐渐发展，JavaScript 应用从简单的表单验证，到复杂的网站交互，再到服务端，移动端，PC 客户端的语言支持。JavaScript 应用领域变的越来越广泛，工程代码变得越来越庞大，代码的管理变得越来越困难，于是乎 JavaScript 模块化方案在社区中应声而起，其中一些优秀的模块化方案，逐渐成为 JavaScript 的语言规范，下面我们就 JavaScript 模块化这个话题展开讨论，本文的主要包含以几部分内容。</p>
<ul>
<li>什么是模块</li>
<li>为什么需要模块化</li>
<li>JavaScript 模块化之 CommonJS</li>
<li>JavaScript 模块化之 AMD</li>
<li>JavaScript 模块化之 CMD</li>
<li>JavaScript 模块化之 ES Module</li>
<li>总结</li>
</ul>
<h2 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h2><p>模块，又称构件，是能够单独命名并独立地完成一定功能的程序语句的集合 (即程序代码和数据结构的集合体)。它具有两个基本的特征：外部特征和内部特征。外部特征是指模块跟外部环境联系的接口 (即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量) 和模块的功能，内部特征是指模块的内部环境具有的特点 (即该模块的局部数据和程序代码)。简而言之，模块就是一个具有独立作用域，对外暴露特定功能接口的代码集合。</p>
<h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><p>首先让我们回到过去，看看原始 JavaScript 模块文件的写法。</p>
<pre><code>// add.jsfunctionadd(a, b) {
  return a + b;
}
// decrease.jsfunctiondecrease(a, b) {
  return a - b;
}

// formula.jsfunctionsquare_difference(a, b) {
  return add(a, b) * decrease(a, b);
}
</code></pre><p>上面我们在三个 JavaScript 文件里面，实现了几个功能函数。其中，第三个功能函数需要依赖第一个和第二个 JavaScript 文件的功能函数，所以我们在使用的时候，一般会这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">		&lt;head&gt;</span><br><span class="line">		  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">		  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">		  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">		&lt;/head&gt;</span><br><span class="line">		&lt;body&gt;</span><br><span class="line">		    &lt;script src=&quot;add.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;script src=&quot;decrease.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;script src=&quot;formula.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;!--使用--&gt;</span><br><span class="line">		    &lt;script&gt;</span><br><span class="line">		       var result = square_difference(3, 4);</span><br><span class="line">		    &lt;/script&gt;</span><br><span class="line">		&lt;/body&gt;</span><br><span class="line">	&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这样的管理方式会造成以下几个问题：</span><br><span class="line"></span><br><span class="line">- 模块的引入顺序可能会出错</span><br><span class="line">- 会污染全局变量</span><br><span class="line">- 模块之间的依赖关系不明显</span><br><span class="line"></span><br><span class="line">基于上述的原因，就有了对上述问题的解决方案，即是 JavaScript 模块化规范，目前主流的有 CommonJS，AMD，CMD，ES6 Module 这四种规范。</span><br><span class="line"></span><br><span class="line">## Javascript 模块化之 CommonJS</span><br><span class="line"></span><br><span class="line">CommonJS 规范的主要内容有，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中，下面讲述一下 NodeJs 中 CommonJS 的模块化机制。</span><br><span class="line"></span><br><span class="line">### 使用方式</span><br><span class="line"></span><br><span class="line">    // 模块定义 add.jsmodule.eports.add = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 模块定义 decrease.jsmodule.exports.decrease = function(a, b) &#123;</span><br><span class="line">      return a - b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // formula.js,模块使用，利用 require() 方法加载模块,require 导出的即是 module.exports 的内容const add = require(&quot;./add.js&quot;).add;</span><br><span class="line">    const decrease = require(&quot;./decrease.js&quot;).decrease;</span><br><span class="line">    module.exports.square_difference = function(a, b) &#123;</span><br><span class="line">      return add(a, b) * decrease(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### exports 和 module.exports</span><br><span class="line"></span><br><span class="line">exports 和 module.exports 是指向同一个东西的变量，即是 module.exports = exports = &#123;&#125;，所以你也可以这样导出模块</span><br><span class="line"></span><br><span class="line">    //add.js</span><br><span class="line">    exports.add = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是如果直接修改 exports 的指向是无效的，例如:</span><br><span class="line"></span><br><span class="line">    // add.js</span><br><span class="line">    exports = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    // main.jsvar add = require(&quot;./add.js&quot;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">此时得到的 add 是一个空对象，因为 require 导入的是，对应模块的 module.exports 的内容，在上面的代码中，虽然一开始 exports = module.exports，但是当执行如下代码的时候，其实就将 exports 指向了 function,而 module.exports 的内容并没有改变，所以这个模块的导出为空对象。</span><br><span class="line"></span><br><span class="line">    exports = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### CommonJS 在 NodeJs 中的模块加载机制</span><br><span class="line"></span><br><span class="line">以下根据 [NodeJs 中 CommonJS 模块加载源码](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnodejs%2Fnode%2Fblob%2Fmaster%2Flib%2Finternal%2Fmodules%2Fcjs%2Floader.js) 来分析 NodeJS 中模块的加载机制。</span><br><span class="line"></span><br><span class="line">在 NodeJs 中引入模块 (require)，需要经历如下 3 个步骤：</span><br><span class="line"></span><br><span class="line">1. 路径分析</span><br><span class="line">2. 文件定位</span><br><span class="line">3. 编译执行</span><br><span class="line"></span><br><span class="line">与前端浏览器会缓存静态脚本文件以提高性能一样，NodeJs 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的是，浏览器仅缓存文件，而在 NodeJs 中缓存的是编译和执行后的对象。</span><br><span class="line"></span><br><span class="line">#### 路径分析 + 文件定位</span><br><span class="line"></span><br><span class="line">其流程如下图所示：</span><br><span class="line">#### 模块编译</span><br><span class="line"></span><br><span class="line">在定位到文件后，首先会检查该文件是否有缓存，有的话直接读取缓存，否则，会新创建一个 Module 对象，其定义如下：</span><br><span class="line"></span><br><span class="line">    functionModule(id, parent) &#123;</span><br><span class="line">      this.id = id; // 模块的识别符，通常是带有绝对路径的模块文件名。this.exports = &#123;&#125;; // 表示模块对外输出的值this.parent = parent; // 返回一个对象，表示调用该模块的模块。if (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">        this.parent.children.push(this);</span><br><span class="line">      &#125;</span><br><span class="line">      this.filename = null;</span><br><span class="line">      this.loaded = false; // 返回一个布尔值，表示模块是否已经完成加载。this.childrent = []; // 返回一个数组，表示该模块要用到的其他模块。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">require 操作代码如下所示：</span><br><span class="line"></span><br><span class="line">    Module.prototype.require = function(id) &#123;</span><br><span class="line">      // 检查模块标识符if (typeof id !== &quot;string&quot;) &#123;</span><br><span class="line">        thrownew ERR_INVALID_ARG_TYPE(&quot;id&quot;, &quot;string&quot;, id);</span><br><span class="line">      &#125;</span><br><span class="line">      if (id === &quot;&quot;) &#123;</span><br><span class="line">        thrownew ERR_INVALID_ARG_VALUE(&quot;id&quot;, id, &quot;must be a non-empty string&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 调用模块加载方法return Module._load(id, this, /* isMain */false);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">接下来是解析模块路径，判断是否有缓存，然后生成 Module 对象：</span><br><span class="line"></span><br><span class="line">    Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">      if (parent) &#123;</span><br><span class="line">        debug(&quot;Module._load REQUEST %s parent: %s&quot;, request, parent.id);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 解析文件名var filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line">    </span><br><span class="line">      var cachedModule = Module._cache[filename];</span><br><span class="line">    </span><br><span class="line">      // 判断是否有缓存，有的话返回缓存对象的 exportsif (cachedModule) &#123;</span><br><span class="line">        updateChildren(parent, cachedModule, true);</span><br><span class="line">        return cachedModule.exports;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 判断是否为原生核心模块，是的话从内存加载if (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">        debug(&quot;load native module %s&quot;, request);</span><br><span class="line">        return NativeModule.require(filename);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 生成模块对象varmodule = new Module(filename, parent);</span><br><span class="line">    </span><br><span class="line">      if (isMain) &#123;</span><br><span class="line">        process.mainModule = module;</span><br><span class="line">        module.id = &quot;.&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 缓存模块对象</span><br><span class="line">      Module._cache[filename] = module;</span><br><span class="line">    </span><br><span class="line">      // 加载模块</span><br><span class="line">      tryModuleLoad(module, filename);</span><br><span class="line">    </span><br><span class="line">      returnmodule.exports;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">tryModuleLoad 的代码如下所示：</span><br></pre></td></tr></table></figure></p>
<pre><code>functiontryModuleLoad(module, filename) {
  var threw = true;
  try {
    // 调用模块实例load方法module.load(filename);
    threw = false;
  } finally {
    if (threw) {
      // 如果加载出错，则删除缓存delete Module._cache[filename];
    }
  }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块对象执行载入操作 module.load 代码如下所示：</span><br></pre></td></tr></table></figure>
<pre><code>Module.prototype.load = function(filename) {
  debug(&quot;load %j for module %j&quot;, filename, this.id);

  assert(!this.loaded);
  this.filename = filename;

  // 解析路径this.paths = Module._nodeModulePaths(path.dirname(filename));

  // 判断扩展名，并且默认为 .js 扩展var extension = path.extname(filename) || &quot;.js&quot;;

  // 判断是否有对应格式文件的处理函数， 没有的话，扩展名改为 .jsif (!Module._extensions[extension]) extension = &quot;.js&quot;;

  // 调用相应的文件处理方法，并传入模块对象
  Module._extensions[extension](this, filename);
  this.loaded = true;

  // 处理 ES Moduleif (experimentalModules) {
    if (asyncESM === undefined) lazyLoadESM();
    const ESMLoader = asyncESM.ESMLoader;
    const url = pathToFileURL(filename);
    const urlString = `${url}`;
    const exports = this.exports;
    if (ESMLoader.moduleMap.has(urlString) !== true) {
      ESMLoader.moduleMap.set(
        urlString,
        new ModuleJob(ESMLoader, url, async () =&gt; {
          const ctx = createDynamicModule([&quot;default&quot;], url);
          ctx.reflect.exports.default.set(exports);
          return ctx;
        })
      );
    } else {
      const job = ESMLoader.moduleMap.get(urlString);
      if (job.reflect) job.reflect.exports.default.set(exports);
    }
  }
};
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这里同步读取模块，再执行编译操作：</span><br></pre></td></tr></table></figure>
<pre><code>Module._extensions[&quot;.js&quot;] = function(module, filename) {
  // 同步读取文件var content = fs.readFileSync(filename, &quot;utf8&quot;);

  // 编译代码module._compile(stripBOM(content), filename);
};
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译过程主要做了以下的操作：</span><br><span class="line"></span><br><span class="line">1. 将 JavaScript 代码用函数体包装，隔离作用域，例如：</span><br></pre></td></tr></table></figure>
<pre><code>exports.add = (function(a, b) {
  return a + b;
}
</code></pre><p><code>`</code><br>会被转换为</p>
<pre><code>(
  function(exports, require, modules, __filename, __dirname) {
    exports.add = function(a, b) {
      return a + b;
    };
  }
);
</code></pre><ol>
<li><p>执行函数，注入模块对象的 exports 属性，require 全局方法，以及对象实例，<strong>filename, </strong>dirname，然后执行模块的源码。</p>
</li>
<li><p>返回模块对象 exports 属性。</p>
</li>
</ol>
<h2 id="JavaScript-模块化之-AMD"><a href="#JavaScript-模块化之-AMD" class="headerlink" title="JavaScript 模块化之 AMD"></a>JavaScript 模块化之 AMD</h2><p>AMD, Asynchronous Module Definition，即异步模块加载机制，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句都定义在一个回调函数中，等到依赖加载完成之后，这个回调函数才会运行。</p>
<p>AMD 的诞生，就是为了解决这两个问题：</p>
<ol>
<li>实现 JavaScript 文件的异步加载，避免网页失去响应</li>
<li><p>管理模块之间的依赖性，便于代码的编写和维护</p>
<p> // 模块定义<br>  define(id?: String, dependencies?: String[], factory: Function|Object);</p>
</li>
</ol>
<p>id 是模块的名字，它是可选的参数。</p>
<p>dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数。每个依赖的模块的输出都将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。</p>
<p>factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值，如果是对象，此对象应该为模块的输出值。</p>
<p>举个例子：</p>
<pre><code>// 模块定义，add.js
define(function() {
  let add = function(a, b) {
    return a + b;
  };
  return add;
});

// 模块定义，decrease.js
define(function() {
  let decrease = function(a, b) {
    return a - b;
  };
  return decrease;
});

// 模块定义，square.js
define([&quot;./add&quot;, &quot;./decrease&quot;], function(add, decrease) {
  let square = function(a, b) {
    return add(a, b) * decrease(a, b);
  };
  return square;
});

// 模块使用，主入口文件 main.jsrequire([&quot;square&quot;], function(math) {
  console.log(square(6, 3));
});
</code></pre><p>这里用实现了 AMD 规范的 RequireJS 来分析，RequireJS 源码较为复杂，这里只对异步模块加载原理做一个分析。在加载模块的过程中， RequireJS 会调用如下函数：</p>
<pre><code>/**
 *
 * @param {Object} context the require context to find state.
 * @param {String} moduleName the name of the module.
 * @param {Object} url the URL to the module.
 */
req.load = function(context, moduleName, url) {
  var config = (context &amp;&amp; context.config) || {},
    node;
  // 判断是否为浏览器if (isBrowser) {
    // 根据模块名称和 url 创建一个 Script 标签
    node = req.createNode(config, moduleName, url);

    node.setAttribute(&quot;data-requirecontext&quot;, context.contextName);
    node.setAttribute(&quot;data-requiremodule&quot;, moduleName);

    // 对不同的浏览器 Script 标签事件监听做兼容处理if (
      node.attachEvent &amp;&amp;
      !(
        node.attachEvent.toString &amp;&amp;
        node.attachEvent.toString().indexOf(&quot;[native code&quot;) &lt; 0
      ) &amp;&amp;
      !isOpera
    ) {
      useInteractive = true;

      node.attachEvent(&quot;onreadystatechange&quot;, context.onScriptLoad);
    } else {
      node.addEventListener(&quot;load&quot;, context.onScriptLoad, false);
      node.addEventListener(&quot;error&quot;, context.onScriptError, false);
    }

    // 设置 Script 标签的 src 属性为模块路径
    node.src = url;

    if (config.onNodeCreated) {
      config.onNodeCreated(node, config, moduleName, url);
    }

    currentlyAddingScript = node;

    // 将 Script 标签插入到页面中if (baseElement) {
      head.insertBefore(node, baseElement);
    } else {
      head.appendChild(node);
    }
    currentlyAddingScript = null;

    return node;
  } elseif (isWebWorker) {
    try {
      //In a web worker, use importScripts. This is not a very//efficient use of importScripts, importScripts will block until//its script is downloaded and evaluated. However, if web workers//are in play, the expectation is that a build has been done so//that only one script needs to be loaded anyway. This may need//to be reevaluated if other use cases become common.// Post a task to the event loop to work around a bug in WebKit// where the worker gets garbage-collected after calling// importScripts(): https://webkit.org/b/153317
      setTimeout(function() {}, 0);
      importScripts(url);

      //Account for anonymous modules
      context.completeLoad(moduleName);
    } catch (e) {
      context.onError(
        makeError(
          &quot;importscripts&quot;,
          &quot;importScripts failed for &quot; + moduleName + &quot; at &quot; + url,
          e,
          [moduleName]
        )
      );
    }
  }
};

// 创建异步 Script 标签
req.createNode = function(config, moduleName, url) {
  var node = config.xhtml
    ? document.createElementNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;html:script&quot;)
    : document.createElement(&quot;script&quot;);
  node.type = config.scriptType || &quot;text/javascript&quot;;
  node.charset = &quot;utf-8&quot;;
  node.async = true;
  return node;
};
</code></pre><p>可以看出，这里主要是根据模块的 Url，创建了一个异步的 Script 标签，并将模块 id 名称添加到的标签的 data-requiremodule 上，再将这个 Script 标签添加到了 html 页面中。同时为 Script 标签的 load 事件添加了处理函数，当该模块文件被加载完毕的时候，就会触发 context.onScriptLoad。我们在 onScriptLoad 添加断点，可以看到页面结构如下图所示:<br> 由图可以看到，Html 中添加了一个 Script 标签，这也就是异步加载模块的原理。</p>
<h2 id="JavaScript-模块化之-CMD"><a href="#JavaScript-模块化之-CMD" class="headerlink" title="JavaScript 模块化之 CMD"></a>JavaScript 模块化之 CMD</h2><p>CMD (Common Module Definition) 通用模块定义，CMD 在浏览器端的实现有 SeaJS， 和 RequireJS 一样，SeaJS 加载原理也是动态创建异步 Script 标签。二者的区别主要是依赖写法上不同，AMD 推崇一开始就加载所有的依赖，而 CMD 则推崇在需要用的地方才进行依赖加载。</p>
<pre><code>// ADM 在执行以下代码的时候，RequireJS 会首先分析依赖数组，然后依次加载，直到所有加载完毕再执行回到函数
define([&quot;add&quot;, &quot;decrease&quot;], function(add, decrease) {
  let result1 = add(9, 7);
  let result2 = decrease(9, 7);
  console.log(result1 * result2);
});

// CMD 在执行以下代码的时候， SeaJS 会首先用正则匹配出代码里面所有的 require 语句，拿到依赖，然后依次加载，加载完成再执行回调函数
define(function(require) {
  let add = require(&quot;add&quot;);
  let result1 = add(9, 7);
  let add = require(&quot;decrease&quot;);
  let result2 = decrease(9, 7);
  console.log(result1 * result2);
});
</code></pre><h2 id="JavaScript-模块化之-ES-Module"><a href="#JavaScript-模块化之-ES-Module" class="headerlink" title="JavaScript 模块化之 ES Module"></a>JavaScript 模块化之 ES Module</h2><p>ES Module 是在 ECMAScript 6 中引入的模块化功能。模块功能主要由两个命令构成，分别是 export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>
<p>其使用方式如下:</p>
<pre><code>// 模块定义 add.jsexportfunctionadd(a, b) {
  return a + b;
}

// 模块使用 main.jsimport { add } from&quot;./add.js&quot;;
console.log(add(1, 2)); // 3
</code></pre><p>下面讲述几个较为重要的点。</p>
<h3 id="export-和-export-default"><a href="#export-和-export-default" class="headerlink" title="export 和 export default"></a>export 和 export default</h3><p>在一个文件或模块中，export 可以有多个，export default 仅有一个, export 类似于具名导出，而 default 类似于导出一个变量名为 default 的变量。同时在 import 的时候，对于 export 的变量，必须要用具名的对象去承接，而对于 default，则可以任意指定变量名，例如：</p>
<pre><code>// a.jsexportvar a = 2;
 exportvar b = 3 ;
// main.js 在导出的时候必须要用具名变量 a, b 且以解构的方式得到导出变量import {a, b} from&apos;a.js&apos;// √ a= 2, b = 3import a from&apos;a.js&apos;// x// b.js export default 方式const a = 3exportdefault a // 注意不能 export default const a = 3 ,因为这里 default 就相当于一个变量名// 导出import b form &apos;b.js&apos;// √import c form &apos;b.js&apos;// √ 因为 b 模块导出的是 default，对于导出的default，可以用任意变量去承接
</code></pre><h3 id="ES-Module-模块加载和导出过程"><a href="#ES-Module-模块加载和导出过程" class="headerlink" title="ES Module 模块加载和导出过程"></a>ES Module 模块加载和导出过程</h3><p>以如下代码为例子：</p>
<pre><code>// counter.jsexportlet count = 5// display.jsexportfunctionrender() {
   console.log(&apos;render&apos;)
 }
 // main.jsimport { counter } from&apos;./counter.js&apos;;
 import { render } from&apos;./display.js&apos;
 ......// more code
</code></pre><p>在模块加载模块的过程中，主要经历以下几个步骤：</p>
<h4 id="构建-Construction"><a href="#构建-Construction" class="headerlink" title="构建 (Construction)"></a>构建 (Construction)</h4><p>这个过程执行查找，下载，并将文件转化为模块记录 (Module record)。所谓的模块记录是指一个记录了对应模块的语法树，依赖信息，以及各种属性和方法 (这里不是很明白)。同样也是在这个过程对模块记录进行了缓存的操作，下图是一个模块记录表：</p>
<p>下图是缓存记录表：</p>
<h4 id="实例化-Instantiation"><a href="#实例化-Instantiation" class="headerlink" title="实例化 (Instantiation)"></a>实例化 (Instantiation)</h4><p>这个过程会在内存中开辟一个存储空间 (此时还没有填充值)，然后将该模块所有的 export 和 import 了该模块的变量指向这个内存，这个过程叫做链接。其写入 export 示意图如下所示：<br> 然后是链接 import，其示意图如下所示：</p>
<h4 id="赋值-Evaluation"><a href="#赋值-Evaluation" class="headerlink" title="赋值(Evaluation)"></a>赋值(Evaluation)</h4><p>这个过程会执行模块代码，并用真实的值填充上一阶段开辟的内存空间，此过程后 import 链接到的值就是 export 导出的真实值。</p>
<p>根据上面的过程我们可以知道。ES Module 模块 export 和 import 其实指向的是同一块内存，但有一个点需要注意的是，import 处不能对这块内存的值进行修改，而 export 可以，其示意图如下：</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对目前主流的 JavaScript 模块化方案 CommonJs，AMD，CMD, ES Module 进行了学习和了解，并对其中最有代表性的模块化实现 (NodeJs，RequireJS，SeaJS，ES6) 做了一个简单的分析。对于服务端的模块而言，由于其模块都是存储在本地的，模块加载方便，所以通常是采用同步读取文件的方式进行模块加载。而对于浏览器而言，其模块一般是存储在远程网络上的，模块的下载是一个十分耗时的过程，所以通常是采用动态异步脚本加载的方式加载模块文件。另外，无论是客户端还是服务端的 JavaScript 模块化实现，都会对模块进行缓存，以此减少二次加载的开销。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/02/JS-继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/11/02/JS-继承/" itemprop="url">JS 继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-02T22:49:01+08:00">
                2016-11-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>众所周知，在 ES 6 之前没有类的概念，所以不能像 Java 中一个 extends 关键字就搞定了继承关系，需要一些 tricks 来实现，下面就介绍一些比较常用的方法。</p>
<h2 id="一-原型链继承："><a href="#一-原型链继承：" class="headerlink" title="(一) 原型链继承："></a>(一) 原型链继承：</h2><pre><code>function Parent(name) { 
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}
function Child(name) {
    this.name = name;
}

Child.prototype = new Parent(&apos;father&apos;);
Child.prototype.constructor = Child;

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

var child = new Child(&apos;son&apos;);
child.sayName();    // child name: son
</code></pre><p>只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。</p>
<p>这种方法存在两个缺点：</p>
<ol>
<li>子类型无法给超类型传递参数，在面向对象的继承中，我们总希望通过 var child = new Child(‘son’, ‘father’); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent(‘father’) 去调用父类。</li>
<li>Child.prototype.sayName 必须写在 Child.prototype = new Parent(‘father’); 之后，不然就会被覆盖掉。</li>
</ol>
<h2 id="二-类式继承："><a href="#二-类式继承：" class="headerlink" title="(二) 类式继承："></a>(二) 类式继承：</h2><pre><code>function Parent(name) { 
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}
Parent.prototype.doSomthing = function() {
    console.log(&apos;parent do something!&apos;);
}
function Child(name, parentName) {
    Parent.call(this, parentName);
    this.name = name;
}

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

var child = new Child(&apos;son&apos;);
child.sayName();      // child name: son
child.doSomthing();   // TypeError: child.doSomthing is not a function
</code></pre><p>相当于 Parent 这个函数在 Child 函数中执行了一遍，并且将所有与 this 绑定的变量都切换到了 Child 上，这样就克服了第一种方式带来的问题。</p>
<p>缺点：</p>
<ol>
<li>没有原型，每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。</li>
</ol>
<h2 id="三-组合式继承：前两种方式的结合"><a href="#三-组合式继承：前两种方式的结合" class="headerlink" title="(三) 组合式继承：前两种方式的结合"></a>(三) 组合式继承：前两种方式的结合</h2><pre><code>function Parent(name) { 
    this.name = name;
}

Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}
Parent.prototype.doSomething = function() {
    console.log(&apos;parent do something!&apos;);
}
function Child(name, parentName) {
    Parent.call(this, parentName);
    this.name = name;
}

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

Child.prototype = new Parent();      
Child.prototype.construtor = Child;

var child = new Child(&apos;son&apos;);
child.sayName();       // child name: son
child.doSomething();   // parent do something!
</code></pre><p>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<p>这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
<p>组合式继承是 JS 最常用的继承模式，但组合继承使用过程中会被调用两次：一次是创建子类型的时候，另一次是在子类型构造函数的内部。</p>
<pre><code>function Parent(name) { 
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}
Parent.prototype.doSomething = function() {
    console.log(&apos;parent do something!&apos;);
}
function Child(name, parentName) {
    Parent.call(this, parentName);      // 第二次调用
    this.name = name;
}

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

Child.prototype = new Parent();         // 第一次调用
Child.prototype.construtor = Child;

var child = new Child(&apos;son&apos;);
child.sayName();      
child.doSomething();   
</code></pre><p>显然从上述的代码中可以看出，第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了，所以这时候你可能会这样写：</p>
<pre><code>Child.prototype = Parent.prototype;
</code></pre><p>这样写显然是不对的：</p>
<ol>
<li>首先，你这样写的话相当于是子类和父类都指向同一个对象，这时候如果你添加了新的方法给 Child 但实际上 Parent 并不需要，相当于强行给 Parent 添加了一个未知的方法。</li>
<li>其次，仔细想想，这样体现不出继承的多态性，比如此时子类想要重写父类的 getName 的方法，那么父类的方法也就会随之修改，这显然违背了多态性。</li>
</ol>
<p>也就是说我们第一次调用构造函数的时候，其实是不管构造函数里面的内容，所以我们何不 new 一个空函数，将其 prototype 指向 Parent.prototype，代码如下：</p>
<h2 id="四-寄生组合式继承："><a href="#四-寄生组合式继承：" class="headerlink" title="(四) 寄生组合式继承："></a>(四) 寄生组合式继承：</h2><pre><code>function Parent(name) {
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}

function Child(name, parentName) {
    Parent.call(this, parentName);  
    this.name = name;    
}

function create(proto) {
    function F(){}
    F.prototype = proto;
    F.prototype.construtor = F;
    return new F();
}

Child.prototype = create(Parent.prototype);
Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}
Child.prototype.construtor = Child;

var parent = new Parent(&apos;father&apos;);
parent.sayName();    // parent name: father


var child = new Child(&apos;son&apos;, &apos;father&apos;);
child.sayName();     // child name: son
</code></pre><p>这就是所谓的寄生组合式继承方式，跟组合式继承的区别在于，他不需要在一次实例中调用两次父类的构造函数，假如说父类的构造器代码很多，还需要调用两次的话对系统肯定会有影响，寄生组合式继承的思想在于：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</p>
<p>在上面的代码中，我们手动创建了一个 create 函数，但是其实是存在于 Object 对象中，不需要我们手动去创建，所以上面的代码可以改为：</p>
<pre><code>function Parent(name) {
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}

function Child(name, parentName) {
    Parent.call(this, parentName);  
    this.name = name;    
}

function inheritPrototype(Parent, Child) {
    Child.prototype = Object.create(Parent.prototype);   //修改
    Child.prototype.construtor = Child;
}

inheritPrototype(Parent, Child);

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

var parent = new Parent(&apos;father&apos;);
parent.sayName();      // parent name: father

var child = new Child(&apos;son&apos;, &apos;father&apos;);
child.sayName();       // child name: son
</code></pre><h2 id="五-ES-6-继承："><a href="#五-ES-6-继承：" class="headerlink" title="(五) ES 6 继承："></a>(五) ES 6 继承：</h2><p>当然，如果你学习过 ES 6，那么写继承关系就会特别简单，如果你学过 Java 就会发现，ES 6 中的继承跟 Java 太像了，上述的代码可改为：</p>
<pre><code>class Parent {
    constructor(name) {
    this.name = name;
    }
    doSomething() {
    console.log(&apos;parent do something!&apos;);
    }
    sayName() {
    console.log(&apos;parent name:&apos;, this.name);
    }
}

class Child extends Parent {
    constructor(name, parentName) {
    super(parentName);
    this.name = name;
    }
    sayName() {
     console.log(&apos;child name:&apos;, this.name);
    }
}

const child = new Child(&apos;son&apos;, &apos;father&apos;);
child.sayName();            // child name: son
child.doSomething();        // parent do something!

const parent = new Parent(&apos;father&apos;);
parent.sayName();           // parent name: father
</code></pre><p>JavaScript前端开发</p>
<p>JavaScript(ES5)中没有像Java那样类的概念，写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。但是我们可以通过原型链prototype来模拟类，去实现继承的相关功能。下面来看看ES5中实现继承常见的三种方法。代码如下：</p>
<pre><code>/**
 * JavaScript(ES5)中实现继承的几种方法
 */

// 定义基类Person
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// 共享数据
Person.prototype.LEGS_NUM = 2;

// 共享方法
Person.prototype.info = function () {
  console.log(&apos;My name is &apos; + this.name + &apos; .I\&apos;m &apos; + this.age + &apos; years old now&apos;);
};

Person.prototype.walk = function () {
  console.log(this.name + &apos; is walking...&apos;);
};

// Student子类
function Student(name, age, className) {
  // 调用父类
  Person.call(this, name, age);
  this.className = className;
}

// 1⃣️ 方法一：Person.prototype直接赋值给Student.prototype
// Student.prototype = Person.prototype;

// 2⃣️ 方法二：Student.prototype为Person的实例
// Student.prototype = new Person();

// 3⃣️ 方法三：创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype
Student.prototype = Object.create(Person.prototype);

Student.prototype.constructor = Student;

// 覆盖父类的info方法
Student.prototype.info = function () {
  console.log(&apos;My name is &apos; + this.name + &apos;,I\&apos;m &apos; + this.age + &apos; years old now, and from class &apos; + this.className + &apos;.&apos;);
};

// Student类的共享方法
Student.prototype.learn = function (subject) {
  console.log(this.name + &apos; is learning &apos; + subject + &apos;.&apos;);
};

// 测试,创建一个Student的实例
var microzz = new Student(&apos;Microzz&apos;, 22, 5);
microzz.info(); // My name is Microzz,I&apos;m 22 years old now, and from class 5.
console.log(microzz.LEGS_NUM); // 2
microzz.walk(); // Microzz is walking...
microzz.learn(&apos;JavaScript&apos;); // Microzz is learning JavaScript.
console.log(microzz.__proto__.__proto__ === Person.prototype); // true
console.log(microzz.__proto__ === Student.prototype); // true
console.log(microzz.__proto__.constructor === Student); // true
</code></pre><p>三种方法比较</p>
<p>上面代码中有三种方法实现继承，现在我们可以来分析一下这几种方法。<br>1⃣️这种方法中，Person.prototype直接赋值给Student.prototype，但是有一个很严重的问题，如果子类prototype添加新的东西的话也会改写父类。所以这种方法不推荐。<br>2⃣️第二种方法Student.prototype为Person的实例，这也是可以实现的。但是Person构造函数有参数应该传什么呢？传任何一个都是很奇怪的。所以也不推荐。<br>3⃣️第三种方法是比较理想的，创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype。但是Object.create也有一点小瑕疵，因为它是ES5之后才支持的，不过我们可以通过模拟实现Object.create方法。代码如下：</p>
<pre><code>if (!Object.create) {
  Object.prototype.create = function (proto) {
    function F() {}
    F.prototype = proto;
    return new F;
  }
}
</code></pre><p>这样在ES5中就完美实现了继承😄</p>
<h2 id="ES6中的实现"><a href="#ES6中的实现" class="headerlink" title="ES6中的实现"></a>ES6中的实现</h2><p>概述</p>
<p>ES6提供了更接近传统语言”类”的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。下面我们用ES6的语法实现类的继承。</p>
<p>代码</p>
<pre><code>// 基类 Person
class Person {
  // 父类的构造方法
  constructor(name, age) {
    this.name = name;
    this.age = age;
    // 共享变量
    this.LEGS_NUM = 2;
  }
  // 父类的info方法
  info() {
    console.log(`My name is ${this.name}, I\&apos;m ${this.age} years old now.`);
  }

  // 父类的walk方法
  walk() {
    console.log(this.name + &apos; is walking...&apos;);
  }

}

// 子类 Student
class Student extends Person {
  constructor(name, age, className) {
    // 调用基类的构造方法
    super(name, age);
    this.className = className;
  }

  // 覆盖父类的info方法
  info() {
    console.log(`My name is ${this.name}, I\&apos;m ${this.age} years old, and from class ${this.className}.`);
  }
}

// 实例化一个Student的实例
let stu = new Student(&apos;Zhaohui&apos;, 22, 5);
stu.info(); // My name is Zhaohui, I&apos;m 22 years old, and from class 5.
stu.walk(); // Zhaohui is walking...
console.log(stu.LEGS_NUM); // 2
console.log(stu instanceof Student); // true
console.log(stu instanceof Person); // true
</code></pre><p>这样我们就通过ES6中的class实现了“类”的继承了😄</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/31/26个精选的JavaScript面试问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/31/26个精选的JavaScript面试问题/" itemprop="url">26个精选的JavaScript面试问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-31T20:34:53+08:00">
                2016-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JavaScript中，在两个不同类型之间的转换叫做<code>coercion</code>。在JavaScript中有两种形式：显示转换和隐式转换。</p>
<p>下面是一个显示转换的例子：</p>
<pre><code>var a = &quot;42&quot;;
var b = Number( a );
a;              // &quot;42&quot;
b;              // 42 -- the number!
</code></pre><p>下面是一个隐式转换的例子：</p>
<pre><code>var a = &quot;42&quot;;
var b = a * 1;  // &quot;42&quot; implicitly coerced to 42 here
a;              // &quot;42&quot;
b;              // 42 -- the number!
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.fullstack.cafe%2F" target="_blank" rel="noopener">FullStack.Cafe</a></p>
<h3 id="Q2-JavaScript中的作用域是怎样的？"><a href="#Q2-JavaScript中的作用域是怎样的？" class="headerlink" title="Q2: JavaScript中的作用域是怎样的？"></a>Q2: JavaScript中的作用域是怎样的？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐</p>
</blockquote>
<p>在JavaScript中，每一个函数都有各自的作用域(<code>scope</code>)。作用域可以理解为是一个变量的集合以及相应的如何访问它的规则。只有在函数内部的变量才可以访问到该函数域的变量。</p>
<p>在同一个作用域内部，变量名必须要唯一。作用域可以嵌套。在最内部的作用域中，可以访问任何外部的作用域中的变量。</p>
<h3 id="Q3-请解释JavaScript中的相等判断"><a href="#Q3-请解释JavaScript中的相等判断" class="headerlink" title="Q3: 请解释JavaScript中的相等判断"></a>Q3: 请解释JavaScript中的相等判断</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐</p>
</blockquote>
<p>JavaScript中的相等判断有严格判断和带隐式转换的判断两种：</p>
<ul>
<li>严格判断(strict comparision): 比如<code>===</code>，比较的时候不会隐式转换类型；</li>
<li><p>抽象判断(abstract comparasion)：比如<code>==</code>，比较的时候会隐式转换类型。</p>
<p>  var a = “42”;<br>  var b = 42;</p>
<p>  a == b;         // true<br>  a === b;        // false</p>
</li>
</ul>
<p>一些简单的规则：</p>
<ul>
<li>如果两边都是布尔类型的值，使用<code>===</code>;</li>
<li>如果两边是0,<code>&quot;&quot;</code>,<code>[]</code>，使用<code>===</code>;</li>
<li>所有其它类型，使用<code>==</code>是安全的。而且在很多情况下会简化代码、增加可读性。</li>
</ul>
<h3 id="Q4-请解释什么叫做回调函数并提供一个简单的例子"><a href="#Q4-请解释什么叫做回调函数并提供一个简单的例子" class="headerlink" title="Q4: 请解释什么叫做回调函数并提供一个简单的例子"></a>Q4: 请解释什么叫做回调函数并提供一个简单的例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>回调函数是一个函数，它被作为参数传入另一个函数，当某些操作结束后，该函数被调用。下面是一个简单的例子，当数组被修改后，调用回调函数打印一行日志。</p>
<pre><code>functionmodifyArray(arr, callback) {
  // do something to arr here
  arr.push(100);
  // then execute the callback function that was passed
  callback();
}

var arr = [1, 2, 3, 4, 5];
modifyArray(arr, function() {
  console.log(&quot;array has been modified&quot;, arr);
});
</code></pre><h3 id="Q5-“use-strict”到底有何用处？"><a href="#Q5-“use-strict”到底有何用处？" class="headerlink" title="Q5: “use strict”到底有何用处？"></a>Q5: “use strict”到底有何用处？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p><code>use strict</code>放在文件的顶部或则函数的第一行来启动更加严格的检查来避免失误引起的错误。比如，下面的代码会抛出错误：</p>
<pre><code>functiondoSomething(val) {
  &quot;use strict&quot;; 
  x = val + 10;
}
</code></pre><p>因为x没有定义，如果使用了<code>use strict</code>，x是不会被当做全局的变量来看待。下面的代码修复了这个BUG：</p>
<pre><code>functiondoSomething(val) {
  &quot;use strict&quot;; 
  var x = val + 10;
}
</code></pre><h3 id="Q6-请解释Null和Undefined"><a href="#Q6-请解释Null和Undefined" class="headerlink" title="Q6: 请解释Null和Undefined"></a>Q6: 请解释Null和Undefined</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>JavaScript和TypeScript有两个最基本的类型<code>null</code>和<code>undefined</code>。它们的含义是不同的：</p>
<ul>
<li>如果还没有被初始化，则是<code>undefined</code>;</li>
<li>如果不可用，则可以用<code>null</code>来表示；</li>
</ul>
<h3 id="Q7-请实现如下函数"><a href="#Q7-请实现如下函数" class="headerlink" title="Q7: 请实现如下函数"></a>Q7: 请实现如下函数</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<pre><code>var addSix = createBase(6);
addSix(10); // returns 16
addSix(21); // returns 27
</code></pre><p><code>addSix</code>是一个函数，也就是说createBase函数的返回是一个函数。</p>
<pre><code>functioncreateBase(baseNumber) {
  returnfunction(N) {
    // we are referencing baseNumber here even though it was declared// outside of this function. Closures allow us to do this in JavaScriptreturn baseNumber + N;
  }
}

var addSix = createBase(6);
addSix(10);
addSix(21);
</code></pre><h3 id="Q8-请解释JavaScript中的值和类型"><a href="#Q8-请解释JavaScript中的值和类型" class="headerlink" title="Q8: 请解释JavaScript中的值和类型"></a>Q8: 请解释JavaScript中的值和类型</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>下面是JavaScript内置的可用类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null和undefined</li>
<li>object</li>
<li>symbol (ES6的新语法)</li>
</ul>
<h3 id="Q9-请解释事件冒泡以及如何阻止它？"><a href="#Q9-请解释事件冒泡以及如何阻止它？" class="headerlink" title="Q9: 请解释事件冒泡以及如何阻止它？"></a>Q9: 请解释事件冒泡以及如何阻止它？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>事件冒泡的概念是指：在最内层的元素上绑定的事件被触发后，会按照嵌套的层次由内向外逐步触发。因此，点击某个孩子节点可能会触发父节点的事件。</p>
<p>一个阻止事件冒泡的办法就是使用<code>event.stopPropagation()</code>，在IE&lt;9的浏览器上使用<code>event.cancelBubble()</code>。</p>
<p>来源：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkennymkchan" target="_blank" rel="noopener">github.com/kennymkchan</a></p>
<h3 id="Q10-请解释JavaScript中的let关键字"><a href="#Q10-请解释JavaScript中的let关键字" class="headerlink" title="Q10. 请解释JavaScript中的let关键字"></a>Q10. 请解释JavaScript中的let关键字</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>ES6允许你使用let关键字来申明块作用域(<code>{...}</code>)的变量。</p>
<p>来源: <a href="https://link.juejin.im?target=github.com%2Fgetify" target="_blank" rel="noopener">github.com/getify</a></p>
<h3 id="Q11-如何检查一个数字是否是整数？"><a href="#Q11-如何检查一个数字是否是整数？" class="headerlink" title="Q11: 如何检查一个数字是否是整数？"></a>Q11: 如何检查一个数字是否是整数？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>一个最简单的方法是判断除以1的余数是否为0.</p>
<pre><code>functionisInt(num) {
  return num % 1 === 0;
}

console.log(isInt(4)); // trueconsole.log(isInt(12.2)); // falseconsole.log(isInt(0.3)); // false
</code></pre><p>来源: <a href="https://link.juejin.im?target=coderbyte.com" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q12-什么叫IIFEs-Immediately-Invoked-Function-Expressions"><a href="#Q12-什么叫IIFEs-Immediately-Invoked-Function-Expressions" class="headerlink" title="Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)?"></a>Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)?</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>IIFE叫做立即执行表达式，顾名思义，该表达式一被创建就立即执行。</p>
<pre><code>(functionIIFE(){
    console.log( &quot;Hello!&quot; );
})();
// &quot;Hello!&quot;
</code></pre><p>该方法常用语避免污染全局的命名空间，因为所以在IIFE中使用的变量外部都无法访问。</p>
<p>来源: <a href="https://link.juejin.im?target=stackoverflow.com" target="_blank" rel="noopener">stackoverflow.com</a></p>
<h3 id="Q13-如果比较JavaScript中的两个对象？"><a href="#Q13-如果比较JavaScript中的两个对象？" class="headerlink" title="Q13: 如果比较JavaScript中的两个对象？"></a>Q13: 如果比较JavaScript中的两个对象？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>两个非基本类型的值，比如对象(包括函数和数组)都是通过引用的形式来访问。如果直接通过<code>==</code>和<code>===</code>来判断，那么只会简单的判断其引用地址是否相同，而不是它们实际对应的值。</p>
<p>如果数组和字符串做比较，那么数组会通过逗号拼接转换为字符串。通过等号判断的时候，两个相同的数组不会相等，但是和相同数据的字符串比较反而相等。</p>
<pre><code>var a = [1,2,3];
var b = [1,2,3];
var c = &quot;1,2,3&quot;;

a == c;     // true
b == c;     // true
a == b;     // false
</code></pre><p>如果要深度比较，可以使用第三方库，比如<code>deep-equal</code>或则你自己实现一个比较算法。</p>
<h3 id="Q14-请解释ES5和ES6的不同点"><a href="#Q14-请解释ES5和ES6的不同点" class="headerlink" title="Q14: 请解释ES5和ES6的不同点"></a>Q14: 请解释ES5和ES6的不同点</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<ul>
<li>ECMAScript 5 (ES5): 第5个ECMAScript版本，于2009年标准化。该标准几乎所有的浏览器都完全支持。</li>
<li>ECMAScript 6 (ES6)/ECMAScript 2015 (ES2015):  第6个ECMAScript版本，于2015年标准化。目前各大浏览器还只是部分支持。</li>
</ul>
<p>接下来介绍它们主要的区别：</p>
<ul>
<li><p>箭头函数和字符串嵌入：</p>
<p>  const greetings = (name) =&gt; {</p>
<pre><code>return`hello ${name}`;
</code></pre><p>  }</p>
</li>
</ul>
<p>甚至：</p>
<pre><code>const greetings = name =&gt;`hello ${name}`;
</code></pre><ul>
<li><p>常量声明(Const): 如同其它编程语言中的常量一样，但又有不同。这里的<code>const</code>代表了<code>constant reference</code>。也就是说，你可以修改其指向的对象的值。但是你不能修改其reference的值。</p>
<p>  const NAMES = [];<br>  NAMES.push(“Jim”);<br>  console.log(NAMES.length === 1); // true<br>  NAMES = [“Steve”, “John”]; // error</p>
</li>
<li><p>块作用域变量：ES6中的新关键字<code>let</code>允许允许开发者将变量的作用域限定在块级别。不会像<code>var</code>一样变量提升。</p>
</li>
<li><p>参数默认值：允许在函数定义的时候指定默认的值。</p>
<p>  // Basic syntaxfunctionmultiply (a, b = 2) {</p>
<pre><code>return a * b;
</code></pre><p>  }<br>  multiply(5); // 10</p>
</li>
<li><p>类定义和继承</p>
</li>
</ul>
<p>ES6开始支持定义类(使用<code>class</code>关键字)，构造函数(使用<code>constructor</code>关键字)，和<code>extend</code>关键字来实现继承。</p>
<ul>
<li>for-of操作</li>
</ul>
<p><code>for...of</code>语句用来迭代访问一个对象的所有属性。</p>
<ul>
<li><p>Spread操作符：用于对象合并</p>
<p>  const obj1 = { a: 1, b: 2 }<br>  const obj2 = { a: 2, c: 3, d: 4}<br>  const obj3 = {…obj1, …obj2}</p>
</li>
</ul>
<ul>
<li><p>Promise: Promises提供了一个处理异步操作的方法。你可以用回调函数来实现，但是Promise更加简洁和可读。</p>
<p>  const isGreater = (a, b) =&gt; {</p>
<pre><code>returnnewPromise ((resolve, reject) =&gt; {
  if(a &gt; b) {
    resolve(true)
  } else {
    reject(false)
  }
  })
</code></pre><p>  }<br>  isGreater(1, 2)</p>
<pre><code>.then(result =&gt; {
  console.log(&apos;greater&apos;)
})
</code></pre><p>   .catch(result =&gt; {</p>
<pre><code>console.log(&apos;smaller&apos;)
</code></pre><p>   })</p>
</li>
</ul>
<ul>
<li><p>模块的export和import。</p>
<p>  const myModule = { x: 1, y: () =&gt; { console.log(‘This is ES5’) }}<br>  exportdefault myModule;</p>
</li>
</ul>
<pre><code>import myModule from&apos;./myModule&apos;;
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.to%2Faershov24%2Fundefined" target="_blank" rel="noopener">Bulby.io</a></p>
<h3 id="Q15-请解释undefined和not-defined的区别"><a href="#Q15-请解释undefined和not-defined的区别" class="headerlink" title="Q15: 请解释undefined和not defined的区别"></a>Q15: 请解释<code>undefined</code>和<code>not defined</code>的区别</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<p>在JavaScript中，如果你尝试使用不存在的还未申明的变量，JavaScript会抛出错误<code>var name is not defined</code>。但是如果你用<code>typeof</code>来查看其类型，会返回<code>undefined</code>。</p>
<p>我们先来澄清一下声明和定义的区别：<code>var x</code>是一个声明，因为你并没有定义其具体的值，你只是声明其存在性。</p>
<pre><code>var x; // declaring xconsole.log(x); //output: undefined
</code></pre><p><code>var x = 1</code>同时兼具声明和定义，我们也可以叫它初始化。在JavaScript中，每一个变量和函数声明都会被提升到顶部。</p>
<p>如果我们访问一个声明了但是未定义的变量，会返回<code>undefined</code>。</p>
<pre><code>var x; // Declarationif(typeof x === &apos;undefined&apos;) // Will return true
</code></pre><blockquote>
<p>访问一个未声明未定义的变量，会返回not defined错误。</p>
</blockquote>
<pre><code>console.log(y);  // Output: ReferenceError: y is not defined
</code></pre><p>来源: <a href="https://link.juejin.im?target=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F20822022%2Fjavascript-variable-definition-declaration" target="_blank" rel="noopener">stackoverflow.com</a></p>
<h3 id="Q16-匿名函数和命名函数的区别？"><a href="#Q16-匿名函数和命名函数的区别？" class="headerlink" title="Q16: 匿名函数和命名函数的区别？"></a>Q16: 匿名函数和命名函数的区别？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<pre><code>var foo = function() { // anonymous function assigned to variable foo// ..
};

var x = functionbar(){ // named function (bar) assigned to variable x // ..
};

foo(); // actual function execution
x();
</code></pre><p>译者补充：匿名函数如果不赋值给某个变量，则无法被调用了；命名函数再次被赋值不是多此一举么。</p>
<h3 id="Q17-JavaScript中闭包是什么？请提供一个例子"><a href="#Q17-JavaScript中闭包是什么？请提供一个例子" class="headerlink" title="Q17: JavaScript中闭包是什么？请提供一个例子"></a>Q17: JavaScript中闭包是什么？请提供一个例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>闭包是一个定义在其它函数(父函数)里面的函数，它拥有对父函数里面变量的访问权。闭包拥有如下三个作用域的访问权：</p>
<ul>
<li>自身的作用域</li>
<li>父作用域</li>
<li><p>全局作用域</p>
<p>  var globalVar = “abc”;</p>
<p>  // Parent self invoking function<br>  (functionouterFunction (outerArg) { // begin of scope outerFunction// Variable declared in outerFunction function scopevar outerFuncVar = ‘x’;    </p>
<pre><code>// Closure self-invoking function
(functioninnerFunction (innerArg) { // begin of scope innerFunction// variable declared in innerFunction function scopevar innerFuncVar = &quot;y&quot;;
  console.log(         
    &quot;outerArg = &quot; + outerArg + &quot;\n&quot; +
    &quot;outerFuncVar = &quot; + outerFuncVar + &quot;\n&quot; +
    &quot;innerArg = &quot; + innerArg + &quot;\n&quot; +
    &quot;innerFuncVar = &quot; + innerFuncVar + &quot;\n&quot; +
    &quot;globalVar = &quot; + globalVar);
// end of scope innerFunction
})(5); // Pass 5 as parameter// end of scope outerFunction
</code></pre><p>  })(7); // Pass 7 as parameter</p>
</li>
</ul>
<p><code>innerFunction</code>是一个闭包，定义在<code>outerFunction</code>中，它可以访问<code>outerFunction</code>作用域的所有变量。当然，它还可以访问全局变量。</p>
<p>输出结果如下：</p>
<pre><code>outerArg = 7
outerFuncVar = x
innerArg = 5
innerFuncVar = y
globalVar = abc
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fganqqwerty%2F123-Essential-JavaScript-Interview-Question%2Fblob%2Fmaster%2FREADME.md" target="_blank" rel="noopener">github.com/ganqqwerty</a></p>
<h3 id="Q18-在JavaScript中如何创建私有变量？"><a href="#Q18-在JavaScript中如何创建私有变量？" class="headerlink" title="Q18: 在JavaScript中如何创建私有变量？"></a>Q18: 在JavaScript中如何创建私有变量？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>你可以通过在函数中声明变量来创建私有变量。因为在函数中，外部无法直接访问。</p>
<pre><code>functionfunc() {
  var priv = &quot;secret code&quot;;
}

console.log(priv); // throws error
</code></pre><p>为了访问该变量，可以构造一个帮助函数来返回该值。</p>
<pre><code>functionfunc() {
  var priv = &quot;secret code&quot;;
  returnfunction() {
    return priv;
  }
}

var getPriv = func();
console.log(getPriv()); // =&gt; secret code
</code></pre><p>来源:<a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q19-请解释原型模式-Prototype-Design-Pattern"><a href="#Q19-请解释原型模式-Prototype-Design-Pattern" class="headerlink" title="Q19: 请解释原型模式(Prototype Design Pattern)"></a>Q19: 请解释原型模式(Prototype Design Pattern)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>原型模式会创建一个新的对象，但不是创建一个未初始化的对象，而是通过拷贝原型链上的值或则被拷贝对象的值来完成初始化。传统的语言很少使用原型模式，但是JavaScript作为一个基于原型的语言，使用原型模式来创建新的对象。</p>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.dofactory.com%2Fjavascript%2Fprototype-design-pattern" target="_blank" rel="noopener">dofactory.com</a></p>
<h3 id="Q20-判断给定的字符串是否同态-isomorphic"><a href="#Q20-判断给定的字符串是否同态-isomorphic" class="headerlink" title="Q20: 判断给定的字符串是否同态(isomorphic)"></a>Q20: 判断给定的字符串是否同态(isomorphic)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>首先介绍什么叫做同态：两个字符串，如果A字符串中的每一个字符都可以在B字符串中找到唯一对应，并且顺序一一对应；如果存在这样的函数，那么A和B同态。</p>
<ul>
<li><code>paper</code>和<code>title</code>同态</li>
<li><code>egg</code>和<code>sad</code>不同态</li>
<li><p><code>dgg</code>和<code>add</code>同态</p>
<p>  isIsomorphic(“egg”, ‘add’); // true<br>  isIsomorphic(“paper”, ‘title’); // true<br>  isIsomorphic(“kick”, ‘side’); // falsefunctionisIsomorphic(firstString, secondString) {</p>
<pre><code>// Check if the same length. If not, they cannot be isomorphicif (firstString.length !== secondString.length) returnfalsevar letterMap = {};

for (var i = 0; i &lt; firstString.length; i++) {
  var letterA = firstString[i],
      letterB = secondString[i];

  // If the letter does not exist, create a map and map it to the value// of the second letterif (letterMap[letterA] === undefined) {
    letterMap[letterA] = letterB;
  } elseif (letterMap[letterA] !== letterB) {
    // Eles if letterA already exists in the map, but it does not map to// letterB, that means that A is mapping to more than one letter.returnfalse;
  }
}
// If after iterating through and conditions are satisfied, return true.// They are isomorphicreturntrue;
</code></pre><p>  }</p>
</li>
</ul>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkennymkchan%2Finterview-questions-in-javascript" target="_blank" rel="noopener">github.com/kennymkchan</a></p>
<h3 id="Q21-Transpiling代表了什么意思？"><a href="#Q21-Transpiling代表了什么意思？" class="headerlink" title="Q21: Transpiling代表了什么意思？"></a>Q21: <code>Transpiling</code>代表了什么意思？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p><code>Transpiling</code>是<code>transforming + compiling</code>的合成词。对于一些新的语法，浏览器还不支持。最好的办法就是将其变换到旧的等价的代码，这个过程通常叫做<code>transpiling</code>。</p>
<p>典型的，你可以在<code>build</code>的过程中加入<code>transpiler</code>，就如同<code>code linter</code>和<code>minifier</code>一样。</p>
<p>已经有很多知名的transpilers可供使用：</p>
<ul>
<li>Babel: 将ES6编译到ES5</li>
<li>Traceur：将ES6,ES7等编译到ES5</li>
</ul>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2Fmaster%2Fup%2520%2526%2520going%2Fch2.md" target="_blank" rel="noopener">You Don’t Know JS, Up &amp;going</a></p>
<h3 id="Q22-this关键字如何工作？请提供一些例子"><a href="#Q22-this关键字如何工作？请提供一些例子" class="headerlink" title="Q22: this关键字如何工作？请提供一些例子"></a>Q22: <code>this</code>关键字如何工作？请提供一些例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>在JavaScript中，this总是指向函数的“拥有者”(也就是指向该函数的对象)，或则拥有该函数的对象。</p>
<pre><code>functionfoo() {
    console.log( this.bar );
}

var bar = &quot;global&quot;;

var obj1 = {
    bar: &quot;obj1&quot;,
    foo: foo
};

var obj2 = {
    bar: &quot;obj2&quot;
};

foo();          // &quot;global&quot;
obj1.foo();     // &quot;obj1&quot;
foo.call( obj2 );  // &quot;obj2&quot;new foo();       // undefined
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.quirksmode.org%2Fjs%2Fthis.html" target="_blank" rel="noopener">quirksmode.org</a></p>
<h3 id="Q23-如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。"><a href="#Q23-如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。" class="headerlink" title="Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。"></a>Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<pre><code>var arr = [1, 2, 3, 4, 5];
var avg = arr.average();
console.log(avg);
</code></pre><p>JavaScript是一个基于原型的语言。也就是说对象之间通过原型链接，并继承其函数。为了给Array对象添加函数，我们可以修改其原型定义<code>Array prorotype</code>。</p>
<pre><code>Array.prototype.average = function() {
  // calculate sumvar sum = this.reduce(function(prev, cur) { return prev + cur; });
  // return sum divided by number of elementsreturn sum / this.length;
}

var arr = [1, 2, 3, 4, 5];
var avg = arr.average();
console.log(avg); // =&gt; 3
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q24-JavaScript中提升-hoisting-是什么意思？"><a href="#Q24-JavaScript中提升-hoisting-是什么意思？" class="headerlink" title="Q24: JavaScript中提升(hoisting)是什么意思？"></a>Q24: JavaScript中提升(hoisting)是什么意思？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>提升(hoisting)是指JavaScript的解释器将所有的变量和函数声明都提升到该作用域的顶部，有两种提升类型：</p>
<ul>
<li>变量提升</li>
<li>函数提升</li>
</ul>
<p>在一个作用域中通过声明的变量和函数在整个作用域中都可以使用。</p>
<pre><code>var a = 2;
foo();                 // works because `foo()`// declaration is &quot;hoisted&quot;functionfoo() {
    a = 3;
    console.log( a );   // 3var a;             // declaration is &quot;hoisted&quot;// to the top of `foo()`
}

console.log( a );   // 2
</code></pre><p>虽然<code>foo()</code>函数在后面定义，但是在前面也可以调用。</p>
<h3 id="Q25-如下代码会返回什么结果？"><a href="#Q25-如下代码会返回什么结果？" class="headerlink" title="Q25: 如下代码会返回什么结果？"></a>Q25: 如下代码会返回什么结果？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<pre><code>0.1 + 0.2 === 0.3
</code></pre><p>不要惊讶，其结果是false。因为浮点数在系统内的精确度问题，0.1+0.2的结果并不是0.3，而是0.30000000000000004。<br>要避免这个问题的方法是指定返回结果的小数位数。</p>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q26-请描述一下揭示模式-Revealing-Module-Pattern"><a href="#Q26-请描述一下揭示模式-Revealing-Module-Pattern" class="headerlink" title="Q26: 请描述一下揭示模式(Revealing Module Pattern)"></a>Q26: 请描述一下揭示模式(Revealing Module Pattern)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<p><strong>Module pattern</strong>的一个变种是<code>Revealing Module Pattern</code>。该设计模式的目的是做到很好的代码隔离，只是将需要对外公开的变量和函数暴露出来。一个直接的实现如下所示：</p>
<pre><code>var Exposer = (function() {
  var privateVariable = 10;

  var privateMethod = function() {
    console.log(&apos;Inside a private method!&apos;);
    privateVariable++;
  }

  var methodToExpose = function() {
    console.log(&apos;This is a method I want to expose!&apos;);
  }

  var otherMethodIWantToExpose = function() {
    privateMethod();
  }

  return {
      first: methodToExpose,
      second: otherMethodIWantToExpose
  };
})();

Exposer.first();        // Output: This is a method I want to expose!
Exposer.second();       // Output: Inside a private method!
Exposer.methodToExpose; // undefined
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/28/JSBridge的原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/28/JSBridge的原理/" itemprop="url">JSBridge的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-28T10:21:44+08:00">
                2016-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。</p>
<p>当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。<br><img src="/2016/10/28/JSBridge的原理/1.webp" alt=""><br><img src="/2016/10/28/JSBridge的原理/2.webp" alt=""></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h1><p>有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。</p>
<h1 id="2-JSBridge-的起源"><a href="#2-JSBridge-的起源" class="headerlink" title="2 JSBridge 的起源"></a><strong>2 JSBridge 的起源</strong></h1><p>为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？</p>
<p>当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的 <strong>最易编写</strong> 、 <strong>最易维护</strong> 、<strong>最易部署</strong> 的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。</p>
<p>因此，<strong>开发维护成本</strong> 和 <strong>更新成本</strong> 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。</p>
<p>PhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。</p>
<p>移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上：</p>
<p>基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案</p>
<p>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native</p>
<p>【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。</p>
<h1 id="3-JSBridge-的用途"><a href="#3-JSBridge-的用途" class="headerlink" title="3 JSBridge 的用途"></a><strong>3 JSBridge 的用途</strong></h1><p>JSBridge 简单来讲，主要是 <strong>给 JavaScript 提供调用 Native 功能的接口</strong>，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。</p>
<p>既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 <strong>构建 Native 和非 Native 间消息通信的通道</strong>，而且是 <strong>双向通信的通道</strong>。<br><img src="/2016/10/28/JSBridge的原理/3.webp" alt=""><br>所谓 <strong>双向通信的通道</strong>:</p>
<ul>
<li>JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。</li>
<li>Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</li>
</ul>
<p>这里有些同学有疑问了：<em>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</em><br>对于这个问题，在下一节里会给出解释。</p>
<h1 id="4-JSBridge-的实现原理"><a href="#4-JSBridge-的实现原理" class="headerlink" title="4 JSBridge 的实现原理"></a><strong>4 JSBridge 的实现原理</strong></h1><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。</p>
<p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：<strong>通信调用（Native 与 JS 通信）</strong> 和 <strong>句柄解析调用</strong>。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）</p>
<p>通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 <strong>Hybrid 方案</strong> 为案例从这几点来剖析 JSBridge 的实现原理。</p>
<h2 id="4-1-JSBridge-的通信原理"><a href="#4-1-JSBridge-的通信原理" class="headerlink" title="4.1 JSBridge 的通信原理"></a><strong>4.1 JSBridge 的通信原理</strong></h2><p>Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。</p>
<h3 id="4-1-1-JavaScript-调用-Native"><a href="#4-1-1-JavaScript-调用-Native" class="headerlink" title="4.1.1 JavaScript 调用 Native"></a><strong>4.1.1 JavaScript 调用 Native</strong></h3><p>JavaScript 调用 Native 的方式，主要有两种：<font color="#ff0000"><strong>注入 API</strong> </font> 和 <font color="#ff0000"> <strong>拦截 URL SCHEME</strong> </font>。</p>
<h4 id="4-1-1-1-注入API"><a href="#4-1-1-1-注入API" class="headerlink" title="4.1.1.1 注入API"></a><strong>4.1.1.1 注入API</strong></h4><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p>
<p>对于 iOS 的 UIWebView，实例如下：</p>
<pre><code>JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) {
    // Native 逻辑
};
</code></pre><p>前端调用方式：</p>
<pre><code>window.postBridgeMessage(message);
</code></pre><p>对于 iOS 的 WKWebView 可以用以下方式：</p>
<pre><code>@interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt;

@implementation WKWebVIewVC

- (void)viewDidLoad {
    [super viewDidLoad];

    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];
    configuration.userContentController = [[WKUserContentController alloc] init];
    WKUserContentController *userCC = configuration.userContentController;
    // 注入对象，前端调用其方法时，Native 可以捕获到
    [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;];

    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];

    // TODO 显示 WebView
}

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) {
        NSLog(@&quot;前端传递的数据 %@: &quot;,message.body);
        // Native 逻辑
    }
}
</code></pre><p>前端调用方式：</p>
<pre><code>window.webkit.messageHandlers.nativeBridge.postMessage(message);
</code></pre><p>对于 Android 可以采用下面的方式：</p>
<pre><code>publicclassJavaScriptInterfaceDemoActivityextendsActivity{
private WebView Wv;

    @Override
    publicvoidonCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);

        Wv = (WebView)findViewById(R.id.webView);     
        final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);         

        Wv.getSettings().setJavaScriptEnabled(true);
        Wv.addJavascriptInterface(myJavaScriptInterface, &quot;nativeBridge&quot;);

        // TODO 显示 WebView

    }

    publicclassJavaScriptInterface{
         Context mContext;

         JavaScriptInterface(Context c) {
             mContext = c;
         }

         publicvoidpostMessage(String webMessage){            
             // Native 逻辑
         }
     }
}
</code></pre><p>前端调用方式：</p>
<pre><code>window.nativeBridge.postMessage(message);
</code></pre><p>在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 <strong>有兼容性问题的</strong>。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。）</p>
<h4 id="4-1-1-2-拦截-URL-SCHEME"><a href="#4-1-1-2-拦截-URL-SCHEME" class="headerlink" title="4.1.1.2 拦截 URL SCHEME"></a><strong>4.1.1.2 拦截 URL SCHEME</strong></h4><p>先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=<a href="https://link.juejin.im?target=http%3A%2F%2Fymfe.tech" target="_blank" rel="noopener">ymfe.tech</a>，protocol 是 qunarhy，host 则是 hy。</p>
<p>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p>
<p>在时间过程中，这种方式有一定的 <strong>缺陷</strong>：</p>
<ul>
<li><font color="#dd0000"><strong> 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</strong></font>
</li>
<li><font color="#dd0000"><strong>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</strong></font>

</li>
</ul>
<p>但是之前为什么很多方案使用这种方式呢？因为它 <strong>支持 iOS6</strong>。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 <strong>并不优雅</strong> 的方式。</p>
<p>【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。</p>
<p>【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。</p>
<h3 id="4-1-2-Native-调用-JavaScript"><a href="#4-1-2-Native-调用-JavaScript" class="headerlink" title="4.1.2 Native 调用 JavaScript"></a><strong>4.1.2 Native 调用 JavaScript</strong></h3><p>相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。</p>
<p>Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）</p>
<p>对于 iOS 的 UIWebView，示例如下：</p>
<pre><code>result = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];
</code></pre><p>对于 iOS 的 WKWebView，示例如下：</p>
<pre><code>[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];
</code></pre><p>对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现：</p>
<pre><code>webView.loadUrl(&quot;javascript:&quot; + javaScriptString);
</code></pre><p>而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现：</p>
<pre><code>webView.evaluateJavascript(javaScriptString, new ValueCallback&lt;String&gt;() {
    @Override
    publicvoidonReceiveValue(String value){

    }
});
</code></pre><p>【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。</p>
<h3 id="4-1-3-通信原理小总结"><a href="#4-1-3-通信原理小总结" class="headerlink" title="4.1.3 通信原理小总结"></a><strong>4.1.3 通信原理小总结</strong></h3><p>通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下：</p>
<ul>
<li><p>JavaScript 调用 Native 推荐使用 <strong>注入 API</strong> 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。</p>
</li>
<li><p>Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。</p>
</li>
</ul>
<p>对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。</p>
<p>以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 <strong>为了与 Native 开发里事件响应机制一致</strong>，设计成 <strong>需要在 Object-C 去调 JavaScript 时才通过返回值触发调用</strong>。原理基本一样，只是实现方式不同。</p>
<p>当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。</p>
<h2 id="4-2-JSBridge-接口实现"><a href="#4-2-JSBridge-接口实现" class="headerlink" title="4.2 JSBridge 接口实现"></a><strong>4.2 JSBridge 接口实现</strong></h2><p>从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：<strong>调用 Native（给 Native 发消息）</strong> 和 <strong>接被 Native 调用（接收 Native 消息）</strong>。因此，JSBridge 可以设计如下：</p>
<pre><code>window.JSBridge = {
    // 调用 Native
    invoke: function(msg) {
        // 判断环境，获取不同的 nativeBridge
        nativeBridge.postMessage(msg);
    },
    receiveMessage: function(msg) {
        // 处理 msg
    }
};
</code></pre><p>在上面的文章中，提到过 RPC 中有一个非常重要的环节是 <strong>句柄解析调用</strong> ，这点在 JSBridge 中体现为 <strong>句柄与功能对应关系</strong>。同时，我们将句柄抽象为 <strong>桥名（BridgeName）</strong>，最终演化为 <strong>一个 BridgeName 对应一个 Native 功能或者一类 Native 消息</strong>。 基于此点，JSBridge 的实现可以优化为如下：</p>
<pre><code>window.JSBridge = {
    // 调用 Native
    invoke: function(bridgeName, data) {
        // 判断环境，获取不同的 nativeBridge
        nativeBridge.postMessage({
            bridgeName: bridgeName,
            data: data || {}
        });
    },
    receiveMessage: function(msg) {
        var bridgeName = msg.bridgeName,
            data = msg.data || {};
        // 具体逻辑
    }
};
</code></pre><p>JSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：<strong>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</strong></p>
<p>对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释：</p>
<blockquote>
<p>当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 <strong>当前页面唯一</strong> 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。</p>
</blockquote>
<p>由此可见，callback 参数这个 <strong>唯一标识</strong> 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。</p>
<pre><code>(function () {
    var id = 0,
        callbacks = {};

    window.JSBridge = {
        // 调用 Native
        invoke: function(bridgeName, callback, data) {
            // 判断环境，获取不同的 nativeBridge
            var thisId = id ++; // 获取唯一 id
            callbacks[thisId] = callback; // 存储 Callback
            nativeBridge.postMessage({
                bridgeName: bridgeName,
                data: data || {},
                callbackId: thisId // 传到 Native 端
            });
        },
        receiveMessage: function(msg) {
            var bridgeName = msg.bridgeName,
                data = msg.data || {},
                callbackId = msg.callbackId; // Native 将 callbackId 原封不动传回
            // 具体逻辑
            // bridgeName 和 callbackId 不会同时存在
            if (callbackId) {
                if (callbacks[callbackId]) { // 找到相应句柄
                    callbacks[callbackId](msg.data); // 执行调用
                }
            } elseif (bridgeName) {

            }
        }
    };
})();
</code></pre><p>最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下：</p>
<pre><code>(function () {
    var id = 0,
        callbacks = {},
        registerFuncs = {};

    window.JSBridge = {
        // 调用 Native
        invoke: function(bridgeName, callback, data) {
            // 判断环境，获取不同的 nativeBridge
            var thisId = id ++; // 获取唯一 id
            callbacks[thisId] = callback; // 存储 Callback
            nativeBridge.postMessage({
                bridgeName: bridgeName,
                data: data || {},
                callbackId: thisId // 传到 Native 端
            });
        },
        receiveMessage: function(msg) {
            var bridgeName = msg.bridgeName,
                data = msg.data || {},
                callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回
                responstId = msg.responstId;
            // 具体逻辑
            // bridgeName 和 callbackId 不会同时存在
            if (callbackId) {
                if (callbacks[callbackId]) { // 找到相应句柄
                    callbacks[callbackId](msg.data); // 执行调用
                }
            } elseif (bridgeName) {
                if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄
                    var ret = {},
                        flag = false;
                    registerFuncs[bridgeName].forEach(function(callback) =&gt; {
                        callback(data, function(r) {
                            flag = true;
                            ret = Object.assign(ret, r);
                        });
                    });
                    if (flag) {
                        nativeBridge.postMessage({ // 回调 Native
                            responstId: responstId,
                            ret: ret
                        });
                    }
                }
            }
        },
        register: function(bridgeName, callback) {
            if (!registerFuncs[bridgeName])  {
                registerFuncs[bridgeName] = [];
            }
            registerFuncs[bridgeName].push(callback); // 存储回调
        }
    };
})();
</code></pre><p>当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。</p>
<p>【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 =&gt; 解析参数，拿到 bridgeName、data 和 callbackId =&gt; 根据 bridgeName 找到功能方法，以 data 为参数执行 =&gt; 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。</p>
<h1 id="5-JSBridge-如何引用"><a href="#5-JSBridge-如何引用" class="headerlink" title="5 JSBridge 如何引用"></a><strong>5 JSBridge 如何引用</strong></h1><p>对于 JSBridge 的引用，常用有两种方式，各有利弊。</p>
<h2 id="5-1-由-Native-端进行注入"><a href="#5-1-由-Native-端进行注入" class="headerlink" title="5.1 由 Native 端进行注入"></a><strong>5.1 由 Native 端进行注入</strong></h2><p>注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。</p>
<p>它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p>
<h2 id="5-2-由-JavaScript-端引用"><a href="#5-2-由-JavaScript-端引用" class="headerlink" title="5.2 由 JavaScript 端引用"></a><strong>5.2 由 JavaScript 端引用</strong></h2><p>直接与 JavaScript 一起执行。</p>
<p>与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。</p>
<h1 id="如何调用三种唤端媒介"><a href="#如何调用三种唤端媒介" class="headerlink" title="如何调用三种唤端媒介"></a><strong>如何调用三种唤端媒介</strong></h1><p>无论是 URL Scheme 还是 Intent 或者 Universal Link ，他们都算是 URL ，只是 URL Scheme 和 Intent 算是特殊的 URL。所以我们可以拿使用 URL 的方法来使用它们。</p>
<blockquote>
<p>iframe</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;sinaweibo://qrcode&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>在只有 URL Scheme 的日子里，iframe 是使用最多的了。因为在未安装 app 的情况下，不会去跳转错误页面。但是 iframe 在各个系统以及各个应用中的兼容问题还是挺多的，不能全部使用 URL Scheme。</p>
<blockquote>
<p>a 标签</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;intent://scan/#Intent;scheme=zxing;package=com.google.zxing.client.android;end&quot;&quot;&gt;扫一扫&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>对于动态生成的 a 标签，使用 dispatch 来模拟触发点击事件，发现很多种 event 传递过去都无效；使用 click() 来模拟触发，部分场景下存在这样的情况，第一次点击过后，回到原先页面，再次点击，点击位置和页面所识别位置有不小的偏移，所以 Intent 协议从 a 标签换成了 window.location。</p>
<blockquote>
<p>window.location</p>
</blockquote>
<p>URL Scheme 在 ios 9+ 上诸如 safari、UC、QQ浏览器中， iframe 均无法成功唤起 APP，只能通过 window.location 才能成功唤端。<br>当然，如果我们的 app 支持 Universal Link，ios 9+ 就用不到 URL Scheme 了。而 Universal Link 在使用过程中，我发现在 qq 中，无论是 iframe 导航 还是 a 标签打开 又或者 window.location 都无法成功唤端，一开始我以为是 qq 和微信一样禁止了 Universal Link 唤端的功能，其实不然，百般试验下，通过 top.location 唤端成功了。</p>
<h3 id="判断唤端是否成功"><a href="#判断唤端是否成功" class="headerlink" title="判断唤端是否成功"></a>判断唤端是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const initialTime = new Date();</span><br><span class="line">let counter = 0;</span><br><span class="line">let waitTime = 0;</span><br><span class="line"></span><br><span class="line">const checkOpen = setInterval(() =&gt; &#123;</span><br><span class="line">   count++;</span><br><span class="line">   waitTime = new Date() - initialTime;</span><br><span class="line"></span><br><span class="line">   if (waitTime &gt; 2500) &#123;</span><br><span class="line">      clearInterval(checkOpen);</span><br><span class="line">      cb();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (counter &lt; 100) return;</span><br><span class="line"></span><br><span class="line">   clearInterval(checkOpen);</span><br><span class="line"></span><br><span class="line">   const hide = document.hidden || document.webkitHidden;</span><br><span class="line"></span><br><span class="line">   if (!hide) &#123;</span><br><span class="line">      cb(); // 唤端失败的回调函数</span><br><span class="line">   &#125;</span><br><span class="line">&#125;, 20);</span><br></pre></td></tr></table></figure>
<p>APP 如果被唤起的话，页面就会进入后台运行，setInterval 在 ios 中不会停止运行，在 android 中停止运行。<br>每 20ms 执行一次，执行 100次 在页面中实际耗费与 2000 ms 不会相差多少。<br>我们的判断条件比预期时间多设置了 500ms，所以如果安卓中 setInterval 内的函数执行 100 次以内所费时间超过 2500ms，则说明 APP 唤起成功，反之则代表失败。<br>我们通过 document.hidden 和 document.webkitHidden 属性来判断 APP 在 ios 中是否被正常唤起，2000ms 内，页面转入后台运行，document.hidden 会返回 true，代表唤端成功，反之则代表失败。</p>
<h1 id="判断是否安装app并打开-否则跳转下载的方法"><a href="#判断是否安装app并打开-否则跳转下载的方法" class="headerlink" title="判断是否安装app并打开,否则跳转下载的方法"></a><strong>判断是否安装app并打开,否则跳转下载的方法</strong></h1><blockquote>
<p>应用场景</p>
</blockquote>
<p>App产品在运营推广上有一个需求，就是要求可以让用户在访问我们的推广网页时，就可以判断出这个用户手机上是否安装了我们的App，如果安装了则可以直接在网页上打开，否则就引导用户前往下载。从而形成一个推广上的闭环。</p>
<blockquote>
<p>解决办法</p>
</blockquote>
<p>而对于点击链接后，能否直接打开，可以通过下面的代码来实现。前提条件：你得知道你的APP对应的打开协议，如贴吧APP，协议为：com.baidu.tieba:// ，微信的：weixin:// ，等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a标签点击打开的动作，在click事件中注册 --&gt;</span><br><span class="line">&lt;a href=&quot;javascript:;&quot; id=&quot;openApp&quot;&gt;贴吧客户端&lt;/a&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">        // 通过iframe的方式试图打开APP，如果能正常打开，会直接切换到APP，并自动阻止js其他行为</span><br><span class="line">        </span><br><span class="line">        var ifr = document.createElement(&apos;iframe&apos;);</span><br><span class="line">        ifr.src = &apos;com.baidu.tieba://&apos;;//打开app的协议，有app同事提供</span><br><span class="line">        ifr.style.display = &apos;none&apos;;</span><br><span class="line">        document.body.appendChild(ifr);</span><br><span class="line">        window.setTimeout(function()&#123;</span><br><span class="line">            document.body.removeChild(ifr);</span><br><span class="line">　　　　　　　window.location.href = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;//打开app下载地址，有app同事提供</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>此方法有些浏览器不兼容iframe，可以window.location的方法解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:;&quot; id=&quot;openApp&quot;&gt;贴吧客户端&lt;/a&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">        window.location.href = &quot;com.baidu.tieba://&quot;;</span><br><span class="line">        window.setTimeout(function()&#123;</span><br><span class="line">            window.location.href = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;//打开app下载地址，有app同事提供</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="js判断本地是否安装app"><a href="#js判断本地是否安装app" class="headerlink" title="js判断本地是否安装app"></a><strong>js判断本地是否安装app</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">             document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">                if(navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123;</span><br><span class="line">                var loadDateTime = new Date();</span><br><span class="line">                window.setTimeout(function() &#123;</span><br><span class="line">                        var timeOutDateTime = new Date();</span><br><span class="line">                        if(timeOutDateTime - loadDateTime &lt; 5000) &#123;</span><br><span class="line">                            window.location = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            window.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    25);</span><br><span class="line">                window.location = &quot;weixin:// &quot;;</span><br><span class="line">            &#125; else if(navigator.userAgent.match(/android/i)) &#123;</span><br><span class="line">                var state = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    state = window.open(&quot;weixin://&quot;);</span><br><span class="line">                &#125; catch(e) &#123;&#125;</span><br><span class="line">                if(state) &#123;</span><br><span class="line">                    window.close();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    window.location = &quot;http://dldir1.qq.com/weixin/android/weixin656android1020.apk&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如果本地安装了app那么直接打开，否则苹果要跳转到app-store，安卓则要跳到对应的市场</p>
<blockquote>
<p>解决方案 一</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//html代码中 的 a 标签，以微信为例，默认的是调用weixin scheme，去打开本机的微信，如果没有则跳转到相应连接</span><br><span class="line">　　　　&lt;a href=&quot;weixin://&quot; class=&quot;btn-download&quot;&gt;立即打开&lt;/a&gt;</span><br><span class="line">　　</span><br><span class="line">　　　　// 为btn-download 绑定事件，如果在500ms内，没有解析到协议，那么就会跳转到下载链接 </span><br><span class="line">　　　　 var appstore, ua = navigator.userAgent;</span><br><span class="line">        if(ua.match(/Android/i))&#123; </span><br><span class="line">            appstore = &apos;market://search?q=com.singtel.travelbuddy.android&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ua.match(/iphone|ipod|ipad/))&#123;</span><br><span class="line">            appstore = &quot;https://itunes.apple.com/cn/app/wei-xin/id414478124?mt=8&amp;ign-mpt=uo%3D4&quot;; </span><br><span class="line">        &#125;</span><br><span class="line">        function applink(fail)&#123;  </span><br><span class="line">            return function()&#123;  </span><br><span class="line">                var clickedAt = +new Date;  </span><br><span class="line">                // During tests on 3g/3gs this timeout fires immediately if less than 500ms.  </span><br><span class="line">                setTimeout(function()&#123;  </span><br><span class="line">                     // To avoid failing on return to MobileSafari, ensure freshness!  </span><br><span class="line">                      if (+new Date - clickedAt &lt; 2000)&#123;  </span><br><span class="line">                          window.location = fail;  </span><br><span class="line">                      &#125;  </span><br><span class="line">                &#125;, 500);      </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;  </span><br><span class="line">        $(&apos;.icon-download, .btn-download&apos;)[0].onclick = applink(appstore);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决方案二 </p>
</blockquote>
<p>通过在页面中生成一个隐藏的iframe，iframe的src指向 app 协议，例如 weixin scheme，并监听onerror事件，意思是如果无法解析协议，就会触发onerror事件，但是我尝试了一下，未果。代码如下，可参考一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 页面中有div#iframe-box 用来插入生成的iframe，还是以微信为例</span><br><span class="line">　　　　 var ifm = document.createElement(&apos;iframe&apos;), isInstalled;</span><br><span class="line">        ifm.style.display = &apos;none&apos;;</span><br><span class="line">        ifm.src = &apos;wixin://&apos;;</span><br><span class="line">        ifm.onload = function(e)&#123;</span><br><span class="line">            var e = e || window.event;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;</span><br><span class="line">        ifm.onerror = function()&#123;</span><br><span class="line">            //isInstalled = false;</span><br><span class="line">            alert(1);</span><br><span class="line">        &#125;</span><br><span class="line">        document.getElementById(&apos;iframe-box&apos;).appendChild(ifm);</span><br><span class="line"></span><br><span class="line">　　　　// 但这时的问题是，iframe的src成功解析到了协议，则会直接跳转，但是解析不到的话，也不会触发error事件，这个还要继续研究</span><br><span class="line">　　　　// 可以把上面的代码，放到函数中，然后作为某个按钮的响应函数。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决方案三</p>
</blockquote>
<p>对于ios手机，会有如下写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=414478124&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>将上面代码放到head中，根据name也会知道意思，app-id是微信的app-id，用ios手机看会看到提示，andriod比可以，结果自行实验。（ios就是强大）</p>
<h1 id="H5唤起客户端通用机方案"><a href="#H5唤起客户端通用机方案" class="headerlink" title="H5唤起客户端通用机方案"></a><strong>H5唤起客户端通用机方案</strong></h1><h4 id="H5唤起客户端"><a href="#H5唤起客户端" class="headerlink" title="H5唤起客户端"></a><a href="https://github.com/suanmei/callapp-lib" target="_blank" rel="noopener">H5唤起客户端</a></h4><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a><strong>6 总结</strong></h1><p>这篇文章主要剖析的 JSBridge 的实现及应用，包括 <strong>JavaScript 与 Native 间的通信原理</strong>，<strong>JSBridge 的 JavaScript 端实现</strong> 以及 <strong>引用方式</strong>，并给出了一些示例代码，希望对读者有一定的帮助。</p>
<h3 id="JSBridge实战"><a href="#JSBridge实战" class="headerlink" title="JSBridge实战"></a><a href="https://juejin.im/post/5bda6f276fb9a0226d18931f" target="_blank" rel="noopener">JSBridge实战</a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/25/CommonJS-AMD-CMD-ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/25/CommonJS-AMD-CMD-ES6/" itemprop="url">CommonJS,AMD,CMD,ES6 </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-25T21:18:27+08:00">
                2016-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CommonJS,AMD,CMD,ES6</p>
<p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>
<p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p>
<pre><code>/** AMD写法 **/
define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) { 
     // 等于在最前面声明并初始化了要用到的所有模块
    a.doSomething();
    if (false) {
        // 即便没用到某个模块 b，但 b 还是提前执行了
        b.doSomething()
    } 
});


/** CMD写法 **/
define(function(require, exports, module) {
    var a = require(&apos;./a&apos;); //在需要时申明
    a.doSomething();
    if (false) {
        var b = require(&apos;./b&apos;);
        b.doSomething();
    }
}); 
</code></pre><p>ES6 模块是动态引用:ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>
<p>ES6 模块与 CommonJS 模块的差异</p>
<ol>
<li><font color="#ff0000">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</font>,<strong>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</strong><br>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
<li><font color="#ff0000"> CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</font></li>
<li><font color="#ff0000">运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>编译时加载: ES6模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</font></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/23/Web-安全攻防总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/23/Web-安全攻防总结/" itemprop="url">Web 安全攻防总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-23T20:02:04+08:00">
                2016-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Web 安全的对于 Web 从业人员来说是一个非常重要的课题，所以在这里总结一下 Web 相关的安全攻防知识，希望以后不要再踩雷，也希望对看到这篇文章的同学有所帮助。今天这边文章主要的内容就是分析几种常见的攻击的类型以及防御的方法。</p>
<blockquote>
<p>也许你对所有的安全问题都有一定的认识，但最主要的还是在编码设计的过程中时刻绷紧安全那根弦，需要反复推敲每个实现细节，安全无小事。</p>
<p>本文代码 Demo 都是基于 Node.js 讲解，其他服务端语言同样可以参考。</p>
</blockquote>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。</p>
<p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。</p>
<h3 id="非持久型-XSS"><a href="#非持久型-XSS" class="headerlink" title="非持久型 XSS"></a>非持久型 XSS</h3><p>非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br><img src="/2016/10/23/Web-安全攻防总结/xss1.jpg" alt="非持久型 XSS"><br>举一个例子，比如你的 Web 页面中包含有以下代码：</p>
<pre><code>&lt;select&gt;
    &lt;script&gt;
        document.write(&apos;&apos;
                + &apos;&lt;optionvalue=1&gt;&apos;
                +     location.href.substring(location.href.indexOf(&apos;default=&apos;) + 8)
                + &apos;&lt;/option&gt;&apos;
            );
            document.write(&apos;&lt;optionvalue=2&gt;English&lt;/option&gt;&apos;);
    &lt;/script&gt;
&lt;/select&gt;
</code></pre><p>攻击者可以直接通过 URL (类似： </p>
<pre><code>https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;
</code></pre><p>注入可执行的脚本代码。</p>
<p>非持久型 XSS 漏洞攻击有以下几点<strong>特征</strong>：</p>
<ul>
<li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li>
<li>攻击者需要诱骗点击</li>
<li>反馈率低，所以较难发现和响应修复</li>
<li>盗取用户敏感保密信息</li>
</ul>
<p>为了<strong>防止出现非持久型 XSS 漏洞</strong>，需要确保这么几件事情：</p>
<ul>
<li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li>
<li>尽量不要从 URL，<code>document.referrer</code>，<code>document.forms</code> 等这种 DOM API 中获取数据直接渲染。</li>
<li>尽量不要使用 <code>eval</code>, <code>new Function()</code>，<code>document.write()</code>，<code>document.writeln()</code>，<code>window.setInterval()</code>，<code>window.setTimeout()</code>，<code>innerHTML</code>，<code>document.creteElement()</code> 等可执行字符串的方法。</li>
<li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li>
<li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li>
</ul>
<blockquote>
<p>escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 <code>&lt;</code>，<code>&gt;</code>，<code>空格</code> 等，转义成 <code>&amp;lt;</code>，<code>&amp;gt;</code>，<code>&amp;nbsp;</code> 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。</p>
</blockquote>
<h3 id="持久型-XSS"><a href="#持久型-XSS" class="headerlink" title="持久型 XSS"></a>持久型 XSS</h3><p>持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>
<p>主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。攻击成功需要同时满足以下几个条件：</p>
<ul>
<li>POST 请求提交表单后端没做转义直接入库。</li>
<li>后端从数据库中取出数据没做转义直接输出给前端。</li>
<li>前端拿到后端数据没做转义直接渲染成 DOM。</li>
</ul>
<p>持久型 XSS 有以下几个<strong>特点</strong>：</p>
<ul>
<li>持久性，植入在数据库中</li>
<li>危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。</li>
<li>盗取用户敏感私密信息</li>
</ul>
<p>为了<strong>防止持久型 XSS 漏洞</strong>，需要前后端共同努力：</p>
<ul>
<li>后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。</li>
<li>后端在输出给前端数据统一进行转义处理。</li>
<li>前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</li>
</ul>
<h3 id="基于字符集的-XSS"><a href="#基于字符集的-XSS" class="headerlink" title="基于字符集的 XSS"></a>基于字符集的 XSS</h3><p>其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。</p>
<p>以基于 utf-7 的 XSS 为例</p>
<p>utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。</p>
<p>这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。</p>
<pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;
      可以被解释为：
+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4-
</code></pre><p>可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。</p>
<p>所以我们有什么办法避免这种 XSS 呢？</p>
<ul>
<li>记住指定 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></li>
<li>XML 中不仅要指定字符集为 utf-8，而且标签要闭合</li>
<li>牛文推荐：<a href="http://drops.wooyun.org/papers/1327" target="_blank" rel="noopener">http://drops.wooyun.org/papers/1327</a> （这个讲的很详细）</li>
</ul>
<h3 id="基于-Flash-的跨站-XSS"><a href="#基于-Flash-的跨站-XSS" class="headerlink" title="基于 Flash 的跨站 XSS"></a>基于 Flash 的跨站 XSS</h3><p>基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。</p>
<p>避免方法：</p>
<ul>
<li>严格管理 cookie 的读写权限</li>
<li>对 Flash 能接受用户输入的参数进行过滤 escape 转义处理</li>
</ul>
<h3 id="未经验证的跳转-XSS"><a href="#未经验证的跳转-XSS" class="headerlink" title="未经验证的跳转 XSS"></a>未经验证的跳转 XSS</h3><p>有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。</p>
<p>这时候需要通过以下方式来防止这类漏洞：</p>
<ul>
<li>对待跳转的 URL 参数做白名单或者某种规则过滤</li>
<li>后端注意对敏感信息的保护, 比如 cookie 使用来源验证。</li>
</ul>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF（Cross-Site Request Forgery），中文名称：跨站请求伪造攻击</p>
<p>那么 CSRF 到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。攻击者只要借助少许的社会工程学的诡计，例如通过 QQ 等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使 Web 应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。</p>
<p>所以遇到 CSRF 攻击时，将对终端用户的数据和操作指令构成严重的威胁。当受攻击的终端用户具有管理员帐户的时候，CSRF 攻击将危及整个 Web 应用程序。</p>
<h3 id="CSRF-原理"><a href="#CSRF-原理" class="headerlink" title="CSRF 原理"></a>CSRF 原理</h3><p>下图大概描述了 CSRF 攻击的原理，可以理解为有一个小偷在你配钥匙的地方得到了你家的钥匙，然后拿着要是去你家想偷什么偷什么。<br><img src="/2016/10/23/Web-安全攻防总结/csrf.jpg" alt="csrf原理"><br>完成 CSRF 攻击必须要有三个条件：</p>
<ol>
<li>用户已经登录了站点 A，并在本地记录了 cookie</li>
<li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。</li>
<li>站点 A 没有做任何 CSRF 防御</li>
</ol>
<p>你也许会问：「如果我不满足以上三个条件中的任意一个，就不会受到 CSRF 的攻击」。其实可以这么说的，但你不能保证以下情况不会发生：</p>
<ul>
<li>你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站，特别现在浏览器都是支持多 tab 的。</li>
<li>你不能保证你关闭浏览器了后，你本地的 cookie 立刻过期，你上次的会话已经结束。</li>
<li>上图中所谓的攻击网站 B，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li>
</ul>
<h3 id="预防-CSRF"><a href="#预防-CSRF" class="headerlink" title="预防 CSRF"></a>预防 CSRF</h3><p>CSRF 的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的 CSRF 防御也都在服务端进行。服务端的预防 CSRF 攻击的方式方法有多种，但思路上都是差不多的，主要从以下两个方面入手：</p>
<ul>
<li>正确使用 GET，POST 请求和 cookie</li>
<li>在非 GET 请求中增加 token</li>
</ul>
<p>一般而言，普通的 Web 应用都是以 GET、POST 请求为主，还有一种请求是 cookie 方式。我们一般都是按照如下规则设计应用的请求：</p>
<ul>
<li>GET 请求常用在查看，列举，展示等不需要改变资源属性的时候（数据库 query 查询的时候）</li>
<li>POST 请求常用在 From 表单提交，改变一个资源的属性或者做其他一些事情的时候（数据库有 insert、update、delete 的时候）</li>
</ul>
<p>当正确的使用了 GET 和 POST 请求之后，剩下的就是在非 GET 方式的请求中增加随机数，这个大概有三种方式来进行：</p>
<ul>
<li><p><strong>为每个用户生成一个唯一的 cookie token</strong>，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的 cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。</p>
</li>
<li><p><strong>每个 POST 请求使用验证码</strong>，这个方案算是比较完美的，但是需要用户多次输入验证码，用户体验比较差，所以不适合在业务中大量运用。</p>
</li>
<li><p><strong>渲染表单的时候，为每一个表单包含一个 csrfToken</strong>，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。</p>
</li>
</ul>
<p>CSRF 的防御可以根据应用场景的不同自行选择。CSRF 的防御工作确实会在正常业务逻辑的基础上带来很多额外的开发量，但是这种工作量是值得的，毕竟用户隐私以及财产安全是产品最基础的根本。</p>
<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p>
<p>而造成 SQL 注入的原因是因为程序没有有效的转义过滤用户的输入，使攻击者成功的向服务器提交恶意的 SQL 查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p>
<p>很多 Web 开发者没有意识到 SQL 查询是可以被篡改的，从而把 SQL 查询当作可信任的命令。殊不知，SQL 查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过 SQL 查询去运行主机系统级的命令。</p>
<h3 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a>SQL 注入原理</h3><p>下面将通过一些真实的例子来详细讲解 SQL 注入的方式的原理。</p>
<p>考虑以下简单的管理员登录表单：</p>
<pre><code>&lt;formaction=&quot;/login&quot;method=&quot;POST&quot;&gt;
&lt;p&gt;Username: &lt;inputtype=&quot;text&quot;name=&quot;username&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Password: &lt;inputtype=&quot;password&quot;name=&quot;password&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;inputtype=&quot;submit&quot;value=&quot;登陆&quot; /&gt;&lt;/p&gt;
&lt;/form&gt;
</code></pre><p>后端的 SQL 语句可能是如下这样的：</p>
<pre><code>let querySQL = `
    SELECT *
    FROM user
    WHERE username=&apos;${username}&apos;
    AND psw=&apos;${password}&apos;
`;
// 接下来就是执行 sql 语句...
</code></pre><p>目的就是来验证用户名和密码是不是正确，按理说乍一看上面的 SQL 语句也没什么毛病，确实是能够达到我们的目的，可是你只是站在用户会老老实实按照你的设计来输入的角度来看问题，如果有一个恶意攻击者输入的用户名是 <code>zoumiaojiang&#39; OR 1 = 1 --</code>，密码随意输入，就可以直接登入系统了。WFT!</p>
<p>冷静下来思考一下，我们之前预想的真实 SQL 语句是:</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;AND psw=&apos;mypassword&apos;
</code></pre><p>可以恶意攻击者的奇怪用户名将你的 SQL 语句变成了如下形式：</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1--&apos; AND psw=&apos;xxxx&apos;
</code></pre><p>在 SQL 中，<code>--</code> 是注释后面的内容的意思，所以查询语句就变成了：</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1
</code></pre><p>这条 SQL 语句的查询条件永远为真，所以意思就是恶意攻击者不用我的密码，就可以登录进我的账号，然后可以在里面为所欲为，然而这还只是最简单的注入，牛逼的 SQL 注入高手甚至可以通过 SQL 查询去运行主机系统级的命令，将你主机里的内容一览无余，这里我也没有这个能力讲解的太深入，毕竟不是专业研究这类攻击的，但是通过以上的例子，已经了解了 SQL 注入的原理，我们基本已经能找到防御 SQL 注入的方案了。</p>
<h3 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h3><p>防止 SQL 注入主要是不能允许用户输入的内容影响正常的 SQL 语句的逻辑，当用户的输入的信息将要用来拼接 SQL 语句的话，我们应该永远选择不相信，任何内容都必须进行转义过滤，当然做到这个还是不够的，下面列出防御 SQL 注入的几点注意事项：</p>
<ul>
<li><p><strong>严格限制Web应用的数据库的操作权限</strong>，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p>
</li>
<li><p><strong>后端代码检查输入的数据是否符合预期</strong>，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>
</li>
<li><p><strong>对进入数据库的特殊字符（<code>&#39;</code>，<code>&quot;</code>，<code>\</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&amp;</code>，<code>*</code>，<code>;</code> 等）进行转义处理</strong>，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 <code>lodash._escapehtmlchar</code> 库。</p>
</li>
<li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口</strong>，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 <code>query</code> 方法中的 <code>?</code> 占位参数。</p>
</li>
</ul>
<pre><code>mysql.query(`SELECT * FROM user WHERE username = ? AND psw = ?`, [username, psw]);
</code></pre><ul>
<li><p><strong>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测</strong>，以及时修补被发现的 SQL 注入漏洞。网上有很多这方面的开源工具，例如 sqlmap、SQLninja 等。</p>
</li>
<li><p><strong>避免网站打印出 SQL 错误信息</strong>，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。</p>
</li>
<li><p><strong>不要过于细化返回的错误信息</strong>，如果目的是方便调试，就去使用后端日志，不要在接口上过多的暴露出错信息，毕竟真正的用户不关心太多的技术细节，只要话术合理就行。</p>
</li>
</ul>
<p>碰到要操作的数据库的代码，一定要慎重，小心使得万年船，多找几个人多来几次 code review，将问题都暴露出来，而且要善于利用工具，操作数据库相关的代码属于机密，没事不要去各种论坛晒自家站点的 SQL 语句，万一被人盯上了呢？</p>
<h2 id="命令行注入"><a href="#命令行注入" class="headerlink" title="命令行注入"></a>命令行注入</h2><p>命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令，听起来好像匪夷所思，这往往是 Web 开发者最容易忽视但是却是最危险的一个漏洞之一，看一个实例：</p>
<p>假如现在需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去产出一个结果返回给用户，接口的部分实现如下：</p>
<pre><code>// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo
const exec = require(&apos;mz/child_process&apos;).exec;
let params = {/* 用户输入的参数 */};

exec(`git clone ${params.repo} /some/path`);
</code></pre><p>这段代码确实能够满足业务需求，正常的用户也确实能从指定的 git repo 上下载到想要的代码，可是和 SQL 注入一样，这段代码在恶意攻击者眼中，简直就是香饽饽。</p>
<p>如果 <code>params.repo</code> 传入的是 <code>https://github.com/zoumiaojiang/zoumiaojiang.github.io.git</code> 当然没问题了。</p>
<p>可是如果 <code>params.repo</code> 传入的是 <code>https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;</code> 恰好你的服务是用 root 权限起的就惨了。</p>
<p>具体恶意攻击者能用命令行注入干什么也像 SQL 注入一样，手法是千变万化的，比如「<a href="http://wiki.bash-hackers.org/howto/redirection_tutorial" target="_blank" rel="noopener">反弹 shell 注入</a>」等，但原理都是一样的，我们绝对有能力防止命令行注入发生。防止命令行注入需要做到以下几件事情：</p>
<ul>
<li>后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。</li>
<li>在调用系统命令前对所有传入参数进行命令行参数转义过滤。</li>
<li>不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 <code>shell-escape</code> npm 包。</li>
</ul>
<p>还是前面的例子，我们可以做到如下：</p>
<pre><code>const exec = require(&apos;mz/child_process&apos;).exec;

// 借助 shell-escape npm 包解决参数转义过滤问题
const shellescape = require(&apos;shell-escape&apos;);

let params = {/* 用户输入的参数 */};

// 先过滤一下参数，让参数符合预期
if (!/正确的表达式/.test(params.repo)) {
return;
}

let cmd = shellescape([
&apos;git&apos;,
&apos;clone&apos;,
    params.repo,
&apos;/some/path&apos;
]);

// cmd 的值: git clone &apos;https://github.com/xx/xx.git &amp;&amp; rm -rf / &amp;&amp;&apos; /some/path
// 这样就不会被注入成功了。
exec(cmd);
</code></pre><blockquote>
<p>无论是在何种后端语言环境中，凡是涉及到代码调用系统 shell 命令的时候都一定要谨慎。</p>
</blockquote>
<h2 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h2><p>DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用，这个攻击应该不能算是安全问题，这应该算是一个另类的存在，因为这种攻击根本就是耍流氓的存在，「伤敌一千，自损八百」的行为。出于保护 Web App 不受攻击的攻防角度，还是介绍一下 DDoS 攻击吧，毕竟也是挺常见的。</p>
<p>DDoS 攻击可以理解为：「你开了一家店，隔壁家点看不惯，就雇了一大堆黑社会人员进你店里干坐着，也不消费，其他客人也进不来，导致你营业惨淡」。为啥说 DDoS 是个「伤敌一千，自损八百」的行为呢？毕竟隔壁店还是花了不少钱雇黑社会但是啥也没得到不是？DDoS 攻击的目的基本上就以下几个：</p>
<ul>
<li>深仇大恨，就是要干死你</li>
<li>敲诈你，不给钱就干你</li>
<li>忽悠你，不买我防火墙服务就会有“人”继续干你</li>
</ul>
<p>也许你的站点遭受过 DDoS 攻击，具体什么原因怎么解读见仁见智。DDos 攻击从层次上可分为网络层攻击与应用层攻击，从攻击手法上可分为快型流量攻击与慢型流量攻击，但其原理都是造成资源过载，导致服务不可用。</p>
<h3 id="网络层-DDoS"><a href="#网络层-DDoS" class="headerlink" title="网络层 DDoS"></a>网络层 DDoS</h3><p>网络层 DDos 攻击包括 <code>SYN Flood</code>、<code>ACK Flood</code>、<code>UDP Flood</code>、<code>ICMP Flood</code> 等。</p>
<p><strong>SYN Flood 攻击</strong></p>
<p>SYN flood 攻击主要利用了 TCP 三次握手过程中的 Bug，我们都知道 TCP 三次握手过程是要建立连接的双方发送 SYN，SYN + ACK，ACK 数据包，而当攻击方随意构造源 IP 去发送 SYN 包时，服务器返回的 SYN + ACK 就不能得到应答（因为 IP 是随意构造的），此时服务器就会尝试重新发送，并且会有至少 30s 的等待时间，导致资源饱和服务不可用，此攻击属于慢型 DDoS 攻击。</p>
<p><strong>ACK Flood 攻击</strong></p>
<p>ACK Flood 攻击是在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。</p>
<p><strong>UDP Flood 攻击</strong></p>
<p>UDP flood 攻击是由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。</p>
<p><strong>ICMP Flood 攻击</strong></p>
<p>ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。</p>
<h3 id="网络层-DDoS-防御"><a href="#网络层-DDoS-防御" class="headerlink" title="网络层 DDoS 防御"></a>网络层 DDoS 防御</h3><p>网络层的 DDoS 攻击究其本质其实是无法防御的，我们能做得就是不断优化服务本身部署的网络架构，以及提升网络带宽。当然，还是做好以下几件事也是有助于缓解网络层 DDoS 攻击的冲击：</p>
<ul>
<li>网络架构上做好优化，采用负载均衡分流。</li>
<li>确保服务器的系统文件是最新的版本，并及时更新系统补丁。</li>
<li>添加抗 DDos 设备，进行流量清洗。</li>
<li>限制同时打开的 SYN 半连接数目，缩短 SYN 半连接的 Timeout 时间。</li>
<li>限制单 IP 请求频率。</li>
<li>防火墙等防护设置禁止 ICMP 包等。</li>
<li>严格限制对外开放的服务器的向外访问。</li>
<li>运行端口映射程序或端口扫描程序，要认真检查特权端口和非特权端口。</li>
<li>关闭不必要的服务。</li>
<li>认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更,那这台机器就可能遭到了攻击。</li>
<li>限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。</li>
<li>加钱堆机器。。</li>
<li>报警。。</li>
</ul>
<h3 id="应用层-DDoS"><a href="#应用层-DDoS" class="headerlink" title="应用层 DDoS"></a>应用层 DDoS</h3><p>应用层 DDoS 攻击不是发生在网络层，是发生在 TCP 建立握手成功之后，应用程序处理请求的时候，现在很多常见的 DDoS 攻击都是应用层攻击。应用层攻击千变万化，目的就是在网络应用层耗尽你的带宽，下面列出集中典型的攻击类型。</p>
<p><strong>CC 攻击</strong></p>
<p>当时绿盟为了防御 DDoS 攻击研发了一款叫做 <code>Collapasar</code> 的产品，能够有效的防御 SYN Flood 攻击。黑客为了挑衅，研发了一款 <code>Challenge Collapasar</code> 攻击工具（简称 CC）。</p>
<p>CC 攻击的原理，就是针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。因此在发送 CC 攻击前，我们需要寻找加载比较慢，消耗资源比较多的网页，比如需要查询数据库的页面、读写硬盘文件的等。通过 CC 攻击，使用爬虫对某些加载需要消耗大量资源的页面发起 HTTP 请求。</p>
<p><strong>DNS Flood</strong></p>
<p>DNS Flood 攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名，被攻击的DNS 服务器在接收到域名解析请求的时候首先会在服务器上查找是否有对应的缓存，如果查找不到并且该域名无法直接由服务器解析的时候，DNS 服务器会向其上层 DNS 服务器递归查询域名信息。域名解析的过程给服务器带来了很大的负载，每秒钟域名解析请求超过一定的数量就会造成 DNS 服务器解析域名超时。</p>
<p>根据微软的统计数据，一台 DNS 服务器所能承受的动态域名查询的上限是每秒钟 9000 个请求。而我们知道，在一台 P3 的 PC 机上可以轻易地构造出每秒钟几万个域名解析请求，足以使一台硬件配置极高的 DNS 服务器瘫痪，由此可见 DNS 服务器的脆弱性。</p>
<p><strong>HTTP 慢速连接攻击</strong></p>
<p>针对 HTTP 协议，先建立起 HTTP 连接，设置一个较大的 Conetnt-Length，每次只发送很少的字节，让服务器一直以为 HTTP 头部没有传输完成，这样连接一多就很快会出现连接耗尽。</p>
<h3 id="应用层-DDoS-防御"><a href="#应用层-DDoS-防御" class="headerlink" title="应用层 DDoS 防御"></a>应用层 DDoS 防御</h3><ul>
<li>判断 User-Agent 字段（不可靠，因为可以随意构造）</li>
<li>针对 IP + cookie，限制访问频率（由于 cookie 可以更改，IP 可以使用代理，或者肉鸡，也不可靠)</li>
<li>关闭服务器最大连接数等，合理配置中间件，缓解 DDoS 攻击。</li>
<li>请求中添加验证码，比如请求中有数据库操作的时候。</li>
<li>编写代码时，尽量实现优化，并合理使用缓存技术，减少数据库的读取操作。</li>
<li>加钱堆机器。。</li>
<li>报警。。</li>
</ul>
<p>应用层的防御有时比网络层的更难，因为导致应用层被 DDoS 攻击的因素非常多，有时往往是因为程序员的失误，导致某个页面加载需要消耗大量资源，有时是因为中间件配置不当等等。而应用层 DDoS 防御的核心就是区分人与机器（爬虫），因为大量的请求不可能是人为的，肯定是机器构造的。因此如果能有效的区分人与爬虫行为，则可以很好地防御此攻击。</p>
<h3 id="其他-DDoS-攻击"><a href="#其他-DDoS-攻击" class="headerlink" title="其他 DDoS 攻击"></a>其他 DDoS 攻击</h3><p>发起 DDoS 也是需要大量的带宽资源的，但是互联网就像森林，林子大了什么鸟都有，DDoS 攻击者也能找到其他的方式发起廉价并且极具杀伤力的 DDoS 攻击。</p>
<p><strong>利用 XSS</strong></p>
<p>举个例子，如果 12306 页面有一个 XSS 持久型漏洞被恶意攻击者发现，只需在春节抢票期间在这个漏洞中执行脚本使得往某一个小站点随便发点什么请求，然后随着用户访问的增多，感染用户增多，被攻击的站点自然就会迅速瘫痪了。这种 DDoS 简直就是无本万利，不用惊讶，现在大站有 XSS 漏洞的不要太多。</p>
<p><strong>来自 P2P 网络攻击</strong></p>
<p>大家都知道，互联网上的 P2P 用户和流量都是一个极为庞大的数字。如果他们都去一个指定的地方下载数据，成千上万的真实 IP 地址连接过来，没有哪个设备能够支撑住。拿 BT 下载来说，伪造一些热门视频的种子，发布到搜索引擎，就足以骗到许多用户和流量了，但是这只是基础攻击。</p>
<p>高级的 P2P 攻击，是直接欺骗资源管理服务器。如迅雷客户端会把自己发现的资源上传到资源管理服务器，然后推送给其它需要下载相同资源的用户，这样，一个链接就发布出去。通过协议逆向，攻击者伪造出大批量的热门资源信息通过资源管理中心分发出去，瞬间就可以传遍整个 P2P 网络。更为恐怖的是，这种攻击是无法停止的，即使是攻击者自身也无法停止，攻击一直持续到 P2P 官方发现问题更新服务器且下载用户重启下载软件为止。</p>
<blockquote>
<p>最后总结下，DDoS 不可能防的住，就好比你的店只能容纳 50 人，黑社会有 100 人，你就换一家大店，能容纳 500 人，然后黑社会又找来了 1000 人，这种堆人头的做法就是 DDoS 本质上的攻防之道，「道高一尺，魔高一丈，魔高一尺，道高一丈」，讲真，必要的时候就答应勒索你的人的条件吧，实在不行就报警吧。</p>
</blockquote>
<h2 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h2><p>流量劫持应该算是黑产行业的一大经济支柱了吧？简直是让人恶心到吐，不吐槽了，还是继续谈干货吧，流量劫持基本分两种：<code>DNS 劫持</code> 和 <code>HTTP 劫持</code>，目的都是一样的，就是当用户访问 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 的时候，给你展示的并不是或者不完全是 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 提供的 “内容”。</p>
<h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持，也叫做域名劫持，可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了</strong>」，DNS 的作用是把网络地址域名对应到真实的计算机能够识别的 IP 地址，以便计算机能够进一步通信，传递网址和内容等。如果当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。<br><img src="/2016/10/23/Web-安全攻防总结/dns.jpg" alt="dns劫持"><br>这类劫持，要不就是网络运营商搞的鬼，一般小的网络运营商与黑产勾结会劫持 DNS，要不就是电脑中毒，被恶意篡改了路由器的 DNS 配置，基本上做为开发者或站长却是很难察觉的，除非有用户反馈，现在升级版的 DNS 劫持还可以对特定用户、特定区域等使用了用户画像进行筛选用户劫持的办法，另外这类广告显示更加随机更小，一般站长除非用户投诉否则很难觉察到，就算觉察到了取证举报更难。无论如何，如果接到有 DNS 劫持的反馈，一定要做好以下几件事：</p>
<ul>
<li>取证很重要，时间、地点、IP、拨号账户、截屏、URL 地址等一定要有。</li>
<li>可以跟劫持区域的电信运营商进行投诉反馈。</li>
<li>如果投诉反馈无效，直接去工信部投诉，一般来说会加白你的域名。</li>
</ul>
<h3 id="HTTP-劫持"><a href="#HTTP-劫持" class="headerlink" title="HTTP 劫持"></a>HTTP 劫持</h3><p>HTTP 劫持您可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告</strong>」，HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面，轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私。能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。</p>
<p>HTTPS 协议就是一种基于 SSL 协议的安全加密网络应用层协议，可以很好的防止 HTTP 劫持。这里有篇 <a href="https://www.jianshu.com/p/13a1b955d095" target="_blank" rel="noopener">文章</a> 讲的不错。HTTPS 在这就不深讲了，后面有机会我会单独好好讲讲 HTTPS。如果不想站点被 HTTP 劫持，赶紧将你的站点全站改造成 HTTPS 吧。</p>
<h2 id="服务器漏洞"><a href="#服务器漏洞" class="headerlink" title="服务器漏洞"></a>服务器漏洞</h2><p>服务器除了以上提到的那些大名鼎鼎的漏洞和臭名昭著的攻击以外，其实还有很多其他的漏洞，往往也很容易被忽视，在这个小节也稍微介绍几种。</p>
<h3 id="越权操作漏洞"><a href="#越权操作漏洞" class="headerlink" title="越权操作漏洞"></a>越权操作漏洞</h3><p>如果你的系统是有登录控制的，那就要格外小心了，因为很有可能你的系统越权操作漏洞，越权操作漏洞可以简单的总结为 「<strong>A 用户能看到或者操作 B 用户的隐私内容</strong>」，如果你的系统中还有权限控制就更加需要小心了。所以每一个请求都需要做 userid 的判断</p>
<p>以下是一段有漏洞的后端示意代码：</p>
<pre><code>// ctx 为请求的 context 上下文
let msgId = ctx.params.msgId;

mysql.query(
&apos;SELECT * FROM msg_table WHERE msg_id = ?&apos;,
    [msgId]
);
</code></pre><p>以上代码是任何人都可以查询到任何用户的消息，只要有 msg_id 就可以，这就是比较典型的越权漏洞，需要如下这么改进一下：</p>
<pre><code>// ctx 为请求的 context 上下文
let msgId = ctx.params.msgId;
let userId = ctx.session.userId; // 从会话中取出当前登陆的 userId

mysql.query(
&apos;SELECT * FROM msg_table WHERE msg_id = ? AND user_id = ?&apos;,
    [msgId, userId]
);
</code></pre><p>嗯，大概就是这个意思，如果有更严格的权限控制，那在每个请求中凡是涉及到数据库的操作都需要先进行严格的验证，并且在设计数据库表的时候需要考虑进 userId 的账号关联以及权限关联。</p>
<h3 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h3><p>目录遍历漏洞指通过在 URL 或参数中构造 <code>../</code>，<code>./</code> 和类似的跨父目录字符串的 ASCII 编码、unicode 编码等，完成目录跳转，读取操作系统各个目录下的敏感文件，也可以称作「任意文件读取漏洞」。</p>
<p>目录遍历漏洞原理：程序没有充分过滤用户输入的 <code>../</code> 之类的目录跳转符，导致用户可以通过提交目录跳转来遍历服务器上的任意文件。使用多个<code>..</code> 符号，不断向上跳转，最终停留在根 <code>/</code>，通过绝对路径去读取任意文件。</p>
<p>目录遍历漏洞几个示例和测试，一般构造 URL 然后使用浏览器直接访问，或者使用 Web 漏洞扫描工具检测，当然也可以自写程序测试。</p>
<pre><code>http://somehost.com/../../../../../../../../../etc/passwd
http://somehost.com/some/path?file=../../Windows/system.ini

# 借助 %00 空字符截断是一个比较经典的攻击手法
http://somehost.com/some/path?file=../../Windows/system.ini%00.js

# 使用了 IIS 的脚本目录来移动目录并执行指令
http://somehost.com/scripts/..%5c../Windows/System32/cmd.exe?/c+dir+c:\
</code></pre><p><strong>防御</strong> 方法就是需要对 URL 或者参数进行 <code>../</code>，<code>./</code> 等字符的转义过滤。</p>
<h3 id="物理路径泄漏"><a href="#物理路径泄漏" class="headerlink" title="物理路径泄漏"></a>物理路径泄漏</h3><p>物理路径泄露属于低风险等级缺陷，它的危害一般被描述为「攻击者可以利用此漏洞得到信息，来对系统进一步地攻击」，通常都是系统报错 500 的错误信息直接返回到页面可见导致的漏洞。得到物理路径有些时候它能给攻击者带来一些有用的信息，比如说：可以大致了解系统的文件目录结构；可以看出系统所使用的第三方软件；也说不定会得到一个合法的用户名（因为很多人把自己的用户名作为网站的目录名）。</p>
<p>防止这种泄漏的方法就是做好后端程序的出错处理，定制特殊的 500 报错页面。</p>
<h3 id="源码暴露漏洞"><a href="#源码暴露漏洞" class="headerlink" title="源码暴露漏洞"></a>源码暴露漏洞</h3><p>和物理路径泄露类似，就是攻击者可以通过请求直接获取到你站点的后端源代码，然后就可以对系统进一步研究攻击。那么导致源代码暴露的原因是什么呢？基本上就是发生在服务器配置上了，服务器可以设置哪些路径的文件才可以被直接访问的，这里给一个 koa 服务起的例子，正常的 koa 服务器可以通过 koa-static 中间件去指定静态资源的目录，好让静态资源可以通过路径的路由访问。比如你的系统源代码目录是这样的：</p>
<pre><code>|- project
    |- src
    |- static
    |- ...
|- server.js
</code></pre><p>你想要将 static 的文件夹配成静态资源目录，你应该会在 <code>server.js</code> 做如下配置：</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const serve = require(&apos;koa-static&apos;);
const app = new Koa();

app.use(serve(__dirname + &apos;/project/static&apos;));
</code></pre><p>但是如果配错了静态资源的目录，可能就出大事了，比如：</p>
<pre><code>// ...
app.use(serve(__dirname + &apos;/project&apos;));
</code></pre><p>这样所有的源代码都可以通过路由访问到了，所有的服务器都提供了静态资源机制，所以在通过服务器配置静态资源目录和路径的时候，一定要注意检验，不然很可能产生漏洞。</p>
<p>最后，希望 Web 开发者们能够管理好自己的代码隐私，注意代码安全问题，比如不要将产品的含有敏感信息的代码放到第三方外部站点或者暴露给外部用户，尤其是前端代码，私钥类似的保密性的东西不要直接输出在代码里或者页面中。也许还有很多值得注意的点，但是归根结底还是绷住安全那根弦，对待每一行代码都要多多推敲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/10/a-1-a-2-a-3-有可能是-true-吗？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/10/a-1-a-2-a-3-有可能是-true-吗？/" itemprop="url">(a ==1 && a== 2 && a==3) 有可能是 true 吗？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-10T12:20:50+08:00">
                2016-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一个有趣的问题："><a href="#一个有趣的问题：" class="headerlink" title="一个有趣的问题："></a>一个有趣的问题：</h2><p><strong>在 JavaScript 中， <code>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3)</code> 是否有可能为 <code>true</code> ？</strong></p>
<p>这是一道我被某科技公司问到的面试题。发生在两周之前，我仍然在努力寻找答案。</p>
<p>我知道我们从来不会在日常工作中写出这样的代码，但我对问题的答案仍然十分很好奇。</p>
<h2 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h2><p>利用松散相等运算符 <code>==</code> 的工作原理，你可以简单地创建一个带有自定义<code>toString</code>( 或者 <code>valueOf</code>)函数的对象，在每一次使用它时候改变它所的返回值，使其满足所有三个条件。</p>
<pre><code>const a = {

i: 1,

toString: function () {

return a.i++;

  }

}

if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {

console.log(&apos;Hello World!&apos;);

}

// Hello World!
</code></pre><blockquote>
<p>之所以会得到如此结果，是由于表达式中使用了松散相等的运算符 <code>==</code>。使用松散相等时，如果其中一个操作数与另一个类型不同，则 JS 引擎将尝试将一个操作转换为另一个类型。在左边对象、右边的数字的情况下，它会尝试将对象转换为一个数，首先通过调用 <code>valueOf</code> 如果是可调用的。否则，它会调用<code>toString</code>方法。我使用<code>toString</code>仅仅是因为它是我的第一反应，<code>valueOf</code> 会更合理。如果我不从<code>toString</code>返回一个字符串（而是返回数字），JS 引擎会尝试将字符串转换为一个数字，虽然有一个稍长的路径，但它仍然会给我们同样的结果。</p>
</blockquote>
<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>我不可否认——其他答案无疑是正确的，但你真的不能过错下面的代码：</p>
<pre><code>var aﾠ = 1;

var a = 2;

var ﾠa = 3;

if(aﾠ==1 &amp;&amp; a== 2 &amp;&amp;ﾠa==3) {

console.log(&quot;Why hello there!&quot;)

}
</code></pre><p>请注意<code>if</code> 语句中的奇怪间距。它是半宽度韩文=,=。这是一个 Unicode 空格字符，但是 ECMAScript 不将其解释为一个空格 —— 这意味着它是一个有效的标识符。因此有三个完全不同的变量，一个是<code>a</code>后加半宽度韩文，一个是<code>a</code>， 一个是<code>a</code>前加半宽度韩文。。。</p>
<p>用下划线 <code>_</code> 替代半宽度韩文，增加可读性，相同的代码看起来像这样：</p>
<pre><code>var a_ = 1;

var a = 2;

var _a = 3;

if(a_==1 &amp;&amp; a== 2 &amp;&amp;_a==3) {

console.log(&quot;Why hello there!&quot;)

}
</code></pre><h2 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h2><p>这是完全可能的！</p>
<pre><code>var val = 0;

Object.defineProperty(window, &apos;a&apos;, {

   get: function() {

        return ++val;

  }

});

if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {

    console.log(&apos;yay&apos;);

}
</code></pre><blockquote>
<p>使用一个<code>get</code>，让 <code>a</code> 的返回值为三个不同的值。然而这并不意味着我们应该在真正的代码中使用。。。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/01/JS正则表达式Regex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/01/JS正则表达式Regex/" itemprop="url">JS正则表达式Regex</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-01T21:56:19+08:00">
                2016-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>名余曰正则兮，字余曰灵均。</p>
</blockquote>
<p><code>Regular Expressions</code>翻译成中文叫正则表达式。也不知道是谁翻译过来的，听起来就很严肃。似乎翻译成<code>通用表达式</code>更能传达其精髓，如果你不怕梦见屈原的话。</p>
<p>为什么叫通用表达式？因为它有一套和编程语言无关的文本匹配规则。很多语言都实现了正则表达式的文本匹配引擎，只不过在功能集合上略有不同。</p>
<p>我们要记住的是三点：</p>
<p>其一，正则表达式是用来提取文本的。</p>
<p>其二，正则表达式的表达能力强大到令人发指。</p>
<p>其三，正则表达式的语法对初学者不友好。</p>
<p>另外，本专题只涉及JavaScript语言的正则表达式，其他语言的规则可能略有不同。</p>
<p>我还为各位读者准备了一副宣传语，应该能让你心动(点赞)吧？</p>
<blockquote>
<p>学一门前端工具，几年就过时了。学正则表达式，受用一辈子。</p>
</blockquote>
<h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>什么叫普通字符？</p>
<p>当我们写<code>a</code>的时候，我们指的就是<code>a</code>；当我们写<code>爱</code>的时候，我们指的就是<code>爱</code>。</p>
<pre><code>&apos;hello 😀 regex&apos;.match(/😀/);
// [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined]复制代码
</code></pre><p>这就是普通字符，它在正则中的含义就是检索它本身。除了正则规定的部分字符外，其余的都是普通字符，包括各种人类语言，包括emoji，只要能够表达为字符串。</p>
<h2 id="开始与结束"><a href="#开始与结束" class="headerlink" title="开始与结束"></a>开始与结束</h2><p><code>^</code>字符的英文是<code>caret</code>，翻译成中文是<code>脱字符</code>。不要问我，又不是我翻译的。它在正则中属于元字符，通常代表的意义是文本的开始。说通常是因为当它在字符组中<code>[^abc]</code>另有含义。</p>
<p>什么叫文本的开始？就是如果它是正则主体的第一个符号，那紧跟着它的字符必须是被匹配文本的第一个字符。</p>
<pre><code>&apos;regex&apos;.match(/^r/);
// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p>问题来了，如果<code>^</code>不是正则的第一个符号呢？</p>
<pre><code>&apos;regex&apos;.match(/a^r/);
// null复制代码
</code></pre><p>所以呀，关于它有三点需要注意：</p>
<ul>
<li>作为匹配文本开始元字符的时候必须是正则主体的第一个符号，否则正则无效。</li>
<li>它匹配的是一个位置，而不是具体的文本。</li>
<li>它在其他规则中有另外的含义。</li>
</ul>
<p><code>$</code>字符与<code>^</code>正好相反。它代表文本的结束，并且没有其他含义(其实是有的，但不是在正则主体内)。同样，它必须是正则主体的最后一个符号。</p>
<pre><code>&apos;regex&apos;.match(/x$/);
// [&quot;x&quot;, index: 4, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p><code>^</code>与<code>$</code>特殊的地方在于它匹配的是一个位置。位置不像字符，它看不见，所以更不容易理解。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>我们现在已经知道<code>$</code>匹配文本的结束位置，它是元字符。但是如果我想匹配<code>$</code>本身呢？匹配一个美元符号的需求再常见不过了吧。所以我们得将它贬为庶民。</p>
<p><code>\</code>反斜杠就是干这个的。</p>
<pre><code>&apos;price: $3.6&apos;.match(/\$[0-9]+\.[0-9]+$/);
// [&quot;$3.6&quot;, index: 7, input: &quot;price: $3.6&quot;, groups: undefined]复制代码
</code></pre><p>上面的例子有点超纲了，超纲的部分先不管。</p>
<p>你可以认为<code>\</code>也是一个元字符，它跟在另一个元字符后面，就能还原它本来的含义。</p>
<p>如果有两个<code>\</code>呢？那就是转义自身了。如果有三个<code>\</code>呢？我们得分成两段去理解。以此类推。</p>
<p>普通字符前面跟了一个<code>\</code>是什么效果？首先它们是一个整体，然后普通字符转义后还是普通字符。</p>
<h2 id="带反斜杠的元字符"><a href="#带反斜杠的元字符" class="headerlink" title="带反斜杠的元字符"></a>带反斜杠的元字符</h2><p>一般来说，普通字符前面带反斜杠还是普通字符，但是有一些普通字符，带反斜杠后反而变成了元字符。</p>
<p>要怪只能怪计算机领域的常用符号太少了。<br>元字符含义\b匹配一个单词边界(boundary)\B匹配一个非单词边界\d匹配一个数字字符(digit)\D匹配一个非数字字符\s匹配一个空白字符(space)\S匹配一个非空白字符\w匹配一个字母或者一个数字或者一个下划线(word)\W匹配一个字母、数字和下划线之外的字符<br>你这么聪明，肯定一眼就看出来，大写代表反义。对，就是这么好记。</p>
<h4 id="b元字符"><a href="#b元字符" class="headerlink" title="\b元字符"></a>\b元字符</h4><p><code>\b</code>匹配的也是一个位置，而不是一个字符。单词和空格之间的位置，就是所谓单词边界。</p>
<pre><code>&apos;hello regex&apos;.match(/\bregex$/);
// [&quot;regex&quot;, index: 6, input: &quot;hello regex&quot;, groups: undefined]&apos;hello regex&apos;.match(/\Bregex$/);
// null复制代码
</code></pre><p>所谓单词边界，对中文等其他语言是无效的。</p>
<pre><code>&apos;jiangshuying gaoyuanyuan huosiyan&apos;.match(/\bgaoyuanyuan\b/);
// [&quot;gaoyuanyuan&quot;, index: 13, input: &quot;jiangshuying gaoyuanyuan huosiyan&quot;, groups: undefined]&apos;江疏影 高圆圆 霍思燕&apos;.match(/\b高圆圆\b/);
// null复制代码
</code></pre><p>所以<code>\b</code>翻译一下就是<code>^\w|\w$|\W\w|\w\W</code>。</p>
<h4 id="d元字符"><a href="#d元字符" class="headerlink" title="\d元字符"></a>\d元字符</h4><p><code>\d</code>匹配一个数字，注意，这里的数字不是指JavaScript中的数字类型，因为文本全是字符串。它指的是代表数字的字符。</p>
<pre><code>&apos;123&apos;.match(/\d/);
// [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined]复制代码
</code></pre><h4 id="s元字符"><a href="#s元字符" class="headerlink" title="\s元字符"></a>\s元字符</h4><p><code>\s</code>匹配一个空白字符。</p>
<p>这里需要解释一下什么是空白字符。</p>
<p>空白字符不是空格，它是空格的超集。很多人说它是<code>\f\n\r\t\v</code>的总和，其中<code>\f</code>是换页符，<code>\n</code>是换行符，<code>\r</code>是回车符，<code>\t</code>是水平制表符，<code>\v</code>是垂直制表符。是这样么？</p>
<pre><code>&apos;a b&apos;.match(/\w\s\w/);
// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]&apos;a b&apos;.match(/\w\f\w/);
// null&apos;a b&apos;.match(/\w\n\w/);
// null&apos;a b&apos;.match(/\w\r\w/);
// null&apos;a b&apos;.match(/\w\t\w/);
// null&apos;a b&apos;.match(/\w\v\w/);
// null&apos;a b&apos;.match(/\w \w/);
// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]复制代码
</code></pre><p>这样说的人，明显是没有做过实验。其实正确的写法是<code>空格\f\n\r\t\v</code>的总和，集合里面包含一个空格，可千万别忽略了。诶，难道空格在正则中的写法就是<code>空一格</code>么，是的，就是这样随意。</p>
<p>这个集合中很多都是不可打印字符，估计只有<code>\n</code>是我们的老朋友。所以，如果不需要区分空格和换行的话，那就大胆的用<code>\s</code>吧。</p>
<h4 id="w元字符"><a href="#w元字符" class="headerlink" title="\w元字符"></a>\w元字符</h4><p><code>\w</code>匹配一个字母或者一个数字或者一个下划线。为什么要将它们放一起？想一想JavaScript中的变量规则，包括很多应用的用户名都只能是这三样，所以把它们放一起挺方便的。</p>
<p>不过要注意，字母指的是26个英文字母，其他的不行。</p>
<pre><code>&apos;正则&apos;.match(/\w/);
// null复制代码
</code></pre><h4 id="负阴抱阳"><a href="#负阴抱阳" class="headerlink" title="负阴抱阳"></a>负阴抱阳</h4><p>如果我们将大写和小写的带反斜杠的元字符组合在一起，就能匹配任何字符。是的，不针对任何人。</p>
<pre><code>&apos;@regex&apos;.match(/[\s\S]/);
// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码
</code></pre><p>方括号的含义我们先按下不表。</p>
<h2 id="道生一"><a href="#道生一" class="headerlink" title="道生一"></a>道生一</h2><p><code>.</code>在正则中的含义仙风道骨，它匹配换行符之外的任意单个字符。</p>
<p>如果文本不存在换行符，那么<code>.</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p>
<p>如果文本存在换行符，那么<code>(.|\n)</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p>
<pre><code>&apos;@regex&apos;.match(/./);
// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码
</code></pre><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>前面我们一直在强调，一个元字符只匹配一个字符。即便强大如<code>.</code>它也只能匹配一个。</p>
<p>那匹配<code>gooooogle</code>的正则是不是得写成<code>/gooooogle/</code>呢？</p>
<p>正则冷笑，并向你发射一个蔑视。</p>
<p>如果匹配的模式有重复，我们可以声明它重复的次数。<br>量词含义?重复零次或者一次+重复一次或者多次，也就是至少一次*重复零次或者多次，也就是任意次数{n}重复n次{n,}重复n次或者更多次{n,m}重复n次到m次之间的次数，包含n次和m次<br>有三点需要注意：</p>
<ul>
<li><p><code>?</code>在诸如匹配http协议的时候非常有用，就像这样：<code>/http(s)?/</code>。它在正则中除了是量词还有别的含义，后面会提到。</p>
</li>
<li><p>我们习惯用<code>/.*/</code>来匹配若干对我们没有价值的文本，它的含义是<code>若干除换行符之外的字符</code>。比如我们需要文本两头的格式化信息，中间是什么无所谓，它就派上用场了。不过它的性能可不好。</p>
</li>
<li><p><code>{n,m}</code>之间不能有空格，空格在正则中是有含义的。</p>
</li>
</ul>
<p>关于量词最令人困惑的是：它重复什么？</p>
<p>它重复紧贴在它前面的某个集合。第一点，必须是紧贴在它前面；第二点，重复一个集合。最常见的集合就是一个字符，当然正则中有一些元字符能够将若干字符变成一个集合，后面会讲到。</p>
<pre><code>&apos;gooooogle&apos;.match(/go{2,5}gle/);
// [&quot;gooooogle&quot;, index: 0, input: &quot;gooooogle&quot;, groups: undefined]复制代码
</code></pre><p>如果一个量词紧贴在另一个量词后面会怎样？</p>
<pre><code>&apos;gooooogle&apos;.match(/go{2,5}+gle/);
// Uncaught SyntaxError: Invalid regular expression: /go{2,5}+gle/: Nothing to repeat复制代码
</code></pre><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>前面提到量词不能紧跟在另一个量词后面，马上要👋👋打脸了。</p>
<pre><code>&apos;https&apos;.match(/http(s)?/);
// [&quot;https&quot;, &quot;s&quot;, index: 0, input: &quot;https&quot;, groups: undefined]&apos;https&apos;.match(/http(s)??/);
// [&quot;http&quot;, undefined, index: 0, input: &quot;https&quot;, groups: undefined]复制代码
</code></pre><p>然而，我的脸是这么好打的？</p>
<p>紧跟在<code>?</code>后面的<code>?</code>它不是一个量词，而是一个模式切换符，从贪婪模式切换到非贪婪模式。</p>
<p>贪婪模式在正则中是默认的模式，就是在既定规则之下匹配尽可能多的文本。因为正则中有量词，它的重复次数可能是一个区间，这就有了取舍。</p>
<p>紧跟在量词之后加上<code>?</code>就可以开启非贪婪模式。怎么省事怎么来。</p>
<p>这里的要点是，<code>?</code>必须紧跟着量词，否则的话它自己就变成量词了。</p>
<h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>正则中的普通字符只能匹配它自己。如果我要匹配一个普通字符，但是我不确定它是什么，怎么办？</p>
<pre><code>&apos;grey or gray&apos;.match(/gr[ae]y/);
// [&quot;grey&quot;, index: 0, input: &quot;grey or gray&quot;, groups: undefined]复制代码
</code></pre><p>方括号在正则中表示一个区间，我们称它为字符组。</p>
<p>首先，字符组中的字符集合只是所有的可选项，最终它只能匹配一个字符。</p>
<p>然后，字符组是一个独立的世界，元字符不需要转义。</p>
<pre><code>&apos;$&apos;.match(/[$&amp;@]/);
// [&quot;$&quot;, index: 0, input: &quot;$&quot;, groups: undefined]复制代码
</code></pre><p>最后，有两个字符在字符组中有特殊含义。</p>
<p><code>^</code>在字符组中表示取反，不再是文本开始的位置了。</p>
<pre><code>&apos;regex&apos;.match(/[^abc]/);
// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p>如果我就要<code>^</code>呢？前面已经讲过了，转义。</p>
<p><code>-</code>本来是一个普通字符，在字符组中摇身一变成为连字符。</p>
<pre><code>&apos;13&apos;.match(/[1-9]3/);
// [&quot;13&quot;, index: 0, input: &quot;13&quot;, groups: undefined]复制代码
</code></pre><p>连字符的意思是匹配范围在它的左边字符和右边字符之间。</p>
<p>如果我这样呢？</p>
<pre><code>&apos;abc-3&apos;.match(/[0-z]/);
// [&quot;a&quot;, index: 0, input: &quot;abc-3&quot;, groups: undefined]复制代码

&apos;xyz-3&apos;.match(/[0-c]/);
// [&quot;3&quot;, index: 4, input: &quot;xyz-3&quot;, groups: undefined]复制代码

&apos;xyz-3&apos;.match(/[0-$]/);
// Uncaught SyntaxError: Invalid regular expression: /[0-$]/: Range out of order in character class复制代码
</code></pre><p>发现什么了没有？只有两种字符是可以用连字符的：英文字母和数字。而且英文字母可以和数字连起来，英文字母的顺序在后面。这和扑克牌<code>1 2 3 4 5 6 7 8 9 10 J Q K</code>是一个道理。</p>
<h2 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h2><p>我们已经知道量词是怎么回事了，我们也知道量词只能重复紧贴在它前面的字符。</p>
<p>如果我要重复的是一串字符呢？</p>
<pre><code>&apos;i love you very very very much&apos;.match(/i love you very +much/);
// null&apos;i love you very very very much&apos;.match(/i love you v+e+r+y+ +much/);
// null复制代码
</code></pre><p>这样肯定是不行的。是时候请圆括号出山了。</p>
<pre><code>&apos;i love you very very very much&apos;.match(/i love you (very )+much/);
// [&quot;i love you very very very much&quot;, &quot;very &quot;, index: 0, input: &quot;i love you very very very much&quot;, groups: undefined]复制代码
</code></pre><p>圆括号的意思是将它其中的字符集合打包成一个整体，然后量词就可以操作这个整体了。这和方括号的效果是完全不一样的。</p>
<p>而且默认的，圆括号的匹配结果是可以捕获的。</p>
<h4 id="正则内捕获"><a href="#正则内捕获" class="headerlink" title="正则内捕获"></a>正则内捕获</h4><p>现在我们有一个需求，匹配<code>&lt;div&gt;</code>标签。</p>
<pre><code>&apos;&lt;div&gt;hello regex&lt;/div&gt;&apos;.match(/&lt;div&gt;.*&lt;\/div&gt;/);
// [&quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, index: 0, input: &quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, groups: undefined]复制代码
</code></pre><p>这很简单。但如果我要匹配的是任意标签，包括自定义的标签呢？</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;([a-zA-Z]+)&gt;.*&lt;\/\1&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: undefined]复制代码
</code></pre><p>这时候就要用到正则的捕获特性。正则内捕获使用<code>\数字</code>的形式，分别对应前面的圆括号捕获的内容。这种捕获的引用也叫<strong>反向引用</strong>。</p>
<p>我们来看一个更复杂的情况：</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&apos;.match(/&lt;((A|a)pp)&gt;(hello regex)+&lt;\/\1&gt;&lt;p&gt;\2&lt;\/p&gt;&lt;p&gt;\3&lt;\/p&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, &quot;App&quot;, &quot;A&quot;, &quot;hello regex&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, groups: undefined]复制代码
</code></pre><p>如果有嵌套的圆括号，那么捕获的引用是先递归的，然后才是下一个顶级捕获。</p>
<h4 id="正则外捕获"><a href="#正则外捕获" class="headerlink" title="正则外捕获"></a>正则外捕获</h4><pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]RegExp.$1;
// &quot;abc&quot;复制代码
</code></pre><p>没错，<code>RegExp</code>就是构造正则的构造函数。如果有捕获组，它的实例属性<code>$数字</code>会显示对应的引用。</p>
<p>如果有多个正则呢？</p>
<pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@xyz&apos;.match(/@(xyz)/);
// [&quot;@xyz&quot;, &quot;xyz&quot;, index: 0, input: &quot;@xyz&quot;, groups: undefined]RegExp.$1;
// &quot;xyz&quot;复制代码
</code></pre><p><code>RegExp</code>构造函数的引用只显示最后一个正则的捕获。</p>
<p>另外还有一个字符串实例方法也支持正则捕获的引用，它就是<code>replace</code>方法。</p>
<pre><code>&apos;hello **regex**&apos;.replace(/\*{2}(.*)\*{2}/, &apos;&lt;strong&gt;$1&lt;/strong&gt;&apos;);
// &quot;hello &lt;strong&gt;regex&lt;/strong&gt;&quot;复制代码
</code></pre><p>实际上它才是最常用的引用捕获的方式。</p>
<h4 id="捕获命名"><a href="#捕获命名" class="headerlink" title="捕获命名"></a>捕获命名</h4><blockquote>
<p>这是ES2018的新特性。</p>
</blockquote>
<p>使用<code>\数字</code>引用捕获必须保证捕获组的顺序不变。现在开发者可以给捕获组命名了，有了名字以后，引用起来更加确定。</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;(?&lt;tag&gt;[a-zA-Z]+)&gt;.*&lt;\/\k&lt;tag&gt;&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: {tag: &quot;App&quot;}]复制代码
</code></pre><p>在捕获组内部最前面加上<code>?&lt;key&gt;</code>，它就被命名了。使用<code>\k&lt;key&gt;</code>语法就可以引用已经命名的捕获组。</p>
<p>是不是很简单？</p>
<p>通常情况下，开发者只是想在正则中将某些字符当成一个整体看待。捕获组很棒，但是它做了额外的事情，肯定需要额外的内存占用和计算资源。于是正则又有了非捕获组的概念。</p>
<pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@abc&apos;.match(/@(?:abc)/);
// [&quot;@abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]复制代码
</code></pre><p>只要在圆括号内最前面加上<code>?:</code>标识，就是告诉正则引擎：我只要这个整体，不需要它的引用，你就别费劲了。从上面的例子也可以看出来，<code>match</code>方法返回的结果有些许不一样。</p>
<p>个人观点：我觉得正则的捕获设计应该反过来，默认不捕获，加上<code>?:</code>标识后才捕获。因为大多数时候开发者是不需要捕获的，但是它又懒得加<code>?:</code>标识，会有些许性能浪费。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>有时候开发者需要在正则中使用<code>或者</code>。</p>
<pre><code>&apos;高圆圆&apos;.match(/陈乔恩|高圆圆/);
// [&quot;高圆圆&quot;, index: 0, input: &quot;高圆圆&quot;, groups: undefined]复制代码
</code></pre><p><code>|</code>就代表<code>或者</code>。字符组其实也是一个多选结构，但是它们俩有本质区别。字符组最终只能匹配一个字符，而分支匹配的是左边所有的字符或者右边所有的字符。</p>
<p>我们来看一个例子：</p>
<pre><code>&apos;我喜欢高圆圆&apos;.match(/我喜欢陈乔恩|高圆圆/);
// [&quot;高圆圆&quot;, index: 3, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码
</code></pre><p>因为<code>|</code>是将左右两边一切两半，然后匹配左边或者右边。所以上面的正则显然达不到我们想要的效果。这个时候就需要一个东西来缩小分支的范围。诶，你可能已经想到了：</p>
<pre><code>&apos;我喜欢高圆圆&apos;.match(/我喜欢(?:陈乔恩|高圆圆)/);
// [&quot;我喜欢高圆圆&quot;, index: 0, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码
</code></pre><p>没错，就是圆括号。</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>正则中有一些元字符，它不匹配字符，而是匹配一个位置。比如之前提到的<code>^</code>和<code>$</code>。<code>^</code>的意思是说这个位置应该是文本开始的位置。</p>
<p>正则还有一些比较高级的匹配位置的语法，它匹配的是：在这个位置之前或之后应该有什么内容。</p>
<p>零宽(zero-width)是什么意思？指的就是它匹配一个位置，本身没有宽度。</p>
<p>断言(assertion)是什么意思？指的是一种判断，断言之前或之后应该有什么或应该没有什么。</p>
<h4 id="零宽肯定先行断言"><a href="#零宽肯定先行断言" class="headerlink" title="零宽肯定先行断言"></a>零宽肯定先行断言</h4><p>所谓的肯定就是判断有什么，而不是判断没有什么。</p>
<p>而先行指的是向前看(lookahead)，断言的这个位置是为前面的规则服务的。</p>
<p>语法很简单：圆括号内最左边加上<code>?=</code>标识。</p>
<pre><code>&apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)/);
// [&quot;Java&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码
</code></pre><p>上面匹配的是四个字母，这四个字母要满足以下条件：紧跟着的应该是<code>Script</code>字符串，而且<code>Script</code>字符串应该是单词的结尾部分。</p>
<p>所以，零宽肯定先行断言的意思是：现在有一段正则语法，用这段语法去匹配给定的文本。但是，满足条件的文本不仅要匹配这段语法，紧跟着它的必须是一个位置，这个位置又必须满足一段正则语法。</p>
<p>说的再直白点，我要匹配一段文本，但是这段文本后面必须紧跟着另一段特定的文本。零宽肯定先行断言就是一个界碑，我要满足前面和后面所有的条件，但是我只要前面的文本。</p>
<p>我们来看另一种情况：</p>
<pre><code>&apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)\w+/);
// [&quot;JavaScript&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码
</code></pre><p>上面的例子更加直观，零宽肯定先行断言已经匹配过<code>Script</code>一次了，后面的<code>\w+</code>却还是能匹配<code>Script</code>成功，足以说明它的<code>零宽</code>特性。它为紧贴在它前面的规则服务，并且不影响后面的匹配规则。</p>
<h4 id="零宽肯定后行断言"><a href="#零宽肯定后行断言" class="headerlink" title="零宽肯定后行断言"></a>零宽肯定后行断言</h4><p>先行是向前看，那后行就是向后看(lookbehind)咯。</p>
<p>语法是圆括号内最左边加上<code>?&lt;=</code>标识。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍\S+/);
// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><p>一个正则可以有多个断言：</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍.+?(?=\s|$)/);
// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><h4 id="零宽否定先行断言"><a href="#零宽否定先行断言" class="headerlink" title="零宽否定先行断言"></a>零宽否定先行断言</h4><p>肯定是判断有什么，否定就是判断没有什么咯。</p>
<p>语法是圆括号内最左边加上<code>?!</code>标识。</p>
<pre><code>&apos;TypeScript Perl JavaScript&apos;.match(/\b\w{4}(?!Script\b)/);
// [&quot;Perl&quot;, index: 11, input: &quot;TypeScript Perl JavaScript&quot;, groups: undefined]复制代码
</code></pre><h4 id="零宽否定后行断言"><a href="#零宽否定后行断言" class="headerlink" title="零宽否定后行断言"></a>零宽否定后行断言</h4><p>语法是圆括号最左边加上<code>?&lt;!</code>标识。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;!演员)霍\S+/);
// [&quot;霍去病&quot;, index: 8, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>正则表达式除了主体语法，还有若干可选的模式修饰符。</p>
<p>写法就是将修饰符安插在正则主体的尾巴上。比如这样：<code>/abc/gi</code>。</p>
<h4 id="g修饰符"><a href="#g修饰符" class="headerlink" title="g修饰符"></a>g修饰符</h4><p><code>g</code>是<code>global</code>的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。<code>g</code>修饰符会开启全局匹配模式，找到所有匹配的结果。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/);
// [&quot;高圆圆&quot;, index: 2, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/g);
// [&quot;高圆圆&quot;, &quot;霍思燕&quot;]复制代码
</code></pre><h4 id="i修饰符"><a href="#i修饰符" class="headerlink" title="i修饰符"></a>i修饰符</h4><p><code>i</code>是<code>ignoreCase</code>的缩写。默认情况下，<code>/z/</code>是无法匹配<code>Z</code>的，所以我们有时候不得不这样写：<code>/[a-zA-Z]/</code>。<code>i</code>修饰符可以全局忽略大小写。</p>
<p>很多时候我们不在乎文本是大写、小写还是大小写混写，这个修饰符还是很有用的。</p>
<pre><code>&apos;javascript is great&apos;.match(/JavaScript/);
// null&apos;javascript is great&apos;.match(/JavaScript/i);
// [&quot;javascript&quot;, index: 0, input: &quot;javascript is great&quot;, groups: undefined]复制代码
</code></pre><h4 id="m修饰符"><a href="#m修饰符" class="headerlink" title="m修饰符"></a>m修饰符</h4><p><code>m</code>是<code>multiline</code>的缩写。这个修饰符有特定起作用的场景：它要和<code>^</code>和<code>$</code>搭配起来使用。默认情况下，<code>^</code>和<code>$</code>匹配的是文本的开始和结束，加上<code>m</code>修饰符，它们的含义就变成了行的开始和结束。</p>
<pre><code>`
abc
xyz
`.match(/xyz/);
// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]`
abc
xyz
`.match(/^xyz$/);
// null`
abc
xyz
`.match(/^xyz$/m);
// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码
</code></pre><h4 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h4><blockquote>
<p>这是ES2015的新特性。</p>
</blockquote>
<p><code>y</code>是<code>sticky</code>的缩写。<code>y</code>修饰符有和<code>g</code>修饰符重合的功能，它们都是全局匹配。所以重点在<code>sticky</code>上，怎么理解这个<code>粘连</code>呢？</p>
<p><code>g</code>修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是<code>y</code>修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。</p>
<pre><code>&apos;a bag with a tag has a mag&apos;.match(/\wag/g);
// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]&apos;a bag with a tag has a mag&apos;.match(/\wag/y);
// null&apos;bagtagmag&apos;.match(/\wag/y);
// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]&apos;bagtagmag&apos;.match(/\wag/gy);
// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]复制代码
</code></pre><p>有人肯定发现了猫腻：你不是说<code>y</code>修饰符是全局匹配么？看上面的例子，单独一个<code>y</code>修饰符用match方法怎么并不是全局匹配呢？</p>
<p>诶，这里说来就话长了。</p>
<p>长话短说呢，就涉及到<code>y</code>修饰符的本质是什么。它的本质有二：</p>
<ul>
<li>全局匹配(先别着急打我)。</li>
<li>从文本的<code>lastIndex</code>位置开始新的匹配。lastIndex是什么？它是正则表达式的一个属性，如果是全局匹配，它用来标注下一次匹配的起始点。这才是粘连的本质所在。</li>
</ul>
<p>不知道你们发现什么了没有：<strong>lastIndex是正则表达式的一个属性</strong>。而上面例子中的match方法是作用在字符串上的，都没有lastIndex属性，休怪人家工作不上心。</p>
<pre><code>const reg = /\wag/y;
reg.exec(&apos;bagtagmag&apos;);
// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]
reg.exec(&apos;bagtagmag&apos;);
// [&quot;tag&quot;, index: 3, input: &quot;bagtagmag&quot;, groups: undefined]
reg.exec(&apos;bagtagmag&apos;);
// [&quot;mag&quot;, index: 6, input: &quot;bagtagmag&quot;, groups: undefined]复制代码
</code></pre><p>咱们换成正则方法exec，多次执行，正则的lastIndex在变，匹配的结果也在变。全局匹配无疑了吧。</p>
<h4 id="s修饰符"><a href="#s修饰符" class="headerlink" title="s修饰符"></a>s修饰符</h4><blockquote>
<p>这是ES2018的新特性。</p>
</blockquote>
<p><code>s</code>不是<code>dotAll</code>的缩写。<code>s</code>修饰符要和<code>.</code>搭配使用，默认情况下，<code>.</code>匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。</p>
<p><code>s</code>修饰符的作用就是让<code>.</code>可以匹配任意单个字符。</p>
<p><code>s</code>是<code>singleline</code>的缩写。</p>
<pre><code>`
abc
xyz
`.match(/c.x/);
// null`
abc
xyz
`.match(/c.x/s);
// [&quot;c↵x&quot;, index: 3, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码
</code></pre><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><blockquote>
<p>这是ES2015的新特性。</p>
</blockquote>
<p><code>u</code>是<code>unicode</code>的缩写。有一些Unicode字符超过一个字节，正则就无法正确的识别它们。<code>u</code>修饰符就是用来处理这些不常见的情况的。</p>
<pre><code>&apos;𠮷&apos;.match(/^.$/);
// null&apos;𠮷&apos;.match(/^.$/u);
// [&quot;𠮷&quot;, index: 0, input: &quot;𠮷&quot;, groups: undefined]复制代码
</code></pre><p><code>𠮷</code>念<code>jí</code>，与<code>吉</code>同义。</p>
<p>笔者对Unicode认识尚浅，这里不过多展开。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


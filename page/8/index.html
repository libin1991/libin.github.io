<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/03/JS类型判断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/03/JS类型判断/" itemprop="url">JS类型判断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-03T22:55:27+08:00">
                2017-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="先看typeof"><a href="#先看typeof" class="headerlink" title="先看typeof"></a>先看typeof</h2><pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;

        &lt;/style&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var a;
            console.log(&quot;1:&quot; + typeof a);
            var b = null;
            console.log(&quot;2:&quot; + typeof b);
            var c = undefined;
            console.log(&quot;3:&quot; + typeof c);
            var d = new Object;
            console.log(&quot;4:&quot; + typeof d);
            var e = function() {};
            console.log(&quot;5:&quot; + typeof e);
            var f = {};
            console.log(&quot;6:&quot; + typeof f);
            var g = &apos;&apos;;
            console.log(&quot;7:&quot; + typeof g);
            var h = [];
            console.log(&quot;8:&quot; + typeof h);
            var i = true;
            console.log(&quot;9:&quot; + typeof i);
            var j = 123;
            console.log(&quot;10:&quot; + typeof j);
            var k = NaN;
            console.log(&quot;11:&quot; + typeof k);
            var l = /^[-+]?\d+$/;
            console.log(&quot;12:&quot; + typeof l);
        &lt;/script&gt;

    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>按照上面的打印结果,总结出下面要注意的几点</p>
<ul>
<li>typeof (引用类型) 除了函数, 都是 ‘object’,比如 typeof /123/</li>
<li>typeof null 为’object’</li>
<li>typeof undefined 为 ‘undefined’,通常, 如果使用两等号, null == undefined 为真.</li>
<li><p>转换为数字的常见用法 “10”-0或+”10”, 如果没有转换成功,返回NaN,由于NaN 的一个特性: NaN != NaN,故判断转换成功与否的常见做法: (这也是我参见 jQuery的源码发现的,jQuery源码读100遍都不为过)</p>
<p>(“10x” - 0) == (“10x” - 0);<br>// 结果为假!   </p>
</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-6f58d81de68683e272adaf7c340aa518_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-6f58d81de68683e272adaf7c340aa518_hd.jpg" alt=""></p>
<h2 id="再看看constructor-和-instanceof"><a href="#再看看constructor-和-instanceof" class="headerlink" title="再看看constructor 和 instanceof"></a>再看看constructor 和 instanceof</h2><pre><code>instanceof 用于判断一个变量是否某个对象的实例,或用于判断一个变量是否某个对象的实例；
constructor 用于判断一个变量的原型，constructor 属性返回对创建此对象的数组函数的引用。
Javascript中对象的prototype属性的解释是:返回对象类型原型的引用。
&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log(&quot;----------------Number---------------&quot;);
            var A = 123;
            console.log(A instanceof Number); //false
            console.log(A.constructor == Number); //true
            console.log(A.constructor);
            console.log(&quot;----------------String---------------&quot;);
            var B = &quot;javascript&quot;;
            console.log(B instanceof String); //false
            console.log(B.constructor == String); //true
            console.log(B.constructor);
            console.log(&quot;----------------Boolean---------------&quot;);
            var C = true;
            console.log(C instanceof Boolean); //false
            console.log(C.constructor == Boolean); //true
            console.log(C.constructor);
            console.log(&quot;----------------null---------------&quot;);
            var D = null;
            console.log(D instanceof Object); //false
            //console.log(D.constructor == null); //报错
            //console.log(D.constructor); //报错
            console.log(&quot;----------------undefined---------------&quot;);
            var E = undefined;
            //console.log(E instanceof undefined); // //报错
            //console.log(E.constructor == undefined); //报错
            //console.log(E.constructor); //报错
            console.log(&quot;----------------function---------------&quot;);
            var F = function() {};
            console.log(F instanceof Function);
            console.log(F.constructor == Function);
            console.log(F.constructor);
            console.log(&quot;----------------new function---------------&quot;);
            function SB() {};
            var G = new SB();
            console.log(G instanceof SB);
            console.log(G.constructor == SB);
            console.log(G.constructor);
            console.log(&quot;----------------new Object---------------&quot;);
            var H = new Object;
            console.log(H instanceof Object);
            console.log(H.constructor == Object);
            console.log(H.constructor);
            console.log(&quot;-----------------Array--------------&quot;);
            var I = [];
            console.log(I instanceof Array);
            console.log(I.constructor == Array);
            console.log(I.constructor);
            console.log(&quot;-----------------JSON--------------&quot;);
            var J = {
                &quot;good&quot;: &quot;js&quot;,
                &quot;node&quot;: &quot;very good&quot;
            };
            console.log(J instanceof Object);
            console.log(J.constructor == Object);
            console.log(J.constructor);
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic4.zhimg.com/v2-21d3ca864773ef451c189c0fd954f14a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-21d3ca864773ef451c189c0fd954f14a_hd.jpg" alt=""></p>
<h2 id="再看看-toString-call-obj"><a href="#再看看-toString-call-obj" class="headerlink" title="再看看{}.toString.call(obj)"></a>再看看{}.toString.call(obj)</h2><pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log({}.toString.call(1));
            console.log({}.toString.call(&quot;11&quot;));
            console.log({}.toString.call(/123/));
            console.log({}.toString.call({}));
            console.log({}.toString.call(function() {}));
            console.log({}.toString.call([]));
            console.log({}.toString.call(true));
            console.log({}.toString.call(new Date()));
            console.log({}.toString.call(new Error()));
            console.log({}.toString.call(null));
            console.log({}.toString.call(undefined));
            console.log(String(null));
            console.log(String(undefined));
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic1.zhimg.com/v2-2d04b5646ab716650f46286dd0be9747_b.jpg" alt=""></p>
<h2 id="使用jQuery中的方法-type"><a href="#使用jQuery中的方法-type" class="headerlink" title="使用jQuery中的方法$.type()"></a>使用jQuery中的方法$.type()</h2><p>现在看看jQuery是怎么做的</p>
<pre><code>// 先申明一个对象,目的是用来做映射
var class2type = {};
// 申明一个core_toString() 的方法,得到最原始的toString() 方法,因为在很多对象中,toStrintg() 已经被重写 
var core_toString() = class2type.toString;
// 这里为 toStrintg() 后的结果和类型名做一个映射,申明一个core_toString() 后的结果,而值就是类型名
jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) {
    class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
});


&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log($.type(1));
            console.log($.type(&quot;11&quot;));
            console.log($.type(/123/));
            console.log($.type({}));
            console.log($.type(function() {}));
            console.log($.type([]));
            console.log($.type(true));
            console.log($.type(new Date()));
            console.log($.type(new Error()));
            console.log($.type(null));
            console.log($.type(undefined));
            console.log(String(null));
            console.log(String(undefined));
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-05899b1b3bcf02e58f2eb987ef69594a_b.jpg" alt=""></p>
<p>上面的打印结果与</p>
<pre><code>class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
</code></pre><p>不谋而合!</p>
<p>这是jQuery.type 的核心方法</p>
<pre><code>type: function( obj ) {
    if ( obj == null ) {
        return String( obj );
    }
    // Support: Safari &lt;= 5.1 (functionish RegExp)
    return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
        class2type[ core_toString.call(obj) ] || &quot;object&quot; :
        typeof obj;
},
</code></pre><blockquote>
<p>注意,为什么把 null 或者 undefined 单独讨论呢,因为 在一些版本浏览器中<br>console.log(core_toString.call(null));<br>console.log(core_toString.call(undefined));</p>
</blockquote>
<pre><code>这是会报错的!


如果是对象类型,另:由于 在一些低版本的浏览器中,typeof /123/ 会返回的是 &quot;function&quot; 而不是 &quot;object&quot;,所以这里要判断是否是函数,要明白 这里的 typeof obj === function 不是为了函数讨论的,因为函数本身就可以通过typeof 来得到类型.

typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
        class2type[ core_toString.call(obj) ]
</code></pre><p>就直接返回class2type 中键值对的结果,,如果不是,那么一定就是基本类型, 通过 typeof 就可以啦.</p>
<pre><code>class2type[ core_toString.call(obj) ] || &quot;object&quot; :
// 这是防止一些未知情况的,如果未取到,就返回object
</code></pre><h2 id="但是-jQuery-type-有一个很大的缺陷"><a href="#但是-jQuery-type-有一个很大的缺陷" class="headerlink" title="但是 jQuery.type 有一个很大的缺陷"></a>但是 jQuery.type 有一个很大的缺陷</h2><p>这是一个自定义类型</p>
<pre><code>function Person() {
    this.name = &apos;pawn&apos;;
}
var p = new Person();
console.log($.type(p));
console.log({}.toString.call(p));
</code></pre><blockquote>
<p>// 注意,这里会打印 [object Object],通过上面的方法,无法得到精确的自定义类型<br>这也是 它的一个大缺陷了!</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/v2-32ad7e97fff63ad11925460861e4ef9e_b.jpg" alt=""></p>
<p>下面,我们通过构造函数的方式来获取精确类型</p>
<h2 id="通过构造函数来获取类型"><a href="#通过构造函数来获取类型" class="headerlink" title="通过构造函数来获取类型"></a>通过构造函数来获取类型</h2><p>在理解这个方法之前,需要理解两个点</p>
<p>prorotype 原型属性</p>
<pre><code>我们知道,任何对象或者函数都直接或者间接的继承自Object 或者 Function， （其实最终Function 是继承自 Object 的，这属于原型链的知识了，见下图）。那么，任何一个对象都具有原型对象 __proto__ (这个对象只在chrome 和 firefox 暴露，但是在其他浏览器中也是存在的)，这个原型对象就是这个对象的构造函数的原型属性(这里可能有点绕,直接上图).
</code></pre><p><img src="https://pic4.zhimg.com/v2-9a1d9c8359714d86fdac5b90d36547ac_b.jpg" alt=""></p>
<p>由于 任何函数都具有 原型属性prototype,并且这个原型属性具有一个默认属性 constructor,它是这个函数的引用,看下面的代码</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 console.log(Person.prototype.constructor === Person);   //true
</code></pre><p>发现,这两个东西其实一个东西</p>
<p>但是,在某些情况下,需要这么写</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 Person.protype = {
     XX: ... ,
     xx: ... ,
     ...
 }
</code></pre><p>这么做,就会覆盖原本的 protype 方法,那么construcor 就不存在了,这是,必须要显示的申明这个对象，</p>
<h2 id="construction-Person-这句话非常重要，作用是修正this指向"><a href="#construction-Person-这句话非常重要，作用是修正this指向" class="headerlink" title="construction: Person, 这句话非常重要，作用是修正this指向"></a>construction: Person, 这句话非常重要，作用是修正this指向</h2><pre><code>Person.protype = {
     construction: Person,   //这句话的作用是修正this指向
     XX: ... ,
     xx: ... ,
     ...
 }
</code></pre><p>在jQuery的中,就是这么做的,</p>
<pre><code>jQuery.fn = jQuery.prototype = {
   constructor: jQuery,
   init: function( selector, context, rootjQuery ) {
       var match, elem;
</code></pre><blockquote>
<p>关于 jQuery对象封装的方式 也是非常值得研究</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-720d122b9b125559f5fb75f2178b25f9_b.jpg" alt=""></p>
<p>注意,这里已经不是熟悉 [object Object],而是 已经重写了.</p>
<p>也就是,如果调用一个函数的toString() 方法.那么就会打印这个函数的函数体.</p>
<p><img src="https://pic3.zhimg.com/v2-b6640c61635718af42b8fb7ce00daf63_b.jpg" alt=""></p>
<p>如何通过构造函数来获得变量的类型?</p>
<p>判断是否是基本类型</p>
<pre><code>var getType = function(obj){
     if(obj == null){
        return String(obj);
     }
     if(typeof obj === &apos;object&apos; || typeof obj === &apos;fucntion&apos;){
         ...
     }else{
         // 如果不是引用类型,那么就是基本类型
         return typeof obj
     }
 }
</code></pre><p>如果是对象或者函数类型</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 var p = new Person();
 console.log(p.constructor);   //返回function Person(){...}
</code></pre><p>现在要做的事 : 如何将Person 提取出来呢?<br>毋庸置疑,字符串切割那一套肯定可以办到,但是太 low 啦!<br>这里,我使用正则将Person提取出来</p>
<pre><code>var regex = /function\s(.+?)\(/
function Person(){
  this.name = &apos;pawn&apos;;
 }
 var p = new Person();
 var c = p.constructor
 var regex = /function\s(.+?)\(/;
 console.log(&apos;|&apos; + regex.exec(c)[1] + &apos;|&apos;);
</code></pre><p><img src="https://pic1.zhimg.com/v2-798dac45bc14f57445c3f12c53a95856_b.jpg" alt=""></p>
<p>其实,除了上面的正则,每个函数还有一个name属性,返回函数名,但是ie8 是不支持的.</p>
<p>因此上面的代码可以写为:</p>
<pre><code>var getType = function(obj){
    if(obj == null){
        return String(obj);
    }
    if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){ 
        var constructor = obj.constructor;
        if(constructor &amp;&amp; constructor.name){
            return constructor.name;
        }
        var regex = /function\s(.+?)\(/;
        return regex.exec(c)[1];
    }else{
        // 如果不是引用类型,那么就是基本;类型
        return typeof obj;
    }
};
</code></pre><p>但是上面的代码太丑啦,将其简化</p>
<p>简化</p>
<pre><code>var getType = function(obj){
    if(obj == null){
        return String(obj);
    }
    if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){ 
        return obj.constructor &amp;&amp; obj.constructor.name.toLowerCase() || 
          /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase();
    }else{
        // 如果不是引用类型,那么就是基本类型
        return typeof obj;
    }
};
</code></pre><p>还是比较麻烦,继续简化</p>
<pre><code>var getType = function(obj){
    if(obj == null){
       return String(obj);
    }
    return typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos; ?
      obj.constructor &amp;&amp; obj.constructor.name &amp;&amp; obj.constructor.name.toLowerCase() ||
          /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase():
      typeof obj;
};
</code></pre><p>好了,已经全部弄完了,写个代码测试一下:</p>
<pre><code>function Person(){
    this.name = &apos;pawn&apos;;
}
var p = new Person();

console.log(getType(p));
console.log(getType(1));
console.log(getType(&quot;a&quot;));
console.log(getType(false));
console.log(getType(/123/));
console.log(getType({}));
console.log(getType(function(){}));
console.log(getType(new Date()));
console.log(getType(new Error()));
console.log(getType( null));
console.log(getType( undefined));
</code></pre><p><img src="https://pic2.zhimg.com/v2-45d3c3f08f70b60b05ed1c8885a5ada8_b.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-fe845739a4f557bdf52bc85f1e7a2823_b.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-0cb813f94a182e42c1214445bf96abf3_b.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-e97820f7d32bab80b31beee769505529_b.jpg" alt=""></p>
<h2 id="1-有时会看到Object-prototype-toString-call"><a href="#1-有时会看到Object-prototype-toString-call" class="headerlink" title="1.有时会看到Object.prototype.toString.call()"></a>1.有时会看到Object.prototype.toString.call()</h2><p><img src="https://pic1.zhimg.com/v2-2c236d4c9534822e61fca4fcab53cf40_b.jpg" alt=""></p>
<h2 id="2-toString-是一个怎样的方法-他定义在哪里？"><a href="#2-toString-是一个怎样的方法-他定义在哪里？" class="headerlink" title="2.toString()是一个怎样的方法,他定义在哪里？"></a>2.toString()是一个怎样的方法,他定义在哪里？</h2><p><img src="https://pic2.zhimg.com/v2-462bb123e83ec081f7fffca86dd9baee_b.jpg" alt=""></p>
<h2 id="3-call-apply-bind可以吗？"><a href="#3-call-apply-bind可以吗？" class="headerlink" title="3.call.apply.bind可以吗？"></a>3.call.apply.bind可以吗？</h2><p><img src="https://pic4.zhimg.com/v2-f396bb49abd0ca789e28d1741aa6360f_b.jpg" alt=""></p>
<h2 id="4-为神马要去call呢？用-Object-prototype-toString-call-obj-而不用-obj-toString-呢？"><a href="#4-为神马要去call呢？用-Object-prototype-toString-call-obj-而不用-obj-toString-呢？" class="headerlink" title="4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？"></a>4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function A(){
                this.say=function(){
                    console.log(&quot;我是1&quot;);
                }
            }
            function B(){
                this.say=function(){
                    console.log(&quot;我是2&quot;);
                }
            }
            var a=new A();
            var b=new B();
            a.say.call(b);    //我是1
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function A(){
                this.name=&apos;SB&apos;;
                this.say=function(){
                    console.log(&quot;我是1&quot;);
                }
            }
            function B(){
                A.call(this);   //B继承A，重写say方法
                this.say=function(){
                    console.log(&quot;我是2&quot;);
                }
            }
            var a=new A();
            var b=new B();
            console.log(b.name);  //SB
            b.say();         //我是2
            a.say.call(b);    //我是1
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="就是怕你重写了toString-所以才要用object-最原始的他toString-所以才去call。"><a href="#就是怕你重写了toString-所以才要用object-最原始的他toString-所以才去call。" class="headerlink" title="就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。"></a>就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。</h2><h2 id="5-Object-prototype-toString方法的原理是什么？"><a href="#5-Object-prototype-toString方法的原理是什么？" class="headerlink" title="5.Object.prototype.toString方法的原理是什么？"></a>5.Object.prototype.toString方法的原理是什么？</h2><p>参考链接：<a href="https://link.zhihu.com/?target=http%3A//www.jb51.net/article/79941.htm" target="_blank" rel="noopener">http://www.jb51.net/article/79941.htm</a></p>
<p>在JavaScript中,想要判断某个对象值属于哪种内置类型,最靠谱的做法就是通过Object.prototype.toString方法.</p>
<p>12var arr = [];console.log(Object.prototype.toString.call(arr)) //“[object Array]”</p>
<p>本文要讲的就是,toString方法是如何做到这一点的,原理是什么.</p>
<p>ECMAScript 3</p>
<p>在ES3中,Object.prototype.toString方法的规范如下:</p>
<p>115.2.4.2 Object.prototype.toString()</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<ol>
<li><p>获取this对象的[[Class]]属性的值.</p>
</li>
<li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串.</p>
</li>
<li><p>返回第二步的操作结果Result(2).</p>
</li>
</ol>
<p>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的</p>
<p>[[Class]]一个字符串值,表明了该对象的类型.</p>
<p>然后给了一段解释:</p>
<p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2).</p>
<p>也就是说,把Object.prototype.toString方法返回的字符串,去掉前面固定的”[object “和后面固定的”]”,就是内部属性[[class]]的值,也就达到了判断对象类型的目的.jQuery中的工具方法$.type(),就是干这个的.</p>
<p>在ES3中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有10种.分别是:”Array”, “Boolean”, “Date”, “Error”, “Function”, “Math”, “Number”, “Object”, “RegExp”, “String”.</p>
<p>ECMAScript 5</p>
<p>在ES5.1中,除了规范写的更详细一些以外,Object.prototype.toString方法和[[class]]内部属性的定义上也有一些变化,Object.prototype.toString方法的规范如下:</p>
<p>15.2.4.2 Object.prototype.toString ( )</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<p>如果this的值为undefined,则返回”[object Undefined]”.</p>
<p>如果this的值为null,则返回”[object Null]”.</p>
<p>让O成为调用ToObject(this)的结果.</p>
<p>让class成为O的内部属性[[Class]]的值.</p>
<p>返回三个字符串”[object “, class, 以及 “]”连接后的新字符串.</p>
<p>可以看出,比ES3多了1,2,3步.第1,2步属于新规则,比较特殊,因为”Undefined”和”Null”并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this的值才会保持undefined或null,非严格模式下会自动成为全局对象).第3步并不算是新规则,因为在ES3的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来.ES5中,[[Class]]属性的解释更加详细:</p>
<p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2).</p>
<p>和ES3对比一下,第一个差别就是[[class]]内部属性的值多了两种,成了12种,一种是arguments对象的[[class]]成了”Arguments”,而不是以前的”Object”,还有就是多个了全局对象JSON,它的[[class]]值为”JSON”.第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这12种值冲突,不过在支持ES3的浏览器中,貌似也没有发现哪些宿主对象故意使用那10个值.</p>
<p>ECMAScript 6</p>
<p>ES6目前还只是工作草案,但能够肯定的是,[[class]]内部属性没有了,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的:</p>
<p>内部属性属性值描述<br>[[NativeBrand]]枚举NativeBrand的一个成员.该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型.</p>
<p>[[NativeBrand]]属性的解释:</p>
<p>[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的ECMAScript原生对象.只有在表10中明确指出的对象类型才有[[NativeBrand]]内部属性.</p>
<p>表10 — [[NativeBrand]]内部属性的值</p>
<p>属性值对应类型<br>NativeFunctionFunction objects<br>NativeArrayArray objects<br>StringWrapperString objects<br>BooleanWrapperBoolean objects<br>NumberWrapperNumber objects<br>NativeMathThe Math object<br>NativeDateDate objects<br>NativeRegExpRegExp objects<br>NativeErrorError objects<br>NativeJSONThe JSON object<br>NativeArgumentsArguments objects<br>NativePrivateNamePrivate Name objects</p>
<p>可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]].同时,Object.prototype.toString方法的规范也改成了下面这样:</p>
<p>15.2.4.2 Object.prototype.toString ( )</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<p>如果this的值为undefined,则返回”[object Undefined]”.</p>
<p>如果this的值为null,则返回”[object Null]”.</p>
<p>让O成为调用ToObject(this)的结果.</p>
<p>如果O有[[NativeBrand]]内部属性,让tag成为表29中对应的值.</p>
<p>否则</p>
<p>让hasTag成为调用O的[[HasProperty]]内部方法后的结果,参数为@@toStringTag.</p>
<p>如果hasTag为false,则让tag为”Object”.</p>
<p>否则,</p>
<p>让tag成为调用O的[[Get]]内部方法后的结果,参数为@@toStringTag.</p>
<p>如果tag是一个abrupt completion,则让tag成为NormalCompletion(“???”).</p>
<p>让tag成为tag.[[value]].</p>
<p>如果Type(tag)不是字符串,则让tag成为”???”.</p>
<p>如果tag的值为”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”,或</p>
<p>者”String”中的任一个,则让tag成为字符串”~”和tag当前的值连接后的结果.</p>
<p>返回三个字符串”[object “, tag, and “]”连接后的新字符串.</p>
<p>表29 — [[NativeBrand]] 标志值</p>
<p>[[NativeBrand]]值标志值<br>NativeFunction”Function”<br>NativeArray”Array”<br>StringWrapper”String”<br>BooleanWrapper”Boolean”<br>NumberWrapper”Number”<br>NativeMath”Math”<br>NativeDate”Date”<br>NativeRegExp”RegExp”<br>NativeError”Error”<br>NativeJSON”JSON”<br>NativeArguments”Arguments”</p>
<p>可以看到,在规范上有了很大的变化,不过对于普通用户来说,貌似感觉不到.</p>
<p>也许你发现了,ES6里的新类型Map,Set等,都没有在表29中.它们在执行toString方法的时候返回的是什么?</p>
<p>console.log(Object.prototype.toString.call(Map())) //“[object Map]”</p>
<p>console.log(Object.prototype.toString.call(Set())) //“[object Set]”</p>
<p>其中的字符串”Map”是怎么来的呢:</p>
<p>15.14.5.13 Map.prototype.@@toStringTag</p>
<p>@@toStringTag 属性的初始值为字符串”Map”.</p>
<p>由于ES6的规范还在制定中,各种相关规定都有可能改变,所以如果想了解更多细节.看看下面这两个链接,现在只需要知道的是:[[class]]没了,使用了更复杂的机制.</p>
<p>以上所述是小编给大家分享的JavaScript中Object.prototype.toString方法的原理，希望对大家有所帮助！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/31/JavaScript进阶提高必读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/31/JavaScript进阶提高必读/" itemprop="url">JavaScript进阶提高必读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-31T23:40:40+08:00">
                2016-12-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="冴羽写博客的地方"><a href="#冴羽写博客的地方" class="headerlink" title="冴羽写博客的地方"></a><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">冴羽写博客的地方</a></h2><h2 id="vue源码-内部运行机制剖析"><a href="#vue源码-内部运行机制剖析" class="headerlink" title="vue源码-内部运行机制剖析"></a><a href="https://github.com/DIVIBEAR/vue" target="_blank" rel="noopener">vue源码-内部运行机制剖析</a></h2><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>JavaScript深入系列 15 篇已完结。</p>
<p>JavaScript专题系列 20 篇已完结。</p>
<p>underscore 系列 8 篇已完结。</p>
<h2 id="深入系列目录"><a href="#深入系列目录" class="headerlink" title="深入系列目录"></a>深入系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScirpt深入之从原型到原型链</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript深入之执行上下文栈</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript深入之变量对象</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">JavaScript深入之作用域链</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">JavaScript深入之从ECMAScript规范解读this</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">JavaScript深入之执行上下文</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">JavaScript深入之闭包</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/10" target="_blank" rel="noopener">JavaScript深入之参数按值传递</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">JavaScript深入之类数组对象与arguments</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/15" target="_blank" rel="noopener">JavaScript深入之创建对象的多种方式以及优缺点</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">JavaScript深入之继承的多种方式以及优缺点</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/17" target="_blank" rel="noopener">JavaScript深入系列15篇正式完结！</a></li>
</ol>
<h2 id="专题系列目录"><a href="#专题系列目录" class="headerlink" title="专题系列目录"></a>专题系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">JavaScript专题之跟着underscore学防抖</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">JavaScript专题之跟着underscore学节流</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/27" target="_blank" rel="noopener">JavaScript专题之数组去重</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">JavaScript专题之类型判断(上)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/30" target="_blank" rel="noopener">JavaScript专题之类型判断(下)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener">JavaScript专题之深浅拷贝</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/33" target="_blank" rel="noopener">JavaScript专题之从零实现jQuery的extend</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/35" target="_blank" rel="noopener">JavaScript专题之如何求数组的最大值和最小值</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/36" target="_blank" rel="noopener">JavaScript专题之数组扁平化</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/37" target="_blank" rel="noopener">JavaScript专题之学underscore在数组中查找指定元素</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/40" target="_blank" rel="noopener">JavaScript专题之jQuery通用遍历方法each的实现</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/41" target="_blank" rel="noopener">JavaScript专题之如何判断两个对象相等</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript专题之函数柯里化</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/43" target="_blank" rel="noopener">JavaScript专题之偏函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/44" target="_blank" rel="noopener">JavaScript专题之惰性函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/45" target="_blank" rel="noopener">JavaScript专题之函数组合</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/46" target="_blank" rel="noopener">JavaScript专题之函数记忆</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/49" target="_blank" rel="noopener">JavaScript专题之递归</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/51" target="_blank" rel="noopener">JavaScript专题之乱序</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/52" target="_blank" rel="noopener">JavaScript专题之解读 v8 排序源码</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/53" target="_blank" rel="noopener">JavaScript专题系列20篇正式完结！</a></li>
</ol>
<h2 id="underscore-系列目录"><a href="#underscore-系列目录" class="headerlink" title="underscore 系列目录"></a>underscore 系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/56" target="_blank" rel="noopener">underscore 系列之如何写自己的 underscore</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/57" target="_blank" rel="noopener">underscore 系列之链式调用</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/58" target="_blank" rel="noopener">underscore 系列之内部函数 cb 和 optimizeCb</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/60" target="_blank" rel="noopener">underscore 系列之内部函数 restArgs</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/62" target="_blank" rel="noopener">underscore 系列之防冲突与 Utility Functions</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/63" target="_blank" rel="noopener">underscore 系列之实现一个模板引擎(上)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/70" target="_blank" rel="noopener">underscore 系列之实现一个模板引擎(下)</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/77" target="_blank" rel="noopener">underscore 系列之字符实体与 _.escape</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/79" target="_blank" rel="noopener">underscore 的源码该如何阅读？</a></li>
</ol>
<h2 id="ES6-系列目录"><a href="#ES6-系列目录" class="headerlink" title="ES6 系列目录"></a>ES6 系列目录</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/82" target="_blank" rel="noopener">ES6 系列之 let 和 const</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/84" target="_blank" rel="noopener">ES6 系列之模板字符串</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/85" target="_blank" rel="noopener">ES6 系列之箭头函数</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/87" target="_blank" rel="noopener">ES6 系列之模拟实现 Symbol 类型</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/90" target="_blank" rel="noopener">ES6 系列之迭代器与 for of</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/91" target="_blank" rel="noopener">ES6 系列之模拟实现一个 Set 数据结构</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/92" target="_blank" rel="noopener">ES6 系列之 WeakMap</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/98" target="_blank" rel="noopener">ES6 系列之我们来聊聊 Promise</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/99" target="_blank" rel="noopener">ES6 系列之 Generator 的自动执行</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/22/JavaScript-模块化解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/22/JavaScript-模块化解析/" itemprop="url">JavaScript 模块化解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T19:47:32+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>随着 JavasScript 语言逐渐发展，JavaScript 应用从简单的表单验证，到复杂的网站交互，再到服务端，移动端，PC 客户端的语言支持。JavaScript 应用领域变的越来越广泛，工程代码变得越来越庞大，代码的管理变得越来越困难，于是乎 JavaScript 模块化方案在社区中应声而起，其中一些优秀的模块化方案，逐渐成为 JavaScript 的语言规范，下面我们就 JavaScript 模块化这个话题展开讨论，本文的主要包含以几部分内容。</p>
<ul>
<li>什么是模块</li>
<li>为什么需要模块化</li>
<li>JavaScript 模块化之 CommonJS</li>
<li>JavaScript 模块化之 AMD</li>
<li>JavaScript 模块化之 CMD</li>
<li>JavaScript 模块化之 ES Module</li>
<li>总结</li>
</ul>
<h2 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h2><p>模块，又称构件，是能够单独命名并独立地完成一定功能的程序语句的集合 (即程序代码和数据结构的集合体)。它具有两个基本的特征：外部特征和内部特征。外部特征是指模块跟外部环境联系的接口 (即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量) 和模块的功能，内部特征是指模块的内部环境具有的特点 (即该模块的局部数据和程序代码)。简而言之，模块就是一个具有独立作用域，对外暴露特定功能接口的代码集合。</p>
<h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><p>首先让我们回到过去，看看原始 JavaScript 模块文件的写法。</p>
<pre><code>// add.jsfunctionadd(a, b) {
  return a + b;
}
// decrease.jsfunctiondecrease(a, b) {
  return a - b;
}

// formula.jsfunctionsquare_difference(a, b) {
  return add(a, b) * decrease(a, b);
}
</code></pre><p>上面我们在三个 JavaScript 文件里面，实现了几个功能函数。其中，第三个功能函数需要依赖第一个和第二个 JavaScript 文件的功能函数，所以我们在使用的时候，一般会这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">		&lt;head&gt;</span><br><span class="line">		  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">		  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">		  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">		&lt;/head&gt;</span><br><span class="line">		&lt;body&gt;</span><br><span class="line">		    &lt;script src=&quot;add.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;script src=&quot;decrease.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;script src=&quot;formula.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		    &lt;!--使用--&gt;</span><br><span class="line">		    &lt;script&gt;</span><br><span class="line">		       var result = square_difference(3, 4);</span><br><span class="line">		    &lt;/script&gt;</span><br><span class="line">		&lt;/body&gt;</span><br><span class="line">	&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这样的管理方式会造成以下几个问题：</span><br><span class="line"></span><br><span class="line">- 模块的引入顺序可能会出错</span><br><span class="line">- 会污染全局变量</span><br><span class="line">- 模块之间的依赖关系不明显</span><br><span class="line"></span><br><span class="line">基于上述的原因，就有了对上述问题的解决方案，即是 JavaScript 模块化规范，目前主流的有 CommonJS，AMD，CMD，ES6 Module 这四种规范。</span><br><span class="line"></span><br><span class="line">## Javascript 模块化之 CommonJS</span><br><span class="line"></span><br><span class="line">CommonJS 规范的主要内容有，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中，下面讲述一下 NodeJs 中 CommonJS 的模块化机制。</span><br><span class="line"></span><br><span class="line">### 使用方式</span><br><span class="line"></span><br><span class="line">    // 模块定义 add.jsmodule.eports.add = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 模块定义 decrease.jsmodule.exports.decrease = function(a, b) &#123;</span><br><span class="line">      return a - b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // formula.js,模块使用，利用 require() 方法加载模块,require 导出的即是 module.exports 的内容const add = require(&quot;./add.js&quot;).add;</span><br><span class="line">    const decrease = require(&quot;./decrease.js&quot;).decrease;</span><br><span class="line">    module.exports.square_difference = function(a, b) &#123;</span><br><span class="line">      return add(a, b) * decrease(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### exports 和 module.exports</span><br><span class="line"></span><br><span class="line">exports 和 module.exports 是指向同一个东西的变量，即是 module.exports = exports = &#123;&#125;，所以你也可以这样导出模块</span><br><span class="line"></span><br><span class="line">    //add.js</span><br><span class="line">    exports.add = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是如果直接修改 exports 的指向是无效的，例如:</span><br><span class="line"></span><br><span class="line">    // add.js</span><br><span class="line">    exports = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    // main.jsvar add = require(&quot;./add.js&quot;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">此时得到的 add 是一个空对象，因为 require 导入的是，对应模块的 module.exports 的内容，在上面的代码中，虽然一开始 exports = module.exports，但是当执行如下代码的时候，其实就将 exports 指向了 function,而 module.exports 的内容并没有改变，所以这个模块的导出为空对象。</span><br><span class="line"></span><br><span class="line">    exports = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### CommonJS 在 NodeJs 中的模块加载机制</span><br><span class="line"></span><br><span class="line">以下根据 [NodeJs 中 CommonJS 模块加载源码](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnodejs%2Fnode%2Fblob%2Fmaster%2Flib%2Finternal%2Fmodules%2Fcjs%2Floader.js) 来分析 NodeJS 中模块的加载机制。</span><br><span class="line"></span><br><span class="line">在 NodeJs 中引入模块 (require)，需要经历如下 3 个步骤：</span><br><span class="line"></span><br><span class="line">1. 路径分析</span><br><span class="line">2. 文件定位</span><br><span class="line">3. 编译执行</span><br><span class="line"></span><br><span class="line">与前端浏览器会缓存静态脚本文件以提高性能一样，NodeJs 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的是，浏览器仅缓存文件，而在 NodeJs 中缓存的是编译和执行后的对象。</span><br><span class="line"></span><br><span class="line">#### 路径分析 + 文件定位</span><br><span class="line"></span><br><span class="line">其流程如下图所示：</span><br><span class="line">#### 模块编译</span><br><span class="line"></span><br><span class="line">在定位到文件后，首先会检查该文件是否有缓存，有的话直接读取缓存，否则，会新创建一个 Module 对象，其定义如下：</span><br><span class="line"></span><br><span class="line">    functionModule(id, parent) &#123;</span><br><span class="line">      this.id = id; // 模块的识别符，通常是带有绝对路径的模块文件名。this.exports = &#123;&#125;; // 表示模块对外输出的值this.parent = parent; // 返回一个对象，表示调用该模块的模块。if (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">        this.parent.children.push(this);</span><br><span class="line">      &#125;</span><br><span class="line">      this.filename = null;</span><br><span class="line">      this.loaded = false; // 返回一个布尔值，表示模块是否已经完成加载。this.childrent = []; // 返回一个数组，表示该模块要用到的其他模块。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">require 操作代码如下所示：</span><br><span class="line"></span><br><span class="line">    Module.prototype.require = function(id) &#123;</span><br><span class="line">      // 检查模块标识符if (typeof id !== &quot;string&quot;) &#123;</span><br><span class="line">        thrownew ERR_INVALID_ARG_TYPE(&quot;id&quot;, &quot;string&quot;, id);</span><br><span class="line">      &#125;</span><br><span class="line">      if (id === &quot;&quot;) &#123;</span><br><span class="line">        thrownew ERR_INVALID_ARG_VALUE(&quot;id&quot;, id, &quot;must be a non-empty string&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 调用模块加载方法return Module._load(id, this, /* isMain */false);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">接下来是解析模块路径，判断是否有缓存，然后生成 Module 对象：</span><br><span class="line"></span><br><span class="line">    Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">      if (parent) &#123;</span><br><span class="line">        debug(&quot;Module._load REQUEST %s parent: %s&quot;, request, parent.id);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 解析文件名var filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line">    </span><br><span class="line">      var cachedModule = Module._cache[filename];</span><br><span class="line">    </span><br><span class="line">      // 判断是否有缓存，有的话返回缓存对象的 exportsif (cachedModule) &#123;</span><br><span class="line">        updateChildren(parent, cachedModule, true);</span><br><span class="line">        return cachedModule.exports;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 判断是否为原生核心模块，是的话从内存加载if (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">        debug(&quot;load native module %s&quot;, request);</span><br><span class="line">        return NativeModule.require(filename);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 生成模块对象varmodule = new Module(filename, parent);</span><br><span class="line">    </span><br><span class="line">      if (isMain) &#123;</span><br><span class="line">        process.mainModule = module;</span><br><span class="line">        module.id = &quot;.&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 缓存模块对象</span><br><span class="line">      Module._cache[filename] = module;</span><br><span class="line">    </span><br><span class="line">      // 加载模块</span><br><span class="line">      tryModuleLoad(module, filename);</span><br><span class="line">    </span><br><span class="line">      returnmodule.exports;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">tryModuleLoad 的代码如下所示：</span><br></pre></td></tr></table></figure></p>
<pre><code>functiontryModuleLoad(module, filename) {
  var threw = true;
  try {
    // 调用模块实例load方法module.load(filename);
    threw = false;
  } finally {
    if (threw) {
      // 如果加载出错，则删除缓存delete Module._cache[filename];
    }
  }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块对象执行载入操作 module.load 代码如下所示：</span><br></pre></td></tr></table></figure>
<pre><code>Module.prototype.load = function(filename) {
  debug(&quot;load %j for module %j&quot;, filename, this.id);

  assert(!this.loaded);
  this.filename = filename;

  // 解析路径this.paths = Module._nodeModulePaths(path.dirname(filename));

  // 判断扩展名，并且默认为 .js 扩展var extension = path.extname(filename) || &quot;.js&quot;;

  // 判断是否有对应格式文件的处理函数， 没有的话，扩展名改为 .jsif (!Module._extensions[extension]) extension = &quot;.js&quot;;

  // 调用相应的文件处理方法，并传入模块对象
  Module._extensions[extension](this, filename);
  this.loaded = true;

  // 处理 ES Moduleif (experimentalModules) {
    if (asyncESM === undefined) lazyLoadESM();
    const ESMLoader = asyncESM.ESMLoader;
    const url = pathToFileURL(filename);
    const urlString = `${url}`;
    const exports = this.exports;
    if (ESMLoader.moduleMap.has(urlString) !== true) {
      ESMLoader.moduleMap.set(
        urlString,
        new ModuleJob(ESMLoader, url, async () =&gt; {
          const ctx = createDynamicModule([&quot;default&quot;], url);
          ctx.reflect.exports.default.set(exports);
          return ctx;
        })
      );
    } else {
      const job = ESMLoader.moduleMap.get(urlString);
      if (job.reflect) job.reflect.exports.default.set(exports);
    }
  }
};
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这里同步读取模块，再执行编译操作：</span><br></pre></td></tr></table></figure>
<pre><code>Module._extensions[&quot;.js&quot;] = function(module, filename) {
  // 同步读取文件var content = fs.readFileSync(filename, &quot;utf8&quot;);

  // 编译代码module._compile(stripBOM(content), filename);
};
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译过程主要做了以下的操作：</span><br><span class="line"></span><br><span class="line">1. 将 JavaScript 代码用函数体包装，隔离作用域，例如：</span><br></pre></td></tr></table></figure>
<pre><code>exports.add = (function(a, b) {
  return a + b;
}
</code></pre><p><code>`</code><br>会被转换为</p>
<pre><code>(
  function(exports, require, modules, __filename, __dirname) {
    exports.add = function(a, b) {
      return a + b;
    };
  }
);
</code></pre><ol>
<li><p>执行函数，注入模块对象的 exports 属性，require 全局方法，以及对象实例，<strong>filename, </strong>dirname，然后执行模块的源码。</p>
</li>
<li><p>返回模块对象 exports 属性。</p>
</li>
</ol>
<h2 id="JavaScript-模块化之-AMD"><a href="#JavaScript-模块化之-AMD" class="headerlink" title="JavaScript 模块化之 AMD"></a>JavaScript 模块化之 AMD</h2><p>AMD, Asynchronous Module Definition，即异步模块加载机制，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句都定义在一个回调函数中，等到依赖加载完成之后，这个回调函数才会运行。</p>
<p>AMD 的诞生，就是为了解决这两个问题：</p>
<ol>
<li>实现 JavaScript 文件的异步加载，避免网页失去响应</li>
<li><p>管理模块之间的依赖性，便于代码的编写和维护</p>
<p> // 模块定义<br>  define(id?: String, dependencies?: String[], factory: Function|Object);</p>
</li>
</ol>
<p>id 是模块的名字，它是可选的参数。</p>
<p>dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数。每个依赖的模块的输出都将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。</p>
<p>factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值，如果是对象，此对象应该为模块的输出值。</p>
<p>举个例子：</p>
<pre><code>// 模块定义，add.js
define(function() {
  let add = function(a, b) {
    return a + b;
  };
  return add;
});

// 模块定义，decrease.js
define(function() {
  let decrease = function(a, b) {
    return a - b;
  };
  return decrease;
});

// 模块定义，square.js
define([&quot;./add&quot;, &quot;./decrease&quot;], function(add, decrease) {
  let square = function(a, b) {
    return add(a, b) * decrease(a, b);
  };
  return square;
});

// 模块使用，主入口文件 main.jsrequire([&quot;square&quot;], function(math) {
  console.log(square(6, 3));
});
</code></pre><p>这里用实现了 AMD 规范的 RequireJS 来分析，RequireJS 源码较为复杂，这里只对异步模块加载原理做一个分析。在加载模块的过程中， RequireJS 会调用如下函数：</p>
<pre><code>/**
 *
 * @param {Object} context the require context to find state.
 * @param {String} moduleName the name of the module.
 * @param {Object} url the URL to the module.
 */
req.load = function(context, moduleName, url) {
  var config = (context &amp;&amp; context.config) || {},
    node;
  // 判断是否为浏览器if (isBrowser) {
    // 根据模块名称和 url 创建一个 Script 标签
    node = req.createNode(config, moduleName, url);

    node.setAttribute(&quot;data-requirecontext&quot;, context.contextName);
    node.setAttribute(&quot;data-requiremodule&quot;, moduleName);

    // 对不同的浏览器 Script 标签事件监听做兼容处理if (
      node.attachEvent &amp;&amp;
      !(
        node.attachEvent.toString &amp;&amp;
        node.attachEvent.toString().indexOf(&quot;[native code&quot;) &lt; 0
      ) &amp;&amp;
      !isOpera
    ) {
      useInteractive = true;

      node.attachEvent(&quot;onreadystatechange&quot;, context.onScriptLoad);
    } else {
      node.addEventListener(&quot;load&quot;, context.onScriptLoad, false);
      node.addEventListener(&quot;error&quot;, context.onScriptError, false);
    }

    // 设置 Script 标签的 src 属性为模块路径
    node.src = url;

    if (config.onNodeCreated) {
      config.onNodeCreated(node, config, moduleName, url);
    }

    currentlyAddingScript = node;

    // 将 Script 标签插入到页面中if (baseElement) {
      head.insertBefore(node, baseElement);
    } else {
      head.appendChild(node);
    }
    currentlyAddingScript = null;

    return node;
  } elseif (isWebWorker) {
    try {
      //In a web worker, use importScripts. This is not a very//efficient use of importScripts, importScripts will block until//its script is downloaded and evaluated. However, if web workers//are in play, the expectation is that a build has been done so//that only one script needs to be loaded anyway. This may need//to be reevaluated if other use cases become common.// Post a task to the event loop to work around a bug in WebKit// where the worker gets garbage-collected after calling// importScripts(): https://webkit.org/b/153317
      setTimeout(function() {}, 0);
      importScripts(url);

      //Account for anonymous modules
      context.completeLoad(moduleName);
    } catch (e) {
      context.onError(
        makeError(
          &quot;importscripts&quot;,
          &quot;importScripts failed for &quot; + moduleName + &quot; at &quot; + url,
          e,
          [moduleName]
        )
      );
    }
  }
};

// 创建异步 Script 标签
req.createNode = function(config, moduleName, url) {
  var node = config.xhtml
    ? document.createElementNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;html:script&quot;)
    : document.createElement(&quot;script&quot;);
  node.type = config.scriptType || &quot;text/javascript&quot;;
  node.charset = &quot;utf-8&quot;;
  node.async = true;
  return node;
};
</code></pre><p>可以看出，这里主要是根据模块的 Url，创建了一个异步的 Script 标签，并将模块 id 名称添加到的标签的 data-requiremodule 上，再将这个 Script 标签添加到了 html 页面中。同时为 Script 标签的 load 事件添加了处理函数，当该模块文件被加载完毕的时候，就会触发 context.onScriptLoad。我们在 onScriptLoad 添加断点，可以看到页面结构如下图所示:<br> 由图可以看到，Html 中添加了一个 Script 标签，这也就是异步加载模块的原理。</p>
<h2 id="JavaScript-模块化之-CMD"><a href="#JavaScript-模块化之-CMD" class="headerlink" title="JavaScript 模块化之 CMD"></a>JavaScript 模块化之 CMD</h2><p>CMD (Common Module Definition) 通用模块定义，CMD 在浏览器端的实现有 SeaJS， 和 RequireJS 一样，SeaJS 加载原理也是动态创建异步 Script 标签。二者的区别主要是依赖写法上不同，AMD 推崇一开始就加载所有的依赖，而 CMD 则推崇在需要用的地方才进行依赖加载。</p>
<pre><code>// ADM 在执行以下代码的时候，RequireJS 会首先分析依赖数组，然后依次加载，直到所有加载完毕再执行回到函数
define([&quot;add&quot;, &quot;decrease&quot;], function(add, decrease) {
  let result1 = add(9, 7);
  let result2 = decrease(9, 7);
  console.log(result1 * result2);
});

// CMD 在执行以下代码的时候， SeaJS 会首先用正则匹配出代码里面所有的 require 语句，拿到依赖，然后依次加载，加载完成再执行回调函数
define(function(require) {
  let add = require(&quot;add&quot;);
  let result1 = add(9, 7);
  let add = require(&quot;decrease&quot;);
  let result2 = decrease(9, 7);
  console.log(result1 * result2);
});
</code></pre><h2 id="JavaScript-模块化之-ES-Module"><a href="#JavaScript-模块化之-ES-Module" class="headerlink" title="JavaScript 模块化之 ES Module"></a>JavaScript 模块化之 ES Module</h2><p>ES Module 是在 ECMAScript 6 中引入的模块化功能。模块功能主要由两个命令构成，分别是 export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>
<p>其使用方式如下:</p>
<pre><code>// 模块定义 add.jsexportfunctionadd(a, b) {
  return a + b;
}

// 模块使用 main.jsimport { add } from&quot;./add.js&quot;;
console.log(add(1, 2)); // 3
</code></pre><p>下面讲述几个较为重要的点。</p>
<h3 id="export-和-export-default"><a href="#export-和-export-default" class="headerlink" title="export 和 export default"></a>export 和 export default</h3><p>在一个文件或模块中，export 可以有多个，export default 仅有一个, export 类似于具名导出，而 default 类似于导出一个变量名为 default 的变量。同时在 import 的时候，对于 export 的变量，必须要用具名的对象去承接，而对于 default，则可以任意指定变量名，例如：</p>
<pre><code>// a.jsexportvar a = 2;
 exportvar b = 3 ;
// main.js 在导出的时候必须要用具名变量 a, b 且以解构的方式得到导出变量import {a, b} from&apos;a.js&apos;// √ a= 2, b = 3import a from&apos;a.js&apos;// x// b.js export default 方式const a = 3exportdefault a // 注意不能 export default const a = 3 ,因为这里 default 就相当于一个变量名// 导出import b form &apos;b.js&apos;// √import c form &apos;b.js&apos;// √ 因为 b 模块导出的是 default，对于导出的default，可以用任意变量去承接
</code></pre><h3 id="ES-Module-模块加载和导出过程"><a href="#ES-Module-模块加载和导出过程" class="headerlink" title="ES Module 模块加载和导出过程"></a>ES Module 模块加载和导出过程</h3><p>以如下代码为例子：</p>
<pre><code>// counter.jsexportlet count = 5// display.jsexportfunctionrender() {
   console.log(&apos;render&apos;)
 }
 // main.jsimport { counter } from&apos;./counter.js&apos;;
 import { render } from&apos;./display.js&apos;
 ......// more code
</code></pre><p>在模块加载模块的过程中，主要经历以下几个步骤：</p>
<h4 id="构建-Construction"><a href="#构建-Construction" class="headerlink" title="构建 (Construction)"></a>构建 (Construction)</h4><p>这个过程执行查找，下载，并将文件转化为模块记录 (Module record)。所谓的模块记录是指一个记录了对应模块的语法树，依赖信息，以及各种属性和方法 (这里不是很明白)。同样也是在这个过程对模块记录进行了缓存的操作，下图是一个模块记录表：</p>
<p>下图是缓存记录表：</p>
<h4 id="实例化-Instantiation"><a href="#实例化-Instantiation" class="headerlink" title="实例化 (Instantiation)"></a>实例化 (Instantiation)</h4><p>这个过程会在内存中开辟一个存储空间 (此时还没有填充值)，然后将该模块所有的 export 和 import 了该模块的变量指向这个内存，这个过程叫做链接。其写入 export 示意图如下所示：<br> 然后是链接 import，其示意图如下所示：</p>
<h4 id="赋值-Evaluation"><a href="#赋值-Evaluation" class="headerlink" title="赋值(Evaluation)"></a>赋值(Evaluation)</h4><p>这个过程会执行模块代码，并用真实的值填充上一阶段开辟的内存空间，此过程后 import 链接到的值就是 export 导出的真实值。</p>
<p>根据上面的过程我们可以知道。ES Module 模块 export 和 import 其实指向的是同一块内存，但有一个点需要注意的是，import 处不能对这块内存的值进行修改，而 export 可以，其示意图如下：</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对目前主流的 JavaScript 模块化方案 CommonJs，AMD，CMD, ES Module 进行了学习和了解，并对其中最有代表性的模块化实现 (NodeJs，RequireJS，SeaJS，ES6) 做了一个简单的分析。对于服务端的模块而言，由于其模块都是存储在本地的，模块加载方便，所以通常是采用同步读取文件的方式进行模块加载。而对于浏览器而言，其模块一般是存储在远程网络上的，模块的下载是一个十分耗时的过程，所以通常是采用动态异步脚本加载的方式加载模块文件。另外，无论是客户端还是服务端的 JavaScript 模块化实现，都会对模块进行缓存，以此减少二次加载的开销。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/11/防抖和节流原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/11/防抖和节流原理分析/" itemprop="url">防抖和节流原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-11T14:51:19+08:00">
                2016-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>窗口的resize、scroll、输入框内容校验等操作时，如果这些<strong>操作处理函数</strong>是较为复杂或页面频繁重渲染等操作时，在这种情况下如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来<strong>减少触发的频率</strong>，同时又不影响实际效果。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>debounce（防抖），简单来说就是防止抖动。</p>
<p>当持续触发事件时，debounce 会<strong>合并事件且不会去触发事件</strong>，<strong>当一定时间内没有触发再这个事件时，才真正去触发事件</strong>。</p>
<h3 id="非立即执行版"><a href="#非立即执行版" class="headerlink" title="非立即执行版"></a>非立即执行版</h3><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p>
<pre><code>const debounce = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() =&gt; {
      func.apply(context, args)
    },wait);
  }
}
</code></pre><p>如此调用：</p>
<pre><code>content.onmousemove = debounce(count,1000);
</code></pre><h3 id="立即执行版"><a href="#立即执行版" class="headerlink" title="立即执行版"></a>立即执行版</h3><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p>
<pre><code>const debounce = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if (timeout) cleatTimeout(timeout);
    let callNow = !timeout;
    timeout = setTimeout(() =&gt; {
      timeout = null;
    },wait)

    if(callNow) func.apply(context,args)
   }
}
</code></pre><h3 id="结合版"><a href="#结合版" class="headerlink" title="结合版"></a>结合版</h3><pre><code>/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */functiondebounce(func,wait,immediate) {
    var timeout;

    returnfunction () {
        var context = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}
</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>throttle（节流），当持续触发事件时，<strong>保证隔间时间触发一次事件</strong>。</p>
<p>持续触发事件时，throttle 会合并一定时间内的事件，并在该时间结束时真正去触发一次事件。</p>
<h3 id="时间戳版"><a href="#时间戳版" class="headerlink" title="时间戳版"></a>时间戳版</h3><p>在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。</p>
<pre><code>const throttle = (func, wait, ...args) =&gt; {
  let pre = 0;
  returnfunction(){
    const context = this;
    let now = Date.now();
    if (now - pre &gt;= wait){
       func.apply(context, args);
       pre = Date.now();
    }
  }
}
</code></pre><h3 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版"></a>定时器版</h3><p>在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p>
<pre><code>const throttle = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if(!timeout){
      timeout = setTimeout(() =&gt; {
        timeout = null;
        func.apply(context,args);
      },wait)
    }
  }
}
</code></pre><h3 id="结合版-1"><a href="#结合版-1" class="headerlink" title="结合版"></a>结合版</h3><p>其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p>
<pre><code>/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */functionthrottle(func, wait ,type) {
    if(type===1){
        var previous = 0;
    }elseif(type===2){
        var timeout;
    }

    returnfunction() {
        var context = this;
        var args = arguments;
        if(type===1){
            var now = Date.now();

            if (now - previous &gt; wait) {
                func.apply(context, args);
                previous = now;
            }
        }elseif(type===2){
            if (!timeout) {
                timeout = setTimeout(function() {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }

    }
}
</code></pre><h2 id="underscore-源码"><a href="#underscore-源码" class="headerlink" title="underscore 源码"></a>underscore 源码</h2><pre><code>/**
 * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行
 *
 * @param  {function} func        回调函数
 * @param  {number}   wait        表示时间窗口的间隔
 * @param  {boolean}  immediate   设置为ture时，是否立即调用函数
 * @return {function}             返回客户调用函数
 */
_.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      // 现在和上一次时间戳比较var last = _.now() - timestamp;
      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器if (last &lt; wait &amp;&amp; last &gt;= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        // 否则的话就是时间到了执行回调函数
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    returnfunction() {
      context = this;
      args = arguments;
      // 获得时间戳
      timestamp = _.now();
      // 如果定时器不存在且立即执行函数var callNow = immediate &amp;&amp; !timeout;
      // 如果定时器不存在就创建一个if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        // 如果需要立即执行函数的话 通过 apply 执行
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };
</code></pre><ul>
<li>对于按钮防点击来说的实现：一旦我开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了。</li>
<li><p>对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数。</p>
<p>  /**</p>
<ul>
<li>underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait<br>*</li>
<li>@param  {function}   func      回调函数</li>
<li>@param  {number}     wait      表示时间窗口的间隔</li>
<li>@param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。</li>
<li>如果想忽略结尾函数的调用，传入{trailing: false}</li>
<li>两者不能共存，否则函数不能执行</li>
<li>@return {function}             返回客户调用函数<br>*/<br>_.throttle = function(func, wait, options) {<br> var context, args, result;<br> var timeout = null;<br> // 之前的时间戳var previous = 0;<br> // 如果 options 没传则设为空对象if (!options) options = {};<br> // 定时器回调函数var later = function() {<br>   // 如果设置了 leading，就将 previous 设为 0// 用于下面函数的第一个 if 判断<br>   previous = options.leading === false ? 0 : _.now();<br>   // 置空一是为了防止内存泄漏，二是为了下面的定时器判断<br>   timeout = null;<br>   result = func.apply(context, args);<br>   if (!timeout) context = args = null;<br> };<br> returnfunction() {<br>   // 获得当前时间戳var now = _.now();<br>   // 首次进入前者肯定为 true// 如果需要第一次不执行函数// 就将上次时间戳设为当前的// 这样在接下来计算 remaining 的值时会大于0if (!previous &amp;&amp; options.leading === false) previous = now;<br>   // 计算剩余时间var remaining = wait - (now - previous);<br>   context = this;<br>   args = arguments;<br>   // 如果当前调用已经大于上次调用时间 + wait// 或者用户手动调了时间// 如果设置了 trailing，只会进入这个条件// 如果没有设置 leading，那么第一次会进入这个条件// 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了// 其实还是会进入的，因为定时器的延时// 并不是准确的时间，很可能你设置了2秒// 但是他需要2.2秒才触发，这时候就会进入这个条件if (remaining &lt;= 0 || remaining &gt; wait) {<pre><code>// 如果存在定时器就清理掉否则会调用二次回调if (timeout) {
  clearTimeout(timeout);
  timeout = null;
}
previous = now;
result = func.apply(context, args);
if (!timeout) context = args = null;
</code></pre>   } elseif (!timeout &amp;&amp; options.trailing !== false) {<pre><code>// 判断是否设置了定时器和 trailing// 没有的话就开启一个定时器// 并且不能不能同时设置 leading 和 trailing
timeout = setTimeout(later, remaining);
</code></pre>   }<br>   return result;<br> };<br>};</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/22/FastClick-源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/22/FastClick-源码解析/" itemprop="url">FastClick-源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-22T19:45:27+08:00">
                2016-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(function() &#123;</span><br><span class="line">	&apos;use strict&apos;;</span><br><span class="line">	//构造函数</span><br><span class="line">	function FastClick(layer, options) &#123;</span><br><span class="line">		var oldOnClick;</span><br><span class="line">		options = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">		//是否开始追踪click事件</span><br><span class="line">		this.trackingClick = false;</span><br><span class="line"></span><br><span class="line">		//存储第一次按下时间戳</span><br><span class="line">		this.trackingClickStart = 0;</span><br><span class="line"></span><br><span class="line">		//目标元素</span><br><span class="line">		this.targetElement = null;</span><br><span class="line"></span><br><span class="line">		//存放坐标值X</span><br><span class="line">		this.touchStartX = 0;</span><br><span class="line"></span><br><span class="line">		//存放坐标值Y</span><br><span class="line">		this.touchStartY = 0;</span><br><span class="line"></span><br><span class="line">		//主要hack iOS4下的一个怪异问题</span><br><span class="line">		this.lastTouchIdentifier = 0;</span><br><span class="line"></span><br><span class="line">		//用于区分是click还是Touchmove，若出点移动超过该值则视为touchmove</span><br><span class="line">		this.touchBoundary = options.touchBoundary || 10;</span><br><span class="line"></span><br><span class="line">		// 绑定了FastClick的元素，一般是是body</span><br><span class="line">		this.layer = layer;</span><br><span class="line"></span><br><span class="line">		//双击最小点击时间差</span><br><span class="line">		this.tapDelay = options.tapDelay || 200;</span><br><span class="line"></span><br><span class="line">		//长按最大时间</span><br><span class="line">		this.tapTimeout = options.tapTimeout || 700;</span><br><span class="line"></span><br><span class="line">		//如果是属于不需要处理的元素类型，则直接返回</span><br><span class="line">		if(FastClick.notNeeded(layer)) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//语法糖，兼容一些用不了 Function.prototype.bind 的旧安卓</span><br><span class="line">		//所以后面不走 layer.addEventListener(&apos;click&apos;, this.onClick.bind(this), true);</span><br><span class="line">		function bind(method, context) &#123;</span><br><span class="line">			return function() &#123;</span><br><span class="line">				return method.apply(context, arguments);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		var methods = [&apos;onMouse&apos;, &apos;onClick&apos;, &apos;onTouchStart&apos;, &apos;onTouchMove&apos;, &apos;onTouchEnd&apos;, &apos;onTouchCancel&apos;];</span><br><span class="line">		var context = this;</span><br><span class="line">		for(var i = 0, l = methods.length; i &lt; l; i++) &#123;</span><br><span class="line">			context[methods[i]] = bind(context[methods[i]], context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//安卓则做额外处理</span><br><span class="line">		if(deviceIsAndroid) &#123;</span><br><span class="line">			layer.addEventListener(&apos;mouseover&apos;, this.onMouse, true);</span><br><span class="line">			layer.addEventListener(&apos;mousedown&apos;, this.onMouse, true);</span><br><span class="line">			layer.addEventListener(&apos;mouseup&apos;, this.onMouse, true);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		layer.addEventListener(&apos;click&apos;, this.onClick, true);</span><br><span class="line">		layer.addEventListener(&apos;touchstart&apos;, this.onTouchStart, false);</span><br><span class="line">		layer.addEventListener(&apos;touchmove&apos;, this.onTouchMove, false);</span><br><span class="line">		layer.addEventListener(&apos;touchend&apos;, this.onTouchEnd, false);</span><br><span class="line">		layer.addEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false);</span><br><span class="line"></span><br><span class="line">		// 兼容不支持 stopImmediatePropagation 的浏览器(比如 Android 2)</span><br><span class="line">		if(!Event.prototype.stopImmediatePropagation) &#123;</span><br><span class="line">			layer.removeEventListener = function(type, callback, capture) &#123;</span><br><span class="line">				var rmv = Node.prototype.removeEventListener;</span><br><span class="line">				if(type === &apos;click&apos;) &#123;</span><br><span class="line">					rmv.call(layer, type, callback.hijacked || callback, capture);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					rmv.call(layer, type, callback, capture);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			layer.addEventListener = function(type, callback, capture) &#123;</span><br><span class="line">				var adv = Node.prototype.addEventListener;</span><br><span class="line">				if(type === &apos;click&apos;) &#123;</span><br><span class="line">					//留意这里 callback.hijacked 中会判断 event.propagationStopped 是否为真来确保（安卓的onMouse事件）只执行一次</span><br><span class="line">					//在 onMouse 事件里会给 event.propagationStopped 赋值 true</span><br><span class="line">					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) &#123;</span><br><span class="line">						if(!event.propagationStopped) &#123;</span><br><span class="line">							callback(event);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;), capture);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					adv.call(layer, type, callback, capture);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 如果layer直接在DOM上写了 onclick 方法，那我们需要把它替换为 addEventListener 绑定形式</span><br><span class="line">		if(typeof layer.onclick === &apos;function&apos;) &#123;</span><br><span class="line">			oldOnClick = layer.onclick;</span><br><span class="line">			layer.addEventListener(&apos;click&apos;, function(event) &#123;</span><br><span class="line">				oldOnClick(event);</span><br><span class="line">			&#125;, false);</span><br><span class="line">			layer.onclick = null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Android requires exceptions.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsAndroid = navigator.userAgent.indexOf(&apos;Android&apos;) &gt; 0 &amp;&amp; !deviceIsWindowsPhone;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * iOS requires exceptions.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * iOS 4 requires an exception for select elements.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsIOS4 = deviceIsIOS &amp;&amp; (/OS 4_\d(_\d)?/).test(navigator.userAgent);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * iOS 6.0-7.* requires the target element to be manually derived</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsIOSWithBadTarget = deviceIsIOS &amp;&amp; (/OS [6-7]_\d/).test(navigator.userAgent);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * BlackBerry requires exceptions.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsBlackBerry10 = navigator.userAgent.indexOf(&apos;BB10&apos;) &gt; 0;</span><br><span class="line"></span><br><span class="line">	//判断元素是否要保留穿透功能</span><br><span class="line">	FastClick.prototype.needsClick = function(target) &#123;</span><br><span class="line">		switch(target.nodeName.toLowerCase()) &#123;</span><br><span class="line"></span><br><span class="line">			// disabled的input</span><br><span class="line">			case &apos;button&apos;:</span><br><span class="line">			case &apos;select&apos;:</span><br><span class="line">			case &apos;textarea&apos;:</span><br><span class="line">				if(target.disabled) &#123;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				break;</span><br><span class="line">			case &apos;input&apos;:</span><br><span class="line"></span><br><span class="line">				// file组件必须通过原生click事件点击才有效</span><br><span class="line">				if((deviceIsIOS &amp;&amp; target.type === &apos;file&apos;) || target.disabled) &#123;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				break;</span><br><span class="line">			case &apos;label&apos;:</span><br><span class="line">			case &apos;iframe&apos;:</span><br><span class="line">			case &apos;video&apos;:</span><br><span class="line">				return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//元素带了名为“bneedsclick”的class也返回true</span><br><span class="line">		return(/\bneedsclick\b/).test(target.className);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//判断给定元素是否需要通过合成click事件来模拟聚焦</span><br><span class="line">	FastClick.prototype.needsFocus = function(target) &#123;</span><br><span class="line">		switch(target.nodeName.toLowerCase()) &#123;</span><br><span class="line">			case &apos;textarea&apos;:</span><br><span class="line">				return true;</span><br><span class="line">			case &apos;select&apos;:</span><br><span class="line">				return !deviceIsAndroid; //iOS下的select得走穿透点击才行</span><br><span class="line">			case &apos;input&apos;:</span><br><span class="line">				switch(target.type) &#123;</span><br><span class="line">					case &apos;button&apos;:</span><br><span class="line">					case &apos;checkbox&apos;:</span><br><span class="line">					case &apos;file&apos;:</span><br><span class="line">					case &apos;image&apos;:</span><br><span class="line">					case &apos;radio&apos;:</span><br><span class="line">					case &apos;submit&apos;:</span><br><span class="line">						return false;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				return !target.disabled &amp;&amp; !target.readOnly;</span><br><span class="line">			default:</span><br><span class="line">				//带有名为“bneedsfocus”的class则返回true</span><br><span class="line">				return(/\bneedsfocus\b/).test(target.className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//合成一个click事件并在指定元素上触发</span><br><span class="line">	FastClick.prototype.sendClick = function(targetElement, event) &#123;</span><br><span class="line">		var clickEvent, touch;</span><br><span class="line"></span><br><span class="line">		// 在一些安卓机器中，得让页面所存在的 activeElement（聚焦的元素，比如input）失焦，否则合成的click事件将无效</span><br><span class="line">		if(document.activeElement &amp;&amp; document.activeElement !== targetElement) &#123;</span><br><span class="line">			document.activeElement.blur();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		touch = event.changedTouches[0];</span><br><span class="line"></span><br><span class="line">		// 合成(Synthesise) 一个 click 事件</span><br><span class="line">		// 通过一个额外属性确保它能被追踪（tracked）</span><br><span class="line">		clickEvent = document.createEvent(&apos;MouseEvents&apos;);</span><br><span class="line">		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);</span><br><span class="line">		clickEvent.forwardedTouchEvent = true; // fastclick的内部变量，用来识别click事件是原生还是合成的</span><br><span class="line">		targetElement.dispatchEvent(clickEvent); //立即触发其click事件</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.determineEventType = function(targetElement) &#123;</span><br><span class="line"></span><br><span class="line">		//安卓设备下 Select 无法通过合成的 click 事件被展开，得改为 mousedown</span><br><span class="line">		if(deviceIsAndroid &amp;&amp; targetElement.tagName.toLowerCase() === &apos;select&apos;) &#123;</span><br><span class="line">			return &apos;mousedown&apos;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return &apos;click&apos;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//设置元素聚焦事件</span><br><span class="line">	FastClick.prototype.focus = function(targetElement) &#123;</span><br><span class="line">		var length;</span><br><span class="line"></span><br><span class="line">		// 组件建议通过setSelectionRange(selectionStart, selectionEnd)来设定光标范围（注意这样还没有聚焦</span><br><span class="line">		// 要等到后面触发 sendClick 事件才会聚焦）</span><br><span class="line">		// 另外 iOS7 下有些input元素(比如 date datetime month) 的 selectionStart 和 selectionEnd 特性是没有整型值的，</span><br><span class="line">		// 导致会抛出一个关于 setSelectionRange 的模糊错误，它们需要改用 focus 事件触发</span><br><span class="line">		if(deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&apos;date&apos;) !== 0 &amp;&amp; targetElement.type !== &apos;time&apos; &amp;&amp; targetElement.type !== &apos;month&apos;) &#123;</span><br><span class="line">			length = targetElement.value.length;</span><br><span class="line">			targetElement.setSelectionRange(length, length);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			//直接触发其focus事件</span><br><span class="line">			targetElement.focus();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 检查target是否一个滚动容器里的子元素，如果是则给它加个标记</span><br><span class="line">	 */</span><br><span class="line">	FastClick.prototype.updateScrollParent = function(targetElement) &#123;</span><br><span class="line">		var scrollParent, parentElement;</span><br><span class="line"></span><br><span class="line">		scrollParent = targetElement.fastClickScrollParent;</span><br><span class="line"></span><br><span class="line">		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the</span><br><span class="line">		// target element was moved to another parent.</span><br><span class="line">		if(!scrollParent || !scrollParent.contains(targetElement)) &#123;</span><br><span class="line">			parentElement = targetElement;</span><br><span class="line">			do &#123;</span><br><span class="line">				if(parentElement.scrollHeight &gt; parentElement.offsetHeight) &#123;</span><br><span class="line">					scrollParent = parentElement;</span><br><span class="line">					targetElement.fastClickScrollParent = parentElement;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				parentElement = parentElement.parentElement;</span><br><span class="line">			&#125; while (parentElement);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 给滚动容器加个标志fastClickLastScrollTop，值为其当前垂直滚动偏移</span><br><span class="line">		if(scrollParent) &#123;</span><br><span class="line">			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 返回目标元素</span><br><span class="line">	 */</span><br><span class="line">	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) &#123;</span><br><span class="line"></span><br><span class="line">		// 一些较老的浏览器，target 可能会是一个文本节点，得返回其DOM节点</span><br><span class="line">		if(eventTarget.nodeType === Node.TEXT_NODE) &#123;</span><br><span class="line">			return eventTarget.parentNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return eventTarget;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.onTouchStart = function(event) &#123;</span><br><span class="line">		var targetElement, touch, selection;</span><br><span class="line"></span><br><span class="line">		// 多指触控的手势则忽略</span><br><span class="line">		if(event.targetTouches.length &gt; 1) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		targetElement = this.getTargetElementFromEventTarget(event.target); //一些较老的浏览器，target 可能会是一个文本节点，得返回其DOM节点</span><br><span class="line">		touch = event.targetTouches[0];</span><br><span class="line"></span><br><span class="line">		if(deviceIsIOS) &#123; //IOS处理</span><br><span class="line"></span><br><span class="line">			// 若用户已经选中了一些内容（比如选中了一段文本打算复制），则忽略</span><br><span class="line">			selection = window.getSelection();</span><br><span class="line">			if(selection.rangeCount &amp;&amp; !selection.isCollapsed) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if(!deviceIsIOS4) &#123; //是否IOS4</span><br><span class="line"></span><br><span class="line">				//怪异特性处理——若click事件回调打开了一个alert/confirm，用户下一次tap页面的其它地方时，新的touchstart和touchend</span><br><span class="line">				//事件会拥有同一个touch.identifier（新的 touch event 会跟上一次触发alert点击的 touch event 一样），</span><br><span class="line">				//为避免将新的event当作之前的event导致问题，这里需要禁用默认事件</span><br><span class="line">				//另外chrome的开发工具启用&apos;Emulate touch events&apos;后，iOS UA下的 identifier 会变成0，所以要做容错避免调试过程也被禁用事件了</span><br><span class="line">				if(touch.identifier &amp;&amp; touch.identifier === this.lastTouchIdentifier) &#123;</span><br><span class="line">					event.preventDefault();</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				this.lastTouchIdentifier = touch.identifier;</span><br><span class="line"></span><br><span class="line">				// 如果target是一个滚动容器里的一个子元素(使用了 -webkit-overflow-scrolling: touch) ，而且满足:</span><br><span class="line">				// 1) 用户非常快速地滚动外层滚动容器</span><br><span class="line">				// 2) 用户通过tap停止住了这个快速滚动</span><br><span class="line">				// 这时候最后的&apos;touchend&apos;的event.target会变成用户最终手指下的那个元素</span><br><span class="line">				// 所以当快速滚动开始的时候，需要做检查target是否滚动容器的子元素，如果是，做个标记</span><br><span class="line">				// 在touchend时检查这个标记的值（滚动容器的scrolltop）是否改变了，如果是则说明页面在滚动中，需要取消fastclick处理</span><br><span class="line">				this.updateScrollParent(targetElement);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.trackingClick = true; //做个标志表示开始追踪click事件了</span><br><span class="line">		this.trackingClickStart = event.timeStamp; //标记下touch事件开始的时间戳</span><br><span class="line">		this.targetElement = targetElement;</span><br><span class="line"></span><br><span class="line">		//标记touch起始点的页面偏移值</span><br><span class="line">		this.touchStartX = touch.pageX;</span><br><span class="line">		this.touchStartY = touch.pageY;</span><br><span class="line"></span><br><span class="line">		// this.lastClickTime 是在 touchend 里标记的事件时间戳</span><br><span class="line">		// this.tapDelay 为常量 200 （ms）</span><br><span class="line">		// 此举用来避免 phantom 的双击（200ms内快速点了两次）触发 click</span><br><span class="line">		// 反正200ms内的第二次点击会禁止触发点击的默认事件</span><br><span class="line">		if((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123;</span><br><span class="line">			event.preventDefault();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return true;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//判断是否移动了</span><br><span class="line">	//this.touchBoundary是常量，值为10</span><br><span class="line">	//如果touch已经移动了10个偏移量单位，则应当作为移动事件处理而非click事件</span><br><span class="line">	FastClick.prototype.touchHasMoved = function(event) &#123;</span><br><span class="line">		var touch = event.changedTouches[0],</span><br><span class="line">			boundary = this.touchBoundary;</span><br><span class="line"></span><br><span class="line">		if(Math.abs(touch.pageX - this.touchStartX) &gt; boundary || Math.abs(touch.pageY - this.touchStartY) &gt; boundary) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.onTouchMove = function(event) &#123;</span><br><span class="line">		//不是需要被追踪click的事件则忽略</span><br><span class="line">		if(!this.trackingClick) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 如果target突然改变了，或者用户其实是在移动手势而非想要click</span><br><span class="line">		// 则应该清掉this.trackingClick和this.targetElement，告诉后面的事件你们也不用处理了</span><br><span class="line">		if(this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) &#123;</span><br><span class="line">			this.trackingClick = false;</span><br><span class="line">			this.targetElement = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return true;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//找到label标签所映射的组件，方便让用户点label的时候直接激活该组件</span><br><span class="line">	FastClick.prototype.findControl = function(labelElement) &#123;</span><br><span class="line"></span><br><span class="line">		// 有缓存则直接读缓存着的</span><br><span class="line">		if(labelElement.control !== undefined) &#123;</span><br><span class="line">			return labelElement.control;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 获取指向的组件</span><br><span class="line">		if(labelElement.htmlFor) &#123;</span><br><span class="line">			return document.getElementById(labelElement.htmlFor);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 没有for属性则激活页面第一个组件（labellable 元素）</span><br><span class="line">		return labelElement.querySelector(&apos;button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea&apos;);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.onTouchEnd = function(event) &#123;</span><br><span class="line">		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;</span><br><span class="line"></span><br><span class="line">		if(!this.trackingClick) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 避免 phantom 的双击（200ms内快速点了两次）触发 click</span><br><span class="line">		// 我们在 ontouchstart 里已经做过一次判断了（仅仅禁用默认事件），这里再做一次判断</span><br><span class="line">		if((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123;</span><br><span class="line">			this.cancelNextClick = true; //该属性会在 onMouse 事件中被判断，为true则彻底禁用事件和冒泡</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//this.tapTimeout是常量，值为700</span><br><span class="line">		//识别是否为长按事件，如果是（大于700ms）则忽略</span><br><span class="line">		if((event.timeStamp - this.trackingClickStart) &gt; this.tapTimeout) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 得重置为false，避免input事件被意外取消</span><br><span class="line">		// 例子见 https://github.com/ftlabs/fastclick/issues/156</span><br><span class="line">		this.cancelNextClick = false;</span><br><span class="line"></span><br><span class="line">		this.lastClickTime = event.timeStamp; //标记touchend时间，方便下一次的touchstart做双击校验</span><br><span class="line"></span><br><span class="line">		trackingClickStart = this.trackingClickStart;</span><br><span class="line">		//重置 this.trackingClick 和 this.trackingClickStart</span><br><span class="line">		this.trackingClick = false;</span><br><span class="line">		this.trackingClickStart = 0;</span><br><span class="line"></span><br><span class="line">		// iOS 6.0-7.*版本下有个问题 —— 如果layer处于transition或scroll过程，event所提供的target是不正确的</span><br><span class="line">		// 所以咱们得重找 targetElement（这里通过 document.elementFromPoint 接口来寻找）</span><br><span class="line">		if(deviceIsIOSWithBadTarget) &#123; //iOS 6.0-7.*版本</span><br><span class="line">			touch = event.changedTouches[0]; //手指离开前的触点</span><br><span class="line"></span><br><span class="line">			// 有些情况下 elementFromPoint 里的参数是预期外/不可用的, 所以还得避免 targetElement 为 null</span><br><span class="line">			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;</span><br><span class="line">			// target可能不正确需要重找，但fastClickScrollParent是不会变的</span><br><span class="line">			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		targetTagName = targetElement.tagName.toLowerCase();</span><br><span class="line">		if(targetTagName === &apos;label&apos;) &#123; //是label则激活其指向的组件</span><br><span class="line">			forElement = this.findControl(targetElement);</span><br><span class="line">			if(forElement) &#123;</span><br><span class="line">				this.focus(targetElement);</span><br><span class="line">				//安卓直接返回（无需合成click事件触发，因为点击和激活元素不同，不存在点透）</span><br><span class="line">				if(deviceIsAndroid) &#123;</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				targetElement = forElement;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if(this.needsFocus(targetElement)) &#123; //非label则识别是否需要focus的元素</span><br><span class="line"></span><br><span class="line">			//手势停留在组件元素时长超过100ms，则置空this.targetElement并返回</span><br><span class="line">			//（而不是通过调用this.focus来触发其聚焦事件，走的原生的click/focus事件触发流程）</span><br><span class="line">			//这也是为何文章开头提到的问题中，稍微久按一点（超过100ms）textarea是可以把光标定位在正确的地方的原因</span><br><span class="line">			//另外iOS下有个意料之外的bug——如果被点击的元素所在文档是在iframe中的，手动调用其focus的话，</span><br><span class="line">			//会发现你往其中输入的text是看不到的（即使value做了更新），so这里也直接返回</span><br><span class="line">			if((event.timeStamp - trackingClickStart) &gt; 100 || (deviceIsIOS &amp;&amp; window.top !== window &amp;&amp; targetTagName === &apos;input&apos;)) &#123;</span><br><span class="line">				this.targetElement = null;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			this.focus(targetElement);</span><br><span class="line">			this.sendClick(targetElement, event); //立即触发其click事件，而无须等待300ms</span><br><span class="line"></span><br><span class="line">			//iOS4下的 select 元素不能禁用默认事件（要确保它能被穿透），否则不会打开select目录</span><br><span class="line">			//有时候 iOS6/7 下（VoiceOver开启的情况下）也会如此</span><br><span class="line">			if(!deviceIsIOS || targetTagName !== &apos;select&apos;) &#123;</span><br><span class="line">				this.targetElement = null;</span><br><span class="line">				event.preventDefault();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(deviceIsIOS &amp;&amp; !deviceIsIOS4) &#123;</span><br><span class="line"></span><br><span class="line">			// 滚动容器的垂直滚动偏移改变了，说明是容器在做滚动而非点击，则忽略</span><br><span class="line">			scrollParent = targetElement.fastClickScrollParent;</span><br><span class="line">			if(scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 查看元素是否无需处理的白名单内（比如加了名为“needsclick”的class）</span><br><span class="line">		// 不是白名单的则照旧预防穿透处理，立即触发合成的click事件</span><br><span class="line">		if(!this.needsClick(targetElement)) &#123;</span><br><span class="line">			event.preventDefault();</span><br><span class="line">			this.sendClick(targetElement, event);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.onTouchCancel = function() &#123;</span><br><span class="line">		this.trackingClick = false;</span><br><span class="line">		this.targetElement = null;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//用于决定是否允许穿透事件（触发layer的click默认事件）</span><br><span class="line">	FastClick.prototype.onMouse = function(event) &#123;</span><br><span class="line"></span><br><span class="line">		// touch事件一直没触发</span><br><span class="line">		if(!this.targetElement) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(event.forwardedTouchEvent) &#123; //触发的click事件是合成的</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 编程派生的事件所对应元素事件可以被允许</span><br><span class="line">		// 确保其没执行过 preventDefault 方法（event.cancelable 不为 true）即可</span><br><span class="line">		if(!event.cancelable) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 需要做预防穿透处理的元素，或者做了快速（200ms）双击的情况</span><br><span class="line">		if(!this.needsClick(this.targetElement) || this.cancelNextClick) &#123;</span><br><span class="line">			//停止当前默认事件和冒泡</span><br><span class="line">			if(event.stopImmediatePropagation) &#123;</span><br><span class="line">				event.stopImmediatePropagation();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line"></span><br><span class="line">				// 不支持 stopImmediatePropagation 的设备(比如Android 2)做标记，</span><br><span class="line">				// 确保该事件回调不会执行（见126行）</span><br><span class="line">				event.propagationStopped = true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 取消事件和冒泡</span><br><span class="line">			event.stopPropagation();</span><br><span class="line">			event.preventDefault();</span><br><span class="line"></span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//允许穿透</span><br><span class="line">		return true;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//click事件常规都是touch事件衍生来的，也排在touch后面触发。</span><br><span class="line">	//对于那些我们在touch事件过程没有禁用掉默认事件的event来说，我们还需要在click的捕获阶段进一步</span><br><span class="line">	//做判断决定是否要禁掉点击事件（防穿透）</span><br><span class="line">	FastClick.prototype.onClick = function(event) &#123;</span><br><span class="line">		var permitted;</span><br><span class="line"></span><br><span class="line">		// 如果还有 trackingClick 存在，可能是某些UI事件阻塞了touchEnd 的执行</span><br><span class="line">		if(this.trackingClick) &#123;</span><br><span class="line">			this.targetElement = null;</span><br><span class="line">			this.trackingClick = false;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 依旧是对 iOS 怪异行为的处理 —— 如果用户点击了iOS模拟器里某个表单中的一个submit元素</span><br><span class="line">		// 或者点击了弹出来的键盘里的“Go”按钮，会触发一个“伪”click事件（target是一个submit-type的input元素）</span><br><span class="line">		if(event.target.type === &apos;submit&apos; &amp;&amp; event.detail === 0) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		permitted = this.onMouse(event);</span><br><span class="line"></span><br><span class="line">		if(!permitted) &#123; //如果点击是被允许的，将this.targetElement置空可以确保onMouse事件里不会阻止默认事件</span><br><span class="line">			this.targetElement = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//没有多大意义</span><br><span class="line">		return permitted;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//销毁Fastclick所注册的监听事件。是给外部实例去调用的</span><br><span class="line">	FastClick.prototype.destroy = function() &#123;</span><br><span class="line">		var layer = this.layer;</span><br><span class="line"></span><br><span class="line">		if(deviceIsAndroid) &#123;</span><br><span class="line">			layer.removeEventListener(&apos;mouseover&apos;, this.onMouse, true);</span><br><span class="line">			layer.removeEventListener(&apos;mousedown&apos;, this.onMouse, true);</span><br><span class="line">			layer.removeEventListener(&apos;mouseup&apos;, this.onMouse, true);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		layer.removeEventListener(&apos;click&apos;, this.onClick, true);</span><br><span class="line">		layer.removeEventListener(&apos;touchstart&apos;, this.onTouchStart, false);</span><br><span class="line">		layer.removeEventListener(&apos;touchmove&apos;, this.onTouchMove, false);</span><br><span class="line">		layer.removeEventListener(&apos;touchend&apos;, this.onTouchEnd, false);</span><br><span class="line">		layer.removeEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//是否没必要使用到 Fastclick 的检测</span><br><span class="line">	FastClick.notNeeded = function(layer) &#123;</span><br><span class="line">		var metaViewport;</span><br><span class="line">		var chromeVersion;</span><br><span class="line">		var blackberryVersion;</span><br><span class="line">		var firefoxVersion;</span><br><span class="line"></span><br><span class="line">		// 不支持触摸的设备</span><br><span class="line">		if(typeof window.ontouchstart === &apos;undefined&apos;) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 获取Chrome版本号，若非Chrome则返回0</span><br><span class="line">		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];</span><br><span class="line"></span><br><span class="line">		if(chromeVersion) &#123;</span><br><span class="line"></span><br><span class="line">			if(deviceIsAndroid) &#123; //安卓</span><br><span class="line">				metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line"></span><br><span class="line">				if(metaViewport) &#123;</span><br><span class="line">					// 安卓下，带有 user-scalable=&quot;no&quot; 的 meta 标签的 chrome 是会自动禁用 300ms 延迟的，所以无需 Fastclick</span><br><span class="line">					if(metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1) &#123;</span><br><span class="line">						return true;</span><br><span class="line">					&#125;</span><br><span class="line">					// 安卓Chrome 32 及以上版本，若带有 width=device-width 的 meta 标签也是无需 FastClick 的</span><br><span class="line">					if(chromeVersion &gt; 31 &amp;&amp; document.documentElement.scrollWidth &lt;= window.outerWidth) &#123;</span><br><span class="line">						return true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 其它的就肯定是桌面级的 Chrome 了，更不需要 FastClick 啦</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(deviceIsBlackBerry10) &#123; //黑莓，和上面安卓同理，就不写注释了</span><br><span class="line">			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);</span><br><span class="line"></span><br><span class="line">			if(blackberryVersion[1] &gt;= 10 &amp;&amp; blackberryVersion[2] &gt;= 3) &#123;</span><br><span class="line">				metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line"></span><br><span class="line">				if(metaViewport) &#123;</span><br><span class="line">					if(metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1) &#123;</span><br><span class="line">						return true;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					if(document.documentElement.scrollWidth &lt;= window.outerWidth) &#123;</span><br><span class="line">						return true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 带有 -ms-touch-action: none / manipulation 特性的 IE10 会禁用双击放大，也没有 300ms 时延</span><br><span class="line">		if(layer.style.msTouchAction === &apos;none&apos; || layer.style.touchAction === &apos;manipulation&apos;) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Firefox检测，同上</span><br><span class="line">		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];</span><br><span class="line"></span><br><span class="line">		if(firefoxVersion &gt;= 27) &#123;</span><br><span class="line"></span><br><span class="line">			metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line">			if(metaViewport &amp;&amp; (metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1 || document.documentElement.scrollWidth &lt;= window.outerWidth)) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// IE11 推荐使用没有“-ms-”前缀的 touch-action 样式特性名</span><br><span class="line">		if(layer.style.touchAction === &apos;none&apos; || layer.style.touchAction === &apos;manipulation&apos;) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.attach = function(layer, options) &#123;</span><br><span class="line">		return new FastClick(layer, options);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	if(typeof define === &apos;function&apos; &amp;&amp; typeof define.amd === &apos;object&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line"></span><br><span class="line">		// AMD. Register as an anonymous module.</span><br><span class="line">		define(function() &#123;</span><br><span class="line">			return FastClick;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; else if(typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class="line">		module.exports = FastClick.attach;</span><br><span class="line">		module.exports.FastClick = FastClick;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		window.FastClick = FastClick;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">		&lt;title&gt;Demo&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;./fastclick.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		&lt;style&gt;</span><br><span class="line">			div &#123;</span><br><span class="line">				width: 200px;</span><br><span class="line">				background: red;Y</span><br><span class="line">				margin: 0 auto;</span><br><span class="line">				height: 200px;</span><br><span class="line">				color: wheat;</span><br><span class="line">				font-size: 25px;</span><br><span class="line">				display: flex;</span><br><span class="line">				justify-content: center;</span><br><span class="line">				align-items: center;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;main&quot;&gt;FastClick&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			FastClick.attach(document.body);</span><br><span class="line">			document.getElementById(&quot;main&quot;).addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class="line">				console.log(event.target.innerText)</span><br><span class="line">			&#125;, false)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">75</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


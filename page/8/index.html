<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/8/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/21/面试之Vue-nextTick原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/21/面试之Vue-nextTick原理/" itemprop="url">面试之Vue.$nextTick原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-21T14:16:44+08:00">
                2017-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="面试官-Vue的nextTick是怎么监听DOM树更新完毕的？"><a href="#面试官-Vue的nextTick是怎么监听DOM树更新完毕的？" class="headerlink" title="面试官:Vue的nextTick是怎么监听DOM树更新完毕的？"></a>面试官:Vue的nextTick是怎么监听DOM树更新完毕的？</h2><p>nextTick是全局vue的一个函数，在vue系统中，用于处理dom更新的操作。vue里面有一个watcher，用于观察数据的变化，然后更新dom，vue里面并不是每次数据改变都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom更新操作。 </p>
<p>通常情况下，我们不需要关心这个问题，而如果想在DOM状态更新后做点什么，则需要用到nextTick。在vue生命周期的created()钩子函数进行的DOM操作要放在Vue.nextTick()的回调函数中，因为created()钩子函数执行的时候DOM并未进行任何渲染，而此时进行DOM操作是徒劳的，所以此处一定要将DOM操作的JS代码放进Vue.nextTick()的回调函数中。而与之对应的mounted钩子函数，该钩子函数执行时所有的DOM挂载和渲染都已完成，此时该钩子函数进行任何DOM操作都不会有个问题。 </p>
<p><code>Vue.nextTick(callback)</code>，当数据发生变化，更新后执行回调。</p>
<p><code>Vue.$nextTick(callback)</code>，当dom发生变化，更新后执行的回调。</p>
<hr>
<p>废话少说，来看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;span id=&apos;name&apos; ref=&apos;name&apos;&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;button @click=&apos;change&apos;&gt;change name&lt;/button&gt;</span><br><span class="line">  &lt;div id=&apos;content&apos;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &apos;SHERlocked93&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change() &#123;</span><br><span class="line">        const $name = this.$refs.name</span><br><span class="line">        this.$nextTick(() =&gt; console.log(&apos;setter前：&apos; + $name.innerHTML))</span><br><span class="line">        this.name = &apos; name改喽 &apos;</span><br><span class="line">        console.log(&apos;同步方式：&apos; + this.$refs.name.innerHTML)</span><br><span class="line">        setTimeout(() =&gt; this.console(&quot;setTimeout方式：&quot; + this.$refs.name.innerHTML))</span><br><span class="line">        this.$nextTick(() =&gt; console.log(&apos;setter后：&apos; + $name.innerHTML))</span><br><span class="line">        this.$nextTick().then(() =&gt; console.log(&apos;Promise方式：&apos; + $name.innerHTML))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>执行以下看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同步方式：SHERlocked93 </span><br><span class="line">setter前：SHERlocked93 </span><br><span class="line">setter后：name改喽 </span><br><span class="line">Promise方式：name改喽 </span><br><span class="line">setTimeout方式：name改喽</span><br></pre></td></tr></table></figure></p>
<hr>
<p>再看一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div ref=&quot;text&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;text&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            text: &apos;start&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods () &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            this.text = &apos;end&apos;;</span><br><span class="line">            console.log(this.$refs.text.innerText);//打印“start”</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的结果是start，为什么明明已经将text设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“start”呢？</p>
<h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>带着这个疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。</p>
<h3 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class="line">   */</span><br><span class="line">  update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">    /*同步则执行run直接渲染视图*/</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现Vue.js默认是使用异步执行DOM更新。<br>当异步执行update的时候，会调用queueWatcher函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Push a watcher into the watcher queue.</span><br><span class="line"> * Jobs with duplicate IDs will be skipped unless it&apos;s</span><br><span class="line"> * pushed when the queue is being flushed.</span><br><span class="line"> **/</span><br><span class="line"> /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/</span><br><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">    /*获取watcher的id*/</span><br><span class="line">  const id = watcher.id</span><br><span class="line">   /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">    /*如果没有flush掉，直接push到队列中即可*/</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // if already flushing, splice the watcher based on its id</span><br><span class="line">      // if already past its id, it will be run next immediately.</span><br><span class="line">      let i = queue.length - 1</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    // queue the flush</span><br><span class="line">    // 刷新队列</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true</span><br><span class="line"></span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</p>
<h3 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/observer/scheduler.js</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Flush both queues and run the watchers.</span><br><span class="line"> */</span><br><span class="line">  /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/</span><br><span class="line">function flushSchedulerQueue () &#123;</span><br><span class="line">  flushing = true</span><br><span class="line">  let watcher, id</span><br><span class="line"></span><br><span class="line">  // Sort queue before flush.</span><br><span class="line">  // This ensures that:</span><br><span class="line">  // 1. Components are updated from parent to child. (because parent is always</span><br><span class="line">  //    created before the child)</span><br><span class="line">  // 2. A component&apos;s user watchers are run before its render watcher (because</span><br><span class="line">  //    user watchers are created before the render watcher)</span><br><span class="line">  // 3. If a component is destroyed during a parent component&apos;s watcher run,</span><br><span class="line">  //    its watchers can be skipped.</span><br><span class="line">  /*</span><br><span class="line">    刷新前给queue排序，这样做可以保证：</span><br><span class="line">    1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。</span><br><span class="line">    2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建</span><br><span class="line">    3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。</span><br><span class="line">  */</span><br><span class="line">  queue.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line"></span><br><span class="line">  // do not cache length because more watchers might be pushed</span><br><span class="line">  // as we run existing watchers</span><br><span class="line">  /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，</span><br><span class="line">  因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/</span><br><span class="line">  for (index = 0; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    if (watcher.before) &#123;</span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id</span><br><span class="line">     /*将has的标记删除*/</span><br><span class="line">    has[id] = null</span><br><span class="line">     /*执行watcher*/</span><br><span class="line">    watcher.run()</span><br><span class="line">    // in dev build, check and stop circular updates.</span><br><span class="line">    /*</span><br><span class="line">      在测试环境中，检测watch是否在死循环中</span><br><span class="line">      比如这样一种情况</span><br><span class="line">      watch: &#123;</span><br><span class="line">        test () &#123;</span><br><span class="line">          this.test++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      持续执行了一百次watch代表可能存在死循环</span><br><span class="line">    */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) &#123;</span><br><span class="line">      circular[id] = (circular[id] || 0) + 1</span><br><span class="line">      if (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;You may have an infinite update loop &apos; + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? `in watcher with expression &quot;$&#123;watcher.expression&#125;&quot;`</span><br><span class="line">              : `in a component render function.`</span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // keep copies of post queues before resetting state</span><br><span class="line">  /*得到队列的拷贝*/</span><br><span class="line">  const activatedQueue = activatedChildren.slice()</span><br><span class="line">  const updatedQueue = queue.slice()</span><br><span class="line">  /*重置调度者的状态*/</span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  // call component updated and activated hooks</span><br><span class="line">  /*使子组件状态都改编成active同时调用activated钩子*/</span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  /*调用updated钩子*/</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">  // devtool hook</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(&apos;flush&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图</p>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>vue.js提供了一个nextTick函数，其实也就是上面调用的nextTick。</p>
<p>nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion。</p>
<p>网上很多文章讨论的nextTick实现是2.4版本以下的实现，2.5以上版本对于nextTick的内部实现进行了大量的修改，看一下源码：</p>
<p>首先是从Vue 2.5+开始，抽出来了一个单独的文件next-tick.js来执行它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/util/next-tick.js</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line">    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function</span><br><span class="line">    这个函数的作用是在task或者microtask中推入一个timerFunc，</span><br><span class="line">    在当前调用栈执行完以后以此执行直到执行到timerFunc</span><br><span class="line">    目的是延迟到当前调用栈执行完以后执行</span><br><span class="line">*/</span><br><span class="line">/*存放异步执行的回调*/</span><br><span class="line">const callbacks = []</span><br><span class="line">/*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/</span><br><span class="line">let pending = false</span><br><span class="line"></span><br><span class="line">/*下一个tick时的回调*/</span><br><span class="line">function flushCallbacks () &#123;</span><br><span class="line">/*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/</span><br><span class="line">  pending = false</span><br><span class="line">  //复制callback</span><br><span class="line">  const copies = callbacks.slice(0)</span><br><span class="line">  //清除callbacks</span><br><span class="line">  callbacks.length = 0</span><br><span class="line">  for (let i = 0; i &lt; copies.length; i++) &#123;</span><br><span class="line">  //触发callback的回调函数</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span><br><span class="line">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span><br><span class="line">// microtasks have too high a priority and fire in between supposedly</span><br><span class="line">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span><br><span class="line">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span><br><span class="line">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span><br><span class="line">// Here we use microtask by default, but expose a way to force (macro) task when</span><br><span class="line">// needed (e.g. in event handlers attached by v-on).</span><br><span class="line">/**</span><br><span class="line">其大概的意思就是：在Vue2.4之前的版本中，nextTick几乎都是基于microTask实现的，</span><br><span class="line">但是由于microTask的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，</span><br><span class="line">就会导致一些诡异的问题；但是如果全部都改成macroTask，对一些有重绘和动画的场</span><br><span class="line">景也会有性能的影响。所以最终nextTick采取的策略是默认走microTask，对于一些DOM</span><br><span class="line">的交互事件，如v-on绑定的事件回调处理函数的处理，会强制走macroTask。</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">let microTimerFunc</span><br><span class="line">let macroTimerFunc</span><br><span class="line">let useMacroTask = false</span><br><span class="line"></span><br><span class="line">// Determine (macro) task defer implementation.</span><br><span class="line">// Technically setImmediate should be the ideal choice, but it&apos;s only available</span><br><span class="line">// in IE. The only polyfill that consistently queues the callback after all DOM</span><br><span class="line">// events triggered in the same loop is by using MessageChannel.</span><br><span class="line">/* istanbul ignore if */</span><br><span class="line">/**</span><br><span class="line">而对于macroTask的执行，Vue优先检测是否支持原生setImmediate（高版本IE和Edge支持），</span><br><span class="line">不支持的话再去检测是否支持原生MessageChannel，如果还不支持的话为setTimeout(fn, 0)。</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (typeof MessageChannel !== &apos;undefined&apos; &amp;&amp; ( </span><br><span class="line">// MessageChannel与原先的MutationObserver异曲同工</span><br><span class="line">/**</span><br><span class="line">在Vue 2.4版本以前使用的MutationObserver来模拟异步任务。</span><br><span class="line">而Vue 2.5版本以后，由于兼容性弃用了MutationObserver。</span><br><span class="line">Vue 2.5+版本使用了MessageChannel来模拟macroTask。</span><br><span class="line">除了IE以外，messageChannel的兼容性还是比较可观的。</span><br><span class="line">**/</span><br><span class="line">  isNative(MessageChannel) ||</span><br><span class="line">  // PhantomJS</span><br><span class="line">  MessageChannel.toString() === &apos;[object MessageChannelConstructor]&apos;</span><br><span class="line">)) &#123;</span><br><span class="line">  /**</span><br><span class="line">  可见，新建一个MessageChannel对象，该对象通过port1来检测信息，port2发送信息。</span><br><span class="line">  通过port2的主动postMessage来触发port1的onmessage事件，</span><br><span class="line">  进而把回调函数flushCallbacks作为macroTask参与事件循环。</span><br><span class="line">  **/</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  /* istanbul ignore next */</span><br><span class="line">   //上面两种都不支持，用setTimeout</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Determine microtask defer implementation.</span><br><span class="line">/* istanbul ignore next, $flow-disable-line */</span><br><span class="line"></span><br><span class="line">if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123;</span><br><span class="line">/*使用Promise*/</span><br><span class="line">  const p = Promise.resolve()</span><br><span class="line">  microTimerFunc = () =&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but</span><br><span class="line">    // it can get stuck in a weird state where callbacks are pushed into the</span><br><span class="line">    // microtask queue but the queue isn&apos;t being flushed, until the browser</span><br><span class="line">    // needs to do some other work, e.g. handle a timer. Therefore we can</span><br><span class="line">    // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span><br><span class="line">    //iOS的webview下，需要强制刷新队列，执行上面的回调函数</span><br><span class="line">    if (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // fallback to macro</span><br><span class="line">  microTimerFunc = macroTimerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wrap a function so that if any code inside triggers state change,</span><br><span class="line"> * the changes are queued using a (macro) task instead of a microtask.</span><br><span class="line"> */</span><br><span class="line"> /**</span><br><span class="line"> 在Vue执行绑定的DOM事件时，默认会给回调的handler函数调用withMacroTask方法做一层包装，</span><br><span class="line"> 它保证整个回调函数的执行过程中，遇到数据状态的改变，这些改变而导致的视图更新（DOM更新）</span><br><span class="line"> 的任务都会被推到macroTask而不是microtask。</span><br><span class="line"> **/</span><br><span class="line">export function withMacroTask (fn: Function): Function &#123;</span><br><span class="line">  return fn._withTask || (fn._withTask = function () &#123;</span><br><span class="line">    useMacroTask = true</span><br><span class="line">    const res = fn.apply(null, arguments)</span><br><span class="line">    useMacroTask = false</span><br><span class="line">    return res</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> /*</span><br><span class="line">    推送到队列中下一个tick时执行</span><br><span class="line">    cb 回调函数</span><br><span class="line">    ctx 上下文</span><br><span class="line">  */</span><br><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">   /*cb存到callbacks中*/</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &apos;nextTick&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    if (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="MessageChannel-VS-setTimeout"><a href="#MessageChannel-VS-setTimeout" class="headerlink" title="MessageChannel VS setTimeout"></a>MessageChannel VS setTimeout</h3><p>为什么要优先MessageChannel创建macroTask而不是setTimeout？</p>
<p><strong> <font color="#dd0000">HTML5中规定setTimeout的最小时间延迟是4ms，也就是说理想环境下异步回调最快也是4ms才能触发。</font> </strong></p>
<p>Vue使用这么多函数来模拟异步任务，其目的只有一个，就是让回调异步且尽早调用。而MessageChannel的延迟明显是小于setTimeout的。</p>
<p>说了这么多，到底什么是macrotasks，什么是microtasks呢？</p>
<h5 id="两者的具体实现"><a href="#两者的具体实现" class="headerlink" title="两者的具体实现"></a>两者的具体实现</h5><p><strong>macrotasks：</strong></p>
<blockquote>
<font color="#dd0000">setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染</font>
</blockquote>
<p><strong>microtasks:</strong></p>
<blockquote>
<font color="#dd0000">Promise， process.nextTick， Object.observe， MutationObserver</font>
</blockquote>
<p><strong>1.在 macrotask 队列中执行最早的那个 task ，然后移出</strong></p>
<p><strong>2.再执行 microtask 队列中所有可用的任务，然后移出</strong></p>
<p><strong>3.下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</strong></p>
<p>那我们上面提到的任务队列到底是什么呢？跟macrotasks和microtasks有什么联系呢？</p>
<p>• 一个事件循环有一个或者多个任务队列；</p>
<p>• 每个事件循环都有一个microtask队列；</p>
<p>• macrotask队列就是我们常说的任务队列，microtask队列不是任务队列；</p>
<p>• 一个任务可以被放入到macrotask队列，也可以放入microtask队列；</p>
<p>• 当一个任务被放入microtask或者macrotask队列后，准备工作就已经结束，这时候可以开始执行任务了。</p>
<p>可见，setTimeout和Promises不是同一类的任务，处理方式应该会有区别，具体的处理方式有什么不同呢？ </p>
<p>通俗的解释一下，microtasks的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务。 例如响应事件、或者异步操作，以避免付出额外的一个task的费用。</p>
<p>microtask会在两种情况下执行：</p>
<p>任务队列(macrotask = task queue)回调后执行，前提条件是当前没有其他执行中的代码。<br>每个task末尾执行。<br>另外在处理microtask期间，如果有新添加的microtasks，也会被添加到队列的末尾并执行。</p>
<p>也就是说执行顺序是：</p>
<p>开始 -&gt; 取task queue第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取task queue下一个任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复</p>
<p>Promise一旦状态置为完成态，便为其回调(.then内的函数)安排一个microtask。</p>
<p>接下来我们看回我们上面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;,0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    for( var i=100000 ; i&gt;0 ; i-- )&#123;</span><br><span class="line">        i==1 &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(5);</span><br></pre></td></tr></table></figure>
<p>按照上面的规则重新分析一遍：</p>
<p>当运行到setTimeout时，会把setTimeout的回调函数console.log(1)放到任务队列里去，然后继续向下执行。</p>
<p>接下来会遇到一个Promise。首先执行打印console.log(2)，然后执行for循环，即时for循环要累加到10万，也是在执行栈里面，等待for循环执行完毕以后，将Promise的状态从fulfilled切换到resolve，随后把要执行的回调函数，也就是then里面的console.log(4)推到microtask里面去。接下来马上执行马上console.log(3)。</p>
<p>然后出Promise，还剩一个同步的console.log(5)，直接打印。这样第一轮下来，已经依次打印了2，3，5。</p>
<p>现在第一轮任务队列已经执行完毕，没有正在执行的代码。符合上面讲的microtask执行条件，因此会将microtask中的任务优先执行，因此执行console.log(4)</p>
<p>最后还剩macrotask里的setTimeout放入的函数console.log(1)最后执行。</p>
<p>如此分析输出顺序是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>我们再来看一个：</p>
<p>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：</p>
<p><strong> 1.先执行 macrotasks：I/O -》 UI渲染 </strong></p>
<p><strong> 2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe </strong></p>
<p><strong> 3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次： setTimeout ，setInterval –》setImmediate </strong></p>
<p>综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;,0);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;,0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(6);</span><br><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(7);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(8);</span><br><span class="line">结果是：3 4 6 8 7 5 2 1</span><br></pre></td></tr></table></figure>
<h3 id="使用了nextTick异步更新视图有什么好处呢？"><a href="#使用了nextTick异步更新视图有什么好处呢？" class="headerlink" title="使用了nextTick异步更新视图有什么好处呢？"></a>使用了nextTick异步更新视图有什么好处呢？</h3><p>接下来我们看一下一个Demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            test: 0</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">      for(let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        this.test++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在有这样的一种情况，created的时候test的值会被++循环执行1000次。<br>每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。<br>如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。<br>所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。<br>保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/11/19-个-JavaScript-有用的简写技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/11/19-个-JavaScript-有用的简写技术/" itemprop="url">19 个 JavaScript 有用的简写技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T23:11:44+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-三元操作符"><a href="#1-三元操作符" class="headerlink" title="1.三元操作符"></a>1.三元操作符</h2><p>当想写if…else语句时，使用三元操作符来代替。</p>
<pre><code>const x = 20;
let answer;
if (x &gt; 10) {
    answer = &apos;is greater&apos;;
} else {
    answer = &apos;is lesser&apos;;
}
</code></pre><p>简写：<br><code>const answer = x &gt; 10 ? &#39;is greater&#39; : &#39;is lesser&#39;;</code></p>
<p>也可以嵌套if语句：<br><code>const big = x &gt; 10 ? &quot; greater 10&quot; : x</code></p>
<h2 id="2-短路求值简写方式"><a href="#2-短路求值简写方式" class="headerlink" title="2.短路求值简写方式"></a>2.短路求值简写方式</h2><p>当给一个变量分配另一个值时，想确定源始值不是null，undefined或空值。可以写撰写一个多重条件的if语句。</p>
<pre><code>if (variable1 !== null || variable1 !== undefined || variable1 !== &apos;&apos;) {
     let variable2 = variable1;
}
</code></pre><p>或者可以使用短路求值方法：<br><code>const variable2 = variable1 || &#39;new&#39;;</code></p>
<h2 id="3-声明变量简写方法"><a href="#3-声明变量简写方法" class="headerlink" title="3.声明变量简写方法"></a>3.声明变量简写方法</h2><pre><code>let x;
let y;
let z = 3;
</code></pre><p>简写方法：<br><code>let x, y, z=3;</code></p>
<h2 id="4-if存在条件简写方法"><a href="#4-if存在条件简写方法" class="headerlink" title="4.if存在条件简写方法"></a>4.if存在条件简写方法</h2><p><code>if (likeJavaScript === true)</code></p>
<p>简写：<br><code>if (likeJavaScript)</code></p>
<p>只有likeJavaScript是真值时，二者语句才相等</p>
<p>如果判断值不是真值，则可以这样：</p>
<pre><code>let a;
if ( a !== true ) {
// do something...
}
</code></pre><p>简写：</p>
<pre><code>let a;
if ( !a ) {
// do something...
}
</code></pre><h2 id="5-JavaScript循环简写方法"><a href="#5-JavaScript循环简写方法" class="headerlink" title="5.JavaScript循环简写方法"></a>5.JavaScript循环简写方法</h2><p><code>for (let i = 0; i &lt; allImgs.length; i++)</code></p>
<p>简写：<br><code>for (let index in allImgs)</code><br>也可以使用Array.forEach：</p>
<pre><code>function logArrayElements(element, index, array) {
  console.log(&quot;a[&quot; + index + &quot;] = &quot; + element);
}
[2, 5, 9].forEach(logArrayElements);
// logs:
// a[0] = 2
// a[1] = 5
// a[2] = 9
</code></pre><h2 id="6-短路评价"><a href="#6-短路评价" class="headerlink" title="6.短路评价"></a>6.短路评价</h2><p>给一个变量分配的值是通过判断其值是否为null或undefined，则可以：</p>
<pre><code>let dbHost;
if (process.env.DB_HOST) {
  dbHost = process.env.DB_HOST;
} else {
  dbHost = &apos;localhost&apos;;
}
</code></pre><p>简写：<br><code>const dbHost = process.env.DB_HOST || &#39;localhost&#39;;</code></p>
<h2 id="7-十进制指数"><a href="#7-十进制指数" class="headerlink" title="7.十进制指数"></a>7.十进制指数</h2><p>当需要写数字带有很多零时（如10000000），可以采用指数（1e7）来代替这个数字：<br><code>for (let i = 0; i &lt; 10000; i++) {}</code><br>简写：</p>
<pre><code>for (let i = 0; i &lt; 1e7; i++) {}

// 下面都是返回true
1e0 === 1;
1e1 === 10;
1e2 === 100;
1e3 === 1000;
1e4 === 10000;
1e5 === 100000;
</code></pre><h2 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8.对象属性简写"></a>8.对象属性简写</h2><p>如果属性名与key名相同，则可以采用ES6的方法：<br><code>const obj = { x:x, y:y };</code></p>
<p>简写：<br><code>const obj = { x, y };</code></p>
<h2 id="9-箭头函数简写"><a href="#9-箭头函数简写" class="headerlink" title="9.箭头函数简写"></a>9.箭头函数简写</h2><p>传统函数编写方法很容易让人理解和编写，但是当嵌套在另一个函数中，则这些优势就荡然无存。</p>
<pre><code>function sayHello(name) {
  console.log(&apos;Hello&apos;, name);
}

setTimeout(function() {
  console.log(&apos;Loaded&apos;)
}, 2000);

list.forEach(function(item) {
  console.log(item);
});
</code></pre><p>简写：</p>
<pre><code>sayHello = name =&gt; console.log(&apos;Hello&apos;, name);

setTimeout(() =&gt; console.log(&apos;Loaded&apos;), 2000);

list.forEach(item =&gt; console.log(item));
</code></pre><h2 id="10-隐式返回值简写"><a href="#10-隐式返回值简写" class="headerlink" title="10.隐式返回值简写"></a>10.隐式返回值简写</h2><p>经常使用return语句来返回函数最终结果，一个单独语句的箭头函数能隐式返回其值（函数必须省略{}为了省略return关键字）</p>
<p>为返回多行语句（例如对象字面表达式），则需要使用()包围函数体。</p>
<pre><code>function calcCircumference(diameter) {
  return Math.PI * diameter
}

var func = function func() {
  return { foo: 1 };
};
</code></pre><p>简写：</p>
<pre><code>calcCircumference = diameter =&gt; (
  Math.PI * diameter;
)

var func = () =&gt; ({ foo: 1 });
</code></pre><h2 id="11-默认参数值"><a href="#11-默认参数值" class="headerlink" title="11.默认参数值"></a>11.默认参数值</h2><p>为了给函数中参数传递默认值，通常使用if语句来编写，但是使用ES6定义默认值，则会很简洁：</p>
<pre><code>function volume(l, w, h) {
  if (w === undefined)
    w = 3;
  if (h === undefined)
    h = 4;
  return l * w * h;
}
</code></pre><p>简写：</p>
<pre><code>volume = (l, w = 3, h = 4 ) =&gt; (l * w * h);

volume(2) //output: 24
</code></pre><h2 id="12-模板字符串"><a href="#12-模板字符串" class="headerlink" title="12.模板字符串"></a>12.模板字符串</h2><p>传统的JavaScript语言，输出模板通常是这样写的。</p>
<pre><code>const welcome = &apos;You have logged in as &apos; + first + &apos; &apos; + last + &apos;.&apos;

const db = &apos;http://&apos; + host + &apos;:&apos; + port + &apos;/&apos; + database;
</code></pre><p>ES6可以使用反引号和${}简写：</p>
<pre><code>const welcome = `You have logged in as ${first} ${last}`;

const db = `http://${host}:${port}/${database}`;
</code></pre><h2 id="13-解构赋值简写方法"><a href="#13-解构赋值简写方法" class="headerlink" title="13.解构赋值简写方法"></a>13.解构赋值简写方法</h2><p>在web框架中，经常需要从组件和API之间来回传递数组或对象字面形式的数据，然后需要解构它</p>
<pre><code>const observable = require(&apos;mobx/observable&apos;);
const action = require(&apos;mobx/action&apos;);
const runInAction = require(&apos;mobx/runInAction&apos;);

const store = this.props.store;
const form = this.props.form;
const loading = this.props.loading;
const errors = this.props.errors;
const entity = this.props.entity;
</code></pre><p>简写：</p>
<pre><code>import { observable, action, runInAction } from &apos;mobx&apos;;

const { store, form, loading, errors, entity } = this.props;
</code></pre><p>也可以分配变量名：</p>
<pre><code>const { store, form, loading, errors, entity:contact } = this.props;
//最后一个变量名为contact
</code></pre><h2 id="14-多行字符串简写"><a href="#14-多行字符串简写" class="headerlink" title="14.多行字符串简写"></a>14.多行字符串简写</h2><p>需要输出多行字符串，需要使用+来拼接：</p>
<pre><code>const lorem = &apos;Lorem ipsum dolor sit amet, consectetur\n\t&apos;
    + &apos;adipisicing elit, sed do eiusmod tempor incididunt\n\t&apos;
    + &apos;ut labore et dolore magna aliqua. Ut enim ad minim\n\t&apos;
    + &apos;veniam, quis nostrud exercitation ullamco laboris\n\t&apos;
    + &apos;nisi ut aliquip ex ea commodo consequat. Duis aute\n\t&apos;
    + &apos;irure dolor in reprehenderit in voluptate velit esse.\n\t&apos;
</code></pre><p>使用反引号，则可以达到简写作用：</p>
<pre><code>const lorem = `Lorem ipsum dolor sit amet, consectetur
    adipisicing elit, sed do eiusmod tempor incididunt
    ut labore et dolore magna aliqua. Ut enim ad minim
    veniam, quis nostrud exercitation ullamco laboris
    nisi ut aliquip ex ea commodo consequat. Duis aute
    irure dolor in reprehenderit in voluptate velit esse.`
</code></pre><h2 id="15-扩展运算符简写"><a href="#15-扩展运算符简写" class="headerlink" title="15.扩展运算符简写"></a>15.扩展运算符简写</h2><p>扩展运算符有几种用例让JavaScript代码更加有效使用，可以用来代替某个数组函数。</p>
<pre><code>// joining arrays
const odd = [1, 3, 5];
const nums = [2 ,4 , 6].concat(odd);

// cloning arrays
const arr = [1, 2, 3, 4];
const arr2 = arr.slice()
</code></pre><p>简写：</p>
<pre><code>// joining arrays
const odd = [1, 3, 5 ];
const nums = [2 ,4 , 6, ...odd];
console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]

// cloning arrays
const arr = [1, 2, 3, 4];
const arr2 = [...arr];
</code></pre><p>不像concat()函数，可以使用扩展运算符来在一个数组中任意处插入另一个数组。</p>
<pre><code>const odd = [1, 3, 5 ];
const nums = [2, ...odd, 4 , 6];
</code></pre><p>也可以使用扩展运算符解构：</p>
<pre><code>const { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };
console.log(a) // 1
console.log(b) // 2
console.log(z) // { c: 3, d: 4 }
</code></pre><h2 id="16-强制参数简写"><a href="#16-强制参数简写" class="headerlink" title="16.强制参数简写"></a>16.强制参数简写</h2><p>JavaScript中如果没有向函数参数传递值，则参数为undefined。为了增强参数赋值，可以使用if语句来抛出异常，或使用强制参数简写方法。</p>
<pre><code>function foo(bar) {
  if(bar === undefined) {
    throw new Error(&apos;Missing parameter!&apos;);
  }
  return bar;
}
</code></pre><p>简写：</p>
<pre><code>mandatory = () =&gt; {
  throw new Error(&apos;Missing parameter!&apos;);
}

foo = (bar = mandatory()) =&gt; {
  return bar;
}
</code></pre><h2 id="17-Array-find简写"><a href="#17-Array-find简写" class="headerlink" title="17.Array.find简写"></a>17.Array.find简写</h2><p>想从数组中查找某个值，则需要循环。在ES6中，find()函数能实现同样效果。</p>
<pre><code>const pets = [
  { type: &apos;Dog&apos;, name: &apos;Max&apos;},
  { type: &apos;Cat&apos;, name: &apos;Karl&apos;},
  { type: &apos;Dog&apos;, name: &apos;Tommy&apos;},
]

function findDog(name) {
  for(let i = 0; i&lt;pets.length; ++i) {
    if(pets[i].type === &apos;Dog&apos; &amp;&amp; pets[i].name === name) {
      return pets[i];
    }
  }
}
</code></pre><p>简写：</p>
<pre><code>pet = pets.find(pet =&gt; pet.type ===&apos;Dog&apos; &amp;&amp; pet.name === &apos;Tommy&apos;);
console.log(pet); // { type: &apos;Dog&apos;, name: &apos;Tommy&apos; }
</code></pre><h2 id="18-Object-key-简写"><a href="#18-Object-key-简写" class="headerlink" title="18.Object[key]简写"></a>18.Object[key]简写</h2><p>考虑一个验证函数</p>
<pre><code>function validate(values) {
  if(!values.first)
    return false;
  if(!values.last)
    return false;
  return true;
}

console.log(validate({first:&apos;Bruce&apos;,last:&apos;Wayne&apos;})); // true
</code></pre><p>假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认？</p>
<pre><code>// 对象验证规则
const schema = {
  first: {
    required:true
  },
  last: {
    required:true
  }
}

// 通用验证函数
const validate = (schema, values) =&gt; {
  for(field in schema) {
    if(schema[field].required) {
      if(!values[field]) {
        return false;
      }
    }
  }
  return true;
}


console.log(validate(schema, {first:&apos;Bruce&apos;})); // false
console.log(validate(schema, {first:&apos;Bruce&apos;,last:&apos;Wayne&apos;})); // true
</code></pre><p>现在可以有适用于各种情况的验证函数，不需要为了每个而编写自定义验证函数了</p>
<h2 id="19-双重非位运算简写"><a href="#19-双重非位运算简写" class="headerlink" title="19.双重非位运算简写"></a>19.双重非位运算简写</h2><p>有一个有效用例用于双重非运算操作符。可以用来代替Math.floor()，其优势在于运行更快，可以阅读此文章了解更多位运算。<br><code>Math.floor(4.9) === 4 //true</code></p>
<p>简写：<br><code>~~4.9 === 4 //true</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/04/React高阶组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/04/React高阶组件/" itemprop="url">React高阶组件HOC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-04T19:10:27+08:00">
                2017-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h4><blockquote>
<p>高阶部件是一种用于复用组件逻辑的高级技术，它并不是 React API的一部分，而是从React 演化而来的一种模式。 具体地说，高阶组件就是一个接收一个组件并返回另外一个新组件的函数！</p>
</blockquote>
<p>这是官方文档说的，我没有截全，因为后面的解释会造成误解，但简单讲高阶组件（函数）就好比一个加工厂，同样的，屏幕、cpu、扬声器、键盘按键、外壳、电池，小米手机工厂组装完就是小米手机，魅族手机组装完就是魅族手机，基本材料都是相同的，不同工厂（高阶组件）有不同的实现及产出，当然这个工厂（高阶组件）也可能是针对某个基本材料的处理。</p>
<p>总之产出的结果拥有了输入组件不具备的功能，输入的组件可以是一个组件的实例，也可以是一个组件类，还可以是一个无状态组件的函数。</p>
<h4 id="解决什么问题？"><a href="#解决什么问题？" class="headerlink" title="解决什么问题？"></a>解决什么问题？</h4><p>随着项目越来越复杂，开发过程中，多个组件需要某个功能，而且这个功能和页面并没有关系，所以也不能简单的抽取成一个新的组件，但是如果让同样的逻辑在各个组件里各自实现，无疑会导致重复的代码。比如页面有三种弹窗一个有title，一个没有，一个又有右上角关闭按钮，除此之外别无它样，你总不能整好几个弹窗组件吧，这里除了tilte,关闭按钮其他的就可以做为上面说的基本材料。</p>
<hr>
<h4 id="高阶组件总共分为两大类"><a href="#高阶组件总共分为两大类" class="headerlink" title="高阶组件总共分为两大类"></a>高阶组件总共分为两大类</h4><ul>
<li><p>代理方式</p>
<ol>
<li>操纵prop</li>
<li>访问ref（不推荐）</li>
<li>抽取状态</li>
<li>包装组件</li>
</ol>
</li>
<li><p>继承方式</p>
<ol>
<li>操纵生命周期</li>
<li>操纵prop</li>
</ol>
</li>
</ul>
<h4 id="代理方式之-操纵prop"><a href="#代理方式之-操纵prop" class="headerlink" title="代理方式之 操纵prop"></a>代理方式之 操纵prop</h4><h6 id="删除prop"><a href="#删除prop" class="headerlink" title="删除prop"></a>删除prop</h6><pre><code>import React from&apos;react&apos;functionHocRemoveProp(WrappedComponent) {
  returnclassWrappingComPonentextendsReact.Component{
    render() {
      const { user, ...otherProps } = this.props;
      return&lt;WrappedComponent {...otherProps} /&gt;
    }
  }
}
export default HocRemoveProp;
</code></pre><h6 id="增加prop"><a href="#增加prop" class="headerlink" title="增加prop"></a>增加prop</h6><p>接下来我把简化了写法，把匿名函数去掉，同时换成箭头函数</p>
<pre><code>import React from&apos;react&apos;const HocAddProp = (WrappedComponent，uid) =&gt;classextendsReact.Component{
    render() {
      const newProps = {
        uid,
      };
      return&lt;WrappedComponent {...this.props}  {...newProps}  /&gt;
    }
  }

export default HocAddProp;
</code></pre><p>上面HocRemoveProp高阶组件中，所做的事情和输入组件WrappedComponent功能一样，只是忽略了名为user的prop。也就是说，如果WrappedComponent能处理名为user的prop,这个高阶组件返回的组件则完全无视这个prop。</p>
<pre><code>const { user, ...otherProps } = this.props;
</code></pre><p>这是一个利用es6语法技巧，经过上面的语句，otherProps里面就有this.props中所有的字段除了user.</p>
<p>假如我们现在不希望某个组件接收user的prop,那么我们就不要直接使用这个组件，而是把这个组件作为参数传递给HocRemoveProp，然后我们把这个函数的返回结果当作组件来使用</p>
<p>两个高阶组件的使用方法：</p>
<pre><code>const  newComponent = HocRemoveProp(SampleComponent);
const  newComponent = HocAddProp(SampleComponent,&apos;1111111&apos;);
</code></pre><p>也可以利用decorator语法糖这样使用</p>
<pre><code>import React, { Component } from&apos;React&apos;;

@HocRemoveProp 
classSampleComponentextendsComponent{
render() {}
}
exportdefault SampleComponent;
</code></pre><h4 id="代理方式之-抽取状态"><a href="#代理方式之-抽取状态" class="headerlink" title="代理方式之 抽取状态"></a>代理方式之 抽取状态</h4><p>将所有的状态的管理交给外面的容器组件，这个模式就是 抽取状态</p>
<p>外面的容器就是这个高阶组件</p>
<pre><code>const HocContainer = (WrappedComponent) =&gt;classextendsReact.Component{
    constructor(props) {
      super(props)
      this.state = {
        name: &apos;&apos;
      }
    }
    onNameChange = (event) =&gt; {
      this.setState({
        name: event.target.value
      })
    }
    render() {
      const newProps = {
        name: {
          value: this.state.name,
          onChange: this.onNameChange
        }
      }
      return&lt;WrappedComponent {...this.props} {...newProps} /&gt;
    }
  }

@HocContainer
classSampleComponentextendsReact.Component{
  render() {
    return&lt;inputname=&quot;name&quot; {...this.props.name}/&gt;
  }
}
</code></pre><p>这样当我们在使用这个已经被包裹的input组件（SampleComponent）时候</p>
<p>它的值就被放在了HocContainer高阶组件中，当很多这样的input组件都用这个HocContainer高阶组件时，那么它们的值都将保存在这个HocContainer高阶组件中</p>
<h4 id="代理方式之-包装组件"><a href="#代理方式之-包装组件" class="headerlink" title="代理方式之 包装组件"></a>代理方式之 包装组件</h4><pre><code>const HocStyleComponent = (WrappedComponent, style) =&gt;classextendsReact.Component{
    render() {
      return (
        &lt;divstyle={style}&gt;&lt;WrappedComponent {...this.props} {...newProps} /&gt;&lt;/div&gt;
      )
    }
  }
</code></pre><p>这样使用</p>
<pre><code>import HocStyleComponent from&apos;./HocStyleComponent&apos;;
const colorSytle ={color:&apos;#ff5555&apos;}
const  newComponent = HocStyleComponent(SampleComponent, colorSytle);
</code></pre><p>-代理方式的生命周期的过程类似于堆栈调用:</p>
<p>didmount 一&gt; HOC didmount 一&gt;(HOCs didmount) 一&gt;(HOCs will unmount) 一&gt;HOC will unmount一&gt;unmount</p>
<h4 id="在说继承方式之前先看一个例子"><a href="#在说继承方式之前先看一个例子" class="headerlink" title="在说继承方式之前先看一个例子"></a>在说继承方式之前先看一个例子</h4><pre><code>const MyContainer = (WrappedComponent) =&gt;classextendsWrappedComponent{
    render() {
      returnsuper.render();
    }
  }
</code></pre><p>这个例子很简单，相当于把WrappedComponent组件的render方法，通过super.render()方法吐到了MyContainer 中，可以顺序调用。</p>
<ul>
<li>继承方式的生命周期的过程类似于队列调用:</li>
</ul>
<p>didmount 一&gt; HOC didmount 一&gt;(HOCs didmount) 一&gt;will unmount一&gt;HOC will unmount一&gt; (HOCs will unmount)</p>
<ul>
<li>代理方式下WrappedComponent会经历一个完整的生命周期，产生的新组件和参数组件是两个不同的组件，一次渲染，两个组件都会经历各自的生命周期，</li>
<li>在继承方式下，产生的新组件和参数组件合二为一，super.render只是生命周期中的函数，变成一个生命周期。</li>
</ul>
<p>来看下面的例子你就会明白了。</p>
<h4 id="继承方式之-操纵生命周期-渲染劫持"><a href="#继承方式之-操纵生命周期-渲染劫持" class="headerlink" title="继承方式之 操纵生命周期(渲染劫持)"></a>继承方式之 操纵生命周期(渲染劫持)</h4><p>首先创建一个高阶，在创建一个使用高阶组件的组件，也就是是输入组件，最后我在改变这个输入组件props</p>
<pre><code>import * as React from&apos;react&apos;;

const HocComponent = (WrappedComponent) =&gt;classMyContainerextendsWrappedComponent{
    render() {
      if (this.props.time &amp;&amp; this.state.success) {
        returnsuper.render()
      }
      return&lt;div&gt;倒计时完成了...&lt;/div&gt;
    }
  }
</code></pre><p>这个高阶组件会直接读取输入组件中的props,state,然后控制了输入组件的render展示</p>
<p>只有在props.time和state.success同时为真的时候才会展示</p>
<pre><code>import * as React from&apos;react&apos;;
import HocComponent from&apos;./HocComponent&apos;

@HocComponent

classDemoComponentextendsReact.Component{
  constructor(props) {
    super(props);
   this.state = {
    success: true,
   };
 }
  render() {
    return&lt;div&gt;我是一个组件&lt;/div&gt;
  }
} 
exportdefault DemoComponent;
</code></pre><p>然后调用，递减time数值直到变为0</p>
<h6 id="由此可以看出高阶组件也可以控制state"><a href="#由此可以看出高阶组件也可以控制state" class="headerlink" title="由此可以看出高阶组件也可以控制state"></a>由此可以看出高阶组件也可以控制state</h6><p>但是最好要限制这样做，可能会让WrappedComponent组件内部状态变得一团糟。建议可以通过重新命名state，以防止混淆。</p>
<h4 id="继承方式之-操纵prop"><a href="#继承方式之-操纵prop" class="headerlink" title="继承方式之 操纵prop"></a>继承方式之 操纵prop</h4><pre><code>const HOCPropsComponent = (WrappedComponent) =&gt;classextendsWrappedComponent{
    render() {
      const elementsTree = super.render();
      let newProps = {
        color: (elementsTree &amp;&amp; elementsTree.type === &apos;div&apos;) ? &apos;#fff&apos; : &apos;#ff5555&apos;
      };

      const props = Object.assign({}, elementsTree.props, newProps)
      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)
      return newElementsTree
    }
  }
</code></pre><p>这样就传入了新的props，。</p>
<p>React.cloneElement( element, [props], […children])</p>
<p>参数：TYPE（ReactElement），[PROPS（object）]，[CHILDREN（ReactElement）]</p>
<p>克隆并返回一个新的 ReactElement ，新返回的元素会保留有旧元素的 props、ref、key，也会集成新的 props。</p>
<h5 id="还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，"><a href="#还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，" class="headerlink" title="还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，"></a>还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，</h5><pre><code>classaddPropsextendsReact.Component{
  render() {
    const newProps = &apos;uid&apos;returnthis.props.children(newProps)
  }
} 
</code></pre><p>使用方式</p>
<pre><code>&lt;addProps&gt;
{
   (argument) =&gt; &lt;div&gt;{argument}&lt;/div&gt;
}
&lt;/addProps&gt;
</code></pre><p>感觉很方便，但是每次渲染都会重新定义一个新的函数，如果不想的话就不要定义匿名函数，</p>
<pre><code>showUid(argument) {
    return&lt;div&gt;{argument}&lt;/div&gt;
}
</code></pre><h5 id="彩蛋recompose库"><a href="#彩蛋recompose库" class="headerlink" title="彩蛋recompose库"></a>彩蛋recompose库</h5><p>recompose是一个很流行的库，它提供了很多很有用的高阶组件（小工具），而且也可以优雅的组合它们。</p>
<h6 id="Step-1-扁平props"><a href="#Step-1-扁平props" class="headerlink" title="Step 1 扁平props."></a>Step 1 扁平props.</h6><p>我们有这样一个组件</p>
<pre><code>const Profile = ({ user }) =&gt; ( 
&lt;div&gt;&lt;div&gt;Username: {user.username}&lt;/div&gt;&lt;div&gt;Age: {user.age}&lt;/div&gt;&lt;/div&gt;
 )
</code></pre><p>如果想要改变组件接口来接收单个 prop 而不是整个用户对象，可以用 recompose 提供的高 阶组件 flattenProp 来实现。</p>
<pre><code>const Profile = ({ username，age }) =&gt; ( 
&lt;div&gt;&lt;div&gt;Username: {username}&lt;/div&gt;&lt;div&gt;Age: {age}&lt;/div&gt;&lt;/div&gt;
 )
</code></pre><p>const ProfileWithFlattenUser = flattenProp(‘user’)(Profile)；</p>
<p>现在我们希望同时使用多个高阶组件：一个用于扁平化处理用户 prop，另一个用于重命名用 户对象的单个 prop，不过串联使用函数的做法似乎不太好。 此时 recompose 库提供的 compose 函数就派上用场了。</p>
<pre><code>const enhance = compose(
 flattenProp(&apos;user&apos;),
 renameProp(&apos;username&apos;, &apos;name&apos;)
 )
</code></pre><p>然后按照以下方式将它应用于原有组件：</p>
<pre><code>const EnhancedProfile = enhance(Profile)
</code></pre><p>还可以将 compose 函数用 在我们自己的高阶组件上，甚至结合使用都可以：</p>
<pre><code>const enhance = compose( 
 flattenProp(&apos;user&apos;), 
 renameProp(&apos;username&apos;, &apos;name&apos;), 
 withInnerWidth 
)
</code></pre><h6 id="Step-2-提取输入表单的State"><a href="#Step-2-提取输入表单的State" class="headerlink" title="Step 2 提取输入表单的State"></a>Step 2 提取输入表单的State</h6><p>我们将从Recompose库中使用withStateHandlers高阶组件。 它将允许我们将组件状态与组件本身隔离开来。 我们将使用它为电子邮件，密码和确认密码字段添加表单状态，以及上述字段的事件处理程序。</p>
<pre><code>import { withStateHandlers, compose } from&quot;recompose&quot;;

const initialState = {
  email: { value: &quot;&quot; },
  password: { value: &quot;&quot; },
  confirmPassword: { value: &quot;&quot; }
};

const onChangeEmail = props =&gt; event =&gt; ({
  email: {
    value: event.target.value,
    isDirty: true
  }
});

const onChangePassword = props =&gt; event =&gt; ({
  password: {
    value: event.target.value,
    isDirty: true
  }
});

const onChangeConfirmPassword = props =&gt; event =&gt; ({
  confirmPassword: {
    value: event.target.value,
    isDirty: true
  }
});

const withTextFieldState = withStateHandlers(initialState, {
  onChangeEmail,
  onChangePassword,
  onChangeConfirmPassword
});

exportdefault withTextFieldState;
</code></pre><p>withStateHandlers它接受初始状态和包含状态处理程序的对象。调用时，每个状态处理程序将返回新的状态。</p>
<p>好了，很辛苦也很感谢你能看到这里，关于recompose介绍到此为止，喜欢的朋友可以深入研究recompose其它的方法和源码。</p>
<p>不准确的地方欢迎拍砖</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/02/CSS如何实现文字两端对齐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/02/CSS如何实现文字两端对齐/" itemprop="url">CSS如何实现文字两端对齐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-02T23:22:03+08:00">
                2017-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在工作项目中接触到Web界面设计的问题，要实现文字两端对齐的效果。在网上搜索了一下，差不多都是互相转帖，用的都是类似的技巧：</p>
<pre><code>text-align:justify;
text-justify:inter-ideograph;
</code></pre><p>但问题是，我怎么就看不到效果呢？无论是英文还是中文，在IE和chrome下都不起作用。后来，终于在StackOverflow上找到解决方法了。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .arter li {
                font-size: 14px;
                line-height: 24px;
                color: #4a4a4a;
            }

            .arter span {
                height: 24px;
                line-height: 24px;
                width: 65px;
                text-align: justify;
                display: inline-block;
                overflow: hidden;
                vertical-align: top;
            }

            .arter i {
                display: inline-block;
                width: 100%;
                height: 0;
            }




            .arter1 li {
                font-size: 14px;
                line-height: 24px;
                color: #4a4a4a;
            }



            .arter1 span {
                height: 24px;
                line-height: 24px;
                width: 65px;
                text-align: justify;
                display: inline-block;
                overflow: hidden;
                vertical-align: top;
            }
            .arter1 span:after {
                content: &quot; &quot;;
                display: inline-block;
                width: 100%;
                height: 0px;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;ul class=&quot;arter&quot;&gt;
            &lt;li&gt;&lt;span&gt;作品名称&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 宝贝儿&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;作品类型&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;艺术家&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 张玉瀛&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;风格&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 超现实&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;材质&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 布面油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;题材&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 人物&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;创作时间&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 2011&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;所在位置&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 华东&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;尺寸&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 78x78cm&lt;/li&gt;
        &lt;/ul&gt;
        &lt;br /&gt;&lt;br /&gt;
        &lt;ul class=&quot;arter1&quot;&gt;
            &lt;li&gt;&lt;span&gt;作品名称&lt;/span&gt;： 宝贝儿&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;作品类型&lt;/span&gt;： 油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;艺术家&lt;/span&gt;： 张玉瀛&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;风格&lt;/span&gt;： 超现实&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;材质&lt;/span&gt;： 布面油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;题材&lt;/span&gt;： 人物&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;创作时间&lt;/span&gt;： 2011&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;所在位置&lt;/span&gt;： 华东&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;尺寸&lt;/span&gt;： 78x78cm&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>样式：<br><img src="https://pic1.zhimg.com/v2-b92871dee74e80785026c069073206ab_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-b92871dee74e80785026c069073206ab_hd.jpg" alt=""><br>从效果图可以看到，除了要在块级元素加text-align:justify样式外，还需要在里面加一个空的span元素，并应用样式。另外，对于中文还必须用空格隔开汉字，否则也没有两端对齐的效果。英文每个单词都有空格隔开，所以没问题。</p>
<p>但是加入HTML元素又违反了结构表现分离的原则，我们可以改用after、before伪元素：</p>
<pre><code>li:after {
    content: &quot; &quot;;
    display: inline-block;
    width: 100%;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/Git-必知必会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/Git-必知必会/" itemprop="url">Git 必知必会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T22:32:36+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Git是目前世界上最先进的分布式版本控制系统。</p>
<p>参考文章：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a54386af265da3e3b7a6317" target="_blank" rel="noopener">如何优雅地使用 Git - 掘金</a></p>
<h2 id="GIT-常见命令学习整理"><a href="#GIT-常见命令学习整理" class="headerlink" title="GIT 常见命令学习整理"></a><a href="https://link.zhihu.com/?target=https%3A//blog.ihoey.com/posts/Git/2017-04-23-git.html" target="_blank" rel="noopener">GIT 常见命令学习整理</a></h2><h2 id="GIT常用命令备忘"><a href="#GIT常用命令备忘" class="headerlink" title="GIT常用命令备忘"></a><a href="https://link.zhihu.com/?target=http%3A//stormzhang.com/git/2014/01/27/git-common-command/" target="_blank" rel="noopener">GIT常用命令备忘</a></h2><h2 id="Git远程操作详解"><a href="#Git远程操作详解" class="headerlink" title="Git远程操作详解"></a><a href="https://link.zhihu.com/?target=https%3A//microzz.com/2017/05/06/git/" target="_blank" rel="noopener">Git远程操作详解</a></h2><h2 id="一篇文章，教你学会Git"><a href="#一篇文章，教你学会Git" class="headerlink" title="一篇文章，教你学会Git"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/599e14875188251240632702" target="_blank" rel="noopener">一篇文章，教你学会Git</a></h2><h2 id="如何在-Git-中使用撤消操作"><a href="#如何在-Git-中使用撤消操作" class="headerlink" title="如何在 Git 中使用撤消操作"></a><a href="https://link.zhihu.com/?target=https%3A//egoist.moe/2015/10/04/how-to-undo-with-git/" target="_blank" rel="noopener">如何在 Git 中使用撤消操作</a></h2><h2 id="git使用中碰到的问题，持续更新"><a href="#git使用中碰到的问题，持续更新" class="headerlink" title="git使用中碰到的问题，持续更新"></a><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/a420344/article/details/51792303" target="_blank" rel="noopener">git使用中碰到的问题，持续更新</a></h2><h2 id="Git-的-4-个阶段的撤销更改"><a href="#Git-的-4-个阶段的撤销更改" class="headerlink" title="Git 的 4 个阶段的撤销更改"></a><a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/akvB2DO_1dpUrf-ol77MwQ" target="_blank" rel="noopener">Git 的 4 个阶段的撤销更改</a></h2><p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a30c1786fb9a045211eb218" target="_blank" rel="noopener">Git提交历史的修改删除合并 - 掘金</a></p>
<h2 id="IDEA中分支切换error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout"><a href="#IDEA中分支切换error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout" class="headerlink" title="IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout"></a><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/tongxinxiao/article/details/43988773" target="_blank" rel="noopener">IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout</a></h2><pre><code>直接执行git clean -d -fx即可。

可能很多人都不明白-d，-fx到底是啥意思，
其实git clean -d -fx表示：删除 一些 没有 git add 的 文件；
    git clean 参数 

    -n 显示将要删除的文件和目录；

    -x -----删除忽略文件已经对git来说不识别的文件

    -d -----删除未被添加到git的路径中的文件

    -f -----强制运行

    git clean -n

    git clean -df

    git clean -f
</code></pre><p><img src="https://pic3.zhimg.com/v2-81f3b33c3cb53387c97135459b92ab3f_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81f3b33c3cb53387c97135459b92ab3f_hd.jpg" alt=""></p>
<pre><code>git reflog        //该指令输出详细的操作历史，包括提交，操作，修改等
修改注释
git commit --amend 或 git commit --amend -m &quot;Fixes bug #42&quot;

gitk 字符集编码：
git config --global gui.encoding utf-8    //在git GUI中使用UTF-8编码 

配置
git config --global user.name &quot;ihoey&quot;           # 设置git用户名
git config --global user.email &quot;mail@ihoey.com&quot; # 设置git邮箱
git config --global color.ui true               # 为true是终端着色

git config --global alias.co checkout           # 配置checkout的别名
git config --global alias.ci commit             # 配置commit的别名
git config --global alias.cm commit             # 配置commit的别名
git config --global alias.st status             # 配置status的别名
git config --global alias.br branch             # 配置branch的别名
git config --global alias.cp cherry-pick        # 配置cherry-pick的别名
 git config --global alias.rb rebase            # 配置rebase的别名

git config --global core.editor &quot;mate -w&quot;       # 设置Editor使用textmate
git config -l                                   # 列举所有配置
#用户的git配置文件~/.gitconfig

SSH 秘钥
ssh-keygen -t rsa -C &quot;mail@ihoey.com&quot;
# 连续3个回车。如果不需要密码的话。
# 最后得到了两个文件：id_rsa和id_rsa.pub，在~/.ssh/文件夹下面
# id_rsa为你的私钥，不可以告诉别人
# id_rsa.pub为你的公钥，一般会放在你的服务器做ssh登录，或者放在github上面

基本命令
创建git仓库 git init
添加文件到暂存区 git add fileName / git add .
提交文件到仓库 git commit -m &quot;版本提交信息&quot;
查看文件提交状态 git status
查看文件修改的信息 git diff readme.txt

git help &lt;command&gt;          # 显示command的help
git show                    # 显示某次提交的内容
git show $id
git checkout  -- &lt;file&gt;     # 抛弃工作区修改
git checkout  .             # 抛弃工作区修改
git add &lt;file&gt;              # 将工作文件修改提交到本地暂存区
git add .                   # 将所有修改过的工作文件提交暂存区
git rm &lt;file&gt;               # 从版本库中删除文件
git rm &lt;file&gt; --cached      # 从版本库中删除文件，但不删除文件
git reset &lt;file&gt;            # 从暂存区恢复到工作文件
git reset -- .              # 从暂存区恢复到工作文件
git reset --hard            # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改
git reset SHA1 ID           # 恢复指定提交
git commit -m &quot;some comments&quot;
git revert &lt;$id&gt;            # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象
git revert HEAD             # 恢复最后一次提交的状态

查看文件
git diff &lt;file&gt;                 # 比较当前文件和暂存区文件差异
git diff
git diff &lt;$id1&gt; &lt;$id2&gt;          # 比较两次提交之间的差异
git diff &lt;branch1&gt;..&lt;branch2&gt;   # 在两个分支之间比较
git diff --staged               # 比较暂存区和版本库差异
git diff --cached               # 比较暂存区和版本库差异
git diff --stat                 # 仅仅比较统计信息

查看提交记录
git log
git log &lt;file&gt;      # 查看该文件每次提交记录
git log -p &lt;file&gt;   # 查看每次详细修改内容的diff
git log -p -2       # 查看最近两次详细修改内容的diff
git log --stat      # 查看提交统计信息

分支管理
git branch -l                           # 查看本地分支
git branch -r                           # 查看远程分支
git branch &lt;new_branch&gt;                 # 创建新的分支
git branch -v                           # 查看各个分支最后提交信息
git branch --merged                     # 查看已经被合并到当前分支的分支
git branch --no-merged                  # 查看尚未被合并到当前分支的分支
git checkout &lt;branch&gt;                   # 切换到某个分支
git checkout -b &lt;new_branch&gt;            # 创建新的分支，并且切换过去
git checkout -b &lt;new_branch&gt; &lt;branch&gt;   # 基于branch创建新的new_branch
git checkout $id       # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除
git checkout $id -b &lt;new_branch&gt;        # 把某次历史提交记录checkout出来，创建成一个分支
git branch -d &lt;branch&gt;                  # 删除某个分支
git branch -D &lt;branch&gt;    # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)

强行切换分支
git checkout -f branch_name

强制checkout分支覆盖本地文件
git checkout -f branchname

分支合并和rebase
git merge &lt;branch&gt;               # 将branch分支合并到当前分支
git merge --no-ff &lt;branch&gt;       # 不要Fast-Foward合并，这样可以生成merge提交
git rebase master &lt;branch&gt;       # 将master rebase到branch，相当于：
git checkout &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge &lt;branch&gt;
</code></pre><ul>
<li>在我们操作过程中。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit 就可以了。</li>
<li><p>而rebase 操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行git rebase –continue继续操作，或者git rebase –skip忽略冲突。</p>
<p>  Git暂存管理<br>  git stash                        # 暂存<br>  git stash pop                    # 恢复暂存<br>  git stash list                   # 列所有stash<br>  git stash apply                  # 恢复暂存的内容<br>  git stash drop                   # 删除暂存区</p>
<p>  git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区<br>  git stash list：查看储藏队列(Stash lists)<br>  git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes))<br>  git stash clear：清空储藏队列<br>  git stash save “name of the stash”：为储藏设置命名<br>  git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏<br>  git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏)</p>
<p>  远程分支管理<br>  git pull                         # 抓取远程仓库所有分支更新并合并到本地<br>  git pull –no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并<br>  git fetch origin                 # 抓取远程仓库更新<br>  git merge origin/master          # 将远程主分支合并到本地当前分支<br>  git checkout –track origin/branch     # 跟踪某个远程分支创建相应的本地分支<br>  git checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;  # 基于远程分支创建本地分支，功能同上<br>  git push                         # push所有分支<br>  git push origin master           # 将本地主分支推到远程主分支<br>  git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)<br>  git push origin &lt;local_branch&gt;   # 创建远程分支， origin是远程仓库名<br>  git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支<br>  git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d <branch>)，然后再push删除远程分支</branch></p>
<p>  git删除远程分支<br>  git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限</p>
<p>  清空git暂存区<br>  git reset HEAD  //可以清空之前git add 的内容</p>
<p>  Git远程仓库管理<br>  git remote -v                    # 查看远程服务器地址和仓库名称<br>  git remote show origin           # 查看远程服务器仓库状态<br>  git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ihoey/blog.git     # 添加远程仓库地址<br>  git remote set-url origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ihoey/blog.git # 设置远程仓库地址(用于修改远程仓库地址)<br>  git remote rm <repository>       # 删除远程仓库</repository></p>
<p>  创建远程仓库<br>  git clone –bare ihoey.com blog.git     # 用带版本的项目创建纯版本仓库<br>  scp -r my_blog.git <a href="mailto:git@ihoey.com" target="_blank" rel="noopener">git@ihoey.com</a>:~      # 将纯仓库上传到服务器上<br>  mkdir blog.git &amp;&amp; cd blog.git &amp;&amp; git –bare init # 在服务器创建纯仓库<br>  git push -u origin master         # 客户端首次提交<br>  git push -u origin develop        # 首次将本地develop分支提交到远程develop分支，并且track<br>  git remote set-head origin master # 设置远程仓库的HEAD指向master分支</p>
<p>  设置跟踪远程库和本地库<br>  git branch –set-upstream master origin/master      #master<br>  git branch –set-upstream develop origin/develop    #develop</p>
<p>  其他命令<br>  mkdir XX    #(创建一个空目录 XX指目录名)<br>  pwd         #显示当前目录的路径。<br>  cat XX      #查看XX文件内容<br>  rm  XX      #删除文件</p>
</li>
</ul>
<p>命令别名设置:</p>
<pre><code>gitk --all &amp;   //打开git 图形化界面
git fetch --all  //刷新工作区    
git remote -v  //查看远端地址
git checkout -b dbg_master  -t origin/master   //基于远端master分支创建dbg_master分支
git merge --squash &lt;branch&gt;：将多次提交合并成一个，然后git add .;git commit -m &quot;XXXXX&quot;;git push origin XXXX...

git push                         # push所有分支
git push origin master           # 将本地主分支推到远程主分支
git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)
git push origin &lt;local_branch&gt;   # 创建远程分支， origin是远程仓库名
git push origin local-branch     #将当前local-branch 分支推送一个远程local-branch分支，本地分支和远程分支同名
git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支，将local_branch代码推送到remote_branch分支
git push origin :&lt;remote_branch&gt;  #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支

 对最近一次commit的进行修改：git commit -a –amend

 Git pull 强制覆盖本地文件
  git fetch --all  
  git reset --hard origin/master 
  git pull

git remote add origin https://git.oschina.net/duandaoke/os.git要求服务已经建立同名仓库
git remote # 显示远程仓库
git remote -v # 显示远程仓库详情
git remote show origin # 显示 origin 远程库的详情



rebase的冲突解决

   解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存） 
      git add -u   //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。
   然后执行下面命令继续rebase：
      git rebase --continue     //有冲突继续解决，重复这这些步骤，直到rebase完成。
   如果中间遇到某个补丁不需要应用，可以用下面命令忽略：
      git rebase --skip 
   如果想回到rebase执行之前的状态，可以执行：
      git rebase --abort    //放弃rebase  
   注：rebase之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。



cherry-pick的冲突解决

   解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存） 
      git add -u   //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。
   然后执行下面命令继续rebase：
      git cherry-pick --continue     //有冲突继续解决，重复这这些步骤，直到cherry-pick完成。
   如果中间遇到某个补丁不需要应用，可以用下面命令忽略：
      git cherry-pick --skip 
   如果想回到rebase执行之前的状态，可以执行：
      git cherry-pick  --abort    //放弃cherry-pick
   注：cherry-pick之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。


       手动编辑冲突的文件，使其内容和master_mlc分支上的内容一致， 
       然后git add此文件，最后执行git cherry-pick –continue即可。 


1、git删除远程分支
git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限
2、清空git暂存区
git reset HEAD  //可以清空之前git add 的内容


git clean命令用来从你的工作目录中删除所有没有tracked过的文件.
    git clean经常和git reset --hard一起结合使用. 记住reset只影响被track过的文件, 所以需要clean来删除没有track过的文件. 结合使用这两个命令能让你的工作目录完全回到一个指定的&lt;commit&gt;的状态.
用法


删除当前目录下没有被track过的文件和文件夹.
    git clean -xf


下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发.
git reset --hard
git clean -df
运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态, git status会告诉你这是一个干净的工作目录, 又是一个新的开始了.


git config --global gui.encoding utf-8    //在git GUI中使用UTF-8编码     
//git 回滚到之前某一commit
git reset –hard 8ff24a6803173208f3e606e32dfcf82db9ac84d8


在使用Git的时候,经过几次提交后,发现需要回退到早些时候的状态.例如: 
7edb8524a xxxxxxxxxxxxxxxxxx 
83dae5691 xxxxxxxxxxxxxxxxxx 
45eadd642 xxxxxxxxxxxxxxxxxx 
657834ade xxxxxxxxxxxxxxxxxx
假设现在处于7edb8524a 状态,现在我想回退到657834ade时的状态,此时可以 
git reset –hard 7edb8524a 
然后 
git reset –soft 657834ade 
会将之间的修改全部进行revert,然后在进行add commit操作就行了.
另外权限足够的话,可以从657834ade 拉一个分支出来,然后将远程分支 
删除,再将拉出来的分支push到远程仓库上,成为原来的分支,也可以实现回退到 
657834ade 的目的.此方法不会保留中间的各种修改信息和状态.


根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:
    git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息
    git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可
    git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容

已经push
对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令

revert
git revert用于反转提交,执行evert命令时要求工作树必须是干净的.
git revert用一个新提交来消除一个历史提交所做的任何修改.
revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)

revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.
git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61
通常,前几位即可
git revert c011eb3

git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit
看似达到的效果是一样的,其实完全不同.
</code></pre><p>合理的命令别名设置可以大大减少输入，有助于提高工作效率，建议遵守下述别名设置：</p>
<pre><code>git config --global alias.ci commit
git config --global alias.co checkout
git config --global alias.st status
git config --global alias.rb rebase
git config --global alias.ll “log --oneline --decorate --color”
git config --global alias.lc “log --graph --color”          
</code></pre><p>正确的回车换行设置，避免 Unix 和 Windows 下开发的回车换行的转换问题。</p>
<pre><code>(Windows  下)
git config --global core.autocrlf true
git config --global core. safecrlf warn

(Linux  下)
git config --global core.autocrlf input
git config --global core. safecrlf warn
</code></pre><p>基本命令</p>
<pre><code>git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;youremail@example.com&quot;
git config --global core.editor &lt;your favorite editor here&gt;
Ex: git config --global core.editor vim

git init：初始化一个repo，初始化本地git仓库（创建新仓库）
</code></pre><p>Commit 结构</p>
<pre><code>git status(gst)：查看 repo 状态
工作区：
.git 目录
暂存区
工作目录
</code></pre><p><img src="https://pic4.zhimg.com/v2-44aed332eb50ca594deeca86186012a8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-44aed332eb50ca594deeca86186012a8_hd.jpg" alt=""></p>
<pre><code>git add &lt;filename&gt;(ga)：添加一个文件到暂存区
git add .(gaa)：添加所有文件到暂存区
git add *.js：添加所有后缀为js的文件到暂存区
git rm --cached &lt;file&gt;：从暂存区删除一个新文件
git commit -m &quot;My first commit&quot;(gcmsg)：创建一次带 message 的提交
git commit -v -a(gca)：
-v是 verbose 的缩写，会在底部显示差异信息和更多有意义的信息
-a 类似于 git add .，会添加所有被修改和删除的文件，但会忽略新创建的文件

git help &lt;command&gt;：查看对应命令的帮助手册
git log(glg,glgg,glo, glog)：查看项目的提交历史
</code></pre><p>暂存区管理</p>
<pre><code>git reset HEAD &lt;filename&gt;(grh)：从暂存区删除一个被修改的文件
git reset HEAD(grh)：从暂存区删除所有被修改的文件
git checkout &lt;filename&gt;(gco)：从暂存区删除一个被修改的文件，并撤销文件的更改     //  git checkout .
git commit -m &quot;My first commit&quot; --amend：添加文件/更改在暂存区的最后一次提交
git commit -v -a --amend(gca!)：添加文件/更改在暂存区的最后一次提交
.gitignore：告诉git，哪些文件不被加入版本跟踪
可以使用 git add &lt;filename&gt; -f 命令添加一个不被版本跟踪的文件


git diff &lt;filename&gt;(gd)：查看基于当前文件的最后一次提交的更改差异
git diff (gd)：查看基于所有文件的最后一次提交的更改差异
git reset HEAD~2 --soft：从项目提交历史中删除最近两次提交，但不丢弃文件的更改
git reset HEAD~2 --hard：从项目提交历史中删除最近两次提交，但会丢弃文件的更改和在(最后两次)提交中创建的新文件
git reset &lt;commit&gt; --soft --hard：
--soft：将所有被更改的文件回溯到“待提交”状态
--hard：commit 之后，对被git追踪的文件的任何更改都被丢弃


git reflog：显示包括&quot;被撤销&quot;在内的所有提交
git merge &lt;commit hash&gt;：重新提交(restore the commit)
git clean -f：删除工作目录中不被git进行版本追踪的文件
</code></pre><p>Stashed &amp; BranchesStash</p>
<pre><code>git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区
git stash list：查看储藏队列(Stash lists)
git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes))
git stash clear：清空储藏队列
git stash save &quot;name of the stash&quot;：为储藏设置命名
git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏
git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏)
</code></pre><p>Branch</p>
<pre><code>git checkout -b dev(gco)：创建 dev 分支并从当前分支切换到 dev 分支      //  git checkout -b dbg_master  -t origin/master   //基于master分支创建dbg_master分支
git branch(gb)：查看所有分支
git checkout master(gcm)：切换到主分支
git merge &lt;branch&gt;(gm)：合并分支
git rebase master：先将 master 上的更改合并到当前分支，再添加当前分支的更改。如果有冲突，解决冲突后加 --continue 参数继续合并
git branch -d &lt;branch&gt;： 删除分支，-D 则强制删除分支
git merge &lt;branch&gt; --squash：将多次提交合并成一个，其流程如下：



# Go to the `master` branch
git checkout master
# Create a temp branch
git checkout -b temp
# Merge the feature/x branch into the temp using --squash
git merge feature/x --squash
# See the new modifications/files in the Staging Area
git status
# Create the unified commit
git commit -m &quot;Add feature/x&quot;
# Delete the feature/x branch
git branch -D feature/x
</code></pre><ul>
<li><p>rebase 和 merge 的区别：</p>
<p>  rebase:<br>  提交历史(的展示)是线性的<br>  缺点：会删除最近一个 commit，然后创建一次新的 commit<br>  如果已提交到远程，不要使用 rebase</p>
<p>  merge:<br>  提交历史(的展示)是分叉的<br>  对于两个分支的合并，会创建一个次新的 commit</p>
</li>
</ul>
<p>远程仓库管理</p>
<pre><code>git remote add &lt;name&gt; &lt;url&gt;：添加一个将被追踪的远程仓库
git remote rm &lt;name&gt;：移除一个远程仓库
git push &lt;remote&gt; &lt;remote-branch&gt;(gp,ggp)：将当前分支的本地 commit 推送到远程仓库
git fetch &lt;remote&gt; &lt;remote-branch&gt;：拉取远程仓库的最新 commit 到当前(本地)分支(&lt;remote&gt;/&lt;branch&gt;)，不会合并
git pull &lt;remote&gt; &lt;remote-branch&gt;(gl,ggl)：拉取远程仓库的最新 commit 到当前(本地)分支，并自动 merge
git pull --rebase(gup)：以 rebase 的方式进行合并，而不是 merge
</code></pre><p>其它有用的命令</p>
<pre><code>git tag &lt;name&gt;：创建一个 tag(如：v1.3)
git push --tags：将本地 tags 推送到远程仓库
git push &lt;tag&gt;：推送指定的本地 tag 到远程


展示帮助信息
git help -g

回到远程仓库的状态
抛弃本地所有的修改，回到远程仓库的状态。
git fetch --all &amp;&amp; git reset --hard origin/master

重设第一个commit
也就是把所有的改动都重新放回工作区，并清空所有的commit，这样就可以重新提交第一个commit了
git update-ref -d HEAD

展示工作区和暂存区的不同
输出工作区和暂存区的different(不同)。
git diff

还可以展示本地仓库中任意两个commit之间的文件变动：
git diff &lt;commit-id&gt; &lt;commit-id&gt;

展示暂存区和最近版本的不同
输出暂存区和本地最近的版本(commit)的different(不同)。
git diff --cached

展示暂存区、工作区和最近版本的不同
输出工作区、暂存区 和本地最近的版本(commit)的different(不同)。
git diff HEAD

快速切换分支
git checkout -

删除已经合并到master的分支
git branch --merged master | grep -v &apos;^\*\|  master&apos; | xargs -n 1 git branch -d

展示本地分支关联远程仓库的情况
git branch -vv

关联远程分支
关联之后，git branch -vv就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。
git branch -u origin/mybranch

或者在push时加上-u参数
git push origin/mybranch -u

列出所有本地分支
-l参数相当于：local
git branch -l

列出所有远程分支
-r参数相当于：remote
git branch -r

列出本地和远程分支
-a参数相当于：all
git branch -a

创建并切换到本地分支
git checkout -b &lt;branch-name&gt;

创建并切换到远程分支
git checkout -b &lt;branch-name&gt; -t origin/&lt;branch-name&gt;

删除本地分支
git branch -d &lt;local-branchname&gt;

删除远程分支
git push origin --delete &lt;remote-branchname&gt;
或者
git push origin :&lt;remote-branchname&gt;

重命名本地分支
git branch -m &lt;new-branch-name&gt;
git branch -m &lt;oldbranchname&gt; &lt;newbranchname&gt;：尝试修改
git branch -M &lt;oldbranchname&gt; &lt;newbranchname&gt;：强制修改

查看标签
git tag

展示当前分支的最近的tag
git describe --tags --abbrev=0

本地创建标签
git tag &lt;version-number&gt;

默认tag是打在最近的一次commit上，如果需要指定commit打tag：
$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;

推送标签到远程仓库
首先要保证本地创建好了标签才可以推送标签到远程仓库：
git push origin &lt;local-version-number&gt;

一次性推送所有标签，同步到远程仓库：
git push origin --tags

删除本地标签
git tag -d &lt;tag-name&gt;

删除远程标签
删除远程标签需要先删除本地标签，再执行下面的命令：
git push origin :refs/tags/&lt;tag-name&gt;

切回到某个标签
一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：
git checkout -b branch_name tag_name

放弃工作区的修改
git checkout &lt;file-name&gt;

放弃所有修改：
git checkout .

恢复删除的文件
git rev-list -n 1 HEAD -- &lt;file_path&gt; #得到 deleting_commit
git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态

回到某一个commit的状态，并重新增添一个commit  //回退，有记录
git revert &lt;commit-id&gt;

回到某个commit的状态，并删除后面的commit
和revert的区别：reset命令会抹去某个commit id之后的所有commit
git reset &lt;commit-id&gt;

修改上一个commit的描述
git commit --amend

查看commit历史
git log

查看某段代码是谁写的
blame的意思为‘责怪’，你懂的。
git blame &lt;file-name&gt;

显示本地执行过git命令
就像shell的history一样
git reflog

修改作者名
git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos;

修改远程仓库的url
git remote set-url origin &lt;URL&gt;

增加远程仓库
git remote add origin &lt;remote-url&gt;

列出所有远程仓库
git remote    //  git remote -v

查看两个星期内的改动
git whatchanged --since=&apos;2 weeks ago&apos;

把A分支的某一个commit，放到B分支上
这个过程需要cherry-pick命令，参考
git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;

给git命令起别名
简化命令
git config --global alias.&lt;handle&gt; &lt;command&gt;
比如：git status 改成 git st，这样可以简化命令
git config --global alias.st status

存储当前的修改，但不用提交commit
详解可以参考廖雪峰老师的git教程

git stash
保存当前状态，包括untracked的文件

untracked文件：新建的文件
git stash -u

展示所有stashes
git stash list

回到某个stash的状态
git stash apply &lt;stash@{n}&gt;

回到最后一个stash的状态，并删除这个stash
git stash pop

删除所有的stash
git stash clear

从stash中拿出某个文件的修改
git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt;

展示所有tracked的文件
git ls-files -t

展示所有untracked的文件
git ls-files --others

展示所有忽略的文件
git ls-files --others -i --exclude-standard

强制删除untracked的文件
可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。clean命令，注意两点：
clean后，删除的文件无法找回
不会影响tracked的文件的改动，只会删除untracked的文件git clean &lt;file-name&gt; -f
强制删除untracked的目录
可以用来删除新建的目录，注意:这个命令也可以用来删除untracked的文件。详情见上一条
git clean &lt;directory-name&gt; -df

展示简化的commit历史
git log --pretty=oneline --graph --decorate --all
把某一个分支到导出成一个文件
git bundle create &lt;file&gt; &lt;branch-name&gt;
从包中导入分支
新建一个分支，分支内容就是上面git bundle create命令导出的内容
git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;
执行rebase之前自动stash
git rebase --autostash
从远程仓库根据ID，拉下某一状态，到本地分支
git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;
详细展示一行中的修改
git diff --word-diff
清除gitignore文件中记录的文件
git clean -X -f
展示所有alias和configs
注意： config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config
git config --local --list (当前目录)
git config --global --list (全局)
展示忽略的文件
git status --ignored
commit历史中显示Branch1有的，但是Branch2没有commit
git log Branch1 ^Branch2
在commit log中显示GPG签名
git log --show-signature
删除全局设置
git config --global --unset &lt;entry-name&gt;
新建并切换到新分支上，同时这个分支没有任何commit
相当于保存修改，但是重写commit历史
git checkout --orphan &lt;branch-name&gt;
展示任意分支某一文件的内容
git show &lt;branch-name&gt;:&lt;file-name&gt;
clone下来指定的单一分支
git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git
忽略某个文件的改动
关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动
git update-index --assume-unchanged path/to/file

恢复 track 指定文件的改动
git update-index --no-assume-unchanged path/to/file

忽略文件的权限变化
不再将文件的权限变化视作改动
git config core.fileMode false
展示本地所有的分支的commit
最新的放在最上面
git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/
在commit log中查找相关内容
通过grep查找，given-text：所需要查找的字段
git log --all --grep=&apos;&lt;given-text&gt;&apos;
把暂存区的指定file放到工作区中
git reset &lt;file-name&gt;

强制推送
git push -f &lt;remote-name&gt; &lt;branch-name&gt;列出所有远程分支
-r参数相当于：remote
git branch -r

更新到本地
# 源 + 分支名
git pull origin master
</code></pre><p>初始化本地git仓库（创建新仓库）</p>
<pre><code>git init                                               
# 初始化 git 项目
git init
安装好 Git 之后，配置你的资料:
# 配置用户名
git config --global user.name &quot;Your Real Name&quot;
# 配置邮箱地址
git config --global user.email you@email.address
</code></pre><p>配置用户名</p>
<pre><code>git config --global user.name &quot;xxx&quot;                       
</code></pre><p>配置邮件</p>
<pre><code>git config --global user.email &quot;xxx@xxx.com&quot;              
</code></pre><p>git status等命令自动着色</p>
<pre><code>git config --global color.ui true                         
git config --global color.status auto
git config --global color.diff auto
git config --global color.branch auto
git config --global color.interactive auto
</code></pre><p>clone远程仓库</p>
<pre><code>git clone git+ssh://git@192.168.53.168/VT.git             
</code></pre><p>查看当前版本状态（是否修改）</p>
<pre><code>git status                                                
</code></pre><p>添加xyz文件至index</p>
<pre><code>git add xyz                                               
</code></pre><p>增加当前子目录下所有更改过的文件至index</p>
<pre><code>git add .                                                 
</code></pre><p>提交</p>
<pre><code>git commit -m &apos;xxx&apos;                                       
</code></pre><p>合并上一次提交（用于反复修改）</p>
<pre><code>git commit --amend -m &apos;xxx&apos;                               
</code></pre><p>将add和commit合为一步</p>
<pre><code>git commit -am &apos;xxx&apos;                                      
</code></pre><p>删除index中的文件</p>
<pre><code>git rm xxx                                                
</code></pre><p>递归删除</p>
<pre><code>git rm -r *                                               
</code></pre><p>显示提交日志</p>
<pre><code>git log                                                   
</code></pre><p>显示1行日志 -n为n行</p>
<pre><code>git log -1                                                
</code></pre><p>git log -5</p>
<p>显示提交日志及相关变动文件</p>
<pre><code>git log --stat                                            
</code></pre><p>git log -p -m</p>
<p>显示某个提交的详细内容</p>
<pre><code>git show dfb02e6e4f2f7b573337763e5c0013802e392818         
</code></pre><p>可只用commitid的前几位</p>
<pre><code>git show dfb02                                            
</code></pre><p>显示HEAD提交日志</p>
<pre><code>git show HEAD                                             
</code></pre><p>显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</p>
<pre><code>git show HEAD^                                            
</code></pre><p>显示已存在的tag</p>
<pre><code>git tag                                                   
</code></pre><p>增加v2.0的tag</p>
<pre><code>git tag -a v2.0 -m &apos;xxx&apos;                                  
</code></pre><p>显示v2.0的日志及详细内容</p>
<pre><code>git show v2.0                                             
</code></pre><p>显示v2.0的日志</p>
<pre><code>git log v2.0                                              
</code></pre><p>显示所有未添加至index的变更</p>
<pre><code>git diff                                                  
</code></pre><p>显示所有已添加index但还未commit的变更</p>
<pre><code>git diff --cached                                         
</code></pre><p>比较与上一个版本的差异</p>
<pre><code>git diff HEAD^                                            
</code></pre><p>比较与HEAD版本lib目录的差异</p>
<pre><code>git diff HEAD -- ./lib                                    
</code></pre><p>比较远程分支master上有本地分支master上没有的</p>
<pre><code>git diff origin/master..master                            
</code></pre><p>只显示差异的文件，不显示具体内容</p>
<pre><code>git diff origin/master..master --stat                     
</code></pre><p>增加远程定义（用于push/pull/fetch）</p>
<pre><code>git remote add origin git+ssh://git@192.168.53.168/VT.git 
</code></pre><p>显示本地分支</p>
<pre><code>git branch                                                
</code></pre><p>显示包含提交50089的分支</p>
<pre><code>git branch --contains 50089                               
</code></pre><p>显示所有分支</p>
<pre><code>git branch -a                                             
</code></pre><p>显示所有原创分支</p>
<pre><code>git branch -r                                             
</code></pre><p>显示所有已合并到当前分支的分支</p>
<pre><code>git branch --merged                                       
</code></pre><p>显示所有未合并到当前分支的分支</p>
<pre><code>git branch --no-merged                                    
</code></pre><p>本地分支改名</p>
<pre><code>git branch -m master master_copy                          
</code></pre><p>从当前分支创建新分支master_copy并检出</p>
<pre><code>git checkout -b master_copy                               
</code></pre><p>上面的完整版</p>
<pre><code>git checkout -b master master_copy                        
</code></pre><p>检出已存在的features/performance分支</p>
<pre><code>git checkout features/performance                         
</code></pre><p>检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</p>
<pre><code>git checkout --track hotfixes/BJVEP933                    
</code></pre><p>检出版本v2.0</p>
<pre><code>git checkout v2.0                                         
</code></pre><p>从远程分支develop创建新本地分支devel并检出</p>
<pre><code>git checkout -b devel origin/develop                      
</code></pre><p>检出head版本的README文件（可用于修改错误回退）</p>
<pre><code>git checkout -- README                                    
</code></pre><p>合并远程master分支至当前分支</p>
<pre><code>git merge origin/master                                   
</code></pre><p>合并提交ff44785404a8e的修改</p>
<pre><code>git cherry-pick ff44785404a8e                             
</code></pre><p>将当前分支push到远程master分支</p>
<pre><code>git push origin master                                    
</code></pre><p>删除远程仓库的hotfixes/BJVEP933分支</p>
<pre><code>git push origin :hotfixes/BJVEP933                        
</code></pre><p>把所有tag推送到远程仓库</p>
<pre><code>git push --tags                                           
</code></pre><p>获取所有远程分支（不更新本地分支，另需merge）</p>
<pre><code>git fetch                                                 
</code></pre><p>获取所有原创分支并清除服务器上已删掉的分支</p>
<pre><code>git fetch --prune                                         
</code></pre><p>获取远程分支master并merge到当前分支</p>
<pre><code>git pull origin master                                    
</code></pre><p>重命名文件README为README2</p>
<pre><code>git mv README README2                                     
</code></pre><p>将当前版本重置为HEAD（通常用于merge失败回退）</p>
<pre><code>git reset --hard HEAD                                     
</code></pre><p>git rebase</p>
<p>删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</p>
<pre><code>git branch -d hotfixes/BJVEP933                           
</code></pre><p>强制删除分支hotfixes/BJVEP933</p>
<pre><code>git branch -D hotfixes/BJVEP933                           
</code></pre><p>列出git index包含的文件</p>
<pre><code>git ls-files                                              
</code></pre><p>图示当前分支历史</p>
<pre><code>git show-branch                                           
</code></pre><p>图示所有分支历史</p>
<pre><code>git show-branch --all                                     
</code></pre><p>显示提交历史对应的文件修改</p>
<pre><code>git whatchanged                                           
</code></pre><p>撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</p>
<pre><code>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       
</code></pre><p>内部命令：显示某个git对象</p>
<pre><code>git ls-tree HEAD                                          
</code></pre><p>内部命令：显示某个ref对于的SHA1 HASH</p>
<pre><code>git rev-parse v2.0                                        
</code></pre><p>显示所有提交，包括孤立节点</p>
<pre><code>git reflog                                                
</code></pre><p>git show HEAD@{5}</p>
<p>显示master分支昨天的状态</p>
<pre><code>git show master@{yesterday}                               
</code></pre><p>图示提交日志</p>
<pre><code>git log --pretty=format:&apos;%h %s&apos; --graph                   
git show HEAD~3
git show -s --pretty=raw 2be7fcb476
</code></pre><p>暂存当前修改，将所有至为HEAD状态</p>
<pre><code>git stash                                                 
</code></pre><p>查看所有暂存</p>
<pre><code>git stash list                                            
</code></pre><p>参考第一次暂存</p>
<pre><code>git stash show -p stash@{0}                               
</code></pre><p>应用第一次暂存</p>
<pre><code>git stash apply stash@{0}                                 
</code></pre><p>文件中搜索文本“delete from”</p>
<pre><code>git grep &quot;delete from&quot;                                    
git grep -e &apos;#define&apos; --and -e SORT_DIRENT

git gc
git fsck
</code></pre><hr>
<ol>
<li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li>
<li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li>
<li>统一概念：</li>
</ol>
<ul>
<li>工作区：改动（增删文件和内容）</li>
<li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了‘暂存区’</li>
<li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。</li>
<li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了‘远程仓库’（GitHub等)</li>
<li>commit-id：输出命令：<code>git log</code>，最上面那行<code>commit xxxxxx</code>，后面的字符串就是commit-id</li>
</ul>
<h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><pre><code>git help -g
</code></pre><h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p>
<pre><code>gitfetch--all&amp;&amp;gitreset--hardorigin/master
</code></pre><h2 id="重设第一个commit"><a href="#重设第一个commit" class="headerlink" title="重设第一个commit"></a>重设第一个commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的commit</strong>，这样就可以重新提交第一个commit了</p>
<pre><code>git update-ref -d HEAD
</code></pre><h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的different(不同)。</p>
<pre><code>git diff
</code></pre><p>还可以展示本地仓库中任意两个commit之间的文件变动：</p>
<pre><code>git diff &lt;commit-id&gt; &lt;commit-id&gt;
</code></pre><h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本(commit)的different(不同)。</p>
<pre><code>git diff --cached
</code></pre><h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本(commit)的different(不同)。</p>
<pre><code>git diff HEAD
</code></pre><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><pre><code>git checkout -
</code></pre><h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><pre><code>git branch --merged master| grep -v &apos;^\*\|  master&apos; | xargs -n 1 git branch -d
</code></pre><h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><pre><code>gitbranch -vv
</code></pre><h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code>就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。</p>
<pre><code>gitbranch -u origin/mybranch
</code></pre><p>或者在push时加上<code>-u</code>参数</p>
<pre><code>git pushorigin/mybranch -u
</code></pre><h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r参数相当于：remote</p>
<pre><code>git branch -r
</code></pre><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all</p>
<pre><code>git branch -a
</code></pre><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><pre><code>git checkout -b &lt;branch-name&gt;
</code></pre><h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><pre><code>git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;
</code></pre><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><pre><code>git branch -d &lt;local-branchname&gt;
</code></pre><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><pre><code>git pushorigin --delete &lt;remote-branchname&gt;
</code></pre><p>或者</p>
<pre><code>git push origin :&lt;remote-branchname&gt;
</code></pre><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><pre><code>git branch -m &lt;new-branch-name&gt;
</code></pre><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><pre><code>git tag
</code></pre><p>展示当前分支的最近的tag</p>
<pre><code>gitdescribe--tags--abbrev=0
</code></pre><h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><pre><code>git tag&lt;version-number&gt;
</code></pre><p>默认tag是打在最近的一次commit上，如果需要指定commit打tag：</p>
<pre><code>$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;
</code></pre><h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p>
<pre><code>git push origin &lt;local-version-number&gt;
</code></pre><p>一次性推送所有标签，同步到远程仓库：</p>
<pre><code>git pushorigin --tags
</code></pre><h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><pre><code>git tag-d&lt;tag-name&gt;
</code></pre><h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p>
<pre><code>git push origin :refs/tags/&lt;tag-name&gt;
</code></pre><h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p>
<pre><code>git checkout -b branch_name tag_name
</code></pre><h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><pre><code>git checkout &lt;file-name&gt;
</code></pre><p>放弃所有修改：</p>
<pre><code>git checkout .
</code></pre><h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><pre><code>git rev-list -n 1 HEAD -- &lt;file_path&gt;#得到 deleting_commit

git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt;#回到删除文件 deleting_commit 之前的状态
</code></pre><h2 id="以新增一个commit的方式还原某一个commit的修改"><a href="#以新增一个commit的方式还原某一个commit的修改" class="headerlink" title="以新增一个commit的方式还原某一个commit的修改"></a>以新增一个commit的方式还原某一个commit的修改</h2><pre><code>git revert &lt;commit-id&gt;
</code></pre><h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和revert的区别：reset命令会抹去某个commit id之后的所有commit</p>
<pre><code>git reset &lt;commit-id&gt;  #默认就是-mixed参数。

git reset –mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。

git reset –soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可   

git reset –hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容
</code></pre><h2 id="修改上一个commit的描述"><a href="#修改上一个commit的描述" class="headerlink" title="修改上一个commit的描述"></a>修改上一个commit的描述</h2><pre><code>git commit--amend
</code></pre><h2 id="查看commit历史"><a href="#查看commit历史" class="headerlink" title="查看commit历史"></a>查看commit历史</h2><pre><code>git log
</code></pre><h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame的意思为‘责怪’，你懂的。</p>
<pre><code>git blame &lt;file-name&gt;
</code></pre><h2 id="显示本地更新过HEAD的git命令记录"><a href="#显示本地更新过HEAD的git命令记录" class="headerlink" title="显示本地更新过HEAD的git命令记录"></a>显示本地更新过HEAD的git命令记录</h2><p>每次更新了HEAD 的git 命令比如 commint、amend、cherry-pick、reset、revert等都会被记录下来（不限分支），就像shell的history一样。<br>这样你可以reset 到任何一次更新了HEAD 的操作之后，而不仅仅是回到当前分支下的某个commit 之后的状态。</p>
<pre><code>git reflog
</code></pre><h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><pre><code>git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos;
</code></pre><h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><pre><code>git remote set-urlorigin &lt;URL&gt;
</code></pre><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><pre><code>git remote add origin &lt;remote-url&gt;
</code></pre><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><pre><code>git remote
</code></pre><h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><pre><code>git whatchanged --since=&apos;2 weeks ago&apos;
</code></pre><h2 id="把A分支的某一个commit，放到B分支上"><a href="#把A分支的某一个commit，放到B分支上" class="headerlink" title="把A分支的某一个commit，放到B分支上"></a>把A分支的某一个commit，放到B分支上</h2><p>这个过程需要<code>cherry-pick</code>命令，<a href="http://sg552.iteye.com/blog/1300713#bc2367928" target="_blank" rel="noopener">参考</a></p>
<pre><code>git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;
</code></pre><h2 id="给git命令起别名"><a href="#给git命令起别名" class="headerlink" title="给git命令起别名"></a>给git命令起别名</h2><p>简化命令</p>
<pre><code>git config --globalalias.&lt;handle&gt; &lt;command&gt;

比如：git status 改成 git st，这样可以简化命令

git config --globalalias.st status
</code></pre><h2 id="存储当前的修改，但不用提交commit"><a href="#存储当前的修改，但不用提交commit" class="headerlink" title="存储当前的修改，但不用提交commit"></a>存储当前的修改，但不用提交commit</h2><p>详解可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="noopener">廖雪峰老师的git教程</a></p>
<pre><code>git stash
</code></pre><h2 id="保存当前状态，包括untracked的文件"><a href="#保存当前状态，包括untracked的文件" class="headerlink" title="保存当前状态，包括untracked的文件"></a>保存当前状态，包括untracked的文件</h2><p>untracked文件：新建的文件</p>
<pre><code>git stash -u
</code></pre><h2 id="展示所有stashes"><a href="#展示所有stashes" class="headerlink" title="展示所有stashes"></a>展示所有stashes</h2><pre><code>git stash list
</code></pre><h2 id="回到某个stash的状态"><a href="#回到某个stash的状态" class="headerlink" title="回到某个stash的状态"></a>回到某个stash的状态</h2><pre><code>git stash apply &lt;stash@{n}&gt;
</code></pre><h2 id="回到最后一个stash的状态，并删除这个stash"><a href="#回到最后一个stash的状态，并删除这个stash" class="headerlink" title="回到最后一个stash的状态，并删除这个stash"></a>回到最后一个stash的状态，并删除这个stash</h2><pre><code>git stash pop
</code></pre><h2 id="删除所有的stash"><a href="#删除所有的stash" class="headerlink" title="删除所有的stash"></a>删除所有的stash</h2><pre><code>git stash clear
</code></pre><h2 id="从stash中拿出某个文件的修改"><a href="#从stash中拿出某个文件的修改" class="headerlink" title="从stash中拿出某个文件的修改"></a>从stash中拿出某个文件的修改</h2><pre><code>git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt;
</code></pre><h2 id="展示所有tracked的文件"><a href="#展示所有tracked的文件" class="headerlink" title="展示所有tracked的文件"></a>展示所有tracked的文件</h2><pre><code>git ls-files -t
</code></pre><h2 id="展示所有untracked的文件"><a href="#展示所有untracked的文件" class="headerlink" title="展示所有untracked的文件"></a>展示所有untracked的文件</h2><pre><code>git ls-files--others
</code></pre><h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><pre><code>gitls-files--others-i--exclude-standard
</code></pre><h2 id="强制删除untracked的文件"><a href="#强制删除untracked的文件" class="headerlink" title="强制删除untracked的文件"></a>强制删除untracked的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。<code>clean</code>命令，<strong>注意两点</strong>：</p>
<ol>
<li>clean后，删除的文件无法找回</li>
<li><p>不会影响tracked的文件的改动，只会删除untracked的文件</p>
<p> git clean <file-name> -f</file-name></p>
</li>
</ol>
<h2 id="强制删除untracked的目录"><a href="#强制删除untracked的目录" class="headerlink" title="强制删除untracked的目录"></a>强制删除untracked的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除untracked的文件。详情见上一条</p>
<pre><code>git clean &lt;directory-name&gt; -df
</code></pre><h2 id="展示简化的commit历史"><a href="#展示简化的commit历史" class="headerlink" title="展示简化的commit历史"></a>展示简化的commit历史</h2><pre><code>gitlog--pretty=oneline--graph--decorate--all
</code></pre><h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><pre><code>git bundle create &lt;file&gt; &lt;branch-name&gt;
</code></pre><h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面<code>git bundle create</code>命令导出的内容</p>
<pre><code>git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;
</code></pre><h2 id="执行rebase之前自动stash"><a href="#执行rebase之前自动stash" class="headerlink" title="执行rebase之前自动stash"></a>执行rebase之前自动stash</h2><pre><code>git rebase --autostash
</code></pre><h2 id="从远程仓库根据ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据ID，拉下某一状态，到本地分支"></a>从远程仓库根据ID，拉下某一状态，到本地分支</h2><pre><code>git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;
</code></pre><h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><pre><code>git diff --word-diff
</code></pre><h2 id="清除gitignore文件中记录的文件"><a href="#清除gitignore文件中记录的文件" class="headerlink" title="清除gitignore文件中记录的文件"></a>清除gitignore文件中记录的文件</h2><pre><code>git clean -X -f
</code></pre><h2 id="展示所有alias和configs"><a href="#展示所有alias和configs" class="headerlink" title="展示所有alias和configs"></a>展示所有alias和configs</h2><p><strong>注意：</strong> config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config</p>
<pre><code>gitconfig--local--list(当前目录)gitconfig--global--list(全局)
</code></pre><h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><pre><code>git status--ignored
</code></pre><h2 id="commit历史中显示Branch1有的，但是Branch2没有commit"><a href="#commit历史中显示Branch1有的，但是Branch2没有commit" class="headerlink" title="commit历史中显示Branch1有的，但是Branch2没有commit"></a>commit历史中显示Branch1有的，但是Branch2没有commit</h2><pre><code>git log Branch1 ^Branch2
</code></pre><h2 id="在commit-log中显示GPG签名"><a href="#在commit-log中显示GPG签名" class="headerlink" title="在commit log中显示GPG签名"></a>在commit log中显示GPG签名</h2><pre><code>git log--show-signature
</code></pre><h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><pre><code>git config --global --unset &lt;entry-name&gt;
</code></pre><h2 id="新建并切换到新分支上，同时这个分支没有任何commit"><a href="#新建并切换到新分支上，同时这个分支没有任何commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何commit"></a>新建并切换到新分支上，同时这个分支没有任何commit</h2><p>相当于保存修改，但是重写commit历史</p>
<pre><code>git checkout --orphan &lt;branch-name&gt;
</code></pre><h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><pre><code>git show &lt;branch-name&gt;:&lt;file-name&gt;
</code></pre><h2 id="clone下来指定的单一分支"><a href="#clone下来指定的单一分支" class="headerlink" title="clone下来指定的单一分支"></a>clone下来指定的单一分支</h2><pre><code>git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git
</code></pre><h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p>
<pre><code>git update-index --assume-unchanged path/to/file
</code></pre><p>恢复 track 指定文件的改动</p>
<pre><code>git update-index --no-assume-unchanged path/to/file
</code></pre><h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p>
<pre><code>git config core.fileMode false
</code></pre><h2 id="以最后提交的顺序列出所有Git分支"><a href="#以最后提交的顺序列出所有Git分支" class="headerlink" title="以最后提交的顺序列出所有Git分支"></a>以最后提交的顺序列出所有Git分支</h2><p>最新的放在最上面</p>
<pre><code>git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/
</code></pre><h2 id="在commit-log中查找相关内容"><a href="#在commit-log中查找相关内容" class="headerlink" title="在commit log中查找相关内容"></a>在commit log中查找相关内容</h2><p>通过grep查找，given-text：所需要查找的字段</p>
<pre><code>git log --all --grep=&apos;&lt;given-text&gt;&apos;
</code></pre><h2 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h2><p>不添加参数，默认是-mixed</p>
<pre><code>git reset &lt;file-name&gt;
</code></pre><h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><pre><code>git push -f &lt;remote-name&gt; &lt;branch-name&gt;
</code></pre><h2 id="长按关注订阅号"><a href="#长按关注订阅号" class="headerlink" title="长按关注订阅号"></a>长按关注订阅号</h2><p><img src="https://static.segmentfault.com/v-5be168e8/global/img/squares.svg" alt="clipboard.png"></p>
<h2 id="长按进入RDhub群"><a href="#长按进入RDhub群" class="headerlink" title="长按进入RDhub群"></a>长按进入RDhub群</h2><p><img src="https://static.segmentfault.com/v-5be168e8/global/img/squares.svg" alt="clipboard.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/15/用css让一个容器水平垂直居中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/15/用css让一个容器水平垂直居中/" itemprop="url">用css让一个容器水平垂直居中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-15T23:19:26+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阅读目录</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label0" target="_blank" rel="noopener">方法一：position加margin</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label1" target="_blank" rel="noopener">方法二： diaplay:table-cell</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label2" target="_blank" rel="noopener">方法三：position加 transform</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label3" target="_blank" rel="noopener">方法四：flex;align-items: center;justify-content: center</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label4" target="_blank" rel="noopener">方法五：display:flex;margin:auto</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label5" target="_blank" rel="noopener">方法六：纯position</a></li>
</ul>
<p>这种css布局平时用的比较多，也是面试题常出的一个题，网上一搜一大丢，不过还是想自己总结一下。</p>
<p>这种方法比较多，本文只总结其中的几种，以便加深印象。</p>
<p>效果图都为这个：</p>
<p><img src="https://pic1.zhimg.com/v2-cf428b1f71583bc3feeeedcdc87d9e6c_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf428b1f71583bc3feeeedcdc87d9e6c_hd.jpg" alt=""></p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法一：position加margin"><a href="#方法一：position加margin" class="headerlink" title="方法一：position加margin"></a>方法一：position加margin</h2><pre><code>/**html**/
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/**css**/
.wrap {
    width: 200px;
    height: 200px;
    background: yellow;
    position: relative;
}
.wrap .center {
    width: 100px;
    height: 100px;
    background: green;
    margin: auto;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
}
</code></pre><p>兼容性：主流浏览器均支持，IE6不支持</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法二：-diaplay-table-cell"><a href="#方法二：-diaplay-table-cell" class="headerlink" title="方法二： diaplay:table-cell"></a>方法二： diaplay:table-cell</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
     &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/*css*/
.wrap{
    width: 200px;
    height: 200px;
    background: yellow;
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}
.center{
    display: inline-block;
    vertical-align: middle;
    width: 100px;
    height: 100px;
    background: green;
}
</code></pre><p>兼容性：由于display:table-cell的原因，IE6\7不兼容</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法三：position加-transform"><a href="#方法三：position加-transform" class="headerlink" title="方法三：position加 transform"></a>方法三：position加 transform</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    position: relative;
    background: yellow;
    width: 200px;
    height: 200px;}

.center {
    position: absolute;
    background: green;
    top:50%;
    left:50%;
    -webkit-transform:translate(-50%,-50%);
    transform:translate(-50%,-50%);
    width: 100px;
    height: 100px;
}
</code></pre><p>兼容性：ie9以下不支持 transform，手机端表现的比较好。</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法四：flex-align-items-center-justify-content-center"><a href="#方法四：flex-align-items-center-justify-content-center" class="headerlink" title="方法四：flex;align-items: center;justify-content: center"></a>方法四：flex;align-items: center;justify-content: center</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    display: flex; 
    align-items: center; 
    justify-content: center;
}

.center {
    background: green;
    width: 100px;
    height: 100px;
}
</code></pre><p>移动端首选</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法五：display-flex-margin-auto"><a href="#方法五：display-flex-margin-auto" class="headerlink" title="方法五：display:flex;margin:auto"></a>方法五：display:flex;margin:auto</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    display: flex; 
}

.center {
    background: green;
    width: 100px;
    height: 100px;
    margin: auto;
}
</code></pre><p>移动端首选</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法六：纯position"><a href="#方法六：纯position" class="headerlink" title="方法六：纯position"></a>方法六：纯position</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    position: relative;
}
/**方法一**/
.center {
    background: green;
    position: absolute;
    width: 100px;
    height: 100px;
    left: 50px;
    top: 50px; 
　　
}
/**方法二**/
.center {
    background: green;
    position: absolute;
    width: 100px;
    height: 100px;
    left: 50%;
    top: 50%;
　　margin-left:-50px;
　　margin-top:-50px;
}　 
</code></pre><p>兼容性：适用于所有浏览器</p>
<p>  方法六中的方法一计算公式如下：</p>
<p>　　子元素（conter）的left值计算公式：left=(父元素的宽 - 子元素的宽 ) / 2=(200-100) / 2=50px;</p>
<p>　　子元素（conter）的top值计算公式：top=(父元素的高 - 子元素的高 ) / 2=(200-100) / 2=50px;</p>
<p>　　方法二计算公式：</p>
<p>　　left值固定为50%;</p>
<p>　　子元素的margin-left= -（子元素的宽/2）=-100/2= -50px;</p>
<p>　　top值也一样，固定为50%</p>
<pre><code>子元素的margin-top= -（子元素的高/2）=-100/2= -50px;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/22/算法的时间复杂度和空间复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/22/算法的时间复杂度和空间复杂度/" itemprop="url">算法的时间复杂度和空间复杂度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-22T23:26:28+08:00">
                2017-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1 - 算法</p>
<p>算法的定义是这样的：解题方案的准确而完善的描述，是一系列解决问题的清晰指令。巴拉巴拉的，虽然是一小句但还是不想看（题外话：有时候吧专业名词记下来面试的时候还是挺有用的），其实就是解决一个问题的完整性描述。只不过这个描述就可能是用不同的方式或者说是“语言”了。</p>
<p>2 - 算法的效率</p>
<p>既然算法是解决问题的描述，那么就像一千个人眼中有一千个阿姆雷特他大姨夫一样，解决同一个问题的办法也是多种多样的，只是在这过程中我们所使用/消耗的时间或者时间以外的代价（计算机消耗的则为内存了）不一样。为了更快、更好、更强的发扬奥利奥..哦不，提高算法的效率。所以很多时候一个优秀的算法就在于它与其他实现同一个问题的算法相比，在时间或空间（内存）或者时间和空间（内存）上都得到明显的降低。</p>
<p>所以呢，算法的效率主要由以下两个复杂度来评估：</p>
<blockquote>
<p>时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。<br>空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。</p>
</blockquote>
<p>设计算法时，时间复杂度要比空间复杂度更容易出问题，所以一般情况一下我们只对时间复杂度进行研究。一般面试或者工作的时候没有特别说明的话，复杂度就是指时间复杂度。</p>
<p>2.0 - 时间复杂度</p>
<p>接下来我们还需要知道另一个概念：时间频度。这个时候你可能会说：“不是说好一起学算法吗，这些东东是什么？赠品吗？”。非也非也，这是非卖品。</p>
<p>因为一个算法执行所消耗的时间理论上是不能算出来的，没错正是理论上，so我们任然可以在程序中测试获得。但是我们不可能又没必要对每个算法进行测试，只需要知道大概的哪个算法执行所花费的时间多，哪个花费的时间少就行了。如果一个算法所花费的时间与算法中代码语句执行次数成正比，那么那个算法执行语句越多，它的花费时间也就越多。我们把一个算法中的语句执行次数称为时间频度。通常（ps:很想知道通常是谁）用<code>T(n)</code>表示。</p>
<p>在时间频度<code>T(n)</code>中，n又代表着问题的规模，当n不断变化时，<code>T(n)</code>也会不断地随之变化。为了了解这个变化的规律，时间复杂度这一概念就被引入了。一般情况下算法基础本操作的重复执行次数为问题规模n的某个函数，用也就是时间频度<code>T(n)</code>。如果有某个辅助函数<code>f(n)</code>，当趋于无穷大的时候，<code>T(n)/f(n)</code>的极限值是不为零的某个常数，那么<code>f(n)</code>是<code>T(n)</code>的同数量级函数，记作<code>T(n)=O(f(n))</code>，被称为算法的渐进时间复杂度，又简称为时间复杂度。</p>
<p>2.1 - 大O表示法</p>
<p>用O(n)来体现算法时间复杂度的记法被称作大O表示法</p>
<p>一般我们我们评估一个算法都是直接评估它的最坏的复杂度。</p>
<p>大O表示法<code>O(f(n))</code>中的<code>f(n)</code>的值可以为1、n、logn、n^2 等，所以我们将O(1)、O(n)、O(logn)、O( n^2 )分别称为常数阶、线性阶、对数阶和平方阶。下面我们来看看推导大O阶的方法：</p>
<p>推导大O阶</p>
<p>推导大O阶有一下三种规则：</p>
<ol>
<li>用常数1取代运行时间中的所有加法常数</li>
<li>只保留最高阶项</li>
<li>去除最高阶的常数</li>
</ol>
<p>举好多栗子</p>
<ul>
<li><p>常数阶</p>
<p>  let sum = 0, n = 10; // 语句执行一次<br>  let sum = (1+n)*n/2; // 语句执行一次<br>  console.log(<code>The sum is : ${sum}</code>) //语句执行一次 </p>
</li>
</ul>
<p>这样的一段代码它的执行次数为 3 ，然后我们套用规则1，则这个算法的时间复杂度为O(1)，也就是常数阶。</p>
<ul>
<li><p>线性阶</p>
<p>  let i =0; // 语句执行一次<br>  while (i &lt; n) { // 语句执行n次 </p>
<pre><code>console.log(`Current i is ${i}`); //语句执行n次
i++; // 语句执行n次
</code></pre><p>  }</p>
</li>
</ul>
<p>这个算法中代码总共执行了 3n + 1次，根据规则 2-&gt;3，因此该算法的时间复杂度是O(n)。</p>
<ul>
<li><p>对数阶</p>
<p>  let number = 1; // 语句执行一次<br>  while (number &lt; n) { // 语句执行logn次</p>
<pre><code>number *= 2; // 语句执行logn次
</code></pre><p>  }</p>
</li>
</ul>
<p>上面的算法中，number每次都放大两倍，我们假设这个循环体执行了m次，那么<code>2^m = n</code>即<code>m = logn</code>，所以整段代码执行次数为1 + 2*logn，则<code>f(n) = logn</code>，时间复杂度为O(logn)。</p>
<ul>
<li><p>平方阶</p>
<p>  for (let i = 0; i &lt; n; i++) { // 语句执行n次 </p>
<pre><code>for (let j = 0; j &lt; n; j++) { // 语句执行n^2次 
   console.log(&apos;I am here!&apos;); // 语句执行n^2
}
</code></pre><p>  }</p>
</li>
</ul>
<p>上面的嵌套循环中，代码共执行 2*n^2 + n，则<code>f(n) = n^2</code>。所以该算法的时间复杂度为O(n^2 )</p>
<p>常见时间复杂度的比较</p>
<p>常见的时间复杂度函数相信大家在大学中都已经见过了，这里也不多做解释了：</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/04/100-100的-canvas-占多少内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/04/100-100的-canvas-占多少内存/" itemprop="url">100*100的 canvas 占多少内存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-04T18:55:12+08:00">
                2017-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>100*100的 canvas 占多少内存？</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实真正的答案是多少我并不清楚，面试过程中面试官也不期待一个准确的答案，而是看你的思考过程。</p>
<p>如果了解过 Canvas 且做过滤镜相关的工作，可能调用过 <code>imageData = ctx.getImageData(sx, sy, sw, sh);</code> 这个 API。我记得这个 API 返回的是一个 ImageData 数组，包含了 sx, sy, sw, sh 表示的矩形的像素数据。</p>
<p>而且这个数组是 Uint8 类型的，且四位表示一个像素。</p>
<p>我在面试的时候只能想起来这些信息。猜想一下，我们在定义颜色的时候就是使用 rgba(r,g,b,a) 四个维度来表示，而且每个像素值就是用十六位 00-ff 表示，即每个维度的范围是 0~255，即 2^8 位，即 1 byte, 也就是 Uint8 能表示的范围。</p>
<font color="#ff0000"><strong> 所以 100 <em> 100 canvas 占的内存是 100 </em> 100 * 4 bytes = 40,000 bytes。</strong></font>

<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>这里的答案并不一定准确。</p>
<h2 id="关于-alpha-的争论"><a href="#关于-alpha-的争论" class="headerlink" title="关于 alpha 的争论"></a>关于 alpha 的争论</h2><p>有同学指出，alpha 不是 0-100 么？我起初也有这样的疑问，不过这篇文章中 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FCanvas_API%2FTutorial%2FPixel_manipulation_with_canvas" target="_blank" rel="noopener">developer.mozilla.org/en-US/docs/…</a> 说</p>
<blockquote>
<p>The data property returns a Uint8ClampedArray which can be accessed to look at the raw pixel data; each pixel is represented by four one-byte values (red, green, blue, and alpha, in that order; that is, “RGBA” format). Each color component is represented by an integer between 0 and 255.</p>
</blockquote>
<p>也就是说即便是 alpha 也是 0-255</p>
<p>那么如何表示 alpha 呢？</p>
<p>接下来这段代码中<br><img src="/2017/06/04/100-100的-canvas-占多少内存/166de139a0bb874e.webp" alt=""><br>可以看出，只需要用 0-255 表示 0-100 就可以啦~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/实现一个-Virtual-DOM-算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/01/实现一个-Virtual-DOM-算法/" itemprop="url">实现一个 Virtual DOM 算法[转]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T20:04:50+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="virtual-dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。"><a href="#virtual-dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。" class="headerlink" title=" virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。"></a><font color="#dd0000"><strong> virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。</strong></font></h2><h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><ul>
<li>1 前言</li>
<li>2 对前端应用状态管理思考</li>
<li>3 Virtual DOM 算法</li>
<li>4 算法实现<ul>
<li>4.1 步骤一：用JS对象模拟DOM树</li>
<li>4.2 步骤二：比较两棵虚拟DOM树的差异</li>
<li>4.3 步骤三：把差异应用到真正的DOM树上</li>
</ul>
</li>
<li>5 结语</li>
<li>6 References</li>
</ul>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。</p>
<h2 id="2-对前端应用状态管理的思考"><a href="#2-对前端应用状态管理的思考" class="headerlink" title="2 对前端应用状态管理的思考"></a>2 对前端应用状态管理的思考</h2><p>假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。<br> <img src="/2017/05/01/实现一个-Virtual-DOM-算法/1.png" alt=""><br>这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sortKey = &quot;new&quot; // 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数</span><br><span class="line">var sortType = 1 // 升序还是逆序</span><br><span class="line">var data = [&#123;...&#125;, &#123;...&#125;, &#123;..&#125;, ..] // 表格数据</span><br></pre></td></tr></table></figure></p>
<p>用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。</p>
<p>这样做会导致的后果就是，随着应用程序越来越复杂，需要在JS里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的DOM操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是DOM操作），你需要操作的DOM还是需要操作，只是换了个地方。</p>
<p>既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看<a href="https://github.com/livoras/blog/issues/11" target="_blank" rel="noopener">这篇介绍</a>）。</p>
<p>MVVM 可以很好的降低我们维护状态 -&gt; 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染<strong>整个视图</strong>，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在JS里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下<code>innerHTML</code>就完事了。</p>
<p>听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，<code>input</code>和<code>textarea</code>的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（Backbone就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。</p>
<p><strong>但是这里要明白和记住这种做法</strong>，因为后面你会发现，<strong>其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更</strong>。</p>
<p>另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：<strong>维护状态，更新视图</strong>。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。</p>
<h2 id="3-Virtual-DOM算法"><a href="#3-Virtual-DOM算法" class="headerlink" title="3 Virtual DOM算法"></a>3 Virtual DOM算法</h2><p>DOM是很慢的。如果我们把一个简单的<code>div</code>元素的属性都打印出来，你会看到：<br> <img src="/2017/05/01/实现一个-Virtual-DOM-算法/2.png" alt=""><br>而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。</p>
<p>相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var element = &#123;</span><br><span class="line">  tagName:&apos;ul&apos;, // 节点标签名</span><br><span class="line">  props: &#123; // DOM的属性，用一个对象存储键值对</span><br><span class="line">    id:&apos;list&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ // 该节点的子节点</span><br><span class="line">    &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 1&quot;]&#125;,</span><br><span class="line">    &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 2&quot;]&#125;,</span><br><span class="line">    &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 3&quot;]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面对应的HTML写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ulid=&apos;list&apos;&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。</p>
<p>之前的章节所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。</p>
<p>但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。</p>
<p>这就是所谓的 Virtual DOM 算法。包括几个步骤：</p>
<ol>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了</li>
</ol>
<p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p>
<h2 id="4-算法实现"><a href="#4-算法实现" class="headerlink" title="4 算法实现"></a>4 算法实现</h2><h3 id="4-1-步骤一：用JS对象模拟DOM树"><a href="#4-1-步骤一：用JS对象模拟DOM树" class="headerlink" title="4.1 步骤一：用JS对象模拟DOM树"></a>4.1 步骤一：用JS对象模拟DOM树</h3><p>用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点：</p>
<p>element.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functionElement (tagName, props, children) &#123;</span><br><span class="line">  this.tagName= tagName</span><br><span class="line">  this.props= props</span><br><span class="line">  this.children= children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports=function (tagName, props, children) &#123;</span><br><span class="line">  returnnewElement(tagName, props, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如上面的 DOM 结构就可以简单的表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var el =require(&apos;./element&apos;)</span><br><span class="line"></span><br><span class="line">var ul =el(&apos;ul&apos;, &#123;id:&apos;list&apos;&#125;, [</span><br><span class="line">  el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 1&apos;]),</span><br><span class="line">  el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 2&apos;]),</span><br><span class="line">  el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 3&apos;])</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p>
<p>现在<code>ul</code>只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个<code>ul</code>构建真正的<code>&lt;ul&gt;</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.render=function () &#123;</span><br><span class="line">  var el =document.createElement(this.tagName) // 根据tagName构建var props =this.propsfor (var propName in props) &#123; // 设置节点的DOM属性var propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var children =this.children|| []</span><br><span class="line"></span><br><span class="line">  children.forEach(function (child) &#123;</span><br><span class="line">    var childEl = (child instanceofElement)</span><br><span class="line">      ?child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点:document.createTextNode(child) // 如果字符串，只构建文本节点el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>render</code>方法会根据<code>tagName</code>构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ulRoot =ul.render()</span><br><span class="line">document.body.appendChild(ulRoot)</span><br></pre></td></tr></table></figure></p>
<p>上面的<code>ulRoot</code>是真正的DOM节点，把它塞入文档中，这样<code>body</code>里面就有了真正的<code>&lt;ul&gt;</code>的DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ulid=&apos;list&apos;&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>
<p>完整代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/element.js" target="_blank" rel="noopener">element.js</a>。</p>
<h3 id="4-2-步骤二：比较两棵虚拟DOM树的差异"><a href="#4-2-步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="4.2 步骤二：比较两棵虚拟DOM树的差异"></a>4.2 步骤二：比较两棵虚拟DOM树的差异</h3><p>正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：<br> <img src="/2017/05/01/实现一个-Virtual-DOM-算法/3.png" alt=""><br>上面的<code>div</code>只会和同一层级的<code>div</code>对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p>
<h4 id="4-2-1-深度优先遍历，记录差异"><a href="#4-2-1-深度优先遍历，记录差异" class="headerlink" title="4.2.1 深度优先遍历，记录差异"></a>4.2.1 深度优先遍历，记录差异</h4><p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p>
<p> <img src="/2017/05/01/实现一个-Virtual-DOM-算法/4.png" alt=""></p>
<p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// diff 函数，对比两棵树functiondiff (oldTree, newTree) &#123;</span><br><span class="line">  var index =0// 当前节点的标志var patches = &#123;&#125; // 用来记录每个节点差异的对象dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  return patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对两棵树进行深度优先遍历functiondfsWalk (oldNode, newNode, index, patches) &#123;</span><br><span class="line">  // 对比oldNode和newNode的不同，记录下来</span><br><span class="line">  patches[index] = [...]</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历子节点functiondiffChildren (oldChildren, newChildren, index, patches) &#123;</span><br><span class="line">  var leftNode =nullvar currentNodeIndex = index</span><br><span class="line">  oldChildren.forEach(function (child, i) &#123;</span><br><span class="line">    var newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp;leftNode.count) // 计算节点的标识? currentNodeIndex +leftNode.count+1: currentNodeIndex +1dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点</span><br><span class="line">    leftNode = child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如，上面的<code>div</code>和新的<code>div</code>有差异，当前的标记是0，那么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同</span><br></pre></td></tr></table></figure></p>
<p>同理<code>p</code>是<code>patches[1]</code>，<code>ul</code>是<code>patches[3]</code>，类推。</p>
<h4 id="4-2-2-差异类型"><a href="#4-2-2-差异类型" class="headerlink" title="4.2.2 差异类型"></a>4.2.2 差异类型</h4><p>上面说的节点的差异指的是什么呢？对 DOM 操作可能会：</p>
<ol>
<li>替换掉原来的节点，例如把上面的<code>div</code>换成了<code>section</code></li>
<li>移动、删除、新增子节点，例如上面<code>div</code>的子节点，把<code>p</code>和<code>ul</code>顺序互换</li>
<li>修改了节点的属性</li>
<li>对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为<code>Virtual DOM 2</code>。</li>
</ol>
<p>所以我们定义了几种差异类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var REPLACE = 0</span><br><span class="line">var REORDER = 1</span><br><span class="line">var PROPS = 2</span><br><span class="line">var TEXT = 3</span><br></pre></td></tr></table></figure></p>
<p>对于节点替换，很简单。判断新旧节点的<code>tagName</code>和是不是一样的，如果不一样的说明需要替换掉。如<code>div</code>换成<code>section</code>，就记录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">  type:REPALCE,</span><br><span class="line">  node: newNode // el(&apos;section&apos;, props, children)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<p>如果给<code>div</code>新增了属性<code>id</code>为<code>container</code>，就记录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">  type:REPALCE,</span><br><span class="line">  node: newNode // el(&apos;section&apos;, props, children)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  type:PROPS,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id:&quot;container&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<p>如果是文本节点，如上面的文本节点2，就记录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[2] = [&#123;</span><br><span class="line">  type:TEXT,</span><br><span class="line">  content:&quot;Virtual DOM2&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<p>那如果把我<code>div</code>的子节点重新排序呢？例如<code>p, ul, div</code>的顺序换成了<code>div, p, ul</code>。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如<code>p</code>和<code>div</code>的<code>tagName</code>不同，<code>p</code>会被<code>div</code>所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。</p>
<p>这牵涉到两个列表的对比算法，需要另外起一个小节来讨论。</p>
<h4 id="4-2-3-列表对比算法"><a href="#4-2-3-列表对比算法" class="headerlink" title="4.2.3 列表对比算法"></a>4.2.3 列表对比算法</h4><p>假设现在可以英文字母唯一地标识每一个子节点：<br>旧的节点顺序：</p>
<pre><code>a b c d e f g h i
</code></pre><p>现在对节点进行了删除、插入、移动的操作。新增<code>j</code>节点，删除<code>e</code>节点，移动<code>h</code>节点：<br>新的节点顺序：</p>
<pre><code>a b c h d f g i j
</code></pre><p>现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="noopener">Edition Distance</a>），最常见的解决算法是 <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank" rel="noopener">Levenshtein Distance</a>，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考<a href="https://github.com/livoras/list-diff/blob/master/lib/diff.js" target="_blank" rel="noopener">代码</a>。</p>
<p>我们能够获取到某个父节点的子节点的操作，就可以记录下来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">  type:REORDER,</span><br><span class="line">  moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p>
<p>但是要注意的是，因为<code>tagName</code>是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识<code>key</code>，列表对比的时候，使用<code>key</code>进行对比，这样才能复用老的 DOM 树上的节点。</p>
<p>这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js" target="_blank" rel="noopener">diff.js</a>。</p>
<h3 id="4-3-步骤三：把差异应用到真正的DOM树上"><a href="#4-3-步骤三：把差异应用到真正的DOM树上" class="headerlink" title="4.3 步骤三：把差异应用到真正的DOM树上"></a>4.3 步骤三：把差异应用到真正的DOM树上</h3><p>因为步骤一所构建的 JavaScript 对象树和<code>render</code>出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的<code>patches</code>对象中找出当前遍历的节点差异，然后进行 DOM 操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">functionpatch (node, patches) &#123;</span><br><span class="line">  var walker = &#123;index:0&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functiondfsWalk (node, walker, patches) &#123;</span><br><span class="line">  var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异var len =node.childNodes?node.childNodes.length:0for (var i =0; i &lt; len; i++) &#123; // 深度遍历子节点var child =node.childNodes[i]</span><br><span class="line">    walker.index++dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches) // 对当前节点进行DOM操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">functionapplyPatches (node, currentPatches) &#123;</span><br><span class="line">  currentPatches.forEach(function (currentPatch) &#123;</span><br><span class="line">    switch (currentPatch.type) &#123;</span><br><span class="line">      caseREPLACE:</span><br><span class="line">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">        breakcaseREORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        breakcasePROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        breakcaseTEXT:</span><br><span class="line">        node.textContent=currentPatch.contentbreakdefault:</span><br><span class="line">        thrownewError(&apos;Unknown patch type &apos;+currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js" target="_blank" rel="noopener">patch.js</a>。</p>
<h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5 结语"></a>5 结语</h2><p>Virtual DOM 算法主要是实现上面步骤的三个函数：<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/element.js" target="_blank" rel="noopener">element</a>，<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js" target="_blank" rel="noopener">diff</a>，<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js" target="_blank" rel="noopener">patch</a>。然后就可以实际的进行使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建虚拟DOM</span><br><span class="line">var tree =el(&apos;div&apos;, &#123;&apos;id&apos;:&apos;container&apos;&#125;, [</span><br><span class="line">    el(&apos;h1&apos;, &#123;style:&apos;color: blue&apos;&#125;, [&apos;simple virtal dom&apos;]),</span><br><span class="line">    el(&apos;p&apos;, [&apos;Hello, virtual-dom&apos;]),</span><br><span class="line">    el(&apos;ul&apos;, [el(&apos;li&apos;)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class="line">var root =tree.render()</span><br><span class="line">document.body.appendChild(root)</span><br><span class="line"></span><br><span class="line">// 3. 生成新的虚拟DOMvar newTree =el(&apos;div&apos;, &#123;&apos;id&apos;:&apos;container&apos;&#125;, [</span><br><span class="line">    el(&apos;h1&apos;, &#123;style:&apos;color: red&apos;&#125;, [&apos;simple virtal dom&apos;]),</span><br><span class="line">    el(&apos;p&apos;, [&apos;Hello, virtual-dom&apos;]),</span><br><span class="line">    el(&apos;ul&apos;, [el(&apos;li&apos;), el(&apos;li&apos;)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 4. 比较两棵虚拟DOM树的不同</span><br><span class="line">var patches =diff(tree, newTree)</span><br><span class="line"></span><br><span class="line">// 5. 在真正的DOM元素上应用变更</span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure></p>
<p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。</p>
<p>本文所实现的完整代码存放在 <a href="https://github.com/livoras/simple-virtual-dom" target="_blank" rel="noopener">Github</a>，仅供学习。</p>
<p>本文所实现的完整代码存放在 <a href="https://github.com/livoras/simple-virtual-dom" target="_blank" rel="noopener">Github</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/18/简化版的vue-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/18/简化版的vue-router/" itemprop="url">简化版的vue-router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-18T15:12:24+08:00">
                2017-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文旨在介绍<code>vue-router</code>的实现思路，并动手实现一个简化版的<code>vue-router</code>。<br>我们先来看一下一般项目中对<code>vue-router</code>最基本的一个使用，可以看到，这里定义了四个路由组件,我们只要在根<code>vue</code>实例中注入该<code>router</code>对象就可以使用了.</p>
<pre><code>import VueRouter from&apos;vue-router&apos;;
import Home from&apos;@/components/Home&apos;;
import A from&apos;@/components/A&apos;;
import B from&apos;@/components/B&apos;import C from&apos;@/components/C&apos;

Vue.use(VueRouter)

export default new VueRouter.Router({
  // mode: &apos;history&apos;,
  routes: [
    {
      path: &apos;/&apos;,
      component: Home
    },
    {
      path: &apos;/a&apos;,
      component: A
    },
    {
      path: &apos;/b&apos;,
      component: B
    },
    {
      path: &apos;/c&apos;,
      component: C
    }
  ]
})
</code></pre><p><code>vue-router</code>提供两个全局组件，<code>router-view</code>和<code>router-link</code>，前者是用于路由组件的占位，后者用于点击时跳转到指定路由。此外组件内部可以通过<code>this.$router.push</code>,<code>this.$rouer.replace</code>等api实现路由跳转。本文将实现上述两个全局组件以及<code>push</code>和<code>replace</code>两个api，调用的时候支持<code>params</code>传参，并且支持<code>hash</code>和<code>history</code>两种模式，忽略其余api、嵌套路由、异步路由、<code>abstract</code>路由以及导航守卫等高级功能的实现，这样有助于理解<code>vue-router</code>的核心原理。本文的最终代码不建议在生产环境使用，只做一个学习用途，下面我们就来一步步实现它。</p>
<h3 id="install实现"><a href="#install实现" class="headerlink" title="install实现"></a>install实现</h3><p>任何一个<code>vue</code>插件都要实现一个<code>install</code>方法，通过<code>Vue.use</code>调用插件的时候就是在调用插件的<code>install</code>方法，那么路由的<code>install</code>要做哪些事情呢？首先我们知道 我们会用<code>new</code>关键字生成一个<code>router</code>实例，就像前面的代码实例一样，然后将其挂载到根<code>vue</code>实例上，那么作为一个全局路由，我们当然需要在各个组件中都可以拿到这个<code>router</code>实例。另外我们使用了全局组件<code>router-view</code>和<code>router-link</code>，由于<code>install</code>会接收到<code>Vue</code>构造函数作为实参，方便我们调用<code>Vue.component</code>来注册全局组件。因此，在<code>install</code>中主要就做两件事，给各个组件都挂载<code>router</code>实例，以及实现<code>router-view</code>和<code>router-link</code>两个全局组件。下面是代码：</p>
<pre><code>const install = (Vue) =&gt; {

  if (this._Vue) {
    return;
  };
  Vue.mixin({
    beforeCreate() {
      if (this.$options &amp;&amp; this.$options.router) {
        this._routerRoot = this;
        this._router = this.$options.router;
        Vue.util.defineReactive(this, &apos;_routeHistory&apos;, this._router.history)
      } else {
        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this
      }

      Object.defineProperty(this, &apos;$router&apos;, {
        get() {
          returnthis._routerRoot._router;
        }
      })

      Object.defineProperty(this, &apos;$route&apos;, {
        get() {
          return {
            current: this._routerRoot._routeHistory.current,
            ...this._routerRoot._router.route
          };
        }
      })
    }
  });

  Vue.component(&apos;router-view&apos;, {
    render(h) { ... }
  })

  Vue.component(&apos;router-link&apos;, {    
    props: {
      to: String,
      tag: String,
    },
    render(h) { ... }
  })
  this._Vue = Vue;
}
</code></pre><p>这里的<code>this</code>代表的就是<code>vue-router</code>对象，它有两个属性暴露出来供外界调用，一个是<code>install</code>，一个是<code>Router</code>构造函数，这样可以保证插件的正确安装以及路由实例化。我们先忽略<code>Router</code>构造函数，来看<code>install</code>，上面代码中的<code>this._Vue</code>是个开始没有定义的属性，他的目的是防止多次安装。我们使用<code>Vue.mixin</code>对每个组件的<code>beforeCreate</code>钩子做全局混入，目的是让每个组件实例共享<code>router</code>实例，即通过<code>this.$router</code>拿到路由实例，通过<code>this.$route</code>拿到路由状态。需要重点关注的是这行代码：</p>
<pre><code>Vue.util.defineReactive(this, &apos;_routeHistory&apos;, this._router.history)
</code></pre><p>这行代码利用<code>vue</code>的响应式原理，对根<code>vue</code>实例注册了一个<code>_routeHistory</code>属性，指向路由实例的<code>history</code>对象，这样<code>history</code>也变成了响应式的。因此一旦路由的<code>history</code>发生变化，用到这个值的组件就会触发<code>render</code>函数重新渲染，这里的组件就是<code>router-view</code>。从这里可以窥察到<code>vue-router</code>实现的一个基本思路。上述的代码中对于两个全局组件的<code>render</code>函数的实现，因为会依赖于<code>router</code>对象，我们先放一放，稍后再来实现它们，下面我们分析一下<code>Router</code>构造函数。</p>
<h3 id="Router构造函数"><a href="#Router构造函数" class="headerlink" title="Router构造函数"></a>Router构造函数</h3><p>经过刚才的分析，我们知道<code>router</code>实例需要有一个<code>history</code>对象，需要一个保存当前路由状态的对象<code>route</code>，另外很显然还需要接受路由配置表<code>routes</code>，根据<code>routes</code>需要一个路由映射表<code>routerMap</code>来实现组件搜索，还需要一个变量<code>mode</code>判断是什么模式下的路由，需要实现<code>push</code>和<code>replace</code>两个api，代码如下：</p>
<pre><code>const Router = function (options) {
  this.routes = options.routes; // 存放路由配置this.mode = options.mode || &apos;hash&apos;;
  this.route = Object.create(null), // 生成路由状态this.routerMap = createMap(this.routes) // 生成路由表this.history = new RouterHistory(); // 实例化路由历史对象this.init(); // 初始化
}

Router.prototype.push = (options) =&gt; { ... }

Router.prototype.replace = (options) =&gt; { ... }

Router.prototype.init = () =&gt; { ... }
</code></pre><p>我们看一下路由表<code>routerMap</code>的实现，由于不考虑嵌套等其他情况，实现很简单，如下：</p>
<pre><code>const createMap = (routes) =&gt; {
  let resMap = Object.create(null);
  routes.forEach(route =&gt; {
    resMap[route[&apos;path&apos;]] = route[&apos;component&apos;];
  })
  return resMap;
}
</code></pre><p><code>RouterHistory</code>的实现也很简单，根据前面分析，我们只需要一个<code>current</code>属性就可以，如下：</p>
<pre><code>const RouterHistory = function (mode) {
  this.current = null; 
}
</code></pre><p>有了路由表和<code>history</code>，<code>router-view</code>的实现就很容易了，如下：</p>
<pre><code>Vue.component(&apos;router-view&apos;, {
    render(h) {
      let routerMap = this._self.$router.routerMap;
      return h(routerMap[this._self.$route.current])
    }
  })
</code></pre><p>这里的<code>this</code>是一个<code>renderProxy</code>实例，他有一个属性<code>_self</code>可以拿到当前的组件实例，进而访问到<code>routerMap</code>，可以看到路由实例<code>history</code>的<code>current</code>本质上就是我们配置的路由表中的<code>path</code>。</p>
<p>接下来我们看一下<code>Router</code>要做哪些初始化工作。对于<code>hash</code>路由而言，url上<code>hash</code>值的改变不会引起页面刷新，但是可以触发一个<code>hashchange</code>事件。由于路由<code>history.current</code>初始为<code>null</code>，因此匹配不到任何一个路由，所以会导致页面刷新加载不出任何路由组件。基于这两点，在<code>init</code>方法中，我们需要实现对页面加载完成的监听，以及<code>hash</code>变化的监听。对于<code>history</code>路由，为了实现浏览器前进后退时准确渲染对应组件，还要监听一个<code>popstate</code>事件。代码如下:</p>
<pre><code>Router.prototype.init = function () {

  if (this.mode === &apos;hash&apos;) {
    fixHash()
    window.addEventListener(&apos;hashchange&apos;, () =&gt; {
      this.history.current = getHash();
    })
    window.addEventListener(&apos;load&apos;, () =&gt; {
      this.history.current = getHash();
    })
  }

  if (this.mode === &apos;history&apos;) {
    removeHash(this);
    window.addEventListener(&apos;load&apos;, () =&gt; {
      this.history.current = location.pathname;
    })
    window.addEventListener(&apos;popstate&apos;, (e) =&gt; {
      if (e.state) {
        this.history.current = e.state.path;
      }
    })
  }

}
</code></pre><p>当启用<code>hash</code>模式的时候，我们要检测url上是否存在<code>hash</code>值，没有的话强制赋值一个默认<code>path</code>，<code>hash</code>路由时会根据<code>hash</code>值作为<code>key</code>来查找路由表。<code>fixHash</code>和<code>getHash</code>实现如下：</p>
<pre><code>const fixHash = () =&gt; {
  if (!location.hash) {
    location.hash = &apos;/&apos;;
  }
}
const getHash = () =&gt; {
  return location.hash.slice(1) || &apos;/&apos;;
}
</code></pre><p>这样在刷新页面和<code>hash</code>改变的时候，<code>current</code>可以得到赋值和更新，页面能根据<code>hash</code>值准确渲染路由。<code>history</code>模式也是一样的道理，只是它通过<code>location.pathname</code>作为<code>key</code>搜索路由组件，另外<code>history</code>模式需要去除url上可能存在的<code>hash</code>,<code>removeHash</code>实现如下：</p>
<pre><code>const removeHash = (route) =&gt; {
  let url = location.href.split(&apos;#&apos;)[1]
  if (url) {
    route.current = url;
    history.replaceState({}, null, url)
  }
}
</code></pre><p>我们可以看到当浏览器后退的时候，<code>history</code>模式会触发<code>popstate</code>事件，这个时候是通过<code>state</code>状态去获取<code>path</code>的，那么<code>state</code>状态从哪里来呢，答案是从<code>window.history</code>对象的<code>pushState</code>和<code>replaceState</code>而来，这两个方法正好可以用来实现<code>router</code>的<code>push</code>方法和<code>replace</code>方法，我们看一下这里它们的实现：</p>
<pre><code>Router.prototype.push = (options) =&gt; {
  this.history.current = options.path;
  if (this.mode === &apos;history&apos;) {
    history.pushState({
      path: options.path
    }, null, options.path);
  } elseif (this.mode === &apos;hash&apos;) {
    location.hash = options.path;
  }
  this.route.params = {
    ...options.params
  }
}

Router.prototype.replace = (options) =&gt; {
  this.history.current = options.path;
  if (this.mode === &apos;history&apos;) {
    history.replaceState({
      path: options.path
    }, null, options.path);
  } elseif (this.mode === &apos;hash&apos;) {
    location.replace(`#${options.path}`)
  }
  this.route.params = {
    ...options.params
  }
}
</code></pre><p><code>pushState</code>和<code>replaceState</code>能够实现改变url的值但不引起页面刷新，从而不会导致新请求发生，<code>pushState</code>会生成一条历史记录而<code>replaceState</code>不会，后者只是替换当前url。在这两个方法执行的时候将<code>path</code>存入<code>state</code>，这就使得<code>popstate</code>触发的时候可以拿到路径从而触发组件渲染了。我们在组件内按照如下方式调用，会将<code>params</code>写入<code>router</code>实例的<code>route</code>属性中，从而在跳转后的组件<code>B</code>内通过<code>this.$route.params</code>可以访问到传参。</p>
<pre><code>this.$router.push({
    path: &apos;/b&apos;,
    params: {
      id: 55
    }
 });
</code></pre><h3 id="router-link实现"><a href="#router-link实现" class="headerlink" title="router-link实现"></a>router-link实现</h3><p><code>router-view</code>的实现很简单，前面已经说过。最后，我们来看一下<code>router-link</code>的实现,先放上代码：</p>
<pre><code>Vue.component(&apos;router-link&apos;, {    
    props: {
      to: String,
      tag: String,
    },

    render(h) {
      let mode = this._self.$router.mode;
      let tag = this.tag || &apos;a&apos;;
      let routerHistory = this._self.$router.history;
      return h(tag, {
        attrs: tag === &apos;a&apos; ? {
          href: mode === &apos;hash&apos; ? &apos;#&apos; + this.to : this.to,

        } : {},
        on: {
          click: (e) =&gt; {
            if (this.to === routerHistory.current) {
              e.preventDefault();
              return;
            }
            routerHistory.current = this.to;
            switch (mode) {
              case&apos;hash&apos;:
                if (tag === &apos;a&apos;) return;
                location.hash = this.to;
                break;
              case&apos;history&apos;:
                history.pushState({
                  path: this.to
                }, null, this.to);
                break;
              default:
            }
            e.preventDefault();
          }
        },
        style: {
          cursor: &apos;pointer&apos;
        }
      }, this.$slots.default)
    }
  })
</code></pre><p><code>router-link</code>可以接受两个属性，<code>to</code>表示要跳转的路由路径，<code>tag</code>表示<code>router-link</code>要渲染的标签名，默认<code>a</code>为标签。如果是<code>a</code>标签，我们为其添加一个<code>href</code>属性。我们给标签绑定<code>click</code>事件，如果检测到本次跳转为当前路由的话什么都不做直接返回，并且阻止默认行为，否则根据<code>to</code>更换路由。<code>hash</code>模式下并且是<code>a</code>标签时候可以直接利用浏览器的默认行为完成url上<code>hash</code>的替换，否者重新为<code>location.hash</code>赋值。<code>history</code>模式下则利用<code>pushState</code>去更新url。</p>
<p>以上实现就是一个简单的vue-router.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">107</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


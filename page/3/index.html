<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/Event-Loop-必知必会（六道题）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/Event-Loop-必知必会（六道题）/" itemprop="url">Event Loop 必知必会（六道题）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T11:48:09+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直想写一篇关于 Event Loop 的文章，前不久发现 CNode 上有位同学写了一篇原理分析的<a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/5a9108d78d6e16e56bb80882%235a98d9a2ce1c90bc44c445af" target="_blank" rel="noopener">文章</a>很详细，这里我就不献丑了。本文就拿出六道题来补充一下，放出一张我认为非常直观的图。<br><img src="https://pic4.zhimg.com/v2-3a59c624e6ff95a7e8c5a23c979f5abe_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3a59c624e6ff95a7e8c5a23c979f5abe_hd.jpg" alt=""><br>绿色小块是 macrotask（宏任务），macrotask 中间的粉红箭头是 microtask（微任务）。</p>
<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><pre><code>setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate
setTimeout
</code></pre><p>或者：</p>
<pre><code>setTimeout
setImmediate
</code></pre><p>为什么结果不确定呢？</p>
<p>解释：setTimeout/setInterval 的第二个参数取值范围是：[1, 2^31 - 1]，如果超过这个范围则会初始化为 1，即 setTimeout(fn, 0) === setTimeout(fn, 1)。我们知道 setTimeout 的回调函数在 timer 阶段执行，setImmediate 的回调函数在 check 阶段执行，event loop 的开始会先检查 timer 阶段，但是在开始之前到 timer 阶段会消耗一定时间，所以就会出现两种情况：</p>
<ol>
<li>timer 前的准备时间超过 1ms，满足  loop-&gt;time &gt;= 1，则执行 timer 阶段（setTimeout）的回调函数</li>
<li>timer 前的准备时间小于 1ms，则先执行 check 阶段（setImmediate）的回调函数，下一次 event loop 执行 timer 阶段（setTimeout）的回调函数</li>
</ol>
<p>再看个例子：</p>
<pre><code>setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})conststart=Date.now()while(Date.now()-start&lt;10);
</code></pre><p>运行结果一定是：</p>
<pre><code>setTimeout
setImmediate
</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><pre><code>constfs=require(&apos;fs&apos;)fs.readFile(__filename,()=&gt;{setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate
setTimeout
</code></pre><p>解释：fs.readFile 的回调函数执行完后：</p>
<ol>
<li>注册 setTimeout 的回调函数到 timer 阶段</li>
<li>注册 setImmediate 的回调函数到 check 阶段</li>
<li>event loop 从 pool 阶段出来继续往下一个阶段执行，恰好是 check 阶段，所以 setImmediate 的回调函数先执行</li>
<li>本次 event loop 结束后，进入下一次 event loop，执行 setTimeout 的回调函数</li>
</ol>
<p>所以，在 I/O Callbacks 中注册的 setTimeout 和 setImmediate，永远都是 setImmediate 先执行。</p>
<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><pre><code>setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)process.nextTick(functiontick(){process.nextTick(tick)})
</code></pre><p>运行结果：setInterval 永远不会打印出来。</p>
<p>解释：process.nextTick 会无限循环，将 event loop 阻塞在 microtask 阶段，导致 event loop 上其他 macrotask 阶段的回调函数没有机会执行。</p>
<p>解决方法通常是用 setImmediate 替代 process.nextTick，如下：</p>
<pre><code>setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)setImmediate(functionimmediate(){setImmediate(immediate)})
</code></pre><p>运行结果：每 100ms 打印一次 setInterval。</p>
<p>解释：process.nextTick 内执行 process.nextTick 仍然将 tick 函数注册到当前 microtask 的尾部，所以导致 microtask 永远执行不完； setImmediate 内执行 setImmediate 会将 immediate 函数注册到下一次 event loop 的 check 阶段，而不是当前正在执行的 check 阶段，所以给了 event loop 上其他 macrotask 执行的机会。</p>
<p>再看个例子：</p>
<pre><code>setImmediate(()=&gt;{console.log(&apos;setImmediate1&apos;)setImmediate(()=&gt;{console.log(&apos;setImmediate2&apos;)})process.nextTick(()=&gt;{console.log(&apos;nextTick&apos;)})})setImmediate(()=&gt;{console.log(&apos;setImmediate3&apos;)})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate1
setImmediate3
nextTick
setImmediate2
</code></pre><p>注意：并不是说 setImmediate 可以完全替代 process.nextTick，process.nextTick 在特定场景下还是无法被替代的，比如我们就想将一些操作放到最近的 microtask 里执行。</p>
<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><pre><code>constpromise=Promise.resolve().then(()=&gt;{returnpromise})promise.catch(console.error)
</code></pre><p>运行结果：</p>
<pre><code>TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
    at &lt;anonymous&gt;
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3
</code></pre><p>解释：promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码会导致死循环，类似前面提到的：</p>
<pre><code>process.nextTick(functiontick(){process.nextTick(tick)})
</code></pre><p>再看个例子：</p>
<pre><code>constpromise=Promise.resolve()
promise.then(()=&gt;{
  console.log(&apos;promise&apos;)})
  process.nextTick(()=&gt;{
      console.log(&apos;nextTick&apos;)
  })
</code></pre><p>运行结果：</p>
<pre><code>nextTick
promise
</code></pre><p>解释：promise.then 虽然和 process.nextTick 一样，都将回调函数注册到 microtask，但优先级不一样。process.nextTick 的 microtask queue 总是优先于 promise 的 microtask queue 执行。</p>
<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><pre><code>setTimeout(()=&gt;{
    console.log(1)
},0)
newPromise((resolve,reject)=&gt;{
   console.log(2)
   for(leti=0;i&lt;10000;i++){
     i===9999&amp;&amp;resolve()
   }
   console.log(3)
}).then(()=&gt;{
   console.log(4)
})
console.log(5)
</code></pre><p>运行结果：</p>
<p>解释：Promise 构造函数是同步执行的，所以先打印 2、3，然后打印 5，接下来 event loop 进入执行 microtask 阶段，执行 promise.then 的回调函数打印出 4，然后执行下一个 macrotask，恰好是 timer 阶段的 setTimeout 的回调函数，打印出 1。</p>
<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><pre><code>setImmediate(()=&gt;{
    console.log(1)
    setTimeout(()=&gt;{
       console.log(2)
    },100)
    setImmediate(()=&gt;{
       console.log(3)
    })
    process.nextTick(
       ()=&gt;{console.log(4)})
     })
     process.nextTick(()=&gt;{
       console.log(5)
       setTimeout(()=&gt;{
        console.log(6)},100)
        setImmediate(()=&gt;{
        console.log(7)})
        process.nextTick(
        ()=&gt;{console.log(8)})
        })console.log(9)
</code></pre><p>运行结果：</p>
<p>process.nextTick、setTimeout 和 setImmediate 的组合，请读者自己推理吧。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c" target="_blank" rel="noopener">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">https://cnodejs.org/topic/57d68794cb6f605d360105bf</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/你不知道的-Promise-对象黑科技/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/你不知道的-Promise-对象黑科技/" itemprop="url">你不知道的 Promise 对象黑科技</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T11:10:58+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Promise-必知必会（十道题）"><a href="#Promise-必知必会（十道题）" class="headerlink" title="Promise 必知必会（十道题）"></a><a href="https://libin1991.github.io/2018/09/25/Promise-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></h2><h2 id="一、resolve-后的执行情况"><a href="#一、resolve-后的执行情况" class="headerlink" title="一、resolve 后的执行情况"></a>一、resolve 后的执行情况</h2><p>无论是 resolve, reject，都会将函数剩余的代码执行完</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
    console.log(&apos;mark 1&apos;);
    resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);
    console.log(&apos;mark 2&apos;);
});

promise.then(result =&gt; {
    console.log(result);
}).catch(err =&gt; {
    console.log(err);
});
</code></pre><p>相当于：</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
    console.log(&apos;mark 1&apos;);
    console.log(&apos;mark 2&apos;);
    resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);
});

promise.then(result =&gt; {
    console.log(result);
}).catch(err =&gt; {
    console.log(err);
});
</code></pre><p>如果你不想在 resolve 或 reject 后执行剩下的代码段，可以在 resolve 后将其返回<br><img src="https://pic4.zhimg.com/v2-f5b865c8a9df8ce752d057fe177c855e_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-f5b865c8a9df8ce752d057fe177c855e_hd.jpg" alt=""></p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; {
    console.log(&apos;mark 1&apos;);
    return resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);
    console.log(&apos;mark 2&apos;);             // never be here
});

promise.then(result =&gt; {
    console.log(result);
}).catch(err =&gt; {
    console.log(err);
});
</code></pre><h2 id="二、串行执行和并行执行："><a href="#二、串行执行和并行执行：" class="headerlink" title="二、串行执行和并行执行："></a>二、串行执行和并行执行：</h2><ol>
<li>串行执行：有一堆 Promise 对象，它们的执行顺序是固定的，前一个 promise 执行完后，后一个 promise 才开始执行，比如数据库查询，它们往往有前后的因果关系。</li>
<li>并行执行：有一堆 Promise 对象，它们的执行顺序是不固定的，没有前后因果关系，可以并发地去执行。</li>
</ol>
<p>并行执行很好解决，在 Promise中有 all 这个函数支持, Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。当多个 Promise 实例执行完后才去执行最后新的 Promise 实例。</p>
<pre><code>const datum = [];
for(let i = 0; i &lt; 10; i++) {
    datum.push(i);
}

Promise.all(datum.map(i =&gt; {
    return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        console.log(i * 200 + &quot; ms 后执行结束&quot;);
        resolve(&quot;第 &quot; + (i + 1) + &quot; 个 Promise 执行结束&quot;);
    }, i * 200);
    })
})).then((data) =&gt; {
    console.log(data);
});
</code></pre><p>如果不使用 Promise.all 这个方法的话，你也可以使用像 ES7 的 async/await</p>
<pre><code>const asyncFun = async () =&gt; {
    const datum = []
    for(let i = 0; i &lt; 10; i++) {
        datum.push(new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
                console.log(i * 200 + &apos;ms 后执行结束&apos;)
                resolve(&apos;第 &apos; + (i + 1) + &apos; 个 Promise 执行结束&apos;)
            }, i * 200)
        }))
    }
    const result = []
    for(let promise of datum) {
        result.push(await promise)
    }
    console.log(result)
}
asyncFun()
</code></pre><p>串行执行：这里提供两种方式</p>
<pre><code>const datum = [];
for(let i = 0; i &lt; 10; i++) {
    datum.push(i);
}

let serial = Promise.resolve();

for(let i of datum) {
    serial = serial.then(data =&gt; {
        console.log(data);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
        console.log(i * 200 + &quot; ms 后执行结束&quot;);
        resolve(&quot;第 &quot; + (i + 1) + &quot; 个 Promise 执行结束&quot;);
        }, i * 200);
    })    
    });
}
</code></pre><p>另外可以使用 reduce 来串行：</p>
<pre><code>const datum = [];
for(let i = 0; i &lt; 10; i++) {
    datum.push(i);
}

datum.reduce((prev, cur) =&gt; {
    return prev.then(data =&gt; {
    console.log(data);
    return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
        console.log(cur * 200 + &quot; ms 后执行结束&quot;);
        resolve(&quot;第 &quot; + (cur + 1) + &quot; 个 Promise 执行结束&quot;);
        }, cur * 200);
    })    
    })
}, Promise.resolve(true));
</code></pre><h2 id="三、值穿透问题："><a href="#三、值穿透问题：" class="headerlink" title="三、值穿透问题："></a>三、值穿透问题：</h2><pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&apos;Hello World!&apos;);
    }, 1000)
});

promise.then(&apos;呵呵哒&apos;).then((data) =&gt; {
    console.log(data);           // Hello World
})
</code></pre><p>这是一种值穿透的情况，一般有下面两种情况：<br>promise 已经是 FULFILLED/REJECTED 时，通过 return this 实现的值穿透：<br><img src="https://pic3.zhimg.com/v2-99374235673349f56d708c28511c27d2_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-99374235673349f56d708c28511c27d2_hd.jpg" alt=""></p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&apos;Hello World!&apos;);
    }, 1000)
});

promise.then(() =&gt; {
    promise.then().then(null).then(&apos;呵呵哒&apos;).then((res) =&gt; {
        console.log(res)
    })
    promise.catch().catch(null).then(&apos;呵呵哒&apos;).then((res) =&gt; {
        console.log(res) 
    })
})
</code></pre><p>promise 是 PENDING 时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态和值。如：<br><img src="https://pic2.zhimg.com/v2-7d3d3728e3b1f90d905d4f4782c1f97a_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7d3d3728e3b1f90d905d4f4782c1f97a_hd.jpg" alt=""></p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(&apos;Hello World!&apos;);
    }, 1000)
});

let a = promise.then(&apos;呵呵哒&apos;);
a.then(res =&gt; {
    console.log(res);
});

let b = promise.catch(&apos;呵呵哒&apos;);
b.then(res =&gt; {
    console.log(res);
})
</code></pre><p>总而言之，当你给 then() 传递一个非函数（比如一个 promise ）值的时候，它实际上会解释为 then(null) ，这会导致之前的 promise 的结果丢失。例如:<br><img src="https://pic1.zhimg.com/v2-14fe675c00c5bc8154d161e3afed0f41_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-14fe675c00c5bc8154d161e3afed0f41_hd.jpg" alt=""></p>
<pre><code>Promise.resolve(&apos;First Value&apos;).then(Promise.resolve(&apos;Second Value&apos;)).then(null).then((value) =&gt; {
    console.log(value)    // First Value
})
</code></pre><h2 id="四、不要在异步回调函数中使用-throw-Error"><a href="#四、不要在异步回调函数中使用-throw-Error" class="headerlink" title="四、不要在异步回调函数中使用 throw Error"></a>四、不要在异步回调函数中使用 throw Error</h2><p>不仅 reject，抛出的异常也会被作为拒绝状态被 Promise 捕获</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    reject(&apos;This is an error&apos;);
});

promise.then(result =&gt; {
    console.log(result);
}).catch(error =&gt; {
    console.log(&apos;handle error: &apos;, error);  //handle error:  Error: This is an error
})
</code></pre><p>但是，永远不要在回调队列中抛出异常，因为回调队列脱离了运行上下文环境，异常无法被当前作用域捕获。</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        throw Error(&apos;This is an error&apos;);
    });
});

promise.then(result =&gt; {
    console.log(result);
}).catch(error =&gt; {
    console.log(&apos;handle error: &apos;, error);  // Error: This is an error
});
</code></pre><p>简单说来，回调队列指的是 JS 事件循环中的 macrotask 队列，比如 setTimeout setInterval 会插入到 macrotask 中。如果要在回调函数中捕获异常，请使用 reject，永远不要使用 Error。<br>上述的代码应改成：</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        reject(&apos;This is an error&apos;);
    });
});

promise.then(result =&gt; {
    console.log(result);
}).catch(error =&gt; {
    console.log(&apos;handle error: &apos;, error);  // Error: This is an error
});
</code></pre><h2 id="五、then-的第二个参数跟-catch-的区别-【面试常问】"><a href="#五、then-的第二个参数跟-catch-的区别-【面试常问】" class="headerlink" title="五、then 的第二个参数跟 catch 的区别 【面试常问】"></a>五、then 的第二个参数跟 catch 的区别 【面试常问】</h2><p>我们都知道 then 的第二参数跟 catch 用法很像，都是用来进行错误处理的，比如下面这段代码：</p>
<pre><code>let promise1 = new Promise((resolve, reject) =&gt; {
    reject(&apos;this is an error&apos;);
});

promise1.then(data =&gt; {
    console.log(data);
}, err =&gt; {
    console.log(&apos;handle err:&apos;, err);    // handle err: this is an error
});

let promise2 = new Promise((resolve, reject) =&gt; {
    reject(&apos;this is an error&apos;);
});
promise2.then(data =&gt; {
    console.log(data);
}).catch(err =&gt; {
    console.log(&apos;handle err:&apos;, err);    // handle err: this is an error
});
</code></pre><p>当时这两者还是区别的，区别于 then 的第二参数无法处理第一参数函数中的错误。</p>
<pre><code>let promise1 = Promise.resolve();
promise1.then(() =&gt; {
    throw Error(&apos;this is a error&apos;);   //UnhandledPromiseRejectionWarning: Unhandled promise rejection
}, err =&gt; {
    console.log(err);
})

let promise2 = Promise.resolve();

promise2.then(() =&gt; {
    throw Error(&apos;this is a error&apos;);  
}).catch(err =&gt; {
    console.log(&apos;handle err:&apos;, err);    //handle err: Error: this is a error
})
</code></pre><blockquote>
<p>当你使用then( resolveHandler, rejectHandler)格式，如果 resolveHandler 自己抛出一个错误 rejectHandler 并不能捕获。第一个 Promise 对象无法处理同级 then 中的函数抛出的异常，所以在一般情况下，最后直接使用 catch 来进行异常捕获比较保险。</p>
</blockquote>
<h2 id="六、处理最后-catch-函数中的异常"><a href="#六、处理最后-catch-函数中的异常" class="headerlink" title="六、处理最后 catch 函数中的异常"></a>六、处理最后 catch 函数中的异常</h2><p>一般我们用 catch 来捕捉前面抛出的异常，但是如果试想一下如果最后一个 catch 函数也抛出了异常，应该怎么处理呢?</p>
<pre><code>let promise = new Promise((resolve, reject) =&gt; {
    reject(&apos;Hello World&apos;)
});

promise.catch((err) =&gt; {
    throw(&apos;Unexpected Error&apos;);   // Uncaught (in promise) Unexpected Error
})
</code></pre><p>面对这样的错误，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）这里提供两种思路：</p>
<ul>
<li><p>拓展 Promise.prototype 的方法，添加一个 done 函数，将错误抛向全局。</p>
<p>  window.onerror = (err) =&gt; {</p>
<pre><code>console.log(err);
</code></pre><p>  }<br>  Promise.prototype.done = function (onFulfilled, onRejected) {</p>
<pre><code>this.then(onFulfilled, onRejected)
  .catch(function (reason) {
    // 抛出一个全局错误
    setTimeout(() =&gt; { throw reason }, 0);
  });
</code></pre><p>  };<br>  let promise = new Promise((resolve, reject) =&gt; {</p>
<pre><code>reject(&apos;Hello World&apos;)
</code></pre><p>  });</p>
<p>  promise.catch((err) =&gt; {</p>
<pre><code>throw(&apos;Unexpected Error&apos;);     // Uncaught Unexpected Error
</code></pre><p>  }).done()</p>
</li>
</ul>
<ul>
<li>在全局添加 unhandledrejection 事件捕获 Promise 异常。</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-b512c7648df6d0d6fefb64d01009c175_b.jpg" alt=""></p>
<pre><code>window.addEventListener(&quot;unhandledrejection&quot;, (e) =&gt;{
    console.log(e.reason)
})    

let promise = new Promise((resolve, reject) =&gt; {
    reject(&apos;Hello World&apos;)
});

promise.catch((err) =&gt; {
    throw(&apos;Unexpected Error&apos;);     // Unexpected Error
})
</code></pre><h2 id="七、未捕获的错误可以被恢复"><a href="#七、未捕获的错误可以被恢复" class="headerlink" title="七、未捕获的错误可以被恢复"></a>七、未捕获的错误可以被恢复</h2><pre><code>let promise = new Promise((resolve, reject) =&gt; [
    reject(&apos;Hello world&apos;)
]).then(() =&gt; {
    console.log(&apos;resolve&apos;)
})

setTimeout(() =&gt; {
    promise.catch((e) =&gt; {
        console.log(e)
    }).then(() =&gt; {
        console.log(&apos;catch resolve&apos;)
    })
}, 1000)
</code></pre><h2 id="八、resolved-状态的-Promise-不会立即执行"><a href="#八、resolved-状态的-Promise-不会立即执行" class="headerlink" title="八、resolved 状态的 Promise 不会立即执行"></a>八、resolved 状态的 Promise 不会立即执行</h2><pre><code>let i = 0;
Promise.resolve(&apos;resolved promise&apos;).then(() =&gt; {
    i += 2
})
console.log(i)  // 0
</code></pre><p>即使是 resolve 的 Promise 调用 then 方法也是异步执行。</p>
<h2 id="九、结合-async-await-编写同步代码"><a href="#九、结合-async-await-编写同步代码" class="headerlink" title="九、结合 async/await 编写同步代码"></a>九、结合 async/await 编写同步代码</h2><ol>
<li>async/await 函数可以帮助我们彻底摆脱回调地狱的烦恼，用一种同步的方式来编写异步函数。</li>
<li>await 后面可以接数值，如果是异步请求的话可以接 Thunk 函数和 Promise 对象。</li>
</ol>
<p><img src="https://pic4.zhimg.com/v2-3ca5e16c6ba1743725cc92a7a8e5a7e2_b.jpg" alt=""></p>
<pre><code>const timeout = (ms) =&gt; {
    return new Promise((resolve) =&gt; {
        setTimeout(() =&gt; {
            resolve(ms + &apos; passed&apos;)
        }, ms)
    })
}

const asyncFunc =  async () =&gt; {
    const value1 = await timeout(2000)
    console.log(value1)
    const value2 = await timeout(2000)
    console.log(value2)
}

asyncFunc()
console.log(&apos;now&apos;)
</code></pre><h2 id="十、调用-then-方法返回新的-Promise-对象"><a href="#十、调用-then-方法返回新的-Promise-对象" class="headerlink" title="十、调用 then 方法返回新的 Promise 对象"></a>十、调用 then 方法返回新的 Promise 对象</h2><pre><code>let promise1 = new Promise((resolve) =&gt; {
    resolve(&apos;Hello world&apos;)
})

let promise2 = promise1.then()

console.log(promise1 === promise2)    // false
console.log(promise1 instanceof Promise)  // true
console.log(promise2 instanceof Promise)  // true
</code></pre><p>每次调用 then 方法后都会返回一个新的 Promise 对象，并不是返回原本的 Promise 对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/03/我也来实现一把MVVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/03/我也来实现一把MVVM/" itemprop="url">我也来实现一把MVVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-03T00:20:32+08:00">
                2018-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大家都知道，vue是个MVVM框架，能够实现view和model的双向绑定，不像backbone那样，model改变需要手动去通知view更新，而vue实现的原理就是通过Object.defineProperty实现数据挟持，定义setter，然后数据改变的时候通知视图更新。</p>
<p>下面是网上vue的实现原理图：</p>
<p> <img src="https://user-gold-cdn.xitu.io/2018/4/10/162ad3d5be3e5105?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p>
<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653b294cd1b80e3?imageslim" alt=""></p>
<h4 id="1、MVVM"><a href="#1、MVVM" class="headerlink" title="1、MVVM"></a>1、MVVM</h4><p>入口文件，在这里对vue当中的$el、methods、$data进行初始化，调用observer遍历$data的数据并进行挟持，调用compile遍历$el下的所有节点，解析指令和取值操作。遍历$data的数据，通过Object.defineProperty的getter和setter实现对$data的代理。</p>
<h4 id="2、Observer"><a href="#2、Observer" class="headerlink" title="2、Observer"></a>2、Observer</h4><p>遍历data，通过Object.defineProperty设置getter和setter，在setter知道数据发生了改变，然后通知Wacher去更新view。</p>
<h4 id="3、Compile"><a href="#3、Compile" class="headerlink" title="3、Compile"></a>3、Compile</h4><p>遍历$el下的所有节点，解析指令和取值操作等，为每个节点绑定更新函数（为什么在compile这里绑定呢？因为这里刚好是遍历的节点☺），绑定事件和method的关系，同时也添加订阅者，当接受到视图更新的订阅消息后，调用更新函数，实现视图更新。同时在添加订阅者的时候，初始化渲染视图。</p>
<h4 id="4、Watcher"><a href="#4、Watcher" class="headerlink" title="4、Watcher"></a>4、Watcher</h4><p>Watcher作为订阅者，充当Observer和Compile的中间桥梁，包含update方法，update方法调用Compile中绑定的事件更新函数，实现对视图的初始化和更新操作。</p>
<h3 id="MVVM的实现"><a href="#MVVM的实现" class="headerlink" title="MVVM的实现"></a>MVVM的实现</h3><p>MVVM完成初始化操作，并且调用observer和compile。对$data进行代理，如此便可以通过this.attribute来代理this.$data.attribute。因为一个属性可能对应多个指令，所以需要一个_binding属性来存放属性对应的所有订阅者，这样属性一改变，就可以取出所有的订阅者去更新视图。</p>
<pre><code>function MVVM(options) {
  // 初始化
  this.$data = options.data;
  this.$methods = options.methods;
  this.$el = options.el;
  // 保存data的每个属性对应的所有watcher
  this._binding  = {};
  // 调用observer和compile
  this._observer(options.data);
  this._compile();
  // this.xxx 代理this.$data.xxx
  this.proxyAttribute();
}
</code></pre><h3 id="Observer的实现"><a href="#Observer的实现" class="headerlink" title="Observer的实现"></a>Observer的实现</h3><p>Observer遍历$data，通过Object.defineProperty的setter的挟持数据改变，监听到数据改变后取出所有该属性对应的订阅者，然后通知更新函数更新视图。</p>
<p>注意：这里有循环，且闭包（getter和setter）里面需要依赖循环项（value和key），所以用立即执行函数解决循环项获取不对的问题。</p>
<pre><code>MVVM.prototype._observer = function(data) {
  var self = this;
  for(var key in this.$data) {
    if (this.$data.hasOwnProperty(key)) {
      // 初始化属性对应的订阅者容器（数组）
      this._binding[key] = {
        _directives: [],
        _texts: []
      };

      if(typeof this.$data[key] === &quot;object&quot;) {
        return this._observer(this.$data[key]);
      }
      var val = data[key];
      // 立即执行函数获取正确的循环项
      (function(value, key) {
        Object.defineProperty(self.$data, key, {
          enumerable: true,
          configurable: true,
          get: function() {
            return value;
          },
          set(newval) {
            if(newval === value) {
              return;
            }
            value = newval;
            // 监听到数据改变后取出所有该属性对应的订阅者，通知view更新-属性
            if(self._binding[key]._directives) {
              self._binding[key]._directives.forEach(function(watcher) {
                watcher.update();
              }, self);
            }
            // 监听到数据改变后取出所有该属性对应的订阅者，通知view更新-文本
            if(self._binding[key]._texts) {
              self._binding[key]._texts.forEach(function(watcher) {
                watcher.update();
              }, self);
            }
          }
        });
      })(val, key);
    }
  }
}
</code></pre><h3 id="Compile的实现"><a href="#Compile的实现" class="headerlink" title="Compile的实现"></a>Compile的实现</h3><p>Compile遍历所有的节点，解析指令，为每个节点绑定更新函数，且添加订阅者，当订阅者通知view更新的时候，调用更新函数，实现对视图的更新。</p>
<p>这里同样需要使用立即执行函数来解决闭包依赖的循环项问题。</p>
<p>还有一点需要解决的是，如果节点的innerText依赖多个属性的话，如何做到只替换改变属性对应的文本问题。</p>
<p>比如：已经被编译解析成“欢迎： 鸣人”，如果message改变为“你好”，怎么让使得“欢迎：鸣人”改为“你好：鸣人”。</p>
<pre><code>MVVM.prototype._compile = function() {
  var dom = document.querySelector(this.$el);
  var children = dom.children;
  var self = this;
  var i = 0, j = 0;
  // 更新函数，但observer中model的数据改变的时候，通过Watcher的update调用更新函数，从而更新dom
  var updater = null;
  for(; i &lt; children.length; i++) {
    var node = children[i];
    (function(node) {
      // 解析{{}}里面的内容
      // 保存指令原始内容，不然数据更新时无法完成替换
      var text = node.innerText;
      var matches = text.match(/{{([^{}]+)}}/g);
      if(matches &amp;&amp; matches.length &gt; 0) {
        // 保存和node绑定的所有属性
        node.bindingAttributes = [];
        for(j = 0; j &lt; matches.length; j++) {
          // data某个属性
          var attr = matches[j].match(/{{([^{}]+)}}/)[1];
          // 将和该node绑定的data属性保存起来
          node.bindingAttributes.push(attr);
          (function(attr) {
            updater = function() {
              // 改变的属性值对应的文本进行替换
              var innerText = text.replace(new RegExp(&quot;{{" + attr + "}}&quot;, &quot;g&quot;), self.$data[attr]);
              // 如果该node绑定多个属性 eg:&lt;div&gt;{{title}}{{description}}&lt;/div&gt;
              for(var k = 0; k &lt; node.bindingAttributes.length; k++) {
                if(node.bindingAttributes[k] !== attr) {
                  // 恢复原来没改变的属性对应的文本
                  innerText = innerText.replace(&quot;{{" + node.bindingAttributes[k] + "}}&quot;, self.$data[node.bindingAttributes[k]]);
                }
              }
              node.innerText = innerText;
            }
            self._binding[attr]._texts.push(new Watcher(self, attr, updater));
          })(attr);
        }
      }

      // 解析vue指令
      var attributes = node.getAttributeNames();
      for(j = 0; j &lt; attributes.length; j++) {
        // vue指令
        var attribute = attributes[j];
        // DOM attribute
        var domAttr = null;
        // 绑定的data属性
        var vmDataAttr = node.getAttribute(attribute);

        if(/v-bind:([^=]+)/.test(attribute)) {
          // 解析v-bind
          domAttr = RegExp.$1;
          // 更新函数
          updater = function(val) {
            node[domAttr] = val;
          }
          // data属性绑定多个watcher
          self._binding[vmDataAttr]._directives.push(
            new Watcher(self, vmDataAttr, updater)
          )
        } elseif(attribute === &quot;v-model&quot; &amp;&amp; (node.tagName = &apos;INPUT&apos; || node.tagName == &apos;TEXTAREA&apos;)) {
          // 解析v-model
          // 更新函数
          updater = function(val) {
            node.value = val;
          }
          // data属性绑定多个watcher
          self._binding[vmDataAttr]._directives.push(
            new Watcher(self, vmDataAttr, updater)
          )
          // 监听input/textarea的数据变化，同步到model去，实现双向绑定
          node.addEventListener(&quot;input&quot;, function(evt) {
            var $el = evt.currentTarget;
            self.$data[vmDataAttr] = $el.value;
          });
        } elseif(/v-on:([^=]+)/.test(attribute)) {
          // 解析v-on
          var event = RegExp.$1;
          var method = vmDataAttr;
          node.addEventListener(event, function(evt) {
            self.$methods[method] &amp;&amp; self.$methods[method].call(self, evt);
          });
        }
      }
    })(node);
  }

}
</code></pre><h3 id="Watcher的实现"><a href="#Watcher的实现" class="headerlink" title="Watcher的实现"></a>Watcher的实现</h3><p>Watcher充当订阅者的角色，架起了Observer和Compile的桥梁，Observer监听到数据变化后，通知Wathcer更新视图(调用Wathcer的update方法)，Watcher再告诉Compile去调用更新函数，实现dom的更新。同时页面的初始化渲染也交给了Watcher（当然也可以放到Compile进行）。</p>
<pre><code>function Watcher(vm, attr, cb) {
  this.vm = vm; // viewmodel
  this.attr = attr; // data的属性，一个watcher订阅一个data属性
  this.cb = cb; // 更新函数，在compile那边定义
  // 初始化渲染视图
  this.update();
}

Watcher.prototype.update = function() {
  // 通知comile中的更新函数更新dom 
  this.cb(this.vm.$data[this.attr]);
}
</code></pre><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><p>git地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FVikiLee%2FMVVM.git" target="_blank" rel="noopener">github.com/VikiLee/MVV…</a></p>
<p>鸣谢：<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5acc17cb51882555745a03f8" target="_blank" rel="noopener">juejin.im/post/5acc17…</a></p>
<h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;view&quot;&gt;
    &lt;div v-bind:id=&quot;id&quot;&gt;
      {{message}}:{{name}}
    &lt;/div&gt;
    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;
    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;script src=&quot;js/MVVM.js&quot;type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  var vue = new MVVM({
    el: &quot;#view&quot;,
    data: {
      message: &quot;欢迎光临&quot;,
      name: &quot;鸣人&quot;,
      id: &quot;id&quot;
    },
    methods: {
      handleClick: function() {
        alert(this.message + &quot;:&quot; + this.name + &quot;, 点击确定路飞会出来&quot;);
        this.name = &apos;路飞&apos;;
      }
    }
  })

  setTimeout(function() {
    vue.message = &quot;你好&quot;;
  }, 1000);
&lt;/script&gt;
&lt;/html&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/02/Promise-必知必会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/02/Promise-必知必会/" itemprop="url">Promise 必知必会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T23:18:00+08:00">
                2018-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="你不知道的-Promise-对象黑科技"><a href="#你不知道的-Promise-对象黑科技" class="headerlink" title="你不知道的 Promise 对象黑科技"></a><a href="https://zhuanlan.zhihu.com/p/30735250" target="_blank" rel="noopener">你不知道的 Promise 对象黑科技</a></h2><p>Promise 想必大家都十分熟悉，想想就那么几个 api，可是你真的了解 Promise 吗？本文根据 Promise 的一些知识点总结了十道题，看看你能做对几道。</p>
<p>以下 promise 均指代 Promise 实例，环境是 Node.js。</p>
<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {
  console.log(1)
  resolve()
  console.log(2)
})
promise.then(() =&gt; {
  console.log(3)
})
console.log(4)
</code></pre><p>运行结果：</p>
<pre><code>1
2
4
3
</code></pre><p>解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。</p>
<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(&apos;success&apos;)
  }, 1000)
})
console.log(promise)
promise
  .then(() =&gt; {
    console.log(promise)
    throw new Error(&apos;error!!!&apos;)
  })
  .catch(err =&gt; {
    console.log(promise)
  })
</code></pre><p>运行结果：</p>
<pre><code>Promise { &lt;pending&gt; }
Promise { &apos;success&apos; }
Promise { &apos;success&apos; }
</code></pre><p>解释：promise 有 3 种状态：pending、fulfilled 和 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。</p>
<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {
  resolve(&apos;success1&apos;)
  reject(&apos;error&apos;)
  resolve(&apos;success2&apos;)
})

promise
  .then((res) =&gt; {
    console.log(&apos;then: &apos;, res)
  })
  .catch((err) =&gt; {
    console.log(&apos;catch: &apos;, err)
  })
</code></pre><p>运行结果：</p>
<pre><code>then: success1
</code></pre><p>解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。</p>
<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><pre><code>Promise.resolve(1)
  .then((res) =&gt; {
    console.log(res)
    return 2
  })
  .catch((err) =&gt; {
    return 3
  })
  .then((res) =&gt; {
    console.log(res)
  })
</code></pre><p>运行结果：</p>
<pre><code>1
2
</code></pre><p>解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。</p>
<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    console.log(&apos;once&apos;)
    resolve(&apos;success&apos;)
  }, 1000)
})

const start = Date.now()
promise.then((res) =&gt; {
  console.log(res, Date.now() - start)
})
promise.then((res) =&gt; {
  console.log(res, Date.now() - start)
})
</code></pre><p>运行结果：</p>
<pre><code>once
success 1005
success 1007
</code></pre><p>解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</p>
<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><pre><code>Promise.resolve()
  .then(() =&gt; {
    return new Error(&apos;error!!!&apos;)
  })
  .then((res) =&gt; {
    console.log(&apos;then: &apos;, res)
  })
  .catch((err) =&gt; {
    console.log(&apos;catch: &apos;, err)
  })
</code></pre><p>运行结果：</p>
<pre><code>then: Error: error!!!
    at Promise.resolve.then (...)
    at ...
</code></pre><p>解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：</p>
<ol>
<li>return Promise.reject(new Error(‘error!!!’))</li>
<li>throw new Error(‘error!!!’)</li>
</ol>
<p>因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。</p>
<h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><pre><code>const promise = Promise.resolve()
  .then(() =&gt; {
    return promise
  })
promise.catch(console.error)
</code></pre><p>运行结果：</p>
<pre><code>TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
    at &lt;anonymous&gt;
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3
</code></pre><p>解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：</p>
<pre><code>process.nextTick(function tick () {
  console.log(&apos;tick&apos;)
  process.nextTick(tick)
})
</code></pre><h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre><p>运行结果：</p>
<pre><code>1
</code></pre><p>解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</p>
<h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><pre><code>Promise.resolve()
  .then(function success (res) {
    throw new Error(&apos;error&apos;)
  }, function fail1 (e) {
    console.error(&apos;fail1: &apos;, e)
  })
  .catch(function fail2 (e) {
    console.error(&apos;fail2: &apos;, e)
  })
</code></pre><p>运行结果：</p>
<pre><code>fail2: Error: error
    at success (...)
    at ...
</code></pre><p>解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以：</p>
<pre><code>Promise.resolve()
  .then(function success1 (res) {
    throw new Error(&apos;error&apos;)
  }, function fail1 (e) {
    console.error(&apos;fail1: &apos;, e)
  })
  .then(function success2 (res) {
  }, function fail2 (e) {
    console.error(&apos;fail2: &apos;, e)
  })
</code></pre><h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><pre><code>process.nextTick(() =&gt; {
  console.log(&apos;nextTick&apos;)
})
Promise.resolve()
  .then(() =&gt; {
    console.log(&apos;then&apos;)
  })
setImmediate(() =&gt; {
  console.log(&apos;setImmediate&apos;)
})
console.log(&apos;end&apos;)
</code></pre><p>运行结果：</p>
<pre><code>end
nextTick
then
setImmediate
</code></pre><p>解释：process.nextTick 和 promise.then 都属于 microtasks，而 setImmediate 属于 macrotasks，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotasks）之间都会执行 microtasks，事件循环的开始会先执行一次 microtasks。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/30/pm2-常用配置及命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/30/pm2-常用配置及命令/" itemprop="url">pm2 常用配置及命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-30T12:11:05+08:00">
                2018-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>PM2</code> 是 <code>node</code> 进程管理工具，可以利用它来简化很多 <code>node</code> 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。本文就 <code>PM2</code> 进行入门性的介绍，基本涵盖了 <code>PM2</code> 的常用的功能和配置。</p>
<h2 id="安装安装"><a href="#安装安装" class="headerlink" title="#安装安装"></a><a href="#安装">#安装</a>安装</h2><pre><code>npm install -g pm2
</code></pre><h2 id="常用命令常用命令"><a href="#常用命令常用命令" class="headerlink" title="#常用命令常用命令"></a><a href="#常用命令">#常用命令</a>常用命令</h2><pre><code>pm2 start [server.js]
# 启动服务
pm2 list
# 查看当前所跑服务的详情
pm2 show [name]
# 查看更加详细的信息这个命令可查看pm2配置 包括日志文件存放的位置等
pm2 stop [id/name]
# 关闭某个服务
pm2 delete [id/name]
# 删除某个服务
pm2 stop all
# 关闭所有服务
pm2 logs
# 查看实时日志
pm2 restart [name]
# 重新启动服务
</code></pre><h2 id="启动启动"><a href="#启动启动" class="headerlink" title="#启动启动"></a><a href="#启动">#启动</a>启动</h2><p>参数说明：</p>
<ul>
<li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</li>
<li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果 <code>-i 0</code> 或者 <code>-i max</code>，则根据当前机器核数确定实例数目。</li>
<li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如 <code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li>
<li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li>
<li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li>
<li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li>
</ul>
<h2 id="监听监听"><a href="#监听监听" class="headerlink" title="#监听监听"></a><a href="#监听">#监听</a>监听</h2><pre><code>pm2 start ./bin/www --watch
#注意，这里用了--watch参数，意味着当你的应用代码发生变化时，pm2会帮你自动重启服务
</code></pre><h2 id="配置及部署配置及部署"><a href="#配置及部署配置及部署" class="headerlink" title="#配置及部署配置及部署"></a><a href="#配置及部署">#配置及部署</a>配置及部署</h2><p>部署的配置文件示例</p>
<pre><code>{
  // 数组中放的是需要发布的项目一些变量的定义
  &quot;apps&quot;: [{
    &quot;name&quot;: &quot;xxx&quot;, //项目名称
    &quot;script&quot;: &quot;server.js&quot;, //用来启动的脚本
    // &quot;instances&quot;:2,
    // 启动项目所需要的环境变量
    &quot;env&quot;: {
      &quot;COMMON_VARIABLE&quot;: &quot;true&quot;, //设置为true 可以在启动的时传入外部的变量进去
    },
    &quot;env_production&quot;: {
      &quot;NODE_ENV&quot;: &quot;production&quot;
    }
  }],
  // 部署
  &quot;deploy&quot;: {
    &quot;production&quot;: {
      &quot;user&quot;: &quot;root&quot;,
      &quot;host&quot;: &quot;0.0.0.0&quot;, //可以是数组 部署到多台主机
      &quot;ref&quot;: &quot;origin/master&quot;, //选择拿哪个个分支的代码
      &quot;repo&quot;: &quot;git@github.com:ihoey/hitalk.git&quot;, //仓库地址
      &quot;path&quot;: &quot;/root/www/hitalk/production&quot;, //要发布到服务器上哪个目录下面
      &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, //避免key验证导致代码更新到远程仓库失败
      &quot;post-deploy&quot;: &quot;source ~/.nvm/nvm.sh &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;, //发布之后执行的动作 执行开启或更新pm2运行的服务
      &quot;pre-deploy-local&quot;: &quot;echo &apos;Deploy Done!&apos;&quot;, //本地发布之前的动作
      &quot;env&quot;: { //指定部署到远程的仓库的环境 是production生产环境
        &quot;NODE_ENV&quot;: &quot;production&quot;
      }
    }
  }
}
</code></pre><h3 id="初始化配置初始化配置"><a href="#初始化配置初始化配置" class="headerlink" title="#初始化配置初始化配置"></a><a href="#初始化配置">#初始化配置</a>初始化配置</h3><p>第一次部署</p>
<pre><code>pm2 deploy ecosystem.json production setup
</code></pre><h3 id="部署部署"><a href="#部署部署" class="headerlink" title="#部署部署"></a><a href="#部署">#部署</a>部署</h3><pre><code>pm2 deploy ecosystem.json production
</code></pre><p>好了，先记录这么多~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/29/浅说-XSS-和-CSRF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/浅说-XSS-和-CSRF/" itemprop="url">浅说 XSS 和 CSRF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-29T12:06:38+08:00">
                2018-09-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 Web 安全领域中，XSS 和 CSRF 是最常见的攻击方式。本文将会简单介绍 XSS 和 CSRF 的攻防问题。</p>
<blockquote>
<p>声明：本文的示例仅用于演示相关的攻击原理</p>
</blockquote>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。</p>
<p>XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p>
<p>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。</p>
<p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p>
<h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。</p>
<p>看一个示例。我先准备一个如下的静态页：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720000-30a9b93a-8752-11e8-879b-edd8519f4e3e.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720000-30a9b93a-8752-11e8-879b-edd8519f4e3e.png" alt="反射型xss1"></a></p>
<p>恶意链接的地址指向了 <code>localhost:8001/?q=111&amp;p=222</code>。然后，我再启一个简单的 Node 服务处理恶意链接的请求：</p>
<pre><code>consthttp=require(&apos;http&apos;);
functionhandleReequest(req, res) {
    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);
    res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;});
    res.write(&apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;);
    res.end();
}

constserver=newhttp.Server();
server.listen(8001, &apos;127.0.0.1&apos;);
server.on(&apos;request&apos;, handleReequest);
</code></pre><p>当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720046-ee5a3f40-8752-11e8-8cc5-8b464414864a.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720046-ee5a3f40-8752-11e8-8cc5-8b464414864a.png" alt="执行脚本"></a></p>
<p>这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。</p>
<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。</p>
<p>比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</p>
<p>举一个示例。</p>
<p>先准备一个输入页面：</p>
<pre><code>&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;
&lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt;   

&lt;script&gt;
    const input = document.getElementById(&apos;input&apos;);
    const btn = document.getElementById(&apos;btn&apos;);

    let val;

    input.addEventListener(&apos;change&apos;, (e) =&gt; {
        val = e.target.value;
    }, false);

    btn.addEventListener(&apos;click&apos;, (e) =&gt; {
        fetch(&apos;http://localhost:8001/save&apos;, {
            method: &apos;POST&apos;,
            body: val
        });
    }, false);
&lt;/script&gt;     
</code></pre><p>启动一个 Node 服务监听 <code>save</code> 请求。为了简化，用一个变量来保存用户的输入：</p>
<pre><code>consthttp=require(&apos;http&apos;);

let userInput =&apos;&apos;;

functionhandleReequest(req, res) {
    constmethod=req.method;
    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);
    res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type&apos;)

    if (method ===&apos;POST&apos;&amp;&amp;req.url===&apos;/save&apos;) {
        let body =&apos;&apos;;
        req.on(&apos;data&apos;, chunk=&gt; {
            body += chunk;
        });

        req.on(&apos;end&apos;, () =&gt; {
            if (body) {
                userInput = body;
            }
            res.end();
        });
    } else {
        res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;});
        res.write(userInput);
        res.end();
    }
}

constserver=newhttp.Server();
server.listen(8001, &apos;127.0.0.1&apos;);

server.on(&apos;request&apos;, handleReequest);
</code></pre><p>当用户点击提交按钮将输入信息提交到服务端时，服务端通过 <code>userInput</code> 变量保存了输入内容。当用户通过 <code>http://localhost:8001/${id}</code> 访问时，服务端会返回与 <code>id</code> 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42720476-eb71a5c8-8759-11e8-8763-eb08b3480201.gif" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720476-eb71a5c8-8759-11e8-8763-eb08b3480201.gif" alt="存储型xss"></a></p>
<h4 id="基于DOM"><a href="#基于DOM" class="headerlink" title="基于DOM"></a>基于DOM</h4><p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p>
<p>看如下代码：</p>
<pre><code>&lt;h2&gt;XSS: &lt;/h2&gt;
&lt;inputtype=&quot;text&quot;id=&quot;input&quot;&gt;
&lt;buttonid=&quot;btn&quot;&gt;Submit&lt;/button&gt;
&lt;divid=&quot;div&quot;&gt;&lt;/div&gt;
&lt;script&gt;constinput=document.getElementById(&apos;input&apos;);constbtn=document.getElementById(&apos;btn&apos;);constdiv=document.getElementById(&apos;div&apos;);let val;input.addEventListener(&apos;change&apos;, (e) =&gt; {        val =e.target.value;    }, false);btn.addEventListener(&apos;click&apos;, () =&gt; {div.innerHTML=`&lt;ahref=${val}&gt;testLink&lt;/a&gt;`    }, false);&lt;/script&gt;
</code></pre><p>点击 <code>Submit</code> 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：</p>
<pre><code>&apos;&apos; onclick=alert(/xss/)
</code></pre><p>用户提交之后，页面代码就变成了：</p>
<pre><code>&lt;ahrefonlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;
</code></pre><p>此时，用户点击生成的链接，就会执行对应的脚本：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42721109-cb7ce572-8766-11e8-96d9-9ada8a787827.gif" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42721109-cb7ce572-8766-11e8-96d9-9ada8a787827.gif" alt="dom-xss"></a></p>
<h3 id="XSS-攻击的防范"><a href="#XSS-攻击的防范" class="headerlink" title="XSS 攻击的防范"></a>XSS 攻击的防范</h3><p>现在主流的浏览器内置了防范 XSS 的措施，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">CSP</a>。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。</p>
<h4 id="HttpOnly-防止劫取-Cookie"><a href="#HttpOnly-防止劫取-Cookie" class="headerlink" title="HttpOnly 防止劫取 Cookie"></a>HttpOnly 防止劫取 Cookie</h4><p>HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。</p>
<p>上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p>
<h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p><strong>不要相信用户的任何输入。</strong> 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</p>
<p>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 <code>&lt;</code>，<code>&gt;</code> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。</p>
<p>而在一些前端框架中，都会有一份 <code>decodingMap</code>， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <code>&lt;</code>，<code>&gt;</code>，<code>script</code>，防止 XSS 攻击：</p>
<pre><code>// vuejs 中的 decodingMap
// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  &apos;&amp;lt;&apos;: &apos;&lt;&apos;,
  &apos;&amp;gt;&apos;: &apos;&gt;&apos;,
  &apos;&amp;quot;&apos;: &apos;&quot;&apos;,
  &apos;&amp;amp;&apos;: &apos;&amp;&apos;,
  &apos;&amp;#10;&apos;: &apos;\n&apos;
}
</code></pre><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 <a href="https://github.com/punkave/sanitize-html" target="_blank" rel="noopener">sanitize-html</a> 对输出内容进行有规则的过滤之后再输出到页面中。</p>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p>
<p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p>
<p>在举例子之前，先说说浏览器的 Cookie 策略。</p>
<h3 id="浏览器的-Cookie-策略"><a href="#浏览器的-Cookie-策略" class="headerlink" title="浏览器的 Cookie 策略"></a>浏览器的 Cookie 策略</h3><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
</ul>
<p>而浏览器所持有的 Cookie 分为两种：</p>
<ul>
<li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。</li>
<li><p>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p>
<p>  res.setHeader(‘Set-Cookie’, [‘mycookie=222’, ‘test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;’]);</p>
</li>
</ul>
<p>上述代码创建了两个 Cookie：<code>mycookie</code> 和 <code>test</code>，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 <code>Expires</code> 属性值会不一样：</p>
<p>Firefox：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png" alt="firefox cookie"></a></p>
<p>Chrome:</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png" alt="chrome cookie"></a></p>
<p>此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 <code>donmain</code> 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。</p>
<h3 id="通过-Cookie-进行-CSRF-攻击"><a href="#通过-Cookie-进行-CSRF-攻击" class="headerlink" title="通过 Cookie 进行 CSRF 攻击"></a>通过 Cookie 进行 CSRF 攻击</h3><p>假设有一个 bbs 站点：<code>http://www.c.com</code>，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：</p>
<pre><code>http://www.c.com:8002/content/delete/:id
</code></pre><p>如发起 <code>http://www.c.com:8002/content/delete/87343</code> 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：</p>
<pre><code>res.setHeader(&apos;Set-Cookie&apos;, [&apos;user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&apos;]);
</code></pre><p><a href="https://user-images.githubusercontent.com/7871813/42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png" alt="user"></a></p>
<p><code>user</code> 对应的值是用户 ID。然后构造一个页面 A：</p>
<pre><code>&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;
&lt;img src=&quot;http://www.c.com:8002/content/delete/87343&quot;&gt;
</code></pre><p>页面 A 使用了一个 <code>img</code> 标签，其地址指向了删除用户帖子的链接：</p>
<p><a href="https://user-images.githubusercontent.com/7871813/42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png" alt="A"></a></p>
<p>可以看到，当登录用户访问攻击者的网站时，会向 <code>www.c.com</code> 发起一个删除用户帖子的请求。此时若用户在切换到 <code>www.c.com</code> 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。</p>
<p>由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p>
<p>但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。</p>
<h3 id="CSRF-攻击的防范"><a href="#CSRF-攻击的防范" class="headerlink" title="CSRF 攻击的防范"></a>CSRF 攻击的防范</h3><p>当前，对 CSRF 攻击的防范措施主要有如下几种方式。</p>
<h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。</p>
<p>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</p>
<p>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p>
<h4 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。</p>
<p>比如，如果用户要删除自己的帖子，那么先要登录 <code>www.c.com</code>，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 <code>http://www.c.com</code>；当请求是从 <code>www.a.com</code> 发起时，Referer 的值是 <code>http://www.a.com</code> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 <code>www.c.com</code> 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</p>
<p>针对上文的例子，可以在服务端增加如下代码：</p>
<pre><code>if (req.headers.referer!==&apos;http://www.c.com:8002/&apos;) {
    res.write(&apos;csrf 攻击&apos;);
    return;
}
</code></pre><p><a href="https://user-images.githubusercontent.com/7871813/42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png" alt="referer check"></a></p>
<p>Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。</p>
<h4 id="添加-token-验证"><a href="#添加-token-验证" class="headerlink" title="添加 token 验证"></a>添加 token 验证</h4><p>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 XSS 和 CSRF 的攻击原理和防御措施。当然，在 Web 安全领域，除了这两种常见的攻击方式，也存在这 SQL 注入等其它攻击方式，这不在本文的讨论范围之内，如果你对其感兴趣，可以阅读<a href="https://zhuanlan.zhihu.com/p/23569276" target="_blank" rel="noopener">SQL注入技术专题</a>的专栏详细了解相关信息。最后，总结一下 XSS 攻击和 CSRF 攻击的常见防御措施：</p>
<ol>
<li>防御 XSS 攻击</li>
</ol>
<ul>
<li>HttpOnly 防止劫取 Cookie</li>
<li>用户的输入检查</li>
<li>服务端的输出检查</li>
</ul>
<ol start="2">
<li>防御 CSRF 攻击</li>
</ol>
<ul>
<li>验证码</li>
<li>Referer Check</li>
<li>Token 验证</li>
</ul>
<p>&lt;完&gt;</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">Cross-site scripting</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html" target="_blank" rel="noopener">CSRF 攻击的应对之道</a></li>
<li>《白帽子讲 Web 安全》</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/21/ES6事件总线-EventBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/21/ES6事件总线-EventBus/" itemprop="url">ES6事件总线 EventBus</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-21T14:13:12+08:00">
                2018-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class EventBus &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.events = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on(type, callback, scope, ...args) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            this.events[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        this.events[type].push(&#123;scope: scope, callback: callback, args: args&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off(type, callback, scope) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let numOfCallbacks = this.events[type].length;</span><br><span class="line">        let newArray = [];</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = this.events[type][i];</span><br><span class="line">            if (event.scope == scope &amp;&amp; event.callback == callback) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                newArray.push(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.events[type] = newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has(type, callback, scope) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        let numOfCallbacks = this.events[type].length;</span><br><span class="line">        if (callback === undefined &amp;&amp; scope === undefined) &#123;</span><br><span class="line">            return numOfCallbacks &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = this.events[type][i];</span><br><span class="line">            if ((scope ? event.scope == scope : true) &amp;&amp; event.callback == callback) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit(type, target, ...args) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let bag = &#123;</span><br><span class="line">            type: type,</span><br><span class="line">            target: target</span><br><span class="line">        &#125;;</span><br><span class="line">        args = [bag].concat(args);</span><br><span class="line">        let events = this.events[type].slice();</span><br><span class="line">        let numOfCallbacks = events.length;</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = events[i];</span><br><span class="line">            if (event &amp;&amp; event.callback) &#123;</span><br><span class="line">                let concatArgs = args.concat(event.args);</span><br><span class="line">                event.callback.apply(event.scope, concatArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug() &#123;</span><br><span class="line">        let str = &quot;&quot;;</span><br><span class="line">        for (let type in this.events) &#123;</span><br><span class="line">            let numOfCallbacks = this.events[type].length;</span><br><span class="line">            for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">                let event = this.events[type][i];</span><br><span class="line">                let className = &quot;Anonymous&quot;;</span><br><span class="line">                if (event.scope) &#123;</span><br><span class="line">                    if (event.scope.constructor.name) &#123;</span><br><span class="line">                        className = event.scope.constructor.name;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                str += `$&#123;className&#125; listening for &quot;$&#123;type&#125;&quot;\n`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default new EventBus();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;EventBus Examples&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">    import EventBus from &apos;/src/eventbus.js&apos;;</span><br><span class="line">    // Simple example</span><br><span class="line">    &#123;</span><br><span class="line">        function myHandler(event) &#123;</span><br><span class="line">            console.log(&quot;myHandler / type: &quot; + event.type);</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.on(&quot;my_event&quot;, myHandler);</span><br><span class="line">        EventBus.emit(&quot;my_event&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // Keeping the scope</span><br><span class="line">    &#123;</span><br><span class="line">        class TestClass1 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass1&quot;;</span><br><span class="line">                EventBus.on(&quot;callback_event&quot;, this.callback, this);</span><br><span class="line">            &#125;</span><br><span class="line">            callback(event) &#123;</span><br><span class="line">                console.log(this.className + &quot; / type: &quot; + event.type + &quot; / dispatcher: &quot; + event.target.className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class TestClass2 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass2&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch() &#123;</span><br><span class="line">                EventBus.emit(&quot;callback_event&quot;, this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let t1 = new TestClass1();</span><br><span class="line">        let t2 = new TestClass2();</span><br><span class="line">        t2.dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">    // Passing additional parameters</span><br><span class="line">    &#123;</span><br><span class="line">        class TestClass1 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass1&quot;;</span><br><span class="line">                EventBus.on(&quot;custom_event&quot;, this.doSomething, this);</span><br><span class="line">            &#125;</span><br><span class="line">            doSomething(event, param1, param2) &#123;</span><br><span class="line">                console.log(this.className + &quot;.doSomething&quot;);</span><br><span class="line">                console.log(&quot;type=&quot; + event.type);</span><br><span class="line">                console.log(&quot;params=&quot; + param1 + param2);</span><br><span class="line">                console.log(&quot;coming from=&quot; + event.target.className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class TestClass2 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass2&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            ready() &#123;</span><br><span class="line">                EventBus.emit(&quot;custom_event&quot;, this, &quot;javascript events&quot;, &quot; are really useful&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let t1 = new TestClass1();</span><br><span class="line">        let t2 = new TestClass2();</span><br><span class="line">        t2.ready();</span><br><span class="line">    &#125;</span><br><span class="line">    // Debugging</span><br><span class="line">    console.log(EventBus.debug());</span><br><span class="line">    // Removing a registered handler</span><br><span class="line">    &#123;</span><br><span class="line">        var handler = function() &#123;</span><br><span class="line">            console.log(&apos;example callback&apos;);</span><br><span class="line">        &#125;;</span><br><span class="line">        EventBus.on(&apos;EXAMPLE_EVENT&apos;, handler);</span><br><span class="line">        EventBus.emit(&apos;EXAMPLE_EVENT&apos;);</span><br><span class="line">        EventBus.off(&apos;EXAMPLE_EVENT&apos;, handler);</span><br><span class="line">        // Not emitted because event was removed</span><br><span class="line">        EventBus.emit(&apos;EXAMPLE_EVENT&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/16/前端代码异常监控实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/16/前端代码异常监控实战/" itemprop="url">前端代码异常监控实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-16T11:22:33+08:00">
                2018-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="把前端监控做到极致-掘金"><a href="#把前端监控做到极致-掘金" class="headerlink" title="把前端监控做到极致 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a52f138f265da3e5b32a41b" target="_blank" rel="noopener">把前端监控做到极致 - 掘金</a></h2><h2 id="线上压缩代码-定位错误-掘金"><a href="#线上压缩代码-定位错误-掘金" class="headerlink" title="线上压缩代码-定位错误 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a4f6886518825734216b352" target="_blank" rel="noopener">线上压缩代码-定位错误 - 掘金</a></h2><p>生产环境没有source-map文件，上报的错误都不好定位，这里实现一个简单的错误定位脚本</p>
<p>1、获取压缩代码错误信息（行数、列数、错误信息，错误文件）</p>
<h2 id="这里通过控制台看错误信息"><a href="#这里通过控制台看错误信息" class="headerlink" title="这里通过控制台看错误信息"></a>这里通过控制台看错误信息</h2><pre><code>window.addEventListener(&apos;error&apos;, function (e) {
    console.debug(&apos;lineno: &apos;, e.lineno, &apos; colno: &apos;, e.colno)
    console.debug(&apos;errorMessage:&apos;, e.message)
    console.debug(&apos;errorFile:&apos;, e.filename)
}, true)
</code></pre><p>我们写一段错误的代码（single.vue的片段）</p>
<pre><code>method: {
   test (option) {
        const data = option.test
        const dataTest = option.data.test
        return data + dataTest
    }
}, 
created () {
    // 设置异步错误的原因是，同步的错误会被vue捕获
    setTimeout(() =&gt; {
        this.test({
          testOption: 1
        })
    }, 300)
}
</code></pre><p>在浏览器中运行，报错结果如下<br><img src="https://pic4.zhimg.com/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_hd.jpg" alt=""></p>
<p>得到错误信息：</p>
<ul>
<li>错误行数：1</li>
<li>错误列数：59236</li>
<li>错误信息：cannot read property ‘test’ of undefined</li>
<li>错误文件：0.0a77f.js</li>
</ul>
<p>2、定位错误的node脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## 安装依赖source-map</span><br><span class="line"></span><br><span class="line"> npm install source-map</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    node脚本如下（map/index.js）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> // 读取文件</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">// souceMap处理文件</span><br><span class="line">var SourceMapConsumer = require(&apos;source-map&apos;).SourceMapConsumer</span><br><span class="line">// 启动构建进程（已构建则不需要）</span><br><span class="line">var exec = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">var lineno = process.argv[2] || 0   // 第一个参数为行数</span><br><span class="line">var columnno = process.argv[3] || 0 // 第二个参数为列数</span><br><span class="line">var fileName = process.argv[4] || &apos;&apos; // 第三个参数为错误文件（错误文件名就好）</span><br><span class="line"></span><br><span class="line">// 构建有map的线上代码</span><br><span class="line">// node build onlineMap为构建命令</span><br><span class="line">exec(&apos;node build onlineMap&apos;, function () &#123;</span><br><span class="line"> // 读取错误文件的map文件</span><br><span class="line"> var consumer = new SourceMapConsumer(fs.readFileSync(&apos;./dist/&apos; + fileName + &apos;.map&apos;, &apos;utf8&apos;))</span><br><span class="line">  // 输出map的错误信息</span><br><span class="line">  console.log(consumer.originalPositionFor(&#123;</span><br><span class="line">    line: +lineno,      // +是为了转化为数字</span><br><span class="line">    column: +columnno</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">    运行node脚本</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> node map 1 59236 0.0a77f.js</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>效果如下：</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/v2-cf68e7b673405c90fe024bf48dfb42c7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf68e7b673405c90fe024bf48dfb42c7_hd.jpg" alt=""></p>
<p>结合控制台输出的信息，就可以定位到错误代码了</p>
<p>我们再来看一下，给代码开启source-map，看错误信息是否一致</p>
<p><img src="https://pic3.zhimg.com/v2-5319b431cef161a0a07ba46f8b0e6a02_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-5319b431cef161a0a07ba46f8b0e6a02_hd.jpg" alt=""><br>错误代码的位置定位是准确的，证明可行。</p>
<p>3、后续扩展思路</p>
<h2 id="目前实现的是比较简单的脚本，所以存在一些问题："><a href="#目前实现的是比较简单的脚本，所以存在一些问题：" class="headerlink" title="目前实现的是比较简单的脚本，所以存在一些问题："></a>目前实现的是比较简单的脚本，所以存在一些问题：</h2><ul>
<li>需要当前构建内容和线上是一致的</li>
<li>操作比较繁琐</li>
</ul>
<p>优化思路如下：</p>
<p><img src="https://pic4.zhimg.com/v2-a8b63ecc364c66c8bf4bbec9880f8c23_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a8b63ecc364c66c8bf4bbec9880f8c23_hd.jpg" alt=""></p>
<p>后续优化慢慢补充~</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在对公司的前端代码脚本错误进行排查，试图降低 JS Error 的错误量，结合自己之前的经验对这方面内容进行了实践并总结，下面就此谈谈我对前端代码异常监控的一些见解。</p>
<p>本文大致围绕下面几点展开讨论：</p>
<ol>
<li>JS 处理异常的方式</li>
<li>上报方式</li>
<li>异常监控上报常见问题</li>
</ol>
<h2 id="JS-异常处理"><a href="#JS-异常处理" class="headerlink" title="JS 异常处理"></a>JS 异常处理</h2><p>对于 Javascript 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>
<ol>
<li>当前代码块将作为一个任务压入任务队列中，JS 线程会不断地从任务队列中提取任务执行。</li>
<li>当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务的执行。</li>
<li><p>JS 线程会继续从任务队列中提取下一个任务继续执行。</p>
 <script>
   error
   console.log('永远不会执行');
 </script>
 <script>
   console.log('我继续执行')
 </script>


</li>
</ol>
<p><img src="https://pic2.zhimg.com/v2-7a136ce7674914bcd7b7f42986d0c5bc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7a136ce7674914bcd7b7f42986d0c5bc_hd.jpg" alt=""></p>
<p>在对脚本错误进行上报之前，我们需要对异常进行处理，程序需要先感知到脚本错误的发生，然后再谈异常上报。</p>
<p>脚本错误一般分为两种：语法错误，运行时错误。</p>
<p>下面就谈谈几种异常监控的处理方式：</p>
<h2 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h2><p>try-catch 在我们的代码中经常见到，通过给代码块进行 try-catch 进行包装后，当代码块发生出错时 catch 将能捕捉到错误的信息，页面也将可以继续执行。</p>
<p>但是 try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误和异步错误就显得无能为力，捕捉不到。</p>
<h2 id="示例：运行时错误"><a href="#示例：运行时错误" class="headerlink" title="示例：运行时错误"></a>示例：运行时错误</h2><pre><code>try {
  error    // 未定义变量 
} catch(e) {
  console.log(&apos;我知道错误了&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-dc8ba7e4b9e56127799c11b46cf7068d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-dc8ba7e4b9e56127799c11b46cf7068d_hd.jpg" alt=""></p>
<p>然而对于语法错误和异步错误就捕捉不到了。</p>
<h2 id="示例：语法错误"><a href="#示例：语法错误" class="headerlink" title="示例：语法错误"></a>示例：语法错误</h2><pre><code>try {
  var error = &apos;error&apos;；   // 大写分号
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-8ddf6acf0f42c4b08ba8b73798b863a0_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8ddf6acf0f42c4b08ba8b73798b863a0_hd.jpg" alt=""></p>
<p>一般语法错误在编辑器就会体现出来，常表现的错误信息为： Uncaught SyntaxError: Invalid or unexpected token xxx 这样。但是这种错误会直接抛出异常，常使程序崩溃，一般在编码时候容易观察得到。</p>
<h2 id="示例：异步错误"><a href="#示例：异步错误" class="headerlink" title="示例：异步错误"></a>示例：异步错误</h2><pre><code>try {
  setTimeout(() =&gt; {
    error        // 异步错误
  })
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic4.zhimg.com/v2-0ed67a00e3c7762e74975bebbbc88274_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-0ed67a00e3c7762e74975bebbbc88274_hd.jpg" alt=""></p>
<p>除非你在 setTimeout 函数中再套上一层 try-catch，否则就无法感知到其错误，但这样代码写起来比较啰嗦。</p>
<h2 id="window-onerror-异常处理"><a href="#window-onerror-异常处理" class="headerlink" title="window.onerror 异常处理"></a>window.onerror 异常处理</h2><p>window.onerror 捕获异常能力比 try-catch 稍微强点，无论是异步还是非异步错误，onerror 都能捕获到运行时错误。</p>
<p>示例：运行时同步错误</p>
<pre><code>/**
 * @param {String}  msg    错误信息
 * @param {String}  url    出错文件
 * @param {Number}  row    行号
 * @param {Number}  col    列号
 * @param {Object}  error  错误详细信息
 */
 window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
error;
</code></pre><p>示例：异步错误</p>
<pre><code>window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道异步错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
setTimeout(() =&gt; {
  error;
});
</code></pre><p><img src="https://pic3.zhimg.com/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_hd.jpg" alt=""></p>
<p>然而 window.onerror 对于语法错误还是无能为力，所以我们在写代码的时候要尽可能避免语法错误的，不过一般这样的错误会使得整个页面崩溃，还是比较容易能够察觉到的。</p>
<p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>
<p>需要注意的是，window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。</p>
<p><img src="https://pic3.zhimg.com/v2-875235a4876ea8429f12e7aaf2f19588_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-875235a4876ea8429f12e7aaf2f19588_hd.jpg" alt=""></p>
<p>关于 window.onerror 还有两点需要值得注意</p>
<ol>
<li>对于 onerror 这种全局捕获，最好写在所有 JS 脚本的前面，因为你无法保证你写的代码是否出错，如果写在后面，一旦发生错误的话是不会被 onerror 捕获到的。</li>
<li>另外 onerror 是无法捕获到网络异常的错误。</li>
</ol>
<p>当我们遇到 <code>&lt;img src=&quot;./404.png&quot;&gt;</code> 报 404 网络请求异常的时候，onerror 是无法帮助我们捕获到异常的。</p>
<pre><code>&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道异步错误了&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot;&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-81341c443f078b6526e0c6031dd40953_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81341c443f078b6526e0c6031dd40953_hd.jpg" alt=""></p>
<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>
<pre><code>&lt;script&gt;
window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我知道 404 错误了&apos;);
  console.log(
    msg, url, row, col, error
  );
  return true;
}, true);
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot; alt=&quot;&quot;&gt;
</code></pre><p><img src="https://pic4.zhimg.com/v2-6d1c1196acd800a4a4475ee6847ee82a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6d1c1196acd800a4a4475ee6847ee82a_hd.jpg" alt=""></p>
<p>这点知识还是需要知道，要不然用户访问网站，图片 CDN 无法服务，图片加载不出来而开发人员没有察觉就尴尬了。</p>
<h2 id="Promise-错误"><a href="#Promise-错误" class="headerlink" title="Promise 错误"></a>Promise 错误</h2><p>通过 Promise 可以帮助我们解决异步回调地狱的问题，但是一旦 Promise 实例抛出异常而你没有用 catch 去捕获的话，onerror 或 try-catch 也无能为力，无法捕捉到错误。</p>
<pre><code>window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我感知不到 promise 错误&apos;);
  console.log(
    msg, url, row, col, error
  );
}, true);
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic4.zhimg.com/v2-1ce580bb2344474b1df1517f2d11aa40_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-1ce580bb2344474b1df1517f2d11aa40_hd.jpg" alt=""></p>
<p>虽然在写 Promise 实例的时候养成最后写上 catch 函数是个好习惯，但是代码写多了就容易糊涂，忘记写 catch。</p>
<p>所以如果你的应用用到很多的 Promise 实例的话，特别是你在一些基于 promise 的异步库比如 axios 等一定要小心，因为你不知道什么时候这些异步请求会抛出异常而你并没有处理它，所以你最好添加一个 Promise 全局异常捕获事件 <strong>unhandledrejection</strong>。</p>
<pre><code>window.addEventListener(&quot;unhandledrejection&quot;, function(e){
  e.preventDefault()
  console.log(&apos;我知道 promise 的错误了&apos;);
  console.log(e.reason);
  return true;
});
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic2.zhimg.com/v2-115d494f26e4f8e2172e1f3b4cb6094f_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-115d494f26e4f8e2172e1f3b4cb6094f_hd.jpg" alt=""></p>
<p>当然，如果你的应用没有做 Promise 全局异常处理的话，那很可能就像某乎首页这样：</p>
<p><img src="https://pic2.zhimg.com/v2-37c6bc3763c147a4c97bdde688a59a5c_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-37c6bc3763c147a4c97bdde688a59a5c_hd.jpg" alt=""></p>
<h2 id="异常上报方式"><a href="#异常上报方式" class="headerlink" title="异常上报方式"></a>异常上报方式</h2><p>监控拿到报错信息之后，接下来就需要将捕捉到的错误信息发送到信息收集平台上，常用的发送形式主要有两种:</p>
<ol>
<li>通过 Ajax 发送数据</li>
<li>动态创建 img 标签的形式</li>
</ol>
<p>实例 - 动态创建 img 标签进行上报</p>
<pre><code>function report(error) {
  var reportUrl = &apos;http://xxxx/report&apos;;
  new Image().src = reportUrl + &apos;error=&apos; + error;
}
</code></pre><h2 id="监控上报常见问题"><a href="#监控上报常见问题" class="headerlink" title="监控上报常见问题"></a>监控上报常见问题</h2><p>下述例子我全部放在我的 github 上，读者可以自行查阅，后面不再赘述。</p>
<pre><code>git clone https://github.com/happylindz/blog.git
cd blog/code/jserror/
npm install
</code></pre><h2 id="Script-error-脚本错误是什么"><a href="#Script-error-脚本错误是什么" class="headerlink" title="Script error 脚本错误是什么"></a>Script error 脚本错误是什么</h2><p>因为我们在线上的版本，经常做静态资源 CDN 化，这就会导致我们常访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。</p>
<p><img src="https://pic3.zhimg.com/v2-840f71bf7014767132b47ad2c6a37238_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-840f71bf7014767132b47ad2c6a37238_hd.jpg" alt=""></p>
<p>可通过 <code>npm run nocors</code> 查看效果。</p>
<p>Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。</p>
<p><img src="https://pic2.zhimg.com/v2-fc3941d89716f96374576d0426ff4ccb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-fc3941d89716f96374576d0426ff4ccb_hd.jpg" alt=""></p>
<p>这样做的目的是避免数据泄露到不安全的域中，举个简单的例子，</p>
<pre><code>&lt;script src=&quot;xxxx.com/login.html&quot;&gt;&lt;/script&gt;
</code></pre><p>上面我们并没有引入一个 js 文件，而是一个 html，这个 html 是银行的登录页面，如果你已经登录了，那 login 页面就会自动跳转到 <code>Welcome xxx...</code>，如果未登录则跳转到 <code>Please Login...</code>，那么报错也会是 <code>Welcome xxx... is not defined，Please Login... is not defined</code>，通过这些信息可以判断一个用户是否登录他的帐号，给入侵者提供了十分便利的判断渠道，这是相当不安全的。</p>
<p>介绍完背景后，那么我们应该去解决这个问题？</p>
<p>首先可以想到的方案肯定是同源化策略，将 JS 文件内联到 html 或者放到同域下，虽然能简单有效地解决 script error 问题，但是这样无法利用好文件缓存和 CDN 的优势，不推荐使用。正确的方法应该是从根本上解决 script error 的错误。</p>
<h2 id="跨源资源共享机制-CORS"><a href="#跨源资源共享机制-CORS" class="headerlink" title="跨源资源共享机制( CORS )"></a>跨源资源共享机制( CORS )</h2><p>首先为页面上的 script 标签添加 crossOrigin 属性</p>
<pre><code>// http://localhost:8080/index.html
&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;script src=&quot;http://localhost:8081/test.js&quot; crossorigin&gt;&lt;/script&gt;

// http://localhost:8081/test.js
setTimeout(() =&gt; {
  console.log(error);
});
</code></pre><p>当你修改完前端代码后，你还需要额外给后端在响应头里加上 <code>Access-Control-Allow-Origin: localhost:8080</code>，这里我以 Koa 为例。</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const path = require(&apos;path&apos;);
const cors = require(&apos;koa-cors&apos;);
const app = new Koa();

app.use(cors());
app.use(require(&apos;koa-static&apos;)(path.resolve(__dirname, &apos;./public&apos;)));

app.listen(8081, () =&gt; {
  console.log(&apos;koa app listening at 8081&apos;)
});
</code></pre><p><img src="https://pic1.zhimg.com/v2-9717062e56340cef40ee67b438b2ba95_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-9717062e56340cef40ee67b438b2ba95_hd.jpg" alt=""></p>
<p>读者可通过 <code>npm run cors</code> 详细的跨域知识我就不展开了，有兴趣可以看看我之前写的文章：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>你以为这样就完了吗？并没有，下面就说一些 Script error 你不常遇见的点：</p>
<p>我们都知道 JSONP 是用来跨域获取数据的，并且兼容性良好，在一些应用中仍然会使用到，所以你的项目中可能会用这样的代码：</p>
<pre><code>// http://localhost:8080/index.html
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，但不知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
function jsonpCallback(data) {
  console.log(data);
}
const url = &apos;http://localhost:8081/data?callback=jsonpCallback&apos;;
const script = document.createElement(&apos;script&apos;);
script.src = url;
document.body.appendChild(script);
</code></pre><p>因为返回的信息会当做脚本文件来执行，一旦返回的脚本内容出错了，也是无法捕捉到错误的信息。</p>
<p><img src="https://pic4.zhimg.com/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_hd.jpg" alt=""></p>
<p>解决办法也不难，跟之前一样，在添加动态添加脚本的时候加上 crossOrigin，并且在后端配上相应的 CORS 字段即可.</p>
<pre><code>const script = document.createElement(&apos;script&apos;);
script.crossOrigin = &apos;anonymous&apos;;
script.src = url;
document.body.appendChild(script);
</code></pre><p>读者可以通过 <code>npm run jsonp</code> 查看效果</p>
<p><img src="https://pic4.zhimg.com/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_hd.jpg" alt=""></p>
<p>知道原理之后你可能会觉得没什么，不就是给每个动态生成的脚本添加 crossOrigin 字段嘛，但是在实际工程中，你可能是面向很多库来编程，比如使用 jQuery，Seajs 或者 webpack 来异步加载脚本，许多库封装了异步加载脚本的能力，以 jQeury 为例你可能是这样来触发异步脚本。</p>
<pre><code>$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>假如这些库中没有提供 crossOrigin 的能力的话(jQuery jsonp 可能有，假装你不知道)，那你只能去修改人家写的源代码了，所以我这里提供一个思路，就是去劫持 document.createElement，从根源上去为每个动态生成的脚本添加 crossOrigin 字段。</p>
<pre><code>document.createElement = (function() {
  const fn = document.createElement.bind(document);
  return function(type) {
    const result = fn(type);
    if(type === &apos;script&apos;) {
      result.crossOrigin = &apos;anonymous&apos;;
    }
    return result;
  }
})();
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，也知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>效果也是一样的，读者可以通过 <code>npm run jsonpjq</code> 来查看效果：</p>
<p><img src="https://pic4.zhimg.com/v2-30d51a96cdb3286edd1e5a88e9f794bb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-30d51a96cdb3286edd1e5a88e9f794bb_hd.jpg" alt=""></p>
<p>这样重写 createElement 理论上没什么问题，但是入侵了原本的代码，不保证一定不会出错，在工程上还是需要多尝试下看看再使用，可能存在兼容性上问题，如果你觉得会出现什么问题的话也欢迎留言讨论下。</p>
<p>关于 Script error 的问题就写到这里，如果你理解了上面的内容，基本上绝大部分的 Script error 都能迎刃而解。</p>
<h2 id="window-onerror-能否捕获-iframe-的错误"><a href="#window-onerror-能否捕获-iframe-的错误" class="headerlink" title="window.onerror 能否捕获 iframe 的错误"></a>window.onerror 能否捕获 iframe 的错误</h2><p>当你的页面有使用 iframe 的时候，你需要对你引入的 iframe 做异常监控的处理，否则一旦你引入的 iframe 页面出现了问题，你的主站显示不出来，而你却浑然不知。</p>
<p>首先需要强调，父窗口直接使用 window.onerror 是无法直接捕获，如果你想要捕获 iframe 的异常的话，有分好几种情况。</p>
<p>如果你的 iframe 页面和你的主站是同域名的话，直接给 iframe 添加 onerror 事件即可。</p>
<pre><code>&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  window.frames[0].onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道 iframe 的错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
</code></pre><p>读者可以通过 <code>npm run iframe</code> 查看效果：</p>
<p><img src="https://pic2.zhimg.com/v2-3edcb5686e27ab11f5f3c9c1644986d0_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3edcb5686e27ab11f5f3c9c1644986d0_hd.jpg" alt=""></p>
<p>如果你嵌入的 iframe 页面和你的主站不是同个域名的，但是 iframe 内容不属于第三方，是你可以控制的，那么可以通过与 iframe 通信的方式将异常信息抛给主站接收。与 iframe 通信的方式有很多，常用的如：postMessage，hash 或者 name 字段跨域等等，这里就不展开了，感兴趣的话可以看：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>如果是非同域且网站不受自己控制的话，除了通过控制台看到详细的错误信息外，没办法捕获，这是出于安全性的考虑，你引入了一个百度首页，人家页面报出的错误凭啥让你去监控呢，这会引出很多安全性的问题。</p>
<h2 id="压缩代码如何定位到脚本异常位置"><a href="#压缩代码如何定位到脚本异常位置" class="headerlink" title="压缩代码如何定位到脚本异常位置"></a>压缩代码如何定位到脚本异常位置</h2><p>线上的代码几乎都经过了压缩处理，几十个文件打包成了一个并丑化代码，当我们收到 <code>a is not defined</code> 的时候，我们根本不知道这个变量 a 究竟是什么含义，此时报错的错误日志显然是无效的。</p>
<p>第一想到的办法是利用 sourcemap 定位到错误代码的具体位置，详细内容可以参考：<a href="https://link.zhihu.com/?target=https%3A//github.com/joeyguo/blog/issues/14" target="_blank" rel="noopener">Sourcemap 定位脚本错误</a></p>
<p>另外也可以通过在打包的时候，在每个合并的文件之间添加几行空格，并相应加上一些注释，这样在定位问题的时候很容易可以知道是哪个文件报的错误，然后再通过一些关键词的搜索，可以快速地定位到问题的所在位置。</p>
<h2 id="收集异常信息量太多，怎么办"><a href="#收集异常信息量太多，怎么办" class="headerlink" title="收集异常信息量太多，怎么办"></a>收集异常信息量太多，怎么办</h2><p>如果你的网站访问量很大，假如网页的 PV 有 1kw，那么一个必然的错误发送的信息就有 1kw 条，我们可以给网站设置一个采集率：</p>
<pre><code>Reporter.send = function(data) {
  // 只采集 30%
  if(Math.random() &lt; 0.3) {
    send(data)      // 上报错误信息
  }
}
</code></pre><p>这个采集率可以通过具体实际的情况来设定，方法多样化，可以使用一个随机数，也可以具体根据用户的某些特征来进行判定。</p>
<p>上面差不多是我对前端代码监控的一些理解，说起来容易，但是一旦在工程化运用，难免需要考虑到兼容性等种种问题，读者可以通过自己的具体情况进行调整，前端代码异常监控对于我们的网站的稳定性起着至关重要的作用。如若文中所有不对的地方，还望指正。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/JS之call和apply-bind的模拟实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/JS之call和apply-bind的模拟实现/" itemprop="url">JS之call和apply,bind的模拟实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T22:39:16+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>一句话介绍 call：</p>
<blockquote>
<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
</blockquote>
<p>举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
</code></pre><p>注意两点：</p>
<ol>
<li>call 改变了 this 的指向，指向到 foo</li>
<li>bar 函数执行了</li>
</ol>
<h2 id="模拟实现第一步"><a href="#模拟实现第一步" class="headerlink" title="模拟实现第一步"></a>模拟实现第一步</h2><p>那么我们该怎么模拟实现这两个效果呢？</p>
<p>试想当调用 call 的时候，把 foo 对象改造成如下：</p>
<pre><code>var foo = {
    value: 1,
    bar: function() {
        console.log(this.value)
    }
};

foo.bar(); // 1
</code></pre><p>这个时候 this 就指向了 foo，是不是很简单呢？</p>
<p>但是这样却给 foo 对象本身添加了一个属性，这可不行呐！</p>
<p>不过也不用担心，我们用 delete 再删除它不就好了~</p>
<p>所以我们模拟的步骤可以分为：</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<p>以上个例子为例，就是：</p>
<pre><code>// 第一步
foo.fn = bar
// 第二步
foo.fn()
// 第三步
delete foo.fn
</code></pre><p>fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。</p>
<p>根据这个思路，我们可以尝试着去写第一版的 call2 函数：</p>
<pre><code>// 第一版
Function.prototype.call2 = function(context) {
    // 首先要获取调用call的函数，用this可以获取
    context.fn = this;
    context.fn();
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call2(foo); // 1
</code></pre><p>正好可以打印 1 哎！是不是很开心！(～￣▽￣)～</p>
<h2 id="模拟实现第二步"><a href="#模拟实现第二步" class="headerlink" title="模拟实现第二步"></a>模拟实现第二步</h2><p>最一开始也讲了，call 函数还能给定参数执行函数。举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call(foo, &apos;kevin&apos;, 18);
// kevin
// 18
// 1
</code></pre><p>注意：传入的参数并不确定，这可咋办？</p>
<p>不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。</p>
<p>比如这样：</p>
<pre><code>// 以上个例子为例，此时的arguments为：
// arguments = {
//      0: foo,
//      1: &apos;kevin&apos;,
//      2: 18,
//      length: 3
// }
// 因为arguments是类数组对象，所以可以用for循环
var args = [];
for(var i = 1, len = arguments.length; i &lt; len; i++) {
    args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
}

// 执行后 args为 [foo, &apos;kevin&apos;, 18]
</code></pre><p>不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。</p>
<pre><code>// 将数组里的元素作为多个参数放进函数的形参里
context.fn(args.join(&apos;,&apos;))
// (O_o)??
// 这个方法肯定是不行的啦！！！
</code></pre><p>也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样：</p>
<pre><code>eval(&apos;context.fn(&apos; + args +&apos;)&apos;)
</code></pre><p>这里 args 会自动调用 Array.toString() 这个方法。</p>
<p>所以我们的第二版克服了两个大问题，代码如下：</p>
<pre><code>// 第二版
Function.prototype.call2 = function(context) {
    context.fn = this;
    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }
    eval(&apos;context.fn(&apos; + args +&apos;)&apos;);
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call2(foo, &apos;kevin&apos;, 18); 
// kevin
// 18
// 1
</code></pre><p>(๑•̀ㅂ•́) ✧</p>
<h2 id="模拟实现第三步"><a href="#模拟实现第三步" class="headerlink" title="模拟实现第三步"></a>模拟实现第三步</h2><p>模拟代码已经完成 80%，还有两个小点要注意：</p>
<p>1.this 参数可以传 null，当为 null 的时候，视为指向 window</p>
<p>举个例子：</p>
<pre><code>var value = 1;

function bar() {
    console.log(this.value);
}

bar.call(null); // 1
</code></pre><p>虽然这个例子本身不使用 call，结果依然一样。</p>
<p>2.函数是可以有返回值的！</p>
<p>举个例子：</p>
<pre><code>var obj = {
    value: 1
}

function bar(name, age) {
    return {
        value: this.value,
        name: name,
        age: age
    }
}

console.log(bar.call(obj, &apos;kevin&apos;, 18));
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>不过都很好解决，让我们直接看第三版也就是最后一版的代码：</p>
<pre><code>// 第三版
Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);

    delete context.fn
    return result;
}

// 测试一下
var value = 2;

var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call(null); // 2

console.log(bar.call2(obj, &apos;kevin&apos;, 18));
// 1
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ</p>
<h2 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h2><p>apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现：</p>
<pre><code>Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push(&apos;arr[&apos; + i + &apos;]&apos;);
        }
        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)
    }

    delete context.fn
    return result;
}
</code></pre><p><img src="https://pic1.zhimg.com/v2-23784bc5e0ab2bdcb4b879e5d28617c6_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-23784bc5e0ab2bdcb4b879e5d28617c6_hd.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-9374916fd3f03dab5836b9fc4057070a_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-9374916fd3f03dab5836b9fc4057070a_hd.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-7fe454d5cfd72880650f53a4f50c93cd_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-7fe454d5cfd72880650f53a4f50c93cd_hd.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-4f15656852b764a859194a3d7156ea99_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-4f15656852b764a859194a3d7156ea99_hd.jpg" alt=""></p>
<pre><code>类数组转对象
在上面的例子中已经提到了一种类数组转数组的方法，再补充三个：
var arrayLike = {0: &apos;name&apos;, 1: &apos;age&apos;, 2: &apos;sex&apos;, length: 3 }
// 1. slice
Array.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 2. splice
Array.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 3. ES6 Array.from
Array.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 4. apply
Array.prototype.concat.apply([], arrayLike)   




要说到类数组对象，Arguments 对象就是一个类数组对象。
在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。


传递参数
将参数从一个函数传递到另一个函数
// 使用 apply 将 foo 的参数传递给 bar
function foo() {
    bar.apply(this, arguments);
}
function bar(a, b, c) {
   console.log(a, b, c);
}

foo(1, 2, 3)




强大的ES6
使用ES6的 ... 运算符，我们可以轻松转成数组。
function func(...arguments) {
    console.log(arguments); // [1, 2, 3]
}

func(1, 2, 3);
</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>一句话介绍 bind:</p>
<blockquote>
<p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p>
</blockquote>
<p>由此我们可以首先得出 bind 函数的两个特点：</p>
<ol>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ol>
<h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><p>从第一个特点开始，我们举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

// 返回了一个函数
var bindFoo = bar.bind(foo); 

bindFoo(); // 1
</code></pre><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">《JavaScript深入之call和apply的模拟实现》</a>。我们来写第一版的代码：</p>
<pre><code>// 第一版
Function.prototype.bind2 = function (context) {
    var self = this;
    return function () {
        self.apply(context);
    }

}
</code></pre><h2 id="传参的模拟实现"><a href="#传参的模拟实现" class="headerlink" title="传参的模拟实现"></a>传参的模拟实现</h2><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(this.value);
    console.log(name);
    console.log(age);

}

var bindFoo = bar.bind(foo, &apos;daisy&apos;);
bindFoo(&apos;18&apos;);
// 1
// daisy
// 18
</code></pre><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p>
<p>这可咋办？不急，我们用 arguments 进行处理：</p>
<pre><code>// 第二版
Function.prototype.bind2 = function (context) {

    var self = this;
    // 获取bind2函数从第二个参数到最后一个参数
    var args = Array.prototype.slice.call(arguments, 1);

    return function () {
        // 这个时候的arguments是指bind返回的函数传入的参数
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(context, args.concat(bindArgs));
    }

}
</code></pre><h2 id="构造函数效果的模拟实现"><a href="#构造函数效果的模拟实现" class="headerlink" title="构造函数效果的模拟实现"></a>构造函数效果的模拟实现</h2><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p>
<blockquote>
<p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
</blockquote>
<p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p>
<pre><code>var value = 2;

var foo = {
    value: 1
};

function bar(name, age) {
    this.habit = &apos;shopping&apos;;
    console.log(this.value);
    console.log(name);
    console.log(age);
}

bar.prototype.friend = &apos;kevin&apos;;

var bindFoo = bar.bind(foo, &apos;daisy&apos;);

var obj = new bindFoo(&apos;18&apos;);
// undefined
// daisy
// 18
console.log(obj.habit);
console.log(obj.friend);
// shopping
// kevin
</code></pre><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p>
<p>(哈哈，我这是为我的下一篇文章<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">《JavaScript深入系列之new的模拟实现》</a>打广告)。</p>
<p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p>
<pre><code>// 第三版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
        self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
    }
    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
    fBound.prototype = this.prototype;
    return fBound;
}
</code></pre><p>如果对原型链稍有困惑，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">《JavaScript深入之从原型到原型链》</a>。</p>
<h2 id="构造函数效果的优化实现"><a href="#构造函数效果的优化实现" class="headerlink" title="构造函数效果的优化实现"></a>构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p>
<pre><code>// 第四版
Function.prototype.bind2 = function (context) {

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
</code></pre><p>到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ</p>
<h2 id="三个小问题"><a href="#三个小问题" class="headerlink" title="三个小问题"></a>三个小问题</h2><p>接下来处理些小问题:</p>
<p>1.apply 这段代码跟 MDN 上的稍有不同</p>
<p>在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：</p>
<pre><code>self.apply(this instanceof self ? this : context || this, args.concat(bindArgs))
</code></pre><p>多了一个关于 context 是否存在的判断，然而这个是错误的！</p>
<p>举个例子：</p>
<pre><code>var value = 2;
var foo = {
    value: 1,
    bar: bar.bind(null)
};

function bar() {
    console.log(this.value);
}

foo.bar() // 2
</code></pre><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！</p>
<p>所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！</p>
<p>2.调用 bind 的不是函数咋办？</p>
<p>不行，我们要报错！</p>
<pre><code>if (typeof this !== &quot;function&quot;) {
  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}
</code></pre><p>3.我要在线上用</p>
<p>那别忘了做个兼容：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function () {
    ……
};
</code></pre><p>当然最好是用 <a href="https://link.zhihu.com/?target=https%3A//github.com/es-shims/es5-shim" target="_blank" rel="noopener">es5-shim</a> 啦。</p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>所以最最后的代码就是：</p>
<pre><code>Function.prototype.bind2 = function (context) {

    if (typeof this !== &quot;function&quot;) {
      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/31/JavaScript-中的-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/31/JavaScript-中的-this/" itemprop="url">JavaScript 中的 this !</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-31T22:53:27+08:00">
                2018-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 js 中，this 这个上下文总是变化莫测，很多时候出现 bug 总是一头雾水，其实，只要分清楚不同的情况下如何执行就 ok 了。</p>
<p><img src="https://pic4.zhimg.com/v2-3068deaab983c4e925d5b325985ce9e9_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3068deaab983c4e925d5b325985ce9e9_hd.jpg" alt=""></p>
<h2 id="全局执行"><a href="#全局执行" class="headerlink" title="全局执行"></a>全局执行</h2><p>首先，我们在全局环境中看看它的 this 是什么：</p>
<p>first. 浏览器：</p>
<pre><code>console.log(this);

// Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}
</code></pre><p>可以看到打印出了 window 对象；</p>
<p>second. node：</p>
<pre><code>console.log(this);

// global
</code></pre><p>可以看到打印出了 global 对象；</p>
<p>总结：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。</p>
<h2 id="函数中执行"><a href="#函数中执行" class="headerlink" title="函数中执行"></a>函数中执行</h2><h2 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h2><p>这是最普通的函数使用方法了：</p>
<pre><code>function test() {
  console.log(this);
};

test();

// Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}
</code></pre><p>我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象；</p>
<p>严格模式 ‘use strict’;</p>
<p>如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为：</p>
<pre><code>&apos;use strict&apos;;
function test() {
  console.log(this);
};

test();

// undefined
</code></pre><p>当然，把它放在一个立即执行函数中会更好，避免了污染全局：</p>
<pre><code>(function (){
  &quot;use strict&quot;;
　console.log(this);
})();

// undefined
</code></pre><h2 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h2><p>当一个函数被当作一个对象的方法调用的时候：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this.name);
  }
}

obj.foo();

// &apos;qiutc&apos;
</code></pre><p>这时候，this 指向当前的这个对象；</p>
<p>当然，我们还可以这么做：</p>
<pre><code>function test() {
  console.log(this.name);
}
var obj = {
  name: &apos;qiutc&apos;,
  foo: test
}

obj.foo();

// &apos;qiutc&apos;
</code></pre><p>同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 test ，它只是一个函数名，函数的引用，它指向这个函数，当 foo = test，foo 同样也指向了这个函数。</p>
<p>如果把对象的方法赋值给一个变量，然后直接调用这个变量呢：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  }
}

var test = obj.foo;
test();

// Window
</code></pre><p>可以看到，这时候 this 执行了全局，当我们把 test = obj.foo ，test 直接指向了一个函数的引用，这时候，其实和 obj 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，this 指向全局对象。</p>
<p>一些坑</p>
<p>我们经常在回调函数里面会遇到一些坑：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);   //Object {name: &quot;qiutc&quot;...}
    setTimeout(this.foo, 1000);   // window 对象
  }
}

obj.foo2();
</code></pre><p><img src="https://pic1.zhimg.com/v2-2099857fcaab02a66d655f172d12cf82_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-2099857fcaab02a66d655f172d12cf82_hd.jpg" alt=""></p>
<p>执行这段代码我们会发现两次打印出来的 this 是不一样的：</p>
<p>关于setTimeout的this指向：<a href="https://link.zhihu.com/?target=https%3A//www.talkingcoder.com/article/6356947525374513523" target="_blank" rel="noopener">https://www.talkingcoder.com/article/6356947525374513523</a></p>
<pre><code>第一次是 foo2 中直接打印 this，这里指向 obj 这个对象，我们毋庸置疑；
</code></pre><p>但是在 setTimeout 中执行的 this.foo，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑；<br>其实，setTimeout 也只是一个函数而已，函数必然有可能需要参数，我们把 this.foo 当作一个参数传给 setTimeout 这个函数，就像它需要一个 fun 参数，在传入参数的时候，其实做了个这样的操作 fun = this.foo，看到没有，这里我们直接把 fun 指向 this.foo 的引用；执行的时候其实是执行了 fun() 所以已经和 obj 无关了，它是被当作普通函数直接调用的，因此 this 指向全局对象。</p>
<p>这个问题是很多异步回调函数中普遍会碰到的；</p>
<p>解决</p>
<p>为了解决这个问题，我们可以利用 闭包 的特性来处理：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);
    var _this = this;
    setTimeout(function() {
      console.log(this);  // Window

      console.log(_this);  // Object {name: &quot;qiutc&quot;}
    }, 1000);
  }
}

obj.foo2();
</code></pre><p>可以看到直接用 this 仍然是 Window；因为 foo2 中的 this 是指向 obj，我们可以先用一个变量 _this 来储存，然后在回调函数中使用 _this，就可以指向当前的这个对象了；</p>
<p>setTimeout 的另一个坑</p>
<p>之前啊说过，如果直接执行回调函数而没有绑定作用域，那么它的 this 是指向全局对象(window)，在严格模式下会指向 undefined，然而在 setTimeout 中的回调函数在严格模式下却表现出不同：</p>
<pre><code>&apos;use strict&apos;;

function foo() {
  console.log(this);
}

setTimeout(foo, 1);

// window
</code></pre><p>按理说我们加了严格模式，foo 调用也没有指定 this，应该是出来 undefined，但是这里仍然出现了全局对象，难道是严格模式失效了吗？</p>
<p>并不，即使在严格模式下，setTimeout 方法在调用传入函数的时候，如果这个函数没有指定了的 this，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 foo.apply(window) 而非 foo()；</p>
<p>当然，如果我们在传入函数的时候已经指定 this，那么就不会被注入全局对象，比如： setTimeout(foo.bind(obj), 1);；</p>
<p><a href="https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code" target="_blank" rel="noopener">http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code</a></p>
<h2 id="作为一个构造函数使用"><a href="#作为一个构造函数使用" class="headerlink" title="作为一个构造函数使用"></a>作为一个构造函数使用</h2><p>在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 new 这个关键字：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var p = new Person(&apos;qiutc&apos;);

// Person {name: &quot;qiutc&quot;}
</code></pre><p>我们可以看到当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象；</p>
<p>当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var p = Person(&apos;qiutc&apos;);

// Window
</code></pre><p>其区别在于，如何调用函数（new）。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 this 的指向了，还记得在上文中（作为对象的方法调用-一些坑-解决）我们使用闭包来解决 this 的指向问题吗，如果用上了箭头函数就可以更完美的解决了：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);
    setTimeout(() =&gt; {
      console.log(this);  // Object {name: &quot;qiutc&quot;}
    }, 1000);
  }
}

obj.foo2();
</code></pre><p>可以看到，在 setTimeout 执行的函数中，本应该打印出在 Window，但是在这里 this 却指向了 obj，原因就在于，给 setTimeout 传入的函数（参数）是一个箭头函数：</p>
<blockquote>
<p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
</blockquote>
<p>根据例子我们理解一下这句话：<br>在 obj.foo2() 执行的时候，当前的 this 指向 obj；在执行 setTimeout 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 this 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 this，也就是 obj.foo2 中的 this，即 obj；所以在执行箭头函数的时候，它的 this -&gt; obj.foo2 中的 this -&gt; obj；</p>
<p>简单来说， 箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。</p>
<h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h2><p>在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向：</p>
<ul>
<li>call</li>
</ul>
<p>fun.call(thisArg[, arg1[, arg2[, …]]])</p>
<p>它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，后面的参数是执行函数需要传入的参数；</p>
<ul>
<li>apply</li>
</ul>
<p>fun.apply(thisArg[, [arg1, arg2, …]])</p>
<p>它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）；</p>
<ul>
<li>bind</li>
</ul>
<p>var foo = fun.bind(thisArg[, arg1[, arg2[, …]]]);</p>
<p>它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数；</p>
<p>这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this），我们以 call 函数为例；</p>
<p>为一个普通函数指定 this</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;
};

function foo() {
  console.log(this);
}

foo.call(obj);

// Object {name: &quot;qiutc&quot;}
</code></pre><p>可以看到，在执行 foo.call(obj) 的时候，函数内的 this 指向了 obj 这个对象，成功；</p>
<p>为对象中的方法指定一个 this</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function () {
    console.log(this);
  }
}

var obj2 = {
  name: &apos;tcqiu222222&apos;
};

obj.foo.call(obj2);

// Object {name: &quot;tcqiu222222&quot;}
</code></pre><p>可以看到，执行函数的时候这里的 this 指向了 obj2，成功；</p>
<p>为构造函数指定 this</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var p = new Person.call(obj, &apos;qiutc&apos;);

// Uncaught TypeError: Person.call is not a constructor(…)
</code></pre><p>这里报了个错，原因是我们去 new 了 Person.call 函数，而非 Person ，这里的函数不是一个构造函数；</p>
<p>换成 bind 试试：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var Person2 = Person.bind(obj);

var p = new Person2(&apos;qiutc&apos;);

// Person {name: &quot;qiutc&quot;}

console.log(obj);

// Object {name: &quot;qiutc2222222&quot;}
</code></pre><p>打印出来的是 Person 实例化出来的对象，而和 obj 没有关系，而 obj 也没有发生变化，说明，我们给 Person 指定 this 上下文并没有生效；</p>
<p>因此可以得出： 使用 bind 给一个构造函数指定 this，在 new 这个构造函数的时候，bind 函数所指定的 this 并不会生效；</p>
<p>当然 bind 不仅可以指定 this ，还能传入参数，我们来试试这个操作：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var Person2 = Person.bind(obj, &apos;qiutc111111&apos;);

var p = new Person2(&apos;qiutc&apos;);

// Person {name: &quot;qiutc111111&quot;}
</code></pre><p>可以看到，虽然指定 this 不起作用，但是传入参数还是起作用了；</p>
<p>为箭头函数指定 this</p>
<p>我们来定义一个全局下的箭头函数，因此这个箭头函数中的 this 必然会指向全局对象，如果用 call 方法改变 this 呢：</p>
<pre><code>var afoo = (a) =&gt; {
  console.log(a);
  console.log(this);
}

afoo(1);

// 1
// Window

var obj = {
  name: &apos;qiutc&apos;
};

afoo.call(obj, 2);

// 2
// Window
</code></pre><p>可以看到，这里的 call 指向 this 的操作并没有成功，所以可以得出： 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this。</p>
<p>只要记住箭头函数大法好，不变的 this。</p>
<p>Function.prototype.call</p>
<ul>
<li>格式:fx.call( thisArg [，arg1，arg2，… ] );</li>
</ul>
<ol>
<li><p>call的传参个数不限,第一个数表示调用函数(fx)函数体内this的指向.从第二个参数开始依次按序传入函数.</p>
<p> var age = 40;<br> var xiaoMing = {</p>
<pre><code>age:30
</code></pre><p> };<br> var xiaoLi = {</p>
<pre><code>age: 20
</code></pre><p> };<br> var getAge = function(){</p>
<pre><code>console.log(this.age);
</code></pre><p> };<br>  getAge.call( xiaoMing );  //30 表示函数this指向xiaoMing<br> getAge.call(xiaoLi);  //20  表示函数this指向xiaoLi<br> getAge.call(undefined);//40  getAge.call(undefined)==getAge.call(null)<br> getAge.call(null);//40<br> getAge(); //40</p>
</li>
</ol>
<p>如果我们传入fx.call()的第一个参数数为null,那么表示函数fx体内this指向宿主对象,在浏览器是Window对象,这也解释了getAge.call(undefined);//40。</p>
<p>在此基础我们可以理解为 getAge()相当于getAge.call(null/undefined),扩展到所有函数,<br>fx()==fx.call(null) == fx.call(undefined)</p>
<p>值得注意的是严格模式下有点区别: this指向null</p>
<pre><code>var getAge = function(){
&apos;use strict&apos;
console.log(this.age);
};
getAge(null);//报错 age未定义
</code></pre><p>再来理解this的使用</p>
<p>this的常用场景:</p>
<ul>
<li><p>this位于一个对象的方法内,此时this指向该对象</p>
<p>  var name = ‘window’;</p>
<p>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {
    console.log(this == Student); //true
    console.log(this.name);  //kobe
}
</code></pre><p>  }</p>
<p>  Student.getName();</p>
<p>  var name = ‘window’;<br>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {
            var name=100;
    console.log(this == Student); //true
    console.log(this.name);  //kobe
}
</code></pre><p>  }<br>  Student.getName();   //getName取得是Student 的name</p>
</li>
</ul>
<ul>
<li><p>this位于一个普通的函数内,表示this指向全局对象,(浏览器是window)</p>
<p>  var name = ‘window’;</p>
<p>  var getName = function () {</p>
<pre><code>var name = &apos;kobe&apos;;  //迷惑性而已
return this.name;
</code></pre><p>  }</p>
<p>  console.log(  getName() ); //window</p>
</li>
</ul>
<ul>
<li><p>this使用在构造函数(构造器)里面,表示this指向的是那个返回的对象.</p>
<p>  var name = ‘window’;<br>  //构造器<br>  var Student = function () {</p>
<pre><code>this.name = &apos;student&apos;;
</code></pre><p>  }</p>
<p>  var s1 = new Student();<br>  console.log(s1.name);  //student</p>
</li>
</ul>
<p>注意: 如果构造器返回的也是一个Object的对象(其他类型this指向不变遵循之前那个规律),这时候this指的是返回的这个Objec.</p>
<pre><code>var name = &apos;window&apos;;
//构造器
var Student = function () {
    this.name = &apos;student&apos;;
    return {
        name: &apos;boyStudent&apos;
    }
}

var s1 = new Student();
console.log(s1.name);  //boyStudent
</code></pre><ul>
<li><p>this指向失效问题</p>
<p>  var name = ‘window’;</p>
<p>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {        
    console.log(this.name);  
}
</code></pre><p>  }</p>
<p>  Student.getName(); // kobe<br>  var s1 = Student.getName;<br>  s1(); //window</p>
</li>
</ul>
<p>原因: 此时s1是一个函数</p>
<pre><code>function () {        
        console.log(this.name);  
    }
</code></pre><p>对一个基本的函数,前面提过this在基本函数中指的是window.</p>
<ul>
<li>在开发中我们经常使用的this缓存法 ,缓存当前作用域下this到另外一个环境域下使用</li>
</ul>
<blockquote>
<p>最后理解apply的用法 Function.prototype.apply</p>
</blockquote>
<p>格式: fx.apply(thisArg [，argArray] ); // 参数数组，argArray</p>
<ol>
<li>apply与call的作用是一样的,只是传参方式不同,</li>
<li><p>apply接受两个参数,第一个也是fx函数体内this的指向,用法与call第一个参数一致.第二个参数是数组或者类数组,apply就是把这个数组元素传入函数fx.</p>
<p> var add = function (a ,b ,c) {</p>
<pre><code>console.log(a +b +c);
</code></pre><p> }</p>
<p> add.apply(null , [1,2,3]); // 6</p>
</li>
</ol>
<p>再吃透这个题目就ok</p>
<pre><code>var a=10;
var foo={
  a:20,
  bar:function(){
      var a=30;
      return this.a;
    }
}
foo.bar()
//20
(foo.bar)()
//20
(foo.bar=foo.bar)()
//10
(foo.bar,foo.bar)()
//10
</code></pre><p>上题注解：</p>
<h2 id="时刻牢记：作用域链查找遵循”就近原则”；"><a href="#时刻牢记：作用域链查找遵循”就近原则”；" class="headerlink" title="时刻牢记：作用域链查找遵循”就近原则”；"></a>时刻牢记：作用域链查找遵循”就近原则”；</h2><h2 id="this谁调用就指向谁。"><a href="#this谁调用就指向谁。" class="headerlink" title="this谁调用就指向谁。"></a>this谁调用就指向谁。</h2><pre><code>var a=10;
var foo={
  a:20,
  bar:function(){
      var a=30;  //this 指向 foo  ：console.log( this == foo) //true
      return this.a;
    }
}


foo.bar()   
//20
// foo.bar()    // foo调用，this指向foo , 此时的 this 指的是foo，所以是20 


(foo.bar)()
//20
//第一步：
(function(){
   var a=30; 
   return this.a;
})()    //作用域链向上查找,this 指向外一层的对象foo



(foo.bar=foo.bar)()
//10
foo.bar=foo.bar,【睁大眼睛，是单等号赋值】就是普通的复制,一个匿名函数赋值给一个全局变量,你可以把右边的foo.bar换成b,
即(b = foo.bar)(),博客里面【this指向失效问题】说过普通的函数里面的this指向window,自然this.a == 10





(foo.bar,foo.bar)()  //逗号表达式
//10
//(foo.bar,foo.bar)是一个小括号表达式,小括号表达式会依次创建两个匿名函数,并返回最后一个的匿名函数值,
(foo.bar,foo.bar) 得到的是这个函数
 function(){
     var a=30;
     console.log( this == foo); //如果不是很了解this的指向就加这个代码进行检测
     return this.a;
   }
 ,这个是匿名函数,匿名函数的this指的是widnow,那么this.a = 10


this可谓是JavaScript中的开发神器，使用得当的话不仅有事半功倍的效果，而且代码的逼格也更高。但是既然是神器，如果你没有足够的功力的话，那么就不要使用它，否则就有可能自毁身亡。曾几何时，我偶然得到这个神器，之后，，，自残，，，自残，，，再自残...再自残了那么多次后，终于可以拥有强大功力持此神器行走江湖了。接下来，我就为大家来传授传说中神器的使用秘诀。
咳咳。。
入正题。
this是什么？this表示当前运行方法的主体。
注意：函数中的this指向和当前函数在哪定义的话或者在哪执行都没有任何的关系。为啥这样说，请仔细阅读下面的秘籍大全。
神器秘籍大全：

秘籍一：自制行函数里面的this永远都是window
var inner = &quot;window&quot;;
var obj = {inner : &quot;obj&quot;,
          fn : (function () {console.log(this.inner)})()
}


上面浏览器在运行该程序时，会自动运行obj.fn里面的方法，因为obj.fn是一个自制行函数，当执行该函数时，程序会输出window。
额，为什么输出不是obj？
因为人家规定自制行函数里面的this是window,所以其实this.inner就是window.inner，因此这个inner是定义在全局变量的，它的值是&quot;window&quot;。

秘籍二：元素绑定事件驱动方法运行，方法里的this表示当前绑定的元素
var oDiv = document.getElementsByTagName(&quot;div&quot;)[0];
oDiv.onclick=function(){
    console.log(this);   //当用鼠标点击该元素，则输出oDiv元素的集合
 };
这个好理解，元素绑定某个行为执行的方法，就相当于把这个方法也绑定在这个元素上，所以this也就指向元素本身。

秘籍三：方法执行，看方法名前面是否有&quot;.&quot;，有的话&quot;.&quot;前面是谁this就是谁，没有的话this就是window

var obj={fn:fn};
function fn(){console.log(this)}
fn.prototype.aa=function(){console.log(this)};
var f=new fn;
fn();  //window..
obj.fn(); //Object..
fn.prototype.aa(); //fn.prototype
f.aa(); //f

记住此秘籍！！！

秘籍四：在构造函数模式中,函数体中的this是当前类的一个实例
function Fn(){
    this.x = 100;
    console.log(this);  // 实例 f
}
var f = new Fn;
构造函数生成的实例，故构造函数里的this当然是指向当前这个实例了。

秘籍五（大招）：call/apply来改变this的指向
var oDiv = document.getElementsByTagName(&quot;div&quot;)[0];
function fn() {
    console.log(this);
}
fn.call(oDiv);
fn.call(oDiv); //执行这个语句后，fn里面的this指向oDiv元素，applay用法与call类似。
此大招一出来，上面四个秘籍都无效了。
</code></pre><h2 id="五个典型的-JavaScript-面试题"><a href="#五个典型的-JavaScript-面试题" class="headerlink" title="五个典型的 JavaScript 面试题"></a>五个典型的 JavaScript 面试题</h2><h2 id="问题1-范围（Scope）"><a href="#问题1-范围（Scope）" class="headerlink" title="问题1: 范围（Scope）"></a>问题1: 范围（Scope）</h2><p>思考以下代码：<br><img src="https://pic4.zhimg.com/v2-3427ee7904e86825dc800f37b5dd76a1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3427ee7904e86825dc800f37b5dd76a1_hd.jpg" alt=""></p>
<p>控制台（console）会打印出什么？</p>
<p>答案</p>
<p>上述代码会打印出5。</p>
<p>这个问题的陷阱就是，在立即执行函数表达式（IIFE）中，有两个命名，但是其中变量是通过关键词var来声明的。这就意味着a是这个函数的局部变量。与此相反，b是在全局作用域下的。</p>
<p>这个问题另一个陷阱就是，在函数中他没有使用”严格模式” (‘use strict’;)。如果 严格模式 开启，那么代码就会报出未捕获引用错误（Uncaught ReferenceError）：b没有定义。记住，严格模式要求你在需要使用全局变量时，明确地引用该变量。因此，你需要像下面这么写：<br><img src="https://pic3.zhimg.com/v2-d2990958fbb99d5fe5b7c2f99fd67fc1_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-d2990958fbb99d5fe5b7c2f99fd67fc1_hd.jpg" alt=""></p>
<h2 id="问题2-创建-“原生（native）”-方法"><a href="#问题2-创建-“原生（native）”-方法" class="headerlink" title="问题2: 创建 “原生（native）” 方法"></a>问题2: 创建 “原生（native）” 方法</h2><p>在String对象上定义一个repeatify函数。这个函数接受一个整数参数，来明确字符串需要重复几次。这个函数要求字符串重复指定的次数。举个例子：<br><img src="https://pic2.zhimg.com/v2-9a26df01a60f8a3020e339a2cdc022dc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-9a26df01a60f8a3020e339a2cdc022dc_hd.jpg" alt=""></p>
<p>应该打印出hellohellohello.</p>
<p>答案</p>
<p>一种可能的实现如下所示：<br><img src="https://pic3.zhimg.com/v2-323205969d7c319efb3257e962fc0e13_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-323205969d7c319efb3257e962fc0e13_hd.jpg" alt=""></p>
<p>这个问题测试了开发人员对于JavaScript中继承的掌握，以及prototype这个属性。这也验证了开发人员是否有能力扩展原生数据类型的功能（虽然不应该这么做）。</p>
<p>这个问题的另一个重点是验证你是否意识到并知道如何避免覆盖已经存在的函数。这可以通过在自定义函数之前判断该函数是否存在来做到。<br><img src="https://pic3.zhimg.com/v2-145aeeefc3c8949329552b22fa9434b3_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-145aeeefc3c8949329552b22fa9434b3_hd.jpg" alt=""></p>
<p>当你需要为旧浏览器实现向后兼容的函数时，这一技巧十分有用。</p>
<h2 id="问题3-变量提升（Hoisting）"><a href="#问题3-变量提升（Hoisting）" class="headerlink" title="问题3: 变量提升（Hoisting）"></a>问题3: 变量提升（Hoisting）</h2><p>执行以下代码会有什么结果？为什么？<br><img src="https://pic2.zhimg.com/v2-76ce0e2d75c2302991e408d087476a59_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-76ce0e2d75c2302991e408d087476a59_hd.jpg" alt=""></p>
<p>答案</p>
<p>这段代码的执行结果是 undefined 和 2。</p>
<p>这个结果的原因是，变量和函数都被提升了（hoisted）。因此，在a被打印的时候，它已经在函数作用域中存在（即它已经被声明了），但是它的值依然是 undefined。换言之，上述代码和以下代码是等价的。<br><img src="https://pic4.zhimg.com/v2-e5d341549dabe574215e26dbf0535ae8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-e5d341549dabe574215e26dbf0535ae8_hd.jpg" alt=""></p>
<h2 id="问题4-this-在-JavaScript-中是如何工作的"><a href="#问题4-this-在-JavaScript-中是如何工作的" class="headerlink" title="问题4: this 在 JavaScript 中是如何工作的"></a>问题4: this 在 JavaScript 中是如何工作的</h2><p>以下代码的结果是什么？请解释你的答案。<br><img src="https://pic4.zhimg.com/v2-c7109c7158a7800b48c57ce5fcfd889a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c7109c7158a7800b48c57ce5fcfd889a_hd.jpg" alt=""></p>
<p>答案</p>
<p>上面的代码打印出 Aurelio De Rosa 和 John Doe。原因是在 JavaScript 中，一个函数的上下文环境，也就是this关键词所引用对象，是依赖于函数是如何被调用的，而不是依赖于函数如何被定义的。</p>
<p>在第一个 console.log() 调用中， getFullname() 是作为 obj.prop 的函数被调用的。因此，这里的上下文环境指向后者并且函数返回this对象的 fullname 属性。相反，当 getFullname() 被赋为test变量的值时，那个语境指向全局对象(window)。这是因为，test被隐式设置为全局对象的属性。因此，函数调用返回 window 的 fullname 属性值，在此段代码中，这个值是通过第一行赋值语句设置的。</p>
<h2 id="问题5-call-和-apply"><a href="#问题5-call-和-apply" class="headerlink" title="问题5: call() 和 apply()"></a>问题5: call() 和 apply()</h2><p>修复上一个问题，让最后一个 console.log() 打印出 Aurelio De Rosa。</p>
<p>答案</p>
<p>要解决这个问题，可以通过为函数 call() 或者 apply() 强制函数调用的上下文环境。如果你不知道 call() 和 apply() 之间的区别，我推荐阅读文章“ function.call 和 function.apply 之间有和区别?”。在以下代码中，我会用 call()，但是在这里，用 apply() 也可以获得相同的结果：<br><img src="https://pic4.zhimg.com/v2-6dd929db46959a48071adb146a84ba56_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6dd929db46959a48071adb146a84ba56_hd.jpg" alt=""></p>
<h2 id="常见面试："><a href="#常见面试：" class="headerlink" title="常见面试："></a>常见面试：</h2><pre><code>下面列举一些简单的实例 总结一下this的一些用法：


1.方法中的this会指向当前执行该方法的对象 如：

var name = &quot;window&quot;

var Tom = {

  name:&quot;Tom&quot;;

  show:function(){alert(this.name)}

}

Tom.show();   //Tom



2.方法中的this不会指向声明它的对象 如下


var Bob={
  name:&quot;Bob&quot;,
  show:function(){alert(this.name);}
  };

var Tom={
  name:&quot;Tom&quot;,
  show:Bob.show
  };

Tom.show() ;   //Tom

因为尽管alert(this.name)是在Bob对象环境中声明的


但该方法是由Tom对象调用执行所以this总是会指向当前执行的对象，而不是声明的对象





3.将方法复制给变量时，执行时仍然会以Tom对象区调用该方法


var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;.
  show:function(){alert(this.name)}
  };

var fun=Tom.show();
fun();              //Tom

可以看出赋值后再调用，并不影响调用其方法的对象



4.将对象赋值给变量后，再调用方法，执行的对象仍然是Tom

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){
             var that=this;
             that.show();
         }
  };

Tom.wait();  //Tom

这里that赋值了当前执行的对象，并让它继续调用show，
所以show方法中alert(this.name)自然而然的指向了Tom
可以把上面的 &quot;that赋值对象 然后调用方法&quot; 这个过程看做成执行对象
的延迟，就是让Tom加班的意思




 5.另一种 指明调用方法的对象 的办法 如下：


var name = &quot;window&quot;;
var Bob= {
    name:&quot;Bob&quot;,
    show:function(){alert(this.name);}
    };

 var Tom= {name: &quot;Tom&quot;};
 Bob.show();                   //Bob
 Bob.show.apply();             //window
 Bob.show.apply(Tom);          //Tom

 当然call()也差不多类似



6.下面来个特殊的例子

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){
             var fun=this.show;
             fun();
         }
  };

Tom.wait();  //window

上面也是赋值方法后，再调用，可是执行的对象却改成了window对象

解释：

在函数体内把方法赋值给变量再调用会导致对象更改为Window对象
执行fun时，可以看做是一种方法调用的延迟行为，延迟调用方法会使得执行的对象
变为全局对象也就是window对象


下面我们来看看其他几种延迟方式，导致对象被更改为window的例子



7.匿名函数的延迟

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){!function(call){call();}(this.show)}
  }

Tom.wait();    //Window




8.setTimeout、setInterval函数延迟
这里只以setTimeout为例子

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){setTimeout(this.show,1000)}
  }

Tom.wait();    //window



9. 在延迟的环境下 尝试让Tom加班（对象也跟着延迟）

var name=&quot;window&quot;;
var Tom={  name:&quot;Tom&quot;,
show:function(){alert(this.name)},
wait:function(){setTimeout(Tom.show,1000)}  }

Tom.wait();    //window  



上面中this对象改成了Tom，尝试让Tom加班，但是结果仍然为Window对象
因为Tom.show放在第一个参数里，延迟的执行使得执行的对象变为window对象
而不再是Tom对象，如何让执行对象Tom在延迟当不被变更呢？下面给你答案


 10.虽然延迟会导致方法的执行对象被更改为Window 但也有办法防止执行对象更改 如下


var name=&quot;window&quot;
var  Tom ={  
    name : &quot;Tom&quot;,  
    show : function(){alert(this.name);},  
    wait:  function(){
    var that=this;
    setTimeout(function(){that.show()},1000)}  
          }

Tom.wait();    //Tom 

如果不能理解上面的代码，你就当做Tom对象也跟着函数一起延迟就好了
而第9个例子没有成功延迟，是因为没有变量保存对象使得执行对象没有跟着延迟





11.eval函数的延迟

对于eval比较特殊

在eval环境下，执行的对象就是当前作用域的对象 如下


var name=&quot;window&quot;;
var Bob={
  name:&quot;Bob&quot;,
  showName: function(){ eval(&quot;alert(this.name)&quot;); }
  };

Bob.showName(); //Bob








12.eval函数的环境下，不会受到延迟而影响函数执行的对象

之所以eval特殊是因为eval不受延迟的影响

var name=&quot;window&quot;;
var that;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){that=this;setTimeout(&quot;that.show()&quot;,1000)}
  }

Tom.wait();    //Tom



也许你会觉得上面的代码没有eval函数的身影
其实setTimeout函数的第一个参数就是eval环境
他会指向当前执行作用域的执行对象，忽略延迟方法延迟调用



如果能把上面12个例子都理解了，那么this将成为你的一把有力的刀，挥舞在你代码中
当然如果不能理解，那么像闭包一样 尽量的少用！
</code></pre><p>函数是JavaScript世界里的第一公民，换句话来说，就是我们如果可以精通JavaScript函数的使用，那么对JavaScript的运用可以更游刃有余了。熟悉JavaScript的人应该都知道，同样的函数，以不同的方式调用的话，受影响最大的应该是  this 。下面我们来说说JavaScript函数的各种调用模式。</p>
<p>一、普通函数的调用模式</p>
<p>　　所谓普通函数的调用模式，也是JavaScript函数的最简单的一种调用模式，直接就是函数名后接一个  ()  实现调用，看下面代码：</p>
<pre><code>function func(){
    console.log(this === window);  //true
}
func();
</code></pre><p>　　上面代码，我们用function关键字声明了一个 func 函数，并且在函数体内打印 this===window，然后我们直接调用函数func，我们可以看到控制台是直接打印出 true ，也就是说，函数的这种普通调用模式，函数体内的  this  是指向全局环境 window 的。不清楚这点的同学，可以能会遇到这样的一个bug：</p>
<pre><code>var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        function func1(){
            console.log(this.color);  //gg
        }
        func1();
    }
}
obj.show(); 
</code></pre><p>　　我们在全局环境下声明了一个变量 color 和一个对象 obj ，在对象 obj 里面我们还声明了一个 color 属性 为 ‘red’，一个 show 方法。而且在 show 方法里面呢，我们还声明了一个函数 func1 并且调用了 func1，func1 的作用是打印 this.color。最后我们运行代码  obj.show();   调用obj里面的show方法。不清楚函数的普通调用模式的特点的同学可能会认为此时在控制台答应出来的会是  ‘red’ 。实际上此时在控制台答应出来的应该是  gg  。因为函数  func1  的调用模式是 普通函数调用模式（即使它是在  obj  的  show  方法里面调用的），所以此时函数体内的  this  是指向 全局环境window 的，所以就打印了全局环境下的变量  color 。</p>
<p>　　可能有些同学会问：如果我们希望  func1  函数打印出来的是 ‘red’ 呢，应该怎么改？其实很简单，因为  obj.color  才是 ‘red’ ，所以我们只需要把  指向  obj  的  this 引入到函数 func1  里面就行了： </p>
<pre><code>var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        var that = this;
        function func1(){
            console.log(that.color);  //red
        }
        func1();
    }
}
obj.show();
var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        var func1=function(){
            console.log(this.color);  //red
        }.bind(this);
        func1();
    }
}
obj.show();
</code></pre><p>　　在上面的代码中，因为  show  里面的   this  指向   obj   的，所以我们在  show  里面声明一个变量  that = this;用来把指向  obj  的  this  引入到  func1 中，然后再把 func1 函数体内的  this.color  改为  that.color ,此时在控制台打印出来的就是我们想要的 ‘red’ 了。</p>
<p>　　可能现在又有同学会问：为什么   show   里面的  this  是指向  obj 的呢？这就是我们要说的JavaScript函数的第二种调用模式：方法调用模式</p>
<p>二、方法调用模式</p>
<p>　　方法调用模式，简单来说就是把一个 JavaScript函数作为一个对象的方法来调用，当一个函数被保存为一个对象的属性是，我们就把它称为方法，例如上文的  obj  对象里的  show  ，当一个方法被调用时，函数体里面的   this  就会绑定到这个对象，例如上文的 show 里面的  this  。方法调用模式也很容易辨别：obj.show()，对象名 . 属性名 () ；代码的话可以参考上文的  obj  代码 ，博主就不多写了。记住：方法的调用是可以在函数体内通过  this  访问自己所属的那个对象的。</p>
<p>三、构造器调用模式</p>
<p>博主认为构造器调用模式是相对于其他模式来说较为复杂点的调用模式了。通过关键字  new  可以把一个函数作为构造器来调用。关键字  new  可以改变函数的返回值：</p>
<pre><code>function func2(name){
    this.name = name;
}

name;   //undefined

//普通函数调用模式
var foo = func2(&apos;afei&apos;);
foo;  //undefined
name;   //afei


//构造器调用模式
var bar = new func2(&apos;lizefei&apos;);
bar.__proto__ === func2.prototype;  //true
bar;  //{name:&apos;lizefei&apos;}
bar.name;  //&apos;lizefei&apos;
</code></pre><p>　　在上示代码中我们声明了一个函数 func2 ，分别用两种不同的调用模式去调用它。因为函数  func2  并没有显式返回值，所以作为普通函数去调用时，它什么也没有返回，所以  foo  的值是  undefined  。因为普通调用模式的   this   是指向 全局环境   window  的，所以  func2(‘afei’);  后，全局环境下就多了一个  name 变量且等于 ‘afei’。</p>
<p>　　func2  作为构造器调用时，我们可以看到，它返回的是一个对象，因为关键字  new  使得函数在调用是发生了如下的特殊变化：</p>
<ol>
<li>　　创建了一个新对象，而且这个新对象是链接到 func2  的  prototype  属性的</li>
<li>　　把函数里的  this  指向了这个新对象</li>
<li>　　如果没有显式的返回值，新对象作为构造器func2的返回值进行返回（所以bar 是 {name:’lizefei’}）</li>
</ol>
<p>这样子我们就可以看出构造器的作用：通过函数的调用来初始化新创建出来的对象。在JavaScript的面向对象编程里面，这个可是相当重要的。</p>
<p>　　因为在函数的声明上，在未来作为构造器调用的函数和普通函数的声明没什么区别，所以导致后来的开发者很容易因为调用模式的错误导致程序出问题。所以开发者们都默契地约定，用来做构造器调用的函数的函数名的第一个字符应该大写，例如：Person，People。这样子后来的开发者一看到函数名就知道要用构造器调用模式调用此函数了。</p>
<p>四、使用apply()和call()方法调用</p>
<p>　　这种调用的模式是为了更灵活控制函数运行的上下文环境而诞生的。简单的说就是为了灵活控制函数体内  this  的值。</p>
<p>　　apply 和 call这两个方法的第一个参数都是要传递被函数上下文的对象（简单点说就是要绑定给函数  this  的对象）。其他参数就有所不同了：</p>
<p>　　apply方法的第二个参数是一个数组，数组里面的值将作为函数调用的参数；</p>
<p>　　call方法，从第二个参数起（包括第二个参数），剩下的参数都是作为函数调用的参数；</p>
<p>　　让我们看看栗子：</p>
<pre><code>var obj = {
    name :&apos;afei&apos;
}
function say(ag1,ag2){
    console.log(ag1+&apos;:&apos;+ag2+&quot; &quot;+ this.name);
}
say.apply(obj,[&apos;apply方法&apos;,&apos;hello&apos;]); //apply方法:hello afei
say.call(obj,&apos;call方法&apos;,&apos;hi&apos;); //call方法:hi afei
</code></pre><p>　　正如栗子所示，我们把对象 obj  作为函数  say  的上下文来调用函数  say  ，所以函数里的  this  是指向 对象  obj  的。在apply方法里，我们通过数组  [‘apply方法’,’hello’]  给  say  方法传递了两个参数（’apply方法’ 和 ‘hello’），所以打印出来是：  apply方法:hello afei。</p>
<p>　　同理  call 也是一样，而且函数传递的方式通过上面的代码也一目了然我，博主就不多做解释了。</p>
<p>　　另外，博主还听说apply和call这两个方法除了传递参数的方式不一样，执行的速度还是apply 比 call 要快呢。不过博主就没有实验过。</p>
<p>五、总结</p>
<p>　　在JavaScript里面，函数只要的调用模式就是这几种了（在ES6里面还有一种很奇怪很特殊的函数调用模式，叫做’标签模板‘，在这里博主也不多说了，有空另更），只要掌握了这几种主要的调用模式，那么日后再也不用担心  this 的值变来变去了。</p>
<p>　　上文如果有漏的、有错误的地方，望各位小伙伴指出，小弟虚心向学。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


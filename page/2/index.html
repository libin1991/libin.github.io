<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>LuckDay</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/02/JS之call和apply-bind的模拟实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/02/JS之call和apply-bind的模拟实现/" itemprop="url">JS之call和apply,bind的模拟实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-02T22:39:16+08:00">
                2018-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>一句话介绍 call：</p>
<blockquote>
<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
</blockquote>
<p>举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
</code></pre><p>注意两点：</p>
<ol>
<li>call 改变了 this 的指向，指向到 foo</li>
<li>bar 函数执行了</li>
</ol>
<h2 id="模拟实现第一步"><a href="#模拟实现第一步" class="headerlink" title="模拟实现第一步"></a>模拟实现第一步</h2><p>那么我们该怎么模拟实现这两个效果呢？</p>
<p>试想当调用 call 的时候，把 foo 对象改造成如下：</p>
<pre><code>var foo = {
    value: 1,
    bar: function() {
        console.log(this.value)
    }
};

foo.bar(); // 1
</code></pre><p>这个时候 this 就指向了 foo，是不是很简单呢？</p>
<p>但是这样却给 foo 对象本身添加了一个属性，这可不行呐！</p>
<p>不过也不用担心，我们用 delete 再删除它不就好了~</p>
<p>所以我们模拟的步骤可以分为：</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<p>以上个例子为例，就是：</p>
<pre><code>// 第一步
foo.fn = bar
// 第二步
foo.fn()
// 第三步
delete foo.fn
</code></pre><p>fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。</p>
<p>根据这个思路，我们可以尝试着去写第一版的 call2 函数：</p>
<pre><code>// 第一版
Function.prototype.call2 = function(context) {
    // 首先要获取调用call的函数，用this可以获取
    context.fn = this;
    context.fn();
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call2(foo); // 1
</code></pre><p>正好可以打印 1 哎！是不是很开心！(～￣▽￣)～</p>
<h2 id="模拟实现第二步"><a href="#模拟实现第二步" class="headerlink" title="模拟实现第二步"></a>模拟实现第二步</h2><p>最一开始也讲了，call 函数还能给定参数执行函数。举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call(foo, &apos;kevin&apos;, 18);
// kevin
// 18
// 1
</code></pre><p>注意：传入的参数并不确定，这可咋办？</p>
<p>不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。</p>
<p>比如这样：</p>
<pre><code>// 以上个例子为例，此时的arguments为：
// arguments = {
//      0: foo,
//      1: &apos;kevin&apos;,
//      2: 18,
//      length: 3
// }
// 因为arguments是类数组对象，所以可以用for循环
var args = [];
for(var i = 1, len = arguments.length; i &lt; len; i++) {
    args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
}

// 执行后 args为 [foo, &apos;kevin&apos;, 18]
</code></pre><p>不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。</p>
<pre><code>// 将数组里的元素作为多个参数放进函数的形参里
context.fn(args.join(&apos;,&apos;))
// (O_o)??
// 这个方法肯定是不行的啦！！！
</code></pre><p>也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样：</p>
<pre><code>eval(&apos;context.fn(&apos; + args +&apos;)&apos;)
</code></pre><p>这里 args 会自动调用 Array.toString() 这个方法。</p>
<p>所以我们的第二版克服了两个大问题，代码如下：</p>
<pre><code>// 第二版
Function.prototype.call2 = function(context) {
    context.fn = this;
    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }
    eval(&apos;context.fn(&apos; + args +&apos;)&apos;);
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call2(foo, &apos;kevin&apos;, 18); 
// kevin
// 18
// 1
</code></pre><p>(๑•̀ㅂ•́) ✧</p>
<h2 id="模拟实现第三步"><a href="#模拟实现第三步" class="headerlink" title="模拟实现第三步"></a>模拟实现第三步</h2><p>模拟代码已经完成 80%，还有两个小点要注意：</p>
<p>1.this 参数可以传 null，当为 null 的时候，视为指向 window</p>
<p>举个例子：</p>
<pre><code>var value = 1;

function bar() {
    console.log(this.value);
}

bar.call(null); // 1
</code></pre><p>虽然这个例子本身不使用 call，结果依然一样。</p>
<p>2.函数是可以有返回值的！</p>
<p>举个例子：</p>
<pre><code>var obj = {
    value: 1
}

function bar(name, age) {
    return {
        value: this.value,
        name: name,
        age: age
    }
}

console.log(bar.call(obj, &apos;kevin&apos;, 18));
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>不过都很好解决，让我们直接看第三版也就是最后一版的代码：</p>
<pre><code>// 第三版
Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);

    delete context.fn
    return result;
}

// 测试一下
var value = 2;

var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call(null); // 2

console.log(bar.call2(obj, &apos;kevin&apos;, 18));
// 1
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ</p>
<h2 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h2><p>apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现：</p>
<pre><code>Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push(&apos;arr[&apos; + i + &apos;]&apos;);
        }
        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)
    }

    delete context.fn
    return result;
}
</code></pre><p><img src="https://pic1.zhimg.com/v2-23784bc5e0ab2bdcb4b879e5d28617c6_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-23784bc5e0ab2bdcb4b879e5d28617c6_hd.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-9374916fd3f03dab5836b9fc4057070a_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-9374916fd3f03dab5836b9fc4057070a_hd.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-7fe454d5cfd72880650f53a4f50c93cd_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-7fe454d5cfd72880650f53a4f50c93cd_hd.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-4f15656852b764a859194a3d7156ea99_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-4f15656852b764a859194a3d7156ea99_hd.jpg" alt=""></p>
<pre><code>类数组转对象
在上面的例子中已经提到了一种类数组转数组的方法，再补充三个：
var arrayLike = {0: &apos;name&apos;, 1: &apos;age&apos;, 2: &apos;sex&apos;, length: 3 }
// 1. slice
Array.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 2. splice
Array.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 3. ES6 Array.from
Array.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 4. apply
Array.prototype.concat.apply([], arrayLike)   




要说到类数组对象，Arguments 对象就是一个类数组对象。
在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。


传递参数
将参数从一个函数传递到另一个函数
// 使用 apply 将 foo 的参数传递给 bar
function foo() {
    bar.apply(this, arguments);
}
function bar(a, b, c) {
   console.log(a, b, c);
}

foo(1, 2, 3)




强大的ES6
使用ES6的 ... 运算符，我们可以轻松转成数组。
function func(...arguments) {
    console.log(arguments); // [1, 2, 3]
}

func(1, 2, 3);
</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>一句话介绍 bind:</p>
<blockquote>
<p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p>
</blockquote>
<p>由此我们可以首先得出 bind 函数的两个特点：</p>
<ol>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ol>
<h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><p>从第一个特点开始，我们举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

// 返回了一个函数
var bindFoo = bar.bind(foo); 

bindFoo(); // 1
</code></pre><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">《JavaScript深入之call和apply的模拟实现》</a>。我们来写第一版的代码：</p>
<pre><code>// 第一版
Function.prototype.bind2 = function (context) {
    var self = this;
    return function () {
        self.apply(context);
    }

}
</code></pre><h2 id="传参的模拟实现"><a href="#传参的模拟实现" class="headerlink" title="传参的模拟实现"></a>传参的模拟实现</h2><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(this.value);
    console.log(name);
    console.log(age);

}

var bindFoo = bar.bind(foo, &apos;daisy&apos;);
bindFoo(&apos;18&apos;);
// 1
// daisy
// 18
</code></pre><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p>
<p>这可咋办？不急，我们用 arguments 进行处理：</p>
<pre><code>// 第二版
Function.prototype.bind2 = function (context) {

    var self = this;
    // 获取bind2函数从第二个参数到最后一个参数
    var args = Array.prototype.slice.call(arguments, 1);

    return function () {
        // 这个时候的arguments是指bind返回的函数传入的参数
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(context, args.concat(bindArgs));
    }

}
</code></pre><h2 id="构造函数效果的模拟实现"><a href="#构造函数效果的模拟实现" class="headerlink" title="构造函数效果的模拟实现"></a>构造函数效果的模拟实现</h2><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p>
<blockquote>
<p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
</blockquote>
<p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p>
<pre><code>var value = 2;

var foo = {
    value: 1
};

function bar(name, age) {
    this.habit = &apos;shopping&apos;;
    console.log(this.value);
    console.log(name);
    console.log(age);
}

bar.prototype.friend = &apos;kevin&apos;;

var bindFoo = bar.bind(foo, &apos;daisy&apos;);

var obj = new bindFoo(&apos;18&apos;);
// undefined
// daisy
// 18
console.log(obj.habit);
console.log(obj.friend);
// shopping
// kevin
</code></pre><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p>
<p>(哈哈，我这是为我的下一篇文章<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">《JavaScript深入系列之new的模拟实现》</a>打广告)。</p>
<p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p>
<pre><code>// 第三版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
        self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
    }
    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
    fBound.prototype = this.prototype;
    return fBound;
}
</code></pre><p>如果对原型链稍有困惑，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">《JavaScript深入之从原型到原型链》</a>。</p>
<h2 id="构造函数效果的优化实现"><a href="#构造函数效果的优化实现" class="headerlink" title="构造函数效果的优化实现"></a>构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p>
<pre><code>// 第四版
Function.prototype.bind2 = function (context) {

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
</code></pre><p>到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ</p>
<h2 id="三个小问题"><a href="#三个小问题" class="headerlink" title="三个小问题"></a>三个小问题</h2><p>接下来处理些小问题:</p>
<p>1.apply 这段代码跟 MDN 上的稍有不同</p>
<p>在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：</p>
<pre><code>self.apply(this instanceof self ? this : context || this, args.concat(bindArgs))
</code></pre><p>多了一个关于 context 是否存在的判断，然而这个是错误的！</p>
<p>举个例子：</p>
<pre><code>var value = 2;
var foo = {
    value: 1,
    bar: bar.bind(null)
};

function bar() {
    console.log(this.value);
}

foo.bar() // 2
</code></pre><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！</p>
<p>所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！</p>
<p>2.调用 bind 的不是函数咋办？</p>
<p>不行，我们要报错！</p>
<pre><code>if (typeof this !== &quot;function&quot;) {
  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}
</code></pre><p>3.我要在线上用</p>
<p>那别忘了做个兼容：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function () {
    ……
};
</code></pre><p>当然最好是用 <a href="https://link.zhihu.com/?target=https%3A//github.com/es-shims/es5-shim" target="_blank" rel="noopener">es5-shim</a> 啦。</p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>所以最最后的代码就是：</p>
<pre><code>Function.prototype.bind2 = function (context) {

    if (typeof this !== &quot;function&quot;) {
      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/31/JavaScript-中的-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/31/JavaScript-中的-this/" itemprop="url">JavaScript 中的 this !</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-31T22:53:27+08:00">
                2018-08-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在 js 中，this 这个上下文总是变化莫测，很多时候出现 bug 总是一头雾水，其实，只要分清楚不同的情况下如何执行就 ok 了。</p>
<p><img src="https://pic4.zhimg.com/v2-3068deaab983c4e925d5b325985ce9e9_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3068deaab983c4e925d5b325985ce9e9_hd.jpg" alt=""></p>
<h2 id="全局执行"><a href="#全局执行" class="headerlink" title="全局执行"></a>全局执行</h2><p>首先，我们在全局环境中看看它的 this 是什么：</p>
<p>first. 浏览器：</p>
<pre><code>console.log(this);

// Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}
</code></pre><p>可以看到打印出了 window 对象；</p>
<p>second. node：</p>
<pre><code>console.log(this);

// global
</code></pre><p>可以看到打印出了 global 对象；</p>
<p>总结：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。</p>
<h2 id="函数中执行"><a href="#函数中执行" class="headerlink" title="函数中执行"></a>函数中执行</h2><h2 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h2><p>这是最普通的函数使用方法了：</p>
<pre><code>function test() {
  console.log(this);
};

test();

// Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}
</code></pre><p>我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象；</p>
<p>严格模式 ‘use strict’;</p>
<p>如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为：</p>
<pre><code>&apos;use strict&apos;;
function test() {
  console.log(this);
};

test();

// undefined
</code></pre><p>当然，把它放在一个立即执行函数中会更好，避免了污染全局：</p>
<pre><code>(function (){
  &quot;use strict&quot;;
　console.log(this);
})();

// undefined
</code></pre><h2 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h2><p>当一个函数被当作一个对象的方法调用的时候：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this.name);
  }
}

obj.foo();

// &apos;qiutc&apos;
</code></pre><p>这时候，this 指向当前的这个对象；</p>
<p>当然，我们还可以这么做：</p>
<pre><code>function test() {
  console.log(this.name);
}
var obj = {
  name: &apos;qiutc&apos;,
  foo: test
}

obj.foo();

// &apos;qiutc&apos;
</code></pre><p>同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 test ，它只是一个函数名，函数的引用，它指向这个函数，当 foo = test，foo 同样也指向了这个函数。</p>
<p>如果把对象的方法赋值给一个变量，然后直接调用这个变量呢：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  }
}

var test = obj.foo;
test();

// Window
</code></pre><p>可以看到，这时候 this 执行了全局，当我们把 test = obj.foo ，test 直接指向了一个函数的引用，这时候，其实和 obj 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，this 指向全局对象。</p>
<p>一些坑</p>
<p>我们经常在回调函数里面会遇到一些坑：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);   //Object {name: &quot;qiutc&quot;...}
    setTimeout(this.foo, 1000);   // window 对象
  }
}

obj.foo2();
</code></pre><p><img src="https://pic1.zhimg.com/v2-2099857fcaab02a66d655f172d12cf82_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-2099857fcaab02a66d655f172d12cf82_hd.jpg" alt=""></p>
<p>执行这段代码我们会发现两次打印出来的 this 是不一样的：</p>
<p>关于setTimeout的this指向：<a href="https://link.zhihu.com/?target=https%3A//www.talkingcoder.com/article/6356947525374513523" target="_blank" rel="noopener">https://www.talkingcoder.com/article/6356947525374513523</a></p>
<pre><code>第一次是 foo2 中直接打印 this，这里指向 obj 这个对象，我们毋庸置疑；
</code></pre><p>但是在 setTimeout 中执行的 this.foo，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑；<br>其实，setTimeout 也只是一个函数而已，函数必然有可能需要参数，我们把 this.foo 当作一个参数传给 setTimeout 这个函数，就像它需要一个 fun 参数，在传入参数的时候，其实做了个这样的操作 fun = this.foo，看到没有，这里我们直接把 fun 指向 this.foo 的引用；执行的时候其实是执行了 fun() 所以已经和 obj 无关了，它是被当作普通函数直接调用的，因此 this 指向全局对象。</p>
<p>这个问题是很多异步回调函数中普遍会碰到的；</p>
<p>解决</p>
<p>为了解决这个问题，我们可以利用 闭包 的特性来处理：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);
    var _this = this;
    setTimeout(function() {
      console.log(this);  // Window

      console.log(_this);  // Object {name: &quot;qiutc&quot;}
    }, 1000);
  }
}

obj.foo2();
</code></pre><p>可以看到直接用 this 仍然是 Window；因为 foo2 中的 this 是指向 obj，我们可以先用一个变量 _this 来储存，然后在回调函数中使用 _this，就可以指向当前的这个对象了；</p>
<p>setTimeout 的另一个坑</p>
<p>之前啊说过，如果直接执行回调函数而没有绑定作用域，那么它的 this 是指向全局对象(window)，在严格模式下会指向 undefined，然而在 setTimeout 中的回调函数在严格模式下却表现出不同：</p>
<pre><code>&apos;use strict&apos;;

function foo() {
  console.log(this);
}

setTimeout(foo, 1);

// window
</code></pre><p>按理说我们加了严格模式，foo 调用也没有指定 this，应该是出来 undefined，但是这里仍然出现了全局对象，难道是严格模式失效了吗？</p>
<p>并不，即使在严格模式下，setTimeout 方法在调用传入函数的时候，如果这个函数没有指定了的 this，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 foo.apply(window) 而非 foo()；</p>
<p>当然，如果我们在传入函数的时候已经指定 this，那么就不会被注入全局对象，比如： setTimeout(foo.bind(obj), 1);；</p>
<p><a href="https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code" target="_blank" rel="noopener">http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code</a></p>
<h2 id="作为一个构造函数使用"><a href="#作为一个构造函数使用" class="headerlink" title="作为一个构造函数使用"></a>作为一个构造函数使用</h2><p>在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 new 这个关键字：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var p = new Person(&apos;qiutc&apos;);

// Person {name: &quot;qiutc&quot;}
</code></pre><p>我们可以看到当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象；</p>
<p>当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var p = Person(&apos;qiutc&apos;);

// Window
</code></pre><p>其区别在于，如何调用函数（new）。</p>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 this 的指向了，还记得在上文中（作为对象的方法调用-一些坑-解决）我们使用闭包来解决 this 的指向问题吗，如果用上了箭头函数就可以更完美的解决了：</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function() {
    console.log(this);
  },
  foo2: function() {
    console.log(this);
    setTimeout(() =&gt; {
      console.log(this);  // Object {name: &quot;qiutc&quot;}
    }, 1000);
  }
}

obj.foo2();
</code></pre><p>可以看到，在 setTimeout 执行的函数中，本应该打印出在 Window，但是在这里 this 却指向了 obj，原因就在于，给 setTimeout 传入的函数（参数）是一个箭头函数：</p>
<blockquote>
<p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
</blockquote>
<p>根据例子我们理解一下这句话：<br>在 obj.foo2() 执行的时候，当前的 this 指向 obj；在执行 setTimeout 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 this 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 this，也就是 obj.foo2 中的 this，即 obj；所以在执行箭头函数的时候，它的 this -&gt; obj.foo2 中的 this -&gt; obj；</p>
<p>简单来说， 箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。</p>
<h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h2><p>在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向：</p>
<ul>
<li>call</li>
</ul>
<p>fun.call(thisArg[, arg1[, arg2[, …]]])</p>
<p>它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，后面的参数是执行函数需要传入的参数；</p>
<ul>
<li>apply</li>
</ul>
<p>fun.apply(thisArg[, [arg1, arg2, …]])</p>
<p>它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）；</p>
<ul>
<li>bind</li>
</ul>
<p>var foo = fun.bind(thisArg[, arg1[, arg2[, …]]]);</p>
<p>它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数；</p>
<p>这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this），我们以 call 函数为例；</p>
<p>为一个普通函数指定 this</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;
};

function foo() {
  console.log(this);
}

foo.call(obj);

// Object {name: &quot;qiutc&quot;}
</code></pre><p>可以看到，在执行 foo.call(obj) 的时候，函数内的 this 指向了 obj 这个对象，成功；</p>
<p>为对象中的方法指定一个 this</p>
<pre><code>var obj = {
  name: &apos;qiutc&apos;,
  foo: function () {
    console.log(this);
  }
}

var obj2 = {
  name: &apos;tcqiu222222&apos;
};

obj.foo.call(obj2);

// Object {name: &quot;tcqiu222222&quot;}
</code></pre><p>可以看到，执行函数的时候这里的 this 指向了 obj2，成功；</p>
<p>为构造函数指定 this</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var p = new Person.call(obj, &apos;qiutc&apos;);

// Uncaught TypeError: Person.call is not a constructor(…)
</code></pre><p>这里报了个错，原因是我们去 new 了 Person.call 函数，而非 Person ，这里的函数不是一个构造函数；</p>
<p>换成 bind 试试：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var Person2 = Person.bind(obj);

var p = new Person2(&apos;qiutc&apos;);

// Person {name: &quot;qiutc&quot;}

console.log(obj);

// Object {name: &quot;qiutc2222222&quot;}
</code></pre><p>打印出来的是 Person 实例化出来的对象，而和 obj 没有关系，而 obj 也没有发生变化，说明，我们给 Person 指定 this 上下文并没有生效；</p>
<p>因此可以得出： 使用 bind 给一个构造函数指定 this，在 new 这个构造函数的时候，bind 函数所指定的 this 并不会生效；</p>
<p>当然 bind 不仅可以指定 this ，还能传入参数，我们来试试这个操作：</p>
<pre><code>function Person(name) {
  this.name = name;
  console.log(this);
}

var obj = {
  name: &apos;qiutc2222222&apos;
};

var Person2 = Person.bind(obj, &apos;qiutc111111&apos;);

var p = new Person2(&apos;qiutc&apos;);

// Person {name: &quot;qiutc111111&quot;}
</code></pre><p>可以看到，虽然指定 this 不起作用，但是传入参数还是起作用了；</p>
<p>为箭头函数指定 this</p>
<p>我们来定义一个全局下的箭头函数，因此这个箭头函数中的 this 必然会指向全局对象，如果用 call 方法改变 this 呢：</p>
<pre><code>var afoo = (a) =&gt; {
  console.log(a);
  console.log(this);
}

afoo(1);

// 1
// Window

var obj = {
  name: &apos;qiutc&apos;
};

afoo.call(obj, 2);

// 2
// Window
</code></pre><p>可以看到，这里的 call 指向 this 的操作并没有成功，所以可以得出： 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this。</p>
<p>只要记住箭头函数大法好，不变的 this。</p>
<p>Function.prototype.call</p>
<ul>
<li>格式:fx.call( thisArg [，arg1，arg2，… ] );</li>
</ul>
<ol>
<li><p>call的传参个数不限,第一个数表示调用函数(fx)函数体内this的指向.从第二个参数开始依次按序传入函数.</p>
<p> var age = 40;<br> var xiaoMing = {</p>
<pre><code>age:30
</code></pre><p> };<br> var xiaoLi = {</p>
<pre><code>age: 20
</code></pre><p> };<br> var getAge = function(){</p>
<pre><code>console.log(this.age);
</code></pre><p> };<br>  getAge.call( xiaoMing );  //30 表示函数this指向xiaoMing<br> getAge.call(xiaoLi);  //20  表示函数this指向xiaoLi<br> getAge.call(undefined);//40  getAge.call(undefined)==getAge.call(null)<br> getAge.call(null);//40<br> getAge(); //40</p>
</li>
</ol>
<p>如果我们传入fx.call()的第一个参数数为null,那么表示函数fx体内this指向宿主对象,在浏览器是Window对象,这也解释了getAge.call(undefined);//40。</p>
<p>在此基础我们可以理解为 getAge()相当于getAge.call(null/undefined),扩展到所有函数,<br>fx()==fx.call(null) == fx.call(undefined)</p>
<p>值得注意的是严格模式下有点区别: this指向null</p>
<pre><code>var getAge = function(){
&apos;use strict&apos;
console.log(this.age);
};
getAge(null);//报错 age未定义
</code></pre><p>再来理解this的使用</p>
<p>this的常用场景:</p>
<ul>
<li><p>this位于一个对象的方法内,此时this指向该对象</p>
<p>  var name = ‘window’;</p>
<p>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {
    console.log(this == Student); //true
    console.log(this.name);  //kobe
}
</code></pre><p>  }</p>
<p>  Student.getName();</p>
<p>  var name = ‘window’;<br>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {
            var name=100;
    console.log(this == Student); //true
    console.log(this.name);  //kobe
}
</code></pre><p>  }<br>  Student.getName();   //getName取得是Student 的name</p>
</li>
</ul>
<ul>
<li><p>this位于一个普通的函数内,表示this指向全局对象,(浏览器是window)</p>
<p>  var name = ‘window’;</p>
<p>  var getName = function () {</p>
<pre><code>var name = &apos;kobe&apos;;  //迷惑性而已
return this.name;
</code></pre><p>  }</p>
<p>  console.log(  getName() ); //window</p>
</li>
</ul>
<ul>
<li><p>this使用在构造函数(构造器)里面,表示this指向的是那个返回的对象.</p>
<p>  var name = ‘window’;<br>  //构造器<br>  var Student = function () {</p>
<pre><code>this.name = &apos;student&apos;;
</code></pre><p>  }</p>
<p>  var s1 = new Student();<br>  console.log(s1.name);  //student</p>
</li>
</ul>
<p>注意: 如果构造器返回的也是一个Object的对象(其他类型this指向不变遵循之前那个规律),这时候this指的是返回的这个Objec.</p>
<pre><code>var name = &apos;window&apos;;
//构造器
var Student = function () {
    this.name = &apos;student&apos;;
    return {
        name: &apos;boyStudent&apos;
    }
}

var s1 = new Student();
console.log(s1.name);  //boyStudent
</code></pre><ul>
<li><p>this指向失效问题</p>
<p>  var name = ‘window’;</p>
<p>  var Student = {</p>
<pre><code>name : &apos;kobe&apos;,
getName: function () {        
    console.log(this.name);  
}
</code></pre><p>  }</p>
<p>  Student.getName(); // kobe<br>  var s1 = Student.getName;<br>  s1(); //window</p>
</li>
</ul>
<p>原因: 此时s1是一个函数</p>
<pre><code>function () {        
        console.log(this.name);  
    }
</code></pre><p>对一个基本的函数,前面提过this在基本函数中指的是window.</p>
<ul>
<li>在开发中我们经常使用的this缓存法 ,缓存当前作用域下this到另外一个环境域下使用</li>
</ul>
<blockquote>
<p>最后理解apply的用法 Function.prototype.apply</p>
</blockquote>
<p>格式: fx.apply(thisArg [，argArray] ); // 参数数组，argArray</p>
<ol>
<li>apply与call的作用是一样的,只是传参方式不同,</li>
<li><p>apply接受两个参数,第一个也是fx函数体内this的指向,用法与call第一个参数一致.第二个参数是数组或者类数组,apply就是把这个数组元素传入函数fx.</p>
<p> var add = function (a ,b ,c) {</p>
<pre><code>console.log(a +b +c);
</code></pre><p> }</p>
<p> add.apply(null , [1,2,3]); // 6</p>
</li>
</ol>
<p>再吃透这个题目就ok</p>
<pre><code>var a=10;
var foo={
  a:20,
  bar:function(){
      var a=30;
      return this.a;
    }
}
foo.bar()
//20
(foo.bar)()
//20
(foo.bar=foo.bar)()
//10
(foo.bar,foo.bar)()
//10
</code></pre><p>上题注解：</p>
<h2 id="时刻牢记：作用域链查找遵循”就近原则”；"><a href="#时刻牢记：作用域链查找遵循”就近原则”；" class="headerlink" title="时刻牢记：作用域链查找遵循”就近原则”；"></a>时刻牢记：作用域链查找遵循”就近原则”；</h2><h2 id="this谁调用就指向谁。"><a href="#this谁调用就指向谁。" class="headerlink" title="this谁调用就指向谁。"></a>this谁调用就指向谁。</h2><pre><code>var a=10;
var foo={
  a:20,
  bar:function(){
      var a=30;  //this 指向 foo  ：console.log( this == foo) //true
      return this.a;
    }
}


foo.bar()   
//20
// foo.bar()    // foo调用，this指向foo , 此时的 this 指的是foo，所以是20 


(foo.bar)()
//20
//第一步：
(function(){
   var a=30; 
   return this.a;
})()    //作用域链向上查找,this 指向外一层的对象foo



(foo.bar=foo.bar)()
//10
foo.bar=foo.bar,【睁大眼睛，是单等号赋值】就是普通的复制,一个匿名函数赋值给一个全局变量,你可以把右边的foo.bar换成b,
即(b = foo.bar)(),博客里面【this指向失效问题】说过普通的函数里面的this指向window,自然this.a == 10





(foo.bar,foo.bar)()  //逗号表达式
//10
//(foo.bar,foo.bar)是一个小括号表达式,小括号表达式会依次创建两个匿名函数,并返回最后一个的匿名函数值,
(foo.bar,foo.bar) 得到的是这个函数
 function(){
     var a=30;
     console.log( this == foo); //如果不是很了解this的指向就加这个代码进行检测
     return this.a;
   }
 ,这个是匿名函数,匿名函数的this指的是widnow,那么this.a = 10


this可谓是JavaScript中的开发神器，使用得当的话不仅有事半功倍的效果，而且代码的逼格也更高。但是既然是神器，如果你没有足够的功力的话，那么就不要使用它，否则就有可能自毁身亡。曾几何时，我偶然得到这个神器，之后，，，自残，，，自残，，，再自残...再自残了那么多次后，终于可以拥有强大功力持此神器行走江湖了。接下来，我就为大家来传授传说中神器的使用秘诀。
咳咳。。
入正题。
this是什么？this表示当前运行方法的主体。
注意：函数中的this指向和当前函数在哪定义的话或者在哪执行都没有任何的关系。为啥这样说，请仔细阅读下面的秘籍大全。
神器秘籍大全：

秘籍一：自制行函数里面的this永远都是window
var inner = &quot;window&quot;;
var obj = {inner : &quot;obj&quot;,
          fn : (function () {console.log(this.inner)})()
}


上面浏览器在运行该程序时，会自动运行obj.fn里面的方法，因为obj.fn是一个自制行函数，当执行该函数时，程序会输出window。
额，为什么输出不是obj？
因为人家规定自制行函数里面的this是window,所以其实this.inner就是window.inner，因此这个inner是定义在全局变量的，它的值是&quot;window&quot;。

秘籍二：元素绑定事件驱动方法运行，方法里的this表示当前绑定的元素
var oDiv = document.getElementsByTagName(&quot;div&quot;)[0];
oDiv.onclick=function(){
    console.log(this);   //当用鼠标点击该元素，则输出oDiv元素的集合
 };
这个好理解，元素绑定某个行为执行的方法，就相当于把这个方法也绑定在这个元素上，所以this也就指向元素本身。

秘籍三：方法执行，看方法名前面是否有&quot;.&quot;，有的话&quot;.&quot;前面是谁this就是谁，没有的话this就是window

var obj={fn:fn};
function fn(){console.log(this)}
fn.prototype.aa=function(){console.log(this)};
var f=new fn;
fn();  //window..
obj.fn(); //Object..
fn.prototype.aa(); //fn.prototype
f.aa(); //f

记住此秘籍！！！

秘籍四：在构造函数模式中,函数体中的this是当前类的一个实例
function Fn(){
    this.x = 100;
    console.log(this);  // 实例 f
}
var f = new Fn;
构造函数生成的实例，故构造函数里的this当然是指向当前这个实例了。

秘籍五（大招）：call/apply来改变this的指向
var oDiv = document.getElementsByTagName(&quot;div&quot;)[0];
function fn() {
    console.log(this);
}
fn.call(oDiv);
fn.call(oDiv); //执行这个语句后，fn里面的this指向oDiv元素，applay用法与call类似。
此大招一出来，上面四个秘籍都无效了。
</code></pre><h2 id="五个典型的-JavaScript-面试题"><a href="#五个典型的-JavaScript-面试题" class="headerlink" title="五个典型的 JavaScript 面试题"></a>五个典型的 JavaScript 面试题</h2><h2 id="问题1-范围（Scope）"><a href="#问题1-范围（Scope）" class="headerlink" title="问题1: 范围（Scope）"></a>问题1: 范围（Scope）</h2><p>思考以下代码：<br><img src="https://pic4.zhimg.com/v2-3427ee7904e86825dc800f37b5dd76a1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3427ee7904e86825dc800f37b5dd76a1_hd.jpg" alt=""></p>
<p>控制台（console）会打印出什么？</p>
<p>答案</p>
<p>上述代码会打印出5。</p>
<p>这个问题的陷阱就是，在立即执行函数表达式（IIFE）中，有两个命名，但是其中变量是通过关键词var来声明的。这就意味着a是这个函数的局部变量。与此相反，b是在全局作用域下的。</p>
<p>这个问题另一个陷阱就是，在函数中他没有使用”严格模式” (‘use strict’;)。如果 严格模式 开启，那么代码就会报出未捕获引用错误（Uncaught ReferenceError）：b没有定义。记住，严格模式要求你在需要使用全局变量时，明确地引用该变量。因此，你需要像下面这么写：<br><img src="https://pic3.zhimg.com/v2-d2990958fbb99d5fe5b7c2f99fd67fc1_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-d2990958fbb99d5fe5b7c2f99fd67fc1_hd.jpg" alt=""></p>
<h2 id="问题2-创建-“原生（native）”-方法"><a href="#问题2-创建-“原生（native）”-方法" class="headerlink" title="问题2: 创建 “原生（native）” 方法"></a>问题2: 创建 “原生（native）” 方法</h2><p>在String对象上定义一个repeatify函数。这个函数接受一个整数参数，来明确字符串需要重复几次。这个函数要求字符串重复指定的次数。举个例子：<br><img src="https://pic2.zhimg.com/v2-9a26df01a60f8a3020e339a2cdc022dc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-9a26df01a60f8a3020e339a2cdc022dc_hd.jpg" alt=""></p>
<p>应该打印出hellohellohello.</p>
<p>答案</p>
<p>一种可能的实现如下所示：<br><img src="https://pic3.zhimg.com/v2-323205969d7c319efb3257e962fc0e13_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-323205969d7c319efb3257e962fc0e13_hd.jpg" alt=""></p>
<p>这个问题测试了开发人员对于JavaScript中继承的掌握，以及prototype这个属性。这也验证了开发人员是否有能力扩展原生数据类型的功能（虽然不应该这么做）。</p>
<p>这个问题的另一个重点是验证你是否意识到并知道如何避免覆盖已经存在的函数。这可以通过在自定义函数之前判断该函数是否存在来做到。<br><img src="https://pic3.zhimg.com/v2-145aeeefc3c8949329552b22fa9434b3_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-145aeeefc3c8949329552b22fa9434b3_hd.jpg" alt=""></p>
<p>当你需要为旧浏览器实现向后兼容的函数时，这一技巧十分有用。</p>
<h2 id="问题3-变量提升（Hoisting）"><a href="#问题3-变量提升（Hoisting）" class="headerlink" title="问题3: 变量提升（Hoisting）"></a>问题3: 变量提升（Hoisting）</h2><p>执行以下代码会有什么结果？为什么？<br><img src="https://pic2.zhimg.com/v2-76ce0e2d75c2302991e408d087476a59_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-76ce0e2d75c2302991e408d087476a59_hd.jpg" alt=""></p>
<p>答案</p>
<p>这段代码的执行结果是 undefined 和 2。</p>
<p>这个结果的原因是，变量和函数都被提升了（hoisted）。因此，在a被打印的时候，它已经在函数作用域中存在（即它已经被声明了），但是它的值依然是 undefined。换言之，上述代码和以下代码是等价的。<br><img src="https://pic4.zhimg.com/v2-e5d341549dabe574215e26dbf0535ae8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-e5d341549dabe574215e26dbf0535ae8_hd.jpg" alt=""></p>
<h2 id="问题4-this-在-JavaScript-中是如何工作的"><a href="#问题4-this-在-JavaScript-中是如何工作的" class="headerlink" title="问题4: this 在 JavaScript 中是如何工作的"></a>问题4: this 在 JavaScript 中是如何工作的</h2><p>以下代码的结果是什么？请解释你的答案。<br><img src="https://pic4.zhimg.com/v2-c7109c7158a7800b48c57ce5fcfd889a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c7109c7158a7800b48c57ce5fcfd889a_hd.jpg" alt=""></p>
<p>答案</p>
<p>上面的代码打印出 Aurelio De Rosa 和 John Doe。原因是在 JavaScript 中，一个函数的上下文环境，也就是this关键词所引用对象，是依赖于函数是如何被调用的，而不是依赖于函数如何被定义的。</p>
<p>在第一个 console.log() 调用中， getFullname() 是作为 obj.prop 的函数被调用的。因此，这里的上下文环境指向后者并且函数返回this对象的 fullname 属性。相反，当 getFullname() 被赋为test变量的值时，那个语境指向全局对象(window)。这是因为，test被隐式设置为全局对象的属性。因此，函数调用返回 window 的 fullname 属性值，在此段代码中，这个值是通过第一行赋值语句设置的。</p>
<h2 id="问题5-call-和-apply"><a href="#问题5-call-和-apply" class="headerlink" title="问题5: call() 和 apply()"></a>问题5: call() 和 apply()</h2><p>修复上一个问题，让最后一个 console.log() 打印出 Aurelio De Rosa。</p>
<p>答案</p>
<p>要解决这个问题，可以通过为函数 call() 或者 apply() 强制函数调用的上下文环境。如果你不知道 call() 和 apply() 之间的区别，我推荐阅读文章“ function.call 和 function.apply 之间有和区别?”。在以下代码中，我会用 call()，但是在这里，用 apply() 也可以获得相同的结果：<br><img src="https://pic4.zhimg.com/v2-6dd929db46959a48071adb146a84ba56_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6dd929db46959a48071adb146a84ba56_hd.jpg" alt=""></p>
<h2 id="常见面试："><a href="#常见面试：" class="headerlink" title="常见面试："></a>常见面试：</h2><pre><code>下面列举一些简单的实例 总结一下this的一些用法：


1.方法中的this会指向当前执行该方法的对象 如：

var name = &quot;window&quot;

var Tom = {

  name:&quot;Tom&quot;;

  show:function(){alert(this.name)}

}

Tom.show();   //Tom



2.方法中的this不会指向声明它的对象 如下


var Bob={
  name:&quot;Bob&quot;,
  show:function(){alert(this.name);}
  };

var Tom={
  name:&quot;Tom&quot;,
  show:Bob.show
  };

Tom.show() ;   //Tom

因为尽管alert(this.name)是在Bob对象环境中声明的


但该方法是由Tom对象调用执行所以this总是会指向当前执行的对象，而不是声明的对象





3.将方法复制给变量时，执行时仍然会以Tom对象区调用该方法


var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;.
  show:function(){alert(this.name)}
  };

var fun=Tom.show();
fun();              //Tom

可以看出赋值后再调用，并不影响调用其方法的对象



4.将对象赋值给变量后，再调用方法，执行的对象仍然是Tom

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){
             var that=this;
             that.show();
         }
  };

Tom.wait();  //Tom

这里that赋值了当前执行的对象，并让它继续调用show，
所以show方法中alert(this.name)自然而然的指向了Tom
可以把上面的 &quot;that赋值对象 然后调用方法&quot; 这个过程看做成执行对象
的延迟，就是让Tom加班的意思




 5.另一种 指明调用方法的对象 的办法 如下：


var name = &quot;window&quot;;
var Bob= {
    name:&quot;Bob&quot;,
    show:function(){alert(this.name);}
    };

 var Tom= {name: &quot;Tom&quot;};
 Bob.show();                   //Bob
 Bob.show.apply();             //window
 Bob.show.apply(Tom);          //Tom

 当然call()也差不多类似



6.下面来个特殊的例子

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){
             var fun=this.show;
             fun();
         }
  };

Tom.wait();  //window

上面也是赋值方法后，再调用，可是执行的对象却改成了window对象

解释：

在函数体内把方法赋值给变量再调用会导致对象更改为Window对象
执行fun时，可以看做是一种方法调用的延迟行为，延迟调用方法会使得执行的对象
变为全局对象也就是window对象


下面我们来看看其他几种延迟方式，导致对象被更改为window的例子



7.匿名函数的延迟

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){!function(call){call();}(this.show)}
  }

Tom.wait();    //Window




8.setTimeout、setInterval函数延迟
这里只以setTimeout为例子

var name=&quot;window&quot;;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){setTimeout(this.show,1000)}
  }

Tom.wait();    //window



9. 在延迟的环境下 尝试让Tom加班（对象也跟着延迟）

var name=&quot;window&quot;;
var Tom={  name:&quot;Tom&quot;,
show:function(){alert(this.name)},
wait:function(){setTimeout(Tom.show,1000)}  }

Tom.wait();    //window  



上面中this对象改成了Tom，尝试让Tom加班，但是结果仍然为Window对象
因为Tom.show放在第一个参数里，延迟的执行使得执行的对象变为window对象
而不再是Tom对象，如何让执行对象Tom在延迟当不被变更呢？下面给你答案


 10.虽然延迟会导致方法的执行对象被更改为Window 但也有办法防止执行对象更改 如下


var name=&quot;window&quot;
var  Tom ={  
    name : &quot;Tom&quot;,  
    show : function(){alert(this.name);},  
    wait:  function(){
    var that=this;
    setTimeout(function(){that.show()},1000)}  
          }

Tom.wait();    //Tom 

如果不能理解上面的代码，你就当做Tom对象也跟着函数一起延迟就好了
而第9个例子没有成功延迟，是因为没有变量保存对象使得执行对象没有跟着延迟





11.eval函数的延迟

对于eval比较特殊

在eval环境下，执行的对象就是当前作用域的对象 如下


var name=&quot;window&quot;;
var Bob={
  name:&quot;Bob&quot;,
  showName: function(){ eval(&quot;alert(this.name)&quot;); }
  };

Bob.showName(); //Bob








12.eval函数的环境下，不会受到延迟而影响函数执行的对象

之所以eval特殊是因为eval不受延迟的影响

var name=&quot;window&quot;;
var that;
var Tom={
  name:&quot;Tom&quot;,
  show:function(){alert(this.name)},
  wait:function(){that=this;setTimeout(&quot;that.show()&quot;,1000)}
  }

Tom.wait();    //Tom



也许你会觉得上面的代码没有eval函数的身影
其实setTimeout函数的第一个参数就是eval环境
他会指向当前执行作用域的执行对象，忽略延迟方法延迟调用



如果能把上面12个例子都理解了，那么this将成为你的一把有力的刀，挥舞在你代码中
当然如果不能理解，那么像闭包一样 尽量的少用！
</code></pre><p>函数是JavaScript世界里的第一公民，换句话来说，就是我们如果可以精通JavaScript函数的使用，那么对JavaScript的运用可以更游刃有余了。熟悉JavaScript的人应该都知道，同样的函数，以不同的方式调用的话，受影响最大的应该是  this 。下面我们来说说JavaScript函数的各种调用模式。</p>
<p>一、普通函数的调用模式</p>
<p>　　所谓普通函数的调用模式，也是JavaScript函数的最简单的一种调用模式，直接就是函数名后接一个  ()  实现调用，看下面代码：</p>
<pre><code>function func(){
    console.log(this === window);  //true
}
func();
</code></pre><p>　　上面代码，我们用function关键字声明了一个 func 函数，并且在函数体内打印 this===window，然后我们直接调用函数func，我们可以看到控制台是直接打印出 true ，也就是说，函数的这种普通调用模式，函数体内的  this  是指向全局环境 window 的。不清楚这点的同学，可以能会遇到这样的一个bug：</p>
<pre><code>var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        function func1(){
            console.log(this.color);  //gg
        }
        func1();
    }
}
obj.show(); 
</code></pre><p>　　我们在全局环境下声明了一个变量 color 和一个对象 obj ，在对象 obj 里面我们还声明了一个 color 属性 为 ‘red’，一个 show 方法。而且在 show 方法里面呢，我们还声明了一个函数 func1 并且调用了 func1，func1 的作用是打印 this.color。最后我们运行代码  obj.show();   调用obj里面的show方法。不清楚函数的普通调用模式的特点的同学可能会认为此时在控制台答应出来的会是  ‘red’ 。实际上此时在控制台答应出来的应该是  gg  。因为函数  func1  的调用模式是 普通函数调用模式（即使它是在  obj  的  show  方法里面调用的），所以此时函数体内的  this  是指向 全局环境window 的，所以就打印了全局环境下的变量  color 。</p>
<p>　　可能有些同学会问：如果我们希望  func1  函数打印出来的是 ‘red’ 呢，应该怎么改？其实很简单，因为  obj.color  才是 ‘red’ ，所以我们只需要把  指向  obj  的  this 引入到函数 func1  里面就行了： </p>
<pre><code>var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        var that = this;
        function func1(){
            console.log(that.color);  //red
        }
        func1();
    }
}
obj.show();
var color = &apos;gg&apos;;
var obj = {
    color : &apos;red&apos;,
    show : function(){
        var func1=function(){
            console.log(this.color);  //red
        }.bind(this);
        func1();
    }
}
obj.show();
</code></pre><p>　　在上面的代码中，因为  show  里面的   this  指向   obj   的，所以我们在  show  里面声明一个变量  that = this;用来把指向  obj  的  this  引入到  func1 中，然后再把 func1 函数体内的  this.color  改为  that.color ,此时在控制台打印出来的就是我们想要的 ‘red’ 了。</p>
<p>　　可能现在又有同学会问：为什么   show   里面的  this  是指向  obj 的呢？这就是我们要说的JavaScript函数的第二种调用模式：方法调用模式</p>
<p>二、方法调用模式</p>
<p>　　方法调用模式，简单来说就是把一个 JavaScript函数作为一个对象的方法来调用，当一个函数被保存为一个对象的属性是，我们就把它称为方法，例如上文的  obj  对象里的  show  ，当一个方法被调用时，函数体里面的   this  就会绑定到这个对象，例如上文的 show 里面的  this  。方法调用模式也很容易辨别：obj.show()，对象名 . 属性名 () ；代码的话可以参考上文的  obj  代码 ，博主就不多写了。记住：方法的调用是可以在函数体内通过  this  访问自己所属的那个对象的。</p>
<p>三、构造器调用模式</p>
<p>博主认为构造器调用模式是相对于其他模式来说较为复杂点的调用模式了。通过关键字  new  可以把一个函数作为构造器来调用。关键字  new  可以改变函数的返回值：</p>
<pre><code>function func2(name){
    this.name = name;
}

name;   //undefined

//普通函数调用模式
var foo = func2(&apos;afei&apos;);
foo;  //undefined
name;   //afei


//构造器调用模式
var bar = new func2(&apos;lizefei&apos;);
bar.__proto__ === func2.prototype;  //true
bar;  //{name:&apos;lizefei&apos;}
bar.name;  //&apos;lizefei&apos;
</code></pre><p>　　在上示代码中我们声明了一个函数 func2 ，分别用两种不同的调用模式去调用它。因为函数  func2  并没有显式返回值，所以作为普通函数去调用时，它什么也没有返回，所以  foo  的值是  undefined  。因为普通调用模式的   this   是指向 全局环境   window  的，所以  func2(‘afei’);  后，全局环境下就多了一个  name 变量且等于 ‘afei’。</p>
<p>　　func2  作为构造器调用时，我们可以看到，它返回的是一个对象，因为关键字  new  使得函数在调用是发生了如下的特殊变化：</p>
<ol>
<li>　　创建了一个新对象，而且这个新对象是链接到 func2  的  prototype  属性的</li>
<li>　　把函数里的  this  指向了这个新对象</li>
<li>　　如果没有显式的返回值，新对象作为构造器func2的返回值进行返回（所以bar 是 {name:’lizefei’}）</li>
</ol>
<p>这样子我们就可以看出构造器的作用：通过函数的调用来初始化新创建出来的对象。在JavaScript的面向对象编程里面，这个可是相当重要的。</p>
<p>　　因为在函数的声明上，在未来作为构造器调用的函数和普通函数的声明没什么区别，所以导致后来的开发者很容易因为调用模式的错误导致程序出问题。所以开发者们都默契地约定，用来做构造器调用的函数的函数名的第一个字符应该大写，例如：Person，People。这样子后来的开发者一看到函数名就知道要用构造器调用模式调用此函数了。</p>
<p>四、使用apply()和call()方法调用</p>
<p>　　这种调用的模式是为了更灵活控制函数运行的上下文环境而诞生的。简单的说就是为了灵活控制函数体内  this  的值。</p>
<p>　　apply 和 call这两个方法的第一个参数都是要传递被函数上下文的对象（简单点说就是要绑定给函数  this  的对象）。其他参数就有所不同了：</p>
<p>　　apply方法的第二个参数是一个数组，数组里面的值将作为函数调用的参数；</p>
<p>　　call方法，从第二个参数起（包括第二个参数），剩下的参数都是作为函数调用的参数；</p>
<p>　　让我们看看栗子：</p>
<pre><code>var obj = {
    name :&apos;afei&apos;
}
function say(ag1,ag2){
    console.log(ag1+&apos;:&apos;+ag2+&quot; &quot;+ this.name);
}
say.apply(obj,[&apos;apply方法&apos;,&apos;hello&apos;]); //apply方法:hello afei
say.call(obj,&apos;call方法&apos;,&apos;hi&apos;); //call方法:hi afei
</code></pre><p>　　正如栗子所示，我们把对象 obj  作为函数  say  的上下文来调用函数  say  ，所以函数里的  this  是指向 对象  obj  的。在apply方法里，我们通过数组  [‘apply方法’,’hello’]  给  say  方法传递了两个参数（’apply方法’ 和 ‘hello’），所以打印出来是：  apply方法:hello afei。</p>
<p>　　同理  call 也是一样，而且函数传递的方式通过上面的代码也一目了然我，博主就不多做解释了。</p>
<p>　　另外，博主还听说apply和call这两个方法除了传递参数的方式不一样，执行的速度还是apply 比 call 要快呢。不过博主就没有实验过。</p>
<p>五、总结</p>
<p>　　在JavaScript里面，函数只要的调用模式就是这几种了（在ES6里面还有一种很奇怪很特殊的函数调用模式，叫做’标签模板‘，在这里博主也不多说了，有空另更），只要掌握了这几种主要的调用模式，那么日后再也不用担心  this 的值变来变去了。</p>
<p>　　上文如果有漏的、有错误的地方，望各位小伙伴指出，小弟虚心向学。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/交叉观察器-intersectionObserver-Vue实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/交叉观察器-intersectionObserver-Vue实战/" itemprop="url">交叉观察器(intersectionObserver) Vue实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T23:04:27+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考文章：IntersectionObserver-API-使用教程"><a href="#参考文章：IntersectionObserver-API-使用教程" class="headerlink" title="参考文章：IntersectionObserver API 使用教程"></a>参考文章：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">IntersectionObserver API 使用教程</a></h2><h2 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener">Intersection Observer</a></h2><h2 id="【译】使用-Intersection-Observer-实现图片延迟加载"><a href="#【译】使用-Intersection-Observer-实现图片延迟加载" class="headerlink" title="【译】使用 Intersection Observer 实现图片延迟加载"></a><a href="https://link.zhihu.com/?target=https%3A//c7sky.com/lazy-loading-images-using-intersection-observer.html" target="_blank" rel="noopener">【译】使用 Intersection Observer 实现图片延迟加载</a></h2><p>intersectionObserver解决什么问题？</p>
<p>intersectionObserver解决目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”，</p>
<p>比如在web网页开发中，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。</p>
<p>传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">getBoundingClientRect()</a>方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">性能问题</a>。</p>
<p>目前有一个新的 <a href="https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/" target="_blank" rel="noopener">IntersectionObserver API</a>，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p>
<blockquote>
<p>IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，<code>IntersectionObserver</code>的实现，应该采用<code>requestIdleCallback()</code>，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p>
</blockquote>
<p>IntersectionObserverEntry 对象</p>
<p><code>IntersectionObserverEntry</code>对象提供目标元素的信息，一共有六个属性。</p>
<pre><code>{
  time: 3893.92,
  rootBounds: ClientRect {
    bottom: 920,
    height: 1024,
    left: 0,
    right: 1024,
    top: 0,
    width: 920 },
  boundingClientRect: ClientRect {  // ...
 },
  intersectionRect: ClientRect {  // ...
 },
  intersectionRatio: 0.54,
  target: element
} 
</code></pre><p>每个属性的含义如下。</p>
<ul>
<li><code>time</code>：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li>
<li><code>target</code>：被观察的目标元素，是一个 DOM 节点对象</li>
<li><code>rootBounds</code>：根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回<code>null</code></li>
<li><code>boundingClientRect</code>：目标元素的矩形区域的信息</li>
<li><code>intersectionRect</code>：目标元素与视口（或根元素）的交叉区域的信息</li>
<li><code>intersectionRatio</code>：目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全可见时为<code>1</code>，完全不可见时小于等于<code>0</code></li>
</ul>
<p>现在我们已经创建了一个 Intersection Observer 并且正在观察页面上的图片，我们现在来了解 intersection 事件，它将在元素进入视区时触发。</p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>此时此刻，你也许想知道关于这项特性的浏览器支持情况。Intersection Observer 现在已被 <a href="https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dintersectionobserver" target="_blank" rel="noopener">Edge、Firefox、Chrome 和 Opera</a> 支持，这是一个好消息。</p>
<p>然而，为了确保我们的代码不会在不支持它的浏览器中造成破坏，我们可以使用特性检测来确定我们应该如何来加载图片。让我们看看下面的代码。</p>
<pre><code>// If we don&apos;t have support for intersection observer, load the images immediately
if (!(&apos;IntersectionObserver&apos; in window)) {
  Array.from(images).forEach(image =&gt; preloadImage(image));
} else {
  // It is supported, load the images
  observer = new IntersectionObserver(onIntersection, config);
  images.forEach(image =&gt; {

   observer.observe(image);
  });
}
view raw
</code></pre><p>Vue:</p>
<pre><code>&lt;template&gt;
    &lt;img :src=&quot;lazysrc&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
    import Bus from &apos;../bus&apos;;
    import nonepng from &apos;../../assets/img/none.png&apos;;

    export default {
        name: &apos;lazyimg&apos;,
        data: function() {
            return {
                isShow: false,
                lazysrc: nonepng
            }
        },
        mounted() {
            if(!this.needlazy) {
                this.lazysrc = this.src;
            } else {
                if(!(&apos;IntersectionObserver&apos; in window)) {
                    //TODO
                } else {
                    var io = new IntersectionObserver(
                        entries =&gt; {
                            entries.forEach(i =&gt; {
                                if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发
                                    i.target.setAttribute(&quot;src&quot;, this.src)
                                }
                            });
                        }, {
                            threshold: [0, 0.25, 0.5, 0.75, 1],
                        }
                    );
                    io.observe(this.$el);
                }
            }
        },
        props: {
            needlazy: {
                type: Boolean,
                default: false,
            },
            src: {
                type: String,
                default: &apos;&apos;,
            },
        }
    };
&lt;/script&gt;
</code></pre><blockquote>
<p>通常都是通过判断intersectionRatio来做某些事，比如当intersectionRatio大于多少的时候做什么事，加载图片等！</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_hd.jpg" alt=""><br>   灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的<code>intersectionRatio</code>图中都已经注明。</p>
<p>DEMO：  <a href="https://zhuanlan.zhihu.com/p/25455672" target="_blank" rel="noopener">延迟加载(Lazyload)三种实现方式</a></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
        &lt;title&gt; &lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            * {
                padding: 0px;
                margin: 0px;
                outline: none;
            }

            body {}

            #main {
                margin: 0 auto;
                width: 600px;
                height: 300px;
                overflow: scroll;
            }

            #con {
                width: 1200px;
                height: 300px;
            }

            .cc {
                width: 300px;
                height: 300px;
                float: left;
                background-size: cover;
            }

            #a {
                background-color: red;
            }

            #b {
                background-color: black;
            }

            #c {
                background-color: blue;
            }

            #d {
                background-color: green;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;
            &lt;div id=&quot;con&quot;&gt;
                &lt;div id=&quot;a&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;b&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;c&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;d&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var io = new IntersectionObserver(
            entries =&gt; {
                console.log(&apos;********************************&apos;);
                console.log(entries);
                console.log(&apos;********************************&apos;);
                entries.forEach(i =&gt; {
                    console.log(&apos;================================&apos;);
                    console.log(&apos;Time: &apos; + i.time);
                    console.log(&apos;Target: &apos; + i.target.nodeName);
                    console.log(&apos;IntersectionRatio: &apos; + i.intersectionRatio);
                    console.log(&apos;rootBounds: &apos; + i.rootBounds);
                    console.log(i.boundingClientRect);
                    console.log(i.intersectionRect);
                    console.log(&apos;================================&apos;);

                    if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发
                        console.log(&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&apos;);
                        i.target.style.backgroundImage = &quot;url(&quot; + &apos;http://pic35.photophoto.cn/20150528/0020032932102307_b.jpg&apos; + &quot;)&quot;
                    }

                });
            }, {
                /* Using default options. Details below */
                threshold: [0, 0.25, 0.5, 0.75, 1],   //会执行5次
            }
        );
        // Start observing an element
        io.observe(document.querySelector(&apos;#d&apos;));
        io.observe(document.querySelector(&apos;#c&apos;));
    &lt;/script&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic1.zhimg.com/v2-83bcd2ce4df13a07da99e0c051e9fcaa_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-83bcd2ce4df13a07da99e0c051e9fcaa_hd.jpg" alt=""></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Lazyload 3&lt;/title&gt;
    &lt;style&gt;
        img {
        display: block;
        margin-bottom: 50px;
        width: 800px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/1.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/2.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/3.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/4.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/5.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/6.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/7.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/8.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/9.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/10.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/11.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/12.png&quot;&gt;
    &lt;script&gt;
    function query(selector) {
        return Array.from(document.querySelectorAll(selector));
    }
    var io = new IntersectionObserver(function(items) {
        items.forEach(function(item) {
        var target = item.target;
        if(target.getAttribute(&apos;src&apos;) == &apos;images/loading.gif&apos;) {
            target.src = target.getAttribute(&apos;data-src&apos;);
        }
        })
    });
    query(&apos;img&apos;).forEach(function(item) {
        io.observe(item);
    });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>IntersectionObserver 传入一个回调函数，当其观察到元素集合出现时候，则会执行该函数。</li>
<li>io.observe 即要观察的元素，要一个个添加才可以。</li>
<li>io 管理的是一个数组，当元素出现或消失的时候，数组添加或删除该元素，并且执行该回调函数。</li>
</ol>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><p>它的用法非常简单。</p>
<pre><code>var io = new IntersectionObserver(callback, option); 
</code></pre><p>上面代码中，<code>IntersectionObserver</code>是浏览器原生提供的构造函数，接受两个参数：<code>callback</code>是可见性变化时的回调函数，<code>option</code>是配置对象（该参数可选）。</p>
<p>构造函数的返回值是一个观察器实例。实例的<code>observe</code>方法可以指定观察哪个 DOM 节点。</p>
<pre><code>// 开始观察
io.observe(document.getElementById(&apos;example&apos;)); 
// 停止观察
io.unobserve(element); 
// 关闭观察器
io.disconnect(); 
</code></pre><p>上面代码中，<code>observe</code>的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p>
<pre><code>io.observe(elementA);
io.observe(elementB); 
</code></pre><h2 id="二、callback-参数"><a href="#二、callback-参数" class="headerlink" title="二、callback 参数"></a>二、callback 参数</h2><p>目标元素的可见性变化时，就会调用观察器的回调函数<code>callback</code>。</p>
<p><code>callback</code>一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p>
<pre><code>var io = new IntersectionObserver(
  entries =&gt; {
    console.log(entries); } 
); 
</code></pre><p>上面代码中，回调函数采用的是<a href="https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/function%23%25E7%25AE%25AD%25E5%25A4%25B4%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">箭头函数</a>的写法。<code>callback</code>函数的参数（<code>entries</code>）是一个数组，每个成员都是一个<code>[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)</code>对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code>数组就会有两个成员。</p>
<h2 id="三、Option-对象"><a href="#三、Option-对象" class="headerlink" title="三、Option 对象"></a>三、Option 对象</h2><p>IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p>
<p><code>[IntersectionObserver.root](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/root)</code> 只读所监听对象的具体祖先元素(<code>[element](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Element)</code>)。如果未传入任何值或值为null，则默认使用viewport。</p>
<p><code>[IntersectionObserver.rootMargin](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/rootMargin)</code> 只读计算交叉时添加到根(root)边界盒<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Glossary/bounding_box" target="_blank" rel="noopener">bounding box</a>的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。此属性返回的值可能与调用构造函数时指定的值不同，因此可能需要更改该值，以匹配内部要求。所有的偏移量均可用像素(pixel)(px)或百分比(percentage)(%)来表达, 默认值为”0px 0px 0px 0px”。</p>
<p><code>[IntersectionObserver.thresholds](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/thresholds)</code> 只读一个包含阈值的list, 升序排列, list中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会生成一个通知(Notification)。如果构造器未传入值, 则默认值为0.</p>
<p>threshold 属性</p>
<p><code>threshold</code>属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为<code>[0]</code>，即交叉比例（<code>intersectionRatio</code>）达到<code>0</code>时触发回调函数。</p>
<pre><code>new IntersectionObserver(
  entries =&gt; {/* ... */}, {
    threshold: [0, 0.25, 0.5, 0.75, 1] } ); 
</code></pre><p>用户可以自定义这个数组。比如，<code>[0, 0.25, 0.5, 0.75, 1]</code>就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p>
<p>root 属性，rootMargin 属性</p>
<p>很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在<code>iframe</code>窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。</p>
<p>IntersectionObserver API 支持容器内滚动。<code>root</code>属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p>
<pre><code>var opts = { 
  root: document.querySelector(&apos;.container&apos;),
  rootMargin: &quot;500px 0px&quot; 
}; 

var observer = new IntersectionObserver(
  callback,
  opts
); 
</code></pre><p>上面代码中，除了<code>root</code>属性，还有<code>[rootMargin](https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/%23dom-intersectionobserverinit-rootmargin)</code>属性。后者定义根元素的<code>margin</code>，用来扩展或缩小<code>rootBounds</code>这个矩形的大小，从而影响<code>intersectionRect</code>交叉区域的大小。它使用CSS的定义方法，比如<code>10px 20px 30px 40px</code>，表示 top、right、bottom 和 left 四个方向的值。</p>
<pre><code>//离视窗还有top=500px 或者 bottom=500 触发加载
rootMargin = `500px 0px`  
//离视窗还有top=-500px 或者 bottom=-500 触发加载 （惰性加载）
rootMargin = `-500px 0px` 
</code></pre><p>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p>
<h2 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h2><p><code>[IntersectionObserver.disconnect](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/disconnect)</code>使IntersectionObserver对象停止监听工作。</p>
<p><code>[IntersectionObserver.observe](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/observe)使IntersectionObserver开始监听一个目标元素。</code></p>
<p><code>[IntersectionObserver.takeRecords](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/takeRecords)</code>为所有监听目标返回一个<code>[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry)</code>对象数组并且停止监听这些目标。</p>
<p><code>[IntersectionObserver.unobserve](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/unobserve)使IntersectionObserver停止监听特定目标元素。</code></p>
<h2 id="五、Vue（xunleif2e-vue-lazy-component）"><a href="#五、Vue（xunleif2e-vue-lazy-component）" class="headerlink" title="五、Vue（xunleif2e/vue-lazy-component）"></a>五、Vue（<a href="https://link.zhihu.com/?target=https%3A//github.com/xunleif2e/vue-lazy-component" target="_blank" rel="noopener">xunleif2e/vue-lazy-component</a>）</h2><p>核心 VueLazyComponent.vue</p>
<pre><code>&lt;template&gt;
  &lt;transition-group :tag=&quot;tagName&quot; name=&quot;lazy-component&quot; style=&quot;position: relative;&quot;
    @before-enter=&quot;(el) =&gt; $emit(&apos;before-enter&apos;, el)&quot;
    @before-leave=&quot;(el) =&gt; $emit(&apos;before-leave&apos;, el)&quot;
    @after-enter=&quot;(el) =&gt; $emit(&apos;after-enter&apos;, el)&quot;
    @after-leave=&quot;(el) =&gt; $emit(&apos;after-leave&apos;, el)&quot;
  &gt;
    &lt;div v-if=&quot;isInit&quot; key=&quot;component&quot;&gt;
      &lt;slot :loading=&quot;loading&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div v-else-if=&quot;$slots.skeleton&quot; key=&quot;skeleton&quot;&gt;
      &lt;slot name=&quot;skeleton&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div v-else key=&quot;loading&quot;&gt;
    &lt;/div&gt;
  &lt;/transition-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: &apos;VueLazyComponent&apos;,

    props: {
      timeout: {
        type: Number
      },
      tagName: {
        type: String,
        default: &apos;div&apos;
      },
      viewport: {
        type: typeof window !== &apos;undefined&apos; ? window.HTMLElement : Object,
        default: () =&gt; null
      },
      threshold: {
        type: String,
        default: &apos;0px&apos;
      },
      direction: {
        type: String,
        default: &apos;vertical&apos;
      },
      maxWaitingTime: {
        type: Number,
        default: 50
      }
    },

    data () {
      return {
        isInit: false,
        timer: null,
        io: null,
        loading: false
      }
    },

    created () {
      // 如果指定timeout则无论可见与否都是在timeout之后初始化
      if (this.timeout) {
        this.timer = setTimeout(() =&gt; {
          this.init()
        }, this.timeout)
      }
    },

    mounted () {
      if (!this.timeout) {
        // 根据滚动方向来构造视口外边距，用于提前加载
        let rootMargin
        switch (this.direction) {
          case &apos;vertical&apos;:
            rootMargin = `${this.threshold} 0px`
            break
          case &apos;horizontal&apos;:
            rootMargin = `0px ${this.threshold}`
            break
        }

        // 观察视口与组件容器的交叉情况
        this.io = new window.IntersectionObserver(this.intersectionHandler, {
          rootMargin,
          root: this.viewport,
          threshold: [ 0, Number.MIN_VALUE, 0.01]
        })
        this.io.observe(this.$el)
      }
    },

    beforeDestroy () {
      // 在组件销毁前取消观察
      if (this.io) {
        this.io.unobserve(this.$el)
      }
    },

    methods: {
      // 交叉情况变化处理函数
      intersectionHandler (entries) {
        if (
          // 正在交叉
          entries[0].isIntersecting ||
          // 交叉率大于0
          entries[0].intersectionRatio
        ) {
          this.init()
          this.io.unobserve(this.$el)
        }
      },

      // 处理组件和骨架组件的切换
      init () {
        // 此时说明骨架组件即将被切换
        this.$emit(&apos;beforeInit&apos;)
        this.$emit(&apos;before-init&apos;)

        // 此时可以准备加载懒加载组件的资源
        this.loading = true

        // 由于函数会在主线程中执行，加载懒加载组件非常耗时，容易卡顿
        // 所以在requestAnimationFrame回调中延后执行
        this.requestAnimationFrame(() =&gt; {
          this.isInit = true
          this.$emit(&apos;init&apos;)
        })
      },

      requestAnimationFrame (callback) {
        // 防止等待太久没有执行回调
        // 设置最大等待时间
        setTimeout(() =&gt; {
          if (this.isInit) return
          callback()
        }, this.maxWaitingTime)

        // 兼容不支持requestAnimationFrame 的浏览器
        return (window.requestAnimationFrame || ((callback) =&gt; setTimeout(callback, 1000 / 60)))(callback)
      }
    }
  }
&lt;/script&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/Raect-异步加载组件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/Raect-异步加载组件/" itemprop="url">Raect 异步加载组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T23:09:27+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先需要知道的是dynamic import通过返回Promise的方式实现异步加载功能。</p>
<pre><code>import(&apos;./component.js&apos;)  
    .then((m) =&gt; {
        // 处理异步加载到的模块m
    })
    .catch((err) =&gt; {
        // 错误处理
    });
</code></pre><p>要注意的是import的参数不能使用变量，简单原则是至少要让Webpack知晓应该预先加载哪些内容。这里的参数除了使用常量之外，还可以使用模板字符串<code>componentDir/${name}.js</code>。</p>
<p>其实到这里基本完成代码切割了，接下来做得就是结合react-router实现按模块异步加载。这是跟业务代码相关的，因此每个人的做法都是不一样的。所以以下代码仅供参考。</p>
<p>异步加载</p>
<p>我参考react-router的例子写了个简单的异步加载组件AsyncLoader.js，内容：</p>
<pre><code>import React from &apos;react&apos;;

export default class AsyncLoader extends React.Component {

  static propTypes = {
    path: React.PropTypes.string.isRequired,
    loading: React.PropTypes.element,
  };

  static defaultProps = {
    path: &apos;&apos;,
    loading: &lt;p&gt;Loading...&lt;/p&gt;,
    error: &lt;p&gt;Error&lt;/p&gt;
  };

  constructor(props) {
    super(props);
    this.state = {
      module: null
    };
  }

  componentWillMount() {
    this.load(this.props);
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.path !== this.props.path
      || nextProps.error !== this.props.error
      || nextProps.loading !== this.props.loading) {
      this.load(nextProps);
    }
  }

  load(props) {

    this.setState({module: props.loading});

    // TODO：异步代码的路径希望做成可以配置的方式
    import(`./path/${props.path}`)
      .then((m) =&gt; {
        let Module = m.default ? m.default : m;
        console.log(&quot;module: &quot;, Module);
        this.setState({module: &lt;Module/&gt;});
      }).catch(() =&gt; {
        this.setState({module: props.error});
      });
  }

  render() {
    return this.state.module;
  }
}
</code></pre><p>使用方法</p>
<pre><code>&lt;Route  
    exact path=&apos;/book&apos; 
    render={()=&gt;&lt;AsyncLoader path={&apos;./components/Book.js&apos;}/&gt;} 
/&gt;
</code></pre><p>Webpack打包的时候会根据import的参数生成相应的js文件，默认使用id（webpack生成的，从0开始）命名这个文件。</p>
<pre><code>const Search = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;search&quot; */ &quot;./containers/Search/SearchContainer&quot;))
const BookList = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;bookList&quot; */ &quot;./containers/BookList/BookListContainer&quot;))


import React from &apos;react&apos;
export const asyncComponent = loadComponent =&gt; (
    class AsyncComponent extends React.Component {
        state = {
            Component: null,
        }

        componentWillMount() {
            if (this.hasLoadedComponent()) {
                return;
            }

            loadComponent()
                .then(module =&gt; module.default) ////兼容 module.default ? module.default : module
                .then((Component) =&gt; {
                    this.setState({ Component });
                })
                .catch((err) =&gt; {
                    console.error(`Cannot load component in &lt;AsyncComponent /&gt;`);
                    throw err;
                });
        }

        hasLoadedComponent() {
            return this.state.Component !== null;
        }

        render() {
            const { Component } = this.state;
            return (Component) ? &lt;Component {...this.props} /&gt; : null;
        }
    }
); 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/08/HTML5的Websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/08/HTML5的Websocket/" itemprop="url">HTML5的Websocket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-08T22:18:50+08:00">
                2018-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>先请来TA的邻居：*<br>http：无状态、基于tcp请求/响应模式的应用层协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么）tcp：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) 传输层协议。（看啊，大阅兵，如此规整有秩序）</li>
</ul>
</blockquote>
<h2 id="为什么要引入Websocket："><a href="#为什么要引入Websocket：" class="headerlink" title="为什么要引入Websocket："></a>为什么要引入Websocket：</h2><blockquote>
<p>RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。</p>
</blockquote>
<p>long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。</p>
<p><img src="https://pic3.zhimg.com/v2-b900392bfe564de524ec5460a2b5d235_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b900392bfe564de524ec5460a2b5d235_hd.jpg" alt=""></p>
<p>从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p>
<p>这个时候，Websocket出现了。</p>
<h2 id="Websocket是什么："><a href="#Websocket是什么：" class="headerlink" title="Websocket是什么："></a>Websocket是什么：</h2><blockquote>
<p>RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。</p>
</blockquote>
<p>对，划重点：双向通信</p>
<p>Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以主动向客户端推送消息。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。</p>
<p>其特点：</p>
<p>（1）握手阶段采用 HTTP 协议，默认端口是80和443</p>
<p>（2）建立在TCP协议基础之上，和http协议同属于应用层</p>
<p>（4）可以发送文本，也可以发送二进制数据</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信</p>
<p>（6）协议标识符是ws（如果加密，为wss），如ws://localhost:8023</p>
<p>简单来说，Websocket协议分为两部分：握手和数据传输。</p>
<p><img src="https://pic2.zhimg.com/v2-5b1e92b99d352ba977f69cbe28604ecf_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5b1e92b99d352ba977f69cbe28604ecf_hd.jpg" alt=""></p>
<h2 id="Websocket-API："><a href="#Websocket-API：" class="headerlink" title="Websocket API："></a>Websocket API：</h2><blockquote>
<p>这里是指客户端 API。</p>
</blockquote>
<h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><ol>
<li><code>通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。</code></li>
<li><code>const ws =`</code>new<code></code>WebSocket(‘ws://localhost:8023’);`</li>
</ol>
<h2 id="Websocket事件"><a href="#Websocket事件" class="headerlink" title="Websocket事件"></a>Websocket事件</h2><ol>
<li><code>WebSocket`</code>是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。`</li>
</ol>
<p>open:</p>
<p>服务端响应WebSocket连接请求，就会触发open事件。onopen是响应的回调函数。</p>
<p><code>// 连接请求open事件处理：</code></p>
<pre><code>ws.onopen=e=&gt;{
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果要指定多个回调函数，可以使用addEventListener方法。</p>
<pre><code>ws.addEventListener(&apos;open&apos;, e =&gt; {
 ws.send(`Hello ${e}`);
});
</code></pre><p>当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。</p>
<p>Message:</p>
<p>收到服务器数据，会触发消息事件，onmessage是响应的回调函数。如下：</p>
<pre><code>// 接受文本消息的事件处理：
ws.onmessage = e =&gt; {
const data = e.data;
if (typeof data === &quot;string&quot;) {
       console.log(&quot;Received string message &quot;,data);
} else if (data instanceof Blob) {
       console.log(&quot;Received blob message &quot;, data);
}
};
</code></pre><p>服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p>
<p>Error</p>
<p>发生错误会触发error事件, onerror是响应的回调函数, 会导致连接关闭。</p>
<pre><code>//异常处理
ws.onerror = e =&gt; {
   console.log(&quot;WebSocket Error: &quot; , e);
   handleErrors(e);
};
</code></pre><p>当连接关闭时触发close事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再通信。</p>
<p>WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧）</p>
<pre><code>//关闭连接处理
ws.onclose = e =&gt; {
const code = e.code;
const reason = e.reason;
   console.log(&quot;Connection close&quot;, code, reason);
};
</code></pre><h2 id="WebSocket-方法："><a href="#WebSocket-方法：" class="headerlink" title="WebSocket 方法："></a>WebSocket 方法：</h2><blockquote>
<p>WebSocket 对象有两个方法：send 和 close</p>
</blockquote>
<p>send:</p>
<p>客户端和服务器建立连接后，可以调用send方法去发送消息。</p>
<pre><code>//发送一个文本消息
ws.send(&quot;this is websocket&quot;);
</code></pre><p>在open事件的回调中调用send()方法传送数据：</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;);
ws.onopen = e =&gt; {
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState.</p>
<p>close</p>
<p>close方法用来关闭连接。调用close方法后，将不能发送数据。close方法可以传入两个可选的参数，code 和reason, 以告诉服务端为什么终止连接。</p>
<pre><code>ws.close();

//1000是状态码，代表正常结束。
ws.close(1000, &quot;Closing normally&quot;);
</code></pre><h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><ul>
<li>readyState：</li>
</ul>
<p>readyState值表示连接状态，是只读属性。它有以下四个值：</p>
<blockquote>
<p>WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开</p>
</blockquote>
<p>除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。</p>
<pre><code>function bindEventHandler(data) {
if (ws.readyState === WebSocket.OPEN) {
       ws.send(data);
} else {
//do something
}
} 
</code></pre><p>bufferedAmount：</p>
<p>当客户端传输大量数据时，浏览器会缓存将要流出的数据，bufferedAmount属性可判断有多少字节的二进制数据没有发送出去，发送是否结束。</p>
<pre><code>ws.onopen = function () {
   setInterval( function() {
//缓存未满的时候发送
if (ws.bufferedAmount &lt; 1024 * 5) {
           ws.send(data);
}
}, 2000);
};
</code></pre><p>protocol：</p>
<p>protocol代表客户端使用的WebSocket协议。当握手协议未成功，这个属性是空。</p>
<ul>
<li>接下来，我们说说握手阶段过程。*</li>
</ul>
<p>当我们创建Websocket实例对象与服务器建立连接时，</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;)；
</code></pre><p>首先客户端向服务器发起一个握手请求，其请求报文的内容如下：</p>
<pre><code>GET /game HTTP/1.1
Host: 10.242.17.102:8023
Cache-Control: no-cache
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Protocol: game
Sec-WebSocket-Version: 10
Origin: http://192.168.185.16
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
</code></pre><p>从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。</p>
<ul>
<li>Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。</li>
<li>Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信</li>
<li>Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议</li>
<li>Sec-WebSocket-Version: 通知服务器所使用的协议版本</li>
</ul>
<p>服务器响应：</p>
<pre><code>当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。 
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ=
</code></pre><ul>
<li>101 状态码，表示要转换协议啦</li>
<li>Upgrde: 通知客户端将要升级成Websocket协议</li>
<li>Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-05e821d0db32cf8cb5ebf51625870cb1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-05e821d0db32cf8cb5ebf51625870cb1_hd.jpg" alt=""></p>
<p>至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/03/redux中间件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/03/redux中间件/" itemprop="url">redux中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-03T00:11:00+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提到中间件，你可能会想到<code>Express</code>和<code>Koa</code>等服务端框架，没想到也没关系，这句话是我装逼用的。</p>
<p>那么redux中的中间件到底干嘛用的？</p>
<p>有这样一个问题？我们之前用的<code>Redux</code>都是在<code>Action</code>发出之后立即执行<code>Reducer</code>,计算出<code>state</code>,这是同步操作。如果想异步操作呢？即过一段时间再执行<code>Reducer</code>怎么办？这里就需要用到中间件<code>middleware</code>。</p>
<p>先放一张图看看：<br><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dcb142c194bfb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h2 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h2><p><code>redux</code>是有流程的，那么，我们该把这个异步操作放在哪个环节比较合适呢？</p>
<ul>
<li><code>Reducer</code>?纯函数只承担计算<code>State</code>功能，不适合其它功能。</li>
<li><code>View</code>?与<code>State</code>一一对应，可以看做是<code>State</code>的视觉层，也不适合承担其它功能。</li>
<li><code>Action</code>？它是一个对象，即存储动作的载体，只能被操作。</li>
</ul>
<p>其实，也只有<code>dispatch</code>能胜任此重任了。那么怎么在<code>dispatch</code>中添加其它操作呢？</p>
<pre><code>let next = store.dispatch;
store.dispatch = function(action){
   console.log(&apos;老状态 &apos;,store.getState());
   next(action);
   console.log(&apos;新状态 &apos;,store.getState());
}
复制代码
</code></pre><p>示例中可以看出，我们对<code>store.dispatch</code>重新进行了定义，在发送<code>action</code>的前后，做了打印。</p>
<p>这是中间件的大致雏形，真实的中间件要比这么复杂多了</p>
<h2 id="二、中间件的用法"><a href="#二、中间件的用法" class="headerlink" title="二、中间件的用法"></a>二、中间件的用法</h2><p>我们在这里先看看中间件是怎么使用，下面我们一步步剖析每个细节。</p>
<pre><code>import {applyMiddleware,createStore} from &apos;redux&apos;;
import reduxLogger form &apos;redux-logger&apos;;

const store = createStore(reducer,inital_state,applyMiddleware(thunk, promise,reduxLogger));

复制代码
</code></pre><p>代码中有两点需要注意：</p>
<ul>
<li><p>1、<code>createStore</code>方法可以整个应用的初始状态作为参数<br>内部是这么处理的</p>
<p>  let state = inital_state;<br>  复制代码</p>
</li>
<li><p>2、中间件的参数次序有讲究。下面我会把这个问题讲明白。</p>
</li>
</ul>
<h2 id="三、applyMiddleware"><a href="#三、applyMiddleware" class="headerlink" title="三、applyMiddleware"></a>三、applyMiddleware</h2><p>Middleware可以让你包装<code>store</code>的<code>dispatch</code>方法来达到你想要的目的。同时，<code>middleWare</code>还拥有“可组合”这一关键特性。多个<code>middleWare</code>可以被组合到一起使用，形成<code>middleWare</code>链，依次执行。其中每个<code>middleware</code>不需要关心链前后的的<code>middleWare</code>的任何信息。</p>
<pre><code>function applyMiddleware(...middlewares){
    returnfunction(createStore){
        returnfunction(reducer){
            //引入store
            let store = createStore(reducer);
            let dispatch = store.dispatch;
            let middlewareAPI = {
                getState:store.getState,
                // 对dispatch进行包装
                dispatch:action=&gt;dispatch(action)
            }
            //每个中间件都是这种模型  ({ getState, dispatch }) =&gt; next =&gt; action
            chain = middlewares.map(middleware=&gt;middleware(middleAPI));
            dispatch = compose(...chain)(store.dispatch);
            // dispatch被改装后，返回store
            return{...store,dispatch};
        }
    }
}
复制代码
</code></pre><p>上面代码中，所有中间件都被放进了一个数组<code>chain</code>,然后嵌套执行，最后执行<code>store.dispatch</code>。中间件内部<code>middlewaAPI</code>可以拿到<code>getState</code>和<code>dispatch</code>这两个方法。</p>
<p><code>...middleware</code>：遵循<code>Redux middleware API</code>的函数。每个<code>middleware</code>接受<code>Store</code>的<code>dispatch</code>和<code>getState</code>函数作为命名参数，并返回一个函数。该函数会被传入成为<code>next</code>的下一个middleWare 的dispatch方法，并返回一个接收action的新函数，这个函数可以直接调用next(action)，或者在其他需要的时刻调用，甚至根本不去调用它。</p>
<p>所以，接下来，我们就能看到middleware的函数签名是<code>({ getState, dispatch }) =&gt; next =&gt; action</code></p>
<p>其实，它的本质就是包装sotre中的<code>dispatch</code>。</p>
<p>上面代码中，还用到了<code>compose</code>方法，我们来看看compose是怎么是实现的？</p>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>先看下面一个栗子：</p>
<pre><code>function add1(str){
   return str+1;
}
function add2(str){
    return str+2;
 }
 function add3(str){
    return str+3;
 }
 let result = add3(add2(add1(&apos;好吃&apos;)));// 好吃123;

复制代码
</code></pre><p>这中写法调用起来，一层套一层，是不是看着很不爽，我们简化一下：</p>
<pre><code>function compose(...fns){
    if(fns.length==1)
     return fns[0];
   returnfunction(...args){
    let last = fns.pop();
    return fns.reduceRight((prev,next)=&gt;{
         return  next(prev);  
    },last(...args));
   }
 }
 let add = compose(add3,add2,add1);//
 let result = add(&apos;好吃&apos;);// 好吃123
 // 上面的代码其实就是redux3.6.0版本中compose的实现方式
复制代码
</code></pre><p>看看这个代码是不是用起来，很干练一些。其实还可以简化</p>
<pre><code>function compose(...fns){
  if(fns.length==1)
     return fns[0];
   return fns.reduce((a,b)=&gt;(...args)=&gt;a(b(...args)));//add3(add2(add1(&apos;好吃&apos;)))
 }
 let add = compose(add3,add2,add1);//
 let result = add(&apos;好吃&apos;);// 好吃123
 // 这是redux3.6.0版本之后的compose实现方式，一直沿用至今。
复制代码
</code></pre><p>至于为什么<code>applyMiddleWare</code>的参数有顺序，这里给出了答案。</p>
<h2 id="四、Applymiddleware的三个常用参数"><a href="#四、Applymiddleware的三个常用参数" class="headerlink" title="四、Applymiddleware的三个常用参数"></a>四、Applymiddleware的三个常用参数</h2><h3 id="4-1、日志记录"><a href="#4-1、日志记录" class="headerlink" title="4.1、日志记录"></a>4.1、日志记录</h3><p>使用 Redux 的一个益处就是它让 state 的变化过程变的可预知和透明。每当一个 action 发起完成后，新的 state 就会被计算并保存下来。State 不能被自身修改，只能由特定的 action 引起变化。</p>
<p>试想一下，当我们的应用中每一个 action 被发起以及每次新的 state 被计算完成时都将它们记录下来，岂不是很好？当程序出现问题时，我们可以通过查阅日志找出是哪个 action 导致了 state 不正确。<br><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dd052d2e07b77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>图片的效果是不是很期待啊！！！</p>
<p>我们先来手动实现一版。</p>
<pre><code>// 记录所有被发起的action和新的statelet next = store.dispatch;
store.dispatch = function(action){
   console.log(&apos;老状态 &apos;,store.getState());
   next(action);
   console.log(&apos;新状态 &apos;,store.getState());
}
复制代码
</code></pre><p>还是上面的示例，我们来做个修改</p>
<pre><code>let logger = function({ getState, dispatch }){
   returnfunction(next){// 这里的next可以理解为store.dispath,本质上就是调用 middleware 链中下一个 middleware 的 dispatch。returnfunction(action){
        console.log(&apos;老状态1 &apos;,getState());
        next(action);//派发动作console.log(&apos;新状态1 &apos;,getState());
    }
    }
}
// 高逼格写法let logger = ({ getState, dispatch }) =&gt; next =&gt; action =&gt; {
  console.log(&apos;老状态1 &apos;,getState());
  next(action)
  console.log(&apos;新状态1 &apos;,getState());
}
复制代码
</code></pre><h3 id="4-2、redux-thunk-中间件"><a href="#4-2、redux-thunk-中间件" class="headerlink" title="4.2、redux-thunk 中间件"></a>4.2、redux-thunk 中间件</h3><p><code>redux-thunk</code> 是<code>redux</code>官方文档中用到的异步组件，实质就是一个<code>redux</code>中间件，一个封装表达式的函数，封装的目的就是延迟执行表达式。</p>
<p><code>redux-thunk</code>是一个通用的解决方案，其核心思想是让<code>action</code>可以变成一个<code>thunk</code>，这样的话，同步情况：<code>dispatch(action)</code>,异步情况：<code>dispatch(thunk)</code>。</p>
<p>下面是<code>redux-thunk</code>的实现：</p>
<pre><code>let thunk = ({dispatch,getState})=&gt;next=&gt;action=&gt;{
    if(typeof action == &apos;function&apos;){
        action(dispatch,getState);
    }else{
        next(action);//这里可以理解为dispatch(action),本质上就是调用 middleware 链中下一个 middleware 的 dispatch。
    }
}
复制代码
</code></pre><p>使用redux-thunk</p>
<pre><code>const store = createStore(  
  reducer,
  applyMiddleware(thunk)
);
复制代码
</code></pre><p>然后我们实现一个thunkActionCreator</p>
<pre><code>    //过一秒加1
    exportfunction thunkActionCreator(payload){
        returnfunction(dispatch,getState){
            setTimeout(function(){
                dispatch({type:types.INCREMENT,payload:payload});
            },1000);
        }
    },
复制代码
</code></pre><p>最后，在组件中dispatch thunk</p>
<pre><code>this.dispatch(thunkActionCreator(payload));
复制代码
</code></pre><h3 id="4-3、redux-promise"><a href="#4-3、redux-promise" class="headerlink" title="4.3、redux-promise"></a>4.3、redux-promise</h3><p><code>redux-promise</code>也是延迟执行的表达式，它是解决异步的另外一种方案。</p>
<p><code>redux-thunk</code>和核心思想是把<code>action</code>变成<code>thunk</code>，而<code>redux-promise</code>的核心思想是让<code>action</code>返回一个promise对象。</p>
<p>这个中间件使得<code>store.dispatch</code>方法可以接收Promise对象作为参数。这时 ，action 有两种写法:</p>
<p>写法一、返回值是一个Promise对象。</p>
<pre><code>functionpromiseIncrement(payload){
 //  return {type:types.INCREMENT,payload:payload}  以前是这种写法returnnewPromise(function(resolve,reject){
      setTimeout(function(){
        resolve({type:types.INCREMENT,payload:payload});
      },1000);
    });
 },
复制代码
</code></pre><p>写法二，action 对象的payload属性是一个Promise对象，这需要从</p>
<pre><code>functionpayloadIncrement(){
    return {
        type:types.INCREMENT,
        payload: newPromise(function(resolve,reject){
            setTimeout(function(){
                if(Math.random()&gt;.5){
                    resolve(100);
                }else{
                    reject(-100);
                }
            },1000)
        })
    }
}
复制代码
</code></pre><p>下面我们来看看 <code>redux-promise</code>是怎么实现的，就会明白它内部是怎么操作的.</p>
<pre><code>let promise = ({dispatch,getState})=&gt;next=&gt;action=&gt;{
    if(action.then &amp;&amp; typeof action.then == &apos;function&apos;){
        action.then(dispatch);
        // 这里的dispatch就是一个函数，dispatch(action){state:reducer(state,action)};
    }elseif(action.payload&amp;&amp; action.payload.then&amp;&amp; typeof action.payload.then == &apos;function&apos;){
        action.payload.then(payload=&gt;dispatch({...action,payload}),payload=&gt;dispatch({...action,payload}));
    }else{
        next(action);
    }
}
复制代码
</code></pre><p>上面的代码可以看出，如果Action本身就是一个Promise，它resolve以后的值应该是一个Action对象，会被dispatch方法送出action.then(dispatch)；如果<code>Action</code>对象的 <code>payload</code>属性是一个<code>Promise</code>对象，那么无论<code>resolve</code>和<code>reject</code>,dispatch 方法都会发出<code>Action</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/强大的margin负边距/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/01/强大的margin负边距/" itemprop="url">强大的margin负边距</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T11:17:55+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>css中的负边距(negative margin)是布局中的一个常用技巧，只要运用得合理常常会有意想不到的效果。很多特殊的css布局方法都依赖于负边距，所以掌握它的用法对于前端的同学来说，那是必须的。本文非常基础，老鸟可以略过。</p>
<p>左和右的负边距对元素宽度的影响</p>
<p>负边距不仅能影响元素在文档流中的位置，还能增加元素的宽度！</p>
<p>这个作用能实现的前提是：该元素没有设定width属性（当然width:auto是可以的）。</p>
<p>比如下图的黑灰色部分是一个块状元素，它没有设定宽度。它被包裹在一个宽度为400px,且水平居中的父元素中。</p>
<p><img src="https://pic3.zhimg.com/v2-d7053213fb80015b97e243fae474124a_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-d7053213fb80015b97e243fae474124a_hd.jpg" alt=""></p>
<p>现在给这个元素的设一个margin-right:-100px;</p>
<p><img src="https://pic3.zhimg.com/v2-a3037b974494cdbe0c92d4c90af69f80_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-a3037b974494cdbe0c92d4c90af69f80_hd.jpg" alt=""></p>
<p>我们看到它的宽度的确变长100px;然后再给它设一个margin-left:-100px;</p>
<p><img src="https://pic1.zhimg.com/v2-444d4e67d5804bfcbcd4991948889bdb_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-444d4e67d5804bfcbcd4991948889bdb_hd.jpg" alt=""></p>
<p>我们看到它变得更宽了。</p>
<p>负的margin会改变元素的宽度，这的确很让人费解，如果说负边距会改变元素在文档流中的位置还是很好理解的话，那改变宽度这种现象还真的蛮让人不可思议的。</p>
<p>那这货有什么用途呢？我就举一个例子吧。<br><img src="https://pic2.zhimg.com/v2-ee54fb10005457120458e7823fc83d29_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-ee54fb10005457120458e7823fc83d29_hd.jpg" alt=""></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh&quot;&gt;



    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
        &lt;title&gt;浮动两端对齐&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            ul,
            li {
                margin: 0;
                padding: 0;
            }

            h2 {
                clear: both;
                font-size: 1.2em;
            }

            .justify {
                width: 320px;
                /* 1行3个li，li之间距离10px = 100px*3 + 10px*2 */
                overflow: hidden;
                margin: 10px;
                border: 1px solid #999999;
            }

            .justify ul {
                width: 330px;
                /* 可容纳下3列的宽度 */
                margin-bottom: -10px;
                /* 隐藏掉最下面一行的margin-bottom */
                overflow: hidden;
                zoom: 1;
                /* 触发IE的Layout */
            }

            *+html .justify ul {
                margin-bottom: 0;
                /* 针对IE7中最后1行li的margin-bottom失效 */
            }

            .justify li {
                display: inline;
                float: left;
                list-style: none;
                width: 100px;
                height: 100px;
                margin: 0 10px 10px 0;
                background: #EEEEEE;
            }

            .margin ul {
                width: auto;
                margin: 0 -10px -10px 0;
            }

            .col-2 {
                width: 210px;
            }

            .col-4 {
                width: 430px;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div&gt;
            &lt;a href=&quot;http://www.ddcat.net/blog/?p=1199&quot; title=&quot;回到猫窝Blog&quot;&gt;回到猫窝Blog&lt;/a&gt;
        &lt;/div&gt;
        &lt;h1&gt;浮动两端对齐&lt;/h1&gt;
        &lt;h2&gt;ul定宽&lt;/h2&gt;
        &lt;div class=&quot;justify&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;h2&gt;ul使用负margin值&lt;/h2&gt;
        &lt;div class=&quot;justify margin&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;h2&gt;两列&lt;/h2&gt;
        &lt;div class=&quot;justify margin col-2&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;h2&gt;四列&lt;/h2&gt;
        &lt;div class=&quot;justify margin col-4&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;1&lt;/li&gt;
                &lt;li&gt;2&lt;/li&gt;
                &lt;li&gt;3&lt;/li&gt;
                &lt;li&gt;4&lt;/li&gt;
                &lt;li&gt;5&lt;/li&gt;
                &lt;li&gt;6&lt;/li&gt;
                &lt;li&gt;7&lt;/li&gt;
                &lt;li&gt;8&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;a href=&quot;http://www.ddcat.net/blog/?p=1199&quot; title=&quot;回到猫窝Blog&quot;&gt;回到猫窝Blog&lt;/a&gt;
        &lt;/div&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-5c529ec117f663aaacc2030c14423321_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5c529ec117f663aaacc2030c14423321_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-3255d3a67bca63a51e1407f982e2432b_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-3255d3a67bca63a51e1407f982e2432b_hd.jpg" alt=""><br>一个负的margin-right,相当于把ul的宽度增加了10px.</p>
<p>负边距对浮动元素的影响</p>
<p>负边距对浮动元素的影响与负边距对文档流中元素的影响其实是差不多的。文档流中元素的位置由文档流的走向决定，浮动的元素也可以看成有一个“浮动流”存在，不过浮动流既可以向左，也可以向右。</p>
<p>比如下图是三个向左浮动的元素，宽高都是100px：</p>
<p><img src="https://pic2.zhimg.com/v2-1de5e1221b518a74b0606c221cd421f1_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-1de5e1221b518a74b0606c221cd421f1_hd.jpg" alt=""></p>
<p>现在把它们都设一个margin-right:-50px; 然后会变成这样子：</p>
<p><img src="https://pic4.zhimg.com/v2-b0b46b0eff5e6f19a4addafe0d670e85_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-b0b46b0eff5e6f19a4addafe0d670e85_hd.jpg" alt=""></p>
<p>我们看到后面的元素叠到了前面的元素上。</p>
<p>再看下面的图：</p>
<p><img src="https://pic3.zhimg.com/v2-21b3ac21b68d64bdb604b825d00343ce_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-21b3ac21b68d64bdb604b825d00343ce_hd.jpg" alt=""></p>
<p>我们把浏览器缩小了，然后因为宽度不够，元素3掉下来了。我们给元素3设一个margin-left:-80px;看看会怎么样</p>
<p><img src="https://pic1.zhimg.com/v2-ee169d733bb4ce86b2c42de5ebf61bb7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-ee169d733bb4ce86b2c42de5ebf61bb7_hd.jpg" alt=""></p>
<p>这时我们看到元素3上去了，而且还覆盖了元素2的一部分。继续元素3设为margin-left:-100px</p>
<p><img src="https://pic4.zhimg.com/v2-73ff48691bcf79125064218d71d6134f_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-73ff48691bcf79125064218d71d6134f_hd.jpg" alt=""></p>
<p>这时元素3完全覆盖住了元素2,当元素3设为：margin-left:-200px时：</p>
<p><img src="https://pic4.zhimg.com/v2-fcc5dd42f3e8df550341c5af6a00fcfb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-fcc5dd42f3e8df550341c5af6a00fcfb_hd.jpg" alt=""></p>
<p>我们看到元素3继续向左移动并覆盖住了元素1。</p>
<p>现在想必大家都明白了负边距对浮动元素位置的影响了吧。所以那些说得很好听的什么圣杯布局、双飞翼布局啊什么的，都是利用这个原理实现的。就是某个元素虽然是写在了后面，但可以通过负边距让它在浏览器显示的时候是在前面的。这个以后可以再慢慢讲。</p>
<p>负边距对绝对定位元素的影响</p>
<p>绝对定位的元素定义的top、right、bottom、left等值是元素自身的边界到最近的已定位的祖先元素的距离，这个元素自身的边界指的就是margin定义的边界，所以，如果margin为正的时候，那它的边界是向外扩的，如果margin为负的时候，则它的边界是向里收的。利用这点，就有了经典的利用绝对定位来居中的方法：</p>
<p><img src="https://pic4.zhimg.com/v2-dffb7a1006cc4f494125e196595e79db_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-dffb7a1006cc4f494125e196595e79db_hd.jpg" alt=""></p>
<p>看下效果：</p>
<p><img src="https://pic3.zhimg.com/v2-61da203d81eb5f79ac55ca7811a35ff2_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-61da203d81eb5f79ac55ca7811a35ff2_hd.jpg" alt=""></p>
<p>但该方法的缺点是必须要知道要居中元素的高度和宽度。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/31/为什么Redux-需要-reducers是纯函数？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/31/为什么Redux-需要-reducers是纯函数？/" itemprop="url">为什么Redux 需要 reducers是纯函数？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-31T00:13:40+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="为什么Redux-需要-reducers是纯函数？"><a href="#为什么Redux-需要-reducers是纯函数？" class="headerlink" title="为什么Redux 需要 reducers是纯函数？"></a>为什么Redux 需要 reducers是纯函数？</h4><p> 这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个state和action作为参数，然后返回一个新的state，这个新的state不能是在原来state基础上的修改。所以经常可以看到以下的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return Object.assign(...)</span><br><span class="line">//或者----------</span><br><span class="line">return &#123;...state,xx:xxx&#125;</span><br></pre></td></tr></table></figure></p>
<p>其作用，都是为了返回一个全新的对象。</p>
<p><strong>为什么reducers要求是纯函数(返回全新的对象，不影响原对象)?</strong>  –某面试官</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。<br>举个例子，下面的add函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add = (a,b) =&gt; &#123;a + b&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数<br>为什么必须是纯函数?<br>先告诉你结果吧，如果在reducer中，在原来的state上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！<br>接下来看下Redux的源码：<br><img src="https://user-gold-cdn.xitu.io/2018/8/22/165609de895ae1ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。<br>Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。<br>好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的state是全新的对象。那么为什么非要这么麻烦开发者呢？<br>请看下面的例子：尝试比较a和b是否相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;],</span><br><span class="line">    years: 12,</span><br><span class="line">    ...//省略n项目</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var b = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;],</span><br><span class="line">    years: 13,</span><br><span class="line">    ...//省略n项目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？<br>有！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//接上面的例子</span><br><span class="line">a === b  //false</span><br></pre></td></tr></table></figure></p>
<p> 我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是redux的reducer如此设计的原因了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/29/从Vue-js源码看nextTick机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/29/从Vue-js源码看nextTick机制/" itemprop="url">从Vue.js源码看nextTick机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-29T22:30:13+08:00">
                2018-07-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://link.zhihu.com/?target=https%3A//chuckliu.me/%23%21/posts/58bd08a2b5187d2fb51c04f9" target="_blank" rel="noopener">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></p>
<h2 id="可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。"><a href="#可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。" class="headerlink" title="可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。"></a>可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。</h2><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>在使用vue.js的时候，有时候因为一些特定的业务场景，不得不去操作DOM，比如这样：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: &apos;begin&apos;
        };
    },
    methods () {
        handleClick () {
            this.test = &apos;end&apos;;
            console.log(this.$refs.test.innerText);//打印“begin”
        }
    }
}
</code></pre><p>打印的结果是begin，为什么我们明明已经将test设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“begin”呢？</p>
<h2 id="Watcher队列"><a href="#Watcher队列" class="headerlink" title="Watcher队列"></a>Watcher队列</h2><p>带着疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。</p>
<pre><code>update () {
    /* istanbul ignore else */
    if (this.lazy) {
        this.dirty = true
    } else if (this.sync) {
        /*同步则执行run直接渲染视图*/
        this.run()
    } else {
        /*异步推送到观察者队列中，下一个tick时调用。*/
        queueWatcher(this)
    }
}
</code></pre><p>我们发现Vue.js默认是使用<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fguide%252Freactivity.html%2523%25E5%25BC%2582%25E6%25AD%25A5%25E6%259B%25B4%25E6%2596%25B0%25E9%2598%259F%25E5%2588%2597" target="_blank" rel="noopener">异步执行DOM更新</a>。<br>当异步执行update的时候，会调用queueWatcher函数。</p>
<pre><code>/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/
export function queueWatcher (watcher: Watcher) {
  /*获取watcher的id*/
  const id = watcher.id
  /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      /*如果没有flush掉，直接push到队列中即可*/
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i &gt;= 0 &amp;&amp; queue[i].id &gt; watcher.id) {
        i--
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
</code></pre><p>查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</p>
<p>那么，什么是下一个tick？</p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>vue.js提供了一个<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fapi%252F%2523Vue-nextTick" target="_blank" rel="noopener">nextTick</a>函数，其实也就是上面调用的nextTick。</p>
<p>nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion，看一下源码：</p>
<pre><code>/**
 * Defer a task to execute it asynchronously.
 */
 /*
    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function
    这个函数的作用是在task或者microtask中推入一个timerFunc，
    在当前调用栈执行完以后以此执行直到执行到timerFunc
    目的是延迟到当前调用栈执行完以后执行
*/
export const nextTick = (function () {
  /*存放异步执行的回调*/
  const callbacks = []
  /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/
  let pending = false
  /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/
  let timerFunc

  /*下一个tick时的回调*/
  function nextTickHandler () {
    /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/
    pending = false
    /*执行所有callback*/
    const copies = callbacks.slice(0)
    callbacks.length = 0
    for (let i = 0; i &lt; copies.length; i++) {
      copies[i]()
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */

  /*
    这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法
    优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。
    如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
    参考：https://www.zhihu.com/question/55364497
  */
  if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) {
    /*使用Promise*/
    var p = Promise.resolve()
    var logError = err =&gt; { console.error(err) }
    timerFunc = () =&gt; {
      p.then(nextTickHandler).catch(logError)
      // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn&apos;t being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.
      if (isIOS) setTimeout(noop)
    }
  } else if (typeof MutationObserver !== &apos;undefined&apos; &amp;&amp; (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === &apos;[object MutationObserverConstructor]&apos;
  )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/
    var counter = 1
    var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, {
      characterData: true
    })
    timerFunc = () =&gt; {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
    }
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    /*使用setTimeout将回调推入任务队列尾部*/
    timerFunc = () =&gt; {
      setTimeout(nextTickHandler, 0)
    }
  }

  /*
    推送到队列中下一个tick时执行
    cb 回调函数
    ctx 上下文
  */
  return function queueNextTick (cb?: Function, ctx?: Object) {
    let _resolve
    /*cb存到callbacks中*/
    callbacks.push(() =&gt; {
      if (cb) {
        try {
          cb.call(ctx)
        } catch (e) {
          handleError(e, ctx, &apos;nextTick&apos;)
        }
      } else if (_resolve) {
        _resolve(ctx)
      }
    })
    if (!pending) {
      pending = true
      timerFunc()
    }
    if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) {
      return new Promise((resolve, reject) =&gt; {
        _resolve = resolve
      })
    }
  }
})()
</code></pre><p>它是一个立即执行函数,返回一个queueNextTick接口。</p>
<p>传入的cb会被push进callbacks中存放起来，然后执行timerFunc（pending是一个状态标记，保证timerFunc在下一个tick之前只执行一次）。</p>
<p>timerFunc是什么？</p>
<p>看了源码发现timerFunc会检测当前环境而不同实现，其实就是按照Promise，MutationObserver，setTimeout优先级，哪个存在使用哪个，最不济的环境下使用setTimeout。</p>
<p>两者的具体实现</p>
<ul>
<li>macrotasks: setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染</li>
<li>microtasks: Promise， process.nextTick， Object.observe， MutationObserver</li>
</ul>
<p>再简单点可以总结为：<br><img src="https://pic1.zhimg.com/v2-e92a4f5f686d115832b63b9b9e3ac2cd_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-e92a4f5f686d115832b63b9b9e3ac2cd_hd.jpg" alt=""></p>
<ol>
<li>在 macrotask 队列中执行最早的那个 task ，然后移出</li>
<li>再执行 microtask 队列中所有可用的任务，然后移出</li>
<li><p>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</p>
<p>  这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。</p>
<pre><code>优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。
如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
</code></pre></li>
</ol>
<p>为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到：</p>
<blockquote>
<p>  JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。<br>setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、   MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。<br>       要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。<br>       实在不行，只能用 setTimeout 创建 task 了。<br>       为啥要用 microtask？<br>       根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。<br>       反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</p>
</blockquote>
<p>首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调，</p>
<p>MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。</p>
<p>至于 MutationObserver 如何模拟 nextTick 这点，直接看源码，其实就是创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容：    var counter = 1</p>
<pre><code>var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, {
      characterData: true
    })
    timerFunc = () =&gt; {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
    }
</code></pre><p>   setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行：</p>
<pre><code>setTimeout(function(){
    console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;);
},0);
</code></pre><p>它会将回调函数加入task中，等到执行。<br><img src="https://pic2.zhimg.com/v2-59cf9f88d7daac690d39edfb9fffc8b8_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-59cf9f88d7daac690d39edfb9fffc8b8_hd.jpg" alt=""></p>
<pre><code>setTimeout(function(){console.log(4)},0);
new Promise(function(resolve){
    console.log(1)
    for( var i=0 ; i&lt;10000 ; i++ ){
        i==9999 &amp;&amp; resolve()
    }
    console.log(2)
}).then(function(){
    console.log(5)
});
console.log(3);
结果是：
1,2,3,5,4
</code></pre><p>再看这个，两个自执行同时执行：</p>
<pre><code>&lt;script&gt;
(function test() {
  setTimeout(function () {
    console.log(4)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(1);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(2);
  }).then(function() {
    console.log(5);
  });
  console.log(3);
})()

(function test2() {
  setTimeout(function () {
    console.log(42)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(12);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(22);
  }).then(function() {
    console.log(52);
  });
  console.log(32);
})()
&lt;/script&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-cd18c572eb05069895ede7e34388bb8d_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-cd18c572eb05069895ede7e34388bb8d_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-afcb6fa6fb862818359f757107b769ab_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-afcb6fa6fb862818359f757107b769ab_hd.jpg" alt=""><br>整个执行过程是一个 main thread 【<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/link%3Furl%3DCV-egCVH8yK1w-ilUqGsztryG8s2mbuhAliIC_L1n_-BSZ_KJ16tAfaNkmbcRtU8" target="_blank" rel="noopener">主线程</a>】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的 <code>setTimeout</code> 进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。</p>
<pre><code>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：
</code></pre><p>   1.先执行 macrotasks：I/O -》 UI渲染</p>
<p>   2.再执行 microtasks ：process.nextTick  -》 Promise  -》MutationObserver -&gt;Object.observe</p>
<p>   3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：</p>
<p>setTimeout ，setInterval –》setImmediate</p>
<pre><code>  综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。

setImmediate(function(){
    console.log(1);
},0);
setTimeout(function(){
    console.log(2);
},0);
new Promise(function(resolve){
    console.log(3);
    resolve();
    console.log(4);
}).then(function(){
    console.log(5);
});
console.log(6);
process.nextTick(function(){
    console.log(7);
});
console.log(8);
结果是：3 4 6 8 7 5 2 1
</code></pre><h2 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h2><pre><code>/*Github:https://github.com/answershuto*/
/**
 * Flush both queues and run the watchers.
 */
 /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component&apos;s user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component&apos;s watcher run,
  //    its watchers can be skipped.
  /*
    给queue排序，这样做可以保证：
    1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。
    2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建
    3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。
  */
  queue.sort((a, b) =&gt; a.id - b.id)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/
  for (index = 0; index &lt; queue.length; index++) {
    watcher = queue[index]
    id = watcher.id
    /*将has的标记删除*/
    has[id] = null
    /*执行watcher*/
    watcher.run()
    // in dev build, check and stop circular updates.
    /*
      在测试环境中，检测watch是否在死循环中
      比如这样一种情况
      watch: {
        test () {
          this.test++;
        }
      }
      持续执行了一百次watch代表可能存在死循环
    */
    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] &gt; MAX_UPDATE_COUNT) {
        warn(
          &apos;You may have an infinite update loop &apos; + (
            watcher.user
              ? `in watcher with expression &quot;${watcher.expression}&quot;`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  /**/
  /*得到队列的拷贝*/
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  /*重置调度者的状态*/
  resetSchedulerState()

  // call component updated and activated hooks
  /*使子组件状态都改编成active同时调用activated钩子*/
  callActivatedHooks(activatedQueue)
  /*调用updated钩子*/
  callUpdateHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools &amp;&amp; config.devtools) {
    devtools.emit(&apos;flush&apos;)
  }
}
</code></pre><p>flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图</p>
<h2 id="为什么要异步更新视图"><a href="#为什么要异步更新视图" class="headerlink" title="为什么要异步更新视图"></a>为什么要异步更新视图</h2><p>来看一下下面这一段代码</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;{{test}}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: 0
        };
    },
    created () {
      for(let i = 0; i &lt; 1000; i++) {
        this.test++;
      }
    }
}
</code></pre><p>现在有这样的一种情况，created的时候test的值会被++循环执行1000次。<br>每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。<br>如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。<br>所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。<br>保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</p>
<h2 id="访问真实DOM节点更新后的数据"><a href="#访问真实DOM节点更新后的数据" class="headerlink" title="访问真实DOM节点更新后的数据"></a>访问真实DOM节点更新后的数据</h2><p>所以我们需要在修改data中的数据后访问真实的DOM节点更新后的数据，只需要这样，我们把文章第一个例子进行修改。</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: &apos;begin&apos;
        };
    },
    methods () {
        handleClick () {
            this.test = &apos;end&apos;;
            this.$nextTick(() =&gt; {
                console.log(this.$refs.test.innerText);//打印&quot;end&quot;
            });
            console.log(this.$refs.test.innerText);//打印“begin”
        }
    }
}
</code></pre><p>使用Vue.js的global API的$nextTick方法，即可在回调中获取已经更新好的DOM实例了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/26/CSS-defer和async的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/26/CSS-defer和async的区别/" itemprop="url">CSS defer和async的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-26T22:46:19+08:00">
                2018-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
<p>然后从实用角度来说呢，首先把所有脚本都丢到  之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p>
<p>接着，我们来看一张图咯：</p>
<p><img src="https://pic3.zhimg.com/v2-256ddc294b88b9a082b3b2aafe193728_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-256ddc294b88b9a082b3b2aafe193728_hd.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-244a0c3246f534e96ce88124e3978261_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-244a0c3246f534e96ce88124e3978261_hd.jpg" alt=""></p>
<h2 id="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】"><a href="#蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】" class="headerlink" title="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】"></a>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】</h2><p>此图告诉我们以下几个要点：</p>
<ol>
<li>defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>
<li>它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的</li>
<li>关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>
<li>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>
<li>仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


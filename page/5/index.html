<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/强大的margin负边距/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/01/强大的margin负边距/" itemprop="url">强大的margin负边距</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T11:17:55+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>css中的负边距(negative margin)是布局中的一个常用技巧，只要运用得合理常常会有意想不到的效果。很多特殊的css布局方法都依赖于负边距，所以掌握它的用法对于前端的同学来说，那是必须的。本文非常基础，老鸟可以略过。</p>
<p>左和右的负边距对元素宽度的影响</p>
<p>负边距不仅能影响元素在文档流中的位置，还能增加元素的宽度！</p>
<p>这个作用能实现的前提是：该元素没有设定width属性（当然width:auto是可以的）。</p>
<p>比如下图的黑灰色部分是一个块状元素，它没有设定宽度。它被包裹在一个宽度为400px,且水平居中的父元素中。</p>
<p><img src="https://pic3.zhimg.com/v2-d7053213fb80015b97e243fae474124a_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-d7053213fb80015b97e243fae474124a_hd.jpg" alt=""></p>
<p>现在给这个元素的设一个margin-right:-100px;</p>
<p><img src="https://pic3.zhimg.com/v2-a3037b974494cdbe0c92d4c90af69f80_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-a3037b974494cdbe0c92d4c90af69f80_hd.jpg" alt=""></p>
<p>我们看到它的宽度的确变长100px;然后再给它设一个margin-left:-100px;</p>
<p><img src="https://pic1.zhimg.com/v2-444d4e67d5804bfcbcd4991948889bdb_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-444d4e67d5804bfcbcd4991948889bdb_hd.jpg" alt=""></p>
<p>我们看到它变得更宽了。</p>
<p>负的margin会改变元素的宽度，这的确很让人费解，如果说负边距会改变元素在文档流中的位置还是很好理解的话，那改变宽度这种现象还真的蛮让人不可思议的。</p>
<p>那这货有什么用途呢？我就举一个例子吧。<br><img src="https://pic2.zhimg.com/v2-ee54fb10005457120458e7823fc83d29_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-ee54fb10005457120458e7823fc83d29_hd.jpg" alt=""></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;zh&quot;&gt;



    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
        &lt;title&gt;浮动两端对齐&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            ul,
            li {
                margin: 0;
                padding: 0;
            }

            h2 {
                clear: both;
                font-size: 1.2em;
            }

            .justify {
                width: 320px;
                /* 1行3个li，li之间距离10px = 100px*3 + 10px*2 */
                overflow: hidden;
                margin: 10px;
                border: 1px solid #999999;
            }

            .justify ul {
                width: 330px;
                /* 可容纳下3列的宽度 */
                margin-bottom: -10px;
                /* 隐藏掉最下面一行的margin-bottom */
                overflow: hidden;
                zoom: 1;
                /* 触发IE的Layout */
            }

            *+html .justify ul {
                margin-bottom: 0;
                /* 针对IE7中最后1行li的margin-bottom失效 */
            }

            .justify li {
                display: inline;
                float: left;
                list-style: none;
                width: 100px;
                height: 100px;
                margin: 0 10px 10px 0;
                background: #EEEEEE;
            }

            .margin ul {
                width: auto;
                margin: 0 -10px -10px 0;
            }

            .col-2 {
                width: 210px;
            }

            .col-4 {
                width: 430px;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div&gt;
            &lt;a href=&quot;http://www.ddcat.net/blog/?p=1199&quot; title=&quot;回到猫窝Blog&quot;&gt;回到猫窝Blog&lt;/a&gt;
        &lt;/div&gt;
        &lt;h1&gt;浮动两端对齐&lt;/h1&gt;
        &lt;h2&gt;ul定宽&lt;/h2&gt;
        &lt;div class=&quot;justify&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;h2&gt;ul使用负margin值&lt;/h2&gt;
        &lt;div class=&quot;justify margin&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;中间&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;h2&gt;两列&lt;/h2&gt;
        &lt;div class=&quot;justify margin col-2&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
                &lt;li&gt;靠左边&lt;/li&gt;
                &lt;li&gt;靠右边&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;h2&gt;四列&lt;/h2&gt;
        &lt;div class=&quot;justify margin col-4&quot;&gt;
            &lt;ul&gt;
                &lt;li&gt;1&lt;/li&gt;
                &lt;li&gt;2&lt;/li&gt;
                &lt;li&gt;3&lt;/li&gt;
                &lt;li&gt;4&lt;/li&gt;
                &lt;li&gt;5&lt;/li&gt;
                &lt;li&gt;6&lt;/li&gt;
                &lt;li&gt;7&lt;/li&gt;
                &lt;li&gt;8&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;a href=&quot;http://www.ddcat.net/blog/?p=1199&quot; title=&quot;回到猫窝Blog&quot;&gt;回到猫窝Blog&lt;/a&gt;
        &lt;/div&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-5c529ec117f663aaacc2030c14423321_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5c529ec117f663aaacc2030c14423321_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-3255d3a67bca63a51e1407f982e2432b_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-3255d3a67bca63a51e1407f982e2432b_hd.jpg" alt=""><br>一个负的margin-right,相当于把ul的宽度增加了10px.</p>
<p>负边距对浮动元素的影响</p>
<p>负边距对浮动元素的影响与负边距对文档流中元素的影响其实是差不多的。文档流中元素的位置由文档流的走向决定，浮动的元素也可以看成有一个“浮动流”存在，不过浮动流既可以向左，也可以向右。</p>
<p>比如下图是三个向左浮动的元素，宽高都是100px：</p>
<p><img src="https://pic2.zhimg.com/v2-1de5e1221b518a74b0606c221cd421f1_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-1de5e1221b518a74b0606c221cd421f1_hd.jpg" alt=""></p>
<p>现在把它们都设一个margin-right:-50px; 然后会变成这样子：</p>
<p><img src="https://pic4.zhimg.com/v2-b0b46b0eff5e6f19a4addafe0d670e85_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-b0b46b0eff5e6f19a4addafe0d670e85_hd.jpg" alt=""></p>
<p>我们看到后面的元素叠到了前面的元素上。</p>
<p>再看下面的图：</p>
<p><img src="https://pic3.zhimg.com/v2-21b3ac21b68d64bdb604b825d00343ce_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-21b3ac21b68d64bdb604b825d00343ce_hd.jpg" alt=""></p>
<p>我们把浏览器缩小了，然后因为宽度不够，元素3掉下来了。我们给元素3设一个margin-left:-80px;看看会怎么样</p>
<p><img src="https://pic1.zhimg.com/v2-ee169d733bb4ce86b2c42de5ebf61bb7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-ee169d733bb4ce86b2c42de5ebf61bb7_hd.jpg" alt=""></p>
<p>这时我们看到元素3上去了，而且还覆盖了元素2的一部分。继续元素3设为margin-left:-100px</p>
<p><img src="https://pic4.zhimg.com/v2-73ff48691bcf79125064218d71d6134f_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-73ff48691bcf79125064218d71d6134f_hd.jpg" alt=""></p>
<p>这时元素3完全覆盖住了元素2,当元素3设为：margin-left:-200px时：</p>
<p><img src="https://pic4.zhimg.com/v2-fcc5dd42f3e8df550341c5af6a00fcfb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-fcc5dd42f3e8df550341c5af6a00fcfb_hd.jpg" alt=""></p>
<p>我们看到元素3继续向左移动并覆盖住了元素1。</p>
<p>现在想必大家都明白了负边距对浮动元素位置的影响了吧。所以那些说得很好听的什么圣杯布局、双飞翼布局啊什么的，都是利用这个原理实现的。就是某个元素虽然是写在了后面，但可以通过负边距让它在浏览器显示的时候是在前面的。这个以后可以再慢慢讲。</p>
<p>负边距对绝对定位元素的影响</p>
<p>绝对定位的元素定义的top、right、bottom、left等值是元素自身的边界到最近的已定位的祖先元素的距离，这个元素自身的边界指的就是margin定义的边界，所以，如果margin为正的时候，那它的边界是向外扩的，如果margin为负的时候，则它的边界是向里收的。利用这点，就有了经典的利用绝对定位来居中的方法：</p>
<p><img src="https://pic4.zhimg.com/v2-dffb7a1006cc4f494125e196595e79db_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-dffb7a1006cc4f494125e196595e79db_hd.jpg" alt=""></p>
<p>看下效果：</p>
<p><img src="https://pic3.zhimg.com/v2-61da203d81eb5f79ac55ca7811a35ff2_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-61da203d81eb5f79ac55ca7811a35ff2_hd.jpg" alt=""></p>
<p>但该方法的缺点是必须要知道要居中元素的高度和宽度。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/31/为什么Redux-需要-reducers是纯函数？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/31/为什么Redux-需要-reducers是纯函数？/" itemprop="url">为什么Redux 需要 reducers是纯函数？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-31T00:13:40+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="为什么Redux-需要-reducers是纯函数？"><a href="#为什么Redux-需要-reducers是纯函数？" class="headerlink" title="为什么Redux 需要 reducers是纯函数？"></a>为什么Redux 需要 reducers是纯函数？</h4><p> 这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个state和action作为参数，然后返回一个新的state，这个新的state不能是在原来state基础上的修改。所以经常可以看到以下的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return Object.assign(...)</span><br><span class="line">//或者----------</span><br><span class="line">return &#123;...state,xx:xxx&#125;</span><br></pre></td></tr></table></figure></p>
<p>其作用，都是为了返回一个全新的对象。</p>
<p><strong>为什么reducers要求是纯函数(返回全新的对象，不影响原对象)?</strong>  –某面试官</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。<br>举个例子，下面的add函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add = (a,b) =&gt; &#123;a + b&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数<br>为什么必须是纯函数?<br>先告诉你结果吧，如果在reducer中，在原来的state上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！<br>接下来看下Redux的源码：<br><img src="https://user-gold-cdn.xitu.io/2018/8/22/165609de895ae1ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。<br>Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。<br>好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的state是全新的对象。那么为什么非要这么麻烦开发者呢？<br>请看下面的例子：尝试比较a和b是否相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;],</span><br><span class="line">    years: 12,</span><br><span class="line">    ...//省略n项目</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var b = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;],</span><br><span class="line">    years: 13,</span><br><span class="line">    ...//省略n项目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？<br>有！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//接上面的例子</span><br><span class="line">a === b  //false</span><br></pre></td></tr></table></figure></p>
<p> 我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是redux的reducer如此设计的原因了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/30/关于-ES6-中-Promise-的面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/30/关于-ES6-中-Promise-的面试题/" itemprop="url">关于 ES6 中 Promise 的面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T20:16:20+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>最近在复习 Promise 的知识，所以就做了一些题，这里挑出几道题，大家一起看看吧。</p>
<h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><pre><code>const promise = newPromise((resolve, reject) =&gt; {
    console.log(1);
    resolve();
    console.log(2);
})

promise.then(() =&gt; {
    console.log(3);
})

console.log(4);
</code></pre><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>首先 Promise 新建后立即执行，所以会先输出 1，2，而 <code>Promise.then()</code> 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3。</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><pre><code>1243
</code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><pre><code>const promise = newPromise((resolve, reject) =&gt; {
    resolve(&apos;success1&apos;);
    reject(&apos;error&apos;);
    resolve(&apos;success2&apos;);
});

promise.then((res) =&gt; {
    console.log(&apos;then:&apos;, res);
}).catch((err) =&gt; {
    console.log(&apos;catch:&apos;, err);
})
</code></pre><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p><code>resolve 函数</code>将 Promise 对象的状态从<code>“未完成”变为“成功”</code>（即从 <code>pending 变为 resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p>
<p><code>reject 函数</code>将 Promise 对象的状态从<code>“未完成”变为“失败”</code>（即从 <code>pending 变为 rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>而一旦状态改变，就不会再变。<br>所以 代码中的<code>reject(&#39;error&#39;);</code> 不会有作用。</p>
<p>Promise 只能 resolve 一次，剩下的调用都会被忽略。<br>所以 第二次的 <code>resolve(&#39;success2&#39;);</code> 也不会有作用。</p>
<h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><pre><code>then: success1
</code></pre><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p><code>Promise.resolve</code> 方法的参数如果是一个原始值，或者是一个不具有 <code>then</code> 方法的对象，则 <code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为<code>resolved</code>，<code>Promise.resolve</code> 方法的参数，会同时传给回调函数。</p>
<p><code>then</code> 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 <code>then(null)</code>，这就会导致前一个 <code>Promise</code> 的结果会穿透下面。</p>
<h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><pre><code>1
</code></pre><h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promse实现）三个亮灯函数已经存在：</p>
<pre><code>functionred() {
    console.log(&apos;red&apos;);
}
functiongreen() {
    console.log(&apos;green&apos;);
}
functionyellow() {
    console.log(&apos;yellow&apos;);
}
</code></pre><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，意思就是3秒，执行一次 red 函数，2秒执行一次 green 函数，1秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以就利用递归来实现。</p>
<h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><pre><code>functionred() {
    console.log(&apos;red&apos;);
}
functiongreen() {
    console.log(&apos;green&apos;);
}
functionyellow() {
    console.log(&apos;yellow&apos;);
}

var light = function (timmer, cb) {
    returnnewPromise(function (resolve, reject) {
        setTimeout(function () {
            cb();
            resolve();
        }, timmer);
    });
};

var step = function () {
    Promise.resolve().then(function () {
        return light(3000, red);
    }).then(function () {
        return light(2000, green);
    }).then(function () {
        return light(1000, yellow);
    }).then(function () {
        step();
    });
}

step();
</code></pre><p>这个答案，看上去已经很不错了，不过经小伙伴提醒，如果一直这么递归下去，会有栈溢出的问题，对于这个问题，其他小伙伴有什么优化建议的话，可以在评论区展示出来。</p>
<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><p>实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。</p>
<pre><code>const timeout = ms =&gt;newPromise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve();
    }, ms);
});

const ajax1 = () =&gt; timeout(2000).then(() =&gt; {
    console.log(&apos;1&apos;);
    return1;
});

const ajax2 = () =&gt; timeout(1000).then(() =&gt; {
    console.log(&apos;2&apos;);
    return2;
});

const ajax3 = () =&gt; timeout(2000).then(() =&gt; {
    console.log(&apos;3&apos;);
    return3;
});

const mergePromise = ajaxArray =&gt; {
    // 在这里实现你的代码

};

mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; {
    console.log(&apos;done&apos;);
    console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出// 1// 2// 3// done// [1, 2, 3]
</code></pre><h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><p>首先 <code>ajax1 、ajax2、ajax3</code> 都是函数，只是这些函数执行后会返回一个 <code>Promise</code>，按题目的要求我们只要顺序执行这三个函数就好了，然后把结果放到 <code>data</code> 中，但是这些函数里都是异步操作，想要按顺序执行，然后输出 1，2，3并没有那么简单，看个例子。</p>
<pre><code>functionA() {
    setTimeout(function () {
        console.log(&apos;a&apos;);
    }, 3000);
}

functionB() {
    setTimeout(function () {
        console.log(&apos;b&apos;);
    }, 1000);
}

A();
B();

// b// a
</code></pre><p>例子中我们是按顺序执行的 <code>A</code>，<code>B</code> 但是输出的结果却是 <code>b</code>，<code>a</code> 对于这些异步函数来说，并不会按顺序执行完一个，再执行后一个。<br>这道题就是考用 <code>Promise</code> 控制异步流程，我们要想办法，让这些函数，一个执行完之后，再执行下一个，看答案吧。</p>
<h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><pre><code>// 保存数组中的函数执行后的结果var data = [];

// Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。var sequence = Promise.resolve();

ajaxArray.forEach(function (item) {
    // 第一次的 then 方法用来执行数组中的每个函数，// 第二次的 then 方法接受数组中的函数执行后返回的结果，// 并把结果添加到 data 中，然后把 data 返回。
    sequence = sequence.then(item).then(function (res) {
        data.push(res);
        return data;
    });
})

// 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。return sequence;
</code></pre><h3 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h3><p>以下代码最后输出什么？</p>
<pre><code>const first = () =&gt; (newPromise((resolve, reject) =&gt; {
    console.log(3);
    let p = newPromise((resolve, reject) =&gt; {
        console.log(7);
        setTimeout(() =&gt; {
            console.log(5);
            resolve(6);
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) =&gt; {
        console.log(arg);
    });

}));

first().then((arg) =&gt; {
    console.log(arg);
});
console.log(4);
</code></pre><h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><p>这道题就其实和 <code>Promise</code> 的关系不太大，主要是需要理解 JS执行机制，才能很好的解决这道题，对于 JS 执行机制不了解的朋友推荐看看这篇文章</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p>
<h4 id="第一轮事件循环"><a href="#第一轮事件循环" class="headerlink" title="第一轮事件循环"></a>第一轮事件循环</h4><p>先执行宏任务，主script ，new Promise立即执行，输出【3】，</p>
<p>执行 p 这个new Promise 操作，输出【7】，</p>
<p>发现 setTimeout，将回调放入下一轮任务队列（Event Queue），p 的 then，姑且叫做 then1，放入微任务队列，发现 first 的 then，叫 then2，放入微任务队列。执行<code>console.log(4)</code>，输出【4】，宏任务执行结束。</p>
<p>再执行微任务，执行 then1，输出【1】，</p>
<p>执行 then2，输出【2】。</p>
<p>到此为止，第一轮事件循环结束。开始执行第二轮。</p>
<h4 id="第二轮事件循环"><a href="#第二轮事件循环" class="headerlink" title="第二轮事件循环"></a>第二轮事件循环</h4><p>先执行宏任务里面的，也就是 setTimeout 的回调，输出【5】。<br><code>resolve(6)</code> 不会生效，因为 p 这个 Promise 的状态一旦改变就不会在改变了。</p>
<h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><pre><code>374125
</code></pre><h3 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h3><p>有 8 个图片资源的 url，已经存储在数组 <code>urls</code> 中（即<code>urls = [&#39;http://example.com/1.jpg&#39;, ...., &#39;http://example.com/8.jpg&#39;]）</code>，而且已经有一个函数 <code>function loadImg</code>，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。<br>但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。<br>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p>
<pre><code>var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;];
functionloadImg(url) {
    returnnewPromise((resolve, reject) =&gt; {
        const img = new Image()
        img.onload = function () {
            console.log(&apos;一张图片加载完成&apos;);
            resolve();
        }
        img.onerror = reject
        img.src = url
    })
};
</code></pre><h3 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h3><p>题目的意思是需要我们这么做，先并发请求 3 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 3 个，直到需要加载的图片都全部发起请求。</p>
<p>用 Promise 来实现就是，先并发请求3个图片资源，这样可以得到 3 个 Promise，组成一个数组，就叫<code>promises</code> 吧，然后不断的调用 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise%23Promise-race" target="_blank" rel="noopener">Promise.race</a> 来返回最快改变状态的 Promise，然后从数组（<code>promises</code>）中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 url 被取完，最后再使用 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise%23Promise-all" target="_blank" rel="noopener">Promise.all</a> 来处理一遍数组（<code>promises</code>）中没有改变状态的 Promise。</p>
<h3 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h3><pre><code>var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;];
functionloadImg(url) {
    returnnewPromise((resolve, reject) =&gt; {
        const img = new Image()
        img.onload = function () {
            console.log(&apos;一张图片加载完成&apos;);
            resolve();
        }
        img.onerror = reject
        img.src = url
    })
};

functionlimitLoad(urls, handler, limit) {
    // 对数组做一个拷贝const sequence = [].concat(urls)
    let promises = [];

    //并发请求到最大数
    promises = sequence.splice(0, limit).map((url, index) =&gt; {
        // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标return handler(url).then(() =&gt; {
            return index
        }); 
    });

    // 利用数组的 reduce 方法来以队列的形式执行return sequence.reduce((last, url, currentIndex) =&gt; {
        return last.then(() =&gt; {
            // 返回最快改变状态的 PromisereturnPromise.race(promises)
        }).catch(err =&gt; {
            // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误// 更重要的是防止中断整个链式调用console.error(err)
        }).then((res) =&gt; {
            // 用新的 Promise 替换掉最快改变状态的 Promise
            promises[res] = handler(sequence[currentIndex]).then(() =&gt; { return res });
        })
    }, Promise.resolve()).then(() =&gt; {
        returnPromise.all(promises)
    })

}
limitLoad(urls, loadImg, 3)

/*
因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用

limitLoad(urls, loadImg, 3).then(() =&gt; {
    console.log(&apos;所有图片加载完成&apos;);
}).catch(err =&gt; {
    console.error(err);
})
*/
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/26/CSS-defer和async的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/26/CSS-defer和async的区别/" itemprop="url">CSS defer和async的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-26T22:46:19+08:00">
                2018-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=&quot;&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
<p>然后从实用角度来说呢，首先把所有脚本都丢到  之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p>
<p>接着，我们来看一张图咯：</p>
<p><img src="https://pic3.zhimg.com/v2-256ddc294b88b9a082b3b2aafe193728_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-256ddc294b88b9a082b3b2aafe193728_hd.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-244a0c3246f534e96ce88124e3978261_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-244a0c3246f534e96ce88124e3978261_hd.jpg" alt=""></p>
<h2 id="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】"><a href="#蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】" class="headerlink" title="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】"></a>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】</h2><p>此图告诉我们以下几个要点：</p>
<ol>
<li>defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>
<li>它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的</li>
<li>关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>
<li>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>
<li>仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/15/nodejs几种文件路径及path模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/15/nodejs几种文件路径及path模块/" itemprop="url">Node.js几种文件路径及path模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-15T22:24:49+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在写一篇weex的webpack配置，刚刚踩坑了，weekpack中会用到path模块，而对于这个模块，我想抽离出来看一下，因为这个用到的还是比较多的,喜欢的朋友可以点个喜欢，或者去我的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Flaihuamin%252FJS-total" target="_blank" rel="noopener">github</a>点个star也行，谢谢支持，举起小手指点一点哦😯，写的不对的地方，评论拍砖，谢谢。</p>
<h2 id="node中的路径分类"><a href="#node中的路径分类" class="headerlink" title="node中的路径分类"></a>node中的路径分类</h2><p>node中的路径大致分5类，dirname,filename,process.cwd(),./,../,其中前三个都是绝对路径</p>
<p>我们先来看一个简单点的例子</p>
<p>假如，我有一个文件的目录结构如下：</p>
<pre><code>editor/
  - dist/
  - src/
      - task.js
</code></pre><p>然后我们在task.js文件中写入一下代码</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(__dirname);
console.log(__filename);
console.log(process.cwd());
console.log(path.resolve(&apos;./&apos;));
</code></pre><p>在editor目录下运行node src/task.js，我们可以看到结果如下：</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src/task.js
/Users/laihuamin/Documents/richEditor/editor
/Users/laihuamin/Documents/richEditor/editor
</code></pre><p>然后我们有可以在src目录下运行这个文件，node task.js,运行结果如下：</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src/task.js
/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src
</code></pre><p>对比两个输出结果，我们可以归纳一下几点：</p>
<p>1.<strong>dirname:返回的是这个文件所在文件夹的位置<br>2.</strong>filename:你运行命令代表的是文件所在的位置，不管你运行什么命令，都是指向文件<br>3.process.cwd():你运行node命令所在文件夹的位置，比如你在src目录下运行，那么就是输出到src为止，下面的同理。</p>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>讲完前面三个绝对路径，我倒是挺想来聊聊path这个模块的，这个node模块在很多地方都有应用，所以，对于我们来说，掌握他，对我们以后的发展更有利，不用每次看webpack的配置文件还要去查询一下这个api是干什么用的，很影响我们的效率</p>
<p><a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fnodejs.org%252Fapi%252Fpath.html" target="_blank" rel="noopener">nodeJS/path</a></p>
<p>上面那个网站有详细的api，但是我们这里不用都掌握吧，我就讲几个我遇到过的，我觉得webpack等工程配置中会用到的</p>
<h2 id="path-normalize"><a href="#path-normalize" class="headerlink" title="path.normalize"></a>path.normalize</h2><p>这个方法就是把不规范的路径规范化，比如看下面的例子</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;));
</code></pre><p>输出结果：</p>
<pre><code>/foo/bar/baz/asdf
</code></pre><h2 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h2><pre><code>const path = require(&apos;path&apos;);
console.log(path.join(&apos;src&apos;, &apos;task.js&apos;));

const path = require(&apos;path&apos;);
console.log(path.join(&apos;dist&apos;, &apos;task.js&apos;));

const path = require(&apos;path&apos;);
console.log(path.join(&apos;&apos;));
</code></pre><p>这么两个的输出结果是：</p>
<pre><code>src/task.js
dist/task.js
.
</code></pre><p>他的作用也就显而易见，他有一下几条规则：<br>1.传入的参数是字符串的路径片段，可以是一个，也可以是多个</p>
<p>2.返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，Unix系统是”/“，Windows系统是”\“，那么你在两个系统下看到的返回结果就不一样。</p>
<p>3.如果返回的路径字符串长度为零，那么他会返回一个’.’，代表当前的文件夹。</p>
<p>4.如果传入的参数中有不是字符串的，那就直接会报错</p>
<h2 id="path-parse"><a href="#path-parse" class="headerlink" title="path.parse"></a>path.parse</h2><p>我们先来看个例子，在src目录下的task.js写入</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor&apos;));
</code></pre><p>然后运行node src/task.js之后,输出的结果如下：</p>
<pre><code>{ 
  root: &apos;/&apos;,
  dir: &apos;/Users/laihuamin/Documents/richEditor&apos;,
  base: &apos;editor&apos;,
  ext: &apos;&apos;,
  name: &apos;editor&apos; 
}
</code></pre><p>他返回的是一个对象，那么我们来把这么几个名词熟悉一下：</p>
<p><img src="https://pic3.zhimg.com/v2-b7c5d496b89fde98f097a4a6e2ba7d03_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b7c5d496b89fde98f097a4a6e2ba7d03_hd.jpg" alt=""></p>
<p>这个表格应该展示的很形象，但是我们还是来解释一下这些名词：<br>1.root：代表根目录<br>2.dir：代表文件所在的文件夹<br>3.base：代表整一个文件<br>4.name：代表文件名<br>5.ext: 代表文件的后缀名</p>
<p>那我们根据下面的规则，来看一下下面这个例子，最好自己脑子做一遍</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果：</p>
<pre><code>{ 
  root: &apos;/&apos;,
  dir: &apos;/Users/laihuamin/Documents/richEditor/editor/src&apos;,
  base: &apos;task.js&apos;,
  ext: &apos;.js&apos;,
  name: &apos;task&apos; 
}
</code></pre><p>你做对了么？0.0</p>
<h2 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename"></a>path.basename</h2><p>那有了前面这个铺垫，想必这个接口猜也能猜的到了。。。。我们看下面这个例子</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果是：</p>
<pre><code>task.js
</code></pre><p>我们还是简单介绍一下，接收两个参数，一个是path,还有一个是ext（可选参数）.</p>
<pre><code>const path = require(&apos;path&apos;)
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;, &apos;.js&apos;));
</code></pre><p>输出结果:</p>
<pre><code>task
</code></pre><h2 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname"></a>path.dirname</h2><p>这个接口比basename还要简单，我就不多说了，看例子，看结果</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果:</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
</code></pre><p>注意一下，接收的参数是字符串类型</p>
<h2 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname"></a>path.extname</h2><p>这个就是展示文件的扩展名，我们得注意几种情况</p>
<pre><code>const path = require(&apos;path&apos;);
path.extname(&apos;index.html&apos;);
path.extname(&apos;index.coffee.md&apos;);
path.extname(&apos;index.&apos;);
path.extname(&apos;index&apos;);
path.extname(&apos;.index&apos;);
</code></pre><p>输出的结果是：</p>
<pre><code>.html
.md
.
&apos;&apos;
&apos;&apos;
</code></pre><p>自己注意一下这几个情况</p>
<h2 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h2><p>我们通过下面这几个例子先来熟悉一下：</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.resolve(&apos;/foo/bar&apos;, &apos;/bar/faa&apos;, &apos;..&apos;, &apos;a/../c&apos;));
</code></pre><p>输出的结果是</p>
<pre><code>/bar/c
</code></pre><p>他就相当于一堆cd操作，我们一步一步看</p>
<pre><code>cd /foo/bar/    //这是第一步, 现在的位置是/foo/bar/
cd /bar/faa     //这是第二步，这里和第一步有区别，他是从/进入的，也就时候根目录，现在的位置是/bar/faa
cd ..       //第三步，从faa退出来，现在的位置是 /bar
cd a/../c   //第四步，进入a，然后在推出，在进入c，最后位置是/bar/c
</code></pre><p>但是这个操作和cd还是有区别的，这个路径不一定要存在，而且最后的可以是文件</p>
<h2 id="path-relative"><a href="#path-relative" class="headerlink" title="path.relative"></a>path.relative</h2><p>这个返回的是from到to的相对路径，什么意思呢，我们看下面的例子就知道了.</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.relative(&apos;src/bar/baz&apos;, &apos;src/aaa/bbb&apos;));
</code></pre><p>输出的结果是：</p>
<pre><code>../../aaa/bbb
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些比较实用的方法，分享给大家，自己还是老老实实去看weektool的webpack的配置文件了，喜欢的朋友可以点个喜欢，或者去我的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Flaihuamin%252FJS-total" target="_blank" rel="noopener">github</a>点个star也行，谢谢支持，举起小手指点一点哦😯。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/Vue安全权限控制axios拦截/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/Vue安全权限控制axios拦截/" itemprop="url">Vue安全权限控制axios拦截</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T22:57:53+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>何为权限控制</p>
<pre><code>//请求失败后的统一拦截，以及ajax的基本设置
import axios from &apos;axios&apos;;
import qs from &apos;qs&apos;;

function cleanRequest(req) {
  for (const i in req) {
    /* eslint guard-for-in: 0 */
    if (req[i] !== 0 &amp;&amp; !req[i]) {
      delete req[i];
    }
  }
}

axios.defaults.withCredentials = true;
axios.defaults.xsrfCookieName = null;
axios.defaults.headers.common[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos;;
axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;
//系统弹层
import Toast from &apos;mint-ui/lib/toast&apos;;
import &apos;mint-ui/lib/toast/style.css&apos;;

module.exports.install = function (Vue) {
  axios.defaults.baseURL=&quot;/&quot;;
  Vue.prototype.$http = axios;
  Vue.http = axios;

  axios.interceptors.request.use(
    function (request) {
      const params = request.params;
      if (params) {
        cleanRequest(params);
      }
      if (request.data) {
        cleanRequest(request.data);
        request.data=qs.stringify(Object.assign(request.data,Bus.movieConfig))
      }else{
        request.data=qs.stringify(Bus.movieConfig)
      }
      return request;
    },
    function (error) {
      return Promise.reject(error);
    }
  );

  // Add a response interceptor
  axios.interceptors.response.use(
    function (response) {
      return response;
    },
    function (error) {
      Toast(&apos;系统繁忙，请稍后重试!&apos;);
      // Do something with response error
      return Promise.reject(error);
    }
  );
};
</code></pre><p>权限控制大致分为两个维度:</p>
<ul>
<li>垂直维度: 控制用户可以访问哪些url的权限</li>
<li>水平维度: 控制用户访问特定url，获取哪些数据的权限（e.g. 普通用户、管理员、超级管理员访问同一url，获取的数据是不同的）</li>
</ul>
<p>Web权限控制方案List</p>
<ul>
<li>前后端不分离：以Java为例，后端通过jsp、freemark、thmeleaf等模板来渲染相应权限的数据，渲染完呈现在浏览器端</li>
<li>前后端分离：<br>▫SPA单页面应用，路由由前端控制，前端通过js控制hash路由的权限<br>▫SSR服务端渲染，Node中间层做代理路由，判断权限渲染特定的路由至浏览器端</li>
</ul>
<p>SPA前端权限控制方案</p>
<p>SPA: 单页Web应用（single page web application）将所有web活动局限于一个html页面中，利用js通过hash或者浏览器history api来实现无刷新路由跳转，前后端通过ajax数据通信，避免了浏览器的刷新重新加载，为用户提供流程的操作体验。这意味着前端接管了路由层，需要通过调用前端自身的MVC模块，来渲染不同的页面。</p>
<blockquote>
<p>Base on：</p>
</blockquote>
<ul>
<li>Vue 前端MVVM框架</li>
<li>Vuex 状态管理机</li>
<li>Vue-router 路由</li>
<li>Axios HTTP请求库</li>
</ul>
<p>1.登陆事件Login</p>
<pre><code>// 1.触发登陆事件
dispatch(&apos;login&apos;)

// actions
commit(types.LOGIN_SUCCESS, res.data.data)
...
</code></pre><p>2.获取Token，经Base64编码后存至sessionStorage</p>
<pre><code>// mutations
const mutations = {
    [types.LOGIN_SUCCESS] (state, data) {
        state.authlock = false
    // 2.登陆成功回调拿到token,经Base64 编码后存入本地sessionStorage
        let token = Base64.encode(data + &apos;:HIKDATAE&apos;)
        sessionStorage.setItem(&apos;userToken&apos;, token)
    // 路由跳转至目标页面
        router.push({name: &apos;xxx&apos;})
    },
    [types.LOGOUT_SUCCESS] (state) {
        state.authlock = true
    // 登出成功回调,移除本地token
        sessionStorage.removeItem(&apos;userToken&apos;)
        router.push({name: &apos;Login&apos;})
    }
}
</code></pre><p>3.所有HTTP Header Authorization 加上编码后的token(前后端可约定规则)</p>
<pre><code>// Axios 请求钩子（request）
axios.interceptors.request.use(req =&gt; {
    let token = sessionStorage.getItem(&apos;user&apos;)     
    if (token) {         
        // 3.token 存在,则在之后所有请求的http请求头 Authorization 带上base64编码后的token,后台拿到token后进行验证权限         
        req.headers.Authorization = `Basic ${token}`     
    }
    req.data = qs.stringify(req.data)     
    return req 
}, error =&gt; {
    return Promise.reject(error) 
})
</code></pre><p>浏览器http header<br><img src="https://pic4.zhimg.com/v2-48ee52913451d66397f33a47f6af3374_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-48ee52913451d66397f33a47f6af3374_hd.jpg" alt=""></p>
<p>4.请求拦截：后台拿到token后对每个请求进行校验，若校验失败返回401，前端response钩子里统一catch error 跳转至登陆页面。</p>
<pre><code>// Axios 请求钩子（response）
axios.interceptors.response.use(res =&gt; {
    return res
}, error =&gt; {
    if (error.response) {
        switch (error.response.status) {
        // 4.所有接口response校验钩子,若token检验失败,后台返回 401 error code, 清除token信息并跳转到登录页面
            case 401:
                store.commit(types.LOGOUT)
                router.replace({
                    path: &apos;/login&apos;
        })
    }
    }
    return Promise.reject(error)
})
</code></pre><p>5.路由跳转拦截：任意路由跳转时，在路由beforeEach钩子里校验本地是否存在token，若没有，则跳转至登陆页面</p>
<pre><code>// 路由钩子(每个路由跳转前调起beforeEach钩子)
router.beforeEach((to, from, next) =&gt; {
  if (to.path === &apos;/login&apos;) {
    sessionStorage.removeItem(&apos;userToken&apos;)
  }
  let user = sessionStorage.getItem(&apos;userToken&apos;)
  if (!user &amp;&amp; to.path !== &apos;/login&apos;) {
    // 若本地token不存在,则任意路由跳转的时候,重定向至login 登陆页面
    next({ path: &apos;/login&apos; })
  } else {
    next()
  }
})
</code></pre><p>6.登出Logout：清楚本地sessionStorage的token信息</p>
<pre><code>// mutations
const mutations = {
    ...
    [types.LOGOUT_SUCCESS] (state) {
        state.authlock = true
    // 登出成功回调,移除本地token
        sessionStorage.removeItem(&apos;userToken&apos;)
    router.push({name: &apos;Login&apos;})
    }
}
</code></pre><p>流程示意图如下:<br><img src="https://pic2.zhimg.com/v2-064f7b05f15399ac9ff6aa03ee1cb710_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-064f7b05f15399ac9ff6aa03ee1cb710_hd.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/02/ES6-实现自己的-Promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/ES6-实现自己的-Promise/" itemprop="url">ES6实现自己的 Promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T22:15:53+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、JavaScript异步编程背景"><a href="#一、JavaScript异步编程背景" class="headerlink" title="一、JavaScript异步编程背景"></a>一、JavaScript异步编程背景</h2><p>从去年ES2015发布至今，已经过去了一年多，ES2015发布的新的语言特性中最为流行的也就莫过于Promise了，Promise使得如今JavaScript异步编程如此轻松惬意，甚至慢慢遗忘了曾经那不堪回首的痛楚。其实从JavaScript诞生，JavaScript中的异步编程就已经出现，例如点击鼠标、敲击键盘这些事件的处理函数都是异步的，时间到了2009年，Node.js横空出世，在整个Node.js的实现中，将回调模式的异步编程机制发挥的淋漓尽致，Node的流行也是的越来越多的JavaScripter开始了异步编程，但是回调模式的副作用也慢慢展现在人们眼前，错误处理不够优雅以及嵌套回调带来的“回调地狱”。这些副作用使得人们从回调模式的温柔乡中慢慢清醒过来，开始寻找更为优雅的异步编程模式，路漫漫其修远兮、吾将上下而求索。时间到了2015年，Promise拯救那些苦苦探索的先驱。行使它历史使命的时代似乎已经到来。</p>
<p>每个事物的诞生有他的历史使命，更有其历史成因，促进其被那些探索的先驱们所发现。了解nodejs或者熟悉浏览器的人都知道，JavaScript引擎是基于事件循环或单线程这两个特性的。更为甚者在浏览器中，更新UI(也就是浏览器重绘、重拍页面布局)和执行JavaScript代码也在一个单线程中，可想而知，一个线程就相当于只有一条马路，如果一辆马车抛锚在路上了阻塞了马路，那么别的马车也就拥堵在了那儿，这个单线程容易被阻塞是一个道理，单线程也只能允许某一时间点只能够执行一段代码。同时，JavaScript没有想它的哥哥姐姐们那么财大气粗，像Java或者C++，一个线程不够，那么再加一个线程，这样就能够同时执行多段代码了，但是这样就会带来的隐患就是状态不容易维护，JavaScript选择了单线程非阻塞式的方式，也就是异步编程的方式，就像上面的马车抛锚在了路上，那么把马车推到路边的维修站，让其他马车先过去，等马车修好了再回到马路上继续行驶，这就是单线程非阻塞方式。正如Promise的工作方式一样，通过Promise去向服务器发起一个请求，毕竟请求有网络开销，不可能马上就返回请求结果的，这个时候Promise就处于pending状态，但是其并不会阻塞其他代码的执行，当请求返回时，修改Promise状态为fulfilled或者rejected（失败请求）。同时执行绑定到这两个状态上面的“处理函数”。这就是异步编程的模式，也就是Promise兢兢业业的工作方式，在下面一个部分将详细讨论Promise。</p>
<h2 id="二、Promise基础"><a href="#二、Promise基础" class="headerlink" title="二、Promise基础"></a>二、Promise基础</h2><p>怎么一句话解释Promise呢？Promise可以代指那些尚未完成的一些操作，但是其在未来的某个时间会返回某一特定的结果。</p>
<p>当创建一个Promise实例后，其代表一个未知的值，在将来的某个时间会返回一个成功的返回值，或者失败的返回值，我们可以为这些返回值添加处理函数，当值返回时，处理函数被调用。Promise总是处于下面三种状态之一：</p>
<ul>
<li>pending： Promise的初始状态，也就是未被fulfilled或者rejected的状态。</li>
<li>fulfilled： 意味着promise代指的操作已经成功完成。</li>
<li>rejected：意味着promise代指的操作由于某些原因失败。</li>
</ul>
<p>一个处于pending状态的promise可能由于某个成功返回值而发展为fulfilled状态，也有可能因为某些错误而进入rejected状态，无论是进入fulfilled状态或者rejected状态，绑定到这两种状态上面的处理函数就会被执行。并且进入fulfilled或者rejected状态也就不能再返回pending状态了。<br><img src="https://pic4.zhimg.com/v2-cf3e4ae1a35caad7c2d8d7bdd8c763d2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-cf3e4ae1a35caad7c2d8d7bdd8c763d2_hd.jpg" alt=""></p>
<h2 id="三、边学边写"><a href="#三、边学边写" class="headerlink" title="三、边学边写"></a>三、边学边写</h2><p>上面说了那么多，其实都是铺垫。接下来我们就开始实现自己的Promise对象。go go go！！！</p>
<h2 id="第一步：Promise构造函数"><a href="#第一步：Promise构造函数" class="headerlink" title="第一步：Promise构造函数"></a>第一步：Promise构造函数</h2><p>Promise有三种状态，pending、fulfilled、rejected。</p>
<pre><code>const PENDING = &apos;PENDING&apos; // Promise 的 初始状态
const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态
const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态
</code></pre><p>有了三种状态后，那么我们怎么创建一个Promise实例呢？</p>
<blockquote>
<p>const promise = new Promise(executor) // 创建Promise的语法</p>
</blockquote>
<p>通过上面生成promise语法我们知道，Promise实例是调用Promise构造函数通过new操作符生成的。这个构造函数我们可以先这样写：</p>
<pre><code>class Promise {
    constructor(executor) {
        this.status = PENDING // 创建一个promise时，首先进行状态初始化。pending
        this.result = undefined // result属性用来缓存promise的返回结果，可以是成功的返回结果，或失败的返回结果
    }
}
</code></pre><p>我们可以看到上面构造函数接受的参数executor。它是一个函数，并且接受其他两个函数（resolve和reject）作为参数，当resolve函数调用后，promise的状态转化为fulfilled，并且执行成功返回的处理函数（不用着急后面会说到怎么添加处理函数）。当reject函数调用后，promise状态转化为rejected，并且执行失败返回的处理函数。</p>
<p>现在我们的代码大概是这样的：</p>
<pre><code>class Promise {
    constructor(executor) {
        this.status = PENDING 
        this.result = undefined
        executor(data =&gt; resolveProvider(this, data), err =&gt; rejectProvider(this, err))
    }
}

function resolveProvider(promise, data) {
    if (promise.status !== PENDING) return false
    promise.status = FULFILLED
}
function rejectProvider(promise, data) {
    if (promise.status !== PENDING) return false
    promise.status = FULFILLED
}
</code></pre><p>Dont Repeat Yourselt！！！我们可以看到上面代码后面两个函数基本相同，其实我们可以把它整合成一个函数，在结合高阶函数的使用。</p>
<pre><code>const statusProvider = (promise, status) =&gt; data =&gt; {
    if (promise.status !== PENDING) return false
    promise.status = status
    promise.result = data
}
class Promise {
    constructor(executor) {
        this.status = PENDING 
        this.result = undefined
        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
    }
}
</code></pre><p>现在我们的代码就看上去简洁多了。</p>
<h2 id="第二步：为Promise添加处理函数"><a href="#第二步：为Promise添加处理函数" class="headerlink" title="第二步：为Promise添加处理函数"></a>第二步：为Promise添加处理函数</h2><p>其实通过 <code>new Promise(executor)</code>已经可以生成一个Promise实例了，甚至我们可以通过传递到executor中的resolve和reject方法来改变promise状态，但是！现在的promise依然没啥卵用！！！因为我们并没有给它添加成功和失败返回的处理函数。</p>
<p>首先我们需要给我们的promise增加两个属性，successListener和failureListener用来分别缓存成功处理函数和失败处理函数。</p>
<pre><code>class Promise {
    constructor(executor) {
        this.status = PENDING
         this.successListener = []
         this.failureListener = []
        this.result = undefined
        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
    }
}
</code></pre><p>怎么添加处理函数呢？ECMASCRIPT标准中说到，我们可以通过promise原型上面的then方法为promise添加成功处理函数和失败处理函数，可以通过catch方法为promise添加失败处理函数。</p>
<pre><code>const statusProvider = (promise, status) =&gt; data =&gt; {
    if (promise.status !== PENDING) return false
    promise.status = status
    promise.result = data
    switch(status) {
        case FULFILLED: return promise.successListener.forEach(fn =&gt; fn(data))
        case REJECTED: return promise.failurelistener.forEach(fn =&gt; fn(data))
    }
}
class Promise {
    constructor(executor) {
        this.status = PENDING
        this.successListener = []
        this.failurelistener = []
        this.result = undefined
        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
    }
    /**
     * Promise原型上面的方法
     */
    then(...args) {
        switch (this.status) {
            case PENDING: {
                this.successListener.push(args[0])
                this.failurelistener.push(args[1])
                break
            }
            case FULFILLED: {
                args[0](this.result)
                break
            }
            case REJECTED: {
                args[1](this.result)
            }
        }
    }
    catch(arg) {
        return this.then(undefined, arg)
    }
}
</code></pre><p>我们现在的Promise基本初具雏形了。甚至可以运用到一些简单的场景中了。举个例子。</p>
<pre><code>/*创建一个延时resolve的pormise*/
new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; resolve(5), 2000)}).then(data =&gt; console.log(data)) // 5
/*创建一个及时resolve的promise*/
new Promise((resolve, reject) =&gt; resolve(5)).then(data =&gt; console.log(data)) // 5
/*链式调用then方法还不能够使用！*/
new Promise(resolve=&gt; resolve(5)).then(data =&gt; data).then(data =&gt; console.log(data))
// Uncaught TypeError: Cannot read property &apos;then&apos; of undefined
</code></pre><h2 id="第三步：Promise的链式调用"><a href="#第三步：Promise的链式调用" class="headerlink" title="第三步：Promise的链式调用"></a>第三步：Promise的链式调用</h2><p>Promise需要实现链式调用，我们需要再次回顾下then方法的定义：</p>
<blockquote>
<p>then方法为pormise添加成功和失败的处理函数，同时then方法返回一个新的promise对象，这个新的promise对象resolve处理函数的返回值，或者当没有提供处理函数时直接resolve原始的值。</p>
</blockquote>
<p>可以看出，promise能够链式调用归功于then方法返回一个全新的promise，并且resolve处理函数的返回值，当然，如果then方法的处理函数本身就返回一个promise，那么久不用我们自己手动生成一个promise了。了解了这些，就开始动手写代码了。</p>
<pre><code>const isPromise = object =&gt; object &amp;&amp; object.then &amp;&amp; typeof object.then === &apos;function&apos;
const noop = () =&gt; {}

const statusProvider = (promise, status) =&gt; data =&gt; {
    // 同上面代码
}

class Promise {
    constructor(executor) {
        // 同上面代码
    }
    then(...args) {
        const child = new this.constructor(noop)

        const handler = fn =&gt; data =&gt; {
            if (typeof fn === &apos;function&apos;) {
                const result = fn(data)
                if (isPromise(result)) {
                    Object.assign(child, result)
                } else {
                    statusProvider(child, FULFILLED)(result)
                }   
            } else if(!fn) {
                statusProvider(child, this.status)(data)
            }
        }
        switch (this.status) {
            case PENDING: {
                this.successListener.push(handler(args[0]))
                this.failurelistener.push(handler(args[1]))
                break
            }
            case FULFILLED: {
                handler(args[0])(this.result)
                break
            }
            case REJECTED: {
                handler(args[1])(this.result)
                break
            }
        }
        return child
    }
    catch(arg) {
        return this.then(undefined, arg)
    }
}
</code></pre><p>首先我们写了一个isPromise方法，用于判断一个对象是否是promise。就是判断对象是否有一个<code>then</code>方法，免责声明为了实现上的简单，我们不区分thenable和promise的区别，但是我们应该是知道。所有的promise都是thenable的，而并不是所有的thenable对象都是promise。（thenable对象是指带有一个then方法的对象，该then方法其实就是一个executor。）isPromise的作用就是用于判断then方法返回值是否是一个promise，如果是promise，就直接返回该promise，如果不是，就新生成一个promise并返回该promise。</p>
<p>由于需要链式调用，我们对successListener和failureListener中处理函数进行了重写，并不是直接push进去then方法接受的参数函数了，因为then方法需要返回一个promise，所以当then方法里面的处理函数被执行的同时，我们也需要对then方法返回的这个promise进行处理，要么resolve，要么reject掉。当然，大部分情况都是需要resolve掉的，只有当then方法没有添加第二个参数函数，同时调用then方法的promise就是rejected的时候，才需要把then方法返回的pormise进行reject处理，也就是调用<code>statusProvider(child, REJECTED)(data)</code>.</p>
<p>toy Promise实现的完整代码：</p>
<pre><code>const PENDING = &apos;PENDING&apos; // Promise 的 初始状态
const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态
const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态

const isPromise = object =&gt; object &amp;&amp; object.then &amp;&amp; typeof object.then === &apos;function&apos;
const noop = () =&gt; {}

const statusProvider = (promise, status) =&gt; data =&gt; {
    if (promise.status !== PENDING) return false
    promise.status = status
    promise.result = data
    switch(status) {
        case FULFILLED: return promise.successListener.forEach(fn =&gt; fn(data))
        case REJECTED: return promise.failurelistener.forEach(fn =&gt; fn(data))
    }
}

class Promise {
    constructor(executor) {
        this.status = PENDING
        this.successListener = []
        this.failurelistener = []
        this.result = undefined 
        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
    }
    /**
     * Promise原型上面的方法
     */
    then(...args) {
        const child = new this.constructor(noop)

        const handler = fn =&gt; data =&gt; {
            if (typeof fn === &apos;function&apos;) {
                const result = fn(data)
                if (isPromise(result)) {
                    Object.assign(child, result)
                } else {
                    statusProvider(child, FULFILLED)(result)
                }   
            } else if(!fn) {
                statusProvider(child, this.status)(data)
            }
        }
        switch (this.status) {
            case PENDING: {
                this.successListener.push(handler(args[0]))
                this.failurelistener.push(handler(args[1]))
                break
            }
            case FULFILLED: {
                handler(args[0])(this.result)
                break
            }
            case REJECTED: {
                handler(args[1])(this.result)
                break
            }
        }
        return child
    }
    catch(arg) {
        return this.then(undefined, arg)
    }
}
</code></pre><h2 id="四、怎么让我们的toy-Promise变强健"><a href="#四、怎么让我们的toy-Promise变强健" class="headerlink" title="四、怎么让我们的toy Promise变强健"></a>四、怎么让我们的toy Promise变强健</h2><ol>
<li>在ECMAScript标准中，Promise构造函数上面还提供了一些静态方法，比如<code>Promise.resolve</code>、<code>Promise.reject</code>、<code>Promsie.all</code>、<code>Promise.race</code>。当我们有了上面的基础实现后，为我们的toy Promise添加上面这些新的功能一定能让其更加实用。</li>
<li>在我们的基本实现中，我们并没有区分thenable对象，其实<code>Promise.resolve</code>和<code>then</code>方法都可以接受一个thenable对象，并把该thenable对象转化为一个promise对象，如果想让我们的toy Promise用于生产的话，这也是要考虑的。</li>
<li>为了让我们的toy Promise变得更强壮，我们需要拥有强健的错误处理机制，比如验证executor必须是一个函数、then方法的参数只能是函数或者undefined或null，又比如executor和then方法中抛出的错误并不能够被window.onerror监测到，而只能够通过错误处理函数来处理，这也是需要考虑的因素。</li>
<li>如果我们的Promise polyfill是考虑支持多平台，那么首要考虑的就是浏览器环境或Node.js环境，其实在这两个平台，原生Promise都是支持两个事件的。就拿浏览器端举例：</li>
</ol>
<ul>
<li><code>unhandledrejection</code>: 在一个事件循环中，如果我们没有对promise返回的错误进行处理，那么就会在window对象上面触发该事件。</li>
<li><code>rejectionhandled</code>:如果在一个事件循环后，我们才去对promise返回的错误进行处理，那么就会在window对象上面监听到此事件。</li>
</ul>
<p>关于这两个事件以及node.js平台上面类似的事件请参考Nicholas C. Zakas新书</p>
<p>Promise能够很棒的处理异步编程，要想学好它我认为最好的方法就是亲自动手去实现一个自己的Promise。</p>
<p>完整code：</p>
<pre><code>/**
 * 2016.09.19
 */
const PENDING = &apos;PENDING&apos; // Promise 的初始状态
const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态
const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态

const isThenable = data =&gt; data &amp;&amp; data.then &amp;&amp; typeof data.then === &apos;function&apos;
const isPromise = object =&gt; isThenable(object) &amp;&amp; (&apos;catch&apos; in object) &amp;&amp; typeof object.catch === &apos;function&apos;
const noop = () =&gt; {}
const range = n =&gt; n === 0 ? [] : [n, ...range(n - 1)]

// resolve function
const statusProvider = (promise, status) =&gt; data =&gt; {
    if (promise.status !== PENDING) return false
    promise.status = status
    promise.result = data
    promise.listeners[status].forEach(fn =&gt; fn(data))
}

class APromise {
    constructor(executor) {
        if (typeof executor !== &apos;function&apos;) {
            throw new TypeError(`Promise resolver ${executor.toString()} is not a function`)
        }
        this.status = PENDING
        this.listeners = {
            FULFILLED: [],
            REJECTED: []
        }
        this.result = undefined

        try {
            executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))
        } catch (e) {
            statusProvider(this, REJECTED)(e)
        }
    }
    // prototype method
    then(...args) {
        const child = new this.constructor(noop)

        const handler = fn =&gt; data =&gt; {
            if (typeof fn === &apos;function&apos;) {
                try {
                    const result = fn(data)
                    if (isThenable(result)) {
                        isPromise(result) ? Object.assign(child, result) : Object.assign(child, new this.constructor(result.then))
                    } else {
                        statusProvider(child, FULFILLED)(result)
                    }
                } catch (e) {
                    statusProvider(child, REJECTED)(e)
                }
            } else if (!fn) {
                statusProvider(child, this.status)(data)
            }
        }
        switch (this.status) {
            case PENDING: {
                this.listeners[FULFILLED].push(handler(args[0]))
                this.listeners[REJECTED].push(handler(args[1]))
                break
            }
            case FULFILLED: {
                handler(args[0])(this.result)
                break
            }
            case REJECTED: {
                handler(args[1])(this.result)
                break
            }
        }
        return child
    }

    catch(arg) {
        return this.then(undefined, arg)
    }
}

APromise.resolve = data =&gt; {
    if (isPromise(data)) return data
    return isThenable(data) ? new APromise(data.then) : new APromise((resolve, reject) =&gt; resolve(data))
}

APromise.reject = err =&gt; new APromise((resolve, reject) =&gt; reject(err))

APromise.all = promises =&gt; {
    const length = promises.length
    const result = new APromise(noop)
    let count = 0
    const values = range(length)

    promises.forEach((p, i) =&gt; {
        p.then(data =&gt; {
            values[i] = data
            count++
            if (count === length) statusProvider(result, FULFILLED)(values)
        }, statusProvider(result, REJECTED))
    })
    return result
}

APromise.race = promises =&gt; {
    const result = new APromise(noop)
    promises.forEach((p, i) =&gt; {
        p.then(statusProvider(result, FULFILLED), statusProvider(result, REJECTED))
    })
    return result
}

export default APromise
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/24/v-for-循环-index的传值问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/24/v-for-循环-index的传值问题/" itemprop="url">v-for 循环 index的传值问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-24T23:02:54+08:00">
                2018-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;el-submenu :index=&quot;index&quot; v-for=&quot;(item,index) in menuList&quot;&gt;

    &lt;el-menu-item :index=&quot;index&quot; 
       v-for=&quot;(subItem,subindex) in item.subMenuList&quot;&gt;
        {{index}}-{{subItem.subMenuName}}&lt;/el-menu-item&gt;

&lt;/el-submenu&gt;
</code></pre><p>发现子组件获取到的index一直都是undefined。</p>
<p>修改办法：</p>
<pre><code>&lt;el-menu-item :index=&quot;&apos;&apos;+index&quot; 
     v-for=&quot;(subItem,subindex) in item.subMenuList&quot;&gt;
  {{index}}-{{subItem.subMenuName}}
&lt;/el-menu-item&gt;
</code></pre><p>将 :index 的制改为’’+index，一定是单引号’’ ，子组件获取的到的就变成字符串”0,””1”…..</p>
<p>将字符串”0”变成整数   +”0” 即可！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/移动端设置了overflow-hidden和border-radius，子元素超出部分不隐藏问题？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/移动端设置了overflow-hidden和border-radius，子元素超出部分不隐藏问题？/" itemprop="url">移动端设置了overflow:hidden和border-radius，子元素超出部分不隐藏问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T14:41:09+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;
        &lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; href=&quot;css/SB.css&quot; /&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .main {
                width: 300px;
                height: 100px;
                border: 1px solid red;
                border-radius: 15px;
                overflow: hidden;
                /*transform:rotate(0deg); */
            }

            .con {
                display: block;
                overflow: scroll;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
                white-space: nowrap;
                font-size: 0px;
            }

            .item {
                width: 100px;
                height: 100px;
                background: green;
                display: inline-block;
                position: relative;
            }

            .item:nth-child(2n) {
                background: red;
            }
            .item p{
                width: 50px;
                height: 20px;
                color: white;
                text-align: center;
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 0px;
                background: blue;
                font-size: 12px;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div class=&quot;main&quot;&gt;
            &lt;div class=&quot;con&quot;&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;

&lt;/html&gt;
复制代码
</code></pre><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d69655dafdb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d6a28737a214?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>解决办法：</p>
<pre><code>.main {
                width: 300px;
                height: 100px;
                border: 1px solid red;
                border-radius: 15px;
                overflow: hidden;
                transform:rotate(0deg);  /*transform: scale(1);也可以*/
            }
复制代码
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d6b547a6dd86?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/03/JavaScript的事件循环/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/JavaScript的事件循环/" itemprop="url">JavaScript的事件循环</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T11:15:38+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Node-js-事件循环一-浅析"><a href="#Node-js-事件循环一-浅析" class="headerlink" title="Node.js 事件循环一: 浅析"></a>Node.js 事件循环一: 浅析</h2><blockquote>
<p>理解事件循环系列第一步 浅析和总览</p>
</blockquote>
<p>多数的网站不需要大量计算，程序花费的时间主要集中在磁盘 I/O 和网络 I/O 上面</p>
<p>SSD读取很快，但和CPU处理指令的速度比起来也不在一个数量级上，而且网络上一个数据包来回的时间更慢：</p>
<p><img src="https://pic1.zhimg.com/v2-67a42368c7dffa3348730760c9c0b907_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-67a42368c7dffa3348730760c9c0b907_hd.jpg" alt=""></p>
<p>一个数据包来回的延迟平均320ms(我网速慢，ping国内网站会更快)，这段时间内一个普通 cpu 执行几千万个周期应该没问题</p>
<p>因此异步IO就要发挥作用了，比如用多线程，如果用 Java 去读一个文件，这是一个阻塞的操作，在等待数据返回的过程中什么也干不了，因此就开一个新的线程来处理文件读取，读取操作结束后再去通知主线程。</p>
<p>这样虽然行得通，但是代码写起来比较麻烦。像 Node.js V8 这种无法开一个线程的怎么办？</p>
<p>先看下面函数执行过程</p>
<h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>当我们调用一个函数，它的地址、参数、局部变量都会压入到一个 stack 中</p>
<pre><code>function fire() {
    const result = sumSqrt(3, 4)
    console.log(result);
}
function sumSqrt(x, y) {
    const s1 = square(x)
    const s2 = square(y)
    const sum = s1 + s2;
    return Math.sqrt(sum)
}
function square(x) {
    return x * x;
}

fire()
</code></pre><blockquote>
<p>下面的图都是用 keynote 做的 <a href="https://link.zhihu.com/?target=https%3A//github.com/ccforward/cc/blob/master/Blog/pic/event-loop.key" target="_blank" rel="noopener">keynote地址</a></p>
</blockquote>
<p>函数 <code>fire</code> 首先被调用</p>
<p><img src="https://pic3.zhimg.com/v2-a3840ed51ad7ccaedb915e05b087e1e4_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-a3840ed51ad7ccaedb915e05b087e1e4_hd.jpg" alt=""></p>
<p><code>fire</code> 调用 <code>sumSqrt</code> 函数 参数为3和4</p>
<p><img src="https://pic4.zhimg.com/v2-5871549477044a0e7a657f9a16e9367c_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-5871549477044a0e7a657f9a16e9367c_hd.jpg" alt=""></p>
<p>之后调用 <code>square</code> 参数为 x, x==3</p>
<p><img src="https://pic2.zhimg.com/v2-ced7e64c06861509c593cdb0cfbc594e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-ced7e64c06861509c593cdb0cfbc594e_hd.jpg" alt=""></p>
<p>当 <code>square</code> 执行结束返回时，从 stack 中弹出，并将返回值赋值给 s1<br>s1加入到 sumSqrt 的 stack frame 中</p>
<p><img src="https://pic2.zhimg.com/v2-0f214a42ee6c2226c343edb7431116be_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-0f214a42ee6c2226c343edb7431116be_hd.jpg" alt=""></p>
<p>以同样的方式调用下一个 <code>square</code> 函数</p>
<p><img src="https://pic4.zhimg.com/v2-6488db685f7ba396d9bb72b80daf0465_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6488db685f7ba396d9bb72b80daf0465_hd.jpg" alt=""></p>
<p><img src="https://pic1.zhimg.com/v2-4900e4ce2e398d085ceb6f2ea31ad6d9_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-4900e4ce2e398d085ceb6f2ea31ad6d9_hd.jpg" alt=""></p>
<p>在下一行的表达式中计算出 s1+s2 并赋值给 sum</p>
<p><img src="https://pic3.zhimg.com/v2-0045b1427a3fd41aa31cbac4271b6200_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-0045b1427a3fd41aa31cbac4271b6200_hd.jpg" alt=""></p>
<p>之后调用 <code>Math.sqrt</code> 参数为sum</p>
<p><img src="https://pic4.zhimg.com/v2-89dc079ce6308a32fbf78c29b67c4985_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-89dc079ce6308a32fbf78c29b67c4985_hd.jpg" alt=""></p>
<p>现在就剩下 <code>sumSqrt</code> 函数返回计算结果了</p>
<p><img src="https://pic2.zhimg.com/v2-3fe1e6705f665c11f3c350bdd4f643c9_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3fe1e6705f665c11f3c350bdd4f643c9_hd.jpg" alt=""></p>
<p>返回值赋值给 result</p>
<p><img src="https://pic4.zhimg.com/v2-d55914f97f05518c2f31b10909efb4f4_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-d55914f97f05518c2f31b10909efb4f4_hd.jpg" alt=""></p>
<p>在 console 中打印出 result</p>
<p><img src="https://pic3.zhimg.com/v2-99d7b0ece63e888549b258944fe0e1e4_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-99d7b0ece63e888549b258944fe0e1e4_hd.jpg" alt=""></p>
<p>最终 <code>fire</code> 没有任何返回值 从stack中弹出 stack也清空了</p>
<p><img src="https://pic4.zhimg.com/v2-bd4e4983cbba11fe080913f2a1d0ef43_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-bd4e4983cbba11fe080913f2a1d0ef43_hd.jpg" alt=""></p>
<p>当函数执行完毕后本地变量会从 stack 中弹出，这只有在使用 numbers string boolean 这种基本数据类型时才会发生。而对象、数组的值是存在于 heap(堆) 中的，stack 只存放了他们对应的指针。</p>
<p>当函数之行结束从 stack 中弹出来时，只有对象的指针被弹出，而真正的值依然存在 heap 中，然后由垃圾回收器自动的清理回收。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>通过一个例子来了解函数的执行顺序</p>
<pre><code>&apos;use strict&apos;

const express = require(&apos;express&apos;)
const superagent = require(&apos;superagent&apos;)
const app = express()

app.get(&apos;/&apos;, getArticle)

function getArticle(req, res) {
    fetchArticle(req, res)
    print()
}

const aids = [4564824, 4506868, 4767667, 4856099, 7456996];

function fetchArticle(req, res) {
    const aid = aids[Math.floor(Math.random() * aids.length)]
    superagent.get(`http://news-at.zhihu.com/api/4/news/${aid}`)
        .end((err, res) =&gt; {
            if(err) {
                console.log(&apos;error ......&apos;);
                return res.status(500).send(&apos;an error ......&apos;)
            }
            const article = res.body
            res.send(article)
            console.log(&apos;Got an article&apos;)
        })

    console.log(&apos;Now is fetching an article&apos;)
}

function print(){
    console.log(&apos;Print something&apos;)
}


app.listen(&apos;5000&apos;)
</code></pre><p>请求 <code>http://localhost:5000/</code> 后打印出</p>
<pre><code>Now is fetching an article

Print something

Got an article
</code></pre><p>虽然 V8 是单线程的，但底层的 C++ API 却不是。这意味着当我们执行一些非阻塞的操作，Node会调用一些代码，与引擎里的js代码同时执行。一旦这个隐藏的线程收到了等待的返回值或者抛出一个异常，之前提供的回调函数就会执行。</p>
<p>上面的说的Node调用的一些代码其实就是 <a href="https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>，一个开源的跨平台的异步 I/O 。最初就是为 Node.js 开发的，现在<a href="https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv/wiki/Projects-that-use-libuv" target="_blank" rel="noopener">很多项目</a>都在用</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>javascript 是单线程事件驱动的语言，那我们可以给时间添加监听器，当事件触发时，监听器就能执行回调函数。</p>
<p>当我们去调用 <code>setTimeout`</code>http.get<code></code>fs.readFile`, Node.js 会把这些定时器、http、IO操作发送给另一个线程以保证V8继续执行我们的代码。</p>
<p>然而我们只有一个主线程和一个 call-stack ，这样当一个读取文件的操作还在执行时，有一个网络请求request过来，那这时他的回调就需要等stack变空才能执行。</p>
<p>回调函数正在等待轮到自己执行所排的队就被称为任务队列(或者事件队列、消息队列)。每当主线程完成前一个任务，回调函数就会在一个无限循环圈里被调用，因此这个圈被称为事件循环。</p>
<p>我们前面那个获取文章的例子的执行顺序就会如下：</p>
<ol>
<li>express 给 request 事件注册了一个 handler，并且当请求到达路径 ‘/‘ 时来触发handler</li>
<li>调过各个函数并且在端口 5000 上启动监听</li>
<li>stack 为空，等待 <code>request</code> 事件触发</li>
<li>根据传入的请求，事件触发，express 调用之前提供的函数 <code>getArticle</code></li>
<li><code>getArticle</code> 压入(push) stack</li>
<li><code>fetchArticle</code> 被调用 同时压入 stack</li>
<li><code>Math.floor</code> 和 <code>Math.random</code> 被调用压入 stack 然后再 弹出(pop), 从 aids 里面取出的一个值被赋值给变量 aid</li>
<li><code>superagent.get</code> 被执行，参数为 <code>&#39;http://news-at.zhihu.com/api/4/news/${aid}&#39;</code> ,并且回调函数注册给了 <code>end</code> 事件</li>
<li>到 <code>http://news-at.zhihu.com/api/4/news/${aid}</code> 的HTTP请求被发送到后台线程，然后函数继续往下执行</li>
<li><code>&#39;Now is fetching an article&#39;</code> 打印在 console 中。 函数 <code>fetchArticle</code> 返回</li>
<li><code>print</code> 函数被调用, <code>&#39;Print something&#39;</code> 打印在 console 中</li>
<li>函数 <code>getArticle</code> 返回，并从 stack 中弹出， stack 为空</li>
<li>等待 <code>http://news-at.zhihu.com/api/4/news/${aid}</code> 发送相应信息</li>
<li>响应信息到达，<code>end</code> 事件被触发</li>
<li>注册给 <code>end</code> 事件的匿名回调函数被执行，这个匿名函数和他闭包中的所有变量压入 stack，这意味着这个匿名函数可以访问并修改 <code>express</code>, <code>superagent</code>, <code>app</code>, <code>aids</code>, <code>req</code>, <code>res</code>, <code>aid</code> 的值以及之前所有已经定义的函数</li>
<li>函数 <code>res.send()</code> 伴随着 200 或 500 的状态码被执行，但同时又被放入到后台线程中，因此 响应流 不会阻塞我们函数的执行。匿名函数也被 pop 出 stack。</li>
</ol>
<h2 id="Microtasks-Macrotasks"><a href="#Microtasks-Macrotasks" class="headerlink" title="Microtasks Macrotasks"></a>Microtasks Macrotasks</h2><p>任务队列不止一个，还有 microtasks 和 macrotasks</p>
<p>microtasks:</p>
<ul>
<li>process.nextTick</li>
<li>promise</li>
<li>Object.observe</li>
</ul>
<p>macrotasks:</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
</ul>
<p>这两个的详细区别下一篇再写，先看一段代码</p>
<pre><code>console.log(&apos;start&apos;)

const interval = setInterval(() =&gt; {  
  console.log(&apos;setInterval&apos;)
}, 0)

setTimeout(() =&gt; {  
  console.log(&apos;setTimeout 1&apos;)
  Promise.resolve()
      .then(() =&gt; {
        console.log(&apos;promise 3&apos;)
      })
      .then(() =&gt; {
        console.log(&apos;promise 4&apos;)
      })
      .then(() =&gt; {
        setTimeout(() =&gt; {
          console.log(&apos;setTimeout 2&apos;)
          Promise.resolve()
              .then(() =&gt; {
                console.log(&apos;promise 5&apos;)
              })
              .then(() =&gt; {
                console.log(&apos;promise 6&apos;)
              })
              .then(() =&gt; {
                clearInterval(interval)
              })
        }, 0)
      })
}, 0)

Promise.resolve()
    .then(() =&gt; {  
        console.log(&apos;promise 1&apos;)
    })
    .then(() =&gt; {
        console.log(&apos;promise 2&apos;)
    })
</code></pre><p>理解了node的事件循环还是比较容易得出答案的：</p>
<pre><code>start
promise 1
promise 2
setInterval
setTimeout 1
promise 3
promise 4
setInterval
setTimeout 2
promise 5
promise 6
</code></pre><p>根据 <a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">WHATVG</a> 的说明，在一个事件循环的周期(cycle)中一个 (macro)task 应该从 macrotask 队列开始执行。当这个 macrotask 结束后，所有的 microtasks 将在同一个 cycle 中执行。在 microtasks 执行时还可以加入更多的 microtask，然后一个一个的执行，直到 microtask 队列清空。</p>
<p>规范理解起来有点晦涩，来看下上面的例子</p>
<h2 id="Cycle-1"><a href="#Cycle-1" class="headerlink" title="Cycle 1"></a>Cycle 1</h2><p>1)<code>setInterval</code> 被列为 task</p>
<p>2)<code>setTimeout 1</code> 被列为 task</p>
<p>3)<code>Promise.resolve 1</code> 中两个 <code>then</code> 被列为 microtask</p>
<p>4) stack 清空 microtasks 执行</p>
<p>任务队列： <code>setInterval`</code>setTimeout 1`</p>
<h2 id="Cycle-2"><a href="#Cycle-2" class="headerlink" title="Cycle 2"></a>Cycle 2</h2><p>5) microtasks 队列清空 <code>setInteval</code> 的回调可以执行。另一个 <code>setInterval</code> 被列为 task , 位于 <code>setTimeout 1</code>后面</p>
<p>任务队列： <code>setTimeout 1`</code>setInterval`</p>
<h2 id="Cycle-3"><a href="#Cycle-3" class="headerlink" title="Cycle 3"></a>Cycle 3</h2><p>6) microtask 队列清空，<code>setTimeout 1</code> 的回调可以执行，<code>promise 3</code> 和 <code>promise 4</code> 被列为 microtasks</p>
<p>7)<code>promise 3</code> 和 <code>promise 4</code> 执行。 <code>setTimeout 2</code> 被列为 task</p>
<p>任务队列 <code>setInterval`</code>setTimeout 2`</p>
<h2 id="Cycle-4"><a href="#Cycle-4" class="headerlink" title="Cycle 4"></a>Cycle 4</h2><p>8) microtask 队列清空 <code>setInteval</code> 的回调可以执行。然后另一个 <code>setInterval</code> 被列为 task ，位于 <code>setTimeout 2</code> 后面</p>
<p>任务队列： <code>setTimeout 2`</code>setInterval`</p>
<p>9)<code>setTimeout 2</code> 的回调执行， <code>promise 5</code> 和 <code>promise 6</code> 被列为 microtasks</p>
<p>现在 <code>promise 5</code> 和 <code>promise 6</code> 的回调应该执行，并且 clear 掉 <code>interval</code>。 但有的时候不知道为什么 <code>setInterval</code> 还会在执行一遍，变成下面结果</p>
<pre><code>...
setTimeout 2
setInterval
promise 5
promise 6
</code></pre><p>但是把上面的代码放入 chrome console 中执行却没有问题。这一点还要再根据不同的 node版本 查一下。</p>
<h2 id="关于-macrotask-和-microtask"><a href="#关于-macrotask-和-microtask" class="headerlink" title="关于 macrotask 和 microtask"></a>关于 macrotask 和 microtask</h2><p>用例子简单理解了下 macrotask 和 microtask</p>
<p>这里再详细的总结下两者的区别和使用</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个事件循环(EventLoop)中会有一个正在执行的任务(Task)，而这个任务就是从 macrotask 队列中来的。在<a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">whatwg规范</a>中有 queue 就是任务队列。当这个 macrotask 执行结束后所有可用的 microtask 将会在同一个事件循环中执行，当这些 microtask 执行结束后还能继续添加 microtask 一直到真个 microtask 队列执行结束。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>基本来说，当我们想以同步的方式来处理异步任务时候就用 microtask（比如我们需要直接在某段代码后就去执行某个任务，就像Promise一样）。</p>
<p>其他情况就直接用 macrotask。</p>
<h2 id="两者的具体实现"><a href="#两者的具体实现" class="headerlink" title="两者的具体实现"></a>两者的具体实现</h2><ul>
<li>macrotasks: setTimeout setInterval setImmediate I/O UI渲染</li>
<li>microtasks: Promise process.nextTick Object.observe MutationObserver</li>
</ul>
<h2 id="从规范中理解"><a href="#从规范中理解" class="headerlink" title="从规范中理解"></a>从规范中理解</h2><p>whatwg规范：<a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/webappapis.html#task-queue</a></p>
<ul>
<li>一个事件循环(event loop)会有一个或多个任务队列(task queue) task queue 就是 macrotask queue</li>
<li>每一个 event loop 都有一个 microtask queue</li>
<li>task queue == macrotask queue != microtask queue</li>
<li>一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中</li>
<li>当一个 task 被放入队列 queue(macro或micro) 那这个 task 就可以被立即执行了</li>
</ul>
<p>再来回顾下事件循环如何执行一个任务的流程</p>
<p>当执行栈(call stack)为空的时候，开始依次执行：</p>
<ol>
<li>把最早的任务(task A)放入任务队列</li>
<li>如果 task A 为null (那任务队列就是空)，直接跳到第6步</li>
<li>将 currently running task 设置为 task A</li>
<li>执行 task A (也就是执行回调函数)</li>
<li>将 currently running task 设置为 null 并移出 task A</li>
<li>执行 microtask 队列</li>
</ol>
<ul>
<li>a: 在 microtask 中选出最早的任务 task X</li>
<li>b: 如果 task X 为null (那 microtask 队列就是空)，直接跳到 g</li>
<li>c: 将 currently running task 设置为 task X</li>
<li>d: 执行 task X</li>
<li>e: 将 currently running task 设置为 null 并移出 task X</li>
<li>f: 在 microtask 中选出最早的任务 , 跳到 b</li>
<li>g: 结束 microtask 队列</li>
</ul>
<ol>
<li>跳到第一步</li>
</ol>
<p>上面就算是一个简单的 event-loop 执行模型</p>
<p>再简单点可以总结为：</p>
<ol>
<li>在 macrotask 队列中执行最早的那个 task ，然后移出</li>
<li>执行 microtask 队列中所有可用的任务，然后移出</li>
<li>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>当一个task(在 macrotask 队列中)正处于执行状态，也可能会有新的事件被注册，那就会有新的 task 被创建。比如下面两个</li>
</ul>
<ol>
<li>promiseA.then() 的回调就是一个 task</li>
</ol>
<ul>
<li>promiseA 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promiseA 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li><p>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</p>
</li>
<li><p>microtask queue 中的 task 会在事件循环的当前回合中执行，因此 macrotask queue 中的 task 就只能等到事件循环的下一个回合中执行了</p>
</li>
<li>click ajax setTimeout 的回调是都是 task, 同时，包裹在一个 script 标签中的js代码也是一个 task 确切说是 macrotask。</li>
</ul>
<p>两者的具体实现</p>
<ul>
<li>macrotasks: setTimeout ，setInterval， setImmediate， I/O ，UI渲染，requestAnimationFrame</li>
<li>microtasks: Promise， process.nextTick， Object.observe， MutationObserver</li>
</ul>
<p>再简单点可以总结为：<br><img src="https://pic1.zhimg.com/v2-e92a4f5f686d115832b63b9b9e3ac2cd_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-e92a4f5f686d115832b63b9b9e3ac2cd_hd.jpg" alt=""></p>
<ol>
<li>在 macrotask 队列中执行最早的那个 task ，然后移出</li>
<li>再执行 microtask 队列中所有可用的任务，然后移出</li>
<li>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</li>
</ol>
<p>这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。<br>优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。<br>如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。</p>
<p>为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到：</p>
<blockquote>
<p>JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。<br>setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、 MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。<br>要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。<br>实在不行，只能用 setTimeout 创建 task 了。<br>为啥要用 microtask？<br>根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。<br>反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</p>
</blockquote>
<p>首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调，</p>
<p>MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。</p>
<p>setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行：</p>
<pre><code>setTimeout(function(){
    console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;);
},0);
</code></pre><p>它会将回调函数加入task中，等到执行。<br><img src="https://pic2.zhimg.com/v2-59cf9f88d7daac690d39edfb9fffc8b8_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-59cf9f88d7daac690d39edfb9fffc8b8_hd.jpg" alt=""></p>
<pre><code>setTimeout(function(){console.log(4)},0);
new Promise(function(resolve){
    console.log(1)
    for( var i=0 ; i&lt;10000 ; i++ ){
        i==9999 &amp;&amp; resolve()
    }
    console.log(2)
}).then(function(){
    console.log(5)
});
console.log(3);
结果是：
1,2,3,5,4
</code></pre><p>再看这个，两个自执行同时执行：</p>
<pre><code>&lt;script&gt;
(function test() {
  setTimeout(function () {
    console.log(4)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(1);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(2);
  }).then(function() {
    console.log(5);
  });
  console.log(3);
})()

(function test2() {
  setTimeout(function () {
    console.log(42)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(12);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(22);
  }).then(function() {
    console.log(52);
  });
  console.log(32);
})()
&lt;/script&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-cd18c572eb05069895ede7e34388bb8d_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-cd18c572eb05069895ede7e34388bb8d_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-afcb6fa6fb862818359f757107b769ab_b.jpg" alt=""><br>整个执行过程是一个 main thread 【<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/link%3Furl%3DCV-egCVH8yK1w-ilUqGsztryG8s2mbuhAliIC_L1n_-BSZ_KJ16tAfaNkmbcRtU8" target="_blank" rel="noopener">主线程</a>】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的<code>setTimeout</code>进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。</p>
<p>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：</p>
<p>1.先执行 macrotasks：I/O -》 UI渲染</p>
<p>2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe</p>
<p>3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：</p>
<p>setTimeout ，setInterval –》setImmediate</p>
<p>综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</p>
<pre><code>setImmediate(function(){
    console.log(1);
},0);
setTimeout(function(){
    console.log(2);
},0);
new Promise(function(resolve){
    console.log(3);
    resolve();
    console.log(4);
}).then(function(){
    console.log(5);
});
console.log(6);
process.nextTick(function(){
    console.log(7);
});
console.log(8);
结果是：3 4 6 8 7 5 2 1 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">94</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">57</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


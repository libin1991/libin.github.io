<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/9/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/31/26个精选的JavaScript面试问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/31/26个精选的JavaScript面试问题/" itemprop="url">26个精选的JavaScript面试问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-31T20:34:53+08:00">
                2016-10-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在JavaScript中，在两个不同类型之间的转换叫做<code>coercion</code>。在JavaScript中有两种形式：显示转换和隐式转换。</p>
<p>下面是一个显示转换的例子：</p>
<pre><code>var a = &quot;42&quot;;
var b = Number( a );
a;              // &quot;42&quot;
b;              // 42 -- the number!
</code></pre><p>下面是一个隐式转换的例子：</p>
<pre><code>var a = &quot;42&quot;;
var b = a * 1;  // &quot;42&quot; implicitly coerced to 42 here
a;              // &quot;42&quot;
b;              // 42 -- the number!
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.fullstack.cafe%2F" target="_blank" rel="noopener">FullStack.Cafe</a></p>
<h3 id="Q2-JavaScript中的作用域是怎样的？"><a href="#Q2-JavaScript中的作用域是怎样的？" class="headerlink" title="Q2: JavaScript中的作用域是怎样的？"></a>Q2: JavaScript中的作用域是怎样的？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐</p>
</blockquote>
<p>在JavaScript中，每一个函数都有各自的作用域(<code>scope</code>)。作用域可以理解为是一个变量的集合以及相应的如何访问它的规则。只有在函数内部的变量才可以访问到该函数域的变量。</p>
<p>在同一个作用域内部，变量名必须要唯一。作用域可以嵌套。在最内部的作用域中，可以访问任何外部的作用域中的变量。</p>
<h3 id="Q3-请解释JavaScript中的相等判断"><a href="#Q3-请解释JavaScript中的相等判断" class="headerlink" title="Q3: 请解释JavaScript中的相等判断"></a>Q3: 请解释JavaScript中的相等判断</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐</p>
</blockquote>
<p>JavaScript中的相等判断有严格判断和带隐式转换的判断两种：</p>
<ul>
<li>严格判断(strict comparision): 比如<code>===</code>，比较的时候不会隐式转换类型；</li>
<li><p>抽象判断(abstract comparasion)：比如<code>==</code>，比较的时候会隐式转换类型。</p>
<p>  var a = “42”;<br>  var b = 42;</p>
<p>  a == b;         // true<br>  a === b;        // false</p>
</li>
</ul>
<p>一些简单的规则：</p>
<ul>
<li>如果两边都是布尔类型的值，使用<code>===</code>;</li>
<li>如果两边是0,<code>&quot;&quot;</code>,<code>[]</code>，使用<code>===</code>;</li>
<li>所有其它类型，使用<code>==</code>是安全的。而且在很多情况下会简化代码、增加可读性。</li>
</ul>
<h3 id="Q4-请解释什么叫做回调函数并提供一个简单的例子"><a href="#Q4-请解释什么叫做回调函数并提供一个简单的例子" class="headerlink" title="Q4: 请解释什么叫做回调函数并提供一个简单的例子"></a>Q4: 请解释什么叫做回调函数并提供一个简单的例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>回调函数是一个函数，它被作为参数传入另一个函数，当某些操作结束后，该函数被调用。下面是一个简单的例子，当数组被修改后，调用回调函数打印一行日志。</p>
<pre><code>functionmodifyArray(arr, callback) {
  // do something to arr here
  arr.push(100);
  // then execute the callback function that was passed
  callback();
}

var arr = [1, 2, 3, 4, 5];
modifyArray(arr, function() {
  console.log(&quot;array has been modified&quot;, arr);
});
</code></pre><h3 id="Q5-“use-strict”到底有何用处？"><a href="#Q5-“use-strict”到底有何用处？" class="headerlink" title="Q5: “use strict”到底有何用处？"></a>Q5: “use strict”到底有何用处？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p><code>use strict</code>放在文件的顶部或则函数的第一行来启动更加严格的检查来避免失误引起的错误。比如，下面的代码会抛出错误：</p>
<pre><code>functiondoSomething(val) {
  &quot;use strict&quot;; 
  x = val + 10;
}
</code></pre><p>因为x没有定义，如果使用了<code>use strict</code>，x是不会被当做全局的变量来看待。下面的代码修复了这个BUG：</p>
<pre><code>functiondoSomething(val) {
  &quot;use strict&quot;; 
  var x = val + 10;
}
</code></pre><h3 id="Q6-请解释Null和Undefined"><a href="#Q6-请解释Null和Undefined" class="headerlink" title="Q6: 请解释Null和Undefined"></a>Q6: 请解释Null和Undefined</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>JavaScript和TypeScript有两个最基本的类型<code>null</code>和<code>undefined</code>。它们的含义是不同的：</p>
<ul>
<li>如果还没有被初始化，则是<code>undefined</code>;</li>
<li>如果不可用，则可以用<code>null</code>来表示；</li>
</ul>
<h3 id="Q7-请实现如下函数"><a href="#Q7-请实现如下函数" class="headerlink" title="Q7: 请实现如下函数"></a>Q7: 请实现如下函数</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<pre><code>var addSix = createBase(6);
addSix(10); // returns 16
addSix(21); // returns 27
</code></pre><p><code>addSix</code>是一个函数，也就是说createBase函数的返回是一个函数。</p>
<pre><code>functioncreateBase(baseNumber) {
  returnfunction(N) {
    // we are referencing baseNumber here even though it was declared// outside of this function. Closures allow us to do this in JavaScriptreturn baseNumber + N;
  }
}

var addSix = createBase(6);
addSix(10);
addSix(21);
</code></pre><h3 id="Q8-请解释JavaScript中的值和类型"><a href="#Q8-请解释JavaScript中的值和类型" class="headerlink" title="Q8: 请解释JavaScript中的值和类型"></a>Q8: 请解释JavaScript中的值和类型</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>下面是JavaScript内置的可用类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>null和undefined</li>
<li>object</li>
<li>symbol (ES6的新语法)</li>
</ul>
<h3 id="Q9-请解释事件冒泡以及如何阻止它？"><a href="#Q9-请解释事件冒泡以及如何阻止它？" class="headerlink" title="Q9: 请解释事件冒泡以及如何阻止它？"></a>Q9: 请解释事件冒泡以及如何阻止它？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>事件冒泡的概念是指：在最内层的元素上绑定的事件被触发后，会按照嵌套的层次由内向外逐步触发。因此，点击某个孩子节点可能会触发父节点的事件。</p>
<p>一个阻止事件冒泡的办法就是使用<code>event.stopPropagation()</code>，在IE&lt;9的浏览器上使用<code>event.cancelBubble()</code>。</p>
<p>来源：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkennymkchan" target="_blank" rel="noopener">github.com/kennymkchan</a></p>
<h3 id="Q10-请解释JavaScript中的let关键字"><a href="#Q10-请解释JavaScript中的let关键字" class="headerlink" title="Q10. 请解释JavaScript中的let关键字"></a>Q10. 请解释JavaScript中的let关键字</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>ES6允许你使用let关键字来申明块作用域(<code>{...}</code>)的变量。</p>
<p>来源: <a href="https://link.juejin.im?target=github.com%2Fgetify" target="_blank" rel="noopener">github.com/getify</a></p>
<h3 id="Q11-如何检查一个数字是否是整数？"><a href="#Q11-如何检查一个数字是否是整数？" class="headerlink" title="Q11: 如何检查一个数字是否是整数？"></a>Q11: 如何检查一个数字是否是整数？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>一个最简单的方法是判断除以1的余数是否为0.</p>
<pre><code>functionisInt(num) {
  return num % 1 === 0;
}

console.log(isInt(4)); // trueconsole.log(isInt(12.2)); // falseconsole.log(isInt(0.3)); // false
</code></pre><p>来源: <a href="https://link.juejin.im?target=coderbyte.com" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q12-什么叫IIFEs-Immediately-Invoked-Function-Expressions"><a href="#Q12-什么叫IIFEs-Immediately-Invoked-Function-Expressions" class="headerlink" title="Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)?"></a>Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)?</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>IIFE叫做立即执行表达式，顾名思义，该表达式一被创建就立即执行。</p>
<pre><code>(functionIIFE(){
    console.log( &quot;Hello!&quot; );
})();
// &quot;Hello!&quot;
</code></pre><p>该方法常用语避免污染全局的命名空间，因为所以在IIFE中使用的变量外部都无法访问。</p>
<p>来源: <a href="https://link.juejin.im?target=stackoverflow.com" target="_blank" rel="noopener">stackoverflow.com</a></p>
<h3 id="Q13-如果比较JavaScript中的两个对象？"><a href="#Q13-如果比较JavaScript中的两个对象？" class="headerlink" title="Q13: 如果比较JavaScript中的两个对象？"></a>Q13: 如果比较JavaScript中的两个对象？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐</p>
</blockquote>
<p>两个非基本类型的值，比如对象(包括函数和数组)都是通过引用的形式来访问。如果直接通过<code>==</code>和<code>===</code>来判断，那么只会简单的判断其引用地址是否相同，而不是它们实际对应的值。</p>
<p>如果数组和字符串做比较，那么数组会通过逗号拼接转换为字符串。通过等号判断的时候，两个相同的数组不会相等，但是和相同数据的字符串比较反而相等。</p>
<pre><code>var a = [1,2,3];
var b = [1,2,3];
var c = &quot;1,2,3&quot;;

a == c;     // true
b == c;     // true
a == b;     // false
</code></pre><p>如果要深度比较，可以使用第三方库，比如<code>deep-equal</code>或则你自己实现一个比较算法。</p>
<h3 id="Q14-请解释ES5和ES6的不同点"><a href="#Q14-请解释ES5和ES6的不同点" class="headerlink" title="Q14: 请解释ES5和ES6的不同点"></a>Q14: 请解释ES5和ES6的不同点</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<ul>
<li>ECMAScript 5 (ES5): 第5个ECMAScript版本，于2009年标准化。该标准几乎所有的浏览器都完全支持。</li>
<li>ECMAScript 6 (ES6)/ECMAScript 2015 (ES2015):  第6个ECMAScript版本，于2015年标准化。目前各大浏览器还只是部分支持。</li>
</ul>
<p>接下来介绍它们主要的区别：</p>
<ul>
<li><p>箭头函数和字符串嵌入：</p>
<p>  const greetings = (name) =&gt; {</p>
<pre><code>return`hello ${name}`;
</code></pre><p>  }</p>
</li>
</ul>
<p>甚至：</p>
<pre><code>const greetings = name =&gt;`hello ${name}`;
</code></pre><ul>
<li><p>常量声明(Const): 如同其它编程语言中的常量一样，但又有不同。这里的<code>const</code>代表了<code>constant reference</code>。也就是说，你可以修改其指向的对象的值。但是你不能修改其reference的值。</p>
<p>  const NAMES = [];<br>  NAMES.push(“Jim”);<br>  console.log(NAMES.length === 1); // true<br>  NAMES = [“Steve”, “John”]; // error</p>
</li>
<li><p>块作用域变量：ES6中的新关键字<code>let</code>允许允许开发者将变量的作用域限定在块级别。不会像<code>var</code>一样变量提升。</p>
</li>
<li><p>参数默认值：允许在函数定义的时候指定默认的值。</p>
<p>  // Basic syntaxfunctionmultiply (a, b = 2) {</p>
<pre><code>return a * b;
</code></pre><p>  }<br>  multiply(5); // 10</p>
</li>
<li><p>类定义和继承</p>
</li>
</ul>
<p>ES6开始支持定义类(使用<code>class</code>关键字)，构造函数(使用<code>constructor</code>关键字)，和<code>extend</code>关键字来实现继承。</p>
<ul>
<li>for-of操作</li>
</ul>
<p><code>for...of</code>语句用来迭代访问一个对象的所有属性。</p>
<ul>
<li><p>Spread操作符：用于对象合并</p>
<p>  const obj1 = { a: 1, b: 2 }<br>  const obj2 = { a: 2, c: 3, d: 4}<br>  const obj3 = {…obj1, …obj2}</p>
</li>
</ul>
<ul>
<li><p>Promise: Promises提供了一个处理异步操作的方法。你可以用回调函数来实现，但是Promise更加简洁和可读。</p>
<p>  const isGreater = (a, b) =&gt; {</p>
<pre><code>returnnewPromise ((resolve, reject) =&gt; {
  if(a &gt; b) {
    resolve(true)
  } else {
    reject(false)
  }
  })
</code></pre><p>  }<br>  isGreater(1, 2)</p>
<pre><code>.then(result =&gt; {
  console.log(&apos;greater&apos;)
})
</code></pre><p>   .catch(result =&gt; {</p>
<pre><code>console.log(&apos;smaller&apos;)
</code></pre><p>   })</p>
</li>
</ul>
<ul>
<li><p>模块的export和import。</p>
<p>  const myModule = { x: 1, y: () =&gt; { console.log(‘This is ES5’) }}<br>  exportdefault myModule;</p>
</li>
</ul>
<pre><code>import myModule from&apos;./myModule&apos;;
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.to%2Faershov24%2Fundefined" target="_blank" rel="noopener">Bulby.io</a></p>
<h3 id="Q15-请解释undefined和not-defined的区别"><a href="#Q15-请解释undefined和not-defined的区别" class="headerlink" title="Q15: 请解释undefined和not defined的区别"></a>Q15: 请解释<code>undefined</code>和<code>not defined</code>的区别</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<p>在JavaScript中，如果你尝试使用不存在的还未申明的变量，JavaScript会抛出错误<code>var name is not defined</code>。但是如果你用<code>typeof</code>来查看其类型，会返回<code>undefined</code>。</p>
<p>我们先来澄清一下声明和定义的区别：<code>var x</code>是一个声明，因为你并没有定义其具体的值，你只是声明其存在性。</p>
<pre><code>var x; // declaring xconsole.log(x); //output: undefined
</code></pre><p><code>var x = 1</code>同时兼具声明和定义，我们也可以叫它初始化。在JavaScript中，每一个变量和函数声明都会被提升到顶部。</p>
<p>如果我们访问一个声明了但是未定义的变量，会返回<code>undefined</code>。</p>
<pre><code>var x; // Declarationif(typeof x === &apos;undefined&apos;) // Will return true
</code></pre><blockquote>
<p>访问一个未声明未定义的变量，会返回not defined错误。</p>
</blockquote>
<pre><code>console.log(y);  // Output: ReferenceError: y is not defined
</code></pre><p>来源: <a href="https://link.juejin.im?target=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F20822022%2Fjavascript-variable-definition-declaration" target="_blank" rel="noopener">stackoverflow.com</a></p>
<h3 id="Q16-匿名函数和命名函数的区别？"><a href="#Q16-匿名函数和命名函数的区别？" class="headerlink" title="Q16: 匿名函数和命名函数的区别？"></a>Q16: 匿名函数和命名函数的区别？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐</p>
</blockquote>
<pre><code>var foo = function() { // anonymous function assigned to variable foo// ..
};

var x = functionbar(){ // named function (bar) assigned to variable x // ..
};

foo(); // actual function execution
x();
</code></pre><p>译者补充：匿名函数如果不赋值给某个变量，则无法被调用了；命名函数再次被赋值不是多此一举么。</p>
<h3 id="Q17-JavaScript中闭包是什么？请提供一个例子"><a href="#Q17-JavaScript中闭包是什么？请提供一个例子" class="headerlink" title="Q17: JavaScript中闭包是什么？请提供一个例子"></a>Q17: JavaScript中闭包是什么？请提供一个例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>闭包是一个定义在其它函数(父函数)里面的函数，它拥有对父函数里面变量的访问权。闭包拥有如下三个作用域的访问权：</p>
<ul>
<li>自身的作用域</li>
<li>父作用域</li>
<li><p>全局作用域</p>
<p>  var globalVar = “abc”;</p>
<p>  // Parent self invoking function<br>  (functionouterFunction (outerArg) { // begin of scope outerFunction// Variable declared in outerFunction function scopevar outerFuncVar = ‘x’;    </p>
<pre><code>// Closure self-invoking function
(functioninnerFunction (innerArg) { // begin of scope innerFunction// variable declared in innerFunction function scopevar innerFuncVar = &quot;y&quot;;
  console.log(         
    &quot;outerArg = &quot; + outerArg + &quot;\n&quot; +
    &quot;outerFuncVar = &quot; + outerFuncVar + &quot;\n&quot; +
    &quot;innerArg = &quot; + innerArg + &quot;\n&quot; +
    &quot;innerFuncVar = &quot; + innerFuncVar + &quot;\n&quot; +
    &quot;globalVar = &quot; + globalVar);
// end of scope innerFunction
})(5); // Pass 5 as parameter// end of scope outerFunction
</code></pre><p>  })(7); // Pass 7 as parameter</p>
</li>
</ul>
<p><code>innerFunction</code>是一个闭包，定义在<code>outerFunction</code>中，它可以访问<code>outerFunction</code>作用域的所有变量。当然，它还可以访问全局变量。</p>
<p>输出结果如下：</p>
<pre><code>outerArg = 7
outerFuncVar = x
innerArg = 5
innerFuncVar = y
globalVar = abc
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fganqqwerty%2F123-Essential-JavaScript-Interview-Question%2Fblob%2Fmaster%2FREADME.md" target="_blank" rel="noopener">github.com/ganqqwerty</a></p>
<h3 id="Q18-在JavaScript中如何创建私有变量？"><a href="#Q18-在JavaScript中如何创建私有变量？" class="headerlink" title="Q18: 在JavaScript中如何创建私有变量？"></a>Q18: 在JavaScript中如何创建私有变量？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>你可以通过在函数中声明变量来创建私有变量。因为在函数中，外部无法直接访问。</p>
<pre><code>functionfunc() {
  var priv = &quot;secret code&quot;;
}

console.log(priv); // throws error
</code></pre><p>为了访问该变量，可以构造一个帮助函数来返回该值。</p>
<pre><code>functionfunc() {
  var priv = &quot;secret code&quot;;
  returnfunction() {
    return priv;
  }
}

var getPriv = func();
console.log(getPriv()); // =&gt; secret code
</code></pre><p>来源:<a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q19-请解释原型模式-Prototype-Design-Pattern"><a href="#Q19-请解释原型模式-Prototype-Design-Pattern" class="headerlink" title="Q19: 请解释原型模式(Prototype Design Pattern)"></a>Q19: 请解释原型模式(Prototype Design Pattern)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>原型模式会创建一个新的对象，但不是创建一个未初始化的对象，而是通过拷贝原型链上的值或则被拷贝对象的值来完成初始化。传统的语言很少使用原型模式，但是JavaScript作为一个基于原型的语言，使用原型模式来创建新的对象。</p>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.dofactory.com%2Fjavascript%2Fprototype-design-pattern" target="_blank" rel="noopener">dofactory.com</a></p>
<h3 id="Q20-判断给定的字符串是否同态-isomorphic"><a href="#Q20-判断给定的字符串是否同态-isomorphic" class="headerlink" title="Q20: 判断给定的字符串是否同态(isomorphic)"></a>Q20: 判断给定的字符串是否同态(isomorphic)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>首先介绍什么叫做同态：两个字符串，如果A字符串中的每一个字符都可以在B字符串中找到唯一对应，并且顺序一一对应；如果存在这样的函数，那么A和B同态。</p>
<ul>
<li><code>paper</code>和<code>title</code>同态</li>
<li><code>egg</code>和<code>sad</code>不同态</li>
<li><p><code>dgg</code>和<code>add</code>同态</p>
<p>  isIsomorphic(“egg”, ‘add’); // true<br>  isIsomorphic(“paper”, ‘title’); // true<br>  isIsomorphic(“kick”, ‘side’); // falsefunctionisIsomorphic(firstString, secondString) {</p>
<pre><code>// Check if the same length. If not, they cannot be isomorphicif (firstString.length !== secondString.length) returnfalsevar letterMap = {};

for (var i = 0; i &lt; firstString.length; i++) {
  var letterA = firstString[i],
      letterB = secondString[i];

  // If the letter does not exist, create a map and map it to the value// of the second letterif (letterMap[letterA] === undefined) {
    letterMap[letterA] = letterB;
  } elseif (letterMap[letterA] !== letterB) {
    // Eles if letterA already exists in the map, but it does not map to// letterB, that means that A is mapping to more than one letter.returnfalse;
  }
}
// If after iterating through and conditions are satisfied, return true.// They are isomorphicreturntrue;
</code></pre><p>  }</p>
</li>
</ul>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkennymkchan%2Finterview-questions-in-javascript" target="_blank" rel="noopener">github.com/kennymkchan</a></p>
<h3 id="Q21-Transpiling代表了什么意思？"><a href="#Q21-Transpiling代表了什么意思？" class="headerlink" title="Q21: Transpiling代表了什么意思？"></a>Q21: <code>Transpiling</code>代表了什么意思？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p><code>Transpiling</code>是<code>transforming + compiling</code>的合成词。对于一些新的语法，浏览器还不支持。最好的办法就是将其变换到旧的等价的代码，这个过程通常叫做<code>transpiling</code>。</p>
<p>典型的，你可以在<code>build</code>的过程中加入<code>transpiler</code>，就如同<code>code linter</code>和<code>minifier</code>一样。</p>
<p>已经有很多知名的transpilers可供使用：</p>
<ul>
<li>Babel: 将ES6编译到ES5</li>
<li>Traceur：将ES6,ES7等编译到ES5</li>
</ul>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2Fmaster%2Fup%2520%2526%2520going%2Fch2.md" target="_blank" rel="noopener">You Don’t Know JS, Up &amp;going</a></p>
<h3 id="Q22-this关键字如何工作？请提供一些例子"><a href="#Q22-this关键字如何工作？请提供一些例子" class="headerlink" title="Q22: this关键字如何工作？请提供一些例子"></a>Q22: <code>this</code>关键字如何工作？请提供一些例子</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>在JavaScript中，this总是指向函数的“拥有者”(也就是指向该函数的对象)，或则拥有该函数的对象。</p>
<pre><code>functionfoo() {
    console.log( this.bar );
}

var bar = &quot;global&quot;;

var obj1 = {
    bar: &quot;obj1&quot;,
    foo: foo
};

var obj2 = {
    bar: &quot;obj2&quot;
};

foo();          // &quot;global&quot;
obj1.foo();     // &quot;obj1&quot;
foo.call( obj2 );  // &quot;obj2&quot;new foo();       // undefined
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.quirksmode.org%2Fjs%2Fthis.html" target="_blank" rel="noopener">quirksmode.org</a></p>
<h3 id="Q23-如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。"><a href="#Q23-如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。" class="headerlink" title="Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。"></a>Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<pre><code>var arr = [1, 2, 3, 4, 5];
var avg = arr.average();
console.log(avg);
</code></pre><p>JavaScript是一个基于原型的语言。也就是说对象之间通过原型链接，并继承其函数。为了给Array对象添加函数，我们可以修改其原型定义<code>Array prorotype</code>。</p>
<pre><code>Array.prototype.average = function() {
  // calculate sumvar sum = this.reduce(function(prev, cur) { return prev + cur; });
  // return sum divided by number of elementsreturn sum / this.length;
}

var arr = [1, 2, 3, 4, 5];
var avg = arr.average();
console.log(avg); // =&gt; 3
</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q24-JavaScript中提升-hoisting-是什么意思？"><a href="#Q24-JavaScript中提升-hoisting-是什么意思？" class="headerlink" title="Q24: JavaScript中提升(hoisting)是什么意思？"></a>Q24: JavaScript中提升(hoisting)是什么意思？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<p>提升(hoisting)是指JavaScript的解释器将所有的变量和函数声明都提升到该作用域的顶部，有两种提升类型：</p>
<ul>
<li>变量提升</li>
<li>函数提升</li>
</ul>
<p>在一个作用域中通过声明的变量和函数在整个作用域中都可以使用。</p>
<pre><code>var a = 2;
foo();                 // works because `foo()`// declaration is &quot;hoisted&quot;functionfoo() {
    a = 3;
    console.log( a );   // 3var a;             // declaration is &quot;hoisted&quot;// to the top of `foo()`
}

console.log( a );   // 2
</code></pre><p>虽然<code>foo()</code>函数在后面定义，但是在前面也可以调用。</p>
<h3 id="Q25-如下代码会返回什么结果？"><a href="#Q25-如下代码会返回什么结果？" class="headerlink" title="Q25: 如下代码会返回什么结果？"></a>Q25: 如下代码会返回什么结果？</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p>
</blockquote>
<pre><code>0.1 + 0.2 === 0.3
</code></pre><p>不要惊讶，其结果是false。因为浮点数在系统内的精确度问题，0.1+0.2的结果并不是0.3，而是0.30000000000000004。<br>要避免这个问题的方法是指定返回结果的小数位数。</p>
<p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p>
<h3 id="Q26-请描述一下揭示模式-Revealing-Module-Pattern"><a href="#Q26-请描述一下揭示模式-Revealing-Module-Pattern" class="headerlink" title="Q26: 请描述一下揭示模式(Revealing Module Pattern)"></a>Q26: 请描述一下揭示模式(Revealing Module Pattern)</h3><blockquote>
<p>话题: JavaScript<br>难度: ⭐⭐⭐⭐⭐</p>
</blockquote>
<p><strong>Module pattern</strong>的一个变种是<code>Revealing Module Pattern</code>。该设计模式的目的是做到很好的代码隔离，只是将需要对外公开的变量和函数暴露出来。一个直接的实现如下所示：</p>
<pre><code>var Exposer = (function() {
  var privateVariable = 10;

  var privateMethod = function() {
    console.log(&apos;Inside a private method!&apos;);
    privateVariable++;
  }

  var methodToExpose = function() {
    console.log(&apos;This is a method I want to expose!&apos;);
  }

  var otherMethodIWantToExpose = function() {
    privateMethod();
  }

  return {
      first: methodToExpose,
      second: otherMethodIWantToExpose
  };
})();

Exposer.first();        // Output: This is a method I want to expose!
Exposer.second();       // Output: Inside a private method!
Exposer.methodToExpose; // undefined
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/28/JSBridge的原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/28/JSBridge的原理/" itemprop="url">JSBridge的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-28T10:21:44+08:00">
                2016-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。</p>
<p>当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。<br><img src="/2016/10/28/JSBridge的原理/1.webp" alt=""><br><img src="/2016/10/28/JSBridge的原理/2.webp" alt=""></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h1><p>有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。</p>
<h1 id="2-JSBridge-的起源"><a href="#2-JSBridge-的起源" class="headerlink" title="2 JSBridge 的起源"></a><strong>2 JSBridge 的起源</strong></h1><p>为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？</p>
<p>当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的 <strong>最易编写</strong> 、 <strong>最易维护</strong> 、<strong>最易部署</strong> 的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。</p>
<p>因此，<strong>开发维护成本</strong> 和 <strong>更新成本</strong> 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。</p>
<p>PhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。</p>
<p>移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上：</p>
<p>基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案</p>
<p>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native</p>
<p>【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。</p>
<h1 id="3-JSBridge-的用途"><a href="#3-JSBridge-的用途" class="headerlink" title="3 JSBridge 的用途"></a><strong>3 JSBridge 的用途</strong></h1><p>JSBridge 简单来讲，主要是 <strong>给 JavaScript 提供调用 Native 功能的接口</strong>，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。</p>
<p>既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 <strong>构建 Native 和非 Native 间消息通信的通道</strong>，而且是 <strong>双向通信的通道</strong>。<br><img src="/2016/10/28/JSBridge的原理/3.webp" alt=""><br>所谓 <strong>双向通信的通道</strong>:</p>
<ul>
<li>JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。</li>
<li>Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</li>
</ul>
<p>这里有些同学有疑问了：<em>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</em><br>对于这个问题，在下一节里会给出解释。</p>
<h1 id="4-JSBridge-的实现原理"><a href="#4-JSBridge-的实现原理" class="headerlink" title="4 JSBridge 的实现原理"></a><strong>4 JSBridge 的实现原理</strong></h1><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。</p>
<p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：<strong>通信调用（Native 与 JS 通信）</strong> 和 <strong>句柄解析调用</strong>。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）</p>
<p>通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 <strong>Hybrid 方案</strong> 为案例从这几点来剖析 JSBridge 的实现原理。</p>
<h2 id="4-1-JSBridge-的通信原理"><a href="#4-1-JSBridge-的通信原理" class="headerlink" title="4.1 JSBridge 的通信原理"></a><strong>4.1 JSBridge 的通信原理</strong></h2><p>Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。</p>
<h3 id="4-1-1-JavaScript-调用-Native"><a href="#4-1-1-JavaScript-调用-Native" class="headerlink" title="4.1.1 JavaScript 调用 Native"></a><strong>4.1.1 JavaScript 调用 Native</strong></h3><p>JavaScript 调用 Native 的方式，主要有两种：<font color="#ff0000"><strong>注入 API</strong> </font> 和 <font color="#ff0000"> <strong>拦截 URL SCHEME</strong> </font>。</p>
<h4 id="4-1-1-1-注入API"><a href="#4-1-1-1-注入API" class="headerlink" title="4.1.1.1 注入API"></a><strong>4.1.1.1 注入API</strong></h4><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p>
<p>对于 iOS 的 UIWebView，实例如下：</p>
<pre><code>JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) {
    // Native 逻辑
};
</code></pre><p>前端调用方式：</p>
<pre><code>window.postBridgeMessage(message);
</code></pre><p>对于 iOS 的 WKWebView 可以用以下方式：</p>
<pre><code>@interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt;

@implementation WKWebVIewVC

- (void)viewDidLoad {
    [super viewDidLoad];

    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];
    configuration.userContentController = [[WKUserContentController alloc] init];
    WKUserContentController *userCC = configuration.userContentController;
    // 注入对象，前端调用其方法时，Native 可以捕获到
    [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;];

    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];

    // TODO 显示 WebView
}

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) {
        NSLog(@&quot;前端传递的数据 %@: &quot;,message.body);
        // Native 逻辑
    }
}
</code></pre><p>前端调用方式：</p>
<pre><code>window.webkit.messageHandlers.nativeBridge.postMessage(message);
</code></pre><p>对于 Android 可以采用下面的方式：</p>
<pre><code>publicclassJavaScriptInterfaceDemoActivityextendsActivity{
private WebView Wv;

    @Override
    publicvoidonCreate(Bundle savedInstanceState){
        super.onCreate(savedInstanceState);

        Wv = (WebView)findViewById(R.id.webView);     
        final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);         

        Wv.getSettings().setJavaScriptEnabled(true);
        Wv.addJavascriptInterface(myJavaScriptInterface, &quot;nativeBridge&quot;);

        // TODO 显示 WebView

    }

    publicclassJavaScriptInterface{
         Context mContext;

         JavaScriptInterface(Context c) {
             mContext = c;
         }

         publicvoidpostMessage(String webMessage){            
             // Native 逻辑
         }
     }
}
</code></pre><p>前端调用方式：</p>
<pre><code>window.nativeBridge.postMessage(message);
</code></pre><p>在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 <strong>有兼容性问题的</strong>。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。）</p>
<h4 id="4-1-1-2-拦截-URL-SCHEME"><a href="#4-1-1-2-拦截-URL-SCHEME" class="headerlink" title="4.1.1.2 拦截 URL SCHEME"></a><strong>4.1.1.2 拦截 URL SCHEME</strong></h4><p>先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=<a href="https://link.juejin.im?target=http%3A%2F%2Fymfe.tech" target="_blank" rel="noopener">ymfe.tech</a>，protocol 是 qunarhy，host 则是 hy。</p>
<p>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p>
<p>在时间过程中，这种方式有一定的 <strong>缺陷</strong>：</p>
<ul>
<li><font color="#dd0000"><strong> 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</strong></font>
</li>
<li><font color="#dd0000"><strong>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</strong></font>

</li>
</ul>
<p>但是之前为什么很多方案使用这种方式呢？因为它 <strong>支持 iOS6</strong>。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 <strong>并不优雅</strong> 的方式。</p>
<p>【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。</p>
<p>【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。</p>
<h3 id="4-1-2-Native-调用-JavaScript"><a href="#4-1-2-Native-调用-JavaScript" class="headerlink" title="4.1.2 Native 调用 JavaScript"></a><strong>4.1.2 Native 调用 JavaScript</strong></h3><p>相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。</p>
<p>Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）</p>
<p>对于 iOS 的 UIWebView，示例如下：</p>
<pre><code>result = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];
</code></pre><p>对于 iOS 的 WKWebView，示例如下：</p>
<pre><code>[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];
</code></pre><p>对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现：</p>
<pre><code>webView.loadUrl(&quot;javascript:&quot; + javaScriptString);
</code></pre><p>而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现：</p>
<pre><code>webView.evaluateJavascript(javaScriptString, new ValueCallback&lt;String&gt;() {
    @Override
    publicvoidonReceiveValue(String value){

    }
});
</code></pre><p>【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。</p>
<h3 id="4-1-3-通信原理小总结"><a href="#4-1-3-通信原理小总结" class="headerlink" title="4.1.3 通信原理小总结"></a><strong>4.1.3 通信原理小总结</strong></h3><p>通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下：</p>
<ul>
<li><p>JavaScript 调用 Native 推荐使用 <strong>注入 API</strong> 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。</p>
</li>
<li><p>Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。</p>
</li>
</ul>
<p>对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。</p>
<p>以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 <strong>为了与 Native 开发里事件响应机制一致</strong>，设计成 <strong>需要在 Object-C 去调 JavaScript 时才通过返回值触发调用</strong>。原理基本一样，只是实现方式不同。</p>
<p>当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。</p>
<h2 id="4-2-JSBridge-接口实现"><a href="#4-2-JSBridge-接口实现" class="headerlink" title="4.2 JSBridge 接口实现"></a><strong>4.2 JSBridge 接口实现</strong></h2><p>从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：<strong>调用 Native（给 Native 发消息）</strong> 和 <strong>接被 Native 调用（接收 Native 消息）</strong>。因此，JSBridge 可以设计如下：</p>
<pre><code>window.JSBridge = {
    // 调用 Native
    invoke: function(msg) {
        // 判断环境，获取不同的 nativeBridge
        nativeBridge.postMessage(msg);
    },
    receiveMessage: function(msg) {
        // 处理 msg
    }
};
</code></pre><p>在上面的文章中，提到过 RPC 中有一个非常重要的环节是 <strong>句柄解析调用</strong> ，这点在 JSBridge 中体现为 <strong>句柄与功能对应关系</strong>。同时，我们将句柄抽象为 <strong>桥名（BridgeName）</strong>，最终演化为 <strong>一个 BridgeName 对应一个 Native 功能或者一类 Native 消息</strong>。 基于此点，JSBridge 的实现可以优化为如下：</p>
<pre><code>window.JSBridge = {
    // 调用 Native
    invoke: function(bridgeName, data) {
        // 判断环境，获取不同的 nativeBridge
        nativeBridge.postMessage({
            bridgeName: bridgeName,
            data: data || {}
        });
    },
    receiveMessage: function(msg) {
        var bridgeName = msg.bridgeName,
            data = msg.data || {};
        // 具体逻辑
    }
};
</code></pre><p>JSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：<strong>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</strong></p>
<p>对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释：</p>
<blockquote>
<p>当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 <strong>当前页面唯一</strong> 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。</p>
</blockquote>
<p>由此可见，callback 参数这个 <strong>唯一标识</strong> 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。</p>
<pre><code>(function () {
    var id = 0,
        callbacks = {};

    window.JSBridge = {
        // 调用 Native
        invoke: function(bridgeName, callback, data) {
            // 判断环境，获取不同的 nativeBridge
            var thisId = id ++; // 获取唯一 id
            callbacks[thisId] = callback; // 存储 Callback
            nativeBridge.postMessage({
                bridgeName: bridgeName,
                data: data || {},
                callbackId: thisId // 传到 Native 端
            });
        },
        receiveMessage: function(msg) {
            var bridgeName = msg.bridgeName,
                data = msg.data || {},
                callbackId = msg.callbackId; // Native 将 callbackId 原封不动传回
            // 具体逻辑
            // bridgeName 和 callbackId 不会同时存在
            if (callbackId) {
                if (callbacks[callbackId]) { // 找到相应句柄
                    callbacks[callbackId](msg.data); // 执行调用
                }
            } elseif (bridgeName) {

            }
        }
    };
})();
</code></pre><p>最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下：</p>
<pre><code>(function () {
    var id = 0,
        callbacks = {},
        registerFuncs = {};

    window.JSBridge = {
        // 调用 Native
        invoke: function(bridgeName, callback, data) {
            // 判断环境，获取不同的 nativeBridge
            var thisId = id ++; // 获取唯一 id
            callbacks[thisId] = callback; // 存储 Callback
            nativeBridge.postMessage({
                bridgeName: bridgeName,
                data: data || {},
                callbackId: thisId // 传到 Native 端
            });
        },
        receiveMessage: function(msg) {
            var bridgeName = msg.bridgeName,
                data = msg.data || {},
                callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回
                responstId = msg.responstId;
            // 具体逻辑
            // bridgeName 和 callbackId 不会同时存在
            if (callbackId) {
                if (callbacks[callbackId]) { // 找到相应句柄
                    callbacks[callbackId](msg.data); // 执行调用
                }
            } elseif (bridgeName) {
                if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄
                    var ret = {},
                        flag = false;
                    registerFuncs[bridgeName].forEach(function(callback) =&gt; {
                        callback(data, function(r) {
                            flag = true;
                            ret = Object.assign(ret, r);
                        });
                    });
                    if (flag) {
                        nativeBridge.postMessage({ // 回调 Native
                            responstId: responstId,
                            ret: ret
                        });
                    }
                }
            }
        },
        register: function(bridgeName, callback) {
            if (!registerFuncs[bridgeName])  {
                registerFuncs[bridgeName] = [];
            }
            registerFuncs[bridgeName].push(callback); // 存储回调
        }
    };
})();
</code></pre><p>当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。</p>
<p>【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 =&gt; 解析参数，拿到 bridgeName、data 和 callbackId =&gt; 根据 bridgeName 找到功能方法，以 data 为参数执行 =&gt; 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。</p>
<h1 id="5-JSBridge-如何引用"><a href="#5-JSBridge-如何引用" class="headerlink" title="5 JSBridge 如何引用"></a><strong>5 JSBridge 如何引用</strong></h1><p>对于 JSBridge 的引用，常用有两种方式，各有利弊。</p>
<h2 id="5-1-由-Native-端进行注入"><a href="#5-1-由-Native-端进行注入" class="headerlink" title="5.1 由 Native 端进行注入"></a><strong>5.1 由 Native 端进行注入</strong></h2><p>注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。</p>
<p>它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p>
<h2 id="5-2-由-JavaScript-端引用"><a href="#5-2-由-JavaScript-端引用" class="headerlink" title="5.2 由 JavaScript 端引用"></a><strong>5.2 由 JavaScript 端引用</strong></h2><p>直接与 JavaScript 一起执行。</p>
<p>与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。</p>
<h1 id="如何调用三种唤端媒介"><a href="#如何调用三种唤端媒介" class="headerlink" title="如何调用三种唤端媒介"></a><strong>如何调用三种唤端媒介</strong></h1><p>无论是 URL Scheme 还是 Intent 或者 Universal Link ，他们都算是 URL ，只是 URL Scheme 和 Intent 算是特殊的 URL。所以我们可以拿使用 URL 的方法来使用它们。</p>
<blockquote>
<p>iframe</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;sinaweibo://qrcode&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>在只有 URL Scheme 的日子里，iframe 是使用最多的了。因为在未安装 app 的情况下，不会去跳转错误页面。但是 iframe 在各个系统以及各个应用中的兼容问题还是挺多的，不能全部使用 URL Scheme。</p>
<blockquote>
<p>a 标签</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;intent://scan/#Intent;scheme=zxing;package=com.google.zxing.client.android;end&quot;&quot;&gt;扫一扫&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>对于动态生成的 a 标签，使用 dispatch 来模拟触发点击事件，发现很多种 event 传递过去都无效；使用 click() 来模拟触发，部分场景下存在这样的情况，第一次点击过后，回到原先页面，再次点击，点击位置和页面所识别位置有不小的偏移，所以 Intent 协议从 a 标签换成了 window.location。</p>
<blockquote>
<p>window.location</p>
</blockquote>
<p>URL Scheme 在 ios 9+ 上诸如 safari、UC、QQ浏览器中， iframe 均无法成功唤起 APP，只能通过 window.location 才能成功唤端。<br>当然，如果我们的 app 支持 Universal Link，ios 9+ 就用不到 URL Scheme 了。而 Universal Link 在使用过程中，我发现在 qq 中，无论是 iframe 导航 还是 a 标签打开 又或者 window.location 都无法成功唤端，一开始我以为是 qq 和微信一样禁止了 Universal Link 唤端的功能，其实不然，百般试验下，通过 top.location 唤端成功了。</p>
<h3 id="判断唤端是否成功"><a href="#判断唤端是否成功" class="headerlink" title="判断唤端是否成功"></a>判断唤端是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const initialTime = new Date();</span><br><span class="line">let counter = 0;</span><br><span class="line">let waitTime = 0;</span><br><span class="line"></span><br><span class="line">const checkOpen = setInterval(() =&gt; &#123;</span><br><span class="line">   count++;</span><br><span class="line">   waitTime = new Date() - initialTime;</span><br><span class="line"></span><br><span class="line">   if (waitTime &gt; 2500) &#123;</span><br><span class="line">      clearInterval(checkOpen);</span><br><span class="line">      cb();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (counter &lt; 100) return;</span><br><span class="line"></span><br><span class="line">   clearInterval(checkOpen);</span><br><span class="line"></span><br><span class="line">   const hide = document.hidden || document.webkitHidden;</span><br><span class="line"></span><br><span class="line">   if (!hide) &#123;</span><br><span class="line">      cb(); // 唤端失败的回调函数</span><br><span class="line">   &#125;</span><br><span class="line">&#125;, 20);</span><br></pre></td></tr></table></figure>
<p>APP 如果被唤起的话，页面就会进入后台运行，setInterval 在 ios 中不会停止运行，在 android 中停止运行。<br>每 20ms 执行一次，执行 100次 在页面中实际耗费与 2000 ms 不会相差多少。<br>我们的判断条件比预期时间多设置了 500ms，所以如果安卓中 setInterval 内的函数执行 100 次以内所费时间超过 2500ms，则说明 APP 唤起成功，反之则代表失败。<br>我们通过 document.hidden 和 document.webkitHidden 属性来判断 APP 在 ios 中是否被正常唤起，2000ms 内，页面转入后台运行，document.hidden 会返回 true，代表唤端成功，反之则代表失败。</p>
<h1 id="判断是否安装app并打开-否则跳转下载的方法"><a href="#判断是否安装app并打开-否则跳转下载的方法" class="headerlink" title="判断是否安装app并打开,否则跳转下载的方法"></a><strong>判断是否安装app并打开,否则跳转下载的方法</strong></h1><blockquote>
<p>应用场景</p>
</blockquote>
<p>App产品在运营推广上有一个需求，就是要求可以让用户在访问我们的推广网页时，就可以判断出这个用户手机上是否安装了我们的App，如果安装了则可以直接在网页上打开，否则就引导用户前往下载。从而形成一个推广上的闭环。</p>
<blockquote>
<p>解决办法</p>
</blockquote>
<p>而对于点击链接后，能否直接打开，可以通过下面的代码来实现。前提条件：你得知道你的APP对应的打开协议，如贴吧APP，协议为：com.baidu.tieba:// ，微信的：weixin:// ，等等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a标签点击打开的动作，在click事件中注册 --&gt;</span><br><span class="line">&lt;a href=&quot;javascript:;&quot; id=&quot;openApp&quot;&gt;贴吧客户端&lt;/a&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">        // 通过iframe的方式试图打开APP，如果能正常打开，会直接切换到APP，并自动阻止js其他行为</span><br><span class="line">        </span><br><span class="line">        var ifr = document.createElement(&apos;iframe&apos;);</span><br><span class="line">        ifr.src = &apos;com.baidu.tieba://&apos;;//打开app的协议，有app同事提供</span><br><span class="line">        ifr.style.display = &apos;none&apos;;</span><br><span class="line">        document.body.appendChild(ifr);</span><br><span class="line">        window.setTimeout(function()&#123;</span><br><span class="line">            document.body.removeChild(ifr);</span><br><span class="line">　　　　　　　window.location.href = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;//打开app下载地址，有app同事提供</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>此方法有些浏览器不兼容iframe，可以window.location的方法解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:;&quot; id=&quot;openApp&quot;&gt;贴吧客户端&lt;/a&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">        window.location.href = &quot;com.baidu.tieba://&quot;;</span><br><span class="line">        window.setTimeout(function()&#123;</span><br><span class="line">            window.location.href = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;//打开app下载地址，有app同事提供</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="js判断本地是否安装app"><a href="#js判断本地是否安装app" class="headerlink" title="js判断本地是否安装app"></a><strong>js判断本地是否安装app</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">             document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">                if(navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123;</span><br><span class="line">                var loadDateTime = new Date();</span><br><span class="line">                window.setTimeout(function() &#123;</span><br><span class="line">                        var timeOutDateTime = new Date();</span><br><span class="line">                        if(timeOutDateTime - loadDateTime &lt; 5000) &#123;</span><br><span class="line">                            window.location = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            window.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    25);</span><br><span class="line">                window.location = &quot;weixin:// &quot;;</span><br><span class="line">            &#125; else if(navigator.userAgent.match(/android/i)) &#123;</span><br><span class="line">                var state = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    state = window.open(&quot;weixin://&quot;);</span><br><span class="line">                &#125; catch(e) &#123;&#125;</span><br><span class="line">                if(state) &#123;</span><br><span class="line">                    window.close();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    window.location = &quot;http://dldir1.qq.com/weixin/android/weixin656android1020.apk&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>如果本地安装了app那么直接打开，否则苹果要跳转到app-store，安卓则要跳到对应的市场</p>
<blockquote>
<p>解决方案 一</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//html代码中 的 a 标签，以微信为例，默认的是调用weixin scheme，去打开本机的微信，如果没有则跳转到相应连接</span><br><span class="line">　　　　&lt;a href=&quot;weixin://&quot; class=&quot;btn-download&quot;&gt;立即打开&lt;/a&gt;</span><br><span class="line">　　</span><br><span class="line">　　　　// 为btn-download 绑定事件，如果在500ms内，没有解析到协议，那么就会跳转到下载链接 </span><br><span class="line">　　　　 var appstore, ua = navigator.userAgent;</span><br><span class="line">        if(ua.match(/Android/i))&#123; </span><br><span class="line">            appstore = &apos;market://search?q=com.singtel.travelbuddy.android&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ua.match(/iphone|ipod|ipad/))&#123;</span><br><span class="line">            appstore = &quot;https://itunes.apple.com/cn/app/wei-xin/id414478124?mt=8&amp;ign-mpt=uo%3D4&quot;; </span><br><span class="line">        &#125;</span><br><span class="line">        function applink(fail)&#123;  </span><br><span class="line">            return function()&#123;  </span><br><span class="line">                var clickedAt = +new Date;  </span><br><span class="line">                // During tests on 3g/3gs this timeout fires immediately if less than 500ms.  </span><br><span class="line">                setTimeout(function()&#123;  </span><br><span class="line">                     // To avoid failing on return to MobileSafari, ensure freshness!  </span><br><span class="line">                      if (+new Date - clickedAt &lt; 2000)&#123;  </span><br><span class="line">                          window.location = fail;  </span><br><span class="line">                      &#125;  </span><br><span class="line">                &#125;, 500);      </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;  </span><br><span class="line">        $(&apos;.icon-download, .btn-download&apos;)[0].onclick = applink(appstore);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决方案二 </p>
</blockquote>
<p>通过在页面中生成一个隐藏的iframe，iframe的src指向 app 协议，例如 weixin scheme，并监听onerror事件，意思是如果无法解析协议，就会触发onerror事件，但是我尝试了一下，未果。代码如下，可参考一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 页面中有div#iframe-box 用来插入生成的iframe，还是以微信为例</span><br><span class="line">　　　　 var ifm = document.createElement(&apos;iframe&apos;), isInstalled;</span><br><span class="line">        ifm.style.display = &apos;none&apos;;</span><br><span class="line">        ifm.src = &apos;wixin://&apos;;</span><br><span class="line">        ifm.onload = function(e)&#123;</span><br><span class="line">            var e = e || window.event;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;</span><br><span class="line">        ifm.onerror = function()&#123;</span><br><span class="line">            //isInstalled = false;</span><br><span class="line">            alert(1);</span><br><span class="line">        &#125;</span><br><span class="line">        document.getElementById(&apos;iframe-box&apos;).appendChild(ifm);</span><br><span class="line"></span><br><span class="line">　　　　// 但这时的问题是，iframe的src成功解析到了协议，则会直接跳转，但是解析不到的话，也不会触发error事件，这个还要继续研究</span><br><span class="line">　　　　// 可以把上面的代码，放到函数中，然后作为某个按钮的响应函数。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解决方案三</p>
</blockquote>
<p>对于ios手机，会有如下写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=414478124&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<p>将上面代码放到head中，根据name也会知道意思，app-id是微信的app-id，用ios手机看会看到提示，andriod比可以，结果自行实验。（ios就是强大）</p>
<h1 id="H5唤起客户端通用机方案"><a href="#H5唤起客户端通用机方案" class="headerlink" title="H5唤起客户端通用机方案"></a><strong>H5唤起客户端通用机方案</strong></h1><h4 id="H5唤起客户端"><a href="#H5唤起客户端" class="headerlink" title="H5唤起客户端"></a><a href="https://github.com/suanmei/callapp-lib" target="_blank" rel="noopener">H5唤起客户端</a></h4><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a><strong>6 总结</strong></h1><p>这篇文章主要剖析的 JSBridge 的实现及应用，包括 <strong>JavaScript 与 Native 间的通信原理</strong>，<strong>JSBridge 的 JavaScript 端实现</strong> 以及 <strong>引用方式</strong>，并给出了一些示例代码，希望对读者有一定的帮助。</p>
<h3 id="JSBridge实战"><a href="#JSBridge实战" class="headerlink" title="JSBridge实战"></a><a href="https://juejin.im/post/5bda6f276fb9a0226d18931f" target="_blank" rel="noopener">JSBridge实战</a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/25/CommonJS-AMD-CMD-ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/25/CommonJS-AMD-CMD-ES6/" itemprop="url">CommonJS,AMD,CMD,ES6 </a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-25T21:18:27+08:00">
                2016-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CommonJS,AMD,CMD,ES6</p>
<p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p>
<p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p>
<pre><code>/** AMD写法 **/
define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) { 
     // 等于在最前面声明并初始化了要用到的所有模块
    a.doSomething();
    if (false) {
        // 即便没用到某个模块 b，但 b 还是提前执行了
        b.doSomething()
    } 
});


/** CMD写法 **/
define(function(require, exports, module) {
    var a = require(&apos;./a&apos;); //在需要时申明
    a.doSomething();
    if (false) {
        var b = require(&apos;./b&apos;);
        b.doSomething();
    }
}); 
</code></pre><p>ES6 模块是动态引用:ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p>
<p>ES6 模块与 CommonJS 模块的差异</p>
<ol>
<li><font color="#ff0000">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</font>,<strong>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</strong><br>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li>
<li><font color="#ff0000"> CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</font></li>
<li><font color="#ff0000">运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>编译时加载: ES6模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</font></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/23/Web-安全攻防总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/23/Web-安全攻防总结/" itemprop="url">Web 安全攻防总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-23T20:02:04+08:00">
                2016-10-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Web 安全的对于 Web 从业人员来说是一个非常重要的课题，所以在这里总结一下 Web 相关的安全攻防知识，希望以后不要再踩雷，也希望对看到这篇文章的同学有所帮助。今天这边文章主要的内容就是分析几种常见的攻击的类型以及防御的方法。</p>
<blockquote>
<p>也许你对所有的安全问题都有一定的认识，但最主要的还是在编码设计的过程中时刻绷紧安全那根弦，需要反复推敲每个实现细节，安全无小事。</p>
<p>本文代码 Demo 都是基于 Node.js 讲解，其他服务端语言同样可以参考。</p>
</blockquote>
<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。</p>
<p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。</p>
<h3 id="非持久型-XSS"><a href="#非持久型-XSS" class="headerlink" title="非持久型 XSS"></a>非持久型 XSS</h3><p>非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br><img src="/2016/10/23/Web-安全攻防总结/xss1.jpg" alt="非持久型 XSS"><br>举一个例子，比如你的 Web 页面中包含有以下代码：</p>
<pre><code>&lt;select&gt;
    &lt;script&gt;
        document.write(&apos;&apos;
                + &apos;&lt;optionvalue=1&gt;&apos;
                +     location.href.substring(location.href.indexOf(&apos;default=&apos;) + 8)
                + &apos;&lt;/option&gt;&apos;
            );
            document.write(&apos;&lt;optionvalue=2&gt;English&lt;/option&gt;&apos;);
    &lt;/script&gt;
&lt;/select&gt;
</code></pre><p>攻击者可以直接通过 URL (类似： </p>
<pre><code>https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;
</code></pre><p>注入可执行的脚本代码。</p>
<p>非持久型 XSS 漏洞攻击有以下几点<strong>特征</strong>：</p>
<ul>
<li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li>
<li>攻击者需要诱骗点击</li>
<li>反馈率低，所以较难发现和响应修复</li>
<li>盗取用户敏感保密信息</li>
</ul>
<p>为了<strong>防止出现非持久型 XSS 漏洞</strong>，需要确保这么几件事情：</p>
<ul>
<li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li>
<li>尽量不要从 URL，<code>document.referrer</code>，<code>document.forms</code> 等这种 DOM API 中获取数据直接渲染。</li>
<li>尽量不要使用 <code>eval</code>, <code>new Function()</code>，<code>document.write()</code>，<code>document.writeln()</code>，<code>window.setInterval()</code>，<code>window.setTimeout()</code>，<code>innerHTML</code>，<code>document.creteElement()</code> 等可执行字符串的方法。</li>
<li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li>
<li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li>
</ul>
<blockquote>
<p>escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 <code>&lt;</code>，<code>&gt;</code>，<code>空格</code> 等，转义成 <code>&amp;lt;</code>，<code>&amp;gt;</code>，<code>&amp;nbsp;</code> 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。</p>
</blockquote>
<h3 id="持久型-XSS"><a href="#持久型-XSS" class="headerlink" title="持久型 XSS"></a>持久型 XSS</h3><p>持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p>
<p>主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。攻击成功需要同时满足以下几个条件：</p>
<ul>
<li>POST 请求提交表单后端没做转义直接入库。</li>
<li>后端从数据库中取出数据没做转义直接输出给前端。</li>
<li>前端拿到后端数据没做转义直接渲染成 DOM。</li>
</ul>
<p>持久型 XSS 有以下几个<strong>特点</strong>：</p>
<ul>
<li>持久性，植入在数据库中</li>
<li>危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。</li>
<li>盗取用户敏感私密信息</li>
</ul>
<p>为了<strong>防止持久型 XSS 漏洞</strong>，需要前后端共同努力：</p>
<ul>
<li>后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。</li>
<li>后端在输出给前端数据统一进行转义处理。</li>
<li>前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</li>
</ul>
<h3 id="基于字符集的-XSS"><a href="#基于字符集的-XSS" class="headerlink" title="基于字符集的 XSS"></a>基于字符集的 XSS</h3><p>其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。</p>
<p>以基于 utf-7 的 XSS 为例</p>
<p>utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。</p>
<p>这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。</p>
<pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;
      可以被解释为：
+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4-
</code></pre><p>可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。</p>
<p>所以我们有什么办法避免这种 XSS 呢？</p>
<ul>
<li>记住指定 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></li>
<li>XML 中不仅要指定字符集为 utf-8，而且标签要闭合</li>
<li>牛文推荐：<a href="http://drops.wooyun.org/papers/1327" target="_blank" rel="noopener">http://drops.wooyun.org/papers/1327</a> （这个讲的很详细）</li>
</ul>
<h3 id="基于-Flash-的跨站-XSS"><a href="#基于-Flash-的跨站-XSS" class="headerlink" title="基于 Flash 的跨站 XSS"></a>基于 Flash 的跨站 XSS</h3><p>基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。</p>
<p>避免方法：</p>
<ul>
<li>严格管理 cookie 的读写权限</li>
<li>对 Flash 能接受用户输入的参数进行过滤 escape 转义处理</li>
</ul>
<h3 id="未经验证的跳转-XSS"><a href="#未经验证的跳转-XSS" class="headerlink" title="未经验证的跳转 XSS"></a>未经验证的跳转 XSS</h3><p>有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。</p>
<p>这时候需要通过以下方式来防止这类漏洞：</p>
<ul>
<li>对待跳转的 URL 参数做白名单或者某种规则过滤</li>
<li>后端注意对敏感信息的保护, 比如 cookie 使用来源验证。</li>
</ul>
<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF（Cross-Site Request Forgery），中文名称：跨站请求伪造攻击</p>
<p>那么 CSRF 到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。攻击者只要借助少许的社会工程学的诡计，例如通过 QQ 等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使 Web 应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。</p>
<p>所以遇到 CSRF 攻击时，将对终端用户的数据和操作指令构成严重的威胁。当受攻击的终端用户具有管理员帐户的时候，CSRF 攻击将危及整个 Web 应用程序。</p>
<h3 id="CSRF-原理"><a href="#CSRF-原理" class="headerlink" title="CSRF 原理"></a>CSRF 原理</h3><p>下图大概描述了 CSRF 攻击的原理，可以理解为有一个小偷在你配钥匙的地方得到了你家的钥匙，然后拿着要是去你家想偷什么偷什么。<br><img src="/2016/10/23/Web-安全攻防总结/csrf.jpg" alt="csrf原理"><br>完成 CSRF 攻击必须要有三个条件：</p>
<ol>
<li>用户已经登录了站点 A，并在本地记录了 cookie</li>
<li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。</li>
<li>站点 A 没有做任何 CSRF 防御</li>
</ol>
<p>你也许会问：「如果我不满足以上三个条件中的任意一个，就不会受到 CSRF 的攻击」。其实可以这么说的，但你不能保证以下情况不会发生：</p>
<ul>
<li>你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站，特别现在浏览器都是支持多 tab 的。</li>
<li>你不能保证你关闭浏览器了后，你本地的 cookie 立刻过期，你上次的会话已经结束。</li>
<li>上图中所谓的攻击网站 B，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li>
</ul>
<h3 id="预防-CSRF"><a href="#预防-CSRF" class="headerlink" title="预防 CSRF"></a>预防 CSRF</h3><p>CSRF 的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的 CSRF 防御也都在服务端进行。服务端的预防 CSRF 攻击的方式方法有多种，但思路上都是差不多的，主要从以下两个方面入手：</p>
<ul>
<li>正确使用 GET，POST 请求和 cookie</li>
<li>在非 GET 请求中增加 token</li>
</ul>
<p>一般而言，普通的 Web 应用都是以 GET、POST 请求为主，还有一种请求是 cookie 方式。我们一般都是按照如下规则设计应用的请求：</p>
<ul>
<li>GET 请求常用在查看，列举，展示等不需要改变资源属性的时候（数据库 query 查询的时候）</li>
<li>POST 请求常用在 From 表单提交，改变一个资源的属性或者做其他一些事情的时候（数据库有 insert、update、delete 的时候）</li>
</ul>
<p>当正确的使用了 GET 和 POST 请求之后，剩下的就是在非 GET 方式的请求中增加随机数，这个大概有三种方式来进行：</p>
<ul>
<li><p><strong>为每个用户生成一个唯一的 cookie token</strong>，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的 cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。</p>
</li>
<li><p><strong>每个 POST 请求使用验证码</strong>，这个方案算是比较完美的，但是需要用户多次输入验证码，用户体验比较差，所以不适合在业务中大量运用。</p>
</li>
<li><p><strong>渲染表单的时候，为每一个表单包含一个 csrfToken</strong>，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。</p>
</li>
</ul>
<p>CSRF 的防御可以根据应用场景的不同自行选择。CSRF 的防御工作确实会在正常业务逻辑的基础上带来很多额外的开发量，但是这种工作量是值得的，毕竟用户隐私以及财产安全是产品最基础的根本。</p>
<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p>
<p>而造成 SQL 注入的原因是因为程序没有有效的转义过滤用户的输入，使攻击者成功的向服务器提交恶意的 SQL 查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p>
<p>很多 Web 开发者没有意识到 SQL 查询是可以被篡改的，从而把 SQL 查询当作可信任的命令。殊不知，SQL 查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过 SQL 查询去运行主机系统级的命令。</p>
<h3 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a>SQL 注入原理</h3><p>下面将通过一些真实的例子来详细讲解 SQL 注入的方式的原理。</p>
<p>考虑以下简单的管理员登录表单：</p>
<pre><code>&lt;formaction=&quot;/login&quot;method=&quot;POST&quot;&gt;
&lt;p&gt;Username: &lt;inputtype=&quot;text&quot;name=&quot;username&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Password: &lt;inputtype=&quot;password&quot;name=&quot;password&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;inputtype=&quot;submit&quot;value=&quot;登陆&quot; /&gt;&lt;/p&gt;
&lt;/form&gt;
</code></pre><p>后端的 SQL 语句可能是如下这样的：</p>
<pre><code>let querySQL = `
    SELECT *
    FROM user
    WHERE username=&apos;${username}&apos;
    AND psw=&apos;${password}&apos;
`;
// 接下来就是执行 sql 语句...
</code></pre><p>目的就是来验证用户名和密码是不是正确，按理说乍一看上面的 SQL 语句也没什么毛病，确实是能够达到我们的目的，可是你只是站在用户会老老实实按照你的设计来输入的角度来看问题，如果有一个恶意攻击者输入的用户名是 <code>zoumiaojiang&#39; OR 1 = 1 --</code>，密码随意输入，就可以直接登入系统了。WFT!</p>
<p>冷静下来思考一下，我们之前预想的真实 SQL 语句是:</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;AND psw=&apos;mypassword&apos;
</code></pre><p>可以恶意攻击者的奇怪用户名将你的 SQL 语句变成了如下形式：</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1--&apos; AND psw=&apos;xxxx&apos;
</code></pre><p>在 SQL 中，<code>--</code> 是注释后面的内容的意思，所以查询语句就变成了：</p>
<pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1
</code></pre><p>这条 SQL 语句的查询条件永远为真，所以意思就是恶意攻击者不用我的密码，就可以登录进我的账号，然后可以在里面为所欲为，然而这还只是最简单的注入，牛逼的 SQL 注入高手甚至可以通过 SQL 查询去运行主机系统级的命令，将你主机里的内容一览无余，这里我也没有这个能力讲解的太深入，毕竟不是专业研究这类攻击的，但是通过以上的例子，已经了解了 SQL 注入的原理，我们基本已经能找到防御 SQL 注入的方案了。</p>
<h3 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h3><p>防止 SQL 注入主要是不能允许用户输入的内容影响正常的 SQL 语句的逻辑，当用户的输入的信息将要用来拼接 SQL 语句的话，我们应该永远选择不相信，任何内容都必须进行转义过滤，当然做到这个还是不够的，下面列出防御 SQL 注入的几点注意事项：</p>
<ul>
<li><p><strong>严格限制Web应用的数据库的操作权限</strong>，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p>
</li>
<li><p><strong>后端代码检查输入的数据是否符合预期</strong>，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>
</li>
<li><p><strong>对进入数据库的特殊字符（<code>&#39;</code>，<code>&quot;</code>，<code>\</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&amp;</code>，<code>*</code>，<code>;</code> 等）进行转义处理</strong>，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 <code>lodash._escapehtmlchar</code> 库。</p>
</li>
<li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口</strong>，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 <code>query</code> 方法中的 <code>?</code> 占位参数。</p>
</li>
</ul>
<pre><code>mysql.query(`SELECT * FROM user WHERE username = ? AND psw = ?`, [username, psw]);
</code></pre><ul>
<li><p><strong>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测</strong>，以及时修补被发现的 SQL 注入漏洞。网上有很多这方面的开源工具，例如 sqlmap、SQLninja 等。</p>
</li>
<li><p><strong>避免网站打印出 SQL 错误信息</strong>，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。</p>
</li>
<li><p><strong>不要过于细化返回的错误信息</strong>，如果目的是方便调试，就去使用后端日志，不要在接口上过多的暴露出错信息，毕竟真正的用户不关心太多的技术细节，只要话术合理就行。</p>
</li>
</ul>
<p>碰到要操作的数据库的代码，一定要慎重，小心使得万年船，多找几个人多来几次 code review，将问题都暴露出来，而且要善于利用工具，操作数据库相关的代码属于机密，没事不要去各种论坛晒自家站点的 SQL 语句，万一被人盯上了呢？</p>
<h2 id="命令行注入"><a href="#命令行注入" class="headerlink" title="命令行注入"></a>命令行注入</h2><p>命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令，听起来好像匪夷所思，这往往是 Web 开发者最容易忽视但是却是最危险的一个漏洞之一，看一个实例：</p>
<p>假如现在需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去产出一个结果返回给用户，接口的部分实现如下：</p>
<pre><code>// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo
const exec = require(&apos;mz/child_process&apos;).exec;
let params = {/* 用户输入的参数 */};

exec(`git clone ${params.repo} /some/path`);
</code></pre><p>这段代码确实能够满足业务需求，正常的用户也确实能从指定的 git repo 上下载到想要的代码，可是和 SQL 注入一样，这段代码在恶意攻击者眼中，简直就是香饽饽。</p>
<p>如果 <code>params.repo</code> 传入的是 <code>https://github.com/zoumiaojiang/zoumiaojiang.github.io.git</code> 当然没问题了。</p>
<p>可是如果 <code>params.repo</code> 传入的是 <code>https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;</code> 恰好你的服务是用 root 权限起的就惨了。</p>
<p>具体恶意攻击者能用命令行注入干什么也像 SQL 注入一样，手法是千变万化的，比如「<a href="http://wiki.bash-hackers.org/howto/redirection_tutorial" target="_blank" rel="noopener">反弹 shell 注入</a>」等，但原理都是一样的，我们绝对有能力防止命令行注入发生。防止命令行注入需要做到以下几件事情：</p>
<ul>
<li>后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。</li>
<li>在调用系统命令前对所有传入参数进行命令行参数转义过滤。</li>
<li>不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 <code>shell-escape</code> npm 包。</li>
</ul>
<p>还是前面的例子，我们可以做到如下：</p>
<pre><code>const exec = require(&apos;mz/child_process&apos;).exec;

// 借助 shell-escape npm 包解决参数转义过滤问题
const shellescape = require(&apos;shell-escape&apos;);

let params = {/* 用户输入的参数 */};

// 先过滤一下参数，让参数符合预期
if (!/正确的表达式/.test(params.repo)) {
return;
}

let cmd = shellescape([
&apos;git&apos;,
&apos;clone&apos;,
    params.repo,
&apos;/some/path&apos;
]);

// cmd 的值: git clone &apos;https://github.com/xx/xx.git &amp;&amp; rm -rf / &amp;&amp;&apos; /some/path
// 这样就不会被注入成功了。
exec(cmd);
</code></pre><blockquote>
<p>无论是在何种后端语言环境中，凡是涉及到代码调用系统 shell 命令的时候都一定要谨慎。</p>
</blockquote>
<h2 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h2><p>DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用，这个攻击应该不能算是安全问题，这应该算是一个另类的存在，因为这种攻击根本就是耍流氓的存在，「伤敌一千，自损八百」的行为。出于保护 Web App 不受攻击的攻防角度，还是介绍一下 DDoS 攻击吧，毕竟也是挺常见的。</p>
<p>DDoS 攻击可以理解为：「你开了一家店，隔壁家点看不惯，就雇了一大堆黑社会人员进你店里干坐着，也不消费，其他客人也进不来，导致你营业惨淡」。为啥说 DDoS 是个「伤敌一千，自损八百」的行为呢？毕竟隔壁店还是花了不少钱雇黑社会但是啥也没得到不是？DDoS 攻击的目的基本上就以下几个：</p>
<ul>
<li>深仇大恨，就是要干死你</li>
<li>敲诈你，不给钱就干你</li>
<li>忽悠你，不买我防火墙服务就会有“人”继续干你</li>
</ul>
<p>也许你的站点遭受过 DDoS 攻击，具体什么原因怎么解读见仁见智。DDos 攻击从层次上可分为网络层攻击与应用层攻击，从攻击手法上可分为快型流量攻击与慢型流量攻击，但其原理都是造成资源过载，导致服务不可用。</p>
<h3 id="网络层-DDoS"><a href="#网络层-DDoS" class="headerlink" title="网络层 DDoS"></a>网络层 DDoS</h3><p>网络层 DDos 攻击包括 <code>SYN Flood</code>、<code>ACK Flood</code>、<code>UDP Flood</code>、<code>ICMP Flood</code> 等。</p>
<p><strong>SYN Flood 攻击</strong></p>
<p>SYN flood 攻击主要利用了 TCP 三次握手过程中的 Bug，我们都知道 TCP 三次握手过程是要建立连接的双方发送 SYN，SYN + ACK，ACK 数据包，而当攻击方随意构造源 IP 去发送 SYN 包时，服务器返回的 SYN + ACK 就不能得到应答（因为 IP 是随意构造的），此时服务器就会尝试重新发送，并且会有至少 30s 的等待时间，导致资源饱和服务不可用，此攻击属于慢型 DDoS 攻击。</p>
<p><strong>ACK Flood 攻击</strong></p>
<p>ACK Flood 攻击是在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。</p>
<p><strong>UDP Flood 攻击</strong></p>
<p>UDP flood 攻击是由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。</p>
<p><strong>ICMP Flood 攻击</strong></p>
<p>ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。</p>
<h3 id="网络层-DDoS-防御"><a href="#网络层-DDoS-防御" class="headerlink" title="网络层 DDoS 防御"></a>网络层 DDoS 防御</h3><p>网络层的 DDoS 攻击究其本质其实是无法防御的，我们能做得就是不断优化服务本身部署的网络架构，以及提升网络带宽。当然，还是做好以下几件事也是有助于缓解网络层 DDoS 攻击的冲击：</p>
<ul>
<li>网络架构上做好优化，采用负载均衡分流。</li>
<li>确保服务器的系统文件是最新的版本，并及时更新系统补丁。</li>
<li>添加抗 DDos 设备，进行流量清洗。</li>
<li>限制同时打开的 SYN 半连接数目，缩短 SYN 半连接的 Timeout 时间。</li>
<li>限制单 IP 请求频率。</li>
<li>防火墙等防护设置禁止 ICMP 包等。</li>
<li>严格限制对外开放的服务器的向外访问。</li>
<li>运行端口映射程序或端口扫描程序，要认真检查特权端口和非特权端口。</li>
<li>关闭不必要的服务。</li>
<li>认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更,那这台机器就可能遭到了攻击。</li>
<li>限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。</li>
<li>加钱堆机器。。</li>
<li>报警。。</li>
</ul>
<h3 id="应用层-DDoS"><a href="#应用层-DDoS" class="headerlink" title="应用层 DDoS"></a>应用层 DDoS</h3><p>应用层 DDoS 攻击不是发生在网络层，是发生在 TCP 建立握手成功之后，应用程序处理请求的时候，现在很多常见的 DDoS 攻击都是应用层攻击。应用层攻击千变万化，目的就是在网络应用层耗尽你的带宽，下面列出集中典型的攻击类型。</p>
<p><strong>CC 攻击</strong></p>
<p>当时绿盟为了防御 DDoS 攻击研发了一款叫做 <code>Collapasar</code> 的产品，能够有效的防御 SYN Flood 攻击。黑客为了挑衅，研发了一款 <code>Challenge Collapasar</code> 攻击工具（简称 CC）。</p>
<p>CC 攻击的原理，就是针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。因此在发送 CC 攻击前，我们需要寻找加载比较慢，消耗资源比较多的网页，比如需要查询数据库的页面、读写硬盘文件的等。通过 CC 攻击，使用爬虫对某些加载需要消耗大量资源的页面发起 HTTP 请求。</p>
<p><strong>DNS Flood</strong></p>
<p>DNS Flood 攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名，被攻击的DNS 服务器在接收到域名解析请求的时候首先会在服务器上查找是否有对应的缓存，如果查找不到并且该域名无法直接由服务器解析的时候，DNS 服务器会向其上层 DNS 服务器递归查询域名信息。域名解析的过程给服务器带来了很大的负载，每秒钟域名解析请求超过一定的数量就会造成 DNS 服务器解析域名超时。</p>
<p>根据微软的统计数据，一台 DNS 服务器所能承受的动态域名查询的上限是每秒钟 9000 个请求。而我们知道，在一台 P3 的 PC 机上可以轻易地构造出每秒钟几万个域名解析请求，足以使一台硬件配置极高的 DNS 服务器瘫痪，由此可见 DNS 服务器的脆弱性。</p>
<p><strong>HTTP 慢速连接攻击</strong></p>
<p>针对 HTTP 协议，先建立起 HTTP 连接，设置一个较大的 Conetnt-Length，每次只发送很少的字节，让服务器一直以为 HTTP 头部没有传输完成，这样连接一多就很快会出现连接耗尽。</p>
<h3 id="应用层-DDoS-防御"><a href="#应用层-DDoS-防御" class="headerlink" title="应用层 DDoS 防御"></a>应用层 DDoS 防御</h3><ul>
<li>判断 User-Agent 字段（不可靠，因为可以随意构造）</li>
<li>针对 IP + cookie，限制访问频率（由于 cookie 可以更改，IP 可以使用代理，或者肉鸡，也不可靠)</li>
<li>关闭服务器最大连接数等，合理配置中间件，缓解 DDoS 攻击。</li>
<li>请求中添加验证码，比如请求中有数据库操作的时候。</li>
<li>编写代码时，尽量实现优化，并合理使用缓存技术，减少数据库的读取操作。</li>
<li>加钱堆机器。。</li>
<li>报警。。</li>
</ul>
<p>应用层的防御有时比网络层的更难，因为导致应用层被 DDoS 攻击的因素非常多，有时往往是因为程序员的失误，导致某个页面加载需要消耗大量资源，有时是因为中间件配置不当等等。而应用层 DDoS 防御的核心就是区分人与机器（爬虫），因为大量的请求不可能是人为的，肯定是机器构造的。因此如果能有效的区分人与爬虫行为，则可以很好地防御此攻击。</p>
<h3 id="其他-DDoS-攻击"><a href="#其他-DDoS-攻击" class="headerlink" title="其他 DDoS 攻击"></a>其他 DDoS 攻击</h3><p>发起 DDoS 也是需要大量的带宽资源的，但是互联网就像森林，林子大了什么鸟都有，DDoS 攻击者也能找到其他的方式发起廉价并且极具杀伤力的 DDoS 攻击。</p>
<p><strong>利用 XSS</strong></p>
<p>举个例子，如果 12306 页面有一个 XSS 持久型漏洞被恶意攻击者发现，只需在春节抢票期间在这个漏洞中执行脚本使得往某一个小站点随便发点什么请求，然后随着用户访问的增多，感染用户增多，被攻击的站点自然就会迅速瘫痪了。这种 DDoS 简直就是无本万利，不用惊讶，现在大站有 XSS 漏洞的不要太多。</p>
<p><strong>来自 P2P 网络攻击</strong></p>
<p>大家都知道，互联网上的 P2P 用户和流量都是一个极为庞大的数字。如果他们都去一个指定的地方下载数据，成千上万的真实 IP 地址连接过来，没有哪个设备能够支撑住。拿 BT 下载来说，伪造一些热门视频的种子，发布到搜索引擎，就足以骗到许多用户和流量了，但是这只是基础攻击。</p>
<p>高级的 P2P 攻击，是直接欺骗资源管理服务器。如迅雷客户端会把自己发现的资源上传到资源管理服务器，然后推送给其它需要下载相同资源的用户，这样，一个链接就发布出去。通过协议逆向，攻击者伪造出大批量的热门资源信息通过资源管理中心分发出去，瞬间就可以传遍整个 P2P 网络。更为恐怖的是，这种攻击是无法停止的，即使是攻击者自身也无法停止，攻击一直持续到 P2P 官方发现问题更新服务器且下载用户重启下载软件为止。</p>
<blockquote>
<p>最后总结下，DDoS 不可能防的住，就好比你的店只能容纳 50 人，黑社会有 100 人，你就换一家大店，能容纳 500 人，然后黑社会又找来了 1000 人，这种堆人头的做法就是 DDoS 本质上的攻防之道，「道高一尺，魔高一丈，魔高一尺，道高一丈」，讲真，必要的时候就答应勒索你的人的条件吧，实在不行就报警吧。</p>
</blockquote>
<h2 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h2><p>流量劫持应该算是黑产行业的一大经济支柱了吧？简直是让人恶心到吐，不吐槽了，还是继续谈干货吧，流量劫持基本分两种：<code>DNS 劫持</code> 和 <code>HTTP 劫持</code>，目的都是一样的，就是当用户访问 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 的时候，给你展示的并不是或者不完全是 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 提供的 “内容”。</p>
<h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持，也叫做域名劫持，可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了</strong>」，DNS 的作用是把网络地址域名对应到真实的计算机能够识别的 IP 地址，以便计算机能够进一步通信，传递网址和内容等。如果当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。<br><img src="/2016/10/23/Web-安全攻防总结/dns.jpg" alt="dns劫持"><br>这类劫持，要不就是网络运营商搞的鬼，一般小的网络运营商与黑产勾结会劫持 DNS，要不就是电脑中毒，被恶意篡改了路由器的 DNS 配置，基本上做为开发者或站长却是很难察觉的，除非有用户反馈，现在升级版的 DNS 劫持还可以对特定用户、特定区域等使用了用户画像进行筛选用户劫持的办法，另外这类广告显示更加随机更小，一般站长除非用户投诉否则很难觉察到，就算觉察到了取证举报更难。无论如何，如果接到有 DNS 劫持的反馈，一定要做好以下几件事：</p>
<ul>
<li>取证很重要，时间、地点、IP、拨号账户、截屏、URL 地址等一定要有。</li>
<li>可以跟劫持区域的电信运营商进行投诉反馈。</li>
<li>如果投诉反馈无效，直接去工信部投诉，一般来说会加白你的域名。</li>
</ul>
<h3 id="HTTP-劫持"><a href="#HTTP-劫持" class="headerlink" title="HTTP 劫持"></a>HTTP 劫持</h3><p>HTTP 劫持您可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告</strong>」，HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面，轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私。能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。</p>
<p>HTTPS 协议就是一种基于 SSL 协议的安全加密网络应用层协议，可以很好的防止 HTTP 劫持。这里有篇 <a href="https://www.jianshu.com/p/13a1b955d095" target="_blank" rel="noopener">文章</a> 讲的不错。HTTPS 在这就不深讲了，后面有机会我会单独好好讲讲 HTTPS。如果不想站点被 HTTP 劫持，赶紧将你的站点全站改造成 HTTPS 吧。</p>
<h2 id="服务器漏洞"><a href="#服务器漏洞" class="headerlink" title="服务器漏洞"></a>服务器漏洞</h2><p>服务器除了以上提到的那些大名鼎鼎的漏洞和臭名昭著的攻击以外，其实还有很多其他的漏洞，往往也很容易被忽视，在这个小节也稍微介绍几种。</p>
<h3 id="越权操作漏洞"><a href="#越权操作漏洞" class="headerlink" title="越权操作漏洞"></a>越权操作漏洞</h3><p>如果你的系统是有登录控制的，那就要格外小心了，因为很有可能你的系统越权操作漏洞，越权操作漏洞可以简单的总结为 「<strong>A 用户能看到或者操作 B 用户的隐私内容</strong>」，如果你的系统中还有权限控制就更加需要小心了。所以每一个请求都需要做 userid 的判断</p>
<p>以下是一段有漏洞的后端示意代码：</p>
<pre><code>// ctx 为请求的 context 上下文
let msgId = ctx.params.msgId;

mysql.query(
&apos;SELECT * FROM msg_table WHERE msg_id = ?&apos;,
    [msgId]
);
</code></pre><p>以上代码是任何人都可以查询到任何用户的消息，只要有 msg_id 就可以，这就是比较典型的越权漏洞，需要如下这么改进一下：</p>
<pre><code>// ctx 为请求的 context 上下文
let msgId = ctx.params.msgId;
let userId = ctx.session.userId; // 从会话中取出当前登陆的 userId

mysql.query(
&apos;SELECT * FROM msg_table WHERE msg_id = ? AND user_id = ?&apos;,
    [msgId, userId]
);
</code></pre><p>嗯，大概就是这个意思，如果有更严格的权限控制，那在每个请求中凡是涉及到数据库的操作都需要先进行严格的验证，并且在设计数据库表的时候需要考虑进 userId 的账号关联以及权限关联。</p>
<h3 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h3><p>目录遍历漏洞指通过在 URL 或参数中构造 <code>../</code>，<code>./</code> 和类似的跨父目录字符串的 ASCII 编码、unicode 编码等，完成目录跳转，读取操作系统各个目录下的敏感文件，也可以称作「任意文件读取漏洞」。</p>
<p>目录遍历漏洞原理：程序没有充分过滤用户输入的 <code>../</code> 之类的目录跳转符，导致用户可以通过提交目录跳转来遍历服务器上的任意文件。使用多个<code>..</code> 符号，不断向上跳转，最终停留在根 <code>/</code>，通过绝对路径去读取任意文件。</p>
<p>目录遍历漏洞几个示例和测试，一般构造 URL 然后使用浏览器直接访问，或者使用 Web 漏洞扫描工具检测，当然也可以自写程序测试。</p>
<pre><code>http://somehost.com/../../../../../../../../../etc/passwd
http://somehost.com/some/path?file=../../Windows/system.ini

# 借助 %00 空字符截断是一个比较经典的攻击手法
http://somehost.com/some/path?file=../../Windows/system.ini%00.js

# 使用了 IIS 的脚本目录来移动目录并执行指令
http://somehost.com/scripts/..%5c../Windows/System32/cmd.exe?/c+dir+c:\
</code></pre><p><strong>防御</strong> 方法就是需要对 URL 或者参数进行 <code>../</code>，<code>./</code> 等字符的转义过滤。</p>
<h3 id="物理路径泄漏"><a href="#物理路径泄漏" class="headerlink" title="物理路径泄漏"></a>物理路径泄漏</h3><p>物理路径泄露属于低风险等级缺陷，它的危害一般被描述为「攻击者可以利用此漏洞得到信息，来对系统进一步地攻击」，通常都是系统报错 500 的错误信息直接返回到页面可见导致的漏洞。得到物理路径有些时候它能给攻击者带来一些有用的信息，比如说：可以大致了解系统的文件目录结构；可以看出系统所使用的第三方软件；也说不定会得到一个合法的用户名（因为很多人把自己的用户名作为网站的目录名）。</p>
<p>防止这种泄漏的方法就是做好后端程序的出错处理，定制特殊的 500 报错页面。</p>
<h3 id="源码暴露漏洞"><a href="#源码暴露漏洞" class="headerlink" title="源码暴露漏洞"></a>源码暴露漏洞</h3><p>和物理路径泄露类似，就是攻击者可以通过请求直接获取到你站点的后端源代码，然后就可以对系统进一步研究攻击。那么导致源代码暴露的原因是什么呢？基本上就是发生在服务器配置上了，服务器可以设置哪些路径的文件才可以被直接访问的，这里给一个 koa 服务起的例子，正常的 koa 服务器可以通过 koa-static 中间件去指定静态资源的目录，好让静态资源可以通过路径的路由访问。比如你的系统源代码目录是这样的：</p>
<pre><code>|- project
    |- src
    |- static
    |- ...
|- server.js
</code></pre><p>你想要将 static 的文件夹配成静态资源目录，你应该会在 <code>server.js</code> 做如下配置：</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const serve = require(&apos;koa-static&apos;);
const app = new Koa();

app.use(serve(__dirname + &apos;/project/static&apos;));
</code></pre><p>但是如果配错了静态资源的目录，可能就出大事了，比如：</p>
<pre><code>// ...
app.use(serve(__dirname + &apos;/project&apos;));
</code></pre><p>这样所有的源代码都可以通过路由访问到了，所有的服务器都提供了静态资源机制，所以在通过服务器配置静态资源目录和路径的时候，一定要注意检验，不然很可能产生漏洞。</p>
<p>最后，希望 Web 开发者们能够管理好自己的代码隐私，注意代码安全问题，比如不要将产品的含有敏感信息的代码放到第三方外部站点或者暴露给外部用户，尤其是前端代码，私钥类似的保密性的东西不要直接输出在代码里或者页面中。也许还有很多值得注意的点，但是归根结底还是绷住安全那根弦，对待每一行代码都要多多推敲。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/10/a-1-a-2-a-3-有可能是-true-吗？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/10/a-1-a-2-a-3-有可能是-true-吗？/" itemprop="url">(a ==1 && a== 2 && a==3) 有可能是 true 吗？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-10T12:20:50+08:00">
                2016-10-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一个有趣的问题："><a href="#一个有趣的问题：" class="headerlink" title="一个有趣的问题："></a>一个有趣的问题：</h2><p><strong>在 JavaScript 中， <code>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3)</code> 是否有可能为 <code>true</code> ？</strong></p>
<p>这是一道我被某科技公司问到的面试题。发生在两周之前，我仍然在努力寻找答案。</p>
<p>我知道我们从来不会在日常工作中写出这样的代码，但我对问题的答案仍然十分很好奇。</p>
<h2 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h2><p>利用松散相等运算符 <code>==</code> 的工作原理，你可以简单地创建一个带有自定义<code>toString</code>( 或者 <code>valueOf</code>)函数的对象，在每一次使用它时候改变它所的返回值，使其满足所有三个条件。</p>
<pre><code>const a = {

i: 1,

toString: function () {

return a.i++;

  }

}

if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {

console.log(&apos;Hello World!&apos;);

}

// Hello World!
</code></pre><blockquote>
<p>之所以会得到如此结果，是由于表达式中使用了松散相等的运算符 <code>==</code>。使用松散相等时，如果其中一个操作数与另一个类型不同，则 JS 引擎将尝试将一个操作转换为另一个类型。在左边对象、右边的数字的情况下，它会尝试将对象转换为一个数，首先通过调用 <code>valueOf</code> 如果是可调用的。否则，它会调用<code>toString</code>方法。我使用<code>toString</code>仅仅是因为它是我的第一反应，<code>valueOf</code> 会更合理。如果我不从<code>toString</code>返回一个字符串（而是返回数字），JS 引擎会尝试将字符串转换为一个数字，虽然有一个稍长的路径，但它仍然会给我们同样的结果。</p>
</blockquote>
<h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>我不可否认——其他答案无疑是正确的，但你真的不能过错下面的代码：</p>
<pre><code>var aﾠ = 1;

var a = 2;

var ﾠa = 3;

if(aﾠ==1 &amp;&amp; a== 2 &amp;&amp;ﾠa==3) {

console.log(&quot;Why hello there!&quot;)

}
</code></pre><p>请注意<code>if</code> 语句中的奇怪间距。它是半宽度韩文=,=。这是一个 Unicode 空格字符，但是 ECMAScript 不将其解释为一个空格 —— 这意味着它是一个有效的标识符。因此有三个完全不同的变量，一个是<code>a</code>后加半宽度韩文，一个是<code>a</code>， 一个是<code>a</code>前加半宽度韩文。。。</p>
<p>用下划线 <code>_</code> 替代半宽度韩文，增加可读性，相同的代码看起来像这样：</p>
<pre><code>var a_ = 1;

var a = 2;

var _a = 3;

if(a_==1 &amp;&amp; a== 2 &amp;&amp;_a==3) {

console.log(&quot;Why hello there!&quot;)

}
</code></pre><h2 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h2><p>这是完全可能的！</p>
<pre><code>var val = 0;

Object.defineProperty(window, &apos;a&apos;, {

   get: function() {

        return ++val;

  }

});

if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {

    console.log(&apos;yay&apos;);

}
</code></pre><blockquote>
<p>使用一个<code>get</code>，让 <code>a</code> 的返回值为三个不同的值。然而这并不意味着我们应该在真正的代码中使用。。。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/01/JS正则表达式Regex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/01/JS正则表达式Regex/" itemprop="url">JS正则表达式Regex</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-01T21:56:19+08:00">
                2016-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>名余曰正则兮，字余曰灵均。</p>
</blockquote>
<p><code>Regular Expressions</code>翻译成中文叫正则表达式。也不知道是谁翻译过来的，听起来就很严肃。似乎翻译成<code>通用表达式</code>更能传达其精髓，如果你不怕梦见屈原的话。</p>
<p>为什么叫通用表达式？因为它有一套和编程语言无关的文本匹配规则。很多语言都实现了正则表达式的文本匹配引擎，只不过在功能集合上略有不同。</p>
<p>我们要记住的是三点：</p>
<p>其一，正则表达式是用来提取文本的。</p>
<p>其二，正则表达式的表达能力强大到令人发指。</p>
<p>其三，正则表达式的语法对初学者不友好。</p>
<p>另外，本专题只涉及JavaScript语言的正则表达式，其他语言的规则可能略有不同。</p>
<p>我还为各位读者准备了一副宣传语，应该能让你心动(点赞)吧？</p>
<blockquote>
<p>学一门前端工具，几年就过时了。学正则表达式，受用一辈子。</p>
</blockquote>
<h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>什么叫普通字符？</p>
<p>当我们写<code>a</code>的时候，我们指的就是<code>a</code>；当我们写<code>爱</code>的时候，我们指的就是<code>爱</code>。</p>
<pre><code>&apos;hello 😀 regex&apos;.match(/😀/);
// [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined]复制代码
</code></pre><p>这就是普通字符，它在正则中的含义就是检索它本身。除了正则规定的部分字符外，其余的都是普通字符，包括各种人类语言，包括emoji，只要能够表达为字符串。</p>
<h2 id="开始与结束"><a href="#开始与结束" class="headerlink" title="开始与结束"></a>开始与结束</h2><p><code>^</code>字符的英文是<code>caret</code>，翻译成中文是<code>脱字符</code>。不要问我，又不是我翻译的。它在正则中属于元字符，通常代表的意义是文本的开始。说通常是因为当它在字符组中<code>[^abc]</code>另有含义。</p>
<p>什么叫文本的开始？就是如果它是正则主体的第一个符号，那紧跟着它的字符必须是被匹配文本的第一个字符。</p>
<pre><code>&apos;regex&apos;.match(/^r/);
// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p>问题来了，如果<code>^</code>不是正则的第一个符号呢？</p>
<pre><code>&apos;regex&apos;.match(/a^r/);
// null复制代码
</code></pre><p>所以呀，关于它有三点需要注意：</p>
<ul>
<li>作为匹配文本开始元字符的时候必须是正则主体的第一个符号，否则正则无效。</li>
<li>它匹配的是一个位置，而不是具体的文本。</li>
<li>它在其他规则中有另外的含义。</li>
</ul>
<p><code>$</code>字符与<code>^</code>正好相反。它代表文本的结束，并且没有其他含义(其实是有的，但不是在正则主体内)。同样，它必须是正则主体的最后一个符号。</p>
<pre><code>&apos;regex&apos;.match(/x$/);
// [&quot;x&quot;, index: 4, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p><code>^</code>与<code>$</code>特殊的地方在于它匹配的是一个位置。位置不像字符，它看不见，所以更不容易理解。</p>
<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>我们现在已经知道<code>$</code>匹配文本的结束位置，它是元字符。但是如果我想匹配<code>$</code>本身呢？匹配一个美元符号的需求再常见不过了吧。所以我们得将它贬为庶民。</p>
<p><code>\</code>反斜杠就是干这个的。</p>
<pre><code>&apos;price: $3.6&apos;.match(/\$[0-9]+\.[0-9]+$/);
// [&quot;$3.6&quot;, index: 7, input: &quot;price: $3.6&quot;, groups: undefined]复制代码
</code></pre><p>上面的例子有点超纲了，超纲的部分先不管。</p>
<p>你可以认为<code>\</code>也是一个元字符，它跟在另一个元字符后面，就能还原它本来的含义。</p>
<p>如果有两个<code>\</code>呢？那就是转义自身了。如果有三个<code>\</code>呢？我们得分成两段去理解。以此类推。</p>
<p>普通字符前面跟了一个<code>\</code>是什么效果？首先它们是一个整体，然后普通字符转义后还是普通字符。</p>
<h2 id="带反斜杠的元字符"><a href="#带反斜杠的元字符" class="headerlink" title="带反斜杠的元字符"></a>带反斜杠的元字符</h2><p>一般来说，普通字符前面带反斜杠还是普通字符，但是有一些普通字符，带反斜杠后反而变成了元字符。</p>
<p>要怪只能怪计算机领域的常用符号太少了。<br>元字符含义\b匹配一个单词边界(boundary)\B匹配一个非单词边界\d匹配一个数字字符(digit)\D匹配一个非数字字符\s匹配一个空白字符(space)\S匹配一个非空白字符\w匹配一个字母或者一个数字或者一个下划线(word)\W匹配一个字母、数字和下划线之外的字符<br>你这么聪明，肯定一眼就看出来，大写代表反义。对，就是这么好记。</p>
<h4 id="b元字符"><a href="#b元字符" class="headerlink" title="\b元字符"></a>\b元字符</h4><p><code>\b</code>匹配的也是一个位置，而不是一个字符。单词和空格之间的位置，就是所谓单词边界。</p>
<pre><code>&apos;hello regex&apos;.match(/\bregex$/);
// [&quot;regex&quot;, index: 6, input: &quot;hello regex&quot;, groups: undefined]&apos;hello regex&apos;.match(/\Bregex$/);
// null复制代码
</code></pre><p>所谓单词边界，对中文等其他语言是无效的。</p>
<pre><code>&apos;jiangshuying gaoyuanyuan huosiyan&apos;.match(/\bgaoyuanyuan\b/);
// [&quot;gaoyuanyuan&quot;, index: 13, input: &quot;jiangshuying gaoyuanyuan huosiyan&quot;, groups: undefined]&apos;江疏影 高圆圆 霍思燕&apos;.match(/\b高圆圆\b/);
// null复制代码
</code></pre><p>所以<code>\b</code>翻译一下就是<code>^\w|\w$|\W\w|\w\W</code>。</p>
<h4 id="d元字符"><a href="#d元字符" class="headerlink" title="\d元字符"></a>\d元字符</h4><p><code>\d</code>匹配一个数字，注意，这里的数字不是指JavaScript中的数字类型，因为文本全是字符串。它指的是代表数字的字符。</p>
<pre><code>&apos;123&apos;.match(/\d/);
// [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined]复制代码
</code></pre><h4 id="s元字符"><a href="#s元字符" class="headerlink" title="\s元字符"></a>\s元字符</h4><p><code>\s</code>匹配一个空白字符。</p>
<p>这里需要解释一下什么是空白字符。</p>
<p>空白字符不是空格，它是空格的超集。很多人说它是<code>\f\n\r\t\v</code>的总和，其中<code>\f</code>是换页符，<code>\n</code>是换行符，<code>\r</code>是回车符，<code>\t</code>是水平制表符，<code>\v</code>是垂直制表符。是这样么？</p>
<pre><code>&apos;a b&apos;.match(/\w\s\w/);
// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]&apos;a b&apos;.match(/\w\f\w/);
// null&apos;a b&apos;.match(/\w\n\w/);
// null&apos;a b&apos;.match(/\w\r\w/);
// null&apos;a b&apos;.match(/\w\t\w/);
// null&apos;a b&apos;.match(/\w\v\w/);
// null&apos;a b&apos;.match(/\w \w/);
// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]复制代码
</code></pre><p>这样说的人，明显是没有做过实验。其实正确的写法是<code>空格\f\n\r\t\v</code>的总和，集合里面包含一个空格，可千万别忽略了。诶，难道空格在正则中的写法就是<code>空一格</code>么，是的，就是这样随意。</p>
<p>这个集合中很多都是不可打印字符，估计只有<code>\n</code>是我们的老朋友。所以，如果不需要区分空格和换行的话，那就大胆的用<code>\s</code>吧。</p>
<h4 id="w元字符"><a href="#w元字符" class="headerlink" title="\w元字符"></a>\w元字符</h4><p><code>\w</code>匹配一个字母或者一个数字或者一个下划线。为什么要将它们放一起？想一想JavaScript中的变量规则，包括很多应用的用户名都只能是这三样，所以把它们放一起挺方便的。</p>
<p>不过要注意，字母指的是26个英文字母，其他的不行。</p>
<pre><code>&apos;正则&apos;.match(/\w/);
// null复制代码
</code></pre><h4 id="负阴抱阳"><a href="#负阴抱阳" class="headerlink" title="负阴抱阳"></a>负阴抱阳</h4><p>如果我们将大写和小写的带反斜杠的元字符组合在一起，就能匹配任何字符。是的，不针对任何人。</p>
<pre><code>&apos;@regex&apos;.match(/[\s\S]/);
// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码
</code></pre><p>方括号的含义我们先按下不表。</p>
<h2 id="道生一"><a href="#道生一" class="headerlink" title="道生一"></a>道生一</h2><p><code>.</code>在正则中的含义仙风道骨，它匹配换行符之外的任意单个字符。</p>
<p>如果文本不存在换行符，那么<code>.</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p>
<p>如果文本存在换行符，那么<code>(.|\n)</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p>
<pre><code>&apos;@regex&apos;.match(/./);
// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码
</code></pre><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>前面我们一直在强调，一个元字符只匹配一个字符。即便强大如<code>.</code>它也只能匹配一个。</p>
<p>那匹配<code>gooooogle</code>的正则是不是得写成<code>/gooooogle/</code>呢？</p>
<p>正则冷笑，并向你发射一个蔑视。</p>
<p>如果匹配的模式有重复，我们可以声明它重复的次数。<br>量词含义?重复零次或者一次+重复一次或者多次，也就是至少一次*重复零次或者多次，也就是任意次数{n}重复n次{n,}重复n次或者更多次{n,m}重复n次到m次之间的次数，包含n次和m次<br>有三点需要注意：</p>
<ul>
<li><p><code>?</code>在诸如匹配http协议的时候非常有用，就像这样：<code>/http(s)?/</code>。它在正则中除了是量词还有别的含义，后面会提到。</p>
</li>
<li><p>我们习惯用<code>/.*/</code>来匹配若干对我们没有价值的文本，它的含义是<code>若干除换行符之外的字符</code>。比如我们需要文本两头的格式化信息，中间是什么无所谓，它就派上用场了。不过它的性能可不好。</p>
</li>
<li><p><code>{n,m}</code>之间不能有空格，空格在正则中是有含义的。</p>
</li>
</ul>
<p>关于量词最令人困惑的是：它重复什么？</p>
<p>它重复紧贴在它前面的某个集合。第一点，必须是紧贴在它前面；第二点，重复一个集合。最常见的集合就是一个字符，当然正则中有一些元字符能够将若干字符变成一个集合，后面会讲到。</p>
<pre><code>&apos;gooooogle&apos;.match(/go{2,5}gle/);
// [&quot;gooooogle&quot;, index: 0, input: &quot;gooooogle&quot;, groups: undefined]复制代码
</code></pre><p>如果一个量词紧贴在另一个量词后面会怎样？</p>
<pre><code>&apos;gooooogle&apos;.match(/go{2,5}+gle/);
// Uncaught SyntaxError: Invalid regular expression: /go{2,5}+gle/: Nothing to repeat复制代码
</code></pre><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>前面提到量词不能紧跟在另一个量词后面，马上要👋👋打脸了。</p>
<pre><code>&apos;https&apos;.match(/http(s)?/);
// [&quot;https&quot;, &quot;s&quot;, index: 0, input: &quot;https&quot;, groups: undefined]&apos;https&apos;.match(/http(s)??/);
// [&quot;http&quot;, undefined, index: 0, input: &quot;https&quot;, groups: undefined]复制代码
</code></pre><p>然而，我的脸是这么好打的？</p>
<p>紧跟在<code>?</code>后面的<code>?</code>它不是一个量词，而是一个模式切换符，从贪婪模式切换到非贪婪模式。</p>
<p>贪婪模式在正则中是默认的模式，就是在既定规则之下匹配尽可能多的文本。因为正则中有量词，它的重复次数可能是一个区间，这就有了取舍。</p>
<p>紧跟在量词之后加上<code>?</code>就可以开启非贪婪模式。怎么省事怎么来。</p>
<p>这里的要点是，<code>?</code>必须紧跟着量词，否则的话它自己就变成量词了。</p>
<h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>正则中的普通字符只能匹配它自己。如果我要匹配一个普通字符，但是我不确定它是什么，怎么办？</p>
<pre><code>&apos;grey or gray&apos;.match(/gr[ae]y/);
// [&quot;grey&quot;, index: 0, input: &quot;grey or gray&quot;, groups: undefined]复制代码
</code></pre><p>方括号在正则中表示一个区间，我们称它为字符组。</p>
<p>首先，字符组中的字符集合只是所有的可选项，最终它只能匹配一个字符。</p>
<p>然后，字符组是一个独立的世界，元字符不需要转义。</p>
<pre><code>&apos;$&apos;.match(/[$&amp;@]/);
// [&quot;$&quot;, index: 0, input: &quot;$&quot;, groups: undefined]复制代码
</code></pre><p>最后，有两个字符在字符组中有特殊含义。</p>
<p><code>^</code>在字符组中表示取反，不再是文本开始的位置了。</p>
<pre><code>&apos;regex&apos;.match(/[^abc]/);
// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码
</code></pre><p>如果我就要<code>^</code>呢？前面已经讲过了，转义。</p>
<p><code>-</code>本来是一个普通字符，在字符组中摇身一变成为连字符。</p>
<pre><code>&apos;13&apos;.match(/[1-9]3/);
// [&quot;13&quot;, index: 0, input: &quot;13&quot;, groups: undefined]复制代码
</code></pre><p>连字符的意思是匹配范围在它的左边字符和右边字符之间。</p>
<p>如果我这样呢？</p>
<pre><code>&apos;abc-3&apos;.match(/[0-z]/);
// [&quot;a&quot;, index: 0, input: &quot;abc-3&quot;, groups: undefined]复制代码

&apos;xyz-3&apos;.match(/[0-c]/);
// [&quot;3&quot;, index: 4, input: &quot;xyz-3&quot;, groups: undefined]复制代码

&apos;xyz-3&apos;.match(/[0-$]/);
// Uncaught SyntaxError: Invalid regular expression: /[0-$]/: Range out of order in character class复制代码
</code></pre><p>发现什么了没有？只有两种字符是可以用连字符的：英文字母和数字。而且英文字母可以和数字连起来，英文字母的顺序在后面。这和扑克牌<code>1 2 3 4 5 6 7 8 9 10 J Q K</code>是一个道理。</p>
<h2 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h2><p>我们已经知道量词是怎么回事了，我们也知道量词只能重复紧贴在它前面的字符。</p>
<p>如果我要重复的是一串字符呢？</p>
<pre><code>&apos;i love you very very very much&apos;.match(/i love you very +much/);
// null&apos;i love you very very very much&apos;.match(/i love you v+e+r+y+ +much/);
// null复制代码
</code></pre><p>这样肯定是不行的。是时候请圆括号出山了。</p>
<pre><code>&apos;i love you very very very much&apos;.match(/i love you (very )+much/);
// [&quot;i love you very very very much&quot;, &quot;very &quot;, index: 0, input: &quot;i love you very very very much&quot;, groups: undefined]复制代码
</code></pre><p>圆括号的意思是将它其中的字符集合打包成一个整体，然后量词就可以操作这个整体了。这和方括号的效果是完全不一样的。</p>
<p>而且默认的，圆括号的匹配结果是可以捕获的。</p>
<h4 id="正则内捕获"><a href="#正则内捕获" class="headerlink" title="正则内捕获"></a>正则内捕获</h4><p>现在我们有一个需求，匹配<code>&lt;div&gt;</code>标签。</p>
<pre><code>&apos;&lt;div&gt;hello regex&lt;/div&gt;&apos;.match(/&lt;div&gt;.*&lt;\/div&gt;/);
// [&quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, index: 0, input: &quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, groups: undefined]复制代码
</code></pre><p>这很简单。但如果我要匹配的是任意标签，包括自定义的标签呢？</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;([a-zA-Z]+)&gt;.*&lt;\/\1&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: undefined]复制代码
</code></pre><p>这时候就要用到正则的捕获特性。正则内捕获使用<code>\数字</code>的形式，分别对应前面的圆括号捕获的内容。这种捕获的引用也叫<strong>反向引用</strong>。</p>
<p>我们来看一个更复杂的情况：</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&apos;.match(/&lt;((A|a)pp)&gt;(hello regex)+&lt;\/\1&gt;&lt;p&gt;\2&lt;\/p&gt;&lt;p&gt;\3&lt;\/p&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, &quot;App&quot;, &quot;A&quot;, &quot;hello regex&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, groups: undefined]复制代码
</code></pre><p>如果有嵌套的圆括号，那么捕获的引用是先递归的，然后才是下一个顶级捕获。</p>
<h4 id="正则外捕获"><a href="#正则外捕获" class="headerlink" title="正则外捕获"></a>正则外捕获</h4><pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]RegExp.$1;
// &quot;abc&quot;复制代码
</code></pre><p>没错，<code>RegExp</code>就是构造正则的构造函数。如果有捕获组，它的实例属性<code>$数字</code>会显示对应的引用。</p>
<p>如果有多个正则呢？</p>
<pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@xyz&apos;.match(/@(xyz)/);
// [&quot;@xyz&quot;, &quot;xyz&quot;, index: 0, input: &quot;@xyz&quot;, groups: undefined]RegExp.$1;
// &quot;xyz&quot;复制代码
</code></pre><p><code>RegExp</code>构造函数的引用只显示最后一个正则的捕获。</p>
<p>另外还有一个字符串实例方法也支持正则捕获的引用，它就是<code>replace</code>方法。</p>
<pre><code>&apos;hello **regex**&apos;.replace(/\*{2}(.*)\*{2}/, &apos;&lt;strong&gt;$1&lt;/strong&gt;&apos;);
// &quot;hello &lt;strong&gt;regex&lt;/strong&gt;&quot;复制代码
</code></pre><p>实际上它才是最常用的引用捕获的方式。</p>
<h4 id="捕获命名"><a href="#捕获命名" class="headerlink" title="捕获命名"></a>捕获命名</h4><blockquote>
<p>这是ES2018的新特性。</p>
</blockquote>
<p>使用<code>\数字</code>引用捕获必须保证捕获组的顺序不变。现在开发者可以给捕获组命名了，有了名字以后，引用起来更加确定。</p>
<pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;(?&lt;tag&gt;[a-zA-Z]+)&gt;.*&lt;\/\k&lt;tag&gt;&gt;/);
// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: {tag: &quot;App&quot;}]复制代码
</code></pre><p>在捕获组内部最前面加上<code>?&lt;key&gt;</code>，它就被命名了。使用<code>\k&lt;key&gt;</code>语法就可以引用已经命名的捕获组。</p>
<p>是不是很简单？</p>
<p>通常情况下，开发者只是想在正则中将某些字符当成一个整体看待。捕获组很棒，但是它做了额外的事情，肯定需要额外的内存占用和计算资源。于是正则又有了非捕获组的概念。</p>
<pre><code>&apos;@abc&apos;.match(/@(abc)/);
// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@abc&apos;.match(/@(?:abc)/);
// [&quot;@abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]复制代码
</code></pre><p>只要在圆括号内最前面加上<code>?:</code>标识，就是告诉正则引擎：我只要这个整体，不需要它的引用，你就别费劲了。从上面的例子也可以看出来，<code>match</code>方法返回的结果有些许不一样。</p>
<p>个人观点：我觉得正则的捕获设计应该反过来，默认不捕获，加上<code>?:</code>标识后才捕获。因为大多数时候开发者是不需要捕获的，但是它又懒得加<code>?:</code>标识，会有些许性能浪费。</p>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>有时候开发者需要在正则中使用<code>或者</code>。</p>
<pre><code>&apos;高圆圆&apos;.match(/陈乔恩|高圆圆/);
// [&quot;高圆圆&quot;, index: 0, input: &quot;高圆圆&quot;, groups: undefined]复制代码
</code></pre><p><code>|</code>就代表<code>或者</code>。字符组其实也是一个多选结构，但是它们俩有本质区别。字符组最终只能匹配一个字符，而分支匹配的是左边所有的字符或者右边所有的字符。</p>
<p>我们来看一个例子：</p>
<pre><code>&apos;我喜欢高圆圆&apos;.match(/我喜欢陈乔恩|高圆圆/);
// [&quot;高圆圆&quot;, index: 3, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码
</code></pre><p>因为<code>|</code>是将左右两边一切两半，然后匹配左边或者右边。所以上面的正则显然达不到我们想要的效果。这个时候就需要一个东西来缩小分支的范围。诶，你可能已经想到了：</p>
<pre><code>&apos;我喜欢高圆圆&apos;.match(/我喜欢(?:陈乔恩|高圆圆)/);
// [&quot;我喜欢高圆圆&quot;, index: 0, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码
</code></pre><p>没错，就是圆括号。</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>正则中有一些元字符，它不匹配字符，而是匹配一个位置。比如之前提到的<code>^</code>和<code>$</code>。<code>^</code>的意思是说这个位置应该是文本开始的位置。</p>
<p>正则还有一些比较高级的匹配位置的语法，它匹配的是：在这个位置之前或之后应该有什么内容。</p>
<p>零宽(zero-width)是什么意思？指的就是它匹配一个位置，本身没有宽度。</p>
<p>断言(assertion)是什么意思？指的是一种判断，断言之前或之后应该有什么或应该没有什么。</p>
<h4 id="零宽肯定先行断言"><a href="#零宽肯定先行断言" class="headerlink" title="零宽肯定先行断言"></a>零宽肯定先行断言</h4><p>所谓的肯定就是判断有什么，而不是判断没有什么。</p>
<p>而先行指的是向前看(lookahead)，断言的这个位置是为前面的规则服务的。</p>
<p>语法很简单：圆括号内最左边加上<code>?=</code>标识。</p>
<pre><code>&apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)/);
// [&quot;Java&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码
</code></pre><p>上面匹配的是四个字母，这四个字母要满足以下条件：紧跟着的应该是<code>Script</code>字符串，而且<code>Script</code>字符串应该是单词的结尾部分。</p>
<p>所以，零宽肯定先行断言的意思是：现在有一段正则语法，用这段语法去匹配给定的文本。但是，满足条件的文本不仅要匹配这段语法，紧跟着它的必须是一个位置，这个位置又必须满足一段正则语法。</p>
<p>说的再直白点，我要匹配一段文本，但是这段文本后面必须紧跟着另一段特定的文本。零宽肯定先行断言就是一个界碑，我要满足前面和后面所有的条件，但是我只要前面的文本。</p>
<p>我们来看另一种情况：</p>
<pre><code>&apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)\w+/);
// [&quot;JavaScript&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码
</code></pre><p>上面的例子更加直观，零宽肯定先行断言已经匹配过<code>Script</code>一次了，后面的<code>\w+</code>却还是能匹配<code>Script</code>成功，足以说明它的<code>零宽</code>特性。它为紧贴在它前面的规则服务，并且不影响后面的匹配规则。</p>
<h4 id="零宽肯定后行断言"><a href="#零宽肯定后行断言" class="headerlink" title="零宽肯定后行断言"></a>零宽肯定后行断言</h4><p>先行是向前看，那后行就是向后看(lookbehind)咯。</p>
<p>语法是圆括号内最左边加上<code>?&lt;=</code>标识。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍\S+/);
// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><p>一个正则可以有多个断言：</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍.+?(?=\s|$)/);
// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><h4 id="零宽否定先行断言"><a href="#零宽否定先行断言" class="headerlink" title="零宽否定先行断言"></a>零宽否定先行断言</h4><p>肯定是判断有什么，否定就是判断没有什么咯。</p>
<p>语法是圆括号内最左边加上<code>?!</code>标识。</p>
<pre><code>&apos;TypeScript Perl JavaScript&apos;.match(/\b\w{4}(?!Script\b)/);
// [&quot;Perl&quot;, index: 11, input: &quot;TypeScript Perl JavaScript&quot;, groups: undefined]复制代码
</code></pre><h4 id="零宽否定后行断言"><a href="#零宽否定后行断言" class="headerlink" title="零宽否定后行断言"></a>零宽否定后行断言</h4><p>语法是圆括号最左边加上<code>?&lt;!</code>标识。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;!演员)霍\S+/);
// [&quot;霍去病&quot;, index: 8, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码
</code></pre><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>正则表达式除了主体语法，还有若干可选的模式修饰符。</p>
<p>写法就是将修饰符安插在正则主体的尾巴上。比如这样：<code>/abc/gi</code>。</p>
<h4 id="g修饰符"><a href="#g修饰符" class="headerlink" title="g修饰符"></a>g修饰符</h4><p><code>g</code>是<code>global</code>的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。<code>g</code>修饰符会开启全局匹配模式，找到所有匹配的结果。</p>
<pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/);
// [&quot;高圆圆&quot;, index: 2, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/g);
// [&quot;高圆圆&quot;, &quot;霍思燕&quot;]复制代码
</code></pre><h4 id="i修饰符"><a href="#i修饰符" class="headerlink" title="i修饰符"></a>i修饰符</h4><p><code>i</code>是<code>ignoreCase</code>的缩写。默认情况下，<code>/z/</code>是无法匹配<code>Z</code>的，所以我们有时候不得不这样写：<code>/[a-zA-Z]/</code>。<code>i</code>修饰符可以全局忽略大小写。</p>
<p>很多时候我们不在乎文本是大写、小写还是大小写混写，这个修饰符还是很有用的。</p>
<pre><code>&apos;javascript is great&apos;.match(/JavaScript/);
// null&apos;javascript is great&apos;.match(/JavaScript/i);
// [&quot;javascript&quot;, index: 0, input: &quot;javascript is great&quot;, groups: undefined]复制代码
</code></pre><h4 id="m修饰符"><a href="#m修饰符" class="headerlink" title="m修饰符"></a>m修饰符</h4><p><code>m</code>是<code>multiline</code>的缩写。这个修饰符有特定起作用的场景：它要和<code>^</code>和<code>$</code>搭配起来使用。默认情况下，<code>^</code>和<code>$</code>匹配的是文本的开始和结束，加上<code>m</code>修饰符，它们的含义就变成了行的开始和结束。</p>
<pre><code>`
abc
xyz
`.match(/xyz/);
// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]`
abc
xyz
`.match(/^xyz$/);
// null`
abc
xyz
`.match(/^xyz$/m);
// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码
</code></pre><h4 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h4><blockquote>
<p>这是ES2015的新特性。</p>
</blockquote>
<p><code>y</code>是<code>sticky</code>的缩写。<code>y</code>修饰符有和<code>g</code>修饰符重合的功能，它们都是全局匹配。所以重点在<code>sticky</code>上，怎么理解这个<code>粘连</code>呢？</p>
<p><code>g</code>修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是<code>y</code>修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。</p>
<pre><code>&apos;a bag with a tag has a mag&apos;.match(/\wag/g);
// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]&apos;a bag with a tag has a mag&apos;.match(/\wag/y);
// null&apos;bagtagmag&apos;.match(/\wag/y);
// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]&apos;bagtagmag&apos;.match(/\wag/gy);
// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]复制代码
</code></pre><p>有人肯定发现了猫腻：你不是说<code>y</code>修饰符是全局匹配么？看上面的例子，单独一个<code>y</code>修饰符用match方法怎么并不是全局匹配呢？</p>
<p>诶，这里说来就话长了。</p>
<p>长话短说呢，就涉及到<code>y</code>修饰符的本质是什么。它的本质有二：</p>
<ul>
<li>全局匹配(先别着急打我)。</li>
<li>从文本的<code>lastIndex</code>位置开始新的匹配。lastIndex是什么？它是正则表达式的一个属性，如果是全局匹配，它用来标注下一次匹配的起始点。这才是粘连的本质所在。</li>
</ul>
<p>不知道你们发现什么了没有：<strong>lastIndex是正则表达式的一个属性</strong>。而上面例子中的match方法是作用在字符串上的，都没有lastIndex属性，休怪人家工作不上心。</p>
<pre><code>const reg = /\wag/y;
reg.exec(&apos;bagtagmag&apos;);
// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]
reg.exec(&apos;bagtagmag&apos;);
// [&quot;tag&quot;, index: 3, input: &quot;bagtagmag&quot;, groups: undefined]
reg.exec(&apos;bagtagmag&apos;);
// [&quot;mag&quot;, index: 6, input: &quot;bagtagmag&quot;, groups: undefined]复制代码
</code></pre><p>咱们换成正则方法exec，多次执行，正则的lastIndex在变，匹配的结果也在变。全局匹配无疑了吧。</p>
<h4 id="s修饰符"><a href="#s修饰符" class="headerlink" title="s修饰符"></a>s修饰符</h4><blockquote>
<p>这是ES2018的新特性。</p>
</blockquote>
<p><code>s</code>不是<code>dotAll</code>的缩写。<code>s</code>修饰符要和<code>.</code>搭配使用，默认情况下，<code>.</code>匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。</p>
<p><code>s</code>修饰符的作用就是让<code>.</code>可以匹配任意单个字符。</p>
<p><code>s</code>是<code>singleline</code>的缩写。</p>
<pre><code>`
abc
xyz
`.match(/c.x/);
// null`
abc
xyz
`.match(/c.x/s);
// [&quot;c↵x&quot;, index: 3, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码
</code></pre><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><blockquote>
<p>这是ES2015的新特性。</p>
</blockquote>
<p><code>u</code>是<code>unicode</code>的缩写。有一些Unicode字符超过一个字节，正则就无法正确的识别它们。<code>u</code>修饰符就是用来处理这些不常见的情况的。</p>
<pre><code>&apos;𠮷&apos;.match(/^.$/);
// null&apos;𠮷&apos;.match(/^.$/u);
// [&quot;𠮷&quot;, index: 0, input: &quot;𠮷&quot;, groups: undefined]复制代码
</code></pre><p><code>𠮷</code>念<code>jí</code>，与<code>吉</code>同义。</p>
<p>笔者对Unicode认识尚浅，这里不过多展开。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/16/前端代码异常监控实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/16/前端代码异常监控实战/" itemprop="url">前端代码异常监控实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-16T11:22:33+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="把前端监控做到极致-掘金"><a href="#把前端监控做到极致-掘金" class="headerlink" title="把前端监控做到极致 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a52f138f265da3e5b32a41b" target="_blank" rel="noopener">把前端监控做到极致 - 掘金</a></h2><h2 id="线上压缩代码-定位错误-掘金"><a href="#线上压缩代码-定位错误-掘金" class="headerlink" title="线上压缩代码-定位错误 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a4f6886518825734216b352" target="_blank" rel="noopener">线上压缩代码-定位错误 - 掘金</a></h2><p>生产环境没有source-map文件，上报的错误都不好定位，这里实现一个简单的错误定位脚本</p>
<p>1、获取压缩代码错误信息（行数、列数、错误信息，错误文件）</p>
<h2 id="这里通过控制台看错误信息"><a href="#这里通过控制台看错误信息" class="headerlink" title="这里通过控制台看错误信息"></a>这里通过控制台看错误信息</h2><pre><code>window.addEventListener(&apos;error&apos;, function (e) {
    console.debug(&apos;lineno: &apos;, e.lineno, &apos; colno: &apos;, e.colno)
    console.debug(&apos;errorMessage:&apos;, e.message)
    console.debug(&apos;errorFile:&apos;, e.filename)
}, true)
</code></pre><p>我们写一段错误的代码（single.vue的片段）</p>
<pre><code>method: {
   test (option) {
        const data = option.test
        const dataTest = option.data.test
        return data + dataTest
    }
}, 
created () {
    // 设置异步错误的原因是，同步的错误会被vue捕获
    setTimeout(() =&gt; {
        this.test({
          testOption: 1
        })
    }, 300)
}
</code></pre><p>在浏览器中运行，报错结果如下<br><img src="https://pic4.zhimg.com/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_hd.jpg" alt=""></p>
<p>得到错误信息：</p>
<ul>
<li>错误行数：1</li>
<li>错误列数：59236</li>
<li>错误信息：cannot read property ‘test’ of undefined</li>
<li>错误文件：0.0a77f.js</li>
</ul>
<p>2、定位错误的node脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## 安装依赖source-map</span><br><span class="line"></span><br><span class="line"> npm install source-map</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    node脚本如下（map/index.js）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> // 读取文件</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">// souceMap处理文件</span><br><span class="line">var SourceMapConsumer = require(&apos;source-map&apos;).SourceMapConsumer</span><br><span class="line">// 启动构建进程（已构建则不需要）</span><br><span class="line">var exec = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">var lineno = process.argv[2] || 0   // 第一个参数为行数</span><br><span class="line">var columnno = process.argv[3] || 0 // 第二个参数为列数</span><br><span class="line">var fileName = process.argv[4] || &apos;&apos; // 第三个参数为错误文件（错误文件名就好）</span><br><span class="line"></span><br><span class="line">// 构建有map的线上代码</span><br><span class="line">// node build onlineMap为构建命令</span><br><span class="line">exec(&apos;node build onlineMap&apos;, function () &#123;</span><br><span class="line"> // 读取错误文件的map文件</span><br><span class="line"> var consumer = new SourceMapConsumer(fs.readFileSync(&apos;./dist/&apos; + fileName + &apos;.map&apos;, &apos;utf8&apos;))</span><br><span class="line">  // 输出map的错误信息</span><br><span class="line">  console.log(consumer.originalPositionFor(&#123;</span><br><span class="line">    line: +lineno,      // +是为了转化为数字</span><br><span class="line">    column: +columnno</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">    运行node脚本</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> node map 1 59236 0.0a77f.js</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>效果如下：</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/v2-cf68e7b673405c90fe024bf48dfb42c7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf68e7b673405c90fe024bf48dfb42c7_hd.jpg" alt=""></p>
<p>结合控制台输出的信息，就可以定位到错误代码了</p>
<p>我们再来看一下，给代码开启source-map，看错误信息是否一致</p>
<p><img src="https://pic3.zhimg.com/v2-5319b431cef161a0a07ba46f8b0e6a02_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-5319b431cef161a0a07ba46f8b0e6a02_hd.jpg" alt=""><br>错误代码的位置定位是准确的，证明可行。</p>
<p>3、后续扩展思路</p>
<h2 id="目前实现的是比较简单的脚本，所以存在一些问题："><a href="#目前实现的是比较简单的脚本，所以存在一些问题：" class="headerlink" title="目前实现的是比较简单的脚本，所以存在一些问题："></a>目前实现的是比较简单的脚本，所以存在一些问题：</h2><ul>
<li>需要当前构建内容和线上是一致的</li>
<li>操作比较繁琐</li>
</ul>
<p>优化思路如下：</p>
<p><img src="https://pic4.zhimg.com/v2-a8b63ecc364c66c8bf4bbec9880f8c23_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a8b63ecc364c66c8bf4bbec9880f8c23_hd.jpg" alt=""></p>
<p>后续优化慢慢补充~</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在对公司的前端代码脚本错误进行排查，试图降低 JS Error 的错误量，结合自己之前的经验对这方面内容进行了实践并总结，下面就此谈谈我对前端代码异常监控的一些见解。</p>
<p>本文大致围绕下面几点展开讨论：</p>
<ol>
<li>JS 处理异常的方式</li>
<li>上报方式</li>
<li>异常监控上报常见问题</li>
</ol>
<h2 id="JS-异常处理"><a href="#JS-异常处理" class="headerlink" title="JS 异常处理"></a>JS 异常处理</h2><p>对于 Javascript 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>
<ol>
<li>当前代码块将作为一个任务压入任务队列中，JS 线程会不断地从任务队列中提取任务执行。</li>
<li>当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务的执行。</li>
<li><p>JS 线程会继续从任务队列中提取下一个任务继续执行。</p>
 <script>
   error
   console.log('永远不会执行');
 </script>
 <script>
   console.log('我继续执行')
 </script>


</li>
</ol>
<p><img src="https://pic2.zhimg.com/v2-7a136ce7674914bcd7b7f42986d0c5bc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7a136ce7674914bcd7b7f42986d0c5bc_hd.jpg" alt=""></p>
<p>在对脚本错误进行上报之前，我们需要对异常进行处理，程序需要先感知到脚本错误的发生，然后再谈异常上报。</p>
<p>脚本错误一般分为两种：语法错误，运行时错误。</p>
<p>下面就谈谈几种异常监控的处理方式：</p>
<h2 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h2><p>try-catch 在我们的代码中经常见到，通过给代码块进行 try-catch 进行包装后，当代码块发生出错时 catch 将能捕捉到错误的信息，页面也将可以继续执行。</p>
<p>但是 try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误和异步错误就显得无能为力，捕捉不到。</p>
<h2 id="示例：运行时错误"><a href="#示例：运行时错误" class="headerlink" title="示例：运行时错误"></a>示例：运行时错误</h2><pre><code>try {
  error    // 未定义变量 
} catch(e) {
  console.log(&apos;我知道错误了&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-dc8ba7e4b9e56127799c11b46cf7068d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-dc8ba7e4b9e56127799c11b46cf7068d_hd.jpg" alt=""></p>
<p>然而对于语法错误和异步错误就捕捉不到了。</p>
<h2 id="示例：语法错误"><a href="#示例：语法错误" class="headerlink" title="示例：语法错误"></a>示例：语法错误</h2><pre><code>try {
  var error = &apos;error&apos;；   // 大写分号
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-8ddf6acf0f42c4b08ba8b73798b863a0_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8ddf6acf0f42c4b08ba8b73798b863a0_hd.jpg" alt=""></p>
<p>一般语法错误在编辑器就会体现出来，常表现的错误信息为： Uncaught SyntaxError: Invalid or unexpected token xxx 这样。但是这种错误会直接抛出异常，常使程序崩溃，一般在编码时候容易观察得到。</p>
<h2 id="示例：异步错误"><a href="#示例：异步错误" class="headerlink" title="示例：异步错误"></a>示例：异步错误</h2><pre><code>try {
  setTimeout(() =&gt; {
    error        // 异步错误
  })
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic4.zhimg.com/v2-0ed67a00e3c7762e74975bebbbc88274_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-0ed67a00e3c7762e74975bebbbc88274_hd.jpg" alt=""></p>
<p>除非你在 setTimeout 函数中再套上一层 try-catch，否则就无法感知到其错误，但这样代码写起来比较啰嗦。</p>
<h2 id="window-onerror-异常处理"><a href="#window-onerror-异常处理" class="headerlink" title="window.onerror 异常处理"></a>window.onerror 异常处理</h2><p>window.onerror 捕获异常能力比 try-catch 稍微强点，无论是异步还是非异步错误，onerror 都能捕获到运行时错误。</p>
<p>示例：运行时同步错误</p>
<pre><code>/**
 * @param {String}  msg    错误信息
 * @param {String}  url    出错文件
 * @param {Number}  row    行号
 * @param {Number}  col    列号
 * @param {Object}  error  错误详细信息
 */
 window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
error;
</code></pre><p>示例：异步错误</p>
<pre><code>window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道异步错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
setTimeout(() =&gt; {
  error;
});
</code></pre><p><img src="https://pic3.zhimg.com/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_hd.jpg" alt=""></p>
<p>然而 window.onerror 对于语法错误还是无能为力，所以我们在写代码的时候要尽可能避免语法错误的，不过一般这样的错误会使得整个页面崩溃，还是比较容易能够察觉到的。</p>
<p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>
<p>需要注意的是，window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。</p>
<p><img src="https://pic3.zhimg.com/v2-875235a4876ea8429f12e7aaf2f19588_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-875235a4876ea8429f12e7aaf2f19588_hd.jpg" alt=""></p>
<p>关于 window.onerror 还有两点需要值得注意</p>
<ol>
<li>对于 onerror 这种全局捕获，最好写在所有 JS 脚本的前面，因为你无法保证你写的代码是否出错，如果写在后面，一旦发生错误的话是不会被 onerror 捕获到的。</li>
<li>另外 onerror 是无法捕获到网络异常的错误。</li>
</ol>
<p>当我们遇到 <code>&lt;img src=&quot;./404.png&quot;&gt;</code> 报 404 网络请求异常的时候，onerror 是无法帮助我们捕获到异常的。</p>
<pre><code>&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道异步错误了&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot;&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-81341c443f078b6526e0c6031dd40953_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81341c443f078b6526e0c6031dd40953_hd.jpg" alt=""></p>
<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>
<pre><code>&lt;script&gt;
window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我知道 404 错误了&apos;);
  console.log(
    msg, url, row, col, error
  );
  return true;
}, true);
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot; alt=&quot;&quot;&gt;
</code></pre><p><img src="https://pic4.zhimg.com/v2-6d1c1196acd800a4a4475ee6847ee82a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6d1c1196acd800a4a4475ee6847ee82a_hd.jpg" alt=""></p>
<p>这点知识还是需要知道，要不然用户访问网站，图片 CDN 无法服务，图片加载不出来而开发人员没有察觉就尴尬了。</p>
<h2 id="Promise-错误"><a href="#Promise-错误" class="headerlink" title="Promise 错误"></a>Promise 错误</h2><p>通过 Promise 可以帮助我们解决异步回调地狱的问题，但是一旦 Promise 实例抛出异常而你没有用 catch 去捕获的话，onerror 或 try-catch 也无能为力，无法捕捉到错误。</p>
<pre><code>window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我感知不到 promise 错误&apos;);
  console.log(
    msg, url, row, col, error
  );
}, true);
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic4.zhimg.com/v2-1ce580bb2344474b1df1517f2d11aa40_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-1ce580bb2344474b1df1517f2d11aa40_hd.jpg" alt=""></p>
<p>虽然在写 Promise 实例的时候养成最后写上 catch 函数是个好习惯，但是代码写多了就容易糊涂，忘记写 catch。</p>
<p>所以如果你的应用用到很多的 Promise 实例的话，特别是你在一些基于 promise 的异步库比如 axios 等一定要小心，因为你不知道什么时候这些异步请求会抛出异常而你并没有处理它，所以你最好添加一个 Promise 全局异常捕获事件 <strong>unhandledrejection</strong>。</p>
<pre><code>window.addEventListener(&quot;unhandledrejection&quot;, function(e){
  e.preventDefault()
  console.log(&apos;我知道 promise 的错误了&apos;);
  console.log(e.reason);
  return true;
});
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic2.zhimg.com/v2-115d494f26e4f8e2172e1f3b4cb6094f_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-115d494f26e4f8e2172e1f3b4cb6094f_hd.jpg" alt=""></p>
<p>当然，如果你的应用没有做 Promise 全局异常处理的话，那很可能就像某乎首页这样：</p>
<p><img src="https://pic2.zhimg.com/v2-37c6bc3763c147a4c97bdde688a59a5c_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-37c6bc3763c147a4c97bdde688a59a5c_hd.jpg" alt=""></p>
<h2 id="异常上报方式"><a href="#异常上报方式" class="headerlink" title="异常上报方式"></a>异常上报方式</h2><p>监控拿到报错信息之后，接下来就需要将捕捉到的错误信息发送到信息收集平台上，常用的发送形式主要有两种:</p>
<ol>
<li>通过 Ajax 发送数据</li>
<li>动态创建 img 标签的形式</li>
</ol>
<p>实例 - 动态创建 img 标签进行上报</p>
<pre><code>function report(error) {
  var reportUrl = &apos;http://xxxx/report&apos;;
  new Image().src = reportUrl + &apos;error=&apos; + error;
}
</code></pre><h2 id="监控上报常见问题"><a href="#监控上报常见问题" class="headerlink" title="监控上报常见问题"></a>监控上报常见问题</h2><p>下述例子我全部放在我的 github 上，读者可以自行查阅，后面不再赘述。</p>
<pre><code>git clone https://github.com/happylindz/blog.git
cd blog/code/jserror/
npm install
</code></pre><h2 id="Script-error-脚本错误是什么"><a href="#Script-error-脚本错误是什么" class="headerlink" title="Script error 脚本错误是什么"></a>Script error 脚本错误是什么</h2><p>因为我们在线上的版本，经常做静态资源 CDN 化，这就会导致我们常访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。</p>
<p><img src="https://pic3.zhimg.com/v2-840f71bf7014767132b47ad2c6a37238_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-840f71bf7014767132b47ad2c6a37238_hd.jpg" alt=""></p>
<p>可通过 <code>npm run nocors</code> 查看效果。</p>
<p>Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。</p>
<p><img src="https://pic2.zhimg.com/v2-fc3941d89716f96374576d0426ff4ccb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-fc3941d89716f96374576d0426ff4ccb_hd.jpg" alt=""></p>
<p>这样做的目的是避免数据泄露到不安全的域中，举个简单的例子，</p>
<pre><code>&lt;script src=&quot;xxxx.com/login.html&quot;&gt;&lt;/script&gt;
</code></pre><p>上面我们并没有引入一个 js 文件，而是一个 html，这个 html 是银行的登录页面，如果你已经登录了，那 login 页面就会自动跳转到 <code>Welcome xxx...</code>，如果未登录则跳转到 <code>Please Login...</code>，那么报错也会是 <code>Welcome xxx... is not defined，Please Login... is not defined</code>，通过这些信息可以判断一个用户是否登录他的帐号，给入侵者提供了十分便利的判断渠道，这是相当不安全的。</p>
<p>介绍完背景后，那么我们应该去解决这个问题？</p>
<p>首先可以想到的方案肯定是同源化策略，将 JS 文件内联到 html 或者放到同域下，虽然能简单有效地解决 script error 问题，但是这样无法利用好文件缓存和 CDN 的优势，不推荐使用。正确的方法应该是从根本上解决 script error 的错误。</p>
<h2 id="跨源资源共享机制-CORS"><a href="#跨源资源共享机制-CORS" class="headerlink" title="跨源资源共享机制( CORS )"></a>跨源资源共享机制( CORS )</h2><p>首先为页面上的 script 标签添加 crossOrigin 属性</p>
<pre><code>// http://localhost:8080/index.html
&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;script src=&quot;http://localhost:8081/test.js&quot; crossorigin&gt;&lt;/script&gt;

// http://localhost:8081/test.js
setTimeout(() =&gt; {
  console.log(error);
});
</code></pre><p>当你修改完前端代码后，你还需要额外给后端在响应头里加上 <code>Access-Control-Allow-Origin: localhost:8080</code>，这里我以 Koa 为例。</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const path = require(&apos;path&apos;);
const cors = require(&apos;koa-cors&apos;);
const app = new Koa();

app.use(cors());
app.use(require(&apos;koa-static&apos;)(path.resolve(__dirname, &apos;./public&apos;)));

app.listen(8081, () =&gt; {
  console.log(&apos;koa app listening at 8081&apos;)
});
</code></pre><p><img src="https://pic1.zhimg.com/v2-9717062e56340cef40ee67b438b2ba95_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-9717062e56340cef40ee67b438b2ba95_hd.jpg" alt=""></p>
<p>读者可通过 <code>npm run cors</code> 详细的跨域知识我就不展开了，有兴趣可以看看我之前写的文章：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>你以为这样就完了吗？并没有，下面就说一些 Script error 你不常遇见的点：</p>
<p>我们都知道 JSONP 是用来跨域获取数据的，并且兼容性良好，在一些应用中仍然会使用到，所以你的项目中可能会用这样的代码：</p>
<pre><code>// http://localhost:8080/index.html
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，但不知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
function jsonpCallback(data) {
  console.log(data);
}
const url = &apos;http://localhost:8081/data?callback=jsonpCallback&apos;;
const script = document.createElement(&apos;script&apos;);
script.src = url;
document.body.appendChild(script);
</code></pre><p>因为返回的信息会当做脚本文件来执行，一旦返回的脚本内容出错了，也是无法捕捉到错误的信息。</p>
<p><img src="https://pic4.zhimg.com/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_hd.jpg" alt=""></p>
<p>解决办法也不难，跟之前一样，在添加动态添加脚本的时候加上 crossOrigin，并且在后端配上相应的 CORS 字段即可.</p>
<pre><code>const script = document.createElement(&apos;script&apos;);
script.crossOrigin = &apos;anonymous&apos;;
script.src = url;
document.body.appendChild(script);
</code></pre><p>读者可以通过 <code>npm run jsonp</code> 查看效果</p>
<p><img src="https://pic4.zhimg.com/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_hd.jpg" alt=""></p>
<p>知道原理之后你可能会觉得没什么，不就是给每个动态生成的脚本添加 crossOrigin 字段嘛，但是在实际工程中，你可能是面向很多库来编程，比如使用 jQuery，Seajs 或者 webpack 来异步加载脚本，许多库封装了异步加载脚本的能力，以 jQeury 为例你可能是这样来触发异步脚本。</p>
<pre><code>$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>假如这些库中没有提供 crossOrigin 的能力的话(jQuery jsonp 可能有，假装你不知道)，那你只能去修改人家写的源代码了，所以我这里提供一个思路，就是去劫持 document.createElement，从根源上去为每个动态生成的脚本添加 crossOrigin 字段。</p>
<pre><code>document.createElement = (function() {
  const fn = document.createElement.bind(document);
  return function(type) {
    const result = fn(type);
    if(type === &apos;script&apos;) {
      result.crossOrigin = &apos;anonymous&apos;;
    }
    return result;
  }
})();
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，也知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>效果也是一样的，读者可以通过 <code>npm run jsonpjq</code> 来查看效果：</p>
<p><img src="https://pic4.zhimg.com/v2-30d51a96cdb3286edd1e5a88e9f794bb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-30d51a96cdb3286edd1e5a88e9f794bb_hd.jpg" alt=""></p>
<p>这样重写 createElement 理论上没什么问题，但是入侵了原本的代码，不保证一定不会出错，在工程上还是需要多尝试下看看再使用，可能存在兼容性上问题，如果你觉得会出现什么问题的话也欢迎留言讨论下。</p>
<p>关于 Script error 的问题就写到这里，如果你理解了上面的内容，基本上绝大部分的 Script error 都能迎刃而解。</p>
<h2 id="window-onerror-能否捕获-iframe-的错误"><a href="#window-onerror-能否捕获-iframe-的错误" class="headerlink" title="window.onerror 能否捕获 iframe 的错误"></a>window.onerror 能否捕获 iframe 的错误</h2><p>当你的页面有使用 iframe 的时候，你需要对你引入的 iframe 做异常监控的处理，否则一旦你引入的 iframe 页面出现了问题，你的主站显示不出来，而你却浑然不知。</p>
<p>首先需要强调，父窗口直接使用 window.onerror 是无法直接捕获，如果你想要捕获 iframe 的异常的话，有分好几种情况。</p>
<p>如果你的 iframe 页面和你的主站是同域名的话，直接给 iframe 添加 onerror 事件即可。</p>
<pre><code>&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  window.frames[0].onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道 iframe 的错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
</code></pre><p>读者可以通过 <code>npm run iframe</code> 查看效果：</p>
<p><img src="https://pic2.zhimg.com/v2-3edcb5686e27ab11f5f3c9c1644986d0_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3edcb5686e27ab11f5f3c9c1644986d0_hd.jpg" alt=""></p>
<p>如果你嵌入的 iframe 页面和你的主站不是同个域名的，但是 iframe 内容不属于第三方，是你可以控制的，那么可以通过与 iframe 通信的方式将异常信息抛给主站接收。与 iframe 通信的方式有很多，常用的如：postMessage，hash 或者 name 字段跨域等等，这里就不展开了，感兴趣的话可以看：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>如果是非同域且网站不受自己控制的话，除了通过控制台看到详细的错误信息外，没办法捕获，这是出于安全性的考虑，你引入了一个百度首页，人家页面报出的错误凭啥让你去监控呢，这会引出很多安全性的问题。</p>
<h2 id="压缩代码如何定位到脚本异常位置"><a href="#压缩代码如何定位到脚本异常位置" class="headerlink" title="压缩代码如何定位到脚本异常位置"></a>压缩代码如何定位到脚本异常位置</h2><p>线上的代码几乎都经过了压缩处理，几十个文件打包成了一个并丑化代码，当我们收到 <code>a is not defined</code> 的时候，我们根本不知道这个变量 a 究竟是什么含义，此时报错的错误日志显然是无效的。</p>
<p>第一想到的办法是利用 sourcemap 定位到错误代码的具体位置，详细内容可以参考：<a href="https://link.zhihu.com/?target=https%3A//github.com/joeyguo/blog/issues/14" target="_blank" rel="noopener">Sourcemap 定位脚本错误</a></p>
<p>另外也可以通过在打包的时候，在每个合并的文件之间添加几行空格，并相应加上一些注释，这样在定位问题的时候很容易可以知道是哪个文件报的错误，然后再通过一些关键词的搜索，可以快速地定位到问题的所在位置。</p>
<h2 id="收集异常信息量太多，怎么办"><a href="#收集异常信息量太多，怎么办" class="headerlink" title="收集异常信息量太多，怎么办"></a>收集异常信息量太多，怎么办</h2><p>如果你的网站访问量很大，假如网页的 PV 有 1kw，那么一个必然的错误发送的信息就有 1kw 条，我们可以给网站设置一个采集率：</p>
<pre><code>Reporter.send = function(data) {
  // 只采集 30%
  if(Math.random() &lt; 0.3) {
    send(data)      // 上报错误信息
  }
}
</code></pre><p>这个采集率可以通过具体实际的情况来设定，方法多样化，可以使用一个随机数，也可以具体根据用户的某些特征来进行判定。</p>
<h3 id="错误上报的方法："><a href="#错误上报的方法：" class="headerlink" title="错误上报的方法："></a>错误上报的方法：</h3><ul>
<li>一：Ajax上传，Ajax上报就是在上文注释错误捕获的地方发起Ajax请求，来向服务器发送错误信息。</li>
<li>二：利用Image对象发送信息(new Image()).src=”<a href="http://post.error.com?data=xxx&quot;" target="_blank" rel="noopener">http://post.error.com?data=xxx&quot;</a></li>
<li>跨域js文件错误是否可以捕获：<br>   答案是可以，错误提示是   script error<br>解决办法，跨域js文件获取是有限制的，如果想获取其他域下的js错误需要在script标签里添加crossorigin属性，然后服务器端要设置header(‘Access-Control-Allow-Origin: *’),或者 指定域名。</li>
</ul>
<p>上面差不多是我对前端代码监控的一些理解，说起来容易，但是一旦在工程化运用，难免需要考虑到兼容性等种种问题，读者可以通过自己的具体情况进行调整，前端代码异常监控对于我们的网站的稳定性起着至关重要的作用。如若文中所有不对的地方，还望指正。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/14/JavaScript函数柯里化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/14/JavaScript函数柯里化/" itemprop="url">JavaScript函数柯里化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-14T20:00:52+08:00">
                2016-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h2><h2 id="官方的说法"><a href="#官方的说法" class="headerlink" title="官方的说法"></a>官方的说法</h2><p>在计算机科学中，<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%259F%25AF%25E9%2587%258C%25E5%258C%2596" target="_blank" rel="noopener">柯里化</a>（英语：<code>Currying</code>），又译为<code>卡瑞化</code>或<code>加里化</code>，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由<code>克里斯托弗·斯特雷奇</code>以逻辑学家<code>哈斯凯尔·加里</code>命名的，尽管它是<code>Moses Schönfinkel</code>和<code>戈特洛布·弗雷格发明的</code>。</p>
<p>在直觉上，柯里化声称如果你固定某些参数，你将得到接受余下参数的一个函数。</p>
<p>在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的<code>lambda</code>演算中，研究带有多个参数的函数的方式。</p>
<p>函数柯里化的对偶是<code>Uncurrying</code>，一种使用匿名单参数函数来实现多参数函数的方法。</p>
<h2 id="方便的理解"><a href="#方便的理解" class="headerlink" title="方便的理解"></a>方便的理解</h2><blockquote>
<p>Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
</blockquote>
<p>如果我们需要实现一个求三个数之和的函数：</p>
<pre><code>function add(x, y, z) {
  return x + y + z;
}
console.log(add(1, 2, 3)); // 6
var add = function(x) {
  return function(y) {
    return function(z) {
      return x + y + z;
    }
  }
}

var addOne = add(1);
var addOneAndTwo = addOne(2);
var addOneAndTwoAndThree = addOneAndTwo(3);

console.log(addOneAndTwoAndThree);
</code></pre><p>这里我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的<code>curry</code>帮助函数（<code>helper function</code>）使这类函数的定义和调用更加容易。</p>
<p>用<code>ES6</code>的箭头函数，我们可以将上面的<code>add</code>实现成这样：</p>
<pre><code>const add = x =&gt; y =&gt; z =&gt; x + y + z;
</code></pre><p>好像使用箭头函数更清晰了许多。</p>
<h2 id="偏函数？"><a href="#偏函数？" class="headerlink" title="偏函数？"></a>偏函数？</h2><p>来看这个函数：</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}
</code></pre><p>有这样的一个场景：我们需要对多个不同的接口发起<code>HTTP</code>请求，有下列两种做法：</p>
<ul>
<li>在调用<code>ajax()</code>函数时，传入全局<code>URL</code>常量。</li>
<li>创建一个已经预设<code>URL</code>实参的函数引用。</li>
</ul>
<p>下面我们创建一个新函数，其内部仍然发起<code>ajax()</code>请求，此外在等待接收另外两个实参的同时，我们手动将<code>ajax()</code>第一个实参设置成你关心的<code>API</code>地址。</p>
<p>对于第一种做法，我们可能产生如下调用方式：</p>
<pre><code>function ajaxTest1(data, callback) {
  ajax(&apos;http://www.test.com/test1&apos;, data, callback);
}

function ajaxTest2(data, callback) {
  ajax(&apos;http://www.test.com/test2&apos;, data, callback);
}
</code></pre><p>对于这两个类似的函数，我们还可以提取出如下的模式：</p>
<pre><code>function beginTest(callback) {
  ajaxTest1({
    data: GLOBAL_TEST_1,
  }, callback);
}
</code></pre><p>相信您已经看到了这样的模式：我们在函数调用现场（<code>function call-site</code>），将实参应用（<code>apply</code>） 于形参。如你所见，我们一开始仅应用了部分实参 —— 具体是将实参应用到<code>URL</code>形参 —— 剩下的实参稍后再应用。</p>
<p>上述概念即为偏函数的定义，偏函数一个减少函数参数个数的过程；这里的参数个数指的是希望传入的形参的数量。我们通过<code>ajaxTest1()</code>把原函数<code>ajax()</code>的参数个数从<code>3</code>个减少到了<code>2</code>个。</p>
<p>我们这样定义一个<code>partial()</code>函数：</p>
<pre><code>function partial(fn, ...presetArgs) {
  return function partiallyApplied(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  }
}
</code></pre><p><code>partial()</code>函数接收<code>fn</code>参数，来表示被我们偏应用实参（<code>partially apply</code>）的函数。接着，<code>fn</code>形参之后，<code>presetArgs</code>数组收集了后面传入的实参，保存起来稍后使用。</p>
<p>我们创建并<code>return</code>了一个新的内部函数（为了清晰明了，我们把它命名为<code>partiallyApplied(..)</code>），该函数中，<code>laterArgs</code>数组收集了全部实参。</p>
<p>使用箭头函数，则更为简洁：</p>
<pre><code>var partial =
  (fn, ...presetArgs) =&gt;
    (...laterArgs) =&gt;
      fn(...presetArgs, ...laterArgs);
</code></pre><p>使用偏函数的这种模式，我们重构之前的代码：</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}

var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);
var ajaxTest2 = partial(ajax, &apos;http://www.test.com/test1&apos;);
</code></pre><p>再次思考<code>beginTest()</code>函数，我们使用<code>partial()</code>来重构它应该怎么做呢？</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}

// 版本1
var beginTest = partial(ajax, &apos;http://www.test.com/test1&apos;, {
  data: GLOBAL_TEST_1,
});

// 版本2
var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);
var beginTest = partial(ajaxTest1, {
  data: GLOBAL_TEST_1,
});
</code></pre><h2 id="一次传一个"><a href="#一次传一个" class="headerlink" title="一次传一个"></a>一次传一个</h2><p>相信你已经在上述例子中看到了版本2比起版本1的优势所在了，没错，柯里化就是：将一个带有多个参数的函数转换为一次一个的函数的过程。每次调用函数时，它只接受一个参数，并返回一个函数，直到传递所有参数为止。</p>
<blockquote>
<p>The process of converting a function that takes multiple arguments into a function that takes them one at a time.</p>
<p>Each time the function is called it only accepts one argument and returns a function that takes one argument until all arguments are passed.</p>
</blockquote>
<p>假设我们已经创建了一个柯里化版本的<code>ajax()</code>函数<code>curriedAjax()</code>：</p>
<pre><code>curriedAjax(&apos;http://www.test.com/test1&apos;)
  ({
    data: GLOBAL_TEST_1,
  })
  (function callback(data) {
    // dosomething
  });
</code></pre><p>我们将三次调用分别拆解开来，这也许有助于我们理解整个过程：</p>
<pre><code>var ajaxTest1 = curriedAjax(&apos;http://www.test.com/test1&apos;);

var beginTest = ajaxTest1({
  data: GLOBAL_TEST_1,
});

var ajaxCallback = beginTest(function callback(data) {
  // dosomething
});
</code></pre><h2 id="实现柯里化"><a href="#实现柯里化" class="headerlink" title="实现柯里化"></a>实现柯里化</h2><p>那么，我们如何来实现一个自动的柯里化的函数呢？</p>
<pre><code>var currying = function(fn) {
  var args = [];

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}
</code></pre><p>调用上述<code>currying()</code>函数：</p>
<pre><code>var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = currying(cost);

cost(100); // 传入了参数，不真正求值
cost(200); // 传入了参数，不真正求值
cost(300); // 传入了参数，不真正求值

console.log(cost()); // 求值并且输出600
</code></pre><p>上述函数是我之前的<a href="http://link.zhihu.com/?target=https%3A//github.com/xingbofeng/JavaScript-design-patterns/blob/master/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0.md%23currying" target="_blank" rel="noopener">JavaScript设计模式与开发实践读书笔记之闭包与高阶函数</a>所写的<code>currying</code>版本，现在仔细思考后发现仍旧有一些问题。</p>
<blockquote>
<p>我们在使用柯里化时，要注意同时为函数预传的参数的情况。</p>
</blockquote>
<p>因此把上述柯里化函数更改如下：</p>
<pre><code>var currying = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}
</code></pre><p>使用实例：</p>
<pre><code>var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = currying(cost, 100);
cost(200); // 传入了参数，不真正求值
cost(300); // 传入了参数，不真正求值

console.log(cost()); // 求值并且输出600
</code></pre><p>你可能会觉得每次都要在最后调用一下不带参数的<code>cost()</code>函数比较麻烦，并且在<code>cost()</code>函数都要使用<code>arguments</code>参数不符合你的预期。我们知道函数都有一个<code>length</code>属性，表明函数期望接受的参数个数。因此我们可以充分利用预传参数的这个特点。</p>
<p>借鉴自<a href="http://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">mqyqingfeng</a>：</p>
<pre><code>function sub_curry(fn) {
  var args = [].slice.call(arguments, 1);
  return function() {
    return fn.apply(this, args.concat([].slice.call(arguments)));
  };
}

function curry(fn, length) {

  length = length || fn.length;

  var slice = Array.prototype.slice;

  return function() {
    if (arguments.length &lt; length) {
      var combined = [fn].concat(slice.call(arguments));
      return curry(sub_curry.apply(this, combined), length - arguments.length);
    } else {
      return fn.apply(this, arguments);
    }
  };
}
</code></pre><p>在上述函数中，我们在currying的返回函数中，每次把<code>arguments.length</code>和<code>fn.length</code>作比较，一旦<code>arguments.length</code>达到了<code>fn.length</code>的数量，我们就去调用<code>fn</code>(<code>return fn.apply(this, arguments);</code>)</p>
<p>验证：</p>
<pre><code>var fn = curry(function(a, b, c) {
  return [a, b, c];
});

fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><h2 id="bind方法的实现"><a href="#bind方法的实现" class="headerlink" title="bind方法的实现"></a>bind方法的实现</h2><p>使用柯里化，能够很方便地借用<code>call()</code>或者<code>apply()</code>实现<code>bind()</code>方法的<code>polyfill</code>。</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function(context) {
  var me = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var innerArgs = Array.prototype.slice.call(arguments);
    var finalArgs = args.concat(innerArgs);
    return me.apply(contenxt, finalArgs);
  }
}
</code></pre><p>上述函数有的问题在于不能兼容构造函数。我们通过判断this指向的对象的原型属性，来判断这个函数是否通过<code>new</code>作为构造函数调用，来使得上述<code>bind</code>方法兼容构造函数。</p>
<p><a href="http://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind() by MDN</a>如下说到：</p>
<blockquote>
<p>绑定函数适用于用new操作符 new 去构造一个由目标函数创建的新的实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。然而, 原先提供的那些参数仍然会被前置到构造函数调用的前面。</p>
</blockquote>
<p>这是<a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/10733304/" target="_blank" rel="noopener">基于MVC的JavaScript Web富应用开发</a>的<code>bind()</code>方法实现：</p>
<pre><code>Function.prototype.bind = function(oThis) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
  }

  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function() {},
    fBound = function() {
      return fToBind.apply(
        this instanceof fNOP &amp;&amp; oThis ? this : oThis || window,
        aArgs.concat(Array.prototype.slice.call(arguments))
      );
    };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
</code></pre><h2 id="反柯里化（uncurrying）"><a href="#反柯里化（uncurrying）" class="headerlink" title="反柯里化（uncurrying）"></a>反柯里化（uncurrying）</h2><p>可能遇到这种情况：拿到一个柯里化后的函数，却想要它柯里化之前的版本，这本质上就是想将类似<code>f(1)(2)(3)</code>的函数变回类似<code>g(1,2,3)</code>的函数。</p>
<p>下面是简单的<code>uncurrying</code>的实现方式：</p>
<pre><code>function uncurrying(fn) {
  return function(...args) {
    var ret = fn;

    for (let i = 0; i &lt; args.length; i++) {
      ret = ret(args[i]); // 反复调用currying版本的函数
    }

    return ret; // 返回结果
  };
}
</code></pre><blockquote>
<p>注意，不要以为uncurrying后的函数和currying之前的函数一模一样，它们只是行为类似！</p>
</blockquote>
<pre><code>var currying = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}

function uncurrying(fn) {
  return function(...args) {
    var ret = fn;

    for (let i = 0; i &lt; args.length; i++) {
      ret = ret(args[i]); // 反复调用currying版本的函数
    }

    return ret; // 返回结果
  };
}

var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var curryingCost = currying(cost);
var uncurryingCost = uncurrying(curryingCost);
console.log(uncurryingCost(100, 200, 300)()); // 600
</code></pre><h2 id="柯里化或偏函数有什么用？"><a href="#柯里化或偏函数有什么用？" class="headerlink" title="柯里化或偏函数有什么用？"></a>柯里化或偏函数有什么用？</h2><p>无论是柯里化还是偏应用，我们都能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。</p>
<p>另一个最能体现柯里化应用的的是，当函数只有一个形参时，我们能够比较容易地组合它们（<code>单一职责原则（Single responsibility principle）</code>）。因此，如果一个函数最终需要三个实参，那么它被柯里化以后会变成需要三次调用，每次调用需要一个实参的函数。当我们组合函数时，这种单元函数的形式会让我们处理起来更简单。</p>
<p>归纳下来，主要为以下常见的三个用途：</p>
<ul>
<li>延迟计算</li>
<li>参数复用</li>
<li>动态生成函数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/08/HTML5的Websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/HTML5的Websocket/" itemprop="url">HTML5的Websocket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-08T22:18:50+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>先请来TA的邻居：*<br>http：无状态、基于tcp请求/响应模式的应用层协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么）tcp：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) 传输层协议。（看啊，大阅兵，如此规整有秩序）</li>
</ul>
</blockquote>
<h2 id="为什么要引入Websocket："><a href="#为什么要引入Websocket：" class="headerlink" title="为什么要引入Websocket："></a>为什么要引入Websocket：</h2><blockquote>
<p>RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。</p>
</blockquote>
<p>long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。</p>
<p><img src="https://pic3.zhimg.com/v2-b900392bfe564de524ec5460a2b5d235_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b900392bfe564de524ec5460a2b5d235_hd.jpg" alt=""></p>
<p>从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p>
<p>这个时候，Websocket出现了。</p>
<h2 id="Websocket是什么："><a href="#Websocket是什么：" class="headerlink" title="Websocket是什么："></a>Websocket是什么：</h2><blockquote>
<p>RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。</p>
</blockquote>
<p>对，划重点：双向通信</p>
<p>Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以主动向客户端推送消息。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。</p>
<p>其特点：</p>
<p>（1）握手阶段采用 HTTP 协议，默认端口是80和443</p>
<p>（2）建立在TCP协议基础之上，和http协议同属于应用层</p>
<p>（4）可以发送文本，也可以发送二进制数据</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信</p>
<p>（6）协议标识符是ws（如果加密，为wss），如ws://localhost:8023</p>
<p>简单来说，Websocket协议分为两部分：握手和数据传输。</p>
<p><img src="https://pic2.zhimg.com/v2-5b1e92b99d352ba977f69cbe28604ecf_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5b1e92b99d352ba977f69cbe28604ecf_hd.jpg" alt=""></p>
<h2 id="Websocket-API："><a href="#Websocket-API：" class="headerlink" title="Websocket API："></a>Websocket API：</h2><blockquote>
<p>这里是指客户端 API。</p>
</blockquote>
<h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><ol>
<li><code>通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。</code></li>
<li><code>const ws =`</code>new<code></code>WebSocket(‘ws://localhost:8023’);`</li>
</ol>
<h2 id="Websocket事件"><a href="#Websocket事件" class="headerlink" title="Websocket事件"></a>Websocket事件</h2><ol>
<li><code>WebSocket`</code>是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。`</li>
</ol>
<p>open:</p>
<p>服务端响应WebSocket连接请求，就会触发open事件。onopen是响应的回调函数。</p>
<p><code>// 连接请求open事件处理：</code></p>
<pre><code>ws.onopen=e=&gt;{
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果要指定多个回调函数，可以使用addEventListener方法。</p>
<pre><code>ws.addEventListener(&apos;open&apos;, e =&gt; {
 ws.send(`Hello ${e}`);
});
</code></pre><p>当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。</p>
<p>Message:</p>
<p>收到服务器数据，会触发消息事件，onmessage是响应的回调函数。如下：</p>
<pre><code>// 接受文本消息的事件处理：
ws.onmessage = e =&gt; {
const data = e.data;
if (typeof data === &quot;string&quot;) {
       console.log(&quot;Received string message &quot;,data);
} else if (data instanceof Blob) {
       console.log(&quot;Received blob message &quot;, data);
}
};
</code></pre><p>服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p>
<p>Error</p>
<p>发生错误会触发error事件, onerror是响应的回调函数, 会导致连接关闭。</p>
<pre><code>//异常处理
ws.onerror = e =&gt; {
   console.log(&quot;WebSocket Error: &quot; , e);
   handleErrors(e);
};
</code></pre><p>当连接关闭时触发close事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再通信。</p>
<p>WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧）</p>
<pre><code>//关闭连接处理
ws.onclose = e =&gt; {
const code = e.code;
const reason = e.reason;
   console.log(&quot;Connection close&quot;, code, reason);
};
</code></pre><h2 id="WebSocket-方法："><a href="#WebSocket-方法：" class="headerlink" title="WebSocket 方法："></a>WebSocket 方法：</h2><blockquote>
<p>WebSocket 对象有两个方法：send 和 close</p>
</blockquote>
<p>send:</p>
<p>客户端和服务器建立连接后，可以调用send方法去发送消息。</p>
<pre><code>//发送一个文本消息
ws.send(&quot;this is websocket&quot;);
</code></pre><p>在open事件的回调中调用send()方法传送数据：</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;);
ws.onopen = e =&gt; {
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState.</p>
<p>close</p>
<p>close方法用来关闭连接。调用close方法后，将不能发送数据。close方法可以传入两个可选的参数，code 和reason, 以告诉服务端为什么终止连接。</p>
<pre><code>ws.close();

//1000是状态码，代表正常结束。
ws.close(1000, &quot;Closing normally&quot;);
</code></pre><h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><ul>
<li>readyState：</li>
</ul>
<p>readyState值表示连接状态，是只读属性。它有以下四个值：</p>
<blockquote>
<p>WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开</p>
</blockquote>
<p>除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。</p>
<pre><code>function bindEventHandler(data) {
if (ws.readyState === WebSocket.OPEN) {
       ws.send(data);
} else {
//do something
}
} 
</code></pre><p>bufferedAmount：</p>
<p>当客户端传输大量数据时，浏览器会缓存将要流出的数据，bufferedAmount属性可判断有多少字节的二进制数据没有发送出去，发送是否结束。</p>
<pre><code>ws.onopen = function () {
   setInterval( function() {
//缓存未满的时候发送
if (ws.bufferedAmount &lt; 1024 * 5) {
           ws.send(data);
}
}, 2000);
};
</code></pre><p>protocol：</p>
<p>protocol代表客户端使用的WebSocket协议。当握手协议未成功，这个属性是空。</p>
<ul>
<li>接下来，我们说说握手阶段过程。*</li>
</ul>
<p>当我们创建Websocket实例对象与服务器建立连接时，</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;)；
</code></pre><p>首先客户端向服务器发起一个握手请求，其请求报文的内容如下：</p>
<pre><code>GET /game HTTP/1.1
Host: 10.242.17.102:8023
Cache-Control: no-cache
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Protocol: game
Sec-WebSocket-Version: 10
Origin: http://192.168.185.16
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
</code></pre><p>从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。</p>
<ul>
<li>Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。</li>
<li>Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信</li>
<li>Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议</li>
<li>Sec-WebSocket-Version: 通知服务器所使用的协议版本</li>
</ul>
<p>服务器响应：</p>
<pre><code>当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。 
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ=
</code></pre><ul>
<li>101 状态码，表示要转换协议啦</li>
<li>Upgrde: 通知客户端将要升级成Websocket协议</li>
<li>Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-05e821d0db32cf8cb5ebf51625870cb1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-05e821d0db32cf8cb5ebf51625870cb1_hd.jpg" alt=""></p>
<p>至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/25/移动端H5页面返回并且刷新页面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/25/移动端H5页面返回并且刷新页面/" itemprop="url">移动端H5页面返回并且刷新页面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-25T20:08:31+08:00">
                2016-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目中的需求：点击浏览器中的返回按钮，要让页面重新加载资源。因为这部分的资源每次去加载的内容都不一样，如果返回的时候，还是看到原先的内容，那做这个内容块的意义就很小了；而如果用户看完了这部分内容，再返回来的时候，这个地方换成了新的内容，这样就能体现这部分的价值了。</p>
<p>而对于浏览器来说，大部分浏览器的返回是直接使用缓存的，不会执行任何的javascript代码。原因：部分浏览器在后退时不会触发onload事件，這是HTML5世代浏览器新增的特性之一——Back-Forward Cache(简称bfcache)</p>
<p><strong>什么是bfcache？</strong></p>
<p>bfcache，即back-forward cache，可称为“往返缓存”，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存不仅保存页面数据，还保存了DOM和JS的状态，实际上是将整个页面都保存在内存里。如果页面位于bfcache中，那么再次打开该页面就不会触发onload事件</p>
<h3 id="pageshow事件"><a href="#pageshow事件" class="headerlink" title="pageshow事件"></a>pageshow事件</h3><p>这个事件在用户浏览网页时触发，pageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， pageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发。</p>
<h3 id="pagehide事件"><a href="#pagehide事件" class="headerlink" title="pagehide事件"></a>pagehide事件</h3><p>该事件会在用户离开网页时触发。离开网页有多种方式。如点击一个链接，刷新页面，提交表单，关闭浏览器等。pagehide 事件有时可以替代 unload事件，但 unload 事件触发后无法缓存页面。</p>
<h3 id="persisted属性"><a href="#persisted属性" class="headerlink" title="persisted属性"></a>persisted属性</h3><p>pageshow事件和pagehide事件的event对象还包含一个名为persisted的布尔值属性。</p>
<ul>
<li>对于pageshow事件，如果页面是从bfcache中加载的，则这个属性的值为true；否则，这个属性的值为false。</li>
<li>对于pagehide事件，如果页面在卸载之后被保存在bfcache中，则这个属性的值为true；否则，这个属性的值为false。</li>
</ul>
<p>不同的浏览器在对当前窗口‘打开’历史记录中的前一个页面的表现上并不统一，这和浏览器的实现以及页面本身的设置有关系。</p>
<p><strong>解决方案：</strong></p>
<p><strong>javascript监听pageshow事件阻止页面进入bfcache</strong></p>
<pre><code> window.addEventListener(&apos;pageshow&apos;, function (e) {
     if (e.persisted) {
         window.location.reload()
     }
})
</code></pre><p>在uc和微信中测试通过，但是在某些安卓手机自带的浏览器中无效。</p>
<p><strong>javascript监听pagehide事件阻止页面进入bfcache</strong></p>
<pre><code>window.addEventListener(&apos;pagehide&apos;, function (e) {
    var dom = document.body;
    dom.children.remove();
    setTimeout(function () {
        dom.appendChild(&quot;&lt;script type=&apos;text/javascript&apos;&gt;window.location.reload();&lt;\/script&gt;&quot;);
    });
});
</code></pre><p><strong>设置meta标签，清除页面缓存</strong></p>
<pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt;
&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;
&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;
</code></pre><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下<br>Public指示响应可被任何缓存区缓存<br>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。<br>注：有些情况下设置清除缓存也没有起到作用，我自己做的这个h5页面就没有起到效果。具体情况还是要具体分析。</p>
<p><strong>我遇到的情况：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">     &lt;iframe id=&quot;iframe&quot; src=&quot;https://cpu.baidu.com/xx/xx/xxx&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个iframe中的地址每次刷新页面都会有不同的内容推送给用户。进入iframe中的内容之后，按返回按钮返回来想进行页面自动刷新，为的就是让用户看到新的内容。</p>
<p>做法：</p>
<p>使用pageshow进行整个页面刷新</p>
<pre><code>window.addEventListener(&apos;pageshow&apos;, function (e) {
    if (e.persisted) {
        window.location.reload()
    }
})
</code></pre><p>这样可以实现。</p>
<p>后面又觉得不妥，没有因为这个小部分而进行整个页面刷新，想到了另一种思路：因为这个iframe中的内容是动态的，可以对其进行定时器设置，如下：</p>
<pre><code>let iframe = document.getElementById(&apos;iframe&apos;)
setInterval(() =&gt; {
    iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
},15000)
</code></pre><p>这样也可以实现自己的功能。</p>
<p>最后可以结合一下：</p>
<pre><code>let iframe = document.getElementById(&apos;iframe&apos;)
window.addEventListener(&apos;pageshow&apos;, function (e) {
    if (e.persisted) {
        iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
    }
})
</code></pre><p>这样做也有好处，可以避免使用定时器，对网页的性能也是比较好。但是这个方法在返回的时候，可以看到iframe里面内容的重新加载，会有一个时间间隙。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">86</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


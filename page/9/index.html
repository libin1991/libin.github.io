<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="舞动乾坤">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="舞动乾坤">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="舞动乾坤">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/9/">





  <title>舞动乾坤 - 男儿欲遂青云志           需信人间红粉空</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">舞动乾坤</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">男儿欲遂青云志           需信人间红粉空</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/03/Event-Loop-必知必会（六道题）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/03/Event-Loop-必知必会（六道题）/" itemprop="url">Event Loop 必知必会（六道题）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-03T11:48:09+08:00">
                2017-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一直想写一篇关于 Event Loop 的文章，前不久发现 CNode 上有位同学写了一篇原理分析的<a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/5a9108d78d6e16e56bb80882%235a98d9a2ce1c90bc44c445af" target="_blank" rel="noopener">文章</a>很详细，这里我就不献丑了。本文就拿出六道题来补充一下，放出一张我认为非常直观的图。<br><img src="https://pic4.zhimg.com/v2-3a59c624e6ff95a7e8c5a23c979f5abe_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3a59c624e6ff95a7e8c5a23c979f5abe_hd.jpg" alt=""><br>绿色小块是 macrotask（宏任务），macrotask 中间的粉红箭头是 microtask（微任务）。</p>
<h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><pre><code>setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate
setTimeout
</code></pre><p>或者：</p>
<pre><code>setTimeout
setImmediate
</code></pre><p>为什么结果不确定呢？</p>
<p>解释：setTimeout/setInterval 的第二个参数取值范围是：[1, 2^31 - 1]，如果超过这个范围则会初始化为 1，即 setTimeout(fn, 0) === setTimeout(fn, 1)。我们知道 setTimeout 的回调函数在 timer 阶段执行，setImmediate 的回调函数在 check 阶段执行，event loop 的开始会先检查 timer 阶段，但是在开始之前到 timer 阶段会消耗一定时间，所以就会出现两种情况：</p>
<ol>
<li>timer 前的准备时间超过 1ms，满足  loop-&gt;time &gt;= 1，则执行 timer 阶段（setTimeout）的回调函数</li>
<li>timer 前的准备时间小于 1ms，则先执行 check 阶段（setImmediate）的回调函数，下一次 event loop 执行 timer 阶段（setTimeout）的回调函数</li>
</ol>
<p>再看个例子：</p>
<pre><code>setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})conststart=Date.now()while(Date.now()-start&lt;10);
</code></pre><p>运行结果一定是：</p>
<pre><code>setTimeout
setImmediate
</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><pre><code>constfs=require(&apos;fs&apos;)fs.readFile(__filename,()=&gt;{setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate
setTimeout
</code></pre><p>解释：fs.readFile 的回调函数执行完后：</p>
<ol>
<li>注册 setTimeout 的回调函数到 timer 阶段</li>
<li>注册 setImmediate 的回调函数到 check 阶段</li>
<li>event loop 从 pool 阶段出来继续往下一个阶段执行，恰好是 check 阶段，所以 setImmediate 的回调函数先执行</li>
<li>本次 event loop 结束后，进入下一次 event loop，执行 setTimeout 的回调函数</li>
</ol>
<p>所以，在 I/O Callbacks 中注册的 setTimeout 和 setImmediate，永远都是 setImmediate 先执行。</p>
<h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><pre><code>setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)process.nextTick(functiontick(){process.nextTick(tick)})
</code></pre><p>运行结果：setInterval 永远不会打印出来。</p>
<p>解释：process.nextTick 会无限循环，将 event loop 阻塞在 microtask 阶段，导致 event loop 上其他 macrotask 阶段的回调函数没有机会执行。</p>
<p>解决方法通常是用 setImmediate 替代 process.nextTick，如下：</p>
<pre><code>setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)setImmediate(functionimmediate(){setImmediate(immediate)})
</code></pre><p>运行结果：每 100ms 打印一次 setInterval。</p>
<p>解释：process.nextTick 内执行 process.nextTick 仍然将 tick 函数注册到当前 microtask 的尾部，所以导致 microtask 永远执行不完； setImmediate 内执行 setImmediate 会将 immediate 函数注册到下一次 event loop 的 check 阶段，而不是当前正在执行的 check 阶段，所以给了 event loop 上其他 macrotask 执行的机会。</p>
<p>再看个例子：</p>
<pre><code>setImmediate(()=&gt;{console.log(&apos;setImmediate1&apos;)setImmediate(()=&gt;{console.log(&apos;setImmediate2&apos;)})process.nextTick(()=&gt;{console.log(&apos;nextTick&apos;)})})setImmediate(()=&gt;{console.log(&apos;setImmediate3&apos;)})
</code></pre><p>运行结果：</p>
<pre><code>setImmediate1
setImmediate3
nextTick
setImmediate2
</code></pre><p>注意：并不是说 setImmediate 可以完全替代 process.nextTick，process.nextTick 在特定场景下还是无法被替代的，比如我们就想将一些操作放到最近的 microtask 里执行。</p>
<h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><pre><code>constpromise=Promise.resolve().then(()=&gt;{returnpromise})promise.catch(console.error)
</code></pre><p>运行结果：</p>
<pre><code>TypeError: Chaining cycle detected for promise #&lt;Promise&gt;
    at &lt;anonymous&gt;
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3
</code></pre><p>解释：promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码会导致死循环，类似前面提到的：</p>
<pre><code>process.nextTick(functiontick(){process.nextTick(tick)})
</code></pre><p>再看个例子：</p>
<pre><code>constpromise=Promise.resolve()
promise.then(()=&gt;{
  console.log(&apos;promise&apos;)})
  process.nextTick(()=&gt;{
      console.log(&apos;nextTick&apos;)
  })
</code></pre><p>运行结果：</p>
<pre><code>nextTick
promise
</code></pre><p>解释：promise.then 虽然和 process.nextTick 一样，都将回调函数注册到 microtask，但优先级不一样。process.nextTick 的 microtask queue 总是优先于 promise 的 microtask queue 执行。</p>
<h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><pre><code>setTimeout(()=&gt;{
    console.log(1)
},0)
newPromise((resolve,reject)=&gt;{
   console.log(2)
   for(leti=0;i&lt;10000;i++){
     i===9999&amp;&amp;resolve()
   }
   console.log(3)
}).then(()=&gt;{
   console.log(4)
})
console.log(5)
</code></pre><p>运行结果：</p>
<p>解释：Promise 构造函数是同步执行的，所以先打印 2、3，然后打印 5，接下来 event loop 进入执行 microtask 阶段，执行 promise.then 的回调函数打印出 4，然后执行下一个 macrotask，恰好是 timer 阶段的 setTimeout 的回调函数，打印出 1。</p>
<h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><pre><code>setImmediate(()=&gt;{
    console.log(1)
    setTimeout(()=&gt;{
       console.log(2)
    },100)
    setImmediate(()=&gt;{
       console.log(3)
    })
    process.nextTick(
       ()=&gt;{console.log(4)})
     })
     process.nextTick(()=&gt;{
       console.log(5)
       setTimeout(()=&gt;{
        console.log(6)},100)
        setImmediate(()=&gt;{
        console.log(7)})
        process.nextTick(
        ()=&gt;{console.log(8)})
        })console.log(9)
</code></pre><p>运行结果：</p>
<p>process.nextTick、setTimeout 和 setImmediate 的组合，请读者自己推理吧。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c" target="_blank" rel="noopener">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">https://cnodejs.org/topic/57d68794cb6f605d360105bf</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/02/CSS如何实现文字两端对齐/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/02/CSS如何实现文字两端对齐/" itemprop="url">CSS如何实现文字两端对齐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-02T23:22:03+08:00">
                2017-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在工作项目中接触到Web界面设计的问题，要实现文字两端对齐的效果。在网上搜索了一下，差不多都是互相转帖，用的都是类似的技巧：</p>
<pre><code>text-align:justify;
text-justify:inter-ideograph;
</code></pre><p>但问题是，我怎么就看不到效果呢？无论是英文还是中文，在IE和chrome下都不起作用。后来，终于在StackOverflow上找到解决方法了。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .arter li {
                font-size: 14px;
                line-height: 24px;
                color: #4a4a4a;
            }

            .arter span {
                height: 24px;
                line-height: 24px;
                width: 65px;
                text-align: justify;
                display: inline-block;
                overflow: hidden;
                vertical-align: top;
            }

            .arter i {
                display: inline-block;
                width: 100%;
                height: 0;
            }




            .arter1 li {
                font-size: 14px;
                line-height: 24px;
                color: #4a4a4a;
            }



            .arter1 span {
                height: 24px;
                line-height: 24px;
                width: 65px;
                text-align: justify;
                display: inline-block;
                overflow: hidden;
                vertical-align: top;
            }
            .arter1 span:after {
                content: &quot; &quot;;
                display: inline-block;
                width: 100%;
                height: 0px;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;ul class=&quot;arter&quot;&gt;
            &lt;li&gt;&lt;span&gt;作品名称&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 宝贝儿&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;作品类型&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;艺术家&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 张玉瀛&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;风格&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 超现实&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;材质&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 布面油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;题材&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 人物&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;创作时间&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 2011&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;所在位置&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 华东&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;尺寸&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 78x78cm&lt;/li&gt;
        &lt;/ul&gt;
        &lt;br /&gt;&lt;br /&gt;
        &lt;ul class=&quot;arter1&quot;&gt;
            &lt;li&gt;&lt;span&gt;作品名称&lt;/span&gt;： 宝贝儿&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;作品类型&lt;/span&gt;： 油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;艺术家&lt;/span&gt;： 张玉瀛&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;风格&lt;/span&gt;： 超现实&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;材质&lt;/span&gt;： 布面油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;题材&lt;/span&gt;： 人物&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;创作时间&lt;/span&gt;： 2011&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;所在位置&lt;/span&gt;： 华东&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;尺寸&lt;/span&gt;： 78x78cm&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>样式：<br><img src="https://pic1.zhimg.com/v2-b92871dee74e80785026c069073206ab_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-b92871dee74e80785026c069073206ab_hd.jpg" alt=""><br>从效果图可以看到，除了要在块级元素加text-align:justify样式外，还需要在里面加一个空的span元素，并应用样式。另外，对于中文还必须用空格隔开汉字，否则也没有两端对齐的效果。英文每个单词都有空格隔开，所以没问题。</p>
<p>但是加入HTML元素又违反了结构表现分离的原则，我们可以改用after、before伪元素：</p>
<pre><code>li:after {
    content: &quot; &quot;;
    display: inline-block;
    width: 100%;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/30/pm2-常用配置及命令/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/30/pm2-常用配置及命令/" itemprop="url">pm2 常用配置及命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T12:11:05+08:00">
                2017-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>如果直接通过node app来启动，如果报错了可能直接停在整个运行，supervisor感觉只是拿来用作开发环境的。再网上找到pm2.目前似乎最常见的线上部署nodejs项目的有forever,pm2这两种。<br>使用场合:</p>
</blockquote>
<ul>
<li>supervisor是开发环境用。</li>
<li>forever管理多个站点，每个站点访问量不大，不需要监控。</li>
<li>nodemon 是开发环境使用，修改自动重启。</li>
<li>pm2 网站访问量比较大,需要完整的监控界面。</li>
</ul>
<p><code>PM2</code> 是 <code>node</code> 进程管理工具，可以利用它来简化很多 <code>node</code> 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。本文就 <code>PM2</code> 进行入门性的介绍，基本涵盖了 <code>PM2</code> 的常用的功能和配置。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure>
<p>如果你的node项目配置文件和以上代码不一样，，，莫急，pm2 也是有办法可以启动的（个人觉得这是一个万能的启动的方法）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm2 start npm -- run XXX</span><br><span class="line">pm2 start npm --watch --name XXX -- run start</span><br></pre></td></tr></table></figure></p>
<p>用她替代：<code>npm run dev</code>，就可以写成：<code>pm2 start npm -- run dev</code>，项目启动：    </p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pm2 start [server.js]</span><br><span class="line"># 启动服务</span><br><span class="line">pm2 list</span><br><span class="line"># 查看当前所跑服务的详情</span><br><span class="line">pm2 show [name]</span><br><span class="line"># 查看更加详细的信息这个命令可查看pm2配置 包括日志文件存放的位置等</span><br><span class="line">pm2 stop [id/name]</span><br><span class="line"># 关闭某个服务</span><br><span class="line">pm2 delete [id/name]</span><br><span class="line"># 删除某个服务</span><br><span class="line">pm2 stop all</span><br><span class="line"># 关闭所有服务</span><br><span class="line">pm2 logs</span><br><span class="line"># 查看实时日志</span><br><span class="line">pm2 restart [name]</span><br><span class="line"># 重新启动服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pm2 logs 显示所有进程日志</span><br><span class="line">$ pm2 stop all 停止所有进程</span><br><span class="line">$ pm2 restart all 重启所有进程</span><br><span class="line">$ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程)</span><br><span class="line">$ pm2 stop 0 停止指定的进程</span><br><span class="line">$ pm2 restart 0 重启指定的进程</span><br><span class="line">$ pm2 startup 产生 init 脚本 保持进程活着</span><br><span class="line">$ pm2 web 运行健壮的 computer API endpoint (http://localhost:9615)</span><br><span class="line">$ pm2 delete 0 杀死指定的进程</span><br><span class="line">$ pm2 delete all 杀死全部进程</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">运行进程的不同方式：</span><br><span class="line">$ pm2 start app.js -i max 根据有效CPU数目启动最大进程数目</span><br><span class="line">$ pm2 start app.js -i 3 启动3个进程</span><br><span class="line">$ pm2 start app.js -x 用fork模式启动 app.js 而不是使用 cluster</span><br><span class="line">$ pm2 start app.js -x -- -a 23 用fork模式启动 app.js 并且传递参数 (-a 23)</span><br><span class="line">$ pm2 start app.js --name serverone 启动一个进程并把它命名为 serverone</span><br><span class="line">$ pm2 stop serverone 停止 serverone 进程</span><br><span class="line">$ pm2 start app.json 启动进程, 在 app.json里设置选项</span><br><span class="line">$ pm2 start app.js -i max -- -a 23 在--之后给 app.js 传递参数</span><br><span class="line">$ pm2 start app.js -i max -e err.log -o out.log 启动 并 生成一个配置文件</span><br></pre></td></tr></table></figure>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>参数说明：</p>
<ul>
<li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</li>
<li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果 <code>-i 0</code> 或者 <code>-i max</code>，则根据当前机器核数确定实例数目。</li>
<li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如 <code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li>
<li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li>
<li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li>
<li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li>
</ul>
<h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><pre><code>pm2 start ./bin/www --watch
#注意，这里用了--watch参数，意味着当你的应用代码发生变化时，pm2会帮你自动重启服务
</code></pre><h2 id="配置及部署"><a href="#配置及部署" class="headerlink" title="配置及部署"></a>配置及部署</h2><p>部署的配置文件示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 数组中放的是需要发布的项目一些变量的定义</span><br><span class="line">  &quot;apps&quot;: [&#123;</span><br><span class="line">    &quot;name&quot;: &quot;xxx&quot;, //项目名称</span><br><span class="line">    &quot;script&quot;: &quot;server.js&quot;, //用来启动的脚本</span><br><span class="line">    // &quot;instances&quot;:2,</span><br><span class="line">    // 启动项目所需要的环境变量</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;COMMON_VARIABLE&quot;: &quot;true&quot;, //设置为true 可以在启动的时传入外部的变量进去</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;env_production&quot;: &#123;</span><br><span class="line">      &quot;NODE_ENV&quot;: &quot;production&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  // 部署</span><br><span class="line">  &quot;deploy&quot;: &#123;</span><br><span class="line">    &quot;production&quot;: &#123;</span><br><span class="line">      &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">      &quot;host&quot;: &quot;0.0.0.0&quot;, //可以是数组 部署到多台主机</span><br><span class="line">      &quot;ref&quot;: &quot;origin/master&quot;, //选择拿哪个个分支的代码</span><br><span class="line">      &quot;repo&quot;: &quot;git@github.com:ihoey/hitalk.git&quot;, //仓库地址</span><br><span class="line">      &quot;path&quot;: &quot;/root/www/hitalk/production&quot;, //要发布到服务器上哪个目录下面</span><br><span class="line">      &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, //避免key验证导致代码更新到远程仓库失败</span><br><span class="line">      &quot;post-deploy&quot;: &quot;source ~/.nvm/nvm.sh &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;, //发布之后执行的动作 执行开启或更新pm2运行的服务</span><br><span class="line">      &quot;pre-deploy-local&quot;: &quot;echo &apos;Deploy Done!&apos;&quot;, //本地发布之前的动作</span><br><span class="line">      &quot;env&quot;: &#123; //指定部署到远程的仓库的环境 是production生产环境</span><br><span class="line">        &quot;NODE_ENV&quot;: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>说明:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apps:json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用</span><br><span class="line">name:应用程序名称</span><br><span class="line">cwd:应用程序所在的目录</span><br><span class="line">script:应用程序的脚本路径</span><br><span class="line">log_date_format:</span><br><span class="line">error_file:自定义应用程序的错误日志文件</span><br><span class="line">out_file:自定义应用程序日志文件</span><br><span class="line">pid_file:自定义应用程序的pid文件</span><br><span class="line">instances:</span><br><span class="line">min_uptime:最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</span><br><span class="line">max_restarts:设置应用程序异常退出重启的次数，默认15次（从0开始计数）</span><br><span class="line">cron_restart:定时启动，解决重启能解决的问题</span><br><span class="line">watch:是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。</span><br><span class="line">merge_logs:</span><br><span class="line">exec_interpreter:应用程序的脚本类型，这里使用的shell，默认是nodejs</span><br><span class="line">exec_mode:应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork</span><br><span class="line">autorestart:启用/禁用应用程序崩溃或退出时自动重启</span><br><span class="line">vizion:启用/禁用vizion特性(版本控制)</span><br></pre></td></tr></table></figure>
<h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>第一次部署</p>
<pre><code>pm2 deploy ecosystem.json production setup
</code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre><code>pm2 deploy ecosystem.json production
</code></pre><p>好了，先记录这么多~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/21/React-setState/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/React-setState/" itemprop="url">React setState</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T20:16:49+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2017/09/21/React-setState/1.webp" alt=""></p>
<blockquote>
<p>面试官：“react中<code>setState</code>是同步的还是异步？”</p>
</blockquote>
<blockquote>
<p>我：“异步的，<code>setState</code>不能立马拿到结果。”</p>
</blockquote>
<blockquote>
<p>面试官：“那什么场景下是异步的，可不可能是同步，什么场景下又是同步的？”</p>
</blockquote>
<blockquote>
<p>我：“……”</p>
</blockquote>
<h3 id="setState真的是异步的吗？"><a href="#setState真的是异步的吗？" class="headerlink" title="setState真的是异步的吗？"></a><code>setState</code>真的是异步的吗？</h3><p>这两天自己简单的看了下 <code>setState</code> 的部分实现代码，在这边给到大家一个自己个人的见解，可能文字或图片较多，没耐心的同学可以直接跳过看总结(<strong>源码版本是16.4.1</strong>)。</p>
<p><strong>看之前，为了方便理解和简化流程，我们默认react内部代码执行到<code>performWork</code><br>、<code>performWorkOnRoot</code>、<code>performSyncWork</code>、<code>performAsyncWork</code>这四个方法的时候，就是react去update更新并且作用到UI上。</strong></p>
<h3 id="一、合成事件中的setState"><a href="#一、合成事件中的setState" class="headerlink" title="一、合成事件中的setState"></a>一、合成事件中的<code>setState</code></h3><p>首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在<code>jsx</code>中常见的<code>onClick</code>、<code>onChange</code>这些都是合成事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line">  increment = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    console.log(this.state.val) // 输出的是更新前的val --&gt; 0</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.increment&#125;&gt;</span><br><span class="line">        &#123;`Counter is: $&#123;this.state.val&#125;`&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>合成事件中的<code>setState</code>写法比较常见，点击事件里去改变 <code>this.state.val</code> 的状态值，在 <code>increment</code> 事件中打个断点可以看到调用栈，这里我贴一张自己画的流程图：<br><img src="/2017/09/21/React-setState/2.webp" alt=""><br>从 <code>dispatchInteractiveEvent</code> 到 <code>callCallBack</code> 为止，都是对合成事件的处理和执行，从 <code>setState</code> 到 <code>requestWork</code> 是调用 <code>this.setState</code> 的逻辑，这边主要看下  <code>requestWork</code> 这个函数（从 <code>dispatchEvent</code> 到 <code>requestWork</code> 的调用栈是属于 <code>interactiveUpdates$1</code> 的 <code>try</code> 代码块，下文会提到）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function requestWork(root, expirationTime) &#123;</span><br><span class="line">  addRootToSchedule(root, expirationTime);</span><br><span class="line"></span><br><span class="line">  if (isRendering) &#123;</span><br><span class="line">    // Prevent reentrancy. Remaining work will be scheduled at the end of</span><br><span class="line">    // the currently rendering batch.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (isBatchingUpdates) &#123;</span><br><span class="line">    // Flush work at the end of the batch.</span><br><span class="line">    if (isUnbatchingUpdates) &#123;</span><br><span class="line">      // ...unless we&apos;re inside unbatchedUpdates, in which case we should</span><br><span class="line">      // flush it now.</span><br><span class="line">      nextFlushedRoot = root;</span><br><span class="line">      nextFlushedExpirationTime = Sync;</span><br><span class="line">      performWorkOnRoot(root, Sync, false);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // TODO: Get rid of Sync and use current time?</span><br><span class="line">  if (expirationTime === Sync) &#123;</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    scheduleCallbackWithExpiration(expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 <code>requestWork</code> 中有三个if分支，三个分支中有两个方法 <code>performWorkOnRoot</code> 和 <code>performSyncWork</code> ，就是我们默认的update函数，但是在合成事件中，走的是第二个if分支，第二个分支中有两个标识 <code>isBatchingUpdates</code> 和 <code>isUnbatchingUpdates</code> 两个初始值都为  <code>false</code> ，但是在 <code>interactiveUpdates$1</code> 中会把 <code>isBatchingUpdates</code> 设为 <code>true</code> ，下面就是 <code>interactiveUpdates$1</code> 的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function interactiveUpdates$1(fn, a, b) &#123;</span><br><span class="line">  if (isBatchingInteractiveUpdates) &#123;</span><br><span class="line">    return fn(a, b);</span><br><span class="line">  &#125;</span><br><span class="line">  // If there are any pending interactive updates, synchronously flush them.</span><br><span class="line">  // This needs to happen before we read any handlers, because the effect of</span><br><span class="line">  // the previous event may influence which handlers are called during</span><br><span class="line">  // this event.</span><br><span class="line">  if (!isBatchingUpdates &amp;&amp; !isRendering &amp;&amp; lowestPendingInteractiveExpirationTime !== NoWork) &#123;</span><br><span class="line">    // Synchronously flush pending interactive updates.</span><br><span class="line">    performWork(lowestPendingInteractiveExpirationTime, false, null);</span><br><span class="line">    lowestPendingInteractiveExpirationTime = NoWork;</span><br><span class="line">  &#125;</span><br><span class="line">  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;</span><br><span class="line">  var previousIsBatchingUpdates = isBatchingUpdates;</span><br><span class="line">  isBatchingInteractiveUpdates = true;</span><br><span class="line">  isBatchingUpdates = true;  // 把requestWork中的isBatchingUpdates标识改为true</span><br><span class="line">  try &#123;</span><br><span class="line">    return fn(a, b);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    if (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">      performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个方法中把 <code>isBatchingUpdates</code> 设为了 <code>true</code> ,导致在 <code>requestWork</code> 方法中， <code>isBatchingUpdates</code> 为 <code>true</code> ，但是 <code>isUnbatchingUpdates</code> 是 <code>false</code> ，而被直接return了。</p>
<p>那return完的逻辑回到哪里呢，最终正是回到了 <code>interactiveUpdates</code> 这个方法，仔细看一眼，这个方法里面有个<a href="https://link.juejin.im?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fgrammar%2Ferror.html%23toc12" target="_blank" rel="noopener">try finally</a>语法，前端同学这个其实是用的比较少的，简单的说就是会先执行 <code>try</code> 代码块中的语句，然后再执行 <code>finally</code> 中的代码，而 <code>fn(a, b)</code> 是在try代码块中，刚才说到在 <code>requestWork</code> 中被return掉的也就是这个fn（上文提到的 <code>从dispatchEvent</code> 到 <code>requestWork</code> 的一整个调用栈）。</p>
<p>所以当你在 <code>increment</code> 中调用 <code>setState</code> 之后去console.log的时候，是属于 <code>try</code> 代码块中的执行，但是由于是合成事件，try代码块执行完state并没有更新，所以你输入的结果是更新前的 <code>state</code> 值，这就导致了所谓的”异步”，但是当你的try代码块执行完的时候（也就是你的increment合成事件），这个时候会去执行 <code>finally</code> 里的代码，在 <code>finally</code> 中执行了 <code>performSyncWork</code> 方法，这个时候才会去更新你的 <code>state</code> 并且渲染到UI上。</p>
<h3 id="二、生命周期函数中的setState"><a href="#二、生命周期函数中的setState" class="headerlink" title="二、生命周期函数中的setState"></a>二、生命周期函数中的<code>setState</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">   console.log(this.state.val) // 输出的还是更新前的值 --&gt; 0</span><br><span class="line"> &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;`Counter is: $&#123;this.state.val&#125;`&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>钩子函数中setState的调用栈：<br><img src="/2017/09/21/React-setState/3.webp" alt=""><br>其实还是和合成事件一样，当 <code>componentDidmount</code> 执行的时候，react内部并没有更新，执行完<code>componentDidmount</code>  后才去 <code>commitUpdateQueue</code> 更新。这就导致你在 <code>componentDidmount</code> 中 <code>setState</code> 完去console.log拿的结果还是更新前的值。</p>
<h3 id="三、原生事件中的setState"><a href="#三、原生事件中的setState" class="headerlink" title="三、原生事件中的setState"></a>三、原生事件中的<code>setState</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    console.log(this.state.val) // 输出的是更新后的值 --&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;, this.changeValue, false)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;`Counter is: $&#123;this.state.val&#125;`&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原生事件是指非react合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生js、jq直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式都属于原生事件。<br><img src="/2017/09/21/React-setState/4.webp" alt=""><br>原生事件的调用栈就比较简单了，因为没有走合成事件的那一大堆，直接触发click事件，到 <code>requestWork</code> ,在<code>requestWork</code>里由于 <code>expirationTime === Sync</code> 的原因，直接走了 <code>performSyncWork</code> 去更新，并不像合成事件或钩子函数中被return，所以当你在原生事件中setState后，能同步拿到更新后的state值。</p>
<h3 id="四、setTimeout中的setState"><a href="#四、setTimeout中的setState" class="headerlink" title="四、setTimeout中的setState"></a>四、setTimeout中的<code>setState</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    setTimeout(_ =&gt; &#123;</span><br><span class="line">      this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">      console.log(this.state.val) // 输出更新后的值 --&gt; 1</span><br><span class="line">    &#125;, 0)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;`Counter is: $&#123;this.state.val&#125;`&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setTimeout</code> 中去 <code>setState</code> 并不算是一个单独的场景，它是随着你外层去决定的，因为你可以在合成事件中 <code>setTimeout</code> ，可以在钩子函数中 <code>setTimeout</code> ，也可以在原生事件<code>setTimeout</code>，但是不管是哪个场景下，基于<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D6XRNXXgP_0" target="_blank" rel="noopener">event loop</a>的模型下， <code>setTimeout</code> 中里去 <code>setState</code> 总能拿到最新的state值。</p>
<p>举个栗子，比如之前的合成事件，由于你是 <code>setTimeout(_ =&gt; { this.setState()}, 0)</code> 是在 <code>try</code> 代码块中,当你 <code>try</code> 代码块执行到 <code>setTimeout</code> 的时候，把它丢到列队里，并没有去执行，而是先执行的 <code>finally</code> 代码块，等 <code>finally</code> 执行完了， <code>isBatchingUpdates</code> 又变为了 <code>false</code> ，导致最后去执行队列里的 <code>setState</code> 时候， <code>requestWork</code> 走的是和原生事件一样的 <code>expirationTime === Sync</code> if分支，所以表现就会和原生事件一样，可以同步拿到最新的state值。</p>
<h3 id="五、setState中的批量更新"><a href="#五、setState中的批量更新" class="headerlink" title="五、setState中的批量更新"></a>五、<code>setState</code>中的批量更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line">  batchUpdates = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.batchUpdates&#125;&gt;</span><br><span class="line">        &#123;`Counter is $&#123;this.state.val&#125;`&#125; // 1</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的结果最终是1，在 <code>setState</code> 的时候react内部会创建一个 <code>updateQueue</code> ，通过 <code>firstUpdate</code> 、 <code>lastUpdate</code> 、 <code>lastUpdate.next</code> 去维护一个更新的队列，在最终的 <code>performWork</code> 中，相同的key会被覆盖，只会对最后一次的 <code>setState</code> 进行更新，下面是部分实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function createUpdateQueue(baseState) &#123;</span><br><span class="line">  var queue = &#123;</span><br><span class="line">    expirationTime: NoWork,</span><br><span class="line">    baseState: baseState,</span><br><span class="line">    firstUpdate: null,</span><br><span class="line">    lastUpdate: null,</span><br><span class="line">    firstCapturedUpdate: null,</span><br><span class="line">    lastCapturedUpdate: null,</span><br><span class="line">    firstEffect: null,</span><br><span class="line">    lastEffect: null,</span><br><span class="line">    firstCapturedEffect: null,</span><br><span class="line">    lastCapturedEffect: null</span><br><span class="line">  &#125;;</span><br><span class="line">  return queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function appendUpdateToQueue(queue, update, expirationTime) &#123;</span><br><span class="line">  // Append the update to the end of the list.</span><br><span class="line">  if (queue.lastUpdate === null) &#123;</span><br><span class="line">    // Queue is empty</span><br><span class="line">    queue.firstUpdate = queue.lastUpdate = update;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    queue.lastUpdate.next = update;</span><br><span class="line">    queue.lastUpdate = update;</span><br><span class="line">  &#125;</span><br><span class="line">  if (queue.expirationTime === NoWork || queue.expirationTime &gt; expirationTime) &#123;</span><br><span class="line">    // The incoming update has the earliest expiration of any update in the</span><br><span class="line">    // queue. Update the queue&apos;s expiration time.</span><br><span class="line">    queue.expirationTime = expirationTime;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="看个demo"><a href="#看个demo" class="headerlink" title="看个demo"></a>看个demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    console.log(this.state.val)</span><br><span class="line"></span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    console.log(this.state.val)</span><br><span class="line"></span><br><span class="line">    setTimeout(_ =&gt; &#123;</span><br><span class="line">      this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">      console.log(this.state.val);</span><br><span class="line"></span><br><span class="line">      this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">      console.log(this.state.val)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;&#123;this.state.val&#125;&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面分析的，钩子函数中的 <code>setState</code> 无法立马拿到更新后的值，所以前两次都是输出0，当执行到 <code>setTimeout</code> 里的时候，前面两个state的值已经被更新，由于 <code>setState</code> 批量更新的策略， <code>this.state.val</code> 只对最后一次的生效，为1，而在 <code>setTimmout</code> 中 <code>setState</code> 是可以同步拿到更新结果，所以 <code>setTimeout</code> 中的两次输出2，3，最终结果就为 <code>0, 0, 2, 3</code> 。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结 :"></a>总结 :</h3><ol>
<li><strong><code>setState</code> 只在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。</strong></li>
<li><strong><code>setState</code>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</strong></li>
<li><strong><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 <code>setState</code> ， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 <code>setState</code> 多个不同的值，在更新时会对其进行合并批量更新。</strong></li>
</ol>
<p>以上就是我看了部分代码后的粗浅理解，对源码细节的那块分析的较少，主要是想让大家理解<code>setState</code>在不同的场景，不同的写法下到底发生了什么样的一个过程和结果，希望对大家有帮助，由于是个人的理解和见解，如果哪里有说的不对的地方，欢迎大家一起指出并讨论。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/Git-必知必会/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/Git-必知必会/" itemprop="url">Git 必知必会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T22:32:36+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Git是目前世界上最先进的分布式版本控制系统。</p>
<p>参考文章：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a54386af265da3e3b7a6317" target="_blank" rel="noopener">如何优雅地使用 Git - 掘金</a></p>
<h2 id="GIT-常见命令学习整理"><a href="#GIT-常见命令学习整理" class="headerlink" title="GIT 常见命令学习整理"></a><a href="https://link.zhihu.com/?target=https%3A//blog.ihoey.com/posts/Git/2017-04-23-git.html" target="_blank" rel="noopener">GIT 常见命令学习整理</a></h2><h2 id="GIT常用命令备忘"><a href="#GIT常用命令备忘" class="headerlink" title="GIT常用命令备忘"></a><a href="https://link.zhihu.com/?target=http%3A//stormzhang.com/git/2014/01/27/git-common-command/" target="_blank" rel="noopener">GIT常用命令备忘</a></h2><h2 id="Git远程操作详解"><a href="#Git远程操作详解" class="headerlink" title="Git远程操作详解"></a><a href="https://link.zhihu.com/?target=https%3A//microzz.com/2017/05/06/git/" target="_blank" rel="noopener">Git远程操作详解</a></h2><h2 id="一篇文章，教你学会Git"><a href="#一篇文章，教你学会Git" class="headerlink" title="一篇文章，教你学会Git"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/599e14875188251240632702" target="_blank" rel="noopener">一篇文章，教你学会Git</a></h2><h2 id="如何在-Git-中使用撤消操作"><a href="#如何在-Git-中使用撤消操作" class="headerlink" title="如何在 Git 中使用撤消操作"></a><a href="https://link.zhihu.com/?target=https%3A//egoist.moe/2015/10/04/how-to-undo-with-git/" target="_blank" rel="noopener">如何在 Git 中使用撤消操作</a></h2><h2 id="git使用中碰到的问题，持续更新"><a href="#git使用中碰到的问题，持续更新" class="headerlink" title="git使用中碰到的问题，持续更新"></a><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/a420344/article/details/51792303" target="_blank" rel="noopener">git使用中碰到的问题，持续更新</a></h2><h2 id="Git-的-4-个阶段的撤销更改"><a href="#Git-的-4-个阶段的撤销更改" class="headerlink" title="Git 的 4 个阶段的撤销更改"></a><a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/akvB2DO_1dpUrf-ol77MwQ" target="_blank" rel="noopener">Git 的 4 个阶段的撤销更改</a></h2><p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a30c1786fb9a045211eb218" target="_blank" rel="noopener">Git提交历史的修改删除合并 - 掘金</a></p>
<h2 id="IDEA中分支切换error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout"><a href="#IDEA中分支切换error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout" class="headerlink" title="IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout"></a><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/tongxinxiao/article/details/43988773" target="_blank" rel="noopener">IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout</a></h2><pre><code>直接执行git clean -d -fx即可。

可能很多人都不明白-d，-fx到底是啥意思，
其实git clean -d -fx表示：删除 一些 没有 git add 的 文件；
    git clean 参数 

    -n 显示将要删除的文件和目录；

    -x -----删除忽略文件已经对git来说不识别的文件

    -d -----删除未被添加到git的路径中的文件

    -f -----强制运行

    git clean -n

    git clean -df

    git clean -f
</code></pre><p><img src="https://pic3.zhimg.com/v2-81f3b33c3cb53387c97135459b92ab3f_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81f3b33c3cb53387c97135459b92ab3f_hd.jpg" alt=""></p>
<pre><code>git reflog        //该指令输出详细的操作历史，包括提交，操作，修改等
修改注释
git commit --amend 或 git commit --amend -m &quot;Fixes bug #42&quot;

gitk 字符集编码：
git config --global gui.encoding utf-8    //在git GUI中使用UTF-8编码 

配置
git config --global user.name &quot;ihoey&quot;           # 设置git用户名
git config --global user.email &quot;mail@ihoey.com&quot; # 设置git邮箱
git config --global color.ui true               # 为true是终端着色

git config --global alias.co checkout           # 配置checkout的别名
git config --global alias.ci commit             # 配置commit的别名
git config --global alias.cm commit             # 配置commit的别名
git config --global alias.st status             # 配置status的别名
git config --global alias.br branch             # 配置branch的别名
git config --global alias.cp cherry-pick        # 配置cherry-pick的别名
 git config --global alias.rb rebase            # 配置rebase的别名

git config --global core.editor &quot;mate -w&quot;       # 设置Editor使用textmate
git config -l                                   # 列举所有配置
#用户的git配置文件~/.gitconfig

SSH 秘钥
ssh-keygen -t rsa -C &quot;mail@ihoey.com&quot;
# 连续3个回车。如果不需要密码的话。
# 最后得到了两个文件：id_rsa和id_rsa.pub，在~/.ssh/文件夹下面
# id_rsa为你的私钥，不可以告诉别人
# id_rsa.pub为你的公钥，一般会放在你的服务器做ssh登录，或者放在github上面

基本命令
创建git仓库 git init
添加文件到暂存区 git add fileName / git add .
提交文件到仓库 git commit -m &quot;版本提交信息&quot;
查看文件提交状态 git status
查看文件修改的信息 git diff readme.txt

git help &lt;command&gt;          # 显示command的help
git show                    # 显示某次提交的内容
git show $id
git checkout  -- &lt;file&gt;     # 抛弃工作区修改
git checkout  .             # 抛弃工作区修改
git add &lt;file&gt;              # 将工作文件修改提交到本地暂存区
git add .                   # 将所有修改过的工作文件提交暂存区
git rm &lt;file&gt;               # 从版本库中删除文件
git rm &lt;file&gt; --cached      # 从版本库中删除文件，但不删除文件
git reset &lt;file&gt;            # 从暂存区恢复到工作文件
git reset -- .              # 从暂存区恢复到工作文件
git reset --hard            # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改
git reset SHA1 ID           # 恢复指定提交
git commit -m &quot;some comments&quot;
git revert &lt;$id&gt;            # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象
git revert HEAD             # 恢复最后一次提交的状态

查看文件
git diff &lt;file&gt;                 # 比较当前文件和暂存区文件差异
git diff
git diff &lt;$id1&gt; &lt;$id2&gt;          # 比较两次提交之间的差异
git diff &lt;branch1&gt;..&lt;branch2&gt;   # 在两个分支之间比较
git diff --staged               # 比较暂存区和版本库差异
git diff --cached               # 比较暂存区和版本库差异
git diff --stat                 # 仅仅比较统计信息

查看提交记录
git log
git log &lt;file&gt;      # 查看该文件每次提交记录
git log -p &lt;file&gt;   # 查看每次详细修改内容的diff
git log -p -2       # 查看最近两次详细修改内容的diff
git log --stat      # 查看提交统计信息

分支管理
git branch -l                           # 查看本地分支
git branch -r                           # 查看远程分支
git branch &lt;new_branch&gt;                 # 创建新的分支
git branch -v                           # 查看各个分支最后提交信息
git branch --merged                     # 查看已经被合并到当前分支的分支
git branch --no-merged                  # 查看尚未被合并到当前分支的分支
git checkout &lt;branch&gt;                   # 切换到某个分支
git checkout -b &lt;new_branch&gt;            # 创建新的分支，并且切换过去
git checkout -b &lt;new_branch&gt; &lt;branch&gt;   # 基于branch创建新的new_branch
git checkout $id       # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除
git checkout $id -b &lt;new_branch&gt;        # 把某次历史提交记录checkout出来，创建成一个分支
git branch -d &lt;branch&gt;                  # 删除某个分支
git branch -D &lt;branch&gt;    # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)

强行切换分支
git checkout -f branch_name

强制checkout分支覆盖本地文件
git checkout -f branchname

分支合并和rebase
git merge &lt;branch&gt;               # 将branch分支合并到当前分支
git merge --no-ff &lt;branch&gt;       # 不要Fast-Foward合并，这样可以生成merge提交
git rebase master &lt;branch&gt;       # 将master rebase到branch，相当于：
git checkout &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge &lt;branch&gt;
</code></pre><ul>
<li>在我们操作过程中。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit 就可以了。</li>
<li><p>而rebase 操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行git rebase –continue继续操作，或者git rebase –skip忽略冲突。</p>
<p>  Git暂存管理<br>  git stash                        # 暂存<br>  git stash pop                    # 恢复暂存<br>  git stash list                   # 列所有stash<br>  git stash apply                  # 恢复暂存的内容<br>  git stash drop                   # 删除暂存区</p>
<p>  git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区<br>  git stash list：查看储藏队列(Stash lists)<br>  git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes))<br>  git stash clear：清空储藏队列<br>  git stash save “name of the stash”：为储藏设置命名<br>  git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏<br>  git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏)</p>
<p>  远程分支管理<br>  git pull                         # 抓取远程仓库所有分支更新并合并到本地<br>  git pull –no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并<br>  git fetch origin                 # 抓取远程仓库更新<br>  git merge origin/master          # 将远程主分支合并到本地当前分支<br>  git checkout –track origin/branch     # 跟踪某个远程分支创建相应的本地分支<br>  git checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;  # 基于远程分支创建本地分支，功能同上<br>  git push                         # push所有分支<br>  git push origin master           # 将本地主分支推到远程主分支<br>  git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)<br>  git push origin &lt;local_branch&gt;   # 创建远程分支， origin是远程仓库名<br>  git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支<br>  git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d <branch>)，然后再push删除远程分支</branch></p>
<p>  git删除远程分支<br>  git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限</p>
<p>  清空git暂存区<br>  git reset HEAD  //可以清空之前git add 的内容</p>
<p>  Git远程仓库管理<br>  git remote -v                    # 查看远程服务器地址和仓库名称<br>  git remote show origin           # 查看远程服务器仓库状态<br>  git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ihoey/blog.git     # 添加远程仓库地址<br>  git remote set-url origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ihoey/blog.git # 设置远程仓库地址(用于修改远程仓库地址)<br>  git remote rm <repository>       # 删除远程仓库</repository></p>
<p>  创建远程仓库<br>  git clone –bare ihoey.com blog.git     # 用带版本的项目创建纯版本仓库<br>  scp -r my_blog.git <a href="mailto:git@ihoey.com" target="_blank" rel="noopener">git@ihoey.com</a>:~      # 将纯仓库上传到服务器上<br>  mkdir blog.git &amp;&amp; cd blog.git &amp;&amp; git –bare init # 在服务器创建纯仓库<br>  git push -u origin master         # 客户端首次提交<br>  git push -u origin develop        # 首次将本地develop分支提交到远程develop分支，并且track<br>  git remote set-head origin master # 设置远程仓库的HEAD指向master分支</p>
<p>  设置跟踪远程库和本地库<br>  git branch –set-upstream master origin/master      #master<br>  git branch –set-upstream develop origin/develop    #develop</p>
<p>  其他命令<br>  mkdir XX    #(创建一个空目录 XX指目录名)<br>  pwd         #显示当前目录的路径。<br>  cat XX      #查看XX文件内容<br>  rm  XX      #删除文件</p>
</li>
</ul>
<p>命令别名设置:</p>
<pre><code>gitk --all &amp;   //打开git 图形化界面
git fetch --all  //刷新工作区    
git remote -v  //查看远端地址
git checkout -b dbg_master  -t origin/master   //基于远端master分支创建dbg_master分支
git merge --squash &lt;branch&gt;：将多次提交合并成一个，然后git add .;git commit -m &quot;XXXXX&quot;;git push origin XXXX...

git push                         # push所有分支
git push origin master           # 将本地主分支推到远程主分支
git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)
git push origin &lt;local_branch&gt;   # 创建远程分支， origin是远程仓库名
git push origin local-branch     #将当前local-branch 分支推送一个远程local-branch分支，本地分支和远程分支同名
git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支，将local_branch代码推送到remote_branch分支
git push origin :&lt;remote_branch&gt;  #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支

 对最近一次commit的进行修改：git commit -a –amend

 Git pull 强制覆盖本地文件
  git fetch --all  
  git reset --hard origin/master 
  git pull

git remote add origin https://git.oschina.net/duandaoke/os.git要求服务已经建立同名仓库
git remote # 显示远程仓库
git remote -v # 显示远程仓库详情
git remote show origin # 显示 origin 远程库的详情



rebase的冲突解决

   解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存） 
      git add -u   //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。
   然后执行下面命令继续rebase：
      git rebase --continue     //有冲突继续解决，重复这这些步骤，直到rebase完成。
   如果中间遇到某个补丁不需要应用，可以用下面命令忽略：
      git rebase --skip 
   如果想回到rebase执行之前的状态，可以执行：
      git rebase --abort    //放弃rebase  
   注：rebase之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。



cherry-pick的冲突解决

   解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存） 
      git add -u   //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。
   然后执行下面命令继续rebase：
      git cherry-pick --continue     //有冲突继续解决，重复这这些步骤，直到cherry-pick完成。
   如果中间遇到某个补丁不需要应用，可以用下面命令忽略：
      git cherry-pick --skip 
   如果想回到rebase执行之前的状态，可以执行：
      git cherry-pick  --abort    //放弃cherry-pick
   注：cherry-pick之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。


       手动编辑冲突的文件，使其内容和master_mlc分支上的内容一致， 
       然后git add此文件，最后执行git cherry-pick –continue即可。 


1、git删除远程分支
git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限
2、清空git暂存区
git reset HEAD  //可以清空之前git add 的内容


git clean命令用来从你的工作目录中删除所有没有tracked过的文件.
    git clean经常和git reset --hard一起结合使用. 记住reset只影响被track过的文件, 所以需要clean来删除没有track过的文件. 结合使用这两个命令能让你的工作目录完全回到一个指定的&lt;commit&gt;的状态.
用法


删除当前目录下没有被track过的文件和文件夹.
    git clean -xf


下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发.
git reset --hard
git clean -df
运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态, git status会告诉你这是一个干净的工作目录, 又是一个新的开始了.


git config --global gui.encoding utf-8    //在git GUI中使用UTF-8编码     
//git 回滚到之前某一commit
git reset –hard 8ff24a6803173208f3e606e32dfcf82db9ac84d8


在使用Git的时候,经过几次提交后,发现需要回退到早些时候的状态.例如: 
7edb8524a xxxxxxxxxxxxxxxxxx 
83dae5691 xxxxxxxxxxxxxxxxxx 
45eadd642 xxxxxxxxxxxxxxxxxx 
657834ade xxxxxxxxxxxxxxxxxx
假设现在处于7edb8524a 状态,现在我想回退到657834ade时的状态,此时可以 
git reset –hard 7edb8524a 
然后 
git reset –soft 657834ade 
会将之间的修改全部进行revert,然后在进行add commit操作就行了.
另外权限足够的话,可以从657834ade 拉一个分支出来,然后将远程分支 
删除,再将拉出来的分支push到远程仓库上,成为原来的分支,也可以实现回退到 
657834ade 的目的.此方法不会保留中间的各种修改信息和状态.


根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:
    git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息
    git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可
    git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容

已经push
对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令

revert
git revert用于反转提交,执行evert命令时要求工作树必须是干净的.
git revert用一个新提交来消除一个历史提交所做的任何修改.
revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)

revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.
git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61
通常,前几位即可
git revert c011eb3

git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit
看似达到的效果是一样的,其实完全不同.
</code></pre><p>合理的命令别名设置可以大大减少输入，有助于提高工作效率，建议遵守下述别名设置：</p>
<pre><code>git config --global alias.ci commit
git config --global alias.co checkout
git config --global alias.st status
git config --global alias.rb rebase
git config --global alias.ll “log --oneline --decorate --color”
git config --global alias.lc “log --graph --color”          
</code></pre><p>正确的回车换行设置，避免 Unix 和 Windows 下开发的回车换行的转换问题。</p>
<pre><code>(Windows  下)
git config --global core.autocrlf true
git config --global core. safecrlf warn

(Linux  下)
git config --global core.autocrlf input
git config --global core. safecrlf warn
</code></pre><p>基本命令</p>
<pre><code>git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;youremail@example.com&quot;
git config --global core.editor &lt;your favorite editor here&gt;
Ex: git config --global core.editor vim

git init：初始化一个repo，初始化本地git仓库（创建新仓库）
</code></pre><p>Commit 结构</p>
<pre><code>git status(gst)：查看 repo 状态
工作区：
.git 目录
暂存区
工作目录
</code></pre><p><img src="https://pic4.zhimg.com/v2-44aed332eb50ca594deeca86186012a8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-44aed332eb50ca594deeca86186012a8_hd.jpg" alt=""></p>
<pre><code>git add &lt;filename&gt;(ga)：添加一个文件到暂存区
git add .(gaa)：添加所有文件到暂存区
git add *.js：添加所有后缀为js的文件到暂存区
git rm --cached &lt;file&gt;：从暂存区删除一个新文件
git commit -m &quot;My first commit&quot;(gcmsg)：创建一次带 message 的提交
git commit -v -a(gca)：
-v是 verbose 的缩写，会在底部显示差异信息和更多有意义的信息
-a 类似于 git add .，会添加所有被修改和删除的文件，但会忽略新创建的文件

git help &lt;command&gt;：查看对应命令的帮助手册
git log(glg,glgg,glo, glog)：查看项目的提交历史
</code></pre><p>暂存区管理</p>
<pre><code>git reset HEAD &lt;filename&gt;(grh)：从暂存区删除一个被修改的文件
git reset HEAD(grh)：从暂存区删除所有被修改的文件
git checkout &lt;filename&gt;(gco)：从暂存区删除一个被修改的文件，并撤销文件的更改     //  git checkout .
git commit -m &quot;My first commit&quot; --amend：添加文件/更改在暂存区的最后一次提交
git commit -v -a --amend(gca!)：添加文件/更改在暂存区的最后一次提交
.gitignore：告诉git，哪些文件不被加入版本跟踪
可以使用 git add &lt;filename&gt; -f 命令添加一个不被版本跟踪的文件


git diff &lt;filename&gt;(gd)：查看基于当前文件的最后一次提交的更改差异
git diff (gd)：查看基于所有文件的最后一次提交的更改差异
git reset HEAD~2 --soft：从项目提交历史中删除最近两次提交，但不丢弃文件的更改
git reset HEAD~2 --hard：从项目提交历史中删除最近两次提交，但会丢弃文件的更改和在(最后两次)提交中创建的新文件
git reset &lt;commit&gt; --soft --hard：
--soft：将所有被更改的文件回溯到“待提交”状态
--hard：commit 之后，对被git追踪的文件的任何更改都被丢弃


git reflog：显示包括&quot;被撤销&quot;在内的所有提交
git merge &lt;commit hash&gt;：重新提交(restore the commit)
git clean -f：删除工作目录中不被git进行版本追踪的文件
</code></pre><p>Stashed &amp; BranchesStash</p>
<pre><code>git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区
git stash list：查看储藏队列(Stash lists)
git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes))
git stash clear：清空储藏队列
git stash save &quot;name of the stash&quot;：为储藏设置命名
git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏
git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏)
</code></pre><p>Branch</p>
<pre><code>git checkout -b dev(gco)：创建 dev 分支并从当前分支切换到 dev 分支      //  git checkout -b dbg_master  -t origin/master   //基于master分支创建dbg_master分支
git branch(gb)：查看所有分支
git checkout master(gcm)：切换到主分支
git merge &lt;branch&gt;(gm)：合并分支
git rebase master：先将 master 上的更改合并到当前分支，再添加当前分支的更改。如果有冲突，解决冲突后加 --continue 参数继续合并
git branch -d &lt;branch&gt;： 删除分支，-D 则强制删除分支
git merge &lt;branch&gt; --squash：将多次提交合并成一个，其流程如下：



# Go to the `master` branch
git checkout master
# Create a temp branch
git checkout -b temp
# Merge the feature/x branch into the temp using --squash
git merge feature/x --squash
# See the new modifications/files in the Staging Area
git status
# Create the unified commit
git commit -m &quot;Add feature/x&quot;
# Delete the feature/x branch
git branch -D feature/x
</code></pre><ul>
<li><p>rebase 和 merge 的区别：</p>
<p>  rebase:<br>  提交历史(的展示)是线性的<br>  缺点：会删除最近一个 commit，然后创建一次新的 commit<br>  如果已提交到远程，不要使用 rebase</p>
<p>  merge:<br>  提交历史(的展示)是分叉的<br>  对于两个分支的合并，会创建一个次新的 commit</p>
</li>
</ul>
<p>远程仓库管理</p>
<pre><code>git remote add &lt;name&gt; &lt;url&gt;：添加一个将被追踪的远程仓库
git remote rm &lt;name&gt;：移除一个远程仓库
git push &lt;remote&gt; &lt;remote-branch&gt;(gp,ggp)：将当前分支的本地 commit 推送到远程仓库
git fetch &lt;remote&gt; &lt;remote-branch&gt;：拉取远程仓库的最新 commit 到当前(本地)分支(&lt;remote&gt;/&lt;branch&gt;)，不会合并
git pull &lt;remote&gt; &lt;remote-branch&gt;(gl,ggl)：拉取远程仓库的最新 commit 到当前(本地)分支，并自动 merge
git pull --rebase(gup)：以 rebase 的方式进行合并，而不是 merge
</code></pre><p>其它有用的命令</p>
<pre><code>git tag &lt;name&gt;：创建一个 tag(如：v1.3)
git push --tags：将本地 tags 推送到远程仓库
git push &lt;tag&gt;：推送指定的本地 tag 到远程


展示帮助信息
git help -g

回到远程仓库的状态
抛弃本地所有的修改，回到远程仓库的状态。
git fetch --all &amp;&amp; git reset --hard origin/master

重设第一个commit
也就是把所有的改动都重新放回工作区，并清空所有的commit，这样就可以重新提交第一个commit了
git update-ref -d HEAD

展示工作区和暂存区的不同
输出工作区和暂存区的different(不同)。
git diff

还可以展示本地仓库中任意两个commit之间的文件变动：
git diff &lt;commit-id&gt; &lt;commit-id&gt;

展示暂存区和最近版本的不同
输出暂存区和本地最近的版本(commit)的different(不同)。
git diff --cached

展示暂存区、工作区和最近版本的不同
输出工作区、暂存区 和本地最近的版本(commit)的different(不同)。
git diff HEAD

快速切换分支
git checkout -

删除已经合并到master的分支
git branch --merged master | grep -v &apos;^\*\|  master&apos; | xargs -n 1 git branch -d

展示本地分支关联远程仓库的情况
git branch -vv

关联远程分支
关联之后，git branch -vv就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。
git branch -u origin/mybranch

或者在push时加上-u参数
git push origin/mybranch -u

列出所有本地分支
-l参数相当于：local
git branch -l

列出所有远程分支
-r参数相当于：remote
git branch -r

列出本地和远程分支
-a参数相当于：all
git branch -a

创建并切换到本地分支
git checkout -b &lt;branch-name&gt;

创建并切换到远程分支
git checkout -b &lt;branch-name&gt; -t origin/&lt;branch-name&gt;

删除本地分支
git branch -d &lt;local-branchname&gt;

删除远程分支
git push origin --delete &lt;remote-branchname&gt;
或者
git push origin :&lt;remote-branchname&gt;

重命名本地分支
git branch -m &lt;new-branch-name&gt;
git branch -m &lt;oldbranchname&gt; &lt;newbranchname&gt;：尝试修改
git branch -M &lt;oldbranchname&gt; &lt;newbranchname&gt;：强制修改

查看标签
git tag

展示当前分支的最近的tag
git describe --tags --abbrev=0

本地创建标签
git tag &lt;version-number&gt;

默认tag是打在最近的一次commit上，如果需要指定commit打tag：
$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;

推送标签到远程仓库
首先要保证本地创建好了标签才可以推送标签到远程仓库：
git push origin &lt;local-version-number&gt;

一次性推送所有标签，同步到远程仓库：
git push origin --tags

删除本地标签
git tag -d &lt;tag-name&gt;

删除远程标签
删除远程标签需要先删除本地标签，再执行下面的命令：
git push origin :refs/tags/&lt;tag-name&gt;

切回到某个标签
一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：
git checkout -b branch_name tag_name

放弃工作区的修改
git checkout &lt;file-name&gt;

放弃所有修改：
git checkout .

恢复删除的文件
git rev-list -n 1 HEAD -- &lt;file_path&gt; #得到 deleting_commit
git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态

回到某一个commit的状态，并重新增添一个commit  //回退，有记录
git revert &lt;commit-id&gt;

回到某个commit的状态，并删除后面的commit
和revert的区别：reset命令会抹去某个commit id之后的所有commit
git reset &lt;commit-id&gt;

修改上一个commit的描述
git commit --amend

查看commit历史
git log

查看某段代码是谁写的
blame的意思为‘责怪’，你懂的。
git blame &lt;file-name&gt;

显示本地执行过git命令
就像shell的history一样
git reflog

修改作者名
git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos;

修改远程仓库的url
git remote set-url origin &lt;URL&gt;

增加远程仓库
git remote add origin &lt;remote-url&gt;

列出所有远程仓库
git remote    //  git remote -v

查看两个星期内的改动
git whatchanged --since=&apos;2 weeks ago&apos;

把A分支的某一个commit，放到B分支上
这个过程需要cherry-pick命令，参考
git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;

给git命令起别名
简化命令
git config --global alias.&lt;handle&gt; &lt;command&gt;
比如：git status 改成 git st，这样可以简化命令
git config --global alias.st status

存储当前的修改，但不用提交commit
详解可以参考廖雪峰老师的git教程

git stash
保存当前状态，包括untracked的文件

untracked文件：新建的文件
git stash -u

展示所有stashes
git stash list

回到某个stash的状态
git stash apply &lt;stash@{n}&gt;

回到最后一个stash的状态，并删除这个stash
git stash pop

删除所有的stash
git stash clear

从stash中拿出某个文件的修改
git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt;

展示所有tracked的文件
git ls-files -t

展示所有untracked的文件
git ls-files --others

展示所有忽略的文件
git ls-files --others -i --exclude-standard

强制删除untracked的文件
可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。clean命令，注意两点：
clean后，删除的文件无法找回
不会影响tracked的文件的改动，只会删除untracked的文件git clean &lt;file-name&gt; -f
强制删除untracked的目录
可以用来删除新建的目录，注意:这个命令也可以用来删除untracked的文件。详情见上一条
git clean &lt;directory-name&gt; -df

展示简化的commit历史
git log --pretty=oneline --graph --decorate --all
把某一个分支到导出成一个文件
git bundle create &lt;file&gt; &lt;branch-name&gt;
从包中导入分支
新建一个分支，分支内容就是上面git bundle create命令导出的内容
git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;
执行rebase之前自动stash
git rebase --autostash
从远程仓库根据ID，拉下某一状态，到本地分支
git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;
详细展示一行中的修改
git diff --word-diff
清除gitignore文件中记录的文件
git clean -X -f
展示所有alias和configs
注意： config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config
git config --local --list (当前目录)
git config --global --list (全局)
展示忽略的文件
git status --ignored
commit历史中显示Branch1有的，但是Branch2没有commit
git log Branch1 ^Branch2
在commit log中显示GPG签名
git log --show-signature
删除全局设置
git config --global --unset &lt;entry-name&gt;
新建并切换到新分支上，同时这个分支没有任何commit
相当于保存修改，但是重写commit历史
git checkout --orphan &lt;branch-name&gt;
展示任意分支某一文件的内容
git show &lt;branch-name&gt;:&lt;file-name&gt;
clone下来指定的单一分支
git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git
忽略某个文件的改动
关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动
git update-index --assume-unchanged path/to/file

恢复 track 指定文件的改动
git update-index --no-assume-unchanged path/to/file

忽略文件的权限变化
不再将文件的权限变化视作改动
git config core.fileMode false
展示本地所有的分支的commit
最新的放在最上面
git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/
在commit log中查找相关内容
通过grep查找，given-text：所需要查找的字段
git log --all --grep=&apos;&lt;given-text&gt;&apos;
把暂存区的指定file放到工作区中
git reset &lt;file-name&gt;

强制推送
git push -f &lt;remote-name&gt; &lt;branch-name&gt;列出所有远程分支
-r参数相当于：remote
git branch -r

更新到本地
# 源 + 分支名
git pull origin master
</code></pre><p>初始化本地git仓库（创建新仓库）</p>
<pre><code>git init                                               
# 初始化 git 项目
git init
安装好 Git 之后，配置你的资料:
# 配置用户名
git config --global user.name &quot;Your Real Name&quot;
# 配置邮箱地址
git config --global user.email you@email.address
</code></pre><p>配置用户名</p>
<pre><code>git config --global user.name &quot;xxx&quot;                       
</code></pre><p>配置邮件</p>
<pre><code>git config --global user.email &quot;xxx@xxx.com&quot;              
</code></pre><p>git status等命令自动着色</p>
<pre><code>git config --global color.ui true                         
git config --global color.status auto
git config --global color.diff auto
git config --global color.branch auto
git config --global color.interactive auto
</code></pre><p>clone远程仓库</p>
<pre><code>git clone git+ssh://git@192.168.53.168/VT.git             
</code></pre><p>查看当前版本状态（是否修改）</p>
<pre><code>git status                                                
</code></pre><p>添加xyz文件至index</p>
<pre><code>git add xyz                                               
</code></pre><p>增加当前子目录下所有更改过的文件至index</p>
<pre><code>git add .                                                 
</code></pre><p>提交</p>
<pre><code>git commit -m &apos;xxx&apos;                                       
</code></pre><p>合并上一次提交（用于反复修改）</p>
<pre><code>git commit --amend -m &apos;xxx&apos;                               
</code></pre><p>将add和commit合为一步</p>
<pre><code>git commit -am &apos;xxx&apos;                                      
</code></pre><p>删除index中的文件</p>
<pre><code>git rm xxx                                                
</code></pre><p>递归删除</p>
<pre><code>git rm -r *                                               
</code></pre><p>显示提交日志</p>
<pre><code>git log                                                   
</code></pre><p>显示1行日志 -n为n行</p>
<pre><code>git log -1                                                
</code></pre><p>git log -5</p>
<p>显示提交日志及相关变动文件</p>
<pre><code>git log --stat                                            
</code></pre><p>git log -p -m</p>
<p>显示某个提交的详细内容</p>
<pre><code>git show dfb02e6e4f2f7b573337763e5c0013802e392818         
</code></pre><p>可只用commitid的前几位</p>
<pre><code>git show dfb02                                            
</code></pre><p>显示HEAD提交日志</p>
<pre><code>git show HEAD                                             
</code></pre><p>显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</p>
<pre><code>git show HEAD^                                            
</code></pre><p>显示已存在的tag</p>
<pre><code>git tag                                                   
</code></pre><p>增加v2.0的tag</p>
<pre><code>git tag -a v2.0 -m &apos;xxx&apos;                                  
</code></pre><p>显示v2.0的日志及详细内容</p>
<pre><code>git show v2.0                                             
</code></pre><p>显示v2.0的日志</p>
<pre><code>git log v2.0                                              
</code></pre><p>显示所有未添加至index的变更</p>
<pre><code>git diff                                                  
</code></pre><p>显示所有已添加index但还未commit的变更</p>
<pre><code>git diff --cached                                         
</code></pre><p>比较与上一个版本的差异</p>
<pre><code>git diff HEAD^                                            
</code></pre><p>比较与HEAD版本lib目录的差异</p>
<pre><code>git diff HEAD -- ./lib                                    
</code></pre><p>比较远程分支master上有本地分支master上没有的</p>
<pre><code>git diff origin/master..master                            
</code></pre><p>只显示差异的文件，不显示具体内容</p>
<pre><code>git diff origin/master..master --stat                     
</code></pre><p>增加远程定义（用于push/pull/fetch）</p>
<pre><code>git remote add origin git+ssh://git@192.168.53.168/VT.git 
</code></pre><p>显示本地分支</p>
<pre><code>git branch                                                
</code></pre><p>显示包含提交50089的分支</p>
<pre><code>git branch --contains 50089                               
</code></pre><p>显示所有分支</p>
<pre><code>git branch -a                                             
</code></pre><p>显示所有原创分支</p>
<pre><code>git branch -r                                             
</code></pre><p>显示所有已合并到当前分支的分支</p>
<pre><code>git branch --merged                                       
</code></pre><p>显示所有未合并到当前分支的分支</p>
<pre><code>git branch --no-merged                                    
</code></pre><p>本地分支改名</p>
<pre><code>git branch -m master master_copy                          
</code></pre><p>从当前分支创建新分支master_copy并检出</p>
<pre><code>git checkout -b master_copy                               
</code></pre><p>上面的完整版</p>
<pre><code>git checkout -b master master_copy                        
</code></pre><p>检出已存在的features/performance分支</p>
<pre><code>git checkout features/performance                         
</code></pre><p>检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</p>
<pre><code>git checkout --track hotfixes/BJVEP933                    
</code></pre><p>检出版本v2.0</p>
<pre><code>git checkout v2.0                                         
</code></pre><p>从远程分支develop创建新本地分支devel并检出</p>
<pre><code>git checkout -b devel origin/develop                      
</code></pre><p>检出head版本的README文件（可用于修改错误回退）</p>
<pre><code>git checkout -- README                                    
</code></pre><p>合并远程master分支至当前分支</p>
<pre><code>git merge origin/master                                   
</code></pre><p>合并提交ff44785404a8e的修改</p>
<pre><code>git cherry-pick ff44785404a8e                             
</code></pre><p>将当前分支push到远程master分支</p>
<pre><code>git push origin master                                    
</code></pre><p>删除远程仓库的hotfixes/BJVEP933分支</p>
<pre><code>git push origin :hotfixes/BJVEP933                        
</code></pre><p>把所有tag推送到远程仓库</p>
<pre><code>git push --tags                                           
</code></pre><p>获取所有远程分支（不更新本地分支，另需merge）</p>
<pre><code>git fetch                                                 
</code></pre><p>获取所有原创分支并清除服务器上已删掉的分支</p>
<pre><code>git fetch --prune                                         
</code></pre><p>获取远程分支master并merge到当前分支</p>
<pre><code>git pull origin master                                    
</code></pre><p>重命名文件README为README2</p>
<pre><code>git mv README README2                                     
</code></pre><p>将当前版本重置为HEAD（通常用于merge失败回退）</p>
<pre><code>git reset --hard HEAD                                     
</code></pre><p>git rebase</p>
<p>删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</p>
<pre><code>git branch -d hotfixes/BJVEP933                           
</code></pre><p>强制删除分支hotfixes/BJVEP933</p>
<pre><code>git branch -D hotfixes/BJVEP933                           
</code></pre><p>列出git index包含的文件</p>
<pre><code>git ls-files                                              
</code></pre><p>图示当前分支历史</p>
<pre><code>git show-branch                                           
</code></pre><p>图示所有分支历史</p>
<pre><code>git show-branch --all                                     
</code></pre><p>显示提交历史对应的文件修改</p>
<pre><code>git whatchanged                                           
</code></pre><p>撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</p>
<pre><code>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       
</code></pre><p>内部命令：显示某个git对象</p>
<pre><code>git ls-tree HEAD                                          
</code></pre><p>内部命令：显示某个ref对于的SHA1 HASH</p>
<pre><code>git rev-parse v2.0                                        
</code></pre><p>显示所有提交，包括孤立节点</p>
<pre><code>git reflog                                                
</code></pre><p>git show HEAD@{5}</p>
<p>显示master分支昨天的状态</p>
<pre><code>git show master@{yesterday}                               
</code></pre><p>图示提交日志</p>
<pre><code>git log --pretty=format:&apos;%h %s&apos; --graph                   
git show HEAD~3
git show -s --pretty=raw 2be7fcb476
</code></pre><p>暂存当前修改，将所有至为HEAD状态</p>
<pre><code>git stash                                                 
</code></pre><p>查看所有暂存</p>
<pre><code>git stash list                                            
</code></pre><p>参考第一次暂存</p>
<pre><code>git stash show -p stash@{0}                               
</code></pre><p>应用第一次暂存</p>
<pre><code>git stash apply stash@{0}                                 
</code></pre><p>文件中搜索文本“delete from”</p>
<pre><code>git grep &quot;delete from&quot;                                    
git grep -e &apos;#define&apos; --and -e SORT_DIRENT

git gc
git fsck
</code></pre><hr>
<ol>
<li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li>
<li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li>
<li>统一概念：</li>
</ol>
<ul>
<li>工作区：改动（增删文件和内容）</li>
<li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了‘暂存区’</li>
<li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。</li>
<li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了‘远程仓库’（GitHub等)</li>
<li>commit-id：输出命令：<code>git log</code>，最上面那行<code>commit xxxxxx</code>，后面的字符串就是commit-id</li>
</ul>
<h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><pre><code>git help -g
</code></pre><h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p>
<pre><code>gitfetch--all&amp;&amp;gitreset--hardorigin/master
</code></pre><h2 id="重设第一个commit"><a href="#重设第一个commit" class="headerlink" title="重设第一个commit"></a>重设第一个commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的commit</strong>，这样就可以重新提交第一个commit了</p>
<pre><code>git update-ref -d HEAD
</code></pre><h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的different(不同)。</p>
<pre><code>git diff
</code></pre><p>还可以展示本地仓库中任意两个commit之间的文件变动：</p>
<pre><code>git diff &lt;commit-id&gt; &lt;commit-id&gt;
</code></pre><h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本(commit)的different(不同)。</p>
<pre><code>git diff --cached
</code></pre><h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本(commit)的different(不同)。</p>
<pre><code>git diff HEAD
</code></pre><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><pre><code>git checkout -
</code></pre><h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><pre><code>git branch --merged master| grep -v &apos;^\*\|  master&apos; | xargs -n 1 git branch -d
</code></pre><h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><pre><code>gitbranch -vv
</code></pre><h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code>就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。</p>
<pre><code>gitbranch -u origin/mybranch
</code></pre><p>或者在push时加上<code>-u</code>参数</p>
<pre><code>git pushorigin/mybranch -u
</code></pre><h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r参数相当于：remote</p>
<pre><code>git branch -r
</code></pre><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all</p>
<pre><code>git branch -a
</code></pre><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><pre><code>git checkout -b &lt;branch-name&gt;
</code></pre><h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><pre><code>git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;
</code></pre><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><pre><code>git branch -d &lt;local-branchname&gt;
</code></pre><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><pre><code>git pushorigin --delete &lt;remote-branchname&gt;
</code></pre><p>或者</p>
<pre><code>git push origin :&lt;remote-branchname&gt;
</code></pre><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><pre><code>git branch -m &lt;new-branch-name&gt;
</code></pre><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><pre><code>git tag
</code></pre><p>展示当前分支的最近的tag</p>
<pre><code>gitdescribe--tags--abbrev=0
</code></pre><h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><pre><code>git tag&lt;version-number&gt;
</code></pre><p>默认tag是打在最近的一次commit上，如果需要指定commit打tag：</p>
<pre><code>$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;
</code></pre><h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p>
<pre><code>git push origin &lt;local-version-number&gt;
</code></pre><p>一次性推送所有标签，同步到远程仓库：</p>
<pre><code>git pushorigin --tags
</code></pre><h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><pre><code>git tag-d&lt;tag-name&gt;
</code></pre><h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p>
<pre><code>git push origin :refs/tags/&lt;tag-name&gt;
</code></pre><h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p>
<pre><code>git checkout -b branch_name tag_name
</code></pre><h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><pre><code>git checkout &lt;file-name&gt;
</code></pre><p>放弃所有修改：</p>
<pre><code>git checkout .
</code></pre><h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><pre><code>git rev-list -n 1 HEAD -- &lt;file_path&gt;#得到 deleting_commit

git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt;#回到删除文件 deleting_commit 之前的状态
</code></pre><h2 id="以新增一个commit的方式还原某一个commit的修改"><a href="#以新增一个commit的方式还原某一个commit的修改" class="headerlink" title="以新增一个commit的方式还原某一个commit的修改"></a>以新增一个commit的方式还原某一个commit的修改</h2><pre><code>git revert &lt;commit-id&gt;
</code></pre><h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和revert的区别：reset命令会抹去某个commit id之后的所有commit</p>
<pre><code>git reset &lt;commit-id&gt;  #默认就是-mixed参数。

git reset –mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。

git reset –soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可   

git reset –hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容
</code></pre><h2 id="修改上一个commit的描述"><a href="#修改上一个commit的描述" class="headerlink" title="修改上一个commit的描述"></a>修改上一个commit的描述</h2><pre><code>git commit--amend
</code></pre><h2 id="查看commit历史"><a href="#查看commit历史" class="headerlink" title="查看commit历史"></a>查看commit历史</h2><pre><code>git log
</code></pre><h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame的意思为‘责怪’，你懂的。</p>
<pre><code>git blame &lt;file-name&gt;
</code></pre><h2 id="显示本地更新过HEAD的git命令记录"><a href="#显示本地更新过HEAD的git命令记录" class="headerlink" title="显示本地更新过HEAD的git命令记录"></a>显示本地更新过HEAD的git命令记录</h2><p>每次更新了HEAD 的git 命令比如 commint、amend、cherry-pick、reset、revert等都会被记录下来（不限分支），就像shell的history一样。<br>这样你可以reset 到任何一次更新了HEAD 的操作之后，而不仅仅是回到当前分支下的某个commit 之后的状态。</p>
<pre><code>git reflog
</code></pre><h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><pre><code>git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos;
</code></pre><h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><pre><code>git remote set-urlorigin &lt;URL&gt;
</code></pre><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><pre><code>git remote add origin &lt;remote-url&gt;
</code></pre><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><pre><code>git remote
</code></pre><h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><pre><code>git whatchanged --since=&apos;2 weeks ago&apos;
</code></pre><h2 id="把A分支的某一个commit，放到B分支上"><a href="#把A分支的某一个commit，放到B分支上" class="headerlink" title="把A分支的某一个commit，放到B分支上"></a>把A分支的某一个commit，放到B分支上</h2><p>这个过程需要<code>cherry-pick</code>命令，<a href="http://sg552.iteye.com/blog/1300713#bc2367928" target="_blank" rel="noopener">参考</a></p>
<pre><code>git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;
</code></pre><h2 id="给git命令起别名"><a href="#给git命令起别名" class="headerlink" title="给git命令起别名"></a>给git命令起别名</h2><p>简化命令</p>
<pre><code>git config --globalalias.&lt;handle&gt; &lt;command&gt;

比如：git status 改成 git st，这样可以简化命令

git config --globalalias.st status
</code></pre><h2 id="存储当前的修改，但不用提交commit"><a href="#存储当前的修改，但不用提交commit" class="headerlink" title="存储当前的修改，但不用提交commit"></a>存储当前的修改，但不用提交commit</h2><p>详解可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="noopener">廖雪峰老师的git教程</a></p>
<pre><code>git stash
</code></pre><h2 id="保存当前状态，包括untracked的文件"><a href="#保存当前状态，包括untracked的文件" class="headerlink" title="保存当前状态，包括untracked的文件"></a>保存当前状态，包括untracked的文件</h2><p>untracked文件：新建的文件</p>
<pre><code>git stash -u
</code></pre><h2 id="展示所有stashes"><a href="#展示所有stashes" class="headerlink" title="展示所有stashes"></a>展示所有stashes</h2><pre><code>git stash list
</code></pre><h2 id="回到某个stash的状态"><a href="#回到某个stash的状态" class="headerlink" title="回到某个stash的状态"></a>回到某个stash的状态</h2><pre><code>git stash apply &lt;stash@{n}&gt;
</code></pre><h2 id="回到最后一个stash的状态，并删除这个stash"><a href="#回到最后一个stash的状态，并删除这个stash" class="headerlink" title="回到最后一个stash的状态，并删除这个stash"></a>回到最后一个stash的状态，并删除这个stash</h2><pre><code>git stash pop
</code></pre><h2 id="删除所有的stash"><a href="#删除所有的stash" class="headerlink" title="删除所有的stash"></a>删除所有的stash</h2><pre><code>git stash clear
</code></pre><h2 id="从stash中拿出某个文件的修改"><a href="#从stash中拿出某个文件的修改" class="headerlink" title="从stash中拿出某个文件的修改"></a>从stash中拿出某个文件的修改</h2><pre><code>git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt;
</code></pre><h2 id="展示所有tracked的文件"><a href="#展示所有tracked的文件" class="headerlink" title="展示所有tracked的文件"></a>展示所有tracked的文件</h2><pre><code>git ls-files -t
</code></pre><h2 id="展示所有untracked的文件"><a href="#展示所有untracked的文件" class="headerlink" title="展示所有untracked的文件"></a>展示所有untracked的文件</h2><pre><code>git ls-files--others
</code></pre><h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><pre><code>gitls-files--others-i--exclude-standard
</code></pre><h2 id="强制删除untracked的文件"><a href="#强制删除untracked的文件" class="headerlink" title="强制删除untracked的文件"></a>强制删除untracked的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。<code>clean</code>命令，<strong>注意两点</strong>：</p>
<ol>
<li>clean后，删除的文件无法找回</li>
<li><p>不会影响tracked的文件的改动，只会删除untracked的文件</p>
<p> git clean <file-name> -f</file-name></p>
</li>
</ol>
<h2 id="强制删除untracked的目录"><a href="#强制删除untracked的目录" class="headerlink" title="强制删除untracked的目录"></a>强制删除untracked的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除untracked的文件。详情见上一条</p>
<pre><code>git clean &lt;directory-name&gt; -df
</code></pre><h2 id="展示简化的commit历史"><a href="#展示简化的commit历史" class="headerlink" title="展示简化的commit历史"></a>展示简化的commit历史</h2><pre><code>gitlog--pretty=oneline--graph--decorate--all
</code></pre><h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><pre><code>git bundle create &lt;file&gt; &lt;branch-name&gt;
</code></pre><h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面<code>git bundle create</code>命令导出的内容</p>
<pre><code>git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;
</code></pre><h2 id="执行rebase之前自动stash"><a href="#执行rebase之前自动stash" class="headerlink" title="执行rebase之前自动stash"></a>执行rebase之前自动stash</h2><pre><code>git rebase --autostash
</code></pre><h2 id="从远程仓库根据ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据ID，拉下某一状态，到本地分支"></a>从远程仓库根据ID，拉下某一状态，到本地分支</h2><pre><code>git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;
</code></pre><h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><pre><code>git diff --word-diff
</code></pre><h2 id="清除gitignore文件中记录的文件"><a href="#清除gitignore文件中记录的文件" class="headerlink" title="清除gitignore文件中记录的文件"></a>清除gitignore文件中记录的文件</h2><pre><code>git clean -X -f
</code></pre><h2 id="展示所有alias和configs"><a href="#展示所有alias和configs" class="headerlink" title="展示所有alias和configs"></a>展示所有alias和configs</h2><p><strong>注意：</strong> config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config</p>
<pre><code>gitconfig--local--list(当前目录)gitconfig--global--list(全局)
</code></pre><h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><pre><code>git status--ignored
</code></pre><h2 id="commit历史中显示Branch1有的，但是Branch2没有commit"><a href="#commit历史中显示Branch1有的，但是Branch2没有commit" class="headerlink" title="commit历史中显示Branch1有的，但是Branch2没有commit"></a>commit历史中显示Branch1有的，但是Branch2没有commit</h2><pre><code>git log Branch1 ^Branch2
</code></pre><h2 id="在commit-log中显示GPG签名"><a href="#在commit-log中显示GPG签名" class="headerlink" title="在commit log中显示GPG签名"></a>在commit log中显示GPG签名</h2><pre><code>git log--show-signature
</code></pre><h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><pre><code>git config --global --unset &lt;entry-name&gt;
</code></pre><h2 id="新建并切换到新分支上，同时这个分支没有任何commit"><a href="#新建并切换到新分支上，同时这个分支没有任何commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何commit"></a>新建并切换到新分支上，同时这个分支没有任何commit</h2><p>相当于保存修改，但是重写commit历史</p>
<pre><code>git checkout --orphan &lt;branch-name&gt;
</code></pre><h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><pre><code>git show &lt;branch-name&gt;:&lt;file-name&gt;
</code></pre><h2 id="clone下来指定的单一分支"><a href="#clone下来指定的单一分支" class="headerlink" title="clone下来指定的单一分支"></a>clone下来指定的单一分支</h2><pre><code>git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git
</code></pre><h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p>
<pre><code>git update-index --assume-unchanged path/to/file
</code></pre><p>恢复 track 指定文件的改动</p>
<pre><code>git update-index --no-assume-unchanged path/to/file
</code></pre><h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p>
<pre><code>git config core.fileMode false
</code></pre><h2 id="以最后提交的顺序列出所有Git分支"><a href="#以最后提交的顺序列出所有Git分支" class="headerlink" title="以最后提交的顺序列出所有Git分支"></a>以最后提交的顺序列出所有Git分支</h2><p>最新的放在最上面</p>
<pre><code>git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/
</code></pre><h2 id="在commit-log中查找相关内容"><a href="#在commit-log中查找相关内容" class="headerlink" title="在commit log中查找相关内容"></a>在commit log中查找相关内容</h2><p>通过grep查找，given-text：所需要查找的字段</p>
<pre><code>git log --all --grep=&apos;&lt;given-text&gt;&apos;
</code></pre><h2 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h2><p>不添加参数，默认是-mixed</p>
<pre><code>git reset &lt;file-name&gt;
</code></pre><h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><pre><code>git push -f &lt;remote-name&gt; &lt;branch-name&gt;
</code></pre><h2 id="长按关注订阅号"><a href="#长按关注订阅号" class="headerlink" title="长按关注订阅号"></a>长按关注订阅号</h2><p><img src="https://static.segmentfault.com/v-5be168e8/global/img/squares.svg" alt="clipboard.png"></p>
<h2 id="长按进入RDhub群"><a href="#长按进入RDhub群" class="headerlink" title="长按进入RDhub群"></a>长按进入RDhub群</h2><p><img src="https://static.segmentfault.com/v-5be168e8/global/img/squares.svg" alt="clipboard.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/02/JS之call和apply-bind的模拟实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/02/JS之call和apply-bind的模拟实现/" itemprop="url">JS之call和apply,bind的模拟实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-02T22:39:16+08:00">
                2017-09-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>一句话介绍 call：</p>
<blockquote>
<p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
</blockquote>
<p>举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call(foo); // 1
</code></pre><p>注意两点：</p>
<ol>
<li>call 改变了 this 的指向，指向到 foo</li>
<li>bar 函数执行了</li>
</ol>
<h2 id="模拟实现第一步"><a href="#模拟实现第一步" class="headerlink" title="模拟实现第一步"></a>模拟实现第一步</h2><p>那么我们该怎么模拟实现这两个效果呢？</p>
<p>试想当调用 call 的时候，把 foo 对象改造成如下：</p>
<pre><code>var foo = {
    value: 1,
    bar: function() {
        console.log(this.value)
    }
};

foo.bar(); // 1
</code></pre><p>这个时候 this 就指向了 foo，是不是很简单呢？</p>
<p>但是这样却给 foo 对象本身添加了一个属性，这可不行呐！</p>
<p>不过也不用担心，我们用 delete 再删除它不就好了~</p>
<p>所以我们模拟的步骤可以分为：</p>
<ol>
<li>将函数设为对象的属性</li>
<li>执行该函数</li>
<li>删除该函数</li>
</ol>
<p>以上个例子为例，就是：</p>
<pre><code>// 第一步
foo.fn = bar
// 第二步
foo.fn()
// 第三步
delete foo.fn
</code></pre><p>fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。</p>
<p>根据这个思路，我们可以尝试着去写第一版的 call2 函数：</p>
<pre><code>// 第一版
Function.prototype.call2 = function(context) {
    // 首先要获取调用call的函数，用this可以获取
    context.fn = this;
    context.fn();
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

bar.call2(foo); // 1
</code></pre><p>正好可以打印 1 哎！是不是很开心！(～￣▽￣)～</p>
<h2 id="模拟实现第二步"><a href="#模拟实现第二步" class="headerlink" title="模拟实现第二步"></a>模拟实现第二步</h2><p>最一开始也讲了，call 函数还能给定参数执行函数。举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call(foo, &apos;kevin&apos;, 18);
// kevin
// 18
// 1
</code></pre><p>注意：传入的参数并不确定，这可咋办？</p>
<p>不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。</p>
<p>比如这样：</p>
<pre><code>// 以上个例子为例，此时的arguments为：
// arguments = {
//      0: foo,
//      1: &apos;kevin&apos;,
//      2: 18,
//      length: 3
// }
// 因为arguments是类数组对象，所以可以用for循环
var args = [];
for(var i = 1, len = arguments.length; i &lt; len; i++) {
    args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
}

// 执行后 args为 [foo, &apos;kevin&apos;, 18]
</code></pre><p>不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。</p>
<pre><code>// 将数组里的元素作为多个参数放进函数的形参里
context.fn(args.join(&apos;,&apos;))
// (O_o)??
// 这个方法肯定是不行的啦！！！
</code></pre><p>也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样：</p>
<pre><code>eval(&apos;context.fn(&apos; + args +&apos;)&apos;)
</code></pre><p>这里 args 会自动调用 Array.toString() 这个方法。</p>
<p>所以我们的第二版克服了两个大问题，代码如下：</p>
<pre><code>// 第二版
Function.prototype.call2 = function(context) {
    context.fn = this;
    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }
    eval(&apos;context.fn(&apos; + args +&apos;)&apos;);
    delete context.fn;
}

// 测试一下
var foo = {
    value: 1
};

function bar(name, age) {
    console.log(name)
    console.log(age)
    console.log(this.value);
}

bar.call2(foo, &apos;kevin&apos;, 18); 
// kevin
// 18
// 1
</code></pre><p>(๑•̀ㅂ•́) ✧</p>
<h2 id="模拟实现第三步"><a href="#模拟实现第三步" class="headerlink" title="模拟实现第三步"></a>模拟实现第三步</h2><p>模拟代码已经完成 80%，还有两个小点要注意：</p>
<p>1.this 参数可以传 null，当为 null 的时候，视为指向 window</p>
<p>举个例子：</p>
<pre><code>var value = 1;

function bar() {
    console.log(this.value);
}

bar.call(null); // 1
</code></pre><p>虽然这个例子本身不使用 call，结果依然一样。</p>
<p>2.函数是可以有返回值的！</p>
<p>举个例子：</p>
<pre><code>var obj = {
    value: 1
}

function bar(name, age) {
    return {
        value: this.value,
        name: name,
        age: age
    }
}

console.log(bar.call(obj, &apos;kevin&apos;, 18));
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>不过都很好解决，让我们直接看第三版也就是最后一版的代码：</p>
<pre><code>// 第三版
Function.prototype.call2 = function (context) {
    var context = context || window;
    context.fn = this;

    var args = [];
    for(var i = 1, len = arguments.length; i &lt; len; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);

    delete context.fn
    return result;
}

// 测试一下
var value = 2;

var obj = {
    value: 1
}

function bar(name, age) {
    console.log(this.value);
    return {
        value: this.value,
        name: name,
        age: age
    }
}

bar.call(null); // 2

console.log(bar.call2(obj, &apos;kevin&apos;, 18));
// 1
// Object {
//    value: 1,
//    name: &apos;kevin&apos;,
//    age: 18
// }
</code></pre><p>到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ</p>
<h2 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h2><p>apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现：</p>
<pre><code>Function.prototype.apply = function (context, arr) {
    var context = Object(context) || window;
    context.fn = this;

    var result;
    if (!arr) {
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0, len = arr.length; i &lt; len; i++) {
            args.push(&apos;arr[&apos; + i + &apos;]&apos;);
        }
        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)
    }

    delete context.fn
    return result;
}
</code></pre><p><img src="https://pic1.zhimg.com/v2-23784bc5e0ab2bdcb4b879e5d28617c6_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-23784bc5e0ab2bdcb4b879e5d28617c6_hd.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-9374916fd3f03dab5836b9fc4057070a_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-9374916fd3f03dab5836b9fc4057070a_hd.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-7fe454d5cfd72880650f53a4f50c93cd_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-7fe454d5cfd72880650f53a4f50c93cd_hd.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-4f15656852b764a859194a3d7156ea99_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-4f15656852b764a859194a3d7156ea99_hd.jpg" alt=""></p>
<pre><code>类数组转对象
在上面的例子中已经提到了一种类数组转数组的方法，再补充三个：
var arrayLike = {0: &apos;name&apos;, 1: &apos;age&apos;, 2: &apos;sex&apos;, length: 3 }
// 1. slice
Array.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 2. splice
Array.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 3. ES6 Array.from
Array.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] 
// 4. apply
Array.prototype.concat.apply([], arrayLike)   




要说到类数组对象，Arguments 对象就是一个类数组对象。
在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。


传递参数
将参数从一个函数传递到另一个函数
// 使用 apply 将 foo 的参数传递给 bar
function foo() {
    bar.apply(this, arguments);
}
function bar(a, b, c) {
   console.log(a, b, c);
}

foo(1, 2, 3)




强大的ES6
使用ES6的 ... 运算符，我们可以轻松转成数组。
function func(...arguments) {
    console.log(arguments); // [1, 2, 3]
}

func(1, 2, 3);
</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>一句话介绍 bind:</p>
<blockquote>
<p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p>
</blockquote>
<p>由此我们可以首先得出 bind 函数的两个特点：</p>
<ol>
<li>返回一个函数</li>
<li>可以传入参数</li>
</ol>
<h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><p>从第一个特点开始，我们举个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar() {
    console.log(this.value);
}

// 返回了一个函数
var bindFoo = bar.bind(foo); 

bindFoo(); // 1
</code></pre><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">《JavaScript深入之call和apply的模拟实现》</a>。我们来写第一版的代码：</p>
<pre><code>// 第一版
Function.prototype.bind2 = function (context) {
    var self = this;
    return function () {
        self.apply(context);
    }

}
</code></pre><h2 id="传参的模拟实现"><a href="#传参的模拟实现" class="headerlink" title="传参的模拟实现"></a>传参的模拟实现</h2><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p>
<pre><code>var foo = {
    value: 1
};

function bar(name, age) {
    console.log(this.value);
    console.log(name);
    console.log(age);

}

var bindFoo = bar.bind(foo, &apos;daisy&apos;);
bindFoo(&apos;18&apos;);
// 1
// daisy
// 18
</code></pre><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p>
<p>这可咋办？不急，我们用 arguments 进行处理：</p>
<pre><code>// 第二版
Function.prototype.bind2 = function (context) {

    var self = this;
    // 获取bind2函数从第二个参数到最后一个参数
    var args = Array.prototype.slice.call(arguments, 1);

    return function () {
        // 这个时候的arguments是指bind返回的函数传入的参数
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(context, args.concat(bindArgs));
    }

}
</code></pre><h2 id="构造函数效果的模拟实现"><a href="#构造函数效果的模拟实现" class="headerlink" title="构造函数效果的模拟实现"></a>构造函数效果的模拟实现</h2><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p>
<blockquote>
<p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p>
</blockquote>
<p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p>
<pre><code>var value = 2;

var foo = {
    value: 1
};

function bar(name, age) {
    this.habit = &apos;shopping&apos;;
    console.log(this.value);
    console.log(name);
    console.log(age);
}

bar.prototype.friend = &apos;kevin&apos;;

var bindFoo = bar.bind(foo, &apos;daisy&apos;);

var obj = new bindFoo(&apos;18&apos;);
// undefined
// daisy
// 18
console.log(obj.habit);
console.log(obj.friend);
// shopping
// kevin
</code></pre><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p>
<p>(哈哈，我这是为我的下一篇文章<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">《JavaScript深入系列之new的模拟实现》</a>打广告)。</p>
<p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p>
<pre><code>// 第三版
Function.prototype.bind2 = function (context) {
    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值
        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性
        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context
        self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));
    }
    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值
    fBound.prototype = this.prototype;
    return fBound;
}
</code></pre><p>如果对原型链稍有困惑，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">《JavaScript深入之从原型到原型链》</a>。</p>
<h2 id="构造函数效果的优化实现"><a href="#构造函数效果的优化实现" class="headerlink" title="构造函数效果的优化实现"></a>构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p>
<pre><code>// 第四版
Function.prototype.bind2 = function (context) {

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
</code></pre><p>到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ</p>
<h2 id="三个小问题"><a href="#三个小问题" class="headerlink" title="三个小问题"></a>三个小问题</h2><p>接下来处理些小问题:</p>
<p>1.apply 这段代码跟 MDN 上的稍有不同</p>
<p>在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：</p>
<pre><code>self.apply(this instanceof self ? this : context || this, args.concat(bindArgs))
</code></pre><p>多了一个关于 context 是否存在的判断，然而这个是错误的！</p>
<p>举个例子：</p>
<pre><code>var value = 2;
var foo = {
    value: 1,
    bar: bar.bind(null)
};

function bar() {
    console.log(this.value);
}

foo.bar() // 2
</code></pre><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！</p>
<p>所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！</p>
<p>2.调用 bind 的不是函数咋办？</p>
<p>不行，我们要报错！</p>
<pre><code>if (typeof this !== &quot;function&quot;) {
  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
}
</code></pre><p>3.我要在线上用</p>
<p>那别忘了做个兼容：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function () {
    ……
};
</code></pre><p>当然最好是用 <a href="https://link.zhihu.com/?target=https%3A//github.com/es-shims/es5-shim" target="_blank" rel="noopener">es5-shim</a> 啦。</p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>所以最最后的代码就是：</p>
<pre><code>Function.prototype.bind2 = function (context) {

    if (typeof this !== &quot;function&quot;) {
      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
    }

    var self = this;
    var args = Array.prototype.slice.call(arguments, 1);

    var fNOP = function () {};

    var fBound = function () {
        var bindArgs = Array.prototype.slice.call(arguments);
        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/async-await-小技巧/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/30/async-await-小技巧/" itemprop="url">async/await 小技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-30T11:58:49+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="async-await-小技巧"><a href="#async-await-小技巧" class="headerlink" title="async/await 小技巧"></a>async/await 小技巧</h1><h2 id="sleep-函数"><a href="#sleep-函数" class="headerlink" title="sleep 函数"></a>sleep 函数</h2><p>以前只接使用 <code>setTimeout</code> 和回调函数实现一个 <code>sleep</code> 会有很多的副作用，用起来很不方便。</p>
<p>所以让 <code>setTimeout</code> 搭配使用 <code>async/await</code></p>
<pre><code>constsleep=delay=&gt; {
  returnnewPromise(resolve=&gt; {
    setTimeout(resolve, delay)
  })
}

constfn=async_=&gt; {
  console.log(&apos;starting....&apos;)
  awaitsleep(1000)
  console.log(&apos;after sleeping for 1 second&apos;)
}
</code></pre><h2 id="搭配-map-函数"><a href="#搭配-map-函数" class="headerlink" title="搭配 map() 函数"></a>搭配 map() 函数</h2><p>在 <code>map</code> 中引入异步处理:</p>
<pre><code>constarr= [1,2,3,4,5]
constasyncFn=data=&gt; {
  // 异步处理函数
}

constresults=arr.map(asyncnum=&gt; {
  awaitasyncFn(num)
  return++num
})

console.log(results)
</code></pre><p>代码执行后的结果 <code>[Promise, Promise, Promise, Promise, Promise]</code> 而且 <code>map</code> 函数并不会等异步函数 <code>asyncFn</code> 执行完毕后再返回结果</p>
<p>既然 <code>async</code> 执行后会返回一个 <code>Promise</code> 对象，所以可以通过 <code>Promise.all</code> 的状态来判断异步函数的状态:</p>
<pre><code>constarr= [1,2,3,4,5]
constasyncFn=data=&gt; {
  // 异步处理函数
}
constp=arr.map(asyncnum=&gt; {
  awaitasyncFn(num)
  return++num
})

Promise.all(p).then(results=&gt; {
  console.log(results)
})
</code></pre><p>这样就能正常返回结果 <code>[2, 3, 4, 5, 6]</code></p>
<h2 id="使用-await-代替-then-函数"><a href="#使用-await-代替-then-函数" class="headerlink" title="使用 await 代替 then() 函数"></a>使用 await 代替 then() 函数</h2><p>上面的例子最后使用了 <code>Promise.all</code>  还是回到了使用回调函数的方式</p>
<p>这个也很好解决，只需要在外层再加一个 <code>async</code> 函数</p>
<pre><code>constmain=async_=&gt; {
  constresults=awaitPromise.all(arr.map(num=&gt; {
    awaitasyncFn()
    return++num
  }))
  console.log(results)
}

main()
</code></pre><h2 id="搭配-reduce-函数"><a href="#搭配-reduce-函数" class="headerlink" title="搭配 reduce() 函数"></a>搭配 reduce() 函数</h2><p>通过引入 <code>async/await</code> 可以把 <code>reduce</code> 扩展成一个按顺序执行异步函数的工具</p>
<p><code>reduce</code> 用起来很简单:</p>
<pre><code>constarr= [1,2,3,4,5]
constresult=arr.reduce((prev, next) =&gt; {
  return prev+next
}, 0)

console.log(result)
</code></pre><p>像 <code>map</code> 函数一样引入 <code>async/await</code> :</p>
<pre><code>constarr= [1,2,3,4,5]
constmain=async_=&gt; {
  constresult=awaitarr.reduce(async (prev, next) =&gt; {
    consttmp=await prev
    return tmp + next
  }, Promise.resolve(0))

  console.log(result)
}

main()
</code></pre><p>而且还可以在 <code>reduce</code> 内部加入异步函数:</p>
<pre><code>constarr= [1,2,3,4,5]
constmain=async_=&gt; {
  constresult=awaitarr.reduce(async (prev, next) =&gt; {
    consttmp=await prev

    // 异步处理 暂停1sawaitsleep(1000)
    console.log(tmp + next)

    return tmp + next
  }, Promise.resolve(0))
}

main()
</code></pre><p>上述代码会每隔一秒依次打出 1 3 6 10 15</p>
<p>参考自</p>
<blockquote>
<p><a href="http://2ality.com/2016/10/async-function-tips.html" target="_blank" rel="noopener">http://2ality.com/2016/10/async-function-tips.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/15/用css让一个容器水平垂直居中/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/15/用css让一个容器水平垂直居中/" itemprop="url">用css让一个容器水平垂直居中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-15T23:19:26+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阅读目录</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label0" target="_blank" rel="noopener">方法一：position加margin</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label1" target="_blank" rel="noopener">方法二： diaplay:table-cell</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label2" target="_blank" rel="noopener">方法三：position加 transform</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label3" target="_blank" rel="noopener">方法四：flex;align-items: center;justify-content: center</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label4" target="_blank" rel="noopener">方法五：display:flex;margin:auto</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label5" target="_blank" rel="noopener">方法六：纯position</a></li>
</ul>
<p>这种css布局平时用的比较多，也是面试题常出的一个题，网上一搜一大丢，不过还是想自己总结一下。</p>
<p>这种方法比较多，本文只总结其中的几种，以便加深印象。</p>
<p>效果图都为这个：</p>
<p><img src="https://pic1.zhimg.com/v2-cf428b1f71583bc3feeeedcdc87d9e6c_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf428b1f71583bc3feeeedcdc87d9e6c_hd.jpg" alt=""></p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法一：position加margin"><a href="#方法一：position加margin" class="headerlink" title="方法一：position加margin"></a>方法一：position加margin</h2><pre><code>/**html**/
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/**css**/
.wrap {
    width: 200px;
    height: 200px;
    background: yellow;
    position: relative;
}
.wrap .center {
    width: 100px;
    height: 100px;
    background: green;
    margin: auto;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
}
</code></pre><p>兼容性：主流浏览器均支持，IE6不支持</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法二：-diaplay-table-cell"><a href="#方法二：-diaplay-table-cell" class="headerlink" title="方法二： diaplay:table-cell"></a>方法二： diaplay:table-cell</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
     &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/*css*/
.wrap{
    width: 200px;
    height: 200px;
    background: yellow;
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}
.center{
    display: inline-block;
    vertical-align: middle;
    width: 100px;
    height: 100px;
    background: green;
}
</code></pre><p>兼容性：由于display:table-cell的原因，IE6\7不兼容</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法三：position加-transform"><a href="#方法三：position加-transform" class="headerlink" title="方法三：position加 transform"></a>方法三：position加 transform</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    position: relative;
    background: yellow;
    width: 200px;
    height: 200px;}

.center {
    position: absolute;
    background: green;
    top:50%;
    left:50%;
    -webkit-transform:translate(-50%,-50%);
    transform:translate(-50%,-50%);
    width: 100px;
    height: 100px;
}
</code></pre><p>兼容性：ie9以下不支持 transform，手机端表现的比较好。</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法四：flex-align-items-center-justify-content-center"><a href="#方法四：flex-align-items-center-justify-content-center" class="headerlink" title="方法四：flex;align-items: center;justify-content: center"></a>方法四：flex;align-items: center;justify-content: center</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    display: flex; 
    align-items: center; 
    justify-content: center;
}

.center {
    background: green;
    width: 100px;
    height: 100px;
}
</code></pre><p>移动端首选</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法五：display-flex-margin-auto"><a href="#方法五：display-flex-margin-auto" class="headerlink" title="方法五：display:flex;margin:auto"></a>方法五：display:flex;margin:auto</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    display: flex; 
}

.center {
    background: green;
    width: 100px;
    height: 100px;
    margin: auto;
}
</code></pre><p>移动端首选</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法六：纯position"><a href="#方法六：纯position" class="headerlink" title="方法六：纯position"></a>方法六：纯position</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    position: relative;
}
/**方法一**/
.center {
    background: green;
    position: absolute;
    width: 100px;
    height: 100px;
    left: 50px;
    top: 50px; 
　　
}
/**方法二**/
.center {
    background: green;
    position: absolute;
    width: 100px;
    height: 100px;
    left: 50%;
    top: 50%;
　　margin-left:-50px;
　　margin-top:-50px;
}　 
</code></pre><p>兼容性：适用于所有浏览器</p>
<p>  方法六中的方法一计算公式如下：</p>
<p>　　子元素（conter）的left值计算公式：left=(父元素的宽 - 子元素的宽 ) / 2=(200-100) / 2=50px;</p>
<p>　　子元素（conter）的top值计算公式：top=(父元素的高 - 子元素的高 ) / 2=(200-100) / 2=50px;</p>
<p>　　方法二计算公式：</p>
<p>　　left值固定为50%;</p>
<p>　　子元素的margin-left= -（子元素的宽/2）=-100/2= -50px;</p>
<p>　　top值也一样，固定为50%</p>
<pre><code>子元素的margin-top= -（子元素的高/2）=-100/2= -50px;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/31/为什么Redux-需要-reducers是纯函数？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/31/为什么Redux-需要-reducers是纯函数？/" itemprop="url">为什么Redux 需要 reducers是纯函数？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-31T00:13:40+08:00">
                2017-07-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="为什么Redux-需要-reducers是纯函数？"><a href="#为什么Redux-需要-reducers是纯函数？" class="headerlink" title="为什么Redux 需要 reducers是纯函数？"></a>为什么Redux 需要 reducers是纯函数？</h4><p> 这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个state和action作为参数，然后返回一个新的state，这个新的state不能是在原来state基础上的修改。所以经常可以看到以下的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return Object.assign(...)</span><br><span class="line">//或者----------</span><br><span class="line">return &#123;...state,xx:xxx&#125;</span><br></pre></td></tr></table></figure></p>
<p>其作用，都是为了返回一个全新的对象。</p>
<p><strong>为什么reducers要求是纯函数(返回全新的对象，不影响原对象)?</strong>  –某面试官</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。<br>举个例子，下面的add函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add = (a,b) =&gt; &#123;a + b&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数<br>为什么必须是纯函数?<br>先告诉你结果吧，如果在reducer中，在原来的state上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！<br>接下来看下Redux的源码：<br><img src="https://user-gold-cdn.xitu.io/2018/8/22/165609de895ae1ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。<br>Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。<br>好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的state是全新的对象。那么为什么非要这么麻烦开发者呢？<br>请看下面的例子：尝试比较a和b是否相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;],</span><br><span class="line">    years: 12,</span><br><span class="line">    ...//省略n项目</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var b = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;],</span><br><span class="line">    years: 13,</span><br><span class="line">    ...//省略n项目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？<br>有！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//接上面的例子</span><br><span class="line">a === b  //false</span><br></pre></td></tr></table></figure></p>
<p> 我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是redux的reducer如此设计的原因了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/09/Node-js的文件路径的一些坑/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/09/Node-js的文件路径的一些坑/" itemprop="url">Node.js的文件路径的一些坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-09T18:16:04+08:00">
                2017-07-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在写一篇weex的webpack配置，刚刚踩坑了，weekpack中会用到path模块，而对于这个模块，我想抽离出来看一下，因为这个用到的还是比较多的,喜欢的朋友可以点个喜欢，或者去我的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Flaihuamin%252FJS-total" target="_blank" rel="noopener">github</a>点个star也行，谢谢支持，举起小手指点一点哦😯，写的不对的地方，评论拍砖，谢谢。</p>
<h2 id="node中的路径分类"><a href="#node中的路径分类" class="headerlink" title="node中的路径分类"></a>node中的路径分类</h2><p>node中的路径大致分5类，dirname,filename,process.cwd(),./,../,其中前三个都是绝对路径</p>
<p>我们先来看一个简单点的例子</p>
<p>假如，我有一个文件的目录结构如下：</p>
<pre><code>editor/
  - dist/
  - src/
      - task.js
</code></pre><p>然后我们在task.js文件中写入一下代码</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(__dirname);
console.log(__filename);
console.log(process.cwd());
console.log(path.resolve(&apos;./&apos;));
</code></pre><p>在editor目录下运行node src/task.js，我们可以看到结果如下：</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src/task.js
/Users/laihuamin/Documents/richEditor/editor
/Users/laihuamin/Documents/richEditor/editor
</code></pre><p>然后我们有可以在src目录下运行这个文件，node task.js,运行结果如下：</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src/task.js
/Users/laihuamin/Documents/richEditor/editor/src
/Users/laihuamin/Documents/richEditor/editor/src
</code></pre><p>对比两个输出结果，我们可以归纳一下几点：</p>
<p>1.<strong>dirname:返回的是这个文件所在文件夹的位置<br>2.</strong>filename:你运行命令代表的是文件所在的位置，不管你运行什么命令，都是指向文件<br>3.process.cwd():你运行node命令所在文件夹的位置，比如你在src目录下运行，那么就是输出到src为止，下面的同理。</p>
<hr>
<p>Node.js中的文件路径大概有 <strong>dirname, </strong>filename, process.cwd(), ./ 或者 ../，前三个都是绝对路径，为了便于比较，./ 和 ../ 我们通过 path.resolve(‘./‘)来转换为绝对路径。<br>简单说一下这几个路径的意思，：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname：    获得当前执行文件所在目录的完整目录名</span><br><span class="line">__filename：   获得当前执行文件的带有完整绝对路径的文件名</span><br><span class="line">process.cwd()：获得当前执行node命令时候的文件夹目录名 </span><br><span class="line">./：           文件所在目录</span><br></pre></td></tr></table></figure></p>
<p>先看一看我电脑当前的目录结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax/</span><br><span class="line">    -nodejs/</span><br><span class="line">        -1.findLargest.js</span><br><span class="line">        -2.path.js</span><br><span class="line">        -3.fs.js</span><br><span class="line">    -regs</span><br><span class="line">        -regx.js</span><br><span class="line">        -test.txt</span><br></pre></td></tr></table></figure></p>
<p>在 path.js 里面我们写这些代码，看看输出是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">console.log(&apos;__dirname：&apos;, __dirname)</span><br><span class="line">console.log(&apos;__filename：&apos;, __filename)</span><br><span class="line">console.log(&apos;process.cwd()：&apos;, process.cwd())</span><br><span class="line">console.log(&apos;./：&apos;, path.resolve(&apos;./&apos;))</span><br></pre></td></tr></table></figure></p>
<p>在当前目录下也就是nodejs目录运行<code>node path.js</code>，我们看看输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname：     /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs</span><br><span class="line">__filename：    /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs/2.path.js</span><br><span class="line">process.cwd()： /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs</span><br><span class="line">./：            /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs</span><br></pre></td></tr></table></figure></p>
<p>然后在 项目根目录ES6-lottery 目录下运行 <code>node syntax/nodejs/2.path.js</code>，我们再来看看输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname：     /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs</span><br><span class="line">__filename：    /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs/2.path.js</span><br><span class="line">process.cwd()： /Users/jawil/Desktop/nodejs/demo/ES6-lottery</span><br><span class="line">./：            /Users/jawil/Desktop/nodejs/demo/ES6-lottery</span><br></pre></td></tr></table></figure></p>
<p>答案显而易见？我们可以通过上面的例子对比，暂时得出表面的结论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname: 总是返回被执行的 js 所在文件夹的绝对路径</span><br><span class="line">__filename: 总是返回被执行的 js 的绝对路径</span><br><span class="line">process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</span><br><span class="line">./: 跟 process.cwd() 一样，返回 node 命令时所在的文件夹的绝对路径</span><br></pre></td></tr></table></figure></p>
<h2 id="require-源码解读"><a href="#require-源码解读" class="headerlink" title="require() 源码解读"></a><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">require() 源码解读</a></h2><p><img src="/2017/07/09/Node-js的文件路径的一些坑/1.webp" alt=""></p>
<p>那么关于 ./ 正确的结论是：</p>
<blockquote>
<p>在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。<br>只有在 require() 时才使用相对路径(./, ../)的写法，其他地方一律使用绝对路径，如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前目录下</span><br><span class="line"> path.dirname(__filename) + &apos;/path.js&apos;; </span><br><span class="line">// 相邻目录下</span><br><span class="line"> path.resolve(__dirname, &apos;../regx/regx.js&apos;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>讲完前面三个绝对路径，我倒是挺想来聊聊path这个模块的，这个node模块在很多地方都有应用，所以，对于我们来说，掌握他，对我们以后的发展更有利，不用每次看webpack的配置文件还要去查询一下这个api是干什么用的，很影响我们的效率</p>
<p><a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fnodejs.org%252Fapi%252Fpath.html" target="_blank" rel="noopener">nodeJS/path</a></p>
<p>上面那个网站有详细的api，但是我们这里不用都掌握吧，我就讲几个我遇到过的，我觉得webpack等工程配置中会用到的</p>
<h2 id="path-normalize"><a href="#path-normalize" class="headerlink" title="path.normalize"></a>path.normalize</h2><p>这个方法就是把不规范的路径规范化，比如看下面的例子</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;));
</code></pre><p>输出结果：</p>
<pre><code>/foo/bar/baz/asdf
</code></pre><h2 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h2><pre><code>const path = require(&apos;path&apos;);
console.log(path.join(&apos;src&apos;, &apos;task.js&apos;));

const path = require(&apos;path&apos;);
console.log(path.join(&apos;dist&apos;, &apos;task.js&apos;));

const path = require(&apos;path&apos;);
console.log(path.join(&apos;&apos;));
</code></pre><p>这么两个的输出结果是：</p>
<pre><code>src/task.js
dist/task.js
.
</code></pre><p>他的作用也就显而易见，他有一下几条规则：<br>1.传入的参数是字符串的路径片段，可以是一个，也可以是多个</p>
<p>2.返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，Unix系统是”/“，Windows系统是”\“，那么你在两个系统下看到的返回结果就不一样。</p>
<p>3.如果返回的路径字符串长度为零，那么他会返回一个’.’，代表当前的文件夹。</p>
<p>4.如果传入的参数中有不是字符串的，那就直接会报错</p>
<h2 id="path-parse"><a href="#path-parse" class="headerlink" title="path.parse"></a>path.parse</h2><p>我们先来看个例子，在src目录下的task.js写入</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor&apos;));
</code></pre><p>然后运行node src/task.js之后,输出的结果如下：</p>
<pre><code>{ 
  root: &apos;/&apos;,
  dir: &apos;/Users/laihuamin/Documents/richEditor&apos;,
  base: &apos;editor&apos;,
  ext: &apos;&apos;,
  name: &apos;editor&apos; 
}
</code></pre><p>他返回的是一个对象，那么我们来把这么几个名词熟悉一下：</p>
<p><img src="https://pic3.zhimg.com/v2-b7c5d496b89fde98f097a4a6e2ba7d03_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b7c5d496b89fde98f097a4a6e2ba7d03_hd.jpg" alt=""></p>
<p>这个表格应该展示的很形象，但是我们还是来解释一下这些名词：<br>1.root：代表根目录<br>2.dir：代表文件所在的文件夹<br>3.base：代表整一个文件<br>4.name：代表文件名<br>5.ext: 代表文件的后缀名</p>
<p>那我们根据下面的规则，来看一下下面这个例子，最好自己脑子做一遍</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果：</p>
<pre><code>{ 
  root: &apos;/&apos;,
  dir: &apos;/Users/laihuamin/Documents/richEditor/editor/src&apos;,
  base: &apos;task.js&apos;,
  ext: &apos;.js&apos;,
  name: &apos;task&apos; 
}
</code></pre><p>你做对了么？0.0</p>
<h2 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename"></a>path.basename</h2><p>那有了前面这个铺垫，想必这个接口猜也能猜的到了。。。。我们看下面这个例子</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果是：</p>
<pre><code>task.js
</code></pre><p>我们还是简单介绍一下，接收两个参数，一个是path,还有一个是ext（可选参数）.</p>
<pre><code>const path = require(&apos;path&apos;)
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;, &apos;.js&apos;));
</code></pre><p>输出结果:</p>
<pre><code>task
</code></pre><h2 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname"></a>path.dirname</h2><p>这个接口比basename还要简单，我就不多说了，看例子，看结果</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));
</code></pre><p>输出的结果:</p>
<pre><code>/Users/laihuamin/Documents/richEditor/editor/src
</code></pre><p>注意一下，接收的参数是字符串类型</p>
<h2 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname"></a>path.extname</h2><p>这个就是展示文件的扩展名，我们得注意几种情况</p>
<pre><code>const path = require(&apos;path&apos;);
path.extname(&apos;index.html&apos;);
path.extname(&apos;index.coffee.md&apos;);
path.extname(&apos;index.&apos;);
path.extname(&apos;index&apos;);
path.extname(&apos;.index&apos;);
</code></pre><p>输出的结果是：</p>
<pre><code>.html
.md
.
&apos;&apos;
&apos;&apos;
</code></pre><p>自己注意一下这几个情况</p>
<h2 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h2><p>我们通过下面这几个例子先来熟悉一下：</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.resolve(&apos;/foo/bar&apos;, &apos;/bar/faa&apos;, &apos;..&apos;, &apos;a/../c&apos;));
</code></pre><p>输出的结果是</p>
<pre><code>/bar/c
</code></pre><p>他就相当于一堆cd操作，我们一步一步看</p>
<pre><code>cd /foo/bar/    //这是第一步, 现在的位置是/foo/bar/
cd /bar/faa     //这是第二步，这里和第一步有区别，他是从/进入的，也就时候根目录，现在的位置是/bar/faa
cd ..       //第三步，从faa退出来，现在的位置是 /bar
cd a/../c   //第四步，进入a，然后在推出，在进入c，最后位置是/bar/c
</code></pre><p>但是这个操作和cd还是有区别的，这个路径不一定要存在，而且最后的可以是文件</p>
<h2 id="path-relative"><a href="#path-relative" class="headerlink" title="path.relative"></a>path.relative</h2><p>这个返回的是from到to的相对路径，什么意思呢，我们看下面的例子就知道了.</p>
<pre><code>const path = require(&apos;path&apos;);
console.log(path.relative(&apos;src/bar/baz&apos;, &apos;src/aaa/bbb&apos;));
</code></pre><p>输出的结果是：</p>
<pre><code>../../aaa/bbb
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些比较实用的方法，分享给大家，自己还是老老实实去看weektool的webpack的配置文件了，喜欢的朋友可以点个喜欢，或者去我的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Flaihuamin%252FJS-total" target="_blank" rel="noopener">github</a>点个star也行，谢谢支持，举起小手指点一点哦😯。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tx.jpg" alt="李斌">
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">133</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/25/Koa-session和cookie/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/25/Koa-session和cookie/" itemprop="url">Koa session和cookie</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-25T17:37:57+08:00">
                2018-08-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="从http协议的无状态性说起"><a href="#从http协议的无状态性说起" class="headerlink" title="从http协议的无状态性说起"></a>从http协议的无状态性说起</h2><p>HTTP是一种无状态协议。关于这个无状态之前我也不太理解，因为HTTP底层是TCP，既然是TCP，就是长连接，这个过程是保持连接状态的，又为什么说http是无状态的呢？先来搞清楚这两个概念：</p>
<h3 id="无连接和无状态"><a href="#无连接和无状态" class="headerlink" title="无连接和无状态"></a>无连接和无状态</h3><blockquote>
<p>无连接</p>
</blockquote>
<p>每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；</p>
<blockquote>
<p>无状态</p>
</blockquote>
<p>是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；</p>
<p>无连接的维度是连接，无状态的维度是请求；http是基于tcp的，而从http1.1开始默认使用持久连接；在这个连接过程中，客户端可以向服务端发送多次请求，但是各个请求之间的并没有什么联系；这样来考虑，就很好理解无状态这个概念了。</p>
<h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><blockquote>
<p>持久连接，本质上是客户端与服务器通信的时候，建立一个持久化的TCP连接，这个连接不会随着请求结束而关闭，通常会保持连接一段时间。`</p>
</blockquote>
<p>现有的持久连接类型有两种：HTTP/1.0+的 <strong> keep-alive </strong>和HTTP/1.1的<strong> persistent </strong>。</p>
<ul>
<li>HTTP/1.0+的keep-alive</li>
</ul>
<p>先来开一张图：<br><img src="/2018/08/25/Koa-session和cookie/1.webp" alt=""><br>这张图是请求<a href="http://www.baidu.com时的请求头信息。这里面我们需要注意的是：" target="_blank" rel="noopener">www.baidu.com时的请求头信息。这里面我们需要注意的是：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection: keep-alive</span><br></pre></td></tr></table></figure></p>
<p>我们每次发送一个HTTP请求，会附带一个connection:keep-alive，这个参数就是声明一个持久连接。</p>
<ul>
<li>HTTP/1.1的persistent</li>
</ul>
<p>HTTP/1.1的持久连接默认是开启的，只有首部中包含connection：close，才会事务结束之后关闭连接。当然服务器和客户端仍可以随时关闭持久连接。</p>
<p>当发送了connection：close首部之后客户端就没有办法在那条连接上发送更多的请求了。当然根据持久连接的特性，一定要传输正确的content-length。</p>
<p>还有根据HTTP/1.1的特性，是不应该和HTTP/1.0客户端建立持久连接的。最后，一定要做好重发的准备。</p>
<h3 id="http无状态"><a href="#http无状态" class="headerlink" title="http无状态"></a>http无状态</h3><p>OK，首先来明确下，这个状态的主体指的是什么？应该是信息，这些信息是由服务端所维护的与客户端交互的信息（也称为状态信息）；<br>因为HTTP本身是不保存任何用户的状态信息的，所以HTTP是无状态的协议。</p>
<h3 id="如何保持状态信息"><a href="#如何保持状态信息" class="headerlink" title="如何保持状态信息"></a>如何保持状态信息</h3><p>在聊这个这个问题之前，我们来考虑下为什么http自己不来做这个事情：也就是让http变成有状态的。</p>
<blockquote>
<p>http本身来实现状态维护</p>
</blockquote>
<p>从上面关于无状态的理解，如果现在需要让http自己变成有状态的，就意味着http协议需要保存交互的状态信息；暂且不说这种方式是否合适，但从维护状态信息这一点来说，代价就很高，因为既然保存了状态信息，那后续的一些行为必定也会受到状态信息的影响。</p>
<p>从历史角度来说，最初的http协议只是用来浏览静态文件的，无状态协议已经足够，这样实现的负担也很轻。但是随着web技术的不断发展，越来越多的场景需要状态信息能够得以保存；一方面是http本身不会去改变它的这种无状态的特性（至少目前是这样的），另一方面业务场景又迫切的需要保持状态；那么这个时候就需要来“装饰”一下http，引入一些其他机制来实现有状态。</p>
<blockquote>
<p>cookie和session体系</p>
</blockquote>
<p>通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie是由服务器发送给客户端（浏览器）的小量信息，以{key：value}的形式存在。</p>
<h3 id="Cookie机制原理"><a href="#Cookie机制原理" class="headerlink" title="Cookie机制原理"></a>Cookie机制原理</h3><p>客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。</p>
<blockquote>
<p>cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名的时候共享数据。</p>
</blockquote>
<blockquote>
<p>HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何   关系的。</p>
</blockquote>
<h4 id="Koa-Cookie-的使用"><a href="#Koa-Cookie-的使用" class="headerlink" title="Koa Cookie 的使用"></a>Koa Cookie 的使用</h4><p>1、Koa 中设置 Cookie 的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.set(name, value, [options])</span><br></pre></td></tr></table></figure></p>
<p>通过options 设置 cookie name 的value :</p>
<table>
<thead>
<tr>
<th>options 名称</th>
<th style="text-align:left">options 值</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxAge</td>
<td style="text-align:left">一个数字表示从 Date.now() 得到的毫秒数</td>
</tr>
<tr>
<td>expires</td>
<td style="text-align:left">cookie 过期的Date</td>
</tr>
<tr>
<td>path</td>
<td style="text-align:left">cookie 路径, 默认是’/‘</td>
</tr>
<tr>
<td>domain</td>
<td style="text-align:left">cookie 域名,可以访问该Cookie的域名。如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该Cookie；第一个字符必须为“.”</td>
</tr>
<tr>
<td>secure</td>
<td style="text-align:left">安全 cookie    默认 false，设置成 true 表示只有 https 可以访问</td>
</tr>
<tr>
<td>httpOnly</td>
<td style="text-align:left">是否只是服务器可访问 cookie, 默认是true</td>
</tr>
<tr>
<td>overwrite</td>
<td style="text-align:left">一个布尔值，表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（不管路径或域） 是否在设置此 Cookie 时从Set-Cookie 标头中过滤掉。</td>
</tr>
</tbody>
</table>
<h3 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h3><blockquote>
<p>name</p>
</blockquote>
<p>cookie的名字，Cookie一旦创建，名称便不可更改</p>
<blockquote>
<p>value</p>
</blockquote>
<p>cookie值</p>
<blockquote>
<p>comment</p>
</blockquote>
<p>该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</p>
<blockquote>
<p>maxAge</p>
</blockquote>
<p>Cookie失效的时间，单位秒。</p>
<ul>
<li><p>正数，则超过maxAge秒之后失效。</p>
</li>
<li><p>负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。</p>
</li>
<li><p>为0，表示删除该Cookie。</p>
</li>
</ul>
<blockquote>
<p>path</p>
</blockquote>
<p>该Cookie的使用路径。例如：</p>
<ul>
<li>path=/，说明本域名下contextPath都可以访问该Cookie。</li>
<li>path=/app/，则只有contextPath为“/app”的程序可以访问该Cookie</li>
</ul>
<p>path设置时，其以“/”结尾.</p>
<blockquote>
<p>secure</p>
</blockquote>
<p>该Cookie是否仅被使用安全协议传输。这里的安全协议包括HTTPS，SSL等。默认为false。</p>
<h3 id="从请求中获取Cookie"><a href="#从请求中获取Cookie" class="headerlink" title="从请求中获取Cookie"></a>从请求中获取Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.get(&apos;name&apos;);</span><br></pre></td></tr></table></figure>
<h3 id="Cookie同源与跨域"><a href="#Cookie同源与跨域" class="headerlink" title="Cookie同源与跨域"></a>Cookie同源与跨域</h3><p>我们知道浏览器的同源策略：</p>
<blockquote>
<p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。</p>
</blockquote>
<p>对于Cookie来说，Cookie的同源只关注域名，是忽略协议和端口的。所以一般情况下，<a href="https://localhost:80/和http://localhost:8080/的Cookie是共享的。" target="_blank" rel="noopener">https://localhost:80/和http://localhost:8080/的Cookie是共享的。</a></p>
<p>Cookie是不可跨域的；在没有经过任何处理的情况下，二级域名不同也是不行的。(wenku.baidu.com和baike.baidu.com)。</p>
<h3 id="Cookie数量-amp-大小限制及处理策略"><a href="#Cookie数量-amp-大小限制及处理策略" class="headerlink" title="Cookie数量&amp;大小限制及处理策略"></a>Cookie数量&amp;大小限制及处理策略</h3><table>
<thead>
<tr>
<th>–</th>
<th>IE6.0</th>
<th>IE7.0/8.0</th>
<th>Opera</th>
<th>FF</th>
<th>Safari</th>
<th>Chrome</th>
</tr>
</thead>
<tbody>
<tr>
<td>个数/个</td>
<td>20/域</td>
<td>50/域</td>
<td>30/域</td>
<td>50/域</td>
<td>无限制</td>
<td>53/域</td>
</tr>
<tr>
<td>大小/Byte</td>
<td>4095</td>
<td>4095</td>
<td>4096</td>
<td>4097</td>
<td>4097</td>
<td>4097</td>
</tr>
</tbody>
</table>
<h3 id="Koa-中设置中文-Cookie"><a href="#Koa-中设置中文-Cookie" class="headerlink" title="Koa 中设置中文 Cookie"></a>Koa 中设置中文 Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 转换成 base64 字符串：aGVsbG8sIHdvcmxkIQ==</span><br><span class="line">console.log(new Buffer(&apos;hello, world!&apos;).toString(&apos;base64&apos;));</span><br><span class="line"></span><br><span class="line">// 还原 base64 字符串：hello, world!</span><br><span class="line">console.log(new Buffer(&apos;aGVsbG8sIHdvcmxkIQ==&apos;, &apos;base64&apos;).toString());</span><br></pre></td></tr></table></figure>
<h3 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">var Koa=require(&apos;koa&apos;),</span><br><span class="line">    router = require(&apos;koa-router&apos;)(),</span><br><span class="line">    render = require(&apos;koa-art-template&apos;),</span><br><span class="line">    path=require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">var app=new Koa();</span><br><span class="line"></span><br><span class="line">//配置 koa-art-template模板引擎</span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, &apos;views&apos;),   // 视图的位置</span><br><span class="line">    extname: &apos;.html&apos;,  // 后缀名</span><br><span class="line">    debug: process.env.NODE_ENV !== &apos;production&apos;  //是否开启调试模式</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(&apos;/&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //正常就这样配置就可以使用了</span><br><span class="line">    /*</span><br><span class="line">     ctx.cookies.set(&apos;userinfo&apos;,&apos;zhangsan&apos;,&#123;</span><br><span class="line">        maxAge:60*1000*60</span><br><span class="line">     &#125;);</span><br><span class="line">    * */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ctx.cookies.set(&apos;userinfo&apos;,&apos;zhangsan2222&apos;,&#123;</span><br><span class="line">        maxAge:60*1000*60,</span><br><span class="line"></span><br><span class="line">       // path:&apos;/news&apos;,  /*配置可以访问的页面*/</span><br><span class="line">        //domain:&apos;.baidu.com&apos;  /*正常情况不要设置 默认就是当前域下面的所有页面都可以方法*/</span><br><span class="line"></span><br><span class="line">        httpOnly:false,  //true表示这个cookie只有服务器端可以访问，false表示客户端（js），服务器端都可以访问</span><br><span class="line">        /*</span><br><span class="line">            a.baidu.com</span><br><span class="line">            b.baidu.com  共享cookie的数据</span><br><span class="line">            express基础教程</span><br><span class="line">        * */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let list=&#123;</span><br><span class="line">        name:&apos;张三&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    await ctx.render(&apos;index&apos;,&#123;</span><br><span class="line">        list:list</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(&apos;/about&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    ctx.cookies.set(&apos;userinfo&apos;,&apos;zhangsan33333&apos;,&#123;</span><br><span class="line">        maxAge:60*1000*60,</span><br><span class="line">        path:&apos;/news&apos;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ctx.body=&quot;这是关于我们&quot;;</span><br><span class="line">&#125;)</span><br><span class="line">//接收post提交的数据</span><br><span class="line">router.get(&apos;/news&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    var userinfo=ctx.cookies.get(&apos;userinfo&apos;);</span><br><span class="line"></span><br><span class="line">    console.log(userinfo);</span><br><span class="line">    let app=&#123;</span><br><span class="line">        name:&apos;张三11&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    await ctx.render(&apos;news&apos;,&#123;</span><br><span class="line">        list:app</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(&apos;/shop&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    var userinfo=ctx.cookies.get(&apos;userinfo&apos;);</span><br><span class="line"></span><br><span class="line">    console.log(userinfo);</span><br><span class="line">   ctx.body=&apos;这是一个商品页面&apos;+userinfo;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());   /*启动路由*/</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而session 保存在服务器上。</p>
<p>Cookie机制弥补了HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p>
<p>与Cookie不同的是，session是以服务端保存状态的。</p>
<h3 id="session机制原理"><a href="#session机制原理" class="headerlink" title="session机制原理"></a>session机制原理</h3><p>当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session 对象，生成一个类似于key,value 的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带 key(cookie)，找到对应的 session(value)。 客户的信息都保存在session 中</p>
<p>当客户端请求创建一个session的时候，服务器会先检查这个客户端的请求里是否已包含了一个session标识 - sessionId，</p>
<ul>
<li>如果已包含这个sessionId，则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（如果检索不到，可能会新建一个）</li>
<li>如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId</li>
</ul>
<p>sessionId的值一般是一个既不会重复，又不容易被仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p>
<h3 id="koa-session-的使用"><a href="#koa-session-的使用" class="headerlink" title="koa-session 的使用:"></a>koa-session 的使用:</h3><blockquote>
<p>安装    express-session</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm	install	koa-session --save</span><br></pre></td></tr></table></figure>
<blockquote>
<p>引入express-session</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const session = require(&apos;koa-session&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置官方文档提供的中间件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.keys = [&apos;some secret hurr&apos;];   /*cookie的签名*/</span><br><span class="line">const CONFIG = &#123;</span><br><span class="line">    key: &apos;koa:sess&apos;, /** 默认 */</span><br><span class="line">    maxAge: 10000,  /*  cookie的过期时间        【需要修改】  */</span><br><span class="line">    overwrite: true, /** (boolean) can overwrite or not (default true)    没有效果，默认 */</span><br><span class="line">    httpOnly: true, /**  true表示只有服务器端可以获取cookie */</span><br><span class="line">    signed: true, /** 默认 签名 */</span><br><span class="line">    rolling: true, /** 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） 【需要修改】 */</span><br><span class="line">    renew: false, /** 快要过期的时候重新设置      【需要修改】*/</span><br><span class="line">&#125;;</span><br><span class="line">app.use(session(CONFIG, app));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//设置值 </span><br><span class="line">ctx.session.username = &quot;张三&quot;;</span><br><span class="line"></span><br><span class="line">//获取值 </span><br><span class="line">ctx.session.username</span><br></pre></td></tr></table></figure>
<h3 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var Koa=require(&apos;koa&apos;),</span><br><span class="line">    router = require(&apos;koa-router&apos;)(),</span><br><span class="line">    render = require(&apos;koa-art-template&apos;),</span><br><span class="line">    path=require(&apos;path&apos;),</span><br><span class="line">    session = require(&apos;koa-session&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app=new Koa();</span><br><span class="line"></span><br><span class="line">//配置 koa-art-template模板引擎</span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, &apos;views&apos;),   // 视图的位置</span><br><span class="line">    extname: &apos;.html&apos;,  // 后缀名</span><br><span class="line">    debug: process.env.NODE_ENV !== &apos;production&apos;  //是否开启调试模式</span><br><span class="line">&#125;);</span><br><span class="line">//配置session的中间件</span><br><span class="line">app.keys = [&apos;some secret hurr&apos;];   /*cookie的签名*/</span><br><span class="line">const CONFIG = &#123;</span><br><span class="line">    key: &apos;koa:sess&apos;, /** 默认 */</span><br><span class="line">    maxAge: 10000,  /*  cookie的过期时间        【需要修改】  */</span><br><span class="line">    overwrite: true, /** (boolean) can overwrite or not (default true)    没有效果，默认 */</span><br><span class="line">    httpOnly: true, /**  true表示只有服务器端可以获取cookie */</span><br><span class="line">    signed: true, /** 默认 签名 */</span><br><span class="line">    rolling: true, /** 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） 【需要修改】 */</span><br><span class="line">    renew: false, /** (boolean) renew session when session is nearly expired      【需要修改】*/</span><br><span class="line">&#125;;</span><br><span class="line">app.use(session(CONFIG, app));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(&apos;/&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //获取session</span><br><span class="line">    console.log(ctx.session.userinfo);</span><br><span class="line">    await ctx.render(&apos;index&apos;,&#123;</span><br><span class="line">        list:&#123;</span><br><span class="line">            name:&apos;张三&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(&apos;/news&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //获取session</span><br><span class="line">    console.log(ctx.session.userinfo);</span><br><span class="line">    ctx.body=&quot;登录成功&quot;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(&apos;/login&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //设置session</span><br><span class="line">    ctx.session.userinfo=&apos;张三&apos;;</span><br><span class="line">    ctx.body=&quot;登录成功&quot;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(router.routes());   /*启动路由*/</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<h3 id="Cookie-和-Session-区别"><a href="#Cookie-和-Session-区别" class="headerlink" title="Cookie 和 Session 区别"></a>Cookie 和 Session 区别</h3><p>1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p>
<p>2、cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗考虑到安全应当使用 session。</p>
<p>3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE。</p>
<p>4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。    </p>
<p>这两种是一样的；如果session不存在，就新建一个；如果是false的话，标识如果不存在就返回null；</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>session的生命周期指的是创建session对象到销毁的过程。会依据session对象设置的存活时间，在达到session时间后将session对象销毁。session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。</p>
<p>之前在单进程应用中，session我一般是存在内存中的，不会做持久化操作或者说使用三方的服务来存session信息，如<strong>redis</strong>。但是在分布式场景下，这种存在本机内存中的方式显然是不适用的，因为session无法共享。这个后面说。</p>
<h3 id="session的有效期"><a href="#session的有效期" class="headerlink" title="session的有效期"></a>session的有效期</h3><p>session一般在内存中存放，内存空间本身大小就有一定的局限性，因此session需要采用一种过期删除的机制来确保session信息不会一直累积，来防止内存溢出的发生。</p>
<p>session的超时时间可以通过maxInactiveInterval属性来设置。</p>
<p>如果我们想让session失效的话，也可以当通过调用session的invalidate()来完成。</p>
<h3 id="分布式session"><a href="#分布式session" class="headerlink" title="分布式session"></a>分布式session</h3><p>首先是为什么会有这样的概念出现？</p>
<p>先考虑这样一个问题，现在我的应用需要部署在3台机器上。是不是出现这样一种情况，我第一次登陆，请求去了机器1，然后再机器1上创建了一个session；但是我第二次访问时，请求被路由到机器2了，但是机器2上并没有我的session信息，所以得重新登录。当然这种可以通过nginx的IP HASH负载策略来解决。对于同一个IP请求都会去同一个机器。</p>
<p>但是业务发展的越来越大，拆分的越来越多，机器数不断增加；很显然那种方案就不行了。那么这个时候就需要考虑是不是应该将session信息放在一个独立的机器上，所以分布式session要解决的问题其实就是分布式环境下的session共享的问题。<br> <img src="/2018/08/25/Koa-session和cookie/2.webp" alt=""><br>上图中的关于session独立部署的方式有很多种，可以是一个独立的数据库服务，也可以是一个缓存服务(redis，目前比较常用的一种方式，即使用Redis来作为session缓存服务器)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/24/async-并发执行和继发执行/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/24/async-并发执行和继发执行/" itemprop="url">async 并发执行和继发执行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-24T19:50:49+08:00">
                2018-08-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong> 面试题继发执行 : 1s后执行10，等1s后输出20，再等1s后输出30 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">			function Pro(val) &#123;</span><br><span class="line">				return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">					setTimeout(function() &#123;</span><br><span class="line">						resolve(val)</span><br><span class="line">					&#125;, 1000)</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			async function log(arrs) &#123;</span><br><span class="line">				for(const item of arrs) &#123;</span><br><span class="line">					var response = await Pro(item);</span><br><span class="line">					console.log(response);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			log([10, 20, 30])</span><br><span class="line">	&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>问题：给定一个 URL 数组，如何实现接口的继发和并发？</strong></p>
<h3 id="async-继发实现："><a href="#async-继发实现：" class="headerlink" title="async 继发实现："></a>async 继发实现：</h3><h4 id="继发一"><a href="#继发一" class="headerlink" title="继发一"></a>继发一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function loadData() &#123;</span><br><span class="line">  var res1 = await fetch(url1);</span><br><span class="line">  var res2 = await fetch(url2);</span><br><span class="line">  var res3 = await fetch(url3);</span><br><span class="line">  return&quot;whew all done&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继发二"><a href="#继发二" class="headerlink" title="继发二"></a>继发二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function loadData(urls) &#123;</span><br><span class="line">  for (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async-并发实现："><a href="#async-并发实现：" class="headerlink" title="async 并发实现："></a>async 并发实现：</h3><h4 id="并发一"><a href="#并发一" class="headerlink" title="并发一"></a>并发一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function loadData() &#123;</span><br><span class="line">  var res = awaitPromise.all([fetch(url1), fetch(url2), fetch(url3)]);</span><br><span class="line">  return&quot;whew all done&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并发二"><a href="#并发二" class="headerlink" title="并发二"></a>并发二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function loadData(urls) &#123;</span><br><span class="line">  // 并发读取 url</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    return response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  for (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/Vue批量异步更新与nextTick原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/Vue批量异步更新与nextTick原理/" itemprop="url">Vue批量异步更新与nextTick原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T13:13:34+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>异步更新</li>
</ol>
<p>我们在依赖收集原理的响应式化方法 defineReactive 中的 setter 访问器中有派发更新 dep.notify() 方法。</p>
<p>这个方法会挨个通知在 dep 的 subs 中收集的订阅自己变动的watchers执行update。</p>
<p>一起来看看 update 方法的实现：</p>
<pre><code>// src/core/observer/watcher.js

/* Subscriber接口，当依赖发生改变的时候进行回调 */
update() {
  if (this.computed) {
    // 一个computed watcher有两种模式：activated lazy(默认)
    // 只有当它被至少一个订阅者依赖时才置activated，这通常是另一个计算属性或组件的render function
    if (this.dep.subs.length === 0) {       // 如果没人订阅这个计算属性的变化
      // lazy时，我们希望它只在必要时执行计算，所以我们只是简单地将观察者标记为dirty
      // 当计算属性被访问时，实际的计算在this.evaluate()中执行
      this.dirty = true
    } else {
      // activated模式下，我们希望主动执行计算，但只有当值确实发生变化时才通知我们的订阅者
      this.getAndInvoke(() =&gt; {
        this.dep.notify()     // 通知渲染watcher重新渲染，通知依赖自己的所有watcher执行update
      })
    }
  } else if (this.sync) {      // 同步
    this.run()
  } else {
    queueWatcher(this)        // 异步推送到调度者观察者队列中，下一个tick时调用
  }
}
</code></pre><p>如果不是 computed watcher 也非 sync 会把调用update的当前watcher推送到调度者队列中，下一个tick时调用，看看 queueWatcher ：</p>
<pre><code>// src/core/observer/scheduler.js

/* 将一个观察者对象push进观察者队列，在队列中已经存在相同的id则
 * 该watcher将被跳过，除非它是在队列正被flush时推送
 */
export function queueWatcher (watcher: Watcher) {
  const id = watcher.id
  if (has[id] == null) {     // 检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验
    has[id] = true
    queue.push(watcher)      // 如果没有正在flush，直接push到队列中
    if (!waiting) {          // 标记是否已传给nextTick
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}

/* 重置调度者状态 */
function resetSchedulerState () {
  queue.length = 0
  has = {}
  waiting = false
}
</code></pre><p>这里使用了一个 has 的哈希map用来检查是否当前watcher的id是否存在，若已存在则跳过。</p>
<p>不存在则就push到 queue 队列中并标记哈希表has，用于下次检验，防止重复添加。</p>
<p>这就是一个去重的过程，比每次查重都要去queue中找要文明，在渲染的时候就不会重复 patch 相同watcher的变化。</p>
<p>这样就算同步修改了一百次视图中用到的data，异步 patch 的时候也只会更新最后一次修改。</p>
<p>这里的 waiting 方法是用来标记 flushSchedulerQueue 是否已经传递给 nextTick 的标记位。</p>
<p>如果已经传递则只push到队列中不传递 flushSchedulerQueue 给 nextTick。</p>
<p>等到 resetSchedulerState 重置调度者状态的时候 waiting 会被置回 false 允许 flushSchedulerQueue 被传递给下一个tick的回调。</p>
<p>总之保证了 flushSchedulerQueue 回调在一个tick内只允许被传入一次。</p>
<p>来看看被传递给 nextTick 的回调 flushSchedulerQueue 做了什么：</p>
<pre><code>// src/core/observer/scheduler.js

/* nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers */
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  queue.sort((a, b) =&gt; a.id - b.id)                    // 排序

  for (index = 0; index &lt; queue.length; index++) {     // 不要将length进行缓存
    watcher = queue[index]
    if (watcher.before) {         // 如果watcher有before则执行
      watcher.before()
    }
    id = watcher.id
    has[id] = null                // 将has的标记删除
    watcher.run()                 // 执行watcher
    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) {  // 在dev环境下检查是否进入死循环
      circular[id] = (circular[id] || 0) + 1     // 比如user watcher订阅自己的情况
      if (circular[id] &gt; MAX_UPDATE_COUNT) {     // 持续执行了一百次watch代表可能存在死循环
        warn()                                  // 进入死循环的警告
        break
      }
    }
  }
  resetSchedulerState()           // 重置调度者状态
  callActivatedHooks()            // 使子组件状态都置成active同时调用activated钩子
  callUpdatedHooks()              // 调用updated钩子
}
</code></pre><p>在 nextTick 方法中执行 flushSchedulerQueue 方法，这个方法挨个执行 queue 中的watcher的 run 方法。</p>
<p>我们看到在首先有个 queue.sort() 方法把队列中的watcher按id从小到大排了个序，这样做可以保证：</p>
<ol>
<li><p>组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。</p>
</li>
<li><p>一个组件的user watchers(侦听器watcher)比render watcher先运行，因为user watchers往往比render watcher更早创建</p>
</li>
<li><p>如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过</p>
</li>
</ol>
<p>在挨个执行队列中的for循环中，index &lt; queue.length 这里没有将length进行缓存。</p>
<p>因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue。</p>
<p>那么数据的修改从model层反映到view的过程：数据更改 -&gt; setter -&gt; Dep -&gt; Watcher -&gt; nextTick -&gt; patch -&gt; 更新视图</p>
<ol start="2">
<li>nextTick原理</li>
</ol>
<p><strong>2.1 宏任务/微任务</strong></p>
<p>这里就来看看包含着每个watcher执行的方法被作为回调传入 nextTick 之后，nextTick 对这个方法做了什么。</p>
<p>不过首先要了解一下浏览器中的 EventLoop、macro task、micro task几个概念。</p>
<p>不了解可以参考一下 JS与Node.js中的事件循环 这篇文章，这里就用一张图来表明一下后两者在主线程中的执行关系：</p>
<p><img src="/2018/08/20/Vue批量异步更新与nextTick原理/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt=""></p>
<p>解释一下，当主线程执行完同步任务后：</p>
<ol>
<li><p>引擎首先从macrotask queue中取出第一个任务，执行完毕后，将microtask queue中的所有任务取出，按顺序全部执行；</p>
</li>
<li><p>然后再从macrotask queue中取下一个，执行完毕后，再次将microtask queue中的全部取出；</p>
</li>
<li><p>循环往复，直到两个queue中的任务都取完。</p>
</li>
</ol>
<p>浏览器环境中常见的异步任务种类，按照优先级：</p>
<ul>
<li>macro task ：</li>
</ul>
<p>同步代码、setImmediate、MessageChannel、setTimeout/setInterval</p>
<ul>
<li>micro task：</li>
</ul>
<p>Promise.then、MutationObserver</p>
<p>有的文章把 micro task 叫微任务，macro task 叫宏任务，因为这两个单词拼写太像了 -。- ，所以后面的注释多用中文表示~</p>
<p>先来看看源码中对micro task与macro task 的实现： macroTimerFunc、microTimerFunc</p>
<pre><code>// src/core/util/next-tick.js

const callbacks = []     // 存放异步执行的回调
let pending = false      // 一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送

/* 挨个同步执行callbacks中回调 */
function flushCallbacks() {
  pending = false
  const copies = callbacks.slice(0)
  callbacks.length = 0
  for (let i = 0; i &lt; copies.length; i++) {
    copies[i]()
  }
}

let microTimerFunc        // 微任务执行方法
let macroTimerFunc        // 宏任务执行方法
let useMacroTask = false  // 是否强制为宏任务，默认使用微任务

// 宏任务
if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) {
  macroTimerFunc = () =&gt; {
    setImmediate(flushCallbacks)
  }
} else if (typeof MessageChannel !== &apos;undefined&apos; &amp;&amp; (
  isNative(MessageChannel) ||
  MessageChannel.toString() === &apos;[object MessageChannelConstructor]&apos;  // PhantomJS
)) {
  const channel = new MessageChannel()
  const port = channel.port2
  channel.port1.onmessage = flushCallbacks
  macroTimerFunc = () =&gt; {
    port.postMessage(1)
  }
} else {
  macroTimerFunc = () =&gt; {
    setTimeout(flushCallbacks, 0)
  }
}

// 微任务
if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) {
  const p = Promise.resolve()
  microTimerFunc = () =&gt; {
    p.then(flushCallbacks)
  }
} else {
  microTimerFunc = macroTimerFunc      // fallback to macro
}
</code></pre><p>flushCallbacks 这个方法就是挨个同步的去执行callbacks中的回调函数们，callbacks中的回调函数是在调用 nextTick 的时候添加进去的；</p>
<p>那么怎么去使用 micro task 与 macro task 去执行 flushCallbacks 呢。</p>
<p>这里他们的实现 macroTimerFunc、microTimerFunc 使用浏览器中宏任务/微任务的API对flushCallbacks 方法进行了一层包装。</p>
<p>比如宏任务方法 macroTimerFunc=()=&gt;{ setImmediate(flushCallbacks) }，这样在触发宏任务执行的时候 macroTimerFunc() 就可以在浏览器中的下一个宏任务loop的时候消费这些保存在callbacks数组中的回调了，微任务同理。</p>
<p>同时也可以看出传给 nextTick 的异步回调函数是被压成了一个同步任务在一个tick执行完的，而不是开启多个异步任务。</p>
<p>注意这里有个比较难理解的地方，第一次调用 nextTick 的时候 pending 为false。</p>
<p>此时已经push到浏览器event loop中一个宏任务或微任务的task，如果在没有flush掉的情况下继续往callbacks里面添加。</p>
<p>那么在执行这个占位queue的时候会执行之后添加的回调，所以 macroTimerFunc、microTimerFunc 相当于task queue的占位。</p>
<p>以后 pending 为true则继续往占位queue里面添加，event loop轮到这个task queue的时候将一并执行。</p>
<p>执行 flushCallbacks 时 pending 置false，允许下一轮执行 nextTick 时往event loop占位。</p>
<p>可以看到上面 macroTimerFunc 与 microTimerFunc 进行了在不同浏览器兼容性下的平稳退化，或者说降级策略：</p>
<p>1、macroTimerFunc ：</p>
<p>setImmediate -&gt; MessageChannel -&gt; setTimeout。</p>
<p>首先检测是否原生支持 setImmediate，这个方法只在 IE、Edge 浏览器中原生实现。</p>
<p>然后检测是否支持 MessageChannel，如果对 MessageChannel 不了解可以参考一下这篇文章。还不支持的话最后使用setTimeout；</p>
<p>为什么优先使用 setImmediate 与 MessageChannel 而不直接使用 setTimeout 呢。</p>
<p>是因为HTML5规定setTimeout执行的最小延时为4ms，而嵌套的timeout表现为10ms。</p>
<p>为了尽可能快的让回调执行，没有最小延时限制的前两者显然要优于 setTimeout。</p>
<p>2、microTimerFunc：</p>
<p>Promise.then -&gt; macroTimerFunc 。</p>
<p>首先检查是否支持 Promise，如果支持的话通过 Promise.then 来调用 flushCallbacks 方法。</p>
<p>否则退化为 macroTimerFunc ；</p>
<p>vue2.5之后 nextTick 中因为兼容性原因删除了微任务平稳退化的 MutationObserver 的方式。</p>
<p><strong>2.2 nextTick实现</strong></p>
<p>最后来看看我们平常用到的 nextTick 方法到底是如何实现的：</p>
<pre><code>// src/core/util/next-tick.js

export function nextTick(cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() =&gt; {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, &apos;nextTick&apos;)
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    if (useMacroTask) {
      macroTimerFunc()
    } else {
      microTimerFunc()
    }
  }
  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) {
    return new Promise(resolve =&gt; {
      _resolve = resolve
    })
  }
}

/* 强制使用macrotask的方法 */
export function withMacroTask(fn: Function): Function {
  return fn._withTask || (fn._withTask = function() {
    useMacroTask = true
    const res = fn.apply(null, arguments)
    useMacroTask = false
    return res
  })
}
</code></pre><p>nextTick 在这里分为三个部分，我们一起来看一下；</p>
<p>1、首先 nextTick 把传入的 cb 回调函数用 try-catch 包裹后放在一个匿名函数中推入callbacks数组中。</p>
<p>这么做是因为防止单个 cb 如果执行错误不至于让整个JS线程挂掉。</p>
<p>每个 cb 都包裹是防止这些回调函数如果执行错误不会相互影响，比如前一个抛错了后一个仍然可以执行。</p>
<p>2、然后检查 pending 状态，这个跟之前介绍的 queueWatcher 中的 waiting 是一个意思。</p>
<p>它是一个标记位，一开始是 false 在进入</p>
<p>macroTimerFunc、microTimerFunc方法前被置为 true。</p>
<p>因此下次调用 nextTick 就不会进入</p>
<p>macroTimerFunc、microTimerFunc方法。</p>
<p>这两个方法中会在下一个 macro/micro tick 时候 flushCallbacks 异步的去执行callbacks队列中收集的任务，而 flushCallbacks 方法在执行一开始会把 pending 置 false。</p>
<p>因此下一次调用 nextTick 时候又能开启新一轮的 macroTimerFunc、microTimerFunc，这样就形成了vue中的 event loop。</p>
<p>3、最后检查是否传入了 cb。</p>
<p>因为 nextTick 还支持Promise化的调用：nextTick().then(() =&gt; {})。</p>
<p>所以如果没有传入 cb 就直接return了一个Promise实例，并且把resolve传递给_resolve。</p>
<p>这样后者执行的时候就跳到我们调用的时候传递进 then 的方法中。</p>
<p>Vue源码中 next-tick.js 文件还有一段重要的注释，这里就翻译一下：</p>
<p>在vue2.5之前的版本中，nextTick基本上基于 micro task 来实现的。</p>
<p>但是在某些情况下 micro task 具有太高的优先级，并且可能在连续顺序事件之间（例如＃4521，＃6690）或者甚至在同一事件的事件冒泡过程中之间触发（＃6566）。</p>
<p>但是如果全部都改成 macro task，对一些有重绘和动画的场景也会有性能影响，如 issue #6813。</p>
<p>vue2.5之后版本提供的解决办法是默认使用 micro task，但在需要时（例如在v-on附加的事件处理程序中）强制使用 macro task。</p>
<p>为什么默认优先使用 micro task 呢。</p>
<p>是利用其高优先级的特性，保证队列中的微任务在一次循环全部执行完毕。</p>
<p>强制 macro task 的方法是在绑定 DOM 事件的时候。</p>
<p>默认会给回调的 handler 函数调用 withMacroTask 方法做一层包装 handler = withMacroTask(handler)。</p>
<p>它保证整个回调函数执行过程中，遇到数据状态的改变，这些改变都会被推到 macro task 中。</p>
<p>以上实现在src/platforms/web/runtime/modules/events.js</p>
<p>的 add 方法中，可以自己看一看具体代码。</p>
<p>刚好在写这篇文章的时候思否上有人问了个问题 vue 2.4 和2.5 版本的@input事件不一样。</p>
<p>这个问题的原因也是因为2.5之前版本的DOM事件采用 micro task ，而之后采用 macro task。</p>
<p>解决的途径参考 &lt; Vue.js 升级踩坑小记&gt; 中介绍的几个办法。</p>
<p>这里就提供一个在mounted钩子中用 addEventListener 添加原生事件的方法来实现。</p>
<p>参见 CodePen</p>
<p>（<a href="https://codepen.io/SHERlocked93/pen/WKGNKJ）。" target="_blank" rel="noopener">https://codepen.io/SHERlocked93/pen/WKGNKJ）。</a></p>
<ol start="3">
<li>一个例子</li>
</ol>
<p>说这么多，不如来个例子，执行参见 CodePen</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;span id=&apos;name&apos; ref=&apos;name&apos;&gt;{{ name }}&lt;/span&gt;
  &lt;button @click=&apos;change&apos;&gt;change name&lt;/button&gt;
  &lt;div id=&apos;content&apos;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
  new Vue({
    el: &apos;#app&apos;,
    data() {
      return {
        name: &apos;SHERlocked93&apos;
      }
    },
    methods: {
      change() {
        const $name = this.$refs.name
        this.$nextTick(() =&gt; console.log(&apos;setter前：&apos; + $name.innerHTML))
        this.name = &apos; name改喽 &apos;
        console.log(&apos;同步方式：&apos; + this.$refs.name.innerHTML)
        setTimeout(() =&gt; this.console(&quot;setTimeout方式：&quot; + this.$refs.name.innerHTML))
        this.$nextTick(() =&gt; console.log(&apos;setter后：&apos; + $name.innerHTML))
        this.$nextTick().then(() =&gt; console.log(&apos;Promise方式：&apos; + $name.innerHTML))
      }
    }
  })
&lt;/script&gt;
</code></pre><p>执行以下看看结果：</p>
<pre><code>同步方式：SHERlocked93 
setter前：SHERlocked93 
setter后：name改喽 
Promise方式：name改喽 
setTimeout方式：name改喽
</code></pre><p>为什么是这样的结果呢，解释一下：</p>
<ol>
<li><p>同步方式： 当把data中的name修改之后，此时会触发name的 setter 中的 dep.notify 通知依赖本data的render watcher去 update，update 会把 flushSchedulerQueue 函数传递给 nextTick，render watcher在 flushSchedulerQueue 函数运行时 watcher.run 再走 diff -&gt; patch 那一套重渲染 re-render 视图，这个过程中会重新依赖收集，这个过程是异步的；所以当我们直接修改了name之后打印，这时异步的改动还没有被 patch 到视图上，所以获取视图上的DOM元素还是原来的内容。</p>
</li>
<li><p>setter前： setter前为什么还打印原来的是原来内容呢，是因为 nextTick 在被调用的时候把回调挨个push进callbacks数组，之后执行的时候也是 for 循环出来挨个执行，所以是类似于队列这样一个概念，先入先出；在修改name之后，触发把render watcher填入 schedulerQueue 队列并把他的执行函数 flushSchedulerQueue 传递给 nextTick ，此时callbacks队列中已经有了 setter前函数 了，因为这个 cb 是在 setter前函数 之后被push进callbacks队列的，那么先入先出的执行callbacks中回调的时候先执行 setter前函数，这时并未执行render watcher的 watcher.run，所以打印DOM元素仍然是原来的内容。</p>
</li>
<li><p>setter后： setter后这时已经执行完 flushSchedulerQueue，这时render watcher已经把改动 patch 到视图上，所以此时获取DOM是改过之后的内容。</p>
</li>
<li><p>Promise方式： 相当于 Promise.then 的方式执行这个函数，此时DOM已经更改。</p>
</li>
<li><p>setTimeout方式： 最后执行macro task的任务，此时DOM已经更改。</p>
</li>
</ol>
<p>注意，在执行 setter前函数 这个异步任务之前，同步的代码已经执行完毕。</p>
<p>异步的任务都还未执行，所有的 $nextTick 函数也执行完毕。</p>
<p>所有回调都被push进了callbacks队列中等待执行，所以在setter前函数执行的时候。</p>
<p>此时callbacks队列是这样的：</p>
<p>[setter前函数，</p>
<p>flushSchedulerQueue，</p>
<p>setter后函数，</p>
<p>Promise方式函数]。</p>
<p>它是一个micro task队列，执行完毕之后执行macro task setTimeout，所以打印出上面的结果。</p>
<p>另外，如果浏览器的宏任务队列里面有setImmediate、MessageChannel、setTimeout/setInterval 各种类型的任务。</p>
<p>那么会按照上面的顺序挨个按照添加进event loop中的顺序执行，所以如果浏览器支持MessageChannel。</p>
<p>nextTick执行的是macroTimerFunc。</p>
<p>那么如果 macrotask queue 中同时有 nextTick 添加的任务和用户自己添加的 setTimeout 类型的任务。</p>
<p>会优先执行 nextTick 中的任务，因为MessageChannel 的优先级比 setTimeout的高，setImmediate 同理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/ES6之promise、generator-co、async-await手写promise/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/ES6之promise、generator-co、async-await手写promise/" itemprop="url">ES6之promise、generator+co、async+await手写promise</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-20T12:06:32+08:00">
                2018-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>传统的解决代码单线程执行的方案是<code>回调函数和事件</code>。这是个解决问题的方案，但是会造成回调地狱。</p>
<p>异步编程是优化代码逻辑提高代码易读性的关键。</p>
<p>目前通用的异步编程方法有三种：</p>
<ol>
<li>Promise</li>
<li>generator+co</li>
<li>async+await</li>
</ol>
<p>这三种方法我都经常在用，但是对它们的原理却一知半解。于是想炒个冷饭从头到尾理一遍，梳理一下它们之间的关系。</p>
<h4 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h4><h5 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h5><p>Promise对象是一个构造函数，用来生成Promise实例。<br>Promise对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。<br>Promise函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是Promise中定义的两个函数，在运行自定义函数时返回。<br><code>resolve</code>函数将Promise对象的状态从 <code>pending</code> 变为<code>resolved</code>,<code>reject</code>将Promise对象的状态从 <code>pending</code> 变为<code>rejected</code><br>Promise的原型链上定义了then方法，提供两个回调函数分别捕获resolve、reject返回的值。</p>
<h5 id="2-2-静态方法"><a href="#2-2-静态方法" class="headerlink" title="2.2 静态方法"></a>2.2 静态方法</h5><p>方法描述<code>Promise.resolve(promise)</code>;返回 <code>promise</code>（仅当 <code>promise.constructor == Promise</code> 时）<code>Promise.resolve(thenable)</code>;<br>从<code>thenable</code> 中生成一个新<code>promise</code>。<code>thenable</code> 是具有 <code>then()</code> 方法的类似于 <code>promise</code> 的对象。<code>Promise.resolve(obj)</code>;<br>在此情况下，生成一个<code>promise</code> 并在执行时返回 <code>obj。Promise.reject(obj)</code>;生成一个<code>promise</code> 并在拒绝时返回 obj。<br>为保持一致和调试之目的（例如堆叠追踪）， obj 应为 <code>instanceof Error</code>。<br><code>Promise.all(array)</code>;生成一个<code>promise</code>，<br>该 promise 在数组中各项执行时执行，在任意一项拒绝时拒绝。<code>Promise.race(array)</code>;<br>生成一个 Promise，该 Promise 在任意项执行时执行，或在任意项拒绝时拒绝，以最先发生的为准。<br>sample 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    console.log(&apos;hello&apos;)</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        reject(&apos;1212&apos;)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(data=&gt; &#123;</span><br><span class="line">    console.log(&apos;success&apos;+data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    console.log(&apos;err&apos;+err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(data=&gt; &#123;</span><br><span class="line">    console.log(&apos;success&apos;+data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    console.log(&apos;err&apos;+err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>terminal:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">err1212</span><br><span class="line">err1212</span><br></pre></td></tr></table></figure></p>
<p>sample 1 中新建了一个Promise实例，定时1S后使用reject方法，将Promise实例的状态从pending变成rejected，触发then的err捕捉回调函数。</p>
<p>在sample 1 中调用then方法，并不会马上执行回调。是等待实例中状态改变后才会执行。这一点和<code>发布订阅</code>模式很类似。</p>
<p>sample 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let event = &#123;</span><br><span class="line">    arr:[],</span><br><span class="line">    result:[],</span><br><span class="line">    on(fn)&#123;</span><br><span class="line">        this.arr.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    emit(data)&#123;</span><br><span class="line">        this.result.push(data)</span><br><span class="line">        this.arr.forEach(fn=&gt;fn(this.result))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.on(function (data) &#123;</span><br><span class="line">    if(data.length === 2)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;1.txt&apos;,&apos;utf8&apos;,function (err,data) &#123;</span><br><span class="line">    event.emit(data)</span><br><span class="line">&#125;)</span><br><span class="line">fs.readFile(&apos;2.txt&apos;,&apos;utf8&apos;,function (err,data) &#123;</span><br><span class="line">    event.emit(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>smaple2 中将结果data放入暂存数组中，在执行接听函数的时候返回。</p>
<h5 id="2-3-简写Promise源码"><a href="#2-3-简写Promise源码" class="headerlink" title="2.3 简写Promise源码"></a>2.3 简写Promise源码</h5><p>通过之前的例子和对发布订阅模式的理解，我们可以大概写出Promise实例的基本功能：</p>
<p>code 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos;</span><br><span class="line">    self.onResovedCallbacks = []</span><br><span class="line">    self.onRejectedCallbacks = []</span><br><span class="line">    function resolve(data) &#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.value = data</span><br><span class="line">            self.status = &apos;resolved&apos;</span><br><span class="line">            self.onResovedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason) &#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = &apos;reject&apos;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果函数执行时发生异常</span><br><span class="line">    try&#123;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;catch (e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function (onFulfilled,onRejected) &#123;</span><br><span class="line">    let self = this</span><br><span class="line">    if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">        self.onResovedCallbacks.push(()=&gt;&#123;</span><br><span class="line">            onFulfilled(self.value)</span><br><span class="line">        &#125;)</span><br><span class="line">        self.onRejectedCallbacks.push(()=&gt;&#123;</span><br><span class="line">            onRejected(self.reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;elseif(self.status === &apos;resolved&apos;)&#123;</span><br><span class="line">        onFulfilled(self.value)</span><br><span class="line">    &#125;elseif(self.status === &apos;reject&apos;)&#123;</span><br><span class="line">        onRejected(self.reason)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>函数内部变量</p>
</li>
<li><p>status：储存Promise的状态</p>
</li>
<li>onResovedCallbacks：储存Promise pending状态下成功回调函数</li>
<li>onRejectedCallbacks：储存Promise pending状态下失败回调函数</li>
<li>resolve函数</li>
<li><p>reject函数</p>
</li>
<li><p>Promise.prototype.then</p>
</li>
<li><p>根据实例状态执行响应的回调</p>
</li>
<li>status == pending使用发布订阅模式储存回调函数。</li>
</ul>
<h5 id="2-4-Promise用法简述"><a href="#2-4-Promise用法简述" class="headerlink" title="2.4 Promise用法简述"></a>2.4 Promise用法简述</h5><ol>
<li><p>如果一个promise执行完后,返回的还是一个Promise对象,会把这个promise的执行结果,传递给下一个then中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">functionread(filePath,encoding) &#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt; &#123;</span><br><span class="line">            if(err) reject(err)</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;1.txt&apos;,&apos;utf8&apos;).then(</span><br><span class="line">    f1=&gt;read(f1,&apos;utf8&apos;) // 1</span><br><span class="line">).then(</span><br><span class="line">    data=&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class="line">    err=&gt; console.log(&apos;rejected: &apos;,err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果then中返回的不是promise，是一个普通值,会将这个普通值作为下一个then的返回结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> ......</span><br><span class="line"> </span><br><span class="line">read(&apos;1.txt&apos;,&apos;utf8&apos;).then(</span><br><span class="line">    f1=&gt;read(f1,&apos;utf8&apos;)</span><br><span class="line">).then(</span><br><span class="line">    return 123 //2</span><br><span class="line">).then(</span><br><span class="line">    data=&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class="line">    err=&gt; console.log(&apos;rejected: &apos;,err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果当前then中失败了会走下一个then的失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> ......</span><br><span class="line"> </span><br><span class="line">read(&apos;1.txt&apos;,&apos;utf8&apos;).then(</span><br><span class="line">    f1=&gt;read(f1,&apos;utf8&apos;)</span><br><span class="line">).then(</span><br><span class="line">    return 123</span><br><span class="line">).then(</span><br><span class="line">    throw new Error(&apos;出错&apos;) //3</span><br><span class="line">).then(</span><br><span class="line">    data=&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class="line">    err=&gt; console.log(&apos;rejected: &apos;,err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果返回的是undefined不管当前是失败还是成功，都会走下一次成功。</p>
</li>
<li>catch是错误没有处理的情况下会走。</li>
<li>then中可以不写。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ......</span><br><span class="line"> </span><br><span class="line">read(&apos;1.txt&apos;,&apos;utf8&apos;).then(</span><br><span class="line">    f1=&gt;read(f1,&apos;utf8&apos;)</span><br><span class="line">).then(</span><br><span class="line">    return 123</span><br><span class="line">).then(</span><br><span class="line">    throw new Error(&apos;出错&apos;) </span><br><span class="line">).then() //6</span><br><span class="line"> .then(</span><br><span class="line">    data=&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class="line">    err=&gt; console.log(&apos;rejected: &apos;,err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这些用法中最重要的是promise的then链式调用。<br>可以大致猜到，旧Promise的then方法返回的是一个新的Promise对象。</p>
<p>参考<a href="https://link.juejin.im?target=https%3A%2F%2Fpromisesaplus.com%2F" target="_blank" rel="noopener">Promises/A+规范</a>，可以完善手写的Promise源码使其支持promise的静态方法和调用规则。</p>
<p>code 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos;</span><br><span class="line">    self.onResovedCallbacks = []</span><br><span class="line">    self.onRejectedCallbacks = []</span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line">        if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.value = value</span><br><span class="line">            self.status = &apos;resolved&apos;</span><br><span class="line">            self.onResovedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(reason) &#123;</span><br><span class="line">        if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = &apos;rejected&apos;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果函数执行时发生异常</span><br><span class="line">    try &#123;</span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">    //If promise and x refer to the same object, reject promise with a TypeError as the reason.</span><br><span class="line">    if (promise2 === x) &#123;</span><br><span class="line">        return reject(new TypeError(&apos;chaining cycle&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">    let called</span><br><span class="line">    //2.3.3.Otherwise, if x is an object or function,</span><br><span class="line">    if (x !== null &amp;&amp; (typeof x == &apos;object&apos; || typeof x === &apos;function&apos;)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            letthen = x.then</span><br><span class="line">            //2.3.3.3.If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:</span><br><span class="line">            //2.3.3.3.3.If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</span><br><span class="line">            if (typeof then === &apos;function&apos;) &#123;</span><br><span class="line">                then.call(x, y=&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    //递归直到解析成普通值为止</span><br><span class="line">                    //2.3.3.1.If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">                &#125;, err=&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called = true;</span><br><span class="line">            //2.3.3.3.If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //If x is not an object or function, fulfill promise with x.</span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//then调用的时候 都是异步调用 (原生的then的成功或者失败 是一个微任务)</span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRejected) &#123;</span><br><span class="line">    //成功和失败的函数 是可选参数</span><br><span class="line">    onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val=&gt;val;</span><br><span class="line">    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : (e)=&gt; &#123;throw e&#125;;</span><br><span class="line">    let self = this</span><br><span class="line">    let promise2;</span><br><span class="line">    promise2 = new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">        if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line">            setTimeout(()=&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x = onFulfilled(self.value)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 0)</span><br><span class="line">        &#125; elseif (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line">            setTimeout(()=&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x = onRejected(self.reason)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 0)</span><br><span class="line">        &#125; elseif (self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.onResovedCallbacks.push(()=&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onFulfilled(self.value)</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        //当执行成功回调的时候,可能会出现异常,那就用这个异常作为promise2的错误结果</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 0)</span><br><span class="line">            &#125;)</span><br><span class="line">            self.onRejectedCallbacks.push(()=&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onRejected(self.reason)</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 0)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise2</span><br><span class="line">&#125;</span><br><span class="line">//setTimeout (规范要求)</span><br><span class="line"></span><br><span class="line">Promise.reject = function (reason) &#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.resolve = function (value) &#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.catch = function (onReject) &#123;</span><br><span class="line">    return this.then(null,onReject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">        dfd.resolve = resolve</span><br><span class="line">        dfd.reject = reject</span><br><span class="line">    &#125;)</span><br><span class="line">    return dfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure></p>
<ol>
<li>为了支持then的链式调用，Promise.then.prototype中返回一个新的Promise对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return p2 = new Promise()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.增加resolvePromise方法，处理旧Promise的回调函数的结果x，根据x的类型，分别调用新promise对象的resolve/reject方法。</p>
<ul>
<li>是普通值用resolve方法返回</li>
<li>是函数或者对象就继续用resolvePromise方法迭代（解决回调函数是Promise对象）</li>
<li>出错就用reject方法返回</li>
</ul>
<h4 id="三、bluebird"><a href="#三、bluebird" class="headerlink" title="三、bluebird"></a>三、bluebird</h4><p>1: NodeJS 中的 fs.readFile 方法的基本使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;),path = require(&apos;path&apos;);</span><br><span class="line"> </span><br><span class="line">fs.readFile(path.join(__dirname, &apos;1.txt&apos;), &apos;utf-8&apos;, (err, data) =&gt; &#123;</span><br><span class="line"> if (err) &#123;</span><br><span class="line">   console.error(err);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   console.log(data);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2：使用Promise封装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">functionread(filePath, encoding) &#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">        fs.readFile(filePath, encoding, (err, data)=&gt; &#123;</span><br><span class="line">            if (err) reject(err)</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;1.txt&apos;, &apos;utf8&apos;).then( data=&gt; data)</span><br></pre></td></tr></table></figure></p>
<p>把fs.readFile方法用Promise封装一下就能使用Promise api。但是每次手动封装比较麻烦，bluebird可以帮我们简化这个步骤。</p>
<p>3：在 NodeJS 环境中，通过 const bluebird = require(‘bluebird’) 就可以开始使用 Bluebird 提供的 Promise 对象。</p>
<p>Promise.promisify 将单个方法转换成Promise对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const bluebird = require(&apos;bluebird&apos;) </span><br><span class="line">letread = bluebird.promisify(fs.readFile)</span><br><span class="line">read(&apos;1.txt&apos;, &apos;utf-8&apos;).then(data=&gt; &#123;</span><br><span class="line">    console.log(&apos;data promisify&apos;, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>使用<code>bluebird.promisify</code>方法，就能将fs.readFile直接封装成一个promise对象，它的原理很简单，return new Promise<br>是它的核心：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function promisify(fn) &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">            fn(...arguments, function (err, data) &#123;</span><br><span class="line">                if (err) reject(err)</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.使用 Promise.promisifyAll 把一个对象的所有方法都自动转换成使用 Promise。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const bluebird = require(&apos;bluebird&apos;),</span><br><span class="line">  fs = require(&apos;fs&apos;),</span><br><span class="line">  path = require(&apos;path&apos;);</span><br><span class="line">Promise.promisifyAll(fs);</span><br><span class="line"> </span><br><span class="line">fs.readFileAsync(path.join(__dirname, &apos;sample.txt&apos;), &apos;utf-8&apos;)</span><br><span class="line">  .then(data =&gt; console.log(data))</span><br><span class="line">  .catch(err =&gt; console.error(err));</span><br></pre></td></tr></table></figure></p>
<p>promisifyAll核心是遍历对象，生成些新创建方法的名称在已有方法的名称后加上”Async”后缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function promisifyAll(obj) &#123;</span><br><span class="line">    Object.keys(obj).forEach(key=&gt;&#123;</span><br><span class="line">        if(typeof obj[key] === &apos;function&apos;)&#123;</span><br><span class="line">            obj[key+&apos;Async&apos;] = promisify(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="四、generator-co"><a href="#四、generator-co" class="headerlink" title="四、generator+co"></a>四、generator+co</h4><h5 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h5><p>generator函数最大的特点是可以用<code>yield</code>暂停执行，为了区别普通函数在函数名前加*号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function *say() &#123;</span><br><span class="line">    let a = yield &quot;test1&quot;let b = yield &quot;test2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let it = say();</span><br><span class="line"></span><br><span class="line">console.log(1, it.next()) //1 &#123; value: &apos;test1&apos;, done: false &#125;</span><br><span class="line">console.log(2, it.next()) //2 &#123; value: &apos;test2&apos;, done: false &#125;</span><br><span class="line">console.log(3, it.next()) //3 &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p>
<p>执行say()方法返回的是指针对象，不会返回函数执行结果。it 就是iterator 迭代器</p>
<p>需要调用指针对象的next()方法，让函数指针不断移动并返回一个对象。（{value:xxx,done:xxx}）</p>
<p>value是yield后面的值，done表示函数是否执行完成。</p>
<p>我们可以用generator函数实现结果的产出，但是也需要它支持输入。</p>
<p>generator函数的运行顺序如下：<br>使用it.next()执行函数，结果并不会返回给定义的变量a。next方法可以接受参数，这是向 Generator 函数体内输入数据。<br>第二个next的时候传入参数，就能被变量a接收到。</p>
<p>terminal 返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &#123; value: &apos;test1&apos;, done: false &#125;</span><br><span class="line">aaa</span><br><span class="line">2 &#123; value: &apos;test2&apos;, done: false &#125;</span><br><span class="line">bbb</span><br><span class="line">3 &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p>
<p>4.2 使用</p>
<p>example：使用generator异步执行函数，使函数的返回作为下一个函数的入参执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let bluebird = require(&apos;bluebird&apos;)</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">letread = bluebird.promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line">function *r() &#123;</span><br><span class="line">    let r1 = yield read(&apos;1.txt&apos;, &apos;utf-8&apos;)</span><br><span class="line">    console.log(&apos;r1&apos;,r1); // r1 2.txt</span><br><span class="line">    let r2 = yield read(r1, &apos;utf-8&apos;)</span><br><span class="line">    console.log(&apos;r2&apos;,r2); // r2 3.txt</span><br><span class="line">    let r3 = yield read(r2, &apos;utf-8&apos;)</span><br><span class="line">    console.log(&apos;r3&apos;,r3); // r3 hello</span><br><span class="line">    return r3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拿读取文件的例子：使用bluebird将fs.readFile变成promise对象，将读取到的文件内容作为入参传入下一个要执行的函数。</p>
<p>突然发现，要拿到结果会是个复杂的过程，但还是硬着头皮下下去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const it_r = r()</span><br><span class="line">it_r.next().value.then(d1=&gt;&#123;</span><br><span class="line">    return it_r.next(d1).value</span><br><span class="line">&#125;).then(d2=&gt;&#123;</span><br><span class="line">    return it_r.next(d2).value</span><br><span class="line">&#125;).then(d3=&gt;&#123;</span><br><span class="line">    return it_r.next(d3).value</span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">    console.log(data) // hello</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>it.next().value 返回的是一个promise，使用then方法，拿到它成功回调的值，并传入下一个next。</p>
<p>这样能成功拿到我们要的值，但是太麻烦了。于是就有了generator+co的组合！</p>
<p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install co</span><br></pre></td></tr></table></figure></p>
<p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(r()).then(data=&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>co会迭代执行it.next()方法，直到done的布尔值为true就返回generator函数的运行结果。</p>
<p>大致执行代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function co(it) &#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">        function next(data) &#123;</span><br><span class="line">            let &#123;value, done&#125; = it.next(data)</span><br><span class="line">            if(done)&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                value.then(data=&gt; &#123;</span><br><span class="line">                    next(data)</span><br><span class="line">                &#125;,reject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="五、async-await"><a href="#五、async-await" class="headerlink" title="五、async+await"></a>五、async+await</h4><p>async 函数是Generator 函数的语法糖。</p>
<p>比Generator函数用起来简单</p>
<ol>
<li>可以让代码像同步</li>
<li>可以try+catch</li>
<li>可以使用promise api<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async functionr() &#123;</span><br><span class="line">   try&#123;</span><br><span class="line">        let r1 = await read(&apos;1.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">        let r2 = await read(r1,&apos;utf8&apos;)</span><br><span class="line">        let r3 = await read(r2,&apos;utf8&apos;)</span><br><span class="line">        return r3</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        console.log(&apos;e&apos;,e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r().then(data=&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    console.log(&apos;err&apos;,err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。遇到await就会先返回，等待函数执行。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/交叉观察器-intersectionObserver-Vue实战/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/交叉观察器-intersectionObserver-Vue实战/" itemprop="url">交叉观察器(intersectionObserver) Vue实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-13T23:04:27+08:00">
                2018-08-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考文章：IntersectionObserver-API-使用教程"><a href="#参考文章：IntersectionObserver-API-使用教程" class="headerlink" title="参考文章：IntersectionObserver API 使用教程"></a>参考文章：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">IntersectionObserver API 使用教程</a></h2><h2 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener">Intersection Observer</a></h2><h2 id="【译】使用-Intersection-Observer-实现图片延迟加载"><a href="#【译】使用-Intersection-Observer-实现图片延迟加载" class="headerlink" title="【译】使用 Intersection Observer 实现图片延迟加载"></a><a href="https://link.zhihu.com/?target=https%3A//c7sky.com/lazy-loading-images-using-intersection-observer.html" target="_blank" rel="noopener">【译】使用 Intersection Observer 实现图片延迟加载</a></h2><p>intersectionObserver解决什么问题？</p>
<p>intersectionObserver解决目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”，</p>
<p>比如在web网页开发中，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。</p>
<p>传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">getBoundingClientRect()</a>方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">性能问题</a>。</p>
<p>目前有一个新的 <a href="https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/" target="_blank" rel="noopener">IntersectionObserver API</a>，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p>
<blockquote>
<p>IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，<code>IntersectionObserver</code>的实现，应该采用<code>requestIdleCallback()</code>，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p>
</blockquote>
<p>IntersectionObserverEntry 对象</p>
<p><code>IntersectionObserverEntry</code>对象提供目标元素的信息，一共有六个属性。</p>
<pre><code>{
  time: 3893.92,
  rootBounds: ClientRect {
    bottom: 920,
    height: 1024,
    left: 0,
    right: 1024,
    top: 0,
    width: 920 },
  boundingClientRect: ClientRect {  // ...
 },
  intersectionRect: ClientRect {  // ...
 },
  intersectionRatio: 0.54,
  target: element
} 
</code></pre><p>每个属性的含义如下。</p>
<ul>
<li><code>time</code>：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li>
<li><code>target</code>：被观察的目标元素，是一个 DOM 节点对象</li>
<li><code>rootBounds</code>：根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回<code>null</code></li>
<li><code>boundingClientRect</code>：目标元素的矩形区域的信息</li>
<li><code>intersectionRect</code>：目标元素与视口（或根元素）的交叉区域的信息</li>
<li><code>intersectionRatio</code>：目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全可见时为<code>1</code>，完全不可见时小于等于<code>0</code></li>
</ul>
<p>现在我们已经创建了一个 Intersection Observer 并且正在观察页面上的图片，我们现在来了解 intersection 事件，它将在元素进入视区时触发。</p>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>此时此刻，你也许想知道关于这项特性的浏览器支持情况。Intersection Observer 现在已被 <a href="https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dintersectionobserver" target="_blank" rel="noopener">Edge、Firefox、Chrome 和 Opera</a> 支持，这是一个好消息。</p>
<p>然而，为了确保我们的代码不会在不支持它的浏览器中造成破坏，我们可以使用特性检测来确定我们应该如何来加载图片。让我们看看下面的代码。</p>
<pre><code>// If we don&apos;t have support for intersection observer, load the images immediately
if (!(&apos;IntersectionObserver&apos; in window)) {
  Array.from(images).forEach(image =&gt; preloadImage(image));
} else {
  // It is supported, load the images
  observer = new IntersectionObserver(onIntersection, config);
  images.forEach(image =&gt; {

   observer.observe(image);
  });
}
view raw
</code></pre><p>Vue:</p>
<pre><code>&lt;template&gt;
    &lt;img :src=&quot;lazysrc&quot; /&gt;
&lt;/template&gt;
&lt;script&gt;
    import Bus from &apos;../bus&apos;;
    import nonepng from &apos;../../assets/img/none.png&apos;;

    export default {
        name: &apos;lazyimg&apos;,
        data: function() {
            return {
                isShow: false,
                lazysrc: nonepng
            }
        },
        mounted() {
            if(!this.needlazy) {
                this.lazysrc = this.src;
            } else {
                if(!(&apos;IntersectionObserver&apos; in window)) {
                    //TODO
                } else {
                    var io = new IntersectionObserver(
                        entries =&gt; {
                            entries.forEach(i =&gt; {
                                if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发
                                    i.target.setAttribute(&quot;src&quot;, this.src)
                                }
                            });
                        }, {
                            threshold: [0, 0.25, 0.5, 0.75, 1],
                        }
                    );
                    io.observe(this.$el);
                }
            }
        },
        props: {
            needlazy: {
                type: Boolean,
                default: false,
            },
            src: {
                type: String,
                default: &apos;&apos;,
            },
        }
    };
&lt;/script&gt;
</code></pre><blockquote>
<p>通常都是通过判断intersectionRatio来做某些事，比如当intersectionRatio大于多少的时候做什么事，加载图片等！</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_hd.jpg" alt=""><br>   灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的<code>intersectionRatio</code>图中都已经注明。</p>
<p>DEMO：  <a href="https://zhuanlan.zhihu.com/p/25455672" target="_blank" rel="noopener">延迟加载(Lazyload)三种实现方式</a></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
        &lt;title&gt; &lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            * {
                padding: 0px;
                margin: 0px;
                outline: none;
            }

            body {}

            #main {
                margin: 0 auto;
                width: 600px;
                height: 300px;
                overflow: scroll;
            }

            #con {
                width: 1200px;
                height: 300px;
            }

            .cc {
                width: 300px;
                height: 300px;
                float: left;
                background-size: cover;
            }

            #a {
                background-color: red;
            }

            #b {
                background-color: black;
            }

            #c {
                background-color: blue;
            }

            #d {
                background-color: green;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div id=&quot;main&quot;&gt;
            &lt;div id=&quot;con&quot;&gt;
                &lt;div id=&quot;a&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;b&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;c&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
                &lt;div id=&quot;d&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
        var io = new IntersectionObserver(
            entries =&gt; {
                console.log(&apos;********************************&apos;);
                console.log(entries);
                console.log(&apos;********************************&apos;);
                entries.forEach(i =&gt; {
                    console.log(&apos;================================&apos;);
                    console.log(&apos;Time: &apos; + i.time);
                    console.log(&apos;Target: &apos; + i.target.nodeName);
                    console.log(&apos;IntersectionRatio: &apos; + i.intersectionRatio);
                    console.log(&apos;rootBounds: &apos; + i.rootBounds);
                    console.log(i.boundingClientRect);
                    console.log(i.intersectionRect);
                    console.log(&apos;================================&apos;);

                    if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发
                        console.log(&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&apos;);
                        i.target.style.backgroundImage = &quot;url(&quot; + &apos;http://pic35.photophoto.cn/20150528/0020032932102307_b.jpg&apos; + &quot;)&quot;
                    }

                });
            }, {
                /* Using default options. Details below */
                threshold: [0, 0.25, 0.5, 0.75, 1],   //会执行5次
            }
        );
        // Start observing an element
        io.observe(document.querySelector(&apos;#d&apos;));
        io.observe(document.querySelector(&apos;#c&apos;));
    &lt;/script&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic1.zhimg.com/v2-83bcd2ce4df13a07da99e0c051e9fcaa_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-83bcd2ce4df13a07da99e0c051e9fcaa_hd.jpg" alt=""></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Lazyload 3&lt;/title&gt;
    &lt;style&gt;
        img {
        display: block;
        margin-bottom: 50px;
        width: 800px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/1.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/2.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/3.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/4.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/5.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/6.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/7.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/8.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/9.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/10.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/11.png&quot;&gt;
    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/12.png&quot;&gt;
    &lt;script&gt;
    function query(selector) {
        return Array.from(document.querySelectorAll(selector));
    }
    var io = new IntersectionObserver(function(items) {
        items.forEach(function(item) {
        var target = item.target;
        if(target.getAttribute(&apos;src&apos;) == &apos;images/loading.gif&apos;) {
            target.src = target.getAttribute(&apos;data-src&apos;);
        }
        })
    });
    query(&apos;img&apos;).forEach(function(item) {
        io.observe(item);
    });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><ol>
<li>IntersectionObserver 传入一个回调函数，当其观察到元素集合出现时候，则会执行该函数。</li>
<li>io.observe 即要观察的元素，要一个个添加才可以。</li>
<li>io 管理的是一个数组，当元素出现或消失的时候，数组添加或删除该元素，并且执行该回调函数。</li>
</ol>
<h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><p>它的用法非常简单。</p>
<pre><code>var io = new IntersectionObserver(callback, option); 
</code></pre><p>上面代码中，<code>IntersectionObserver</code>是浏览器原生提供的构造函数，接受两个参数：<code>callback</code>是可见性变化时的回调函数，<code>option</code>是配置对象（该参数可选）。</p>
<p>构造函数的返回值是一个观察器实例。实例的<code>observe</code>方法可以指定观察哪个 DOM 节点。</p>
<pre><code>// 开始观察
io.observe(document.getElementById(&apos;example&apos;)); 
// 停止观察
io.unobserve(element); 
// 关闭观察器
io.disconnect(); 
</code></pre><p>上面代码中，<code>observe</code>的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p>
<pre><code>io.observe(elementA);
io.observe(elementB); 
</code></pre><h2 id="二、callback-参数"><a href="#二、callback-参数" class="headerlink" title="二、callback 参数"></a>二、callback 参数</h2><p>目标元素的可见性变化时，就会调用观察器的回调函数<code>callback</code>。</p>
<p><code>callback</code>一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p>
<pre><code>var io = new IntersectionObserver(
  entries =&gt; {
    console.log(entries); } 
); 
</code></pre><p>上面代码中，回调函数采用的是<a href="https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/function%23%25E7%25AE%25AD%25E5%25A4%25B4%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">箭头函数</a>的写法。<code>callback</code>函数的参数（<code>entries</code>）是一个数组，每个成员都是一个<code>[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)</code>对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code>数组就会有两个成员。</p>
<h2 id="三、Option-对象"><a href="#三、Option-对象" class="headerlink" title="三、Option 对象"></a>三、Option 对象</h2><p>IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p>
<p><code>[IntersectionObserver.root](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/root)</code> 只读所监听对象的具体祖先元素(<code>[element](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Element)</code>)。如果未传入任何值或值为null，则默认使用viewport。</p>
<p><code>[IntersectionObserver.rootMargin](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/rootMargin)</code> 只读计算交叉时添加到根(root)边界盒<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Glossary/bounding_box" target="_blank" rel="noopener">bounding box</a>的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。此属性返回的值可能与调用构造函数时指定的值不同，因此可能需要更改该值，以匹配内部要求。所有的偏移量均可用像素(pixel)(px)或百分比(percentage)(%)来表达, 默认值为”0px 0px 0px 0px”。</p>
<p><code>[IntersectionObserver.thresholds](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/thresholds)</code> 只读一个包含阈值的list, 升序排列, list中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会生成一个通知(Notification)。如果构造器未传入值, 则默认值为0.</p>
<p>threshold 属性</p>
<p><code>threshold</code>属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为<code>[0]</code>，即交叉比例（<code>intersectionRatio</code>）达到<code>0</code>时触发回调函数。</p>
<pre><code>new IntersectionObserver(
  entries =&gt; {/* ... */}, {
    threshold: [0, 0.25, 0.5, 0.75, 1] } ); 
</code></pre><p>用户可以自定义这个数组。比如，<code>[0, 0.25, 0.5, 0.75, 1]</code>就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p>
<p>root 属性，rootMargin 属性</p>
<p>很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在<code>iframe</code>窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。</p>
<p>IntersectionObserver API 支持容器内滚动。<code>root</code>属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p>
<pre><code>var opts = { 
  root: document.querySelector(&apos;.container&apos;),
  rootMargin: &quot;500px 0px&quot; 
}; 

var observer = new IntersectionObserver(
  callback,
  opts
); 
</code></pre><p>上面代码中，除了<code>root</code>属性，还有<code>[rootMargin](https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/%23dom-intersectionobserverinit-rootmargin)</code>属性。后者定义根元素的<code>margin</code>，用来扩展或缩小<code>rootBounds</code>这个矩形的大小，从而影响<code>intersectionRect</code>交叉区域的大小。它使用CSS的定义方法，比如<code>10px 20px 30px 40px</code>，表示 top、right、bottom 和 left 四个方向的值。</p>
<pre><code>//离视窗还有top=500px 或者 bottom=500 触发加载
rootMargin = `500px 0px`  
//离视窗还有top=-500px 或者 bottom=-500 触发加载 （惰性加载）
rootMargin = `-500px 0px` 
</code></pre><p>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p>
<h2 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h2><p><code>[IntersectionObserver.disconnect](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/disconnect)</code>使IntersectionObserver对象停止监听工作。</p>
<p><code>[IntersectionObserver.observe](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/observe)使IntersectionObserver开始监听一个目标元素。</code></p>
<p><code>[IntersectionObserver.takeRecords](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/takeRecords)</code>为所有监听目标返回一个<code>[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry)</code>对象数组并且停止监听这些目标。</p>
<p><code>[IntersectionObserver.unobserve](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/unobserve)使IntersectionObserver停止监听特定目标元素。</code></p>
<h2 id="五、Vue（xunleif2e-vue-lazy-component）"><a href="#五、Vue（xunleif2e-vue-lazy-component）" class="headerlink" title="五、Vue（xunleif2e/vue-lazy-component）"></a>五、Vue（<a href="https://link.zhihu.com/?target=https%3A//github.com/xunleif2e/vue-lazy-component" target="_blank" rel="noopener">xunleif2e/vue-lazy-component</a>）</h2><p>核心 VueLazyComponent.vue</p>
<pre><code>&lt;template&gt;
  &lt;transition-group :tag=&quot;tagName&quot; name=&quot;lazy-component&quot; style=&quot;position: relative;&quot;
    @before-enter=&quot;(el) =&gt; $emit(&apos;before-enter&apos;, el)&quot;
    @before-leave=&quot;(el) =&gt; $emit(&apos;before-leave&apos;, el)&quot;
    @after-enter=&quot;(el) =&gt; $emit(&apos;after-enter&apos;, el)&quot;
    @after-leave=&quot;(el) =&gt; $emit(&apos;after-leave&apos;, el)&quot;
  &gt;
    &lt;div v-if=&quot;isInit&quot; key=&quot;component&quot;&gt;
      &lt;slot :loading=&quot;loading&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div v-else-if=&quot;$slots.skeleton&quot; key=&quot;skeleton&quot;&gt;
      &lt;slot name=&quot;skeleton&quot;&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;div v-else key=&quot;loading&quot;&gt;
    &lt;/div&gt;
  &lt;/transition-group&gt;
&lt;/template&gt;

&lt;script&gt;
  export default {
    name: &apos;VueLazyComponent&apos;,

    props: {
      timeout: {
        type: Number
      },
      tagName: {
        type: String,
        default: &apos;div&apos;
      },
      viewport: {
        type: typeof window !== &apos;undefined&apos; ? window.HTMLElement : Object,
        default: () =&gt; null
      },
      threshold: {
        type: String,
        default: &apos;0px&apos;
      },
      direction: {
        type: String,
        default: &apos;vertical&apos;
      },
      maxWaitingTime: {
        type: Number,
        default: 50
      }
    },

    data () {
      return {
        isInit: false,
        timer: null,
        io: null,
        loading: false
      }
    },

    created () {
      // 如果指定timeout则无论可见与否都是在timeout之后初始化
      if (this.timeout) {
        this.timer = setTimeout(() =&gt; {
          this.init()
        }, this.timeout)
      }
    },

    mounted () {
      if (!this.timeout) {
        // 根据滚动方向来构造视口外边距，用于提前加载
        let rootMargin
        switch (this.direction) {
          case &apos;vertical&apos;:
            rootMargin = `${this.threshold} 0px`
            break
          case &apos;horizontal&apos;:
            rootMargin = `0px ${this.threshold}`
            break
        }

        // 观察视口与组件容器的交叉情况
        this.io = new window.IntersectionObserver(this.intersectionHandler, {
          rootMargin,
          root: this.viewport,
          threshold: [ 0, Number.MIN_VALUE, 0.01]
        })
        this.io.observe(this.$el)
      }
    },

    beforeDestroy () {
      // 在组件销毁前取消观察
      if (this.io) {
        this.io.unobserve(this.$el)
      }
    },

    methods: {
      // 交叉情况变化处理函数
      intersectionHandler (entries) {
        if (
          // 正在交叉
          entries[0].isIntersecting ||
          // 交叉率大于0
          entries[0].intersectionRatio
        ) {
          this.init()
          this.io.unobserve(this.$el)
        }
      },

      // 处理组件和骨架组件的切换
      init () {
        // 此时说明骨架组件即将被切换
        this.$emit(&apos;beforeInit&apos;)
        this.$emit(&apos;before-init&apos;)

        // 此时可以准备加载懒加载组件的资源
        this.loading = true

        // 由于函数会在主线程中执行，加载懒加载组件非常耗时，容易卡顿
        // 所以在requestAnimationFrame回调中延后执行
        this.requestAnimationFrame(() =&gt; {
          this.isInit = true
          this.$emit(&apos;init&apos;)
        })
      },

      requestAnimationFrame (callback) {
        // 防止等待太久没有执行回调
        // 设置最大等待时间
        setTimeout(() =&gt; {
          if (this.isInit) return
          callback()
        }, this.maxWaitingTime)

        // 兼容不支持requestAnimationFrame 的浏览器
        return (window.requestAnimationFrame || ((callback) =&gt; setTimeout(callback, 1000 / 60)))(callback)
      }
    }
  }
&lt;/script&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/11/Raect-异步加载组件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/11/Raect-异步加载组件/" itemprop="url">React 异步加载组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T23:09:27+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先需要知道的是dynamic import通过返回Promise的方式实现异步加载功能。</p>
<pre><code>import(&apos;./component.js&apos;)  
    .then((m) =&gt; {
        // 处理异步加载到的模块m
    })
    .catch((err) =&gt; {
        // 错误处理
    });
</code></pre><p>要注意的是import的参数不能使用变量，简单原则是至少要让Webpack知晓应该预先加载哪些内容。这里的参数除了使用常量之外，还可以使用模板字符串<code>componentDir/${name}.js</code>。</p>
<p>其实到这里基本完成代码切割了，接下来做得就是结合react-router实现按模块异步加载。这是跟业务代码相关的，因此每个人的做法都是不一样的。所以以下代码仅供参考。</p>
<p>异步加载</p>
<p>我参考react-router的例子写了个简单的异步加载组件AsyncLoader.js，内容：</p>
<pre><code>import React from &apos;react&apos;;

export default class AsyncLoader extends React.Component {

  static propTypes = {
    path: React.PropTypes.string.isRequired,
    loading: React.PropTypes.element,
  };

  static defaultProps = {
    path: &apos;&apos;,
    loading: &lt;p&gt;Loading...&lt;/p&gt;,
    error: &lt;p&gt;Error&lt;/p&gt;
  };

  constructor(props) {
    super(props);
    this.state = {
      module: null
    };
  }

  componentWillMount() {
    this.load(this.props);
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.path !== this.props.path
      || nextProps.error !== this.props.error
      || nextProps.loading !== this.props.loading) {
      this.load(nextProps);
    }
  }

  load(props) {

    this.setState({module: props.loading});

    // TODO：异步代码的路径希望做成可以配置的方式
    import(`./path/${props.path}`)
      .then((m) =&gt; {
        let Module = m.default ? m.default : m;
        console.log(&quot;module: &quot;, Module);
        this.setState({module: &lt;Module/&gt;});
      }).catch(() =&gt; {
        this.setState({module: props.error});
      });
  }

  render() {
    return this.state.module;
  }
}
</code></pre><p>使用方法</p>
<pre><code>&lt;Route  
    exact path=&apos;/book&apos; 
    render={()=&gt;&lt;AsyncLoader path={&apos;./components/Book.js&apos;}/&gt;} 
/&gt;
</code></pre><p>Webpack打包的时候会根据import的参数生成相应的js文件，默认使用id（webpack生成的，从0开始）命名这个文件。</p>
<pre><code>const Search = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;search&quot; */ &quot;./containers/Search/SearchContainer&quot;))
const BookList = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;bookList&quot; */ &quot;./containers/BookList/BookListContainer&quot;))


import React from &apos;react&apos;
export const asyncComponent = loadComponent =&gt; (
    class AsyncComponent extends React.Component {
        state = {
            Component: null,
        }

        componentWillMount() {
            if (this.hasLoadedComponent()) {
                return;
            }

            loadComponent()
                .then(module =&gt; module.default) ////兼容 module.default ? module.default : module
                .then((Component) =&gt; {
                    this.setState({ Component });
                })
                .catch((err) =&gt; {
                    console.error(`Cannot load component in &lt;AsyncComponent /&gt;`);
                    throw err;
                });
        }

        hasLoadedComponent() {
            return this.state.Component !== null;
        }

        render() {
            const { Component } = this.state;
            return (Component) ? &lt;Component {...this.props} /&gt; : null;
        }
    }
); 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/04/JS面试之数组对象解构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/04/JS面试之数组对象解构/" itemprop="url">JS面试之数组对象解构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-04T21:25:38+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构:"></a>数组解构:</h3><blockquote>
<p>将 destructuringArray([1, [2, 3], 4], “[a, [b], c]”) =&gt; {a: 1, b: 2, c: 4}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 将 destructuringArray([1, [2, 3], 4], &quot;[a, [b], c]&quot;) =&gt; &#123;a: 1, b: 2, c: 4&#125;</span><br><span class="line">const targetArray = [1, [2, 3], 4];</span><br><span class="line">const formater = &quot;[a, [b], c]&quot;;</span><br><span class="line"></span><br><span class="line">const destructuringArray = (values, keys) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const obj = &#123;&#125;;</span><br><span class="line">    if (typeof keys === &apos;string&apos;) &#123;</span><br><span class="line">      keys = JSON.parse(keys.replace(/\w+/g, &apos;&quot;$&amp;&quot;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const iterate = (values, keys) =&gt;</span><br><span class="line">      keys.forEach((key, i) =&gt; &#123;</span><br><span class="line">        if(Array.isArray(key)) iterate(values[i], key)</span><br><span class="line">        else obj[key] = values[i]</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    iterate(values, keys)</span><br><span class="line">    </span><br><span class="line">    return obj;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><blockquote>
<p>实现一个get函数，使得下面的调用可以输出正确的结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;);</span><br><span class="line">// [ &apos;FE Coder&apos;, 1, &apos;byted&apos;]</span><br></pre></td></tr></table></figure>
<p>乍眼一看，这不就是实现一个lodash.get方法吗？看上去好像很简单。所以我就开始写了第一个版本。思想其实很简单，遍历传进来的参数，使用split将每一个参数分隔开，然后遍历取值，最终返回结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	return args.map((item) =&gt; &#123;</span><br><span class="line">		const paths = item.split(&apos;.&apos;);</span><br><span class="line">		let res = data;</span><br><span class="line">		paths.map(path =&gt; res = res[path]);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">	selector: &#123;</span><br><span class="line">		to: &#123;</span><br><span class="line">			toutiao: &quot;FE Coder&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	target: [1, 2, &#123;</span><br><span class="line">		name: &apos;byted&apos;</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get(obj, ...list) &#123;</span><br><span class="line">	return list.map((item) =&gt; &#123;</span><br><span class="line">		return item.split(&quot;.&quot;).reduce((a = &#123;&#125;, b) =&gt; &#123;</span><br><span class="line">			if(/\[([0-9])\]/g.test(b))&#123;</span><br><span class="line">				var c=/(\w+)\[([0-9])\]/g.exec(b)</span><br><span class="line">				return a[c[1]]&amp;&amp;a[c[1]][c[2]]</span><br><span class="line">			&#125;</span><br><span class="line">			return a[b]</span><br><span class="line">		&#125;, obj)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;)</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;));</span><br></pre></td></tr></table></figure>
<p>一运行，果不其然，报错了。<br>后来仔细看了一下提供的测试代码，发现居然有target[0]这种东西。。居然还带了个数组索引。<br> 冷静分析一下，对于后面带了个索引的类型，比如’target[0]’,我们肯定是要特殊对待的。所以，我们首先得先识别到这种特殊的类型，然后再对它进行额外处理。</p>
<p>这个时候，很快的就可以想到使用正则表达式来做这个事情。为什么呢？因为像这种带有索引的类型，他们都有一个特色，就是有固定的格式：[num]，那么我们只需要能构造出可以匹配这种固定格式的正则，就可以解决这个问题。</p>
<p>对于这种格式，不难想到可以用这个正则表达式来做判断：/[[0-9]+]/gi，可是我们还需要将匹配值取出来。这个时候查了下正则表达式的文档(<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString%2Fmatch" target="_blank" rel="noopener">文档点击这里</a>)，发现有一个match方法，可以返回匹配成功的结果。那么就让我们来做个测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\[[0-9]+\]/gi;</span><br><span class="line">const str = &quot;target[123123]&quot;;</span><br><span class="line">const str1 = &quot;target[]&quot;</span><br><span class="line">if (reg.test(str)) &#123;</span><br><span class="line">    console.log(&apos;test success&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!reg.test(str1)) &#123;</span><br><span class="line">    console.log(&apos;test fail&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const matchResult = str.match(reg);</span><br><span class="line">console.log(matchResult); // [&quot;[123123]&quot;]</span><br></pre></td></tr></table></figure></p>
<p>诶，我们现在已经找到了解决这种问题的方法，那让我们赶紧来继续改进下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	const reg = /\[[0-9]+\]/gi;</span><br><span class="line">	return args.map((item) =&gt; &#123;</span><br><span class="line">		const paths = item.split(&apos;.&apos;);</span><br><span class="line">		let res = data;</span><br><span class="line">		paths.map((path) =&gt; &#123;</span><br><span class="line">                  if (reg.test(path)) &#123;</span><br><span class="line">                    const match = path.match(reg)[0];</span><br><span class="line">                    // 将target[0]里的target储存到cmd里</span><br><span class="line">                    const cmd = path.replace(match, &apos;&apos;);</span><br><span class="line">                    // 获取数组索引</span><br><span class="line">                    const arrIndex = match.replace(/[\[\]]/gi, &apos;&apos;);</span><br><span class="line">                    res = res[cmd][arrIndex];</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    res = res[path];</span><br><span class="line">                  &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;));</span><br></pre></td></tr></table></figure></p>
<p>写完赶紧运行一下，完美，输出了正确的结果了。那么到这里就结束了?</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>可是总感觉有点不妥，感觉事情没有那么简单。一般来说，面试题除了考验你解决问题的能力之外，可能还考验着你思考问题的全面性、严谨性。像上面那种写法，<br>如果用户传入了一个不存在的path链或者一些其他特殊情况，就可能导致整个程序crash掉。想下lodash.get调用方式，<br>即使你传入了错误的path，他也可以帮你做处理，并且返回一个undefined。因此，我们还需要完善这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	const reg = /\[[0-9]+\]/gi;</span><br><span class="line">	return args.map((item) =&gt; &#123;</span><br><span class="line">		const paths = item.split(&apos;.&apos;);</span><br><span class="line">		let res = data;</span><br><span class="line">		paths.map(path =&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (reg.test(path)) &#123;</span><br><span class="line">					const match = path.match(reg)[0];</span><br><span class="line">					const cmd = path.replace(match, &apos;&apos;);</span><br><span class="line">					const arrIndex = match.replace(/[\[\]]/gi, &apos;&apos;);</span><br><span class="line">					res = res[cmd][arrIndex];</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					res = res[path];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (err) &#123;</span><br><span class="line">				console.error(err);</span><br><span class="line">				res = undefined;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们对每一个path的处理进行了try catch处理。若出错了，则返回undefined。哇，这样看起来就比较稳了。</p>
<p><strong>那么，有没有别的解决方法呢？</strong></p>
<p>群里有一个大佬提出了一种更简单也很取巧的解决方案，就是通过构建一个Function解决这个问题(Function的详细介绍点击<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction" target="_blank" rel="noopener">这里</a>)。由于代码很简单，我就直接贴出来了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	const res = JSON.stringify(data);</span><br><span class="line">	return args.map((item) =&gt; (new Function(`try &#123;return $&#123;res&#125;.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;, &apos;asd&apos;));</span><br></pre></td></tr></table></figure></p>
<p>看完之后，就两个字，牛逼。<br> 这种方法我承认一开始我确实没想到，确实是很奇技淫巧。不过仔细思考了下，其实很多框架都用到了这个奇技淫巧。比如说vue里，就使用new Function的方式来动态创建函数，解决执行动态生成的代码的问题。<br><img src="/2018/08/04/JS面试之数组对象解构/1.webp" alt=""><br>再比如说，Function.prototype.bind方法里(我写了个类似的bind方法:<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fchenjigeng%2Fsomething%2Fblob%2Fmaster%2Fbind%2Fbind.js" target="_blank" rel="noopener">仓库</a>)，也使用了Function来解决一些问题(fn.length丢失问题)。说明这个东西还是挺有用的，得学习了解一波，说不定哪天就用到了。<br><img src="/2018/08/04/JS面试之数组对象解构/2.webp" alt=""><br><strong>更新</strong></p>
<p>有人提到了那种Function的方式没办法处理以下的处理:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;time : new Date(), a : &quot;this is a&quot;, b : 30&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为JSON.stringfy后，Date、Function和RegExp类型的变量都会失效。对于这种情况，评论区有个大佬(<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fu%2Ffenghengzhi%2Fabout" target="_blank" rel="noopener">冯恒智</a>)也提到了一种很好的解决方案:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; (new Function(&apos;data&apos;,`try &#123;return data.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，另一种解决方案，就是将”target[0]”分为两个key，也很简单粗暴，就是将在split之前，将字符串里的’[‘替换为’.’,将’]’直接去掉。这样就可以将”target[0]”变为”target.0”。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; &#123;</span><br><span class="line">				let res = data;</span><br><span class="line">				item</span><br><span class="line">					.replace(/\[/g, &quot;.&quot;)</span><br><span class="line">					.replace(/\]/g, &quot;&quot;)</span><br><span class="line">					.split(&apos;.&apos;)</span><br><span class="line">					.map(path =&gt; res = res &amp;&amp; res[path]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且这两种方式的好处在于，它也可以处理多维数组的情况。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学习完之后，最重要就是要总结，只有总结下来了，知识才是你自己的。那么我来总结下文章想表达的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	const res = JSON.stringify(data);</span><br><span class="line">	return args.map((item) =&gt; (new Function(`try &#123;return $&#123;res&#125;.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;, &apos;asd&apos;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get1(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; (new Function(&apos;data&apos;,`try &#123;return data.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get2(data, ...args) &#123;</span><br><span class="line">  return args.map(item =&gt; &#123;</span><br><span class="line">    const reg = /\[([0-9])\]/g;</span><br><span class="line">    if (reg.test(item)) &#123;</span><br><span class="line">      item = item.replace(reg, &apos;.$1&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    const paths = item.split(&apos;.&apos;);</span><br><span class="line">    return paths.reduce((result, current) =&gt; &#123;</span><br><span class="line">      return result[current];</span><br><span class="line">    &#125;, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const get3 = (obj, ...args) =&gt; args.map(key =&gt; eval(`obj.$&#123;key&#125;`));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get4(obj, ...list) &#123;   //自己实现</span><br><span class="line">	return list.map((item) =&gt; &#123;</span><br><span class="line">		return item.split(&quot;.&quot;).reduce((a = &#123;&#125;, b) =&gt; &#123;</span><br><span class="line">			if(/\[([0-9])\]/g.test(b))&#123;</span><br><span class="line">				var c=/(\w+)\[([0-9])\]/g.exec(b)</span><br><span class="line">				return a[c[1]]&amp;&amp;a[c[1]][c[2]]</span><br><span class="line">			&#125;</span><br><span class="line">			return a[b]</span><br><span class="line">		&#125;, obj)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get4(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>对于具有固定格式的字符串，可以考虑使用正则表达式来识别和匹配。</li>
<li>实现一个功能的时候，不要只考虑正常情况，要多考虑一些非正常情况，比如输入格式不对、用户不按套路来或者因为一些奇奇怪怪的事情报错。并且能对可预见的非正常情况做一个容错处理。</li>
<li>有时候还是可以多学习了解一下一些黑科技(比如Function)，说不定哪天就可以用它来解决问题。</li>
</ol>
<h3 id="一道面试题引起的思考"><a href="#一道面试题引起的思考" class="headerlink" title="一道面试题引起的思考"></a><a href="https://juejin.im/post/5bf769e0518825773a2ebfe5" target="_blank" rel="noopener">一道面试题引起的思考</a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/03/JS获取深层次属性-一道很经典的面试题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/03/JS获取深层次属性-一道很经典的面试题/" itemprop="url">js获取深层次属性,一道很经典的面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-03T21:09:05+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："><a href="#题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：" class="headerlink" title="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："></a>题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="string">'ScriptOJ'</span> &#125; &#125; &#125;</span><br><span class="line">data.a.b.c <span class="comment">// = scriptoj</span></span><br><span class="line">data.a.b.c.d <span class="comment">// = 报错，代码停止执行console.log('ScriptOJ') // = 不会被执行</span></span><br></pre></td></tr></table></figure>
<p>请你完成一个 safeGet 函数，可以安全的获取无限多层次的数据，一旦数据不存在不会报错，会返回 undefined，<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="string">'ScriptOJ'</span> &#125; &#125; &#125;</span><br><span class="line">safeGet(data, <span class="string">'a.b.c'</span>) <span class="comment">// = scriptoj</span></span><br><span class="line">safeGet(data, <span class="string">'a.b.c.d'</span>) <span class="comment">// = 返回 undefined</span></span><br><span class="line">safeGet(data, <span class="string">'a.b.c.d.e.f.g'</span>) <span class="comment">// = 返回 undefined</span></span><br></pre></td></tr></table></figure></p>
<p> 答案1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> safeGet = (o, path) = &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.split(<span class="string">'.'</span>).reduce((o, k) = o[k], o)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 答案2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeGet</span>(<span class="params">o, path</span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> path.split(<span class="string">'.'</span>).reduce((o=&#123;&#125;,b)=&#123;   <span class="comment">//用到参数默认值</span></span><br><span class="line">     </span><br><span class="line">      <span class="keyword">return</span> o[b]  </span><br><span class="line">   &#125;,o)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.b = [<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">this</span>.a];</span><br><span class="line"><span class="keyword">this</span>.c = &#123; <span class="attr">demo</span>: <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a , <span class="keyword">this</span>.b , <span class="keyword">this</span>.c.demo );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.b.push(<span class="keyword">this</span>.a);</span><br><span class="line"><span class="keyword">this</span>.a = <span class="keyword">this</span>.b.length;</span><br><span class="line"><span class="keyword">this</span>.c.demo = <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); </span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">parent.show();<span class="comment">//Q1</span></span><br><span class="line">child1.show();<span class="comment">//Q2</span></span><br><span class="line">child2.show();<span class="comment">//Q3</span></span><br><span class="line"></span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line"></span><br><span class="line">parent.show();<span class="comment">//Q4</span></span><br><span class="line">child1.show();<span class="comment">//Q5</span></span><br><span class="line">child2.show();<span class="comment">//Q6</span></span><br></pre></td></tr></table></figure>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><p>原型链的查找规则</p>
<ul>
<li>当实例上存在属性时， 用实例上的</li>
<li>如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的</li>
<li>如果原型链都不存在，就用Object原型对象上的</li>
<li>如果Object原型对象都不存在， 就是undefined</li>
</ul>
</li>
<li>数组和字面量对象都是引用</li>
<li><p>this指向在引用时确认而不是定义时</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>下面分别模拟Q1-Q6的执行情况</p>
<h5 id="Q1："><a href="#Q1：" class="headerlink" title="Q1："></a>Q1：</h5><p>直接调用<code>parent.show()</code>,此时this指向parent,语句中的三条语句相当于分别在给window对象上赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.a = <span class="number">1</span>;</span><br><span class="line">parent.b = [<span class="number">1</span>, <span class="number">2</span>, parent.a];</span><br><span class="line">parent.c = &#123; <span class="attr">demo</span>: <span class="number">8</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 此时，parent对象应为：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">a:<span class="number">1</span>,</span><br><span class="line">b:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">c:&#123;</span><br><span class="line">demo:<span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Q2"><a href="#Q2" class="headerlink" title="Q2:"></a>Q2:</h5><p> 在执行<code>var child1 = new Child();</code>语句时，child对象的a值为2，而因为后被手动赋值为11，所以child实例上的a被改为11，这时调用原型链上的<code>show()</code>方法，依次打印,</p>
<p> 这里<code>this.a</code>根据原型链的查找规则，在实例上有a的赋值，所以直接使用实例上的值也就是11，其他值实例上没有，需要在原型上寻找，所以输出b为<code>[1,2,this.a]</code>,</p>
<p> 而这里的this.b因为是数组，为引用类型，在执行<code>var parent = new Parent();</code>时被定义在parent实例上，所有this.a的指针指向共同的引用地址，所以为1 ,</p>
<p> this.c因为也是引用类型，指针也被指向共同的引用对象地址。</p>
<h5 id="Q3："><a href="#Q3：" class="headerlink" title="Q3："></a>Q3：</h5><p> 实例上的a被重新赋值，所以<code>this.a</code>的输出被改为12，其余执行步骤同Q2。</p>
<h5 id="Q4："><a href="#Q4：" class="headerlink" title="Q4："></a>Q4：</h5><p> 相当于再次调用parent实例上的show方法，因为数据没有发生变动，所以输出值同Q1。</p>
<h5 id="Q5："><a href="#Q5：" class="headerlink" title="Q5："></a>Q5：</h5><p> 因为在调用<code>this.change</code>时，this.a的值被赋值为this.b数组的长度，所有这里的a输出为4，this.b的值使用引用地址b数组，因为在下一步中又执行了一次对this.b数组的push，所以这里打印this.b是被push两次后的数组，而this.c也是被push两次后的数组的长度，注意因为this.a和this.c的数据类型不同，所以this.a是单独的内存，而this.c则是使用相同一块内存。</p>
<h5 id="Q6"><a href="#Q6" class="headerlink" title="Q6:"></a>Q6:</h5><p> 又对this.b数组执行了一次push，所以这次this.a的输出应为数组的当前长度也就是5，this.c的值也是数组长度也就是5。</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p> 在chrome控制台中运行代码得到结果如下：</p>
<p> <img src="https://user-images.githubusercontent.com/29997411/50052858-bca89400-0165-11e9-866f-baa5371500b6.jpg" alt="jietu20181216-183105"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/03/Redux中间件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/03/Redux中间件/" itemprop="url">redux中间件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-03T00:11:00+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提到中间件，你可能会想到<code>Express</code>和<code>Koa</code>等服务端框架，没想到也没关系，这句话是我装逼用的。</p>
<p>那么redux中的中间件到底干嘛用的？</p>
<p>有这样一个问题？我们之前用的<code>Redux</code>都是在<code>Action</code>发出之后立即执行<code>Reducer</code>,计算出<code>state</code>,这是同步操作。如果想异步操作呢？即过一段时间再执行<code>Reducer</code>怎么办？这里就需要用到中间件<code>middleware</code>。</p>
<p>先放一张图看看：<br><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dcb142c194bfb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h2 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h2><p><code>redux</code>是有流程的，那么，我们该把这个异步操作放在哪个环节比较合适呢？</p>
<ul>
<li><code>Reducer</code>?纯函数只承担计算<code>State</code>功能，不适合其它功能。</li>
<li><code>View</code>?与<code>State</code>一一对应，可以看做是<code>State</code>的视觉层，也不适合承担其它功能。</li>
<li><code>Action</code>？它是一个对象，即存储动作的载体，只能被操作。</li>
</ul>
<p>其实，也只有<code>dispatch</code>能胜任此重任了。那么怎么在<code>dispatch</code>中添加其它操作呢？</p>
<pre><code>let next = store.dispatch;
store.dispatch = function(action){
   console.log(&apos;老状态 &apos;,store.getState());
   next(action);
   console.log(&apos;新状态 &apos;,store.getState());
}
</code></pre><p>示例中可以看出，我们对<code>store.dispatch</code>重新进行了定义，在发送<code>action</code>的前后，做了打印。</p>
<p>这是中间件的大致雏形，真实的中间件要比这么复杂多了</p>
<h2 id="二、中间件的用法"><a href="#二、中间件的用法" class="headerlink" title="二、中间件的用法"></a>二、中间件的用法</h2><p>我们在这里先看看中间件是怎么使用，下面我们一步步剖析每个细节。</p>
<pre><code>import {applyMiddleware,createStore} from &apos;redux&apos;;
import reduxLogger form &apos;redux-logger&apos;;

const store = createStore(reducer,inital_state,applyMiddleware(thunk, promise,reduxLogger));
</code></pre><p>代码中有两点需要注意：</p>
<ul>
<li><p>1、<code>createStore</code>方法可以整个应用的初始状态作为参数<br>内部是这么处理的</p>
<p>  let state = inital_state;</p>
</li>
</ul>
<ul>
<li>2、中间件的参数次序有讲究。下面我会把这个问题讲明白。</li>
</ul>
<h2 id="三、applyMiddleware"><a href="#三、applyMiddleware" class="headerlink" title="三、applyMiddleware"></a>三、applyMiddleware</h2><p>Middleware可以让你包装<code>store</code>的<code>dispatch</code>方法来达到你想要的目的。同时，<code>middleWare</code>还拥有“可组合”这一关键特性。多个<code>middleWare</code>可以被组合到一起使用，形成<code>middleWare</code>链，依次执行。其中每个<code>middleware</code>不需要关心链前后的的<code>middleWare</code>的任何信息。</p>
<pre><code>function applyMiddleware(...middlewares){
    returnfunction(createStore){
        returnfunction(reducer){
            //引入store
            let store = createStore(reducer);
            let dispatch = store.dispatch;
            let middlewareAPI = {
                getState:store.getState,
                // 对dispatch进行包装
                dispatch:action=&gt;dispatch(action)
            }
            //每个中间件都是这种模型  ({ getState, dispatch }) =&gt; next =&gt; action
            chain = middlewares.map(middleware=&gt;middleware(middleAPI));
            dispatch = compose(...chain)(store.dispatch);
            // dispatch被改装后，返回store
            return{...store,dispatch};
        }
    }
}
</code></pre><p>上面代码中，所有中间件都被放进了一个数组<code>chain</code>,然后嵌套执行，最后执行<code>store.dispatch</code>。中间件内部<code>middlewaAPI</code>可以拿到<code>getState</code>和<code>dispatch</code>这两个方法。</p>
<p><code>...middleware</code>：遵循<code>Redux middleware API</code>的函数。每个<code>middleware</code>接受<code>Store</code>的<code>dispatch</code>和<code>getState</code>函数作为命名参数，并返回一个函数。该函数会被传入成为<code>next</code>的下一个middleWare 的dispatch方法，并返回一个接收action的新函数，这个函数可以直接调用next(action)，或者在其他需要的时刻调用，甚至根本不去调用它。</p>
<p>所以，接下来，我们就能看到middleware的函数签名是<code>({ getState, dispatch }) =&gt; next =&gt; action</code></p>
<p>其实，它的本质就是包装sotre中的<code>dispatch</code>。</p>
<p>上面代码中，还用到了<code>compose</code>方法，我们来看看compose是怎么是实现的？</p>
<h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>先看下面一个栗子：</p>
<pre><code>function add1(str){
   return str+1;
}
function add2(str){
    return str+2;
 }
 function add3(str){
    return str+3;
 }
 let result = add3(add2(add1(&apos;好吃&apos;)));// 好吃123;
</code></pre><p>这中写法调用起来，一层套一层，是不是看着很不爽，我们简化一下：</p>
<pre><code>function compose(...fns){
    if(fns.length==1)
     return fns[0];
   returnfunction(...args){
    let last = fns.pop();
    return fns.reduceRight((prev,next)=&gt;{
         return  next(prev);  
    },last(...args));
   }
 }
 let add = compose(add3,add2,add1);//
 let result = add(&apos;好吃&apos;);// 好吃123
 // 上面的代码其实就是redux3.6.0版本中compose的实现方式
</code></pre><p>看看这个代码是不是用起来，很干练一些。其实还可以简化</p>
<pre><code>function compose(...fns){
  if(fns.length==1)
     return fns[0];
   return fns.reduce((a,b)=&gt;(...args)=&gt;a(b(...args)));//add3(add2(add1(&apos;好吃&apos;)))
 }
 let add = compose(add3,add2,add1);//
 let result = add(&apos;好吃&apos;);// 好吃123
 // 这是redux3.6.0版本之后的compose实现方式，一直沿用至今。
</code></pre><p>至于为什么<code>applyMiddleWare</code>的参数有顺序，这里给出了答案。</p>
<h2 id="四、Applymiddleware的三个常用参数"><a href="#四、Applymiddleware的三个常用参数" class="headerlink" title="四、Applymiddleware的三个常用参数"></a>四、Applymiddleware的三个常用参数</h2><h3 id="4-1、日志记录"><a href="#4-1、日志记录" class="headerlink" title="4.1、日志记录"></a>4.1、日志记录</h3><p>使用 Redux 的一个益处就是它让 state 的变化过程变的可预知和透明。每当一个 action 发起完成后，新的 state 就会被计算并保存下来。State 不能被自身修改，只能由特定的 action 引起变化。</p>
<p>试想一下，当我们的应用中每一个 action 被发起以及每次新的 state 被计算完成时都将它们记录下来，岂不是很好？当程序出现问题时，我们可以通过查阅日志找出是哪个 action 导致了 state 不正确。<br><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dd052d2e07b77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>图片的效果是不是很期待啊！！！</p>
<p>我们先来手动实现一版。</p>
<pre><code>// 记录所有被发起的action和新的statelet next = store.dispatch;
store.dispatch = function(action){
   console.log(&apos;老状态 &apos;,store.getState());
   next(action);
   console.log(&apos;新状态 &apos;,store.getState());
}
</code></pre><p>还是上面的示例，我们来做个修改</p>
<pre><code>let logger = function({ getState, dispatch }){
   returnfunction(next){// 这里的next可以理解为store.dispath,本质上就是调用 middleware 链中下一个 middleware 的 dispatch。returnfunction(action){
        console.log(&apos;老状态1 &apos;,getState());
        next(action);//派发动作console.log(&apos;新状态1 &apos;,getState());
    }
    }
}
// 高逼格写法let logger = ({ getState, dispatch }) =&gt; next =&gt; action =&gt; {
  console.log(&apos;老状态1 &apos;,getState());
  next(action)
  console.log(&apos;新状态1 &apos;,getState());
}
</code></pre><h3 id="4-2、redux-thunk-中间件"><a href="#4-2、redux-thunk-中间件" class="headerlink" title="4.2、redux-thunk 中间件"></a>4.2、redux-thunk 中间件</h3><p><code>redux-thunk</code> 是<code>redux</code>官方文档中用到的异步组件，实质就是一个<code>redux</code>中间件，一个封装表达式的函数，封装的目的就是延迟执行表达式。</p>
<p><code>redux-thunk</code>是一个通用的解决方案，其核心思想是让<code>action</code>可以变成一个<code>thunk</code>，这样的话，同步情况：<code>dispatch(action)</code>,异步情况：<code>dispatch(thunk)</code>。</p>
<p>下面是<code>redux-thunk</code>的实现：</p>
<pre><code>let thunk = ({dispatch,getState})=&gt;next=&gt;action=&gt;{
    if(typeof action == &apos;function&apos;){
        action(dispatch,getState);
    }else{
        next(action);//这里可以理解为dispatch(action),本质上就是调用 middleware 链中下一个 middleware 的 dispatch。
    }
}
</code></pre><p>使用redux-thunk</p>
<pre><code>const store = createStore(  
  reducer,
  applyMiddleware(thunk)
);
</code></pre><p>然后我们实现一个thunkActionCreator</p>
<pre><code>//过一秒加1
exportfunction thunkActionCreator(payload){
    returnfunction(dispatch,getState){
        setTimeout(function(){
            dispatch({type:types.INCREMENT,payload:payload});
        },1000);
    }
},
</code></pre><p>最后，在组件中dispatch thunk</p>
<pre><code>this.dispatch(thunkActionCreator(payload));
</code></pre><h3 id="4-3、redux-promise"><a href="#4-3、redux-promise" class="headerlink" title="4.3、redux-promise"></a>4.3、redux-promise</h3><p><code>redux-promise</code>也是延迟执行的表达式，它是解决异步的另外一种方案。</p>
<p><code>redux-thunk</code>和核心思想是把<code>action</code>变成<code>thunk</code>，而<code>redux-promise</code>的核心思想是让<code>action</code>返回一个promise对象。</p>
<p>这个中间件使得<code>store.dispatch</code>方法可以接收Promise对象作为参数。这时 ，action 有两种写法:</p>
<p>写法一、返回值是一个Promise对象。</p>
<pre><code>functionpromiseIncrement(payload){
 //  return {type:types.INCREMENT,payload:payload}  以前是这种写法returnnewPromise(function(resolve,reject){
      setTimeout(function(){
        resolve({type:types.INCREMENT,payload:payload});
      },1000);
    });
 },
</code></pre><p>写法二，action 对象的payload属性是一个Promise对象，这需要从</p>
<pre><code>functionpayloadIncrement(){
    return {
        type:types.INCREMENT,
        payload: newPromise(function(resolve,reject){
            setTimeout(function(){
                if(Math.random()&gt;.5){
                    resolve(100);
                }else{
                    reject(-100);
                }
            },1000)
        })
    }
}
</code></pre><p>下面我们来看看 <code>redux-promise</code>是怎么实现的，就会明白它内部是怎么操作的.</p>
<pre><code>let promise = ({dispatch,getState})=&gt;next=&gt;action=&gt;{
    if(action.then &amp;&amp; typeof action.then == &apos;function&apos;){
        action.then(dispatch);
        // 这里的dispatch就是一个函数，dispatch(action){state:reducer(state,action)};
    }elseif(action.payload&amp;&amp; action.payload.then&amp;&amp; typeof action.payload.then == &apos;function&apos;){
        action.payload.then(payload=&gt;dispatch({...action,payload}),payload=&gt;dispatch({...action,payload}));
    }else{
        next(action);
    }
}
</code></pre><p>上面的代码可以看出，如果Action本身就是一个Promise，它resolve以后的值应该是一个Action对象，会被dispatch方法送出action.then(dispatch)；如果<code>Action</code>对象的 <code>payload</code>属性是一个<code>Promise</code>对象，那么无论<code>resolve</code>和<code>reject</code>,dispatch 方法都会发出<code>Action</code>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/30/关于-ES6-中-Promise-的面试题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/30/关于-ES6-中-Promise-的面试题/" itemprop="url">关于 ES6 中 Promise 的面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T20:16:20+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>最近在复习 Promise 的知识，所以就做了一些题，这里挑出几道题，大家一起看看吧。</p>
<h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><pre><code>const promise = newPromise((resolve, reject) =&gt; {
    console.log(1);
    resolve();
    console.log(2);
})

promise.then(() =&gt; {
    console.log(3);
})

console.log(4);
</code></pre><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>首先 Promise 新建后立即执行，所以会先输出 1，2，而 <code>Promise.then()</code> 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3。</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><pre><code>1243
</code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><pre><code>const promise = newPromise((resolve, reject) =&gt; {
    resolve(&apos;success1&apos;);
    reject(&apos;error&apos;);
    resolve(&apos;success2&apos;);
});

promise.then((res) =&gt; {
    console.log(&apos;then:&apos;, res);
}).catch((err) =&gt; {
    console.log(&apos;catch:&apos;, err);
})
</code></pre><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p><code>resolve 函数</code>将 Promise 对象的状态从<code>“未完成”变为“成功”</code>（即从 <code>pending 变为 resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p>
<p><code>reject 函数</code>将 Promise 对象的状态从<code>“未完成”变为“失败”</code>（即从 <code>pending 变为 rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>而一旦状态改变，就不会再变。<br>所以 代码中的<code>reject(&#39;error&#39;);</code> 不会有作用。</p>
<p>Promise 只能 resolve 一次，剩下的调用都会被忽略。<br>所以 第二次的 <code>resolve(&#39;success2&#39;);</code> 也不会有作用。</p>
<h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><pre><code>then: success1
</code></pre><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p><code>Promise.resolve</code> 方法的参数如果是一个原始值，或者是一个不具有 <code>then</code> 方法的对象，则 <code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为<code>resolved</code>，<code>Promise.resolve</code> 方法的参数，会同时传给回调函数。</p>
<p><code>then</code> 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 <code>then(null)</code>，这就会导致前一个 <code>Promise</code> 的结果会穿透下面。</p>
<h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><pre><code>1
</code></pre><h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promse实现）三个亮灯函数已经存在：</p>
<pre><code>functionred() {
    console.log(&apos;red&apos;);
}
functiongreen() {
    console.log(&apos;green&apos;);
}
functionyellow() {
    console.log(&apos;yellow&apos;);
}
</code></pre><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，意思就是3秒，执行一次 red 函数，2秒执行一次 green 函数，1秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以就利用递归来实现。</p>
<h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><pre><code>functionred() {
    console.log(&apos;red&apos;);
}
functiongreen() {
    console.log(&apos;green&apos;);
}
functionyellow() {
    console.log(&apos;yellow&apos;);
}

var light = function (timmer, cb) {
    returnnewPromise(function (resolve, reject) {
        setTimeout(function () {
            cb();
            resolve();
        }, timmer);
    });
};

var step = function () {
    Promise.resolve().then(function () {
        return light(3000, red);
    }).then(function () {
        return light(2000, green);
    }).then(function () {
        return light(1000, yellow);
    }).then(function () {
        step();
    });
}

step();
</code></pre><p>这个答案，看上去已经很不错了，不过经小伙伴提醒，如果一直这么递归下去，会有栈溢出的问题，对于这个问题，其他小伙伴有什么优化建议的话，可以在评论区展示出来。</p>
<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><p>实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。</p>
<pre><code>const timeout = ms =&gt;newPromise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve();
    }, ms);
});

const ajax1 = () =&gt; timeout(2000).then(() =&gt; {
    console.log(&apos;1&apos;);
    return1;
});

const ajax2 = () =&gt; timeout(1000).then(() =&gt; {
    console.log(&apos;2&apos;);
    return2;
});

const ajax3 = () =&gt; timeout(2000).then(() =&gt; {
    console.log(&apos;3&apos;);
    return3;
});

const mergePromise = ajaxArray =&gt; {
    // 在这里实现你的代码

};

mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; {
    console.log(&apos;done&apos;);
    console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出// 1// 2// 3// done// [1, 2, 3]
</code></pre><h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><p>首先 <code>ajax1 、ajax2、ajax3</code> 都是函数，只是这些函数执行后会返回一个 <code>Promise</code>，按题目的要求我们只要顺序执行这三个函数就好了，然后把结果放到 <code>data</code> 中，但是这些函数里都是异步操作，想要按顺序执行，然后输出 1，2，3并没有那么简单，看个例子。</p>
<pre><code>functionA() {
    setTimeout(function () {
        console.log(&apos;a&apos;);
    }, 3000);
}

functionB() {
    setTimeout(function () {
        console.log(&apos;b&apos;);
    }, 1000);
}

A();
B();

// b// a
</code></pre><p>例子中我们是按顺序执行的 <code>A</code>，<code>B</code> 但是输出的结果却是 <code>b</code>，<code>a</code> 对于这些异步函数来说，并不会按顺序执行完一个，再执行后一个。<br>这道题就是考用 <code>Promise</code> 控制异步流程，我们要想办法，让这些函数，一个执行完之后，再执行下一个，看答案吧。</p>
<h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><pre><code>// 保存数组中的函数执行后的结果var data = [];

// Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。var sequence = Promise.resolve();

ajaxArray.forEach(function (item) {
    // 第一次的 then 方法用来执行数组中的每个函数，// 第二次的 then 方法接受数组中的函数执行后返回的结果，// 并把结果添加到 data 中，然后把 data 返回。
    sequence = sequence.then(item).then(function (res) {
        data.push(res);
        return data;
    });
})

// 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。return sequence;
</code></pre><h3 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h3><p>以下代码最后输出什么？</p>
<pre><code>const first = () =&gt; (newPromise((resolve, reject) =&gt; {
    console.log(3);
    let p = newPromise((resolve, reject) =&gt; {
        console.log(7);
        setTimeout(() =&gt; {
            console.log(5);
            resolve(6);
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) =&gt; {
        console.log(arg);
    });

}));

first().then((arg) =&gt; {
    console.log(arg);
});
console.log(4);
</code></pre><h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><p>这道题就其实和 <code>Promise</code> 的关系不太大，主要是需要理解 JS执行机制，才能很好的解决这道题，对于 JS 执行机制不了解的朋友推荐看看这篇文章</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p>
<h4 id="第一轮事件循环"><a href="#第一轮事件循环" class="headerlink" title="第一轮事件循环"></a>第一轮事件循环</h4><p>先执行宏任务，主script ，new Promise立即执行，输出【3】，</p>
<p>执行 p 这个new Promise 操作，输出【7】，</p>
<p>发现 setTimeout，将回调放入下一轮任务队列（Event Queue），p 的 then，姑且叫做 then1，放入微任务队列，发现 first 的 then，叫 then2，放入微任务队列。执行<code>console.log(4)</code>，输出【4】，宏任务执行结束。</p>
<p>再执行微任务，执行 then1，输出【1】，</p>
<p>执行 then2，输出【2】。</p>
<p>到此为止，第一轮事件循环结束。开始执行第二轮。</p>
<h4 id="第二轮事件循环"><a href="#第二轮事件循环" class="headerlink" title="第二轮事件循环"></a>第二轮事件循环</h4><p>先执行宏任务里面的，也就是 setTimeout 的回调，输出【5】。<br><code>resolve(6)</code> 不会生效，因为 p 这个 Promise 的状态一旦改变就不会在改变了。</p>
<h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><pre><code>374125
</code></pre><h3 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h3><p>有 8 个图片资源的 url，已经存储在数组 <code>urls</code> 中（即<code>urls = [&#39;http://example.com/1.jpg&#39;, ...., &#39;http://example.com/8.jpg&#39;]）</code>，而且已经有一个函数 <code>function loadImg</code>，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。<br>但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。<br>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p>
<pre><code>var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;];
functionloadImg(url) {
    returnnewPromise((resolve, reject) =&gt; {
        const img = new Image()
        img.onload = function () {
            console.log(&apos;一张图片加载完成&apos;);
            resolve();
        }
        img.onerror = reject
        img.src = url
    })
};
</code></pre><h3 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h3><p>题目的意思是需要我们这么做，先并发请求 3 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 3 个，直到需要加载的图片都全部发起请求。</p>
<p>用 Promise 来实现就是，先并发请求3个图片资源，这样可以得到 3 个 Promise，组成一个数组，就叫<code>promises</code> 吧，然后不断的调用 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise%23Promise-race" target="_blank" rel="noopener">Promise.race</a> 来返回最快改变状态的 Promise，然后从数组（<code>promises</code>）中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 url 被取完，最后再使用 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise%23Promise-all" target="_blank" rel="noopener">Promise.all</a> 来处理一遍数组（<code>promises</code>）中没有改变状态的 Promise。</p>
<h3 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h3><pre><code>var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;];
functionloadImg(url) {
    returnnewPromise((resolve, reject) =&gt; {
        const img = new Image()
        img.onload = function () {
            console.log(&apos;一张图片加载完成&apos;);
            resolve();
        }
        img.onerror = reject
        img.src = url
    })
};

functionlimitLoad(urls, handler, limit) {
    // 对数组做一个拷贝const sequence = [].concat(urls)
    let promises = [];

    //并发请求到最大数
    promises = sequence.splice(0, limit).map((url, index) =&gt; {
        // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标return handler(url).then(() =&gt; {
            return index
        }); 
    });

    // 利用数组的 reduce 方法来以队列的形式执行return sequence.reduce((last, url, currentIndex) =&gt; {
        return last.then(() =&gt; {
            // 返回最快改变状态的 PromisereturnPromise.race(promises)
        }).catch(err =&gt; {
            // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误// 更重要的是防止中断整个链式调用console.error(err)
        }).then((res) =&gt; {
            // 用新的 Promise 替换掉最快改变状态的 Promise
            promises[res] = handler(sequence[currentIndex]).then(() =&gt; { return res });
        })
    }, Promise.resolve()).then(() =&gt; {
        returnPromise.all(promises)
    })

}
limitLoad(urls, loadImg, 3)

/*
因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用

limitLoad(urls, loadImg, 3).then(() =&gt; {
    console.log(&apos;所有图片加载完成&apos;);
}).catch(err =&gt; {
    console.error(err);
})
*/
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tx.jpg" alt="李斌">
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">132</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">105</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


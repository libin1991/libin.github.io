<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>LuckDay</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/02/CSS如何实现文字两端对齐/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/02/CSS如何实现文字两端对齐/" itemprop="url">CSS如何实现文字两端对齐</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-02T23:22:03+08:00">
                2017-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在工作项目中接触到Web界面设计的问题，要实现文字两端对齐的效果。在网上搜索了一下，差不多都是互相转帖，用的都是类似的技巧：</p>
<pre><code>text-align:justify;
text-justify:inter-ideograph;
</code></pre><p>但问题是，我怎么就看不到效果呢？无论是英文还是中文，在IE和chrome下都不起作用。后来，终于在StackOverflow上找到解决方法了。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .arter li {
                font-size: 14px;
                line-height: 24px;
                color: #4a4a4a;
            }

            .arter span {
                height: 24px;
                line-height: 24px;
                width: 65px;
                text-align: justify;
                display: inline-block;
                overflow: hidden;
                vertical-align: top;
            }

            .arter i {
                display: inline-block;
                width: 100%;
                height: 0;
            }




            .arter1 li {
                font-size: 14px;
                line-height: 24px;
                color: #4a4a4a;
            }



            .arter1 span {
                height: 24px;
                line-height: 24px;
                width: 65px;
                text-align: justify;
                display: inline-block;
                overflow: hidden;
                vertical-align: top;
            }
            .arter1 span:after {
                content: &quot; &quot;;
                display: inline-block;
                width: 100%;
                height: 0px;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;ul class=&quot;arter&quot;&gt;
            &lt;li&gt;&lt;span&gt;作品名称&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 宝贝儿&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;作品类型&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;艺术家&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 张玉瀛&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;风格&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 超现实&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;材质&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 布面油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;题材&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 人物&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;创作时间&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 2011&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;所在位置&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 华东&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;尺寸&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 78x78cm&lt;/li&gt;
        &lt;/ul&gt;
        &lt;br /&gt;&lt;br /&gt;
        &lt;ul class=&quot;arter1&quot;&gt;
            &lt;li&gt;&lt;span&gt;作品名称&lt;/span&gt;： 宝贝儿&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;作品类型&lt;/span&gt;： 油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;艺术家&lt;/span&gt;： 张玉瀛&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;风格&lt;/span&gt;： 超现实&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;材质&lt;/span&gt;： 布面油画&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;题材&lt;/span&gt;： 人物&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;创作时间&lt;/span&gt;： 2011&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;所在位置&lt;/span&gt;： 华东&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;尺寸&lt;/span&gt;： 78x78cm&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>样式：<br><img src="https://pic1.zhimg.com/v2-b92871dee74e80785026c069073206ab_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-b92871dee74e80785026c069073206ab_hd.jpg" alt=""><br>从效果图可以看到，除了要在块级元素加text-align:justify样式外，还需要在里面加一个空的span元素，并应用样式。另外，对于中文还必须用空格隔开汉字，否则也没有两端对齐的效果。英文每个单词都有空格隔开，所以没问题。</p>
<p>但是加入HTML元素又违反了结构表现分离的原则，我们可以改用after、before伪元素：</p>
<pre><code>li:after {
    content: &quot; &quot;;
    display: inline-block;
    width: 100%;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/15/用css让一个容器水平垂直居中/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/15/用css让一个容器水平垂直居中/" itemprop="url">用css让一个容器水平垂直居中</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-15T23:19:26+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>阅读目录</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label0" target="_blank" rel="noopener">方法一：position加margin</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label1" target="_blank" rel="noopener">方法二： diaplay:table-cell</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label2" target="_blank" rel="noopener">方法三：position加 transform</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label3" target="_blank" rel="noopener">方法四：flex;align-items: center;justify-content: center</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label4" target="_blank" rel="noopener">方法五：display:flex;margin:auto</a></li>
<li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label5" target="_blank" rel="noopener">方法六：纯position</a></li>
</ul>
<p>这种css布局平时用的比较多，也是面试题常出的一个题，网上一搜一大丢，不过还是想自己总结一下。</p>
<p>这种方法比较多，本文只总结其中的几种，以便加深印象。</p>
<p>效果图都为这个：</p>
<p><img src="https://pic1.zhimg.com/v2-cf428b1f71583bc3feeeedcdc87d9e6c_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf428b1f71583bc3feeeedcdc87d9e6c_hd.jpg" alt=""></p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法一：position加margin"><a href="#方法一：position加margin" class="headerlink" title="方法一：position加margin"></a>方法一：position加margin</h2><pre><code>/**html**/
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/**css**/
.wrap {
    width: 200px;
    height: 200px;
    background: yellow;
    position: relative;
}
.wrap .center {
    width: 100px;
    height: 100px;
    background: green;
    margin: auto;
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
}
</code></pre><p>兼容性：主流浏览器均支持，IE6不支持</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法二：-diaplay-table-cell"><a href="#方法二：-diaplay-table-cell" class="headerlink" title="方法二： diaplay:table-cell"></a>方法二： diaplay:table-cell</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
     &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/*css*/
.wrap{
    width: 200px;
    height: 200px;
    background: yellow;
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}
.center{
    display: inline-block;
    vertical-align: middle;
    width: 100px;
    height: 100px;
    background: green;
}
</code></pre><p>兼容性：由于display:table-cell的原因，IE6\7不兼容</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法三：position加-transform"><a href="#方法三：position加-transform" class="headerlink" title="方法三：position加 transform"></a>方法三：position加 transform</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    position: relative;
    background: yellow;
    width: 200px;
    height: 200px;}

.center {
    position: absolute;
    background: green;
    top:50%;
    left:50%;
    -webkit-transform:translate(-50%,-50%);
    transform:translate(-50%,-50%);
    width: 100px;
    height: 100px;
}
</code></pre><p>兼容性：ie9以下不支持 transform，手机端表现的比较好。</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法四：flex-align-items-center-justify-content-center"><a href="#方法四：flex-align-items-center-justify-content-center" class="headerlink" title="方法四：flex;align-items: center;justify-content: center"></a>方法四：flex;align-items: center;justify-content: center</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    display: flex; 
    align-items: center; 
    justify-content: center;
}

.center {
    background: green;
    width: 100px;
    height: 100px;
}
</code></pre><p>移动端首选</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法五：display-flex-margin-auto"><a href="#方法五：display-flex-margin-auto" class="headerlink" title="方法五：display:flex;margin:auto"></a>方法五：display:flex;margin:auto</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    display: flex; 
}

.center {
    background: green;
    width: 100px;
    height: 100px;
    margin: auto;
}
</code></pre><p>移动端首选</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p>
<h2 id="方法六：纯position"><a href="#方法六：纯position" class="headerlink" title="方法六：纯position"></a>方法六：纯position</h2><pre><code>&lt;!-- html --&gt;
&lt;div class=&quot;wrap&quot;&gt;
    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;

/* css */
.wrap {
    background: yellow;
    width: 200px;
    height: 200px;
    position: relative;
}
/**方法一**/
.center {
    background: green;
    position: absolute;
    width: 100px;
    height: 100px;
    left: 50px;
    top: 50px; 
　　
}
/**方法二**/
.center {
    background: green;
    position: absolute;
    width: 100px;
    height: 100px;
    left: 50%;
    top: 50%;
　　margin-left:-50px;
　　margin-top:-50px;
}　 
</code></pre><p>兼容性：适用于所有浏览器</p>
<p>  方法六中的方法一计算公式如下：</p>
<p>　　子元素（conter）的left值计算公式：left=(父元素的宽 - 子元素的宽 ) / 2=(200-100) / 2=50px;</p>
<p>　　子元素（conter）的top值计算公式：top=(父元素的高 - 子元素的高 ) / 2=(200-100) / 2=50px;</p>
<p>　　方法二计算公式：</p>
<p>　　left值固定为50%;</p>
<p>　　子元素的margin-left= -（子元素的宽/2）=-100/2= -50px;</p>
<p>　　top值也一样，固定为50%</p>
<pre><code>子元素的margin-top= -（子元素的高/2）=-100/2= -50px;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/22/算法的时间复杂度和空间复杂度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/22/算法的时间复杂度和空间复杂度/" itemprop="url">算法的时间复杂度和空间复杂度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-22T23:26:28+08:00">
                2017-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1 - 算法</p>
<p>算法的定义是这样的：解题方案的准确而完善的描述，是一系列解决问题的清晰指令。巴拉巴拉的，虽然是一小句但还是不想看（题外话：有时候吧专业名词记下来面试的时候还是挺有用的），其实就是解决一个问题的完整性描述。只不过这个描述就可能是用不同的方式或者说是“语言”了。</p>
<p>2 - 算法的效率</p>
<p>既然算法是解决问题的描述，那么就像一千个人眼中有一千个阿姆雷特他大姨夫一样，解决同一个问题的办法也是多种多样的，只是在这过程中我们所使用/消耗的时间或者时间以外的代价（计算机消耗的则为内存了）不一样。为了更快、更好、更强的发扬奥利奥..哦不，提高算法的效率。所以很多时候一个优秀的算法就在于它与其他实现同一个问题的算法相比，在时间或空间（内存）或者时间和空间（内存）上都得到明显的降低。</p>
<p>所以呢，算法的效率主要由以下两个复杂度来评估：</p>
<blockquote>
<p>时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。<br>空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。</p>
</blockquote>
<p>设计算法时，时间复杂度要比空间复杂度更容易出问题，所以一般情况一下我们只对时间复杂度进行研究。一般面试或者工作的时候没有特别说明的话，复杂度就是指时间复杂度。</p>
<p>2.0 - 时间复杂度</p>
<p>接下来我们还需要知道另一个概念：时间频度。这个时候你可能会说：“不是说好一起学算法吗，这些东东是什么？赠品吗？”。非也非也，这是非卖品。</p>
<p>因为一个算法执行所消耗的时间理论上是不能算出来的，没错正是理论上，so我们任然可以在程序中测试获得。但是我们不可能又没必要对每个算法进行测试，只需要知道大概的哪个算法执行所花费的时间多，哪个花费的时间少就行了。如果一个算法所花费的时间与算法中代码语句执行次数成正比，那么那个算法执行语句越多，它的花费时间也就越多。我们把一个算法中的语句执行次数称为时间频度。通常（ps:很想知道通常是谁）用<code>T(n)</code>表示。</p>
<p>在时间频度<code>T(n)</code>中，n又代表着问题的规模，当n不断变化时，<code>T(n)</code>也会不断地随之变化。为了了解这个变化的规律，时间复杂度这一概念就被引入了。一般情况下算法基础本操作的重复执行次数为问题规模n的某个函数，用也就是时间频度<code>T(n)</code>。如果有某个辅助函数<code>f(n)</code>，当趋于无穷大的时候，<code>T(n)/f(n)</code>的极限值是不为零的某个常数，那么<code>f(n)</code>是<code>T(n)</code>的同数量级函数，记作<code>T(n)=O(f(n))</code>，被称为算法的渐进时间复杂度，又简称为时间复杂度。</p>
<p>2.1 - 大O表示法</p>
<p>用O(n)来体现算法时间复杂度的记法被称作大O表示法</p>
<p>一般我们我们评估一个算法都是直接评估它的最坏的复杂度。</p>
<p>大O表示法<code>O(f(n))</code>中的<code>f(n)</code>的值可以为1、n、logn、n^2 等，所以我们将O(1)、O(n)、O(logn)、O( n^2 )分别称为常数阶、线性阶、对数阶和平方阶。下面我们来看看推导大O阶的方法：</p>
<p>推导大O阶</p>
<p>推导大O阶有一下三种规则：</p>
<ol>
<li>用常数1取代运行时间中的所有加法常数</li>
<li>只保留最高阶项</li>
<li>去除最高阶的常数</li>
</ol>
<p>举好多栗子</p>
<ul>
<li><p>常数阶</p>
<p>  let sum = 0, n = 10; // 语句执行一次<br>  let sum = (1+n)*n/2; // 语句执行一次<br>  console.log(<code>The sum is : ${sum}</code>) //语句执行一次 </p>
</li>
</ul>
<p>这样的一段代码它的执行次数为 3 ，然后我们套用规则1，则这个算法的时间复杂度为O(1)，也就是常数阶。</p>
<ul>
<li><p>线性阶</p>
<p>  let i =0; // 语句执行一次<br>  while (i &lt; n) { // 语句执行n次 </p>
<pre><code>console.log(`Current i is ${i}`); //语句执行n次
i++; // 语句执行n次
</code></pre><p>  }</p>
</li>
</ul>
<p>这个算法中代码总共执行了 3n + 1次，根据规则 2-&gt;3，因此该算法的时间复杂度是O(n)。</p>
<ul>
<li><p>对数阶</p>
<p>  let number = 1; // 语句执行一次<br>  while (number &lt; n) { // 语句执行logn次</p>
<pre><code>number *= 2; // 语句执行logn次
</code></pre><p>  }</p>
</li>
</ul>
<p>上面的算法中，number每次都放大两倍，我们假设这个循环体执行了m次，那么<code>2^m = n</code>即<code>m = logn</code>，所以整段代码执行次数为1 + 2*logn，则<code>f(n) = logn</code>，时间复杂度为O(logn)。</p>
<ul>
<li><p>平方阶</p>
<p>  for (let i = 0; i &lt; n; i++) { // 语句执行n次 </p>
<pre><code>for (let j = 0; j &lt; n; j++) { // 语句执行n^2次 
   console.log(&apos;I am here!&apos;); // 语句执行n^2
}
</code></pre><p>  }</p>
</li>
</ul>
<p>上面的嵌套循环中，代码共执行 2*n^2 + n，则<code>f(n) = n^2</code>。所以该算法的时间复杂度为O(n^2 )</p>
<p>常见时间复杂度的比较</p>
<p>常见的时间复杂度函数相信大家在大学中都已经见过了，这里也不多做解释了：</p>
<p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/01/原生-JS-汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/01/原生-JS-汇总/" itemprop="url">原生 JS 汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-01T22:27:31+08:00">
                2017-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JS选取DOM元素的方法 注意：原生JS选取DOM元素比使用jQuery类库选取要快很多</p>
<pre><code>1、通过ID选取元素 document.getElementById(&apos;myid&apos;);
 2、通过CLASS选取元素 document.getElementsByClassName(&apos;myclass&apos;)[0]; 
 3、通过标签选取元素 document.getElementsByTagName(&apos;mydiv&apos;)[0];
 4、通过NAME属性选取元素（常用于表单） document.getElementsByName(&apos;myname&apos;)[0];
</code></pre><p>JS修改CSS样式 </p>
<pre><code>document.getElementById(&apos;myid&apos;).style.display = &apos;none&apos;;
</code></pre><p>class 操作：</p>
<pre><code>JS修改CLASS属性
document.getElementById(&apos;myid&apos;).className = &apos;active&apos;;
如果有多个CLASS属性，即用空格隔开
document.getElementById(&apos;myid&apos;).className = &apos;active div-1&apos;;
移除该元素上的所有CLASS
document.getElementById(&apos;myid&apos;).className = &apos;&apos;;
注意：使用classList会优于使用className
document.getElementById(&apos;myid&apos;).classList.item(0);//item为类名的索引
document.getElementById(&apos;myid&apos;).classList.length;//只读属性
document.getElementById(&apos;myid&apos;).classList.add(&apos;newClass&apos;);//添加class
document.getElementById(&apos;myid&apos;).classList.remove(&apos;newClass&apos;);//移除class
document.getElementById(&apos;myid&apos;).classList.toggle(&apos;newClass&apos;);//切换，有则移除，没有则添加
document.getElementById(&apos;myid&apos;).classList.contains(&apos;newClass&apos;);//判断是否存在该class
</code></pre><p>补充：add和remove方法不允许链式操作，因为返回的都是undefined，其次，也不允许同时添加或删除多个class，可以自行扩展一下</p>
<pre><code>DOMTokenList.prototype.adds = function(tokens){  
   tokens.split(&apos; &apos;).forEach(function(token){  
      this.add(token);  
   }).bind(this));  
   return this;  
};  
var clList = document.body.classList;  
clList.adds(&apos;a b c&apos;).toString();  
//a b c 
</code></pre><p>JS修改文本 </p>
<pre><code>document.getElementById(&apos;myid&apos;).innerHTML = &apos;123&apos;;
</code></pre><p>JS创建元素并向其中追加文本</p>
<pre><code>var newdiv = document.createElement(&apos;div&apos;);
var newtext = document.createTextNode(&apos;123&apos;);
newdiv.appendChild(newtext);
document.body.appendChild(newdiv);
</code></pre><p>同理：removeChild()移除节点，并返回节点</p>
<p>cloneNode()复制节点</p>
<p>insertBefore()插入节点（父节点内容的最前面）</p>
<p>注意：insertBefore()有两个参数，第一个是插入的节点，第二个是插入的位置</p>
<p>例子：</p>
<pre><code>var list = document.getElementById(&apos;myList&apos;);
list.insertBefore(newItem,list.childNodes[1]);
//插入新节点newItem到list的第二个子节点
</code></pre><p>JS返回所有子节点对象childNodes</p>
<pre><code>var mylist = document.getElementById(&apos;myid&apos;);
for(var i=0,i&lt;mylist.childNodes.length;i++){
console.log(mylist.childNodes[i]);
}
firstChild返回第一个子节点
lastChild返回最后一个子节点
parentNode返回父节点对象
nextSibling返回下一个兄弟节点对象
previousSibling返回前一个兄弟节点对象
nodeName返回节点的HTML标记名称
</code></pre><p>原生JS汇总：</p>
<pre><code>一、节点
1.1 节点属性
Node.nodeName   //返回节点名称，只读
Node.nodeType   //返回节点类型的常数值，只读
Node.nodeValue  //返回Text或Comment节点的文本值，只读
Node.textContent  //返回当前节点和它的所有后代节点的文本内容，可读写
Node.baseURI    //返回当前网页的绝对路径

Node.ownerDocument  //返回当前节点所在的顶层文档对象，即document
Node.nextSibling  //返回紧跟在当前节点后面的第一个兄弟节点
Node.previousSibling  //返回当前节点前面的、距离最近的一个兄弟节点
Node.parentNode   //返回当前节点的父节点
Node.parentElement  //返回当前节点的父Element节点
Node.childNodes   //返回当前节点的所有子节点
Node.firstChild  //返回当前节点的第一个子节点
Node.lastChild   //返回当前节点的最后一个子节点

//parentNode接口
Node.children  //返回指定节点的所有Element子节点
Node.firstElementChild  //返回当前节点的第一个Element子节点
Node.lastElementChild   //返回当前节点的最后一个Element子节点
Node.childElementCount  //返回当前节点所有Element子节点的数目。
1.2 操作
Node.appendChild(node)   //向节点添加最后一个子节点
Node.hasChildNodes()   //返回布尔值，表示当前节点是否有子节点
Node.cloneNode(true);  // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)
Node.insertBefore(newNode,oldNode)  // 在指定子节点之前插入新的子节点
Node.removeChild(node)   //删除节点，在要删除节点的父节点上操作
Node.replaceChild(newChild,oldChild)  //替换节点
Node.contains(node)  //返回一个布尔值，表示参数节点是否为当前节点的后代节点。
Node.compareDocumentPosition(node)   //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系
Node.isEqualNode(noe)  //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。
Node.normalize()   //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。

//ChildNode接口
Node.remove()  //用于删除当前节点
Node.before()  //
Node.after()
Node.replaceWith()
1.3 Document节点
1.3.1 Document节点的属性
document.doctype   //
document.documentElement  //返回当前文档的根节点
document.defaultView   //返回document对象所在的window对象
document.body   //返回当前文档的&lt;body&gt;节点
document.head   //返回当前文档的&lt;head&gt;节点
document.activeElement  //返回当前文档中获得焦点的那个元素。

//节点集合属性
document.links  //返回当前文档的所有a元素
document.forms  //返回页面中所有表单元素
document.images  //返回页面中所有图片元素
document.embeds  //返回网页中所有嵌入对象
document.scripts  //返回当前文档的所有脚本
document.styleSheets  //返回当前网页的所有样式表

//文档信息属性
document.documentURI  //表示当前文档的网址
document.URL  //返回当前文档的网址
document.domain  //返回当前文档的域名
document.lastModified  //返回当前文档最后修改的时间戳
document.location  //返回location对象，提供当前文档的URL信息
document.referrer  //返回当前文档的访问来源
document.title    //返回当前文档的标题
document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。
document.readyState  //返回当前文档的状态
document.designMode  //控制当前文档是否可编辑，可读写
document.compatMode  //返回浏览器处理文档的模式
document.cookie   //用来操作Cookie
1.3.2 Document节点的方法
（1）读写方法
document.open()   //用于新建并打开一个文档
document.close()   //不安比open方法所新建的文档
document.write()   //用于向当前文档写入内容
document.writeIn()  //用于向当前文档写入内容，尾部添加换行符。
（2）查找节点
document.querySelector(selectors)   //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。
document.querySelectorAll(selectors)  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。
document.getElementsByTagName(tagName)  //返回所有指定HTML标签的元素
document.getElementsByClassName(className)   //返回包括了所有class名字符合指定条件的元素
document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）
document.getElementById(id)   //返回匹配指定id属性的元素节点。
document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。
（3）生成节点
document.createElement(tagName)   //用来生成HTML元素节点。
document.createTextNode(text)   //用来生成文本节点
document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。
document.createDocumentFragment()  //生成一个DocumentFragment对象
（4）事件方法
document.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用
document.addEventListener(type,listener,capture)  //注册事件
document.removeEventListener(type,listener,capture)  //注销事件
document.dispatchEvent(event)  //触发事件
（5）其他
document.hasFocus()   //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。
document.adoptNode(externalNode)  //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。
document.importNode(externalNode, deep)   //从外部文档拷贝指定节点，插入当前文档。
1.4 Element节点
1.4.1 Element节点的属性
（1）特性属性
Element.attributes  //返回当前元素节点的所有属性节点
Element.id  //返回指定元素的id属性，可读写
Element.tagName  //返回指定元素的大写标签名
Element.innerHTML   //返回该元素包含的HTML代码，可读写
Element.outerHTML  //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写
Element.className  //返回当前元素的class属性，可读写
Element.classList  //返回当前元素节点的所有class集合
Element.dataset   //返回元素节点中所有的data-*属性。
（2）尺寸属性
Element.clientHeight   //返回元素节点可见部分的高度
Element.clientWidth   //返回元素节点可见部分的宽度
Element.clientLeft   //返回元素节点左边框的宽度
Element.clientTop   //返回元素节点顶部边框的宽度
Element.scrollHeight  //返回元素节点的总高度
Element.scrollWidth  //返回元素节点的总宽度
Element.scrollLeft   //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置
Element.scrollTop   //返回元素节点的垂直滚动向下滚动的像素数值
Element.offsetHeight   //返回元素的垂直高度(包含border,padding)
Element.offsetWidth    //返回元素的水平宽度(包含border,padding)
Element.offsetLeft    //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移
Element.offsetTop   //返回水平位移
Element.style  //返回元素节点的行内样式
（3）节点相关属性
Element.children   //包括当前元素节点的所有子元素
Element.childElementCount   //返回当前元素节点包含的子HTML元素节点的个数
Element.firstElementChild  //返回当前节点的第一个Element子节点  
Element.lastElementChild   //返回当前节点的最后一个Element子节点  
Element.nextElementSibling  //返回当前元素节点的下一个兄弟HTML元素节点
Element.previousElementSibling  //返回当前元素节点的前一个兄弟HTML节点
Element.offsetParent   //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。
1.4.2 Element节点的方法
（1）位置方法
getBoundingClientRect()  
// getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高
// top 元素上外边界距窗口最上面的距离
// right 元素右外边界距窗口最上面的距离
// bottom 元素下外边界距窗口最上面的距离
// left 元素左外边界距窗口最上面的距离
// width 元素自身宽(包含border,padding) 
// height 元素自身高(包含border,padding) 

getClientRects()   //返回当前元素在页面上形参的所有矩形。

// 元素在页面上的偏移量  
var rect = el.getBoundingClientRect()  
return {   
  top: rect.top + document.body.scrollTop,   
  left: rect.left + document.body.scrollLeft  
}
（2）属性方法
Element.getAttribute()：读取指定属性  
Element.setAttribute()：设置指定属性  
Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  
Element.removeAttribute()：移除指定属性
（3）查找方法
Element.querySelector()  
Element.querySelectorAll()  
Element.getElementsByTagName()  
Element.getElementsByClassName()
（4）事件方法
Element.addEventListener()：添加事件的回调函数  
Element.removeEventListener()：移除事件监听函数  
Element.dispatchEvent()：触发事件

//ie8
Element.attachEvent(oneventName,listener)
Element.detachEvent(oneventName,listener)

// event对象  
var event = window.event||event;    

// 事件的目标节点  
var target = event.target || event.srcElement;

// 事件代理  
ul.addEventListener(&apos;click&apos;, function(event) {   
  if (event.target.tagName.toLowerCase() === &apos;li&apos;) {   
    console.log(event.target.innerHTML)   
  }  
});
（5）其他
Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域

//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。
Element.insertAdjacentHTML(where, htmlString); 
Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入  
Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 
Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 
Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入

Element.remove()  //用于将当前元素节点从DOM中移除
Element.focus()   //用于将当前页面的焦点，转移到指定元素上
二、CSS操作
（1）类名操作
//ie8以下
Element.className  //获取元素节点的类名
Element.className += &apos; &apos; + newClassName  //新增一个类名

//判断是否有某个类名
function hasClass(element,className){
  return new RegExp(className,&apos;gi&apos;).test(element.className);
}

//移除class
function removeClass(element,className){
  element.className = element.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);
}

//ie10 
element.classList.add(className)  //新增
element.classList.remove(className)  //删除
element.classList.contains(className)  //是否包含
element.classList.toggle(className)  //toggle class
（2）style操作
element.setAttribute(&apos;style&apos;,&apos;&apos;)

element.style.backgroundColor = &apos;red&apos;

element.style.cssText //用来读写或删除整个style属性

element.style.setProperty(propertyName,value)  //设置css属性
element.style.getPropertyValue(property)  //获取css属性
element.style.removeProperty(property)  //删除css属性
操作非内联样式
//ie8
element.currentStyle[attrName]
//ie9+
window.getComputedStyle(el,null)[attrName] 
window.getComputedStyle(el,null).getPropertyValue(attrName)
//伪类
window.getComputedStyle(el,&apos;:after&apos;)[attrName]
三、对象
3.1 Object对象
（1）生成实例对象
var o = new Object()
（2）属性
Object.prototype   //返回原型对象
（3）方法
Object.keys(o)   //遍历对象的可枚举属性
Object.getOwnPropertyName(o)   //遍历对象不可枚举的属性
对象实例的方法
valueOf()：返回当前对象对应的值。  
toString()：返回当前对象对应的字符串形式。  
toLocaleString()：返回当前对象对应的本地字符串形式。  
hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 
isPrototypeOf()：判断当前对象是否为另一个对象的原型。
propertyIsEnumerable()：判断某个属性是否可枚举。
3.2 Array对象
（1）生成实例对象
var a = new Array()
（2）属性
a.length  //长度
（3）Array.isArray()
Array.isArray(a)   //用来判断一个值是否为数组
（4）Array实例的方法

[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;

a.valueof()   //返回数组本身
a.toString()  //返回数组的字符串形式
a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。
pop()   //用于删除数组的最后一个元素，并返回该元素
join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。
concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。
shift()  //用于删除数组的第一个元素，并返回该元素。
unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。
reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组
slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。
splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。
sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。
map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。
map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。
forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。
filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。
some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。
every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。
reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）
reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）
indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置
lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。
3.3 Number对象
（1）生成对象
var n = new Number()
（2）Number对象的属性
Number.POSITIVE_INFINITY：正的无限，指向Infinity。  
Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。  
Number.NaN：表示非数值，指向NaN。  
Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。  
Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。  
Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。  
Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。
（4）Number对象实例的方法
toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。
toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。
toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。
toPrecision()  //用于将一个数转为指定位数的有效数字。
3.4 String 对象
（1）生成实例对象
var s = new String()
（2）String对象的属性
s.length   //返回字符串的长度
（3）方法
s.chatAt(index)   //返回指定位置的字符    //&quot;123456&quot;[0] == &quot;1&quot;
s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。
s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）
s.concat(s2)  //用于连接两个字符串
s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。
s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。
s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。
s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 
s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。
s.trim()  //用于去除字符串两端的空格，返回一个新字符串
s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。
s.toUpperCase()  //全部转为大写
s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。
s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。
s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。
s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。
s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。
3.5 Math对象
（1）属性
Math.E：常数e。  
Math.LN2：2的自然对数。  
Math.LN10：10的自然对数。  
Math.LOG2E：以2为底的e的对数。  
Math.LOG10E：以10为底的e的对数。  
Math.PI：常数Pi。  
Math.SQRT1_2：0.5的平方根。  
Math.SQRT2：2的平方根。
（2）数学方法
Math.abs()：返回参数的绝对值  
Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 
Math.floor()：向下取整  
Math.max(n,n1,...)：可接受多个参数，返回最大值  
Math.min(n,n1,..)：可接受多个参数，返回最小值  
Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 
Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。  
Math.log()：返回以e为底的自然对数值。
Math.exp()：返回e的指数，也就是常数e的参数次方。
Math.round()：四舍五入  
Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。
（3）三角函数方法
Math.sin()：返回参数的正弦  
Math.cos()：返回参数的余弦  
Math.tan()：返回参数的正切  
Math.asin()：返回参数的反正弦（弧度值）  
Math.acos()：返回参数的反余弦（弧度值）  
Math.atan()：返回参数的反正切（弧度值）
3.6 JSON对象
（1）方法
JSON.stringify()   
//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。
//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。
//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。

JSON.parse()   //用于将JSON字符串转化成对象。
3.7 console对象
（1）方法
console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。
console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。
console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；
console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈
console.table()  //可以将复合类型的数据转为表格显示。
console.count()  //用于计数，输出它被调用了多少次。
console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。
console.dirxml()  //用于以目录树的形式，显示DOM节点。
console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。

//这两个方法用于计时，可以算出一个操作所花费的准确时间。
console.time()
console.timeEnd()
//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。

console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。
console.profileEnd()  //用来结束正在运行的性能测试器。

console.group()
console.groupend()
//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。
console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。

console.trace()  //显示当前执行的代码在堆栈中的调用路径。
console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。


正则表达式：
只允许输入汉字：onkeyup=&quot;value=value.replace(/[^\u4E00-\u9FA5]/g,&apos;&apos;)&quot; 
只允许输入数字：onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot;
[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;
</code></pre><p>例子：</p>
<pre><code>&lt;ul class=”main”&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
            &lt;li&gt;3&lt;/li&gt;
        &lt;/ul&gt;
请用原生JS实现：
        &lt;ul class=”main”&gt;
            &lt;div&gt;A&lt;/div&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
            &lt;li&gt;3&lt;/li&gt;
            &lt;div&gt;B&lt;/div&gt;
&lt;/ul&gt;


&lt;body&gt;
        &lt;ul id=&quot;main&quot;&gt;
            &lt;li&gt;1&lt;/li&gt;
            &lt;li&gt;2&lt;/li&gt;
            &lt;li&gt;3&lt;/li&gt;
        &lt;/ul&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
          var main=document.getElementById(&quot;main&quot;);
          var DIV=document.createElement(&quot;div&quot;);
          DIV.innerText=&quot;B&quot;;
          var P=document.createElement(&quot;p&quot;);
          P.innerText=&quot;A&quot;;
          main.appendChild(DIV);
          main.insertBefore(P, main.firstChild);
        &lt;/script&gt;
    &lt;/body&gt;
</code></pre><p>JQuery选择器：</p>
<pre><code>0、常用选择器
$(&apos;#div1&apos;)   //id为div1的节点，如&lt;div id=&apos;div1&apos;&gt;&lt;/div&gt; 

$(&apos;span&apos;)   //所有的span结点，一个包装集
$(&apos;p span&apos;)   //p标签下的所有span节点，后代节点
$(&apos;p&gt;span&apos;)   //p标签下的所有span子节点，子代节点

$(&apos;.red&apos;)  //使用样式red的节点，如&lt;span class=&quot;red&quot;&gt;&lt;/span&gt;

$(&apos;*&apos;)  //所有节点

$(&quot;div,span,p.cls&quot;)  //选取所有&lt;div&gt;，&lt;span&gt;和拥有class为cls的&lt;p&gt;标签的一组元素


1、基本筛选器
$(&apos;span:first&apos;)    //第一个节点
$(&apos;span:last&apos;)     //最后一个节点

$(&quot;td:even&quot;)     //索引为偶数的节点，从 0 开始
$(&quot;td:odd&quot;)      //索引为奇数的节点，从 0 开始

$(&quot;td:eq(1)&quot;)    //给定索引值的节点
$(&quot;td:gt(0)&quot;)    //大于给定索引值的节点
$(&quot;td:lt(2)&quot;)    //小于给定索引值的节点

$(&quot;:focus&quot;)      //当前获取焦点的节点
$(&quot;:animated&quot;)   //正在执行动画效果的节点


2、内容选择器
$(&quot;div:contains(&apos;hello&apos;)&quot;)    //包含hello文本的节点
$(&quot;td:empty&quot;)    //不包含子节点或者文本的空节点
$(&quot;div:has(p)&quot;)  //含有选择器所匹配的节点
$(&quot;td:parent&quot;)   //含有子节点或者文本的节点


3、表单选择器
$(&quot;input:checked&quot;)    //所有选中的节点
$(&quot;select option:selected&quot;)    //select中所有选中的option节点

$(&quot;:input&quot;)      //匹配所有 input, textarea, select 和 button 节点
$(&quot;:text&quot;)       //所有的单行文本框
$(&quot;:password&quot;)   //所有密码框
$(&quot;:radio&quot;)      //所有单选按钮
$(&quot;:checkbox&quot;)   //所有复选框
$(&quot;:submit&quot;)     //所有提交按钮
$(&quot;:reset&quot;)      //所有重置按钮
$(&quot;:button&quot;)     //所有button按钮
$(&quot;:file&quot;)       //所有文件域


4、筛选与查找
$(&quot;p&quot;).eq(0)       //当前操作中第N个jQuery对象,类似索引
$(&apos;li&apos;).first()    //第一个节点
$(&apos;li&apos;).last()     //最后一个节点
$(this).hasClass(&quot;node&quot;)    //节点是否含有某个特定的类,返回布尔值
$(&apos;li&apos;).has(&apos;ul&apos;)  //包含特定后代的节点

$(&quot;div&quot;).children()      //div中的每个子节点,第一层
$(&quot;div&quot;).find(&quot;span&quot;)    //查找div下的所有span节点

$(&quot;p&quot;).next()       　　　//紧邻p节点后的一个同辈节点
$(&quot;p&quot;).nextAll()         //p节点之后所有的同辈节点
$(&quot;#node&quot;).nextUntil(&quot;#node2&quot;)    //id为&quot;#node&quot;节点之后到id为&apos;#node2&apos;之间所有的同辈节点,掐头去尾

$(&quot;p&quot;).prev()            //紧邻p节点前的一个同辈节点
$(&quot;p&quot;).prevAll()         //p节点之前所有的同辈节点
$(&quot;#node&quot;).prevUntil(&quot;#node2&quot;)    //id为&quot;#node&quot;节点之前到id为&apos;#node2&apos;之间所有的同辈节点,掐头去尾

$(&quot;p&quot;).parent()          //每个p节点的父节点
$(&quot;p&quot;).parents()         //每个p节点的所有祖先节点,body,html
$(&quot;#node&quot;).parentsUntil(&quot;#node2&quot;)    //id为&quot;#node&quot;节点到id为&apos;#node2&apos;之间所有的父级节点,掐头去尾

$(&quot;div&quot;).siblings()      //所有的同辈节点,不包括自己


5、属性操作
$(&quot;img&quot;).attr(&quot;src&quot;);    　　　　　　 //返回文档中所有图像的src属性值
$(&quot;img&quot;).attr(&quot;src&quot;,&quot;node.jpg&quot;);    //设置所有图像的src属性
$(&quot;img&quot;).removeAttr(&quot;src&quot;);    　　　//将文档中图像的src属性删除

$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, true);    //选中复选框
$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, false);   //不选中复选框
$(&quot;img&quot;).removeProp(&quot;src&quot;);    　　 //删除img的src属性


6、样式操作
$(&quot;p&quot;).addClass(&quot;selected&quot;);    　　//为p节点加上 &apos;selected&apos; 类
$(&quot;p&quot;).removeClass(&quot;selected&quot;);    //从p节点中删除 &apos;selected&apos; 类
$(&quot;p&quot;).toggleClass(&quot;selected&quot;);    //如果存在就删除,否则就添加HTML代码/文本/值


7、内容操作
$(&apos;p&apos;).html();    　　　　　　　　　　 //返回p节点的html内容
$(&quot;p&quot;).html(&quot;Hello &lt;b&gt;hello&lt;/b&gt;!&quot;);  //设置p节点的html内容
$(&apos;p&apos;).text();    　　　　　　　　　　 //返回p节点的文本内容
$(&quot;p&quot;).text(&quot;hello&quot;);    　　　　　　　//设置p节点的文本内容
$(&quot;input&quot;).val();    　　　　　　　　 //获取文本框中的值
$(&quot;input&quot;).val(&quot;hello&quot;);     　　　　 //设置文本框中的内容


8、CSS操作
$(&quot;p&quot;).css(&quot;color&quot;);          //访问查看p节点的color属性
$(&quot;p&quot;).css(&quot;color&quot;,&quot;red&quot;);    //设置p节点的color属性为red
$(&quot;p&quot;).css({ &quot;color&quot;: &quot;red&quot;, &quot;background&quot;: &quot;yellow&quot; });    //设置p节点的color为red，background属性为yellow（设置多个属性要用{}字典形式）


9、定位与偏移
$(&apos;p&apos;).offset()     //节点在当前视口的相对偏移,对象 {top: 5, left: 9}
$(&apos;p&apos;).offset().top
$(&apos;p&apos;).offset().left
$(&quot;p&quot;).position()   //节点相对父节点的偏移,对可见节点有效，Object {top: 5, left: 8}

$(window).scrollTop()    //获取滚轮滑的高度
$(window).scrollLeft()   //获取滚轮滑的宽度
$(window).scrollTop(&apos;25&apos;)    //设置滚轮滑的高度为25


10、尺寸
$(&quot;p&quot;).height();    //获取p节点的高度
$(&quot;p&quot;).width();     //获取p节点的宽度

$(&quot;p:first&quot;).innerHeight()    //获取第一个匹配节点内部区域高度(包括补白、不包括边框)
$(&quot;p:first&quot;).innerWidth()     //获取第一个匹配节点内部区域宽度(包括补白、不包括边框)

$(&quot;p:first&quot;).outerHeight()    //匹配节点外部高度(默认包括补白和边框)
$(&quot;p:first&quot;).outerWidth()     //匹配节点外部宽度(默认包括补白和边框)
$(&quot;p:first&quot;).outerHeight(true)    //为true时包括边距


11、DOM内部插入
$(&quot;p&quot;).append(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;);    //每个p节点内后面追加内容
$(&quot;p&quot;).appendTo(&quot;div&quot;);    　　　 //p节点追加到div内后
$(&quot;p&quot;).prepend(&quot;&lt;b&gt;Hello&lt;/b&gt;&quot;);  //每个p节点内前面追加内容
$(&quot;p&quot;).prependTo(&quot;div&quot;);    　   //p节点追加到div内前


12、DOM外部插入
$(&quot;p&quot;).after(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;);     //每个p节点同级之后插入内容
$(&quot;p&quot;).before(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;);    //在每个p节点同级之前插入内容
$(&quot;p&quot;).insertAfter(&quot;#node&quot;);     //所有p节点插入到id为node节点的后面
$(&quot;p&quot;).insertBefore(&quot;#node&quot;);    //所有p节点插入到id为node节点的前面


13、DOM替换
$(&quot;p&quot;).replaceWith(&quot;&lt;b&gt;Paragraph. &lt;/b&gt;&quot;);    //将所有匹配的节点替换成指定的HTML或DOM节点
$(&quot;&lt;b&gt;Paragraph. &lt;/b&gt;&quot;).replaceAll(&quot;p&quot;);     //用匹配的节点替换掉所有 selector匹配到的节点


14、DOM删除
$(&quot;p&quot;).empty();     //删除匹配的节点集合中所有的子节点，不包括本身
$(&quot;p&quot;).remove();    //删除所有匹配的节点,包括本身
$(&quot;p&quot;).detach();    //删除所有匹配的节点(和remove()不同的是:所有绑定的事件、附加的数据会保留下来)


15、DOM复制
$(&quot;p&quot;).clone()    　　//克隆节点并选中克隆的副本
$(&quot;p&quot;).clone(true)   //布尔值指事件处理函数是否会被复制


16、DOM加载完成事件
$(document).ready(function(){
  您的代码...
});

//缩写
$(function($) {
  您的代码...
});


17、绑定事件
//bind 为每个匹配节点绑定事件处理函数，绑定多个用{}。
$(&quot;p&quot;).bind(&quot;click&quot;, function(){
  alert( $(this).text() );
});
$(&apos;#div1&apos;).bind({
    &quot;mouseover&quot;:function () {
     $(&apos;#div1&apos;).parent().removeClass(&quot;hide&quot;);
     },&quot;mouseout&quot;:function () {
     $(&apos;#div1&apos;).parent().addClass(&quot;hide&quot;);
}
});         

$(&quot;p&quot;).one( &quot;click&quot;, function(){})    //事件绑定后只会执行一次
$(&quot;p&quot;).unbind( &quot;click&quot; )        //反绑一个事件

// 与bind 不同的是当时间发生时才去临时绑定。
$(&quot;p&quot;).delegate(&quot;click&quot;,function(){
  您的代码
});

$(&quot;p&quot;).undelegate();    　　　//p节点删除由 delegate() 方法添加的所有事件
$(&quot;p&quot;).undelegate(&quot;click&quot;)   //从p节点删除由 delegate() 方法添加的所有click事件

$(&quot;p&quot;).click();    　　//单击事件
$(&quot;p&quot;).dblclick();    //双击事件
$(&quot;input[type=text]&quot;).focus()  //节点获得焦点时,触发 focus 事件
$(&quot;input[type=text]&quot;).blur()   //节点失去焦点时,触发 blur事件
$(&quot;button&quot;).mousedown()//当按下鼠标时触发事件
$(&quot;button&quot;).mouseup()  //节点上放松鼠标按钮时触发事件
$(&quot;p&quot;).mousemove()     //当鼠标指针在指定的节点中移动时触发事件
$(&quot;p&quot;).mouseover()     //当鼠标指针位于节点上方时触发事件
$(&quot;p&quot;).mouseout()    　//当鼠标指针从节点上移开时触发事件
$(window).keydown()    //当键盘或按钮被按下时触发事件
$(window).keypress()   //当键盘或按钮被按下时触发事件,每输入一个字符都触发一次
$(&quot;input&quot;).keyup()     //当按钮被松开时触发事件
$(window).scroll()     //当用户滚动时触发事件
$(window).resize()     //当调整浏览器窗口的大小时触发事件
$(&quot;input[type=&apos;text&apos;]&quot;).change()    //当节点的值发生改变时触发事件
$(&quot;input&quot;).select()    //当input 节点中的文本被选择时触发事件
$(&quot;form&quot;).submit()     //当提交表单时触发事件
$(window).unload()     //用户离开页面时


18、事件对象
$(&quot;p&quot;).click(function(event){  
 alert(event.type); //&quot;click&quot;  
}); 

(evnet object)属性方法：
event.pageX 　 //事件发生时，鼠标距离网页左上角的水平距离
event.pageY 　 //事件发生时，鼠标距离网页左上角的垂直距离
event.type 　　//事件的类型
event.which 　 //按下了哪一个键
event.data 　　//在事件对象上绑定数据，然后传入事件处理函数
event.target 　//事件针对的网页节点
event.preventDefault() 　//阻止事件的默认行为(比如点击链接，会自动打开新页面)
event.stopPropagation()  //停止事件向上层节点冒泡


19、动态事件绑定
 $(&quot;p&quot;).on(&quot;click&quot;,&apos;span&apos;,function(){
alert( $(this).text() );
});
//当p中增加span时仍然有效


20、动画效果
$(&quot;p&quot;).show()    　　　　//显示隐藏的匹配节点
$(&quot;p&quot;).show(&quot;slow&quot;);    //参数表示速度,(&quot;slow&quot;,&quot;normal&quot;,&quot;fast&quot;),也可为600毫秒
$(&quot;p&quot;).hide()    　　　　//隐藏显示的节点
$(&quot;p&quot;).toggle();   　　 //切换 显示/隐藏

$(&quot;p&quot;).slideDown(&quot;600&quot;);    //用600毫秒时间将段落滑下
$(&quot;p&quot;).slideUp(&quot;600&quot;);    　//用600毫秒时间将段落滑上
$(&quot;p&quot;).slideToggle(&quot;600&quot;);  //用600毫秒时间将段落滑上，滑下淡入淡出

$(&quot;p&quot;).fadeIn(&quot;600&quot;);    　　  //用600毫秒时间将段落淡入
$(&quot;p&quot;).fadeOut(&quot;600&quot;);    　　 //用600毫秒时间将段落淡出
$(&quot;p&quot;).fadeToggle(&quot;600&quot;);    　//用600毫秒时间将段落淡入,淡出
$(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.6);    //用600毫秒时间将段落的透明度调整到0.6


21、工具方法
$(&quot;#form1&quot;).serialize()    //序列表表格内容为字符串。
$(&quot;select, :radio&quot;).serializeArray();  //序列化表单元素为数组返回 JSON 数据结构数据
$.trim() 　　//去除字符串两端的空格
$.each() 　　//遍历一个数组或对象，for循环
$.inArray() //返回一个值在数组中的索引位置，不存在返回-1  
$.grep() 　 //返回数组中符合某种标准的节点
$.extend({a:1,b:2},{b:3,c:4},{c:5:d:6})  //将多个对象，合并到第一个对象{a:1,b:3,c:5,d:6}
$.makeArray() //将对象转化为数组
$.type()    //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等
$.isArray() //判断某个参数是否为数组
$.isEmptyObject() //判断某个对象是否为空(不含有任何属性)
$.isFunction()    //判断某个参数是否为函数
$.isPlainObject() //判断某个参数是否为用&quot;{}&quot;或&quot;new Object&quot;建立的对象
$.support()       //判断浏览器是否支持某个特性

22、AJAX
//保存数据到服务器，成功时显示信息
$.ajax({
   type: &quot;POST&quot;,
   url: &quot;some.php&quot;,
   data: &quot;name=John&amp;location=Boston&quot;,
   success: function(msg){
     alert( &quot;Data Saved: &quot; + msg );
   }
});

//加载 feeds.html 文件内容。
$(&quot;#feeds&quot;).load(&quot;feeds.html&quot;);

//请求 test.php 网页，传送2个参数，忽略返回值。
$.get(&quot;test.php&quot;, { name: &quot;John&quot;, time: &quot;2pm&quot; } );

//从 Flickr JSONP API 载入 4 张最新的关于猫的图片。
$.getJSON(&quot;http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;tagmode=any&amp;format
=json&amp;jsoncallback=?&quot;, function(data){
  $.each(data.items, function(i,item){
    $(&quot;&lt;img/&gt;&quot;).attr(&quot;src&quot;, item.media.m).appendTo(&quot;#images&quot;);
    if ( i == 3 ) return false;
  });
});

//加载并执行 test.js ，成功后显示信息
$.getScript(&quot;test.js&quot;, function(){
  alert(&quot;Script loaded and executed.&quot;);
});

//向页面 test.php 发送数据，并输出结果（HTML 或 XML，取决于所返回的内容）：
$.post(&quot;test.php&quot;, { name: &quot;John&quot;, time: &quot;2pm&quot; },
   function(data){
     alert(&quot;Data Loaded: &quot; + data);
   });

//AJAX 请求完成时执行函数。
 $(&quot;#msg&quot;).ajaxComplete(function(event,request, settings){
   $(this).append(&quot;&lt;li&gt;请求完成.&lt;/li&gt;&quot;);
 });

//AJAX 请求失败时显示信息。
$(&quot;#msg&quot;).ajaxError(function(event,request, settings){
     $(this).append(&quot;&lt;li&gt;出错页面:&quot; + settings.url + &quot;&lt;/li&gt;&quot;);
});

//AJAX 请求发送前显示信息。
 $(&quot;#msg&quot;).ajaxSend(function(evt, request, settings){
   $(this).append(&quot;&lt;li&gt;开始请求: &quot; + settings.url + &quot;&lt;/li&gt;&quot;);
 });

 //AJAX 请求开始时显示信息。
 $(&quot;#loading&quot;).ajaxStart(function(){
   $(this).show();
 });

//AJAX 请求结束后隐藏信息。
 $(&quot;#loading&quot;).ajaxStop(function(){
   $(this).hide();
 });

//当 AJAX 请求成功后显示消息。
 $(&quot;#msg&quot;).ajaxSuccess(function(evt, request, settings){
   $(this).append(&quot;&lt;li&gt;请求成功!&lt;/li&gt;&quot;);
 });

//请求前过滤
$.ajaxPrefilter( function( options, originalOptions, jqXHR ) { 
   // Modify options, control originalOptions, store jqXHR, etc 
 });

 //设置全局 AJAX 默认选项，设置 AJAX 请求默认地址为 &quot;/xmlhttp/&quot;，禁止触发全局 AJAX 事件，用 POST 代替默认 GET 方法。其后的 AJAX 请求不再设置任何选项参数。
$.ajaxSetup({
  url: &quot;/xmlhttp/&quot;,
  global: false,
  type: &quot;POST&quot;
});
$.ajax({ data: myData });






JavaScript中巧用位运算
日常前端开发中我们很少用到位运算，容易让人遗忘，让我们一起回顾下一下js中的位运算。
位运算详细说明查看JavaScript|MDN
下面主要回顾一下一些常用的位运算的巧用。
将十进制转化为二进制
var number = 3;
var result = number.toString(2);

var result2 = 14..toString(2); // &quot;1110&quot;


我们使用位运算来代替Math.floor()来向下取整
var data = 2.2352524535;
var result = data | 0; // 2


var re2 = ~~data; // 2

将颜色从RGA转换为Hex格式

var color = {r: 186, g: 218, b: 85};

// RGB to HEX
var rgb2hex = function(r, g, b) {
    return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).substr(1);
}
rgb2hex(color.r, color.g, color.b);//&quot;#bada55&quot;

区分两个数的大小
// variables
var a = 9285;
var b = 3569;

// 取大
var max = a ^ ((a ^ b) &amp; -(a &lt; b));//9285;

// 取小
var min =  b ^ ((a ^ b) &amp; -(a &lt; b);//3569

交换变量
var a = 10;
var b = 99;

a = (b^=a^=b)^a;

console.log(a) // 99
console.log(b) // 10

判断正负
function isPos(n) {
  return (n === (n &gt;&gt;&gt; 0)) ? true : false;  
}
isPos(-1); // false
isPos(1); // true
</code></pre><p>常用函数：</p>
<pre><code>/*========================常用函数========================*/

/*时间格式化*/
Date.prototype.Format = function (fmt) {
    var o = {
        &quot;M+&quot;: this.getMonth() + 1, /*月份*/
        &quot;d+&quot;: this.getDate(), /*日*/
        &quot;h+&quot;: this.getHours(), /*小时*/
        &quot;m+&quot;: this.getMinutes(), /*分*/
        &quot;s+&quot;: this.getSeconds(), /*秒*/
        &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), /*季度*/
        &quot;S&quot;: this.getMilliseconds() /*毫秒*/
    };
    if (/(y+)/.test(fmt))
        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));
    for (var k in o)
        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))
            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));
    return fmt;
};

/*IE浏览器不支持date(time),所以用此方法转换*/
function NewDate(fmt) {
    /*首先将日期分隔 ，获取到日期部分 和 时间部分*/
    var day = fmt.split(&apos; &apos;);
    /*获取日期部分的年月日*/
    var days = day[0].split(&apos;-&apos;);
    /*获取时间部分的 时分秒*/
    var mi = day[day.length - 1].split(&apos;:&apos;);
    /*获取当前date类型日期*/
    var date = new Date();
    /*给date赋值  年月日*/
    date.setUTCFullYear(days[0], days[1] - 1, days[2]);
    /*给date赋值 时分秒  首先转换utc时区 ：+8*/
    date.setUTCHours(mi[0] - 8, mi[1], mi[2]);
    return date;
}

/*为空判断*/
function isEmpty(s) {
    switch (typeof(s)) {
        case &apos;string&apos;:
            return !s.length;
            break;
        case &apos;array&apos;:
        case &apos;object&apos;:
            for (var i in s) return false;
            return true;
            break;
        case &apos;undefined&apos;:
            return true;
            break;
        default:
            return !s;
            break;
    }
}

/*数字判断*/
function isNumber(s) {
    return typeof(s) == &apos;number&apos; ? true : false;
}

/*整数判断*/
function isInt(s) {
    var re = /^-?\d*$/;
    return re.test(s);
}

/*正整数判断*/
function isUInt(s) {
    var re = /^\d*$/;
    return re.test(s) &amp;&amp; s &gt;= 0;
}

/*小数判断*/
function isDecimal(s, bit) {
    if (!arguments[1]) bit = -1;
    if (bit == -1) {
        var re = /^-?\d*.?\d*$/;
        return re.test(s);
    } else {
        var re = new RegExp(&apos;^-?\\d*.?\\d{0,&apos; + bit + &apos;}$&apos;);
        return re.test(s);
    }
}

/*正小数判断*/
function isUDecimal(s, bit) {
    if (!arguments[1]) bit = -1;
    if (bit == -1) {
        var re = /^\d*.?\d*$/;
        return re.test(s) &amp;&amp; s &gt;= 0;
    } else {
        var re = new RegExp(&apos;^\\d*.?\\d{0,&apos; + bit + &apos;}$&apos;);
        return re.test(s) &amp;&amp; s &gt;= 0;
    }
}

/*字符串判断*/
function isString(s) {
    return typeof(s) == &apos;string&apos;;
}

/*========================/常用函数========================*/

js onkeyup replace 自动替换

检测浮点数 只能是整数或者小数 
多余的就replace 掉 的表单验证


function checkFloatNum(obj)
{
    //先把非数字的都替换掉，除了数字和.
    obj.value = obj.value.replace(/[^\d.]/g,&quot;&quot;);
    //必须保证第一个为数字而不是.
    obj.value = obj.value.replace(/^\./g,&quot;&quot;);
    //保证只有出现一个.而没有多个.
    obj.value = obj.value.replace(/\.{2,}/g,&quot;.&quot;);
    //保证.只出现一次，而不能出现两次以上
    obj.value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;);
}
</code></pre><p>解决键盘弹出遮挡：</p>
<pre><code>// 解决键盘弹出后挡表单的问题
        window.addEventListener(&apos;resize&apos;, function() {
            if(
                document.activeElement.tagName === &apos;INPUT&apos; ||
                document.activeElement.tagName === &apos;TEXTAREA&apos;
            ) {
                window.setTimeout(function() {
                    if(&apos;scrollIntoView&apos; in document.activeElement) {
                        document.activeElement.scrollIntoView();
                    } else {
                        document.activeElement.scrollIntoViewIfNeeded();
                    }
                }, 0);
            }
        });
</code></pre><p>单个for循环实现排序：</p>
<pre><code>var a = [12, 13, 65, 54, 86, 21, 37, 1, 95, 4];
var l=a.length;
        for(var i = 0; i &lt; l; i++) {
            if(a[i] &gt; a[i + 1]) {
                var tem = a[i];
                a[i] = a[i + 1];
                a[i + 1] = tem;
            }
            if(i == l - 1) {
                i = -1;
                l--;
            }
        }
        console.log(a);
</code></pre><p>Object.assign实现:</p>
<pre><code>if (!Object.assign) {
    // 定义assign方法
  Object.defineProperty(Object, &apos;assign&apos;, {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target) { // assign方法的第一个参数
      &apos;use strict&apos;;
      // 第一个参数为空，则抛错
      if (target === undefined || target === null) {
        throw new TypeError(&apos;Cannot convert first argument to object&apos;);
      }

      var to = Object(target);
      // 遍历剩余所有参数
      for (var i = 1; i &lt; arguments.length; i++) {
        var nextSource = arguments[i];
        // 参数为空，则跳过，继续下一个
        if (nextSource === undefined || nextSource === null) {
          continue;
        }
        nextSource = Object(nextSource);

        // 获取改参数的所有key值，并遍历
        var keysArray = Object.keys(nextSource);
        for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          // 如果不为空且可枚举，则直接浅拷贝赋值
          if (desc !== undefined &amp;&amp; desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
      return to;
    }
  });
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/03/JS类型判断/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/03/JS类型判断/" itemprop="url">JS类型判断</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-03T22:55:27+08:00">
                2017-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="先看typeof"><a href="#先看typeof" class="headerlink" title="先看typeof"></a>先看typeof</h2><pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;

        &lt;/style&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var a;
            console.log(&quot;1:&quot; + typeof a);
            var b = null;
            console.log(&quot;2:&quot; + typeof b);
            var c = undefined;
            console.log(&quot;3:&quot; + typeof c);
            var d = new Object;
            console.log(&quot;4:&quot; + typeof d);
            var e = function() {};
            console.log(&quot;5:&quot; + typeof e);
            var f = {};
            console.log(&quot;6:&quot; + typeof f);
            var g = &apos;&apos;;
            console.log(&quot;7:&quot; + typeof g);
            var h = [];
            console.log(&quot;8:&quot; + typeof h);
            var i = true;
            console.log(&quot;9:&quot; + typeof i);
            var j = 123;
            console.log(&quot;10:&quot; + typeof j);
            var k = NaN;
            console.log(&quot;11:&quot; + typeof k);
            var l = /^[-+]?\d+$/;
            console.log(&quot;12:&quot; + typeof l);
        &lt;/script&gt;

    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p>按照上面的打印结果,总结出下面要注意的几点</p>
<ul>
<li>typeof (引用类型) 除了函数, 都是 ‘object’,比如 typeof /123/</li>
<li>typeof null 为’object’</li>
<li>typeof undefined 为 ‘undefined’,通常, 如果使用两等号, null == undefined 为真.</li>
<li><p>转换为数字的常见用法 “10”-0或+”10”, 如果没有转换成功,返回NaN,由于NaN 的一个特性: NaN != NaN,故判断转换成功与否的常见做法: (这也是我参见 jQuery的源码发现的,jQuery源码读100遍都不为过)</p>
<p>(“10x” - 0) == (“10x” - 0);<br>// 结果为假!   </p>
</li>
</ul>
<p><img src="https://pic3.zhimg.com/v2-6f58d81de68683e272adaf7c340aa518_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-6f58d81de68683e272adaf7c340aa518_hd.jpg" alt=""></p>
<h2 id="再看看constructor-和-instanceof"><a href="#再看看constructor-和-instanceof" class="headerlink" title="再看看constructor 和 instanceof"></a>再看看constructor 和 instanceof</h2><pre><code>instanceof 用于判断一个变量是否某个对象的实例,或用于判断一个变量是否某个对象的实例；
constructor 用于判断一个变量的原型，constructor 属性返回对创建此对象的数组函数的引用。
Javascript中对象的prototype属性的解释是:返回对象类型原型的引用。
&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log(&quot;----------------Number---------------&quot;);
            var A = 123;
            console.log(A instanceof Number); //false
            console.log(A.constructor == Number); //true
            console.log(A.constructor);
            console.log(&quot;----------------String---------------&quot;);
            var B = &quot;javascript&quot;;
            console.log(B instanceof String); //false
            console.log(B.constructor == String); //true
            console.log(B.constructor);
            console.log(&quot;----------------Boolean---------------&quot;);
            var C = true;
            console.log(C instanceof Boolean); //false
            console.log(C.constructor == Boolean); //true
            console.log(C.constructor);
            console.log(&quot;----------------null---------------&quot;);
            var D = null;
            console.log(D instanceof Object); //false
            //console.log(D.constructor == null); //报错
            //console.log(D.constructor); //报错
            console.log(&quot;----------------undefined---------------&quot;);
            var E = undefined;
            //console.log(E instanceof undefined); // //报错
            //console.log(E.constructor == undefined); //报错
            //console.log(E.constructor); //报错
            console.log(&quot;----------------function---------------&quot;);
            var F = function() {};
            console.log(F instanceof Function);
            console.log(F.constructor == Function);
            console.log(F.constructor);
            console.log(&quot;----------------new function---------------&quot;);
            function SB() {};
            var G = new SB();
            console.log(G instanceof SB);
            console.log(G.constructor == SB);
            console.log(G.constructor);
            console.log(&quot;----------------new Object---------------&quot;);
            var H = new Object;
            console.log(H instanceof Object);
            console.log(H.constructor == Object);
            console.log(H.constructor);
            console.log(&quot;-----------------Array--------------&quot;);
            var I = [];
            console.log(I instanceof Array);
            console.log(I.constructor == Array);
            console.log(I.constructor);
            console.log(&quot;-----------------JSON--------------&quot;);
            var J = {
                &quot;good&quot;: &quot;js&quot;,
                &quot;node&quot;: &quot;very good&quot;
            };
            console.log(J instanceof Object);
            console.log(J.constructor == Object);
            console.log(J.constructor);
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic4.zhimg.com/v2-21d3ca864773ef451c189c0fd954f14a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-21d3ca864773ef451c189c0fd954f14a_hd.jpg" alt=""></p>
<h2 id="再看看-toString-call-obj"><a href="#再看看-toString-call-obj" class="headerlink" title="再看看{}.toString.call(obj)"></a>再看看{}.toString.call(obj)</h2><pre><code>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log({}.toString.call(1));
            console.log({}.toString.call(&quot;11&quot;));
            console.log({}.toString.call(/123/));
            console.log({}.toString.call({}));
            console.log({}.toString.call(function() {}));
            console.log({}.toString.call([]));
            console.log({}.toString.call(true));
            console.log({}.toString.call(new Date()));
            console.log({}.toString.call(new Error()));
            console.log({}.toString.call(null));
            console.log({}.toString.call(undefined));
            console.log(String(null));
            console.log(String(undefined));
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic1.zhimg.com/v2-2d04b5646ab716650f46286dd0be9747_b.jpg" alt=""></p>
<h2 id="使用jQuery中的方法-type"><a href="#使用jQuery中的方法-type" class="headerlink" title="使用jQuery中的方法$.type()"></a>使用jQuery中的方法$.type()</h2><p>现在看看jQuery是怎么做的</p>
<pre><code>// 先申明一个对象,目的是用来做映射
var class2type = {};
// 申明一个core_toString() 的方法,得到最原始的toString() 方法,因为在很多对象中,toStrintg() 已经被重写 
var core_toString() = class2type.toString;
// 这里为 toStrintg() 后的结果和类型名做一个映射,申明一个core_toString() 后的结果,而值就是类型名
jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) {
    class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
});


&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot; /&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            console.log($.type(1));
            console.log($.type(&quot;11&quot;));
            console.log($.type(/123/));
            console.log($.type({}));
            console.log($.type(function() {}));
            console.log($.type([]));
            console.log($.type(true));
            console.log($.type(new Date()));
            console.log($.type(new Error()));
            console.log($.type(null));
            console.log($.type(undefined));
            console.log(String(null));
            console.log(String(undefined));
        &lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-05899b1b3bcf02e58f2eb987ef69594a_b.jpg" alt=""></p>
<p>上面的打印结果与</p>
<pre><code>class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();
</code></pre><p>不谋而合!</p>
<p>这是jQuery.type 的核心方法</p>
<pre><code>type: function( obj ) {
    if ( obj == null ) {
        return String( obj );
    }
    // Support: Safari &lt;= 5.1 (functionish RegExp)
    return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
        class2type[ core_toString.call(obj) ] || &quot;object&quot; :
        typeof obj;
},
</code></pre><blockquote>
<p>注意,为什么把 null 或者 undefined 单独讨论呢,因为 在一些版本浏览器中<br>console.log(core_toString.call(null));<br>console.log(core_toString.call(undefined));</p>
</blockquote>
<pre><code>这是会报错的!


如果是对象类型,另:由于 在一些低版本的浏览器中,typeof /123/ 会返回的是 &quot;function&quot; 而不是 &quot;object&quot;,所以这里要判断是否是函数,要明白 这里的 typeof obj === function 不是为了函数讨论的,因为函数本身就可以通过typeof 来得到类型.

typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?
        class2type[ core_toString.call(obj) ]
</code></pre><p>就直接返回class2type 中键值对的结果,,如果不是,那么一定就是基本类型, 通过 typeof 就可以啦.</p>
<pre><code>class2type[ core_toString.call(obj) ] || &quot;object&quot; :
// 这是防止一些未知情况的,如果未取到,就返回object
</code></pre><h2 id="但是-jQuery-type-有一个很大的缺陷"><a href="#但是-jQuery-type-有一个很大的缺陷" class="headerlink" title="但是 jQuery.type 有一个很大的缺陷"></a>但是 jQuery.type 有一个很大的缺陷</h2><p>这是一个自定义类型</p>
<pre><code>function Person() {
    this.name = &apos;pawn&apos;;
}
var p = new Person();
console.log($.type(p));
console.log({}.toString.call(p));
</code></pre><blockquote>
<p>// 注意,这里会打印 [object Object],通过上面的方法,无法得到精确的自定义类型<br>这也是 它的一个大缺陷了!</p>
</blockquote>
<p><img src="https://pic3.zhimg.com/v2-32ad7e97fff63ad11925460861e4ef9e_b.jpg" alt=""></p>
<p>下面,我们通过构造函数的方式来获取精确类型</p>
<h2 id="通过构造函数来获取类型"><a href="#通过构造函数来获取类型" class="headerlink" title="通过构造函数来获取类型"></a>通过构造函数来获取类型</h2><p>在理解这个方法之前,需要理解两个点</p>
<p>prorotype 原型属性</p>
<pre><code>我们知道,任何对象或者函数都直接或者间接的继承自Object 或者 Function， （其实最终Function 是继承自 Object 的，这属于原型链的知识了，见下图）。那么，任何一个对象都具有原型对象 __proto__ (这个对象只在chrome 和 firefox 暴露，但是在其他浏览器中也是存在的)，这个原型对象就是这个对象的构造函数的原型属性(这里可能有点绕,直接上图).
</code></pre><p><img src="https://pic4.zhimg.com/v2-9a1d9c8359714d86fdac5b90d36547ac_b.jpg" alt=""></p>
<p>由于 任何函数都具有 原型属性prototype,并且这个原型属性具有一个默认属性 constructor,它是这个函数的引用,看下面的代码</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 console.log(Person.prototype.constructor === Person);   //true
</code></pre><p>发现,这两个东西其实一个东西</p>
<p>但是,在某些情况下,需要这么写</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 Person.protype = {
     XX: ... ,
     xx: ... ,
     ...
 }
</code></pre><p>这么做,就会覆盖原本的 protype 方法,那么construcor 就不存在了,这是,必须要显示的申明这个对象，</p>
<h2 id="construction-Person-这句话非常重要，作用是修正this指向"><a href="#construction-Person-这句话非常重要，作用是修正this指向" class="headerlink" title="construction: Person, 这句话非常重要，作用是修正this指向"></a>construction: Person, 这句话非常重要，作用是修正this指向</h2><pre><code>Person.protype = {
     construction: Person,   //这句话的作用是修正this指向
     XX: ... ,
     xx: ... ,
     ...
 }
</code></pre><p>在jQuery的中,就是这么做的,</p>
<pre><code>jQuery.fn = jQuery.prototype = {
   constructor: jQuery,
   init: function( selector, context, rootjQuery ) {
       var match, elem;
</code></pre><blockquote>
<p>关于 jQuery对象封装的方式 也是非常值得研究</p>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-720d122b9b125559f5fb75f2178b25f9_b.jpg" alt=""></p>
<p>注意,这里已经不是熟悉 [object Object],而是 已经重写了.</p>
<p>也就是,如果调用一个函数的toString() 方法.那么就会打印这个函数的函数体.</p>
<p><img src="https://pic3.zhimg.com/v2-b6640c61635718af42b8fb7ce00daf63_b.jpg" alt=""></p>
<p>如何通过构造函数来获得变量的类型?</p>
<p>判断是否是基本类型</p>
<pre><code>var getType = function(obj){
     if(obj == null){
        return String(obj);
     }
     if(typeof obj === &apos;object&apos; || typeof obj === &apos;fucntion&apos;){
         ...
     }else{
         // 如果不是引用类型,那么就是基本类型
         return typeof obj
     }
 }
</code></pre><p>如果是对象或者函数类型</p>
<pre><code>function Person(){
     this.name = &apos;pawn&apos;;
 }
 var p = new Person();
 console.log(p.constructor);   //返回function Person(){...}
</code></pre><p>现在要做的事 : 如何将Person 提取出来呢?<br>毋庸置疑,字符串切割那一套肯定可以办到,但是太 low 啦!<br>这里,我使用正则将Person提取出来</p>
<pre><code>var regex = /function\s(.+?)\(/
function Person(){
  this.name = &apos;pawn&apos;;
 }
 var p = new Person();
 var c = p.constructor
 var regex = /function\s(.+?)\(/;
 console.log(&apos;|&apos; + regex.exec(c)[1] + &apos;|&apos;);
</code></pre><p><img src="https://pic1.zhimg.com/v2-798dac45bc14f57445c3f12c53a95856_b.jpg" alt=""></p>
<p>其实,除了上面的正则,每个函数还有一个name属性,返回函数名,但是ie8 是不支持的.</p>
<p>因此上面的代码可以写为:</p>
<pre><code>var getType = function(obj){
    if(obj == null){
        return String(obj);
    }
    if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){ 
        var constructor = obj.constructor;
        if(constructor &amp;&amp; constructor.name){
            return constructor.name;
        }
        var regex = /function\s(.+?)\(/;
        return regex.exec(c)[1];
    }else{
        // 如果不是引用类型,那么就是基本;类型
        return typeof obj;
    }
};
</code></pre><p>但是上面的代码太丑啦,将其简化</p>
<p>简化</p>
<pre><code>var getType = function(obj){
    if(obj == null){
        return String(obj);
    }
    if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){ 
        return obj.constructor &amp;&amp; obj.constructor.name.toLowerCase() || 
          /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase();
    }else{
        // 如果不是引用类型,那么就是基本类型
        return typeof obj;
    }
};
</code></pre><p>还是比较麻烦,继续简化</p>
<pre><code>var getType = function(obj){
    if(obj == null){
       return String(obj);
    }
    return typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos; ?
      obj.constructor &amp;&amp; obj.constructor.name &amp;&amp; obj.constructor.name.toLowerCase() ||
          /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase():
      typeof obj;
};
</code></pre><p>好了,已经全部弄完了,写个代码测试一下:</p>
<pre><code>function Person(){
    this.name = &apos;pawn&apos;;
}
var p = new Person();

console.log(getType(p));
console.log(getType(1));
console.log(getType(&quot;a&quot;));
console.log(getType(false));
console.log(getType(/123/));
console.log(getType({}));
console.log(getType(function(){}));
console.log(getType(new Date()));
console.log(getType(new Error()));
console.log(getType( null));
console.log(getType( undefined));
</code></pre><p><img src="https://pic2.zhimg.com/v2-45d3c3f08f70b60b05ed1c8885a5ada8_b.jpg" alt=""></p>
<p><img src="https://pic2.zhimg.com/v2-fe845739a4f557bdf52bc85f1e7a2823_b.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-0cb813f94a182e42c1214445bf96abf3_b.jpg" alt=""></p>
<p><img src="https://pic3.zhimg.com/v2-e97820f7d32bab80b31beee769505529_b.jpg" alt=""></p>
<h2 id="1-有时会看到Object-prototype-toString-call"><a href="#1-有时会看到Object-prototype-toString-call" class="headerlink" title="1.有时会看到Object.prototype.toString.call()"></a>1.有时会看到Object.prototype.toString.call()</h2><p><img src="https://pic1.zhimg.com/v2-2c236d4c9534822e61fca4fcab53cf40_b.jpg" alt=""></p>
<h2 id="2-toString-是一个怎样的方法-他定义在哪里？"><a href="#2-toString-是一个怎样的方法-他定义在哪里？" class="headerlink" title="2.toString()是一个怎样的方法,他定义在哪里？"></a>2.toString()是一个怎样的方法,他定义在哪里？</h2><p><img src="https://pic2.zhimg.com/v2-462bb123e83ec081f7fffca86dd9baee_b.jpg" alt=""></p>
<h2 id="3-call-apply-bind可以吗？"><a href="#3-call-apply-bind可以吗？" class="headerlink" title="3.call.apply.bind可以吗？"></a>3.call.apply.bind可以吗？</h2><p><img src="https://pic4.zhimg.com/v2-f396bb49abd0ca789e28d1741aa6360f_b.jpg" alt=""></p>
<h2 id="4-为神马要去call呢？用-Object-prototype-toString-call-obj-而不用-obj-toString-呢？"><a href="#4-为神马要去call呢？用-Object-prototype-toString-call-obj-而不用-obj-toString-呢？" class="headerlink" title="4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？"></a>4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function A(){
                this.say=function(){
                    console.log(&quot;我是1&quot;);
                }
            }
            function B(){
                this.say=function(){
                    console.log(&quot;我是2&quot;);
                }
            }
            var a=new A();
            var b=new B();
            a.say.call(b);    //我是1
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            function A(){
                this.name=&apos;SB&apos;;
                this.say=function(){
                    console.log(&quot;我是1&quot;);
                }
            }
            function B(){
                A.call(this);   //B继承A，重写say方法
                this.say=function(){
                    console.log(&quot;我是2&quot;);
                }
            }
            var a=new A();
            var b=new B();
            console.log(b.name);  //SB
            b.say();         //我是2
            a.say.call(b);    //我是1
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><h2 id="就是怕你重写了toString-所以才要用object-最原始的他toString-所以才去call。"><a href="#就是怕你重写了toString-所以才要用object-最原始的他toString-所以才去call。" class="headerlink" title="就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。"></a>就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。</h2><h2 id="5-Object-prototype-toString方法的原理是什么？"><a href="#5-Object-prototype-toString方法的原理是什么？" class="headerlink" title="5.Object.prototype.toString方法的原理是什么？"></a>5.Object.prototype.toString方法的原理是什么？</h2><p>参考链接：<a href="https://link.zhihu.com/?target=http%3A//www.jb51.net/article/79941.htm" target="_blank" rel="noopener">http://www.jb51.net/article/79941.htm</a></p>
<p>在JavaScript中,想要判断某个对象值属于哪种内置类型,最靠谱的做法就是通过Object.prototype.toString方法.</p>
<p>12var arr = [];console.log(Object.prototype.toString.call(arr)) //“[object Array]”</p>
<p>本文要讲的就是,toString方法是如何做到这一点的,原理是什么.</p>
<p>ECMAScript 3</p>
<p>在ES3中,Object.prototype.toString方法的规范如下:</p>
<p>115.2.4.2 Object.prototype.toString()</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<ol>
<li><p>获取this对象的[[Class]]属性的值.</p>
</li>
<li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串.</p>
</li>
<li><p>返回第二步的操作结果Result(2).</p>
</li>
</ol>
<p>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的</p>
<p>[[Class]]一个字符串值,表明了该对象的类型.</p>
<p>然后给了一段解释:</p>
<p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2).</p>
<p>也就是说,把Object.prototype.toString方法返回的字符串,去掉前面固定的”[object “和后面固定的”]”,就是内部属性[[class]]的值,也就达到了判断对象类型的目的.jQuery中的工具方法$.type(),就是干这个的.</p>
<p>在ES3中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有10种.分别是:”Array”, “Boolean”, “Date”, “Error”, “Function”, “Math”, “Number”, “Object”, “RegExp”, “String”.</p>
<p>ECMAScript 5</p>
<p>在ES5.1中,除了规范写的更详细一些以外,Object.prototype.toString方法和[[class]]内部属性的定义上也有一些变化,Object.prototype.toString方法的规范如下:</p>
<p>15.2.4.2 Object.prototype.toString ( )</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<p>如果this的值为undefined,则返回”[object Undefined]”.</p>
<p>如果this的值为null,则返回”[object Null]”.</p>
<p>让O成为调用ToObject(this)的结果.</p>
<p>让class成为O的内部属性[[Class]]的值.</p>
<p>返回三个字符串”[object “, class, 以及 “]”连接后的新字符串.</p>
<p>可以看出,比ES3多了1,2,3步.第1,2步属于新规则,比较特殊,因为”Undefined”和”Null”并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this的值才会保持undefined或null,非严格模式下会自动成为全局对象).第3步并不算是新规则,因为在ES3的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来.ES5中,[[Class]]属性的解释更加详细:</p>
<p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2).</p>
<p>和ES3对比一下,第一个差别就是[[class]]内部属性的值多了两种,成了12种,一种是arguments对象的[[class]]成了”Arguments”,而不是以前的”Object”,还有就是多个了全局对象JSON,它的[[class]]值为”JSON”.第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这12种值冲突,不过在支持ES3的浏览器中,貌似也没有发现哪些宿主对象故意使用那10个值.</p>
<p>ECMAScript 6</p>
<p>ES6目前还只是工作草案,但能够肯定的是,[[class]]内部属性没有了,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的:</p>
<p>内部属性属性值描述<br>[[NativeBrand]]枚举NativeBrand的一个成员.该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型.</p>
<p>[[NativeBrand]]属性的解释:</p>
<p>[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的ECMAScript原生对象.只有在表10中明确指出的对象类型才有[[NativeBrand]]内部属性.</p>
<p>表10 — [[NativeBrand]]内部属性的值</p>
<p>属性值对应类型<br>NativeFunctionFunction objects<br>NativeArrayArray objects<br>StringWrapperString objects<br>BooleanWrapperBoolean objects<br>NumberWrapperNumber objects<br>NativeMathThe Math object<br>NativeDateDate objects<br>NativeRegExpRegExp objects<br>NativeErrorError objects<br>NativeJSONThe JSON object<br>NativeArgumentsArguments objects<br>NativePrivateNamePrivate Name objects</p>
<p>可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]].同时,Object.prototype.toString方法的规范也改成了下面这样:</p>
<p>15.2.4.2 Object.prototype.toString ( )</p>
<p>在toString方法被调用时,会执行下面的操作步骤:</p>
<p>如果this的值为undefined,则返回”[object Undefined]”.</p>
<p>如果this的值为null,则返回”[object Null]”.</p>
<p>让O成为调用ToObject(this)的结果.</p>
<p>如果O有[[NativeBrand]]内部属性,让tag成为表29中对应的值.</p>
<p>否则</p>
<p>让hasTag成为调用O的[[HasProperty]]内部方法后的结果,参数为@@toStringTag.</p>
<p>如果hasTag为false,则让tag为”Object”.</p>
<p>否则,</p>
<p>让tag成为调用O的[[Get]]内部方法后的结果,参数为@@toStringTag.</p>
<p>如果tag是一个abrupt completion,则让tag成为NormalCompletion(“???”).</p>
<p>让tag成为tag.[[value]].</p>
<p>如果Type(tag)不是字符串,则让tag成为”???”.</p>
<p>如果tag的值为”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”,或</p>
<p>者”String”中的任一个,则让tag成为字符串”~”和tag当前的值连接后的结果.</p>
<p>返回三个字符串”[object “, tag, and “]”连接后的新字符串.</p>
<p>表29 — [[NativeBrand]] 标志值</p>
<p>[[NativeBrand]]值标志值<br>NativeFunction”Function”<br>NativeArray”Array”<br>StringWrapper”String”<br>BooleanWrapper”Boolean”<br>NumberWrapper”Number”<br>NativeMath”Math”<br>NativeDate”Date”<br>NativeRegExp”RegExp”<br>NativeError”Error”<br>NativeJSON”JSON”<br>NativeArguments”Arguments”</p>
<p>可以看到,在规范上有了很大的变化,不过对于普通用户来说,貌似感觉不到.</p>
<p>也许你发现了,ES6里的新类型Map,Set等,都没有在表29中.它们在执行toString方法的时候返回的是什么?</p>
<p>console.log(Object.prototype.toString.call(Map())) //“[object Map]”</p>
<p>console.log(Object.prototype.toString.call(Set())) //“[object Set]”</p>
<p>其中的字符串”Map”是怎么来的呢:</p>
<p>15.14.5.13 Map.prototype.@@toStringTag</p>
<p>@@toStringTag 属性的初始值为字符串”Map”.</p>
<p>由于ES6的规范还在制定中,各种相关规定都有可能改变,所以如果想了解更多细节.看看下面这两个链接,现在只需要知道的是:[[class]]没了,使用了更复杂的机制.</p>
<p>以上所述是小编给大家分享的JavaScript中Object.prototype.toString方法的原理，希望对大家有所帮助！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/02/JavaScript核武库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/02/JavaScript核武库/" itemprop="url">JavaScript核武库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-02T16:24:04+08:00">
                2017-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下是个人总结，也有一些是copy大神的，现在放到一起，方便以后查阅（有不对的地方，还望大家能够提出，我会尽快加以改正）。</p>
<h2 id="强制转boolean"><a href="#强制转boolean" class="headerlink" title="!!强制转boolean"></a>!!强制转<code>boolean</code></h2><p>根据真值，假值 判断，返回<code>true</code>，<code>false</code>假值：  0     “”  null   undefined  false NaN</p>
<pre><code>例如：
var nu=null;
var nul=&quot;&quot;;
var str=&quot;abcd&quot;;

console.log(!!nu)     // false;
console.log(!!nul)    // false;
console.log(!!str)    // true;
</code></pre><h2 id="obj-强制转Number"><a href="#obj-强制转Number" class="headerlink" title="+obj 强制转Number"></a>+obj 强制转<code>Number</code></h2><p> 将对象强制转<code>number</code>,如果是纯数字的“88”字符串，可转为<code>number</code></p>
<pre><code>var a=&quot;88&quot;;
console.log(+a)   =&gt;88
//但是如果是混合类型的字符串，则会转为NaN
var b=&quot;1606e&quot;;
console.log(+b)  =&gt; NaN
</code></pre><h2 id="强制取整"><a href="#强制取整" class="headerlink" title="~~ 强制取整"></a>~~ 强制取整</h2><pre><code>~~ 12.34
 12
~~ 12.88
 12
</code></pre><h2 id="不可靠的undefined-可靠的void-0"><a href="#不可靠的undefined-可靠的void-0" class="headerlink" title="不可靠的undefined 可靠的void 0"></a>不可靠的<code>undefined</code> 可靠的<code>void 0</code></h2><p>在<code>JavaScript</code>中，假设我们想判断一个是否是 <code>undefined</code>，那么我们通常会这样写：</p>
<pre><code>if(a === undefined){
  dosomething
}
</code></pre><p>//但是在<code>javascript</code>中，<code>undefined</code>是不可靠的</p>
<p>例如：<br>当undefined在函数内，并且是在局部变量是可以赋上值</p>
<pre><code>function foo2(){
 var undefined=1;
 console.log(undefined)
}
foo2();  =&gt;1;
</code></pre><p>但是当在函数内定义一个全局变量，并不能给赋上值</p>
<pre><code>var undefined;
function foo2(){
undefined=1;
 console.log(undefined)
}
foo2()  // undefined
void 0或者 void (0)：
</code></pre><p>最常见的用法是通过<code>void 0</code> 运算来获得 <code>undefined</code>，表达式为 0 时的运算开销最小：<br>那在以后需要判断值为<code>undefined</code>的时候，可以直接用<code>void 0</code>或者<code>void (0)</code></p>
<h2 id="字符串也是有length属性的！"><a href="#字符串也是有length属性的！" class="headerlink" title="字符串也是有length属性的！"></a>字符串也是有<code>length</code>属性的！</h2><p>我们知道所有的<code>array</code>都是有<code>length</code>,属性，就算事空数组，<code>length</code> 是0，那么字符串有没有呢？接下来我们来验证一下：</p>
<pre><code>var str=&quot;sdfsd5565s6dfsd65sd6+d5fd5&quot;;
console.log(str.length)      // 26
</code></pre><p>结果是有的，所以我们在判断类型时，不能单纯拿有没有<code>length</code>属性来判断是不是数组了，我们可以用下面的方法：</p>
<pre><code>var obj=[1,2] ;
console.log(toString.call(obj) === &apos;[object Array]&apos;);
</code></pre><h2 id="生成一个随机数组-创建数组，sort排序"><a href="#生成一个随机数组-创建数组，sort排序" class="headerlink" title="生成一个随机数组(创建数组，sort排序)"></a>生成一个随机数组(创建数组，<code>sort</code>排序)</h2><p>在项目中有时候我们需要一个随机打乱的数组，那么下面我们来实现以下：<br>先来创建一个数组：</p>
<pre><code>var arr=[];
for(var i=0;i&lt;10;i++){
   arr.push(i)
}
console.log(arr)    //  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre><p>接下来我们来打乱它：</p>
<pre><code>arr.sort(()=&gt;{
 return Math.random() - 0.5
})                 // [1, 0, 2, 3, 4, 6, 8, 5, 7, 9] 
</code></pre><p>第二种打乱方法：</p>
<pre><code>arr.sort((a,b)=&gt;{
　　　return a&gt;Math.random()*10;
})               //  [1, 2, 0, 6, 4, 3, 8, 9, 7, 5]
</code></pre><p>我们以前的正常排序是这样的：</p>
<pre><code>arr.sort(function(a,b){
   return b-a
});
</code></pre><p>解析：<br>先说正常的排序：<br>a,b表示数组中的任意两个元素，若<code>return &gt; 0</code> b前a后；<code>reutrn &lt; 0</code> a前b后；<code>a=b</code>时存在浏览器兼容 ，<br><code>a-b</code>输出从小到大排序，<code>b-a</code>输出从大到小排序。<br>然后再说我们打乱的方法：<br>创建数组不用说，接下来就是用js的sort方法 来实现，<code>Math.random()</code>实现一个随机<code>0-1</code>之间的小数 然后再减去<code>0.5</code>，这时就会根据return比较后得到的值排，所以说就会生成不是正常从大到小或者从小到大的排序。</p>
<p>第二个打乱的方法同样是遵循<code>sort</code>的方法，将<code>a,b</code>传进去 然后和随机数做比较，关于比较的方法不太清楚。</p>
<h2 id="去除前后、前、后-所有空格"><a href="#去除前后、前、后-所有空格" class="headerlink" title="去除前后、前、后 所有空格"></a>去除前后、前、后 所有空格</h2><p> 这是专门为去除空格写的一套方法，适用于各种情况，所有空格,前后空格，前空格，后空格。</p>
<p>var strr=”    1 ad dertasdf sdfASDFDF DFG SDFG    “<br>//  type 1-所有空格  2-前后空格  3-前空格 4-后空格</p>
<pre><code>function trim(str,type){
    switch (type){
        case 1:return str.replace(/\s+/g,&quot;&quot;);
        case 2:return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
        case 3:return str.replace(/(^\s*)/g, &quot;&quot;);
        case 4:return str.replace(/(\s*$)/g, &quot;&quot;);
        default:return str;
    }
}
console.log( trim(strr,1))      //  &quot;1addertasdfsdfASDFDFDFGSDFG&quot;
</code></pre><p>解析：<br>  这个方法用的是正则的匹配格式,后面我会把正则单独拿出来总结一个系列，敬请期待！！！</p>
<pre><code>\s ： 空格符，Tab,换页符，换行符
  \S ： 非\s的所有内容
  /g :  全局匹配
  ^  :  匹配在行首
  $  :  匹配在行尾
  +  ： 重复次数&gt;0
  *  ： 重复次数&gt;=0
  |  :  或者
</code></pre><p><code>replace(a,b)</code>： 方法用于在字符创中用一些字符替换另一些字符, 会传入两个值，将逗号前面的值<code>a</code>替换成逗号后面的值<code>b</code></p>
<h2 id="字母大小写切换（正则匹配，replace）"><a href="#字母大小写切换（正则匹配，replace）" class="headerlink" title="字母大小写切换（正则匹配，replace）"></a>字母大小写切换（正则匹配，<code>replace</code>）</h2><p>这个方法主要是给一些需要大小写转换提供的方法，主要有首字母大写，首字母小写，大小写转换，全部转大写和全部转小写。</p>
<pre><code>type：
　　1:首字母大写
　　2：首页母小写
　　3：大小写转换
　　4：全部大写
　　5：全部小写
</code></pre><p>原始字符串：</p>
<pre><code>var str=&quot;sdfwwerasfddffddeerAasdgFegqer&quot;;

function changeCase(str,type) {

   //这个函数是第三个大小写转换的方法
    function ToggleCase(str) {
        var itemText = &quot;&quot;
        str.split(&quot;&quot;).forEach(
                function (item) {
                 // 判断循环字符串中每个字符是否以a-z之间开头的并且重复大于0次
                    if (/^([a-z]+)/.test(item)) {
                    //  如果是小写，转换成大写
                        itemText += item.toUpperCase();
                    }
                //  判断循环字符串中每个字符是否以A-Z之间开头的并且重复大于0次
                    else if (/^([A-Z]+)/.test(item)) {
                   //   如果是大写，转换成小写
                        itemText += item.toLowerCase();
                    }
                    else{
                  //  如果都不符合，返回其本身
                        itemText += item;
                    }
                });
        return itemText;
    }
  //下面主要根据传入的type值来匹配各个场景
    switch (type) {
         //当匹配
        case 1:
            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {
                 //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer
                return v1.toUpperCase() + v2.toLowerCase();
            });
        case 2:
            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {
                //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer
                return v1.toLowerCase() + v2.toUpperCase();
            });
        case 3:
            return ToggleCase(str);
        case 4:
            return str.toUpperCase();
        case 5:
            return str.toLowerCase();
        default:
            return str;
    }

}

 console.log(changeCase(str,1)) =&gt;SdfwwerasfddffddeerAasdgFegqer
</code></pre><p>解析：</p>
<pre><code>split：用于把一个字符串分割成字符串数组
\w: 数字0-9或字母a-z及A-Z,或下划线
\W: 非\w，除以上的特殊符号等   
toUpperCase：转大写
toLowerCase：转小写
replace第二个参数可以是函数，函数的参数中，第一个是本身，第二个是正则匹配内容，第三个匹配剩下的内容
</code></pre><p>下面我们就通过小实验来验证一下：<br>网上有说replace是可以有4个参数的，但是我并没有验证到第四个代表的意义，前三个已经验证，第一个参数为验证本身，第二个正则匹配结果，第三为第二个匹配完剩下的值。</p>
<h2 id="循环n次传入的字符串str为传入随意字符串，count为循环的次数"><a href="#循环n次传入的字符串str为传入随意字符串，count为循环的次数" class="headerlink" title="循环n次传入的字符串str为传入随意字符串，count为循环的次数"></a>循环n次传入的字符串<code>str</code>为传入随意字符串，<code>count</code>为循环的次数</h2><pre><code>var str=&quot;abc&quot;;
 var number=555;

function repeatStr(str, count) {
    //声明一个空字符串，用来保存生成后的新字符串
    var text = &apos;&apos;;
    //循环传入的count值，即循环的次数
    for (var i = 0; i &lt; count; i++) {
       //循环一次就把字符串+到我们事先准备好的空字符串上
        text += str;
    }
    return text;
}

  console.log(repeatStr(str, 3))         // &quot;abcabcabc&quot;

  console.log(repeatStr(number, 3))      // &quot;555555555&quot;
</code></pre><p>解析：根据count循环的次数，在循环体内复制，return 返回+=后的值</p>
<h2 id="查找字符串的A内容替换成B内容"><a href="#查找字符串的A内容替换成B内容" class="headerlink" title="查找字符串的A内容替换成B内容"></a>查找字符串的A内容替换成B内容</h2><pre><code>let str=&quot;abacdasdfsd&quot; function replaceAll(str,AFindText,ARepText){
   raRegExp = new RegExp(AFindText,&quot;g&quot;);
   return str.replace(raRegExp,ARepText);
}
console.log(replaceAll(str,&quot;a&quot;,&quot;x&quot;))  // xbxcdxsdfsd
str：需要编辑的字符串本身
AFindText:需要替换的内容
ARepText:被替换成的内容
</code></pre><p>解析：创建正则，匹配内容，替换</p>
<h2 id="检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"><a href="#检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证" class="headerlink" title="检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"></a>检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证</h2><pre><code>function checkType (str, type) {
    switch (type) {
        case &apos;email&apos;:
            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);
        case &apos;phone&apos;:
            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);
        case &apos;tel&apos;:
            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);
        case &apos;number&apos;:
            return /^[0-9]$/.test(str);
        case &apos;english&apos;:
            return /^[a-zA-Z]+$/.test(str);
        case &apos;chinese&apos;:
            return /^[\u4E00-\u9FA5]+$/.test(str);
        case &apos;lower&apos;:
            return /^[a-z]+$/.test(str);
        case &apos;upper&apos;:
            return /^[A-Z]+$/.test(str);
        default :
            return true;
    }
}
console.log(checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;))   //false
</code></pre><p>解析：</p>
<pre><code>checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;)&apos;需要验证的字符串&apos;，&apos;匹配的格式&apos;
email：验证邮箱
phone：验证手机号
tel：验证座机号
number：验证数字
english：验证英文字母
chinese：验证中文字
lower：验证小写
upper：验证大写
</code></pre><p>JS返回浏览器历史第一页：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//www.xiejiahe.com/detail/5a18f8f5c7431c02ef43bca9" target="_blank" rel="noopener">JS返回浏览器历史第一页</a></p>
<p>我在浏览器控制台敲了 window.history 其实我想看看还有哪些API，他输出了以下信息，我看到length 这个属性让我眼前一亮，其他2个我不关心。</p>
<pre><code>{
    length: 2,
    scrollRestoration: &quot;auto&quot;,
    state: null
}
</code></pre><p>我尝试用length 去回退， 不成功！</p>
<pre><code>window.history.go(-2);
</code></pre><p>我再尝试用length去减1, 成功了， 我猜应该是跟新标签页有关吧。 那我不管了，我已经有答案了</p>
<pre><code>window.history.go(-1);
</code></pre><p>最后代码</p>
<pre><code>var historyLen = window.history;
window.history.go(-(historyLen - 1));
</code></pre><p>测试了3个浏览器， 都是第一次打开浏览器测试</p>
<pre><code>Chrome 会直接返回到新标签页
Safari 我这里测试是返回到百度，可能是我的设置问题
Firefox 直接关闭浏览器 
</code></pre><p>作为战斗在业务一线的前端，要想少加班，就要想办法提高工作效率。这里提一个小点，我们在业务开发过程中，经常会重复用到<code>日期格式化</code>、<code>url参数转对象</code>、<code>浏览器类型判断</code>、<code>节流函数</code>等一类函数，这些工具类函数，基本上在每个项目都会用到，为避免不同项目多次复制粘贴的麻烦，我们可以统一封装，发布到<code>npm</code>，以提高开发效率。</p>
<p>这里，笔者已经封装并发布了自己的武器库 <a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener">outils</a>，如果你对本项目感兴趣，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。当然你也可以在本项目的基础上封装自己的武器库。</p>
<p>常用函数汇总</p>
<h2 id="这里先分类整理下，之前项目中多次用到的工具函数。"><a href="#这里先分类整理下，之前项目中多次用到的工具函数。" class="headerlink" title="这里先分类整理下，之前项目中多次用到的工具函数。"></a>这里先分类整理下，之前项目中多次用到的工具函数。</h2><h2 id="1-Array"><a href="#1-Array" class="headerlink" title="1.Array"></a>1.Array</h2><h2 id="1-1-arrayEqual"><a href="#1-1-arrayEqual" class="headerlink" title="1.1 arrayEqual"></a>1.1 arrayEqual</h2><pre><code>/**
 * 
 * @desc 判断两个数组是否相等
 * @param {Array} arr1 
 * @param {Array} arr2 
 * @return {Boolean}
 */ function arrayEqual(arr1, arr2) {
    if (arr1 === arr2) return true;
    if (arr1.length != arr2.length) return false;
    for (var i = 0; i &lt; arr1.length; ++i) {
        if (arr1[i] !== arr2[i]) return false;
    }
    return true;
}
</code></pre><h2 id="2-Class"><a href="#2-Class" class="headerlink" title="2.Class"></a>2.Class</h2><h2 id="2-1-addClass"><a href="#2-1-addClass" class="headerlink" title="2.1 addClass"></a>2.1 addClass</h2><pre><code>/**
 * 
 * @desc   为元素添加class
 * @param  {HTMLElement} ele 
 * @param  {String} cls 
 */ 
var hasClass = require(&apos;./hasClass&apos;);
function addClass(ele, cls) {
    if (!hasClass(ele, cls)) {
        ele.className += &apos; &apos; + cls;
    }
}
</code></pre><p>2.2 hasClass</p>
<pre><code>/**
 * 
 * @desc 判断元素是否有某个class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 * @return {Boolean}
 */ 
function hasClass(ele, cls) {
    return (new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;)).test(ele.className);
}
</code></pre><p>2.3 removeClass</p>
<pre><code>/**
 * 
 * @desc 为元素移除class
 * @param {HTMLElement} ele 
 * @param {String} cls 
 */ 
var hasClass = require(&apos;./hasClass&apos;);
function removeClass(ele, cls) {
    if (hasClass(ele, cls)) {
        var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;);
        ele.className = ele.className.replace(reg, &apos; &apos;);
    }
}
</code></pre><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h2><h2 id="3-1-getCookie"><a href="#3-1-getCookie" class="headerlink" title="3.1 getCookie"></a>3.1 getCookie</h2><pre><code>/**
 * 
 * @desc 根据name读取cookie
 * @param  {String} name 
 * @return {String}
 */ 
function getCookie(name) {
    var arr = document.cookie.replace(/\s/g, &quot;&quot;).split(&apos;;&apos;);
    for (var i = 0; i &lt; arr.length; i++) {
        var tempArr = arr[i].split(&apos;=&apos;);
        if (tempArr[0] == name) {
            return decodeURIComponent(tempArr[1]);
        }
    }
    return &apos;&apos;;
}
</code></pre><p>3.2 removeCookie</p>
<pre><code>var setCookie = require(&apos;./setCookie&apos;);
/**
 * 
 * @desc 根据name删除cookie
 * @param  {String} name 
 */
 function removeCookie(name) {
    // 设置已过期，系统会立刻删除cookie
    setCookie(name, &apos;1&apos;, -1);
}
</code></pre><p>3.3 setCookie</p>
<pre><code>/**
 * 
 * @desc  设置Cookie
 * @param {String} name 
 * @param {String} value 
 * @param {Number} days 
 */ 
function setCookie(name, value, days) {
    var date = new Date();
    date.setDate(date.getDate() + days);
    document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + date;
}
</code></pre><h2 id="4-Device"><a href="#4-Device" class="headerlink" title="4.Device"></a>4.Device</h2><h2 id="4-1-getExplore"><a href="#4-1-getExplore" class="headerlink" title="4.1 getExplore"></a>4.1 getExplore</h2><pre><code>/**
 * 
 * @desc 获取浏览器类型和版本
 * @return {String} 
 */ 
function getExplore() {
    var sys = {},
        ua = navigator.userAgent.toLowerCase(),
        s;
    (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:
        (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :
        (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :
        (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :
        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :
        (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :
        (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;
    // 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie)
    if (sys.edge) return (&apos;EDGE: &apos; + sys.edge)
    if (sys.firefox) return (&apos;Firefox: &apos; + sys.firefox)
    if (sys.chrome) return (&apos;Chrome: &apos; + sys.chrome)
    if (sys.opera) return (&apos;Opera: &apos; + sys.opera)
    if (sys.safari) return (&apos;Safari: &apos; + sys.safari)
    return &apos;Unkonwn&apos;
}
</code></pre><p>4.2 getOS</p>
<pre><code>/**
 * 
 * @desc 获取操作系统类型
 * @return {String} 
 */ 
function getOS() {
    var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;;
    var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;;
    var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;;

    if (/mac/i.test(appVersion)) return &apos;MacOSX&apos; if (/win/i.test(appVersion)) return &apos;windows&apos; if (/linux/i.test(appVersion)) return &apos;linux&apos; if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos; if (/android/i.test(userAgent)) return &apos;android&apos; if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos;
}
</code></pre><h2 id="5-Dom"><a href="#5-Dom" class="headerlink" title="5.Dom"></a>5.Dom</h2><h2 id="5-1-getScrollTop"><a href="#5-1-getScrollTop" class="headerlink" title="5.1 getScrollTop"></a>5.1 getScrollTop</h2><pre><code>/**
 * 
 * @desc 获取滚动条距顶部的距离
 */ 
function getScrollTop() {
    return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;
}
</code></pre><p>5.2 offset</p>
<pre><code>/**
 * 
 * @desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset()
 * @param {HTMLElement} ele 
 * @returns { {left: number, top: number} }
 */ 
function offset(ele) {
    var pos = {
        left: 0,
        top: 0
    };
    while (ele) {
        pos.left += ele.offsetLeft;
        pos.top += ele.offsetTop;
        ele = ele.offsetParent;
    };
    return pos;
}
</code></pre><h2 id="5-3-scrollTo"><a href="#5-3-scrollTo" class="headerlink" title="5.3 scrollTo"></a>5.3 scrollTo</h2><pre><code>var getScrollTop = require(&apos;./getScrollTop&apos;);
var setScrollTop = require(&apos;./setScrollTop&apos;);
var requestAnimFrame = (function () {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (callback) {
            window.setTimeout(callback, 1000 / 60);
        };
})();
/**
 * 
 * @desc  在${duration}时间内，滚动条平滑滚动到${to}指定位置
 * @param {Number} to 
 * @param {Number} duration 
 */ 
function scrollTo(to, duration) {
    if (duration &lt; 0) {
        setScrollTop(to);
        return
    }
    var diff = to - getScrollTop();
    if (diff === 0) return var step = diff / duration * 10;
    requestAnimationFrame(
        function () {
            if (Math.abs(step) &gt; Math.abs(diff)) {
                setScrollTop(getScrollTop() + diff);
                return;
            }
            setScrollTop(getScrollTop() + step);
            if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) {
                return;
            }
            scrollTo(to, duration - 16);
        });
}
</code></pre><h2 id="5-4-setScrollTop"><a href="#5-4-setScrollTop" class="headerlink" title="5.4 setScrollTop"></a>5.4 setScrollTop</h2><pre><code>/**
 * 
 * @desc 设置滚动条距顶部的距离
 */ 
function setScrollTop(value) {
    window.scrollTo(0, value);
    return value;
}
</code></pre><h2 id="6-Keycode"><a href="#6-Keycode" class="headerlink" title="6.Keycode"></a>6.Keycode</h2><h2 id="6-1-getKeyName"><a href="#6-1-getKeyName" class="headerlink" title="6.1 getKeyName"></a>6.1 getKeyName</h2><pre><code>var keyCodeMap = {
    8: &apos;Backspace&apos;,
    9: &apos;Tab&apos;,
    13: &apos;Enter&apos;,
    16: &apos;Shift&apos;,
    17: &apos;Ctrl&apos;,
    18: &apos;Alt&apos;,
    19: &apos;Pause&apos;,
    20: &apos;Caps Lock&apos;,
    27: &apos;Escape&apos;,
    32: &apos;Space&apos;,
    33: &apos;Page Up&apos;,
    34: &apos;Page Down&apos;,
    35: &apos;End&apos;,
    36: &apos;Home&apos;,
    37: &apos;Left&apos;,
    38: &apos;Up&apos;,
    39: &apos;Right&apos;,
    40: &apos;Down&apos;,
    42: &apos;Print Screen&apos;,
    45: &apos;Insert&apos;,
    46: &apos;Delete&apos;,

    48: &apos;0&apos;,
    49: &apos;1&apos;,
    50: &apos;2&apos;,
    51: &apos;3&apos;,
    52: &apos;4&apos;,
    53: &apos;5&apos;,
    54: &apos;6&apos;,
    55: &apos;7&apos;,
    56: &apos;8&apos;,
    57: &apos;9&apos;,

    65: &apos;A&apos;,
    66: &apos;B&apos;,
    67: &apos;C&apos;,
    68: &apos;D&apos;,
    69: &apos;E&apos;,
    70: &apos;F&apos;,
    71: &apos;G&apos;,
    72: &apos;H&apos;,
    73: &apos;I&apos;,
    74: &apos;J&apos;,
    75: &apos;K&apos;,
    76: &apos;L&apos;,
    77: &apos;M&apos;,
    78: &apos;N&apos;,
    79: &apos;O&apos;,
    80: &apos;P&apos;,
    81: &apos;Q&apos;,
    82: &apos;R&apos;,
    83: &apos;S&apos;,
    84: &apos;T&apos;,
    85: &apos;U&apos;,
    86: &apos;V&apos;,
    87: &apos;W&apos;,
    88: &apos;X&apos;,
    89: &apos;Y&apos;,
    90: &apos;Z&apos;,

    91: &apos;Windows&apos;,
    93: &apos;Right Click&apos;,

    96: &apos;Numpad 0&apos;,
    97: &apos;Numpad 1&apos;,
    98: &apos;Numpad 2&apos;,
    99: &apos;Numpad 3&apos;,
    100: &apos;Numpad 4&apos;,
    101: &apos;Numpad 5&apos;,
    102: &apos;Numpad 6&apos;,
    103: &apos;Numpad 7&apos;,
    104: &apos;Numpad 8&apos;,
    105: &apos;Numpad 9&apos;,
    106: &apos;Numpad *&apos;,
    107: &apos;Numpad +&apos;,
    109: &apos;Numpad -&apos;,
    110: &apos;Numpad .&apos;,
    111: &apos;Numpad /&apos;,

    112: &apos;F1&apos;,
    113: &apos;F2&apos;,
    114: &apos;F3&apos;,
    115: &apos;F4&apos;,
    116: &apos;F5&apos;,
    117: &apos;F6&apos;,
    118: &apos;F7&apos;,
    119: &apos;F8&apos;,
    120: &apos;F9&apos;,
    121: &apos;F10&apos;,
    122: &apos;F11&apos;,
    123: &apos;F12&apos;,

    144: &apos;Num Lock&apos;,
    145: &apos;Scroll Lock&apos;,
    182: &apos;My Computer&apos;,
    183: &apos;My Calculator&apos;,
    186: &apos;;&apos;,
    187: &apos;=&apos;,
    188: &apos;,&apos;,
    189: &apos;-&apos;,
    190: &apos;.&apos;,
    191: &apos;/&apos;,
    192: &apos;`&apos;,
    219: &apos;[&apos;,
    220: &apos;\\&apos;,
    221: &apos;]&apos;,
    222: &apos;\&apos;&apos;
};
/**
 * @desc 根据keycode获得键名
 * @param  {Number} keycode 
 * @return {String}
 */ 
function getKeyName(keycode) {
    if (keyCodeMap[keycode]) {
        return keyCodeMap[keycode];
    } else {
        console.log(&apos;Unknow Key(Key Code:&apos; + keycode + &apos;)&apos;);
        return &apos;&apos;;
    }
};
</code></pre><h2 id="7-Object"><a href="#7-Object" class="headerlink" title="7.Object"></a>7.Object</h2><h2 id="7-1-deepClone"><a href="#7-1-deepClone" class="headerlink" title="7.1 deepClone"></a>7.1 deepClone</h2><pre><code>/**
 * @desc 深拷贝，支持常见类型
 * @param {Any} values
 */ 
function deepClone(values) {
    var copy;

    // Handle the 3 simple types, and null or undefined if (null == values || &quot;object&quot; != typeof values) return values;

    // Handle Date if (values instanceof Date) {
        copy = new Date();
        copy.setTime(values.getTime());
        return copy;
    }

    // Handle Array if (values instanceof Array) {
        copy = [];
        for (var i = 0, len = values.length; i &lt; len; i++) {
            copy[i] = deepClone(values[i]);
        }
        return copy;
    }

    // Handle Object if (values instanceof Object) {
        copy = {};
        for (var attr in values) {
            if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);
        }
        return copy;
    }

    throw new Error(&quot;Unable to copy values! Its type isn&apos;t supported.&quot;);
}
</code></pre><h2 id="7-2-isEmptyObject"><a href="#7-2-isEmptyObject" class="headerlink" title="7.2 isEmptyObject"></a>7.2 isEmptyObject</h2><pre><code>/**
 * 
 * @desc   判断`obj`是否为空
 * @param  {Object} obj
 * @return {Boolean}
 */ 
function isEmptyObject(obj) {
    if (!obj || typeof obj !== &apos;object&apos; || Array.isArray(obj))
        return false return !Object.keys(obj).length
}
</code></pre><h2 id="8-Random"><a href="#8-Random" class="headerlink" title="8.Random"></a>8.Random</h2><h2 id="8-1-randomColor"><a href="#8-1-randomColor" class="headerlink" title="8.1 randomColor"></a>8.1 randomColor</h2><pre><code>/**
 * 
 * @desc 随机生成颜色
 * @return {String} 
 */ 
function randomColor() {
    return &apos;#&apos; + (&apos;00000&apos; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);
}
</code></pre><h2 id="8-2-randomNum"><a href="#8-2-randomNum" class="headerlink" title="8.2 randomNum"></a>8.2 randomNum</h2><pre><code>/**
 * 
 * @desc 生成指定范围随机数
 * @param  {Number} min 
 * @param  {Number} max 
 * @return {Number} 
 */ 
function randomNum(min, max) {
    return Math.floor(min + Math.random() * (max - min));
}
</code></pre><h2 id="9-Regexp"><a href="#9-Regexp" class="headerlink" title="9.Regexp"></a>9.Regexp</h2><h2 id="9-1-isEmail"><a href="#9-1-isEmail" class="headerlink" title="9.1 isEmail"></a>9.1 isEmail</h2><pre><code>/**
 * 
 * @desc   判断是否为邮箱地址
 * @param  {String}  str
 * @return {Boolean} 
 */ 
function isEmail(str) {
    return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str);
}
</code></pre><h2 id="9-2-isIdCard"><a href="#9-2-isIdCard" class="headerlink" title="9.2 isIdCard"></a>9.2 isIdCard</h2><pre><code>/**
 * 
 * @desc  判断是否为身份证号
 * @param  {String|Number} str 
 * @return {Boolean}
 */ 
function isIdCard(str) {
    return /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/.test(str)
}
</code></pre><h2 id="9-3-isPhoneNum"><a href="#9-3-isPhoneNum" class="headerlink" title="9.3 isPhoneNum"></a>9.3 isPhoneNum</h2><pre><code>/**
 * 
 * @desc   判断是否为手机号
 * @param  {String|Number} str 
 * @return {Boolean} 
 */
 function isPhoneNum(str) {
    return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/.test(str)
}
</code></pre><h2 id="9-4-isUrl"><a href="#9-4-isUrl" class="headerlink" title="9.4 isUrl"></a>9.4 isUrl</h2><pre><code>/**
 * 
 * @desc   判断是否为URL地址
 * @param  {String} str 
 * @return {Boolean}
 */ 
function isUrl(str) {
    return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str);
}
</code></pre><h2 id="10-String"><a href="#10-String" class="headerlink" title="10.String"></a>10.String</h2><h2 id="10-1-digitUppercase"><a href="#10-1-digitUppercase" class="headerlink" title="10.1 digitUppercase"></a>10.1 digitUppercase</h2><pre><code>/**
 * 
 * @desc   现金额转大写
 * @param  {Number} n 
 * @return {String}
 */
 function digitUppercase(n) {
    var fraction = [&apos;角&apos;, &apos;分&apos;];
    var digit = [
        &apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;,
        &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos;
    ];
    var unit = [
        [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;],
        [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;]
    ];
    var head = n &lt; 0 ? &apos;欠&apos; : &apos;&apos;;
    n = Math.abs(n);
    var s = &apos;&apos;;
    for (var i = 0; i &lt; fraction.length; i++) {
        s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;);
    }
    s = s || &apos;整&apos;;
    n = Math.floor(n);
    for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) {
        var p = &apos;&apos;;
        for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) {
            p = digit[n % 10] + unit[1][j] + p;
            n = Math.floor(n / 10);
        }
        s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s;
    }
    return head + s.replace(/(零.)*零元/, &apos;元&apos;)
        .replace(/(零.)+/g, &apos;零&apos;)
        .replace(/^整$/, &apos;零元整&apos;);
};
</code></pre><h2 id="11-Support"><a href="#11-Support" class="headerlink" title="11.Support"></a>11.Support</h2><h2 id="11-1-isSupportWebP"><a href="#11-1-isSupportWebP" class="headerlink" title="11.1 isSupportWebP"></a>11.1 isSupportWebP</h2><pre><code>/**
 * 
 * @desc 判断浏览器是否支持webP格式图片
 * @return {Boolean} 
 */ 
function isSupportWebP() {
    return !![].map &amp;&amp; document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0;
}
</code></pre><h2 id="12-Time"><a href="#12-Time" class="headerlink" title="12.Time"></a>12.Time</h2><h2 id="12-1-formatPassTime"><a href="#12-1-formatPassTime" class="headerlink" title="12.1 formatPassTime"></a>12.1 formatPassTime</h2><pre><code>/**
 * @desc   格式化${startTime}距现在的已过时间
 * @param  {Date} startTime 
 * @return {String}
 */ 
function formatPassTime(startTime) {
    var currentTime = Date.parse(new Date()),
        time = currentTime - startTime,
        day = parseInt(time / (1000 * 60 * 60 * 24)),
        hour = parseInt(time / (1000 * 60 * 60)),
        min = parseInt(time / (1000 * 60)),
        month = parseInt(day / 30),
        year = parseInt(month / 12);
    if (year) return year + &quot;年前&quot; if (month) return month + &quot;个月前&quot; if (day) return day + &quot;天前&quot; if (hour) return hour + &quot;小时前&quot; if (min) return min + &quot;分钟前&quot; else return &apos;刚刚&apos;
}
</code></pre><h2 id="12-2-formatRemainTime"><a href="#12-2-formatRemainTime" class="headerlink" title="12.2 formatRemainTime"></a>12.2 formatRemainTime</h2><pre><code>/**
 * 
 * @desc   格式化现在距${endTime}的剩余时间
 * @param  {Date} endTime  
 * @return {String}
 */ function formatRemainTime(endTime) {
    var startDate = new Date(); //开始时间 var endDate = new Date(endTime); //结束时间 var t = endDate.getTime() - startDate.getTime(); //时间差 var d = 0,
        h = 0,
        m = 0,
        s = 0;
    if (t &gt;= 0) {
        d = Math.floor(t / 1000 / 3600 / 24);
        h = Math.floor(t / 1000 / 60 / 60 % 24);
        m = Math.floor(t / 1000 / 60 % 60);
        s = Math.floor(t / 1000 % 60);
    }
    return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;;
}
</code></pre><h2 id="13-Url"><a href="#13-Url" class="headerlink" title="13.Url"></a>13.Url</h2><h2 id="13-1-parseQueryString"><a href="#13-1-parseQueryString" class="headerlink" title="13.1 parseQueryString"></a>13.1 parseQueryString</h2><pre><code>/**
 * 
 * @desc   url参数转对象
 * @param  {String} url  default: window.location.href
 * @return {Object} 
 */ 
function parseQueryString(url) {
    url = url == null ? window.location.href : url
    var search = url.substring(url.lastIndexOf(&apos;?&apos;) + 1)
    if (!search) {
        return {}
    }
    return JSON.parse(&apos;{&quot;&apos; + decodeURIComponent(search).replace(/&quot;/g, &apos;\\&quot;&apos;).replace(/&amp;/g, &apos;&quot;,&quot;&apos;).replace(/=/g, &apos;&quot;:&quot;&apos;) + &apos;&quot;}&apos;)
}
</code></pre><h2 id="13-2-stringfyQueryString"><a href="#13-2-stringfyQueryString" class="headerlink" title="13.2 stringfyQueryString"></a>13.2 stringfyQueryString</h2><pre><code>/**
 * 
 * @desc   对象序列化
 * @param  {Object} obj 
 * @return {String}
 */ function stringfyQueryString(obj) {
    if (!obj) return &apos;&apos;;
    var pairs = [];

    for (var key in obj) {
        var value = obj[key];

        if (value instanceof Array) {
            for (var i = 0; i &lt; value.length; ++i) {
                pairs.push(encodeURIComponent(key + &apos;[&apos; + i + &apos;]&apos;) + &apos;=&apos; + encodeURIComponent(value[i]));
            }
            continue;
        }

        pairs.push(encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(obj[key]));
    }

    return pairs.join(&apos;&amp;&apos;);
}
</code></pre><h2 id="14-Function"><a href="#14-Function" class="headerlink" title="14.Function"></a>14.Function</h2><h2 id="14-1-throttle"><a href="#14-1-throttle" class="headerlink" title="14.1 throttle"></a>14.1 throttle</h2><pre><code>/**
 * @desc   函数节流。
 * 适用于限制`resize`和`scroll`等函数的调用频率
 *
 * @param  {Number}    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}   noTrailing     可选，默认为false。
 *                                    如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。
 *                                    如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次.
 *                                    （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位）
 * @param  {Function}  callback       延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                    执行去节流功能时，调用`callback`。
 * @param  {Boolean}   debounceMode   如果`debounceMode`为true，`clear`在`delay`ms后执行。
 *                                    如果debounceMode是false，`callback`在`delay` ms之后执行。
 *
 * @return {Function}  新的节流函数
 */ function throttle(delay, noTrailing, callback, debounceMode) {

    // After wrapper has stopped being called, this timeout ensures that // `callback` is executed at the proper times in `throttle` and `end` // debounce modes. var timeoutID;

    // Keep track of the last time `callback` was executed. var lastExec = 0;

    // `noTrailing` defaults to falsy. if (typeof noTrailing !== &apos;boolean&apos;) {
        debounceMode = callback;
        callback = noTrailing;
        noTrailing = undefined;
    }

    // The `wrapper` function encapsulates all of the throttling / debouncing // functionality and when executed will limit the rate at which `callback` // is executed. function wrapper() {

        var self = this;
        var elapsed = Number(new Date()) - lastExec;
        var args = arguments;

        // Execute `callback` and update the `lastExec` timestamp. function exec() {
            lastExec = Number(new Date());
            callback.apply(self, args);
        }

        // If `debounceMode` is true (at begin) this is used to clear the flag // to allow future `callback` executions. function clear() {
            timeoutID = undefined;
        }

        if (debounceMode &amp;&amp; !timeoutID) {
            // Since `wrapper` is being called for the first time and // `debounceMode` is true (at begin), execute `callback`.
            exec();
        }

        // Clear any existing timeout. if (timeoutID) {
            clearTimeout(timeoutID);
        }

        if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) {
            // In throttle mode, if `delay` time has been exceeded, execute // `callback`.
            exec();

        } else if (noTrailing !== true) {
            // In trailing throttle mode, since `delay` time has not been // exceeded, schedule `callback` to execute `delay` ms after most // recent execution. // // If `debounceMode` is true (at begin), schedule `clear` to execute // after `delay` ms. // // If `debounceMode` is false (at end), schedule `callback` to // execute after `delay` ms.
            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
        }

    }

    // Return the wrapper function. return wrapper;

};
</code></pre><h2 id="14-2-debounce"><a href="#14-2-debounce" class="headerlink" title="14.2 debounce"></a>14.2 debounce</h2><pre><code>/**
 * @desc 函数防抖 
 * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次，
 * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。
 * @example 适用场景：如在线编辑的自动存储防抖。
 * @param  {Number}   delay         0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。
 * @param  {Boolean}  atBegin       可选，默认为false。
 *                                  如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。
                                    如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行
 * @param  {Function} callback      延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的，
 *                                  执行去抖动功能时，，调用`callback`。
 *
 * @return {Function} 新的防抖函数。
 */ 
var throttle = require(&apos;./throttle&apos;);
function debounce(delay, atBegin, callback) {
    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
};
</code></pre><p>封装</p>
<p>除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用<code>webpack</code>统一打包成<code>UMD</code> 通用模块规范，支持<code>webpack</code>、<code>RequireJS</code>、<code>SeaJS</code>等模块加载器，亦或直接通过<code>&lt;script&gt;</code>标签引入。</p>
<p>但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持按需引入吧</p>
<p>1.目录结构说明</p>
<pre><code>│  .babelrc
│  .gitignore
│  .travis.yml
│  LICENSE
│  package.json
│  README.md
│  setCookie.js  // 拷贝到根路径的函数模块，方便按需加载
│  setScrollTop.js
│  stringfyQueryString.js
│   ...
│   ...
│  
├─min
│      outils.min.js  // 所有函数统一打包生成的全量压缩包
│      
├─script  // 本项目开发脚本目录
│      build.js  // 打包构建脚本
│      test.js  // 测试脚本
│      webpack.conf.js  // webpack打包配置文件
│      
├─src // 源码目录
│  │  index.js  // webpack入口文件
│  │  
│  ├─array
│  │      
│  ├─class
│  │      
│  ├─cookie
│  │      
│  ├─device
│  │      
│  ├─dom
│  │      
│  ├─keycode
│  │      
│  ├─object
│  │      
│  ├─random
│  │      
│  ├─regexp
│  │      
│  ├─string
│  │      
│  ├─support
│  │      
│  ├─time
│  │      
│  └─url
│          
└─test // 测试用例目录
    │  array.test.js
    │  class.test.js
    │  cookie.test.js
    │  device.test.js
    │  dom.test.js
    │  index.html
    │  keycode.test.js
    │  object.test.js
    │  random.test.js
    │  regexp.test.js
    │  string.test.js
    │  support.test.js
    │  time.test.js
    │  url.test.js
    │  
    └─_lib // 测试所用到的第三方库
            mocha.css
            mocha.js
            power-assert.js
</code></pre><p>2.构建脚本</p>
<p>这里主要说明一下项目中<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fbuild.js" target="_blank" rel="noopener"> build.js </a>的构建过程<br>第一步，构建全量压缩包，先删除<code>min</code>目录中之前的<code>outils.min.js</code>，后通过<code>webpack</code>打包并保存新的压缩包至<code>min</code>目录中：</p>
<pre><code>......
 ......
 // 删除旧的全量压缩包
 rm(path.resolve(rootPath, &apos;min&apos;, `${pkg.name}.min.js`), err =&gt; {
     if (err) throw (err)
     webpack(config, function (err, stats) {
         if (err) throw (err)
         building.stop()
         process.stdout.write(stats.toString({
             colors: true,
             modules: false,
             children: false,
             chunks: false,
             chunkModules: false
         }) + &apos;\n\n&apos;)
         resolve()
         console.log(chalk.cyan(&apos;  Build complete.\n&apos;))
     })
 })
 ......
 ......
</code></pre><p>第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝<code>src</code>下面一层目录的所有<code>js</code>文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接<code>require(&#39;outils/&lt;方法名&gt;&#39;)</code>即可，缩短引入的路径，也算是提高点效率。</p>
<pre><code>// 替换模块文件
    ......
    ......
    // 先删除根目录中之前的函数模块
    rm(&apos;*.js&apos;, err =&gt; {
        if (err) throw (err)
        let folderList = fs.readdirSync(path.resolve(rootPath, &apos;src&apos;))
        folderList.forEach((item, index) =&gt; {
            // 拷贝`src`下面一层目录的所有`js`文件至根目录
            copy(`src/${item}/*.js`, rootPath, function (err, files) {
                if (err) throw err;
                if (index === folderList.length - 1) {
                    console.log(chalk.cyan(&apos;  Copy complete.\n&apos;))
                    copying.stop()
                }
            })
        })
    })
    ......
    ......
</code></pre><p>3.书写测试用例</p>
<p>俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。</p>
<p>但是因为时间关系，本项目暂时通过项目中的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Ftest.js" target="_blank" rel="noopener"> test.js </a>，启动了一个<code>koa</code>静态服务器，来加载<code>mocha</code>网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。<br>但是后续将使用<code>travis-ci</code>配合<code>Github</code>来做持续化构建，自动发布到<code>npm</code>。改用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>做单元测试，使用<code>Coverage</code>测试覆盖率。这一部分，后续更新。</p>
<p>这里给大家推荐一个好用的断言库<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252Fpackage%252Fpower-assert" target="_blank" rel="noopener"> power-assert </a>，这个库记住<code>assert(value, [message])</code>一个API就基本无敌，从此再也不用担心记不住断言库的API。</p>
<p>本项目的所有测试用例都在<code>test</code>目录下，大家可以作一定参考。</p>
<p>更新：单元测试，已使用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>，使用<code>Coverage</code>测试覆盖率，并集成<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Ftravis-ci.org%252F" target="_blank" rel="noopener"> travis-ci </a>配合<code>Github</code>来做持续化构建，可以参考本项目的<code>travis</code>配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252F.travis.yml" target="_blank" rel="noopener"> .travis.yml </a>和<code>karma</code>的配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fkarma.conf.js" target="_blank" rel="noopener"> karma.conf.js </a>。</p>
<blockquote>
<p>发布</p>
</blockquote>
<p>首先放到<code>Github</code>托管一下，当然你也可以直接<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252F" target="_blank" rel="noopener">fork</a>本项目，然后再加入你自己的函数。<br>以笔者项目，举个栗子:</p>
<p>1.添加自己的函数</p>
<p>在<code>src</code>目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。</p>
<pre><code>/**
 * 
 * @desc   判断是否NaN
 * @param  {Any} value 
 * @return {Boolean}
 */ 
function isNaN(value) {    
    return value !== value;
};

modules.export = isNaN
</code></pre><p>然后记得在src/index.js文件中暴露isNaN函数</p>
<p>2.单元测试</p>
<p>在<code>test</code>文件新建测试用例</p>
<pre><code>describe(&apos;#isNaN()&apos;, function () {
    it(`outils.isNaN(NaN) should return true`, function () {
        assert(outils.isNaN(NaN))
    })
    it(`outils.isNaN(&apos;value&apos;) should return false`, function () {
        assert.notEqual(outils.isNaN(NaN))
    })
})
</code></pre><p>然后记得在<code>test/index.html</code>中引入之前创建的测试用例脚本。</p>
<p>3.测试并打包</p>
<p>执行<code>npm run test</code>，看所有的测试用例是否通过。如果没有问题，执行<code>npm run build</code>构建，之后提交到个人的 github 仓库即可。</p>
<p>4.发布到<code>npm</code></p>
<p>在<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>注册账号，修改本地<code>package.json</code>中的<code>name</code>、<code>version</code>、<code>author</code>等信息，最后<code>npm publish</code>就大功告成了。<br>注意：向<code>npm</code>发包，要把镜像源切到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>，使用<code>cnpm</code>等第三方镜像源会报错。</p>
<p>使用</p>
<p>1.浏览器</p>
<p>直接下载<code>min</code>目录下的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fmin%252Foutils.min.js" target="_blank" rel="noopener"> outils.min.js </a>，通过<code>&lt;script&gt;</code>标签引入。</p>
<pre><code>&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var OS = outils.getOS()
  &lt;/script&gt;
</code></pre><p>注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Freleases" target="_blank" rel="noopener"> github Release </a>页面下载对应版本号的代码。</p>
<p>2.Webpack、RequireJS、SeaJS等模块加载器</p>
<p>先使用<code>npm</code>安装<code>outils</code>。</p>
<pre><code>$ npm install --save-dev outils
// 完整引入 const outils = require(&apos;outils&apos;)
const OS = outils.getOS()
推荐使用方法 
// 按需引入require(&apos;outils/&lt;方法名&gt;&apos;) const getOS = require(&apos;outils/getOS&apos;)
const OS = getOS()
</code></pre><p>当然，你的开发环境有<code>babel</code>编译<code>ES6</code>语法的话，也可以这样使用：</p>
<pre><code>import getOS from &apos;outils/getOS&apos; // 或 import { getOS } from &quot;outils&quot;;
</code></pre><p>总结</p>
<p>这里只是简单封装，发布到<code>npm</code>上，省去下次复制粘贴的功夫，或者直接Goole的时间。如果笔者的库中，没有你常用的函数，或者你有更好的建议，欢迎来本项目的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fissues" target="_blank" rel="noopener"> Github Issues </a>交流，如果觉得不错，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。</p>
<p>当然，更好的建议是<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> fork </a>本项目，或者直接新建自己的项目，添加自己 想要的 、常用的 、记不住的 函数，甚至是可以抽象出来的功能，封装成自己顺手、熟悉的库。 这样才能打造出你自己的武器库，瞬间提高你的单兵作战（开发）能力。</p>
<h2 id="libraries-：https-github-com-wuxianqiang-libraries"><a href="#libraries-：https-github-com-wuxianqiang-libraries" class="headerlink" title="libraries ：https://github.com/wuxianqiang/libraries"></a>libraries ：<a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries" target="_blank" rel="noopener">https://github.com/wuxianqiang/libraries</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectcreate%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.create()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADstringtrim%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中String.trim()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarrayreduce%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.reduce()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectkeys%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.keys()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADfunctionbind%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Function.bind()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarraymap%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.map()函数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFmathmax%25E6%2596%25B9%25E6%25B3%2595%25E4%25B8%258D%25E5%25AE%259A%25E5%25AE%259E%25E5%258F%2582%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿Math.max()方法实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFstringmatch%25E6%2596%25B9%25E6%25B3%2595%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">仿String.match()方法实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFhtml5%25E7%259A%2584classlist%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">仿HTML5的classList属性实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2587%25BD%25E6%2595%25B0%25E7%259A%2584%25E5%2590%258D%25E5%25AD%2597" target="_blank" rel="noopener">仿Function.name属性实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E5%25B1%2582%25E7%25A5%2596%25E5%2585%2588%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n层祖先元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%2585%2584%25E5%25BC%259F%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个兄弟元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%25AD%2590%25E4%25BB%25A3%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个子代元素</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB1" target="_blank" rel="noopener">原生JS实现CSS动画之震动</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB2" target="_blank" rel="noopener">原生JS实现CSS动画之隐藏</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E6%2595%25B0%25E7%25BB%2584%25E4%25B8%25AD%25E6%259F%25A5%25E6%2589%25BE%25E6%2589%2580%25E6%259C%2589%25E5%2587%25BA%25E7%258E%25B0%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E6%2596%25B9%25E6%25B3%2595" target="_blank" rel="noopener">在数组中查找所有出现的元素方法</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E6%258D%25AE%25E7%25B1%25BB%25E5%259E%258B%25E6%25A3%2580%25E6%25B5%258B%25E7%2589%25B9%25E6%25AE%258A%25E6%2583%2585%25E5%2586%25B5%25E7%2589%25B9%25E6%25AE%258A%25E5%25A4%2584%25E7%2590%2586" target="_blank" rel="noopener">数据类型检测之特殊情况特殊处理</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0outerhtml%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">使用innerHTML实现outerHTML属性</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258F%2592%25E5%2585%25A5%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">插入节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2580%2592%25E5%25BA%258F%25E6%258E%2592%25E5%2588%2597%25E5%25AD%2590%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">倒序排列子节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E6%25BB%259A%25E5%258A%25A8%25E6%259D%25A1%25E7%259A%2584%25E4%25BD%258D%25E7%25BD%25AE" target="_blank" rel="noopener">查询窗口滚动条的位置</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E7%259A%2584%25E8%25A7%2586%25E5%258F%25A3%25E5%25B0%25BA%25E5%25AF%25B8" target="_blank" rel="noopener">查询窗口的视口尺寸</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25A1%25A8%25E6%25A0%25BC%25E7%259A%2584%25E8%25A1%258C%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">表格的行排序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E7%2594%259F%25E6%2588%2590%25E7%259B%25AE%25E5%25BD%2595%25E8%25A1%25A8" target="_blank" rel="noopener">生成目录表</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E7%25BB%2584%25E5%258E%25BB%25E9%2587%258D" target="_blank" rel="noopener">数组去重</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">冒泡排序</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%258Eurl%25E8%25A7%25A3%25E6%259E%2590%25E5%258F%2582%25E6%2595%25B0" target="_blank" rel="noopener">从URL解析参数</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%258E%25B7%25E5%258F%2596%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">获取纯文本的元素内容</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2589%258B%25E5%2586%2599%25E4%25B8%2580%25E4%25B8%25AAjsonp%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">手写一个JSONP实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E5%25BD%25A2%25E5%25BC%258F%25E7%259A%2584%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">查询纯文本形式的内容</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E6%2589%25BE%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E5%2590%258E%25E4%25BB%25A3%25E4%25B8%25AD%25E8%258A%2582%25E7%2582%25B9%25E4%25B8%25AD%25E7%259A%2584%25E6%2589%2580%25E6%259C%2589text%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">查找元素的后代中节点中的所有Text节点</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0insertadjacenthtml" target="_blank" rel="noopener">使用innerHTML实现insertAdjacentHTML</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258B%2596%25E6%258B%25BD" target="_blank" rel="noopener">拖拽</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E8%25B0%25B7%25E6%25AD%258C%25E5%259C%25B0%25E5%259B%25BE%25E4%25B8%258A%25E6%2598%25BE%25E7%25A4%25BA%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E4%25BF%25A1%25E6%2581%25AF" target="_blank" rel="noopener">在谷歌地图上显示地理位置信息</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8%25E6%2589%2580%25E6%259C%2589%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E7%2589%25B9%25E6%2580%25A7" target="_blank" rel="noopener">使用所有地理位置特性</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BC%2598%25E9%259B%2585%25E7%259A%2584%25E5%259B%25BE%25E7%2589%2587%25E7%25BF%25BB%25E8%25BD%25AC%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">优雅的图片翻转实现</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E5%25A4%259A%25E8%25BE%25B9%25E5%25BD%25A2" target="_blank" rel="noopener">使用canvas绘制多边形</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E9%259B%25AA%25E8%258A%25B1" target="_blank" rel="noopener">使用canvas绘制雪花</a></li>
<li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8web-worker%25E4%25B8%25AD%25E5%258F%2591%25E8%25B5%25B7%25E5%2590%258C%25E6%25AD%25A5xmlhtttprequest" target="_blank" rel="noopener">在Web Worker中发起同步XMLHtttpRequest</a></li>
</ul>
<h2 id="仿ECMAScript5中Object-create-函数"><a href="#仿ECMAScript5中Object-create-函数" class="headerlink" title="仿ECMAScript5中Object.create()函数"></a>仿ECMAScript5中Object.create()函数</h2><pre><code>function inherit(obj) {
            if (obj === null) throw TypeError();
            if (Object.create) return Object.create(obj);
            var t = typeof obj;
            if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) throw TypeError();
            function Fn() {};
            Fn.prototype = obj;
            return new Fn();
        }
</code></pre><h2 id="仿ECMAScript5中String-trim-函数"><a href="#仿ECMAScript5中String-trim-函数" class="headerlink" title="仿ECMAScript5中String.trim()函数"></a>仿ECMAScript5中String.trim()函数</h2><pre><code>String.prototype.mytrim = function () {
            String.prototype.trim || function () {
                if (!this) return this; //空字符串不做处理
                return this.replace(/^\s+|\s+$/g, &quot;&quot;) //使用正则表达式经行空格替换
            }
        }
</code></pre><h2 id="仿ECMAScript5中Array-reduce-函数"><a href="#仿ECMAScript5中Array-reduce-函数" class="headerlink" title="仿ECMAScript5中Array.reduce()函数"></a>仿ECMAScript5中Array.reduce()函数</h2><pre><code>var reduce = Array.prototype.reduce ? function (ary, fn, initial) {
            if (arguments.length &gt; 2) { //如果reduce()方法存在的话
                return ary.reduce(fn, initial); //如果传入了一个初始值
            } else {
                return ary.reduce(fn); //否则初始值
            }
        } : function (ary, fn, initial) { //以特定的初始值开始，否则第一个值取自ary
            var i = 0,
                len = ary.length,
                accumulator;
            if (arguments.length &gt; 2) {
                accumulator = initial;
            } else { //找到数组中第一个已经定义的索引
                if (len == 0) throw TypeError();
                while (i &lt; len) {
                    if (i in ary) {
                        accumulator = ary[i++];
                        break;
                    } else {
                        i++;
                    }
                }
                if (i == len) throw TypeError();
            }
            while (i &lt; len) { //对于数组中剩下的元素依次调用fn
                if (i in ary) {
                    accumulator = fn.call(undefined, accumulator, ary[i], i, ary)
                }
                i++;
            }
            return accumulator;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在数组中查找所有出现的元素方法"><a href="#在数组中查找所有出现的元素方法" class="headerlink" title="在数组中查找所有出现的元素方法"></a>在数组中查找所有出现的元素方法</h2><pre><code>function findAll(ary, ele) {
            var results = [],
                len = ary.length,
                pos = 0;
            while (pos &lt; len) {
                pos = ary.indexOf(ele, pos);
                if (pos === -1) break;
                results.push(pos);
                pos++;
            }
            return results;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="数据类型检测，特殊情况特殊处理"><a href="#数据类型检测，特殊情况特殊处理" class="headerlink" title="数据类型检测，特殊情况特殊处理"></a>数据类型检测，特殊情况特殊处理</h2><pre><code>function classOf(obj) {
            if (obj === null) return &quot;Null&quot;;
            if (obj === undefined) return &apos;Undefined&apos;;
            return Object.prototype.toString.call(obj).slice(8, -1);
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Object-keys-函数"><a href="#仿ECMAScript5中Object-keys-函数" class="headerlink" title="仿ECMAScript5中Object.keys()函数"></a>仿ECMAScript5中Object.keys()函数</h2><pre><code>function keys(obj) {
            if (typeof obj !== &quot;object&quot;) {
                throw TypeError();
            }
            var result = [];
            for (var prop in obj) {
                if (obj.hasOwnProperty(prop)) {
                    result.push(prop);
                }
            }
            return result;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿Math-max方法（不定实参函数）"><a href="#仿Math-max方法（不定实参函数）" class="headerlink" title="仿Math.max方法（不定实参函数）"></a>仿Math.max方法（不定实参函数）</h2><pre><code>function max() {
            var max = Number.NEGATIVE_INFINITY;
            for (var i = 0; i &lt; arguments.length; i++) {
                if (arguments[i] &gt; max) max = arguments[i];
            }
            return max;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Function-bind-函数"><a href="#仿ECMAScript5中Function-bind-函数" class="headerlink" title="仿ECMAScript5中Function.bind()函数"></a>仿ECMAScript5中Function.bind()函数</h2><pre><code>if (!Function.prototype.bind) {
            Function.prototype.bind = function (obj) {
                var self = this,
                    boundArgs = arguments;
                return function () {
                    var args = [],
                        i;
                    for (i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);
                    for (i = 1; i &lt; arguments.length; i++) args.push(arguments[i]);
                    return self.apply(obj, args);
                }
            }
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿ECMAScript5中Array-map-函数"><a href="#仿ECMAScript5中Array-map-函数" class="headerlink" title="仿ECMAScript5中Array.map()函数"></a>仿ECMAScript5中Array.map()函数</h2><pre><code>var map = Array.prototype.map ? function (ary, fn) {
            return ary.map(fn);
        } : function (ary, fn) {
            var results = [];
            for (var i = 0, len = ary.length; i &lt; len; i++) {
                if (i in ary) {
                    results[i] = fn.call(null, ary[i], i, ary);
                }
            }
            return results;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code>Array.prototype.unique = function unique() {
            var obj = {};
            for (var i = 0; i &lt; this.length; i++) {
                var current = this[i];
                if (obj[current] === current) {
                    current = this[this.length - 1];
                    this.length--;
                    i--;
                    continue;
                }
                obj[current] = current
            }
            obj = null;
            return this;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>Array.prototype.bubbleSort = function bubbleSort() {
            var temp = null;
            for (var i = 0; i &lt; this.length - 1; i++) {
                for (var k = 0; k &lt; this.length - 1 - i; k++) {
                    if (this[k] &gt; this[k + 1]) {
                        temp = this[k];
                        this[k] = this[k + 1];
                        this[k + 1] = temp;
                    }
                }
            }
            return this;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿String-match-方法实现"><a href="#仿String-match-方法实现" class="headerlink" title="仿String.match()方法实现"></a>仿String.match()方法实现</h2><pre><code>String.prototype.mymatch = function (reg) {
         var ary = [];
         var res = reg.exec(this);
         while (res) {
            ary.push(res[0]);
            res = reg.exec(this);
         }
         return ary;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n层祖先元素"><a href="#返回元素的第n层祖先元素" class="headerlink" title="返回元素的第n层祖先元素"></a>返回元素的第n层祖先元素</h2><pre><code>/**
        *返回元素ele的第n层祖先元素，如果不存在此类祖先或祖先不是Element，
        *（例如Document或者DocumentFragment）则返回null
        *如果n为0，则返回e本身。如果n为1（或省略），则返回其父元素
        *如果n为2，则返回其祖父元素，依次类推
        */
        function parent(ele, n) {
            if (n === nudefined) n = 1;
            while (n-- &amp;&amp; ele) {
                ele = ele.parentNode;
            }
            if (!ele || ele.nodeTope !== 1) return null;
            return ele;
        }
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n个兄弟元素"><a href="#返回元素的第n个兄弟元素" class="headerlink" title="返回元素的第n个兄弟元素"></a>返回元素的第n个兄弟元素</h2><pre><code>/**
 *返回元素ele的第n个兄弟元素
 *如果n为正，返回后续的第n个兄弟元素
 *如果n为负，返回前面的第n个兄弟元素
 *如果n为零，返回ele本身
 */
function sibling(ele, n) {
    while (ele &amp;&amp; n !== 0) { //如果ele未定义，即刻返回它
        if (n &gt; 0) { //查找后续的兄弟元素
            if (ele.nextElementSibling) {
                ele = ele.nextElementSibling;
            } else {
                for (ele = ele.nextSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;
            }
            n--;
        } else { //查找前面的兄弟元素
            if (ele.previousElementSibing) {
                ele = ele.previousElementSibling;
            } else {
                for (ele = ele.previousSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;
            }
            n++;
        }
    }
    return ele;
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回元素的第n个子代元素"><a href="#返回元素的第n个子代元素" class="headerlink" title="返回元素的第n个子代元素"></a>返回元素的第n个子代元素</h2><pre><code>/**
 *返回元素ele的第n代子元素，如果不存在则为null
 *负值n代表从后往前计数。0表示第一个子元素，而-1代表最后一个，-2代表倒数第二个，依次类推
 */
function child(ele, n) {
    if (ele.children) { //如果children数组存在
        if (n &lt; 0) n += ele.children.length; //转换负的n为数组索引
        if (n &lt; 0) return null; //如果它仍然为负，说明没有子元素
        return ele.children[n]; //返回指定的子元素
    }
    //如果e没有children数组，找到第一个子元素并向前数，或找到最后一个子元素并往回数
    if (n &gt;= 0) { //n非负：从第一个子元素向前数
        //找到元素e的第一个子元素
        if (ele.firstElementChild) {
            ele = ele.firstElementChild;
        } else {
            for (ele = ele.firstChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;
        }
        return sibling(ele, n); //返回第一个子元素的第n个兄弟元素
    } else { //n为负：从最后一个子元素往回数
        if (ele.lastElementChild) {
            ele = ele.lastElementChild;
        } else {
            for (ele = ele.lastChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;
        }
        return sibling(ele, n + 1); //+1来转化最后1个子元素为最后1个兄弟元素
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="表格的行排序"><a href="#表格的行排序" class="headerlink" title="表格的行排序"></a>表格的行排序</h2><pre><code>//根据指定表格每行第n个单元格的值，对第一个＜tbody＞中的行进行排序
//如果存在comparator函数则使用它，否则按字母表顺序比较
function sortrows(table, n, comparator) {
    var tbody = table.tBodies[0]; //第一个＜tbody＞，可能是隐式创建的
    var rows = tbody.getElementsByTagName(&quot;tr&quot;); //tbody中的所有行
    rows = Array.prototype.slice.call(rows, 0); //真实数组中的快照
    //基于第n个＜td＞元素的值对行排序
    rows.sort(function (row1, row2) {
        var cell1 = row1.getElementsByTagName(&quot;td&quot;)[n]; //获得第n个单元格
        var cell2 = row2.getElementsByTagName(&quot;td&quot;)[n]; //两行都是
        var val1 = cell1.textContent || cell1.innerText; //获得文本内容
        var val2 = cell2.textContent || cell2.innerText; //两单元格都是
        if (comparator) return comparator(val1, val2); //进行比较
        if (val1 &lt; val2) {
            return -1;
        } else if (val1 &gt; val2) {
            return 1;
        } else {
            return 0;
        }
    }); //在tbody中按它们的顺序把行添加到最后
    //这将自动把它们从当前位置移走，故没必要预先删除它们
    //如果＜tbody＞还包含了除了＜tr＞的任何其他元素，这些节点将会悬浮到顶部位置
    for (var i = 0; i &lt; rows.length; i++) tbody.appendChild(rows[i]);
}
//查找表格的＜th＞元素（假设只有一行），让它们可单击，
//以便单击列标题，按该列对行排序
function makeSortable(table) {
    var headers = table.getElementsByTagName(&quot;th&quot;);
    for (var i = 0; i &lt; headers.length; i++) {
        (function (n) { //嵌套函数来创建本地作用域
            headers[i].onclick = function () {
                sortrows(table, n);
            };
        }(i)); //将i的值赋给局部变量n
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="生成目录表"><a href="#生成目录表" class="headerlink" title="生成目录表"></a>生成目录表</h2><pre><code>/**
 *
 *这个模块注册一个可在页面加载完成后自动运行的匿名函数。当执行这个函数时会去文档中查找
 *id为&quot;TOC&quot;的元素。如果这个元素不存在，就创建一个元素
 *
 *生成的TOC目录应当具有自己的CSS样式。整个目录区域的样式className设置为&quot;TOCEntry&quot;
 *同样我们为不同层级的目录标题定义不同的样式。＜h1＞标签生成的标题
 *className为&quot;TOCLevel1&quot;，＜h2＞标签生成的标题className为&quot;TOCLevel2&quot;，以此类推
 *段编号的样式为&quot;TOCSectNum&quot;
 *
 *完整的CSS样式代码如下:
 *
 *#TOC{border:solid black 1px;margin:10px;padding:10px;}
 *.TOCEntry{font-family:sans-serif;}
 *.TOCEntry a{text-decoration:none;}
 *.TOCLevel1{font-size:16pt;font-weight:bold;}
 *.TOCLevel2{font-size:12pt;margin-left:.5in;}
 *.TOCSectNum:after{content:&quot;:&quot;;}
 *
 *这段代码的最后一行表示每个段编号之后都有一个冒号和空格符。要想隐藏段编号，
 *请使用这行代码：
 *.TOCSectNum{display:none}
 *
 **/
(function () { //匿名函数定义了一个局部作用域
    //查找TOC容器元素
    //如果不存在，则在文档开头处创建一个
    var toc = document.getElementById(&quot;TOC&quot;);
    if (!toc) {
        toc = document.createElement(&quot;div&quot;);
        toc.id = &quot;TOC&quot;;
        document.body.insertBefore(toc, document.body.firstChild);
    }
    //查找所有的标题元素
    var headings;
    if (document.querySelectorAll) //我们是否能用这个简单的方法？
        headings = document.querySelectorAll(&quot;h1,h2,h3,h4,h5,h6&quot;);
    else //否则，查找方法稍微麻烦一些
        headings = findHeadings(document.body, []); //递归遍历document的body，查找标题元素
    function findHeadings(root, sects) {
        for (var c = root.firstChild; c != null; c = c.nextSibling) {
            if (c.nodeType !== 1) continue;
            if (c.tagName.length == 2 &amp;&amp; c.tagName.charAt(0) == &quot;H&quot;)
                sects.push(c);
            else
                findHeadings(c, sects);
        }
        return sects;
    }
    //初始化一个数组来保持跟踪章节号
    var sectionNumbers = [0, 0, 0, 0, 0, 0]; //现在，循环已找到的标题元素
    for (var h = 0; h &lt; headings.length; h++) {
        var heading = headings[h]; //跳过在TOC容器中的标题元素
        if (heading.parentNode == toc) continue; //判定标题的级别
        var level = parseInt(heading.tagName.charAt(1));
        if (isNaN(level) || level &lt; 1 || level &gt; 6) continue; //对于该标题级别增加sectionNumbers对应的数字
        //重置所有标题比它级别低的数字为零
        sectionNumbers[level - 1]++;
        for (var i = level; i &lt; 6; i++) sectionNumbers[i] = 0; //现在，将所有标题级别的章节号组合产生一个章节号， 如2 .3 .1
        var sectionNumber = sectionNumbers.slice(0, level).join(&quot;.&quot;) //为标题级别增加章节号
        //把数字放在＜span＞中，使得其可以用样式修饰
        var span = document.createElement(&quot;span&quot;);
        span.className = &quot;TOCSectNum&quot;;
        span.innerHTML = sectionNumber;
        heading.insertBefore(span, heading.firstChild); //用命名的锚点将标题包起来，以便为它增加链接
        var anchor = document.createElement(&quot;a&quot;);
        anchor.name = &quot;TOC&quot; + sectionNumber;
        heading.parentNode.insertBefore(anchor, heading);
        anchor.appendChild(heading); //现在为该节创建一个链接
        var link = document.createElement(&quot;a&quot;);
        link.href = &quot;#TOC&quot; + sectionNumber; //链接的目标地址
        link.innerHTML = heading.innerHTML; //链接文本与实际标题一致
        //将链接放在一个div中，div用基于级别名字的样式修饰
        var entry = document.createElement(&quot;div&quot;);
        entry.className = &quot;TOCEntry TOCLevel&quot; + level;
        entry.appendChild(link); //该div添加到TOC容器中
        toc.appendChild(entry);
    }
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="从URL解析参数"><a href="#从URL解析参数" class="headerlink" title="从URL解析参数"></a>从URL解析参数</h2><pre><code>/*
 *这个函数用来解析来自URL的查询串中的name=value参数对
 *它将name=value对存储在一个对象的属性中，并返回该对象
 *这样来使用它
 *
 *var args=urlArgs();//从URL中解析参数
 *var q=args.q||&quot;&quot;;//如果参数定义了的话就使用参数；否则使用一个默认值
 *var n=args.n?parseInt(args.n):10;
 */
function urlArgs() {
    var args = {}; //定义一个空对象
    var query = location.search.substring(1); //查找到查询串，并去掉&apos;?&apos;
    var pairs = query.split(&quot;&amp;&quot;); //根据&quot;&amp;&quot;符号将查询字符串分隔开
    for (var i = 0; i &lt; pairs.length; i++) { //对于每个片段
        var pos = pairs[i].indexOf(&apos;=&apos;); //查找&quot;name=value&quot;
        if (pos == -1) continue; //如果没有找到的话，就跳过
        var name = pairs[i].substring(0, pos); //提取name
        var value = pairs[i].substring(pos + 1); //提取value
        value = decodeURIComponent(value); //对value进行解码
        args[name] = value; //存储为属性
    }
    return args; //返回解析后的参数
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="获取纯文本的元素内容"><a href="#获取纯文本的元素内容" class="headerlink" title="获取纯文本的元素内容"></a>获取纯文本的元素内容</h2><pre><code>/**
 *一个参数，返回元素的textContent或innerText
 *两个参数，用value参数的值设置元素的textContent或innerText
 */
function textContent(element, value) {
    var content = element.textContent; //检测textContent是否有定义
    if (value === undefined) { //没传递value，因此返回当前文本
        if (content !== undefined) {
            return content;
        } else {
            return element.innerText;
        }
    } else { //传递了value，因此设置文本
        if (content !== undefined) {
            element.textContent = value;
        } else {
            element.innerText = value;
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="手写一个JSONP实现"><a href="#手写一个JSONP实现" class="headerlink" title="手写一个JSONP实现"></a>手写一个JSONP实现</h2><pre><code>//根据指定的URL发送一个JSONP请求
//然后把解析得到的响应数据传递给回调函数
//在URL中添加一个名为jsonp的查询参数，用于指定该请求的回调函数的名称
function getJSONP(url, callback) { //为本次请求创建一个唯一的回调函数名称
    var cbnum = &quot;cb&quot; + getJSONP.counter++; //每次自增计数器
    var cbname = &quot;getJSONP.&quot; + cbnum; //作为JSONP函数的属性
    //将回调函数名称以表单编码的形式添加到URL的查询部分中
    //使用jsonp作为参数名，一些支持JSONP的服务
    //可能使用其他的参数名，比如callback
    if (url.indexOf(&quot;?&quot;) === -1) //URL没有查询部分
        url += &quot;?jsonp=&quot; + cbname; //作为查询部分添加参数
    else //否则
        url += &quot;＆jsonp=&quot; + cbname; //作为新的参数添加它
    //创建script元素用于发送请求
    var script = document.createElement(&quot;script&quot;); //定义将被脚本执行的回调函数
    getJSONP[cbnum] = function (response) {
        try {
            callback(response); //处理响应数据
        } finally { //即使回调函数或响应抛出错误
            delete getJSONP[cbnum]; //删除该函数
            script.parentNode.removeChild(script); //移除script元素
        }
    }; //立即触发HTTP请求
    script.src = url; //设置脚本的URL
    document.body.appendChild(script); //把它添加到文档中
}
getJSONP.counter = 0; //用于创建唯一回调函数名称的计数器
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><pre><code>//将child节点插入到parent中，使其成为第n个子节点
function insertAt(parent, child, n) {
    if (n &lt; 0 || n &gt; parent.childNodes.length) {
        throw new Error(&quot;invalid index&quot;);
    } else if (n == parent.childNodes.length) {
        parent.appendChild(child);
    } else {
        parent.insertBefore(child, parent.childNodes[n]);
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用innerHTML实现outerHTML属性"><a href="#使用innerHTML实现outerHTML属性" class="headerlink" title="使用innerHTML实现outerHTML属性"></a>使用innerHTML实现outerHTML属性</h2><pre><code>//为那些不支持它的浏览器实现outerHTML属性
//假设浏览器确实支持innerHTML，并有个可扩展的Element.prototype，
//并且可以定义getter和setter
(function () { //如果outerHTML存在，则直接返回
    if (document.createElement(&quot;div&quot;).outerHTML) return; //返回this所引用元素的外部HTML
    function outerHTMLGetter() {
        var container = document.createElement(&quot;div&quot;); //虚拟元素
        container.appendChild(this.cloneNode(true)); //复制到该虚拟节点
        return container.innerHTML; //返回虚拟节点的innerHTML
    }
    //用指定的值设置元素的外部HTML
    function outerHTMLSetter(value) { //创建一个虚拟元素，设置其内容为指定的值
        var container = document.createElement(&quot;div&quot;);
        container.innerHTML = value; //将虚拟元素中的节点全部移动到文档中
        while (container.firstChild) //循环，直到container没有子节点为止
            this.parentNode.insertBefore(container.firstChild, this); //删除所被取代的节点
        this.parentNode.removeChild(this);
    }
    //现在使用这两个函数作为所有Element对象的outerHTML属性的getter和setter
    //如果它存在则使用ES5的Object.defineProperty()方法，
    //否则，退而求其次，使用__defineGetter__()和__defineSetter__()
    if (Object.defineProperty) {
        Object.defineProperty(Element.prototype, &quot;outerHTML&quot;, {
            get: outerHTMLGetter,
            set: outerHTMLSetter,
            enumerable: false,
            configurable: true
        });
    } else {
        Element.prototype.__defineGetter__(&quot;outerHTML&quot;, outerHTMLGetter);
        Element.prototype.__defineSetter__(&quot;outerHTML&quot;, outerHTMLSetter);
    }
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="倒序排列子节点"><a href="#倒序排列子节点" class="headerlink" title="倒序排列子节点"></a>倒序排列子节点</h2><pre><code>//倒序排列节点n的子节点
function reverse(n) { //创建一个DocumentFragment作为临时容器
    var f = document.createDocumentFragment(); //从后至前循环子节点，将每一个子节点移动到文档片段中
    //n的最后一个节点变成f的第一个节点，反之亦然
    //注意，给f添加一个节点，该节点自动地会从n中删除
    while (n.lastChild) f.appendChild(n.lastChild); //最后，把f的所有子节点一次性全部移回n中
    n.appendChild(f);
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询窗口滚动条的位置"><a href="#查询窗口滚动条的位置" class="headerlink" title="查询窗口滚动条的位置"></a>查询窗口滚动条的位置</h2><pre><code>//以一个对象的x和y属性的方式返回滚动条的偏移量
function getScrollOffsets(w) { //使用指定的窗口，如果不带参数则使用当前窗口
    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用
    if (w.pageXOffset != null) return {
        x: w.pageXOffset,
        y: w.pageYOffset
    }; //对标准模式下的IE（或任何浏览器）
    var d = w.document;
    if (document.compatMode == &quot;CSS1Compat&quot;)
        return {
            x: d.documentElement.scrollLeft,
            y: d.documentElement.scrollTop
        }; //对怪异模式下的浏览器
    return {
        x: d.body.scrollLeft,
        y: d.body.scrollTop
    };
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询窗口的视口尺寸"><a href="#查询窗口的视口尺寸" class="headerlink" title="查询窗口的视口尺寸"></a>查询窗口的视口尺寸</h2><pre><code>//作为一个对象的w和h属性返回视口的尺寸
function getViewportSize(w) { //使用指定的窗口，如果不带参数则使用当前窗口
    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用
    if (w.innerWidth != null) return {
        w: w.innerWidth,
        h: w.innerHeight
    }; //对标准模式下的IE（或任何浏览器）
    var d = w.document;
    if (document.compatMode == &quot;CSS1Compat&quot;)
        return {
            w: d.documentElement.clientWidth,
            h: d.documentElement.clientHeight
        }; //对怪异模式下的浏览器
    return {
        w: d.body.clientWidth,
        h: d.body.clientWidth
    };
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="返回函数的名字"><a href="#返回函数的名字" class="headerlink" title="返回函数的名字"></a>返回函数的名字</h2><pre><code>Function.prototype.getName = function () {
    return this.name || this.toString().match(/function\s*(\w*)\s*\(/)[1];
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="原生JS实现CSS动画1"><a href="#原生JS实现CSS动画1" class="headerlink" title="原生JS实现CSS动画1"></a>原生JS实现CSS动画1</h2><pre><code>//将e转化为相对定位的元素，使之左右&quot;震动&quot;
//第一个参数可以是元素对象或者元素的id
//如果第二个参数是函数，以e为参数，它将在动画结束时调用
//第三个参数指定e震动的距离，默认是5像素
//第四个参数指定震动多久，默认是500毫秒
function shake(e, oncomplete, distance, time) { //句柄参数
    if (typeof e === &quot;string&quot;) e = document.getElementById(e);
    if (!time) time = 500;
    if (!distance) distance = 5;
    var originalStyle = e.style.cssText; //保存e的原始style
    e.style.position = &quot;relative&quot;; //使e相对定位
    var start = (new Date()).getTime(); //注意，动画的开始时间
    animate(); //动画开始
    //函数检查消耗的时间，并更新e的位置
    //如果动画完成，它将e还原为原始状态
    //否则，它更新e的位置，安排它自身重新运行
    function animate() {
        var now = (new Date()).getTime(); //得到当前时间
        var elapsed = now - start; //从开始以来消耗了多长时间？
        var fraction = elapsed / time; //是总时间的几分之几？
        if (fraction &lt; 1) { //如果动画未完成
            //作为动画完成比例的函数，计算e的x位置
            //使用正弦函数将完成比例乘以4pi
            //所以，它来回往复两次
            var x = distance * Math.sin(fraction * 4 * Math.PI);
            e.style.left = x + &quot;px&quot;; //在25毫秒后或在总时间的最后尝试再次运行函数
            //目的是为了产生每秒40帧的动画
            setTimeout(animate, Math.min(25, time - elapsed));
        } else { //否则，动画完成
            e.style.cssText = originalStyle //恢复原始样式
            if (oncomplete) oncomplete(e); //调用完成后的回调函数
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="原生JS实现CSS动画2"><a href="#原生JS实现CSS动画2" class="headerlink" title="原生JS实现CSS动画2"></a>原生JS实现CSS动画2</h2><pre><code>function fadeOut(e, oncomplete, time) {
    if (typeof e === &quot;string&quot;) e = document.getElementById(e);
    if (!time) time = 500; //使用Math.sqrt作为一个简单的“缓动函数”来创建动画
    //精巧的非线性：一开始淡出得比较快，然后缓慢了一些
    var ease = Math.sqrt;
    var start = (new Date()).getTime(); //注意：动画开始的时间
    animate(); //动画开始
    function animate() {
        var elapsed = (new Date()).getTime() - start; //消耗的时间
        var fraction = elapsed / time; //总时间的几分之几？
        if (fraction &lt; 1) { //如果动画未完成
            var opacity = 1 - ease(fraction); //计算元素的不透明度
            e.style.opacity = String(opacity); //设置在e上
            setTimeout(animate, //调度下一帧
                Math.min(25, time - elapsed));
        } else { //否则，动画完成
            e.style.opacity = &quot;0&quot;; //使e完全透明
            if (oncomplete) oncomplete(e); //调用完成后的回调函数
        }
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="仿HTML5的classList属性"><a href="#仿HTML5的classList属性" class="headerlink" title="仿HTML5的classList属性"></a>仿HTML5的classList属性</h2><pre><code>/*
 *如果e有classList属性则返回它。否则，返回一个为e模拟DOMTokenList API的对象
 *返回的对象有contains()、add()、remove()、toggle()和toString()等方法
 *来检测和修改元素e的类集合。如果classList属性是原生支持的，
 *返回的类数组对象有length和数组索引属性。模拟DOMTokenList不是类数组对象，
 *但是它有一个toArray()方法来返回一个含元素类名的纯数组快照
 */
function classList(e) {
    if (e.classList) return e.classList; //如果e.classList存在，则返回它
    else return new CSSClassList(e); //否则，就伪造一个
}
//CSSClassList是一个模拟DOMTokenList的JavaScript类
function CSSClassList(e) {
    this.e = e;
} //如果e.className包含类名c则返回true否则返回false
CSSClassList.prototype.contains = function (c) { //检查c是否是合法的类名
    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)
        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //首先是常规检查
    var classes = this.e.className;
    if (!classes) return false; //e不含类名
    if (classes === c) return true; //e有一个完全匹配的类名
    //否则，把c自身看做一个单词，利用正则表达式搜索c
    //\b在正则表达式里代表单词的边界
    return classes.search(&quot;\\b&quot; + c + &quot;\\b&quot;) != -1;
}; //如果c不存在，将c添加到e.className中
CSSClassList.prototype.add = function (c) {
    if (this.contains(c)) return; //如果存在，什么都不做
    var classes = this.e.className;
    if (classes &amp;&amp; classes[classes.length - 1] != &quot;&quot;)
        c = &quot;&quot; + c; //如果需要加一个空格
    this.e.className += c; //将c添加到className中
}; //将在e.className中出现的所有c都删除
CSSClassList.prototype.remove = function (c) { //检查c是否是合法的类名
    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)
        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //将所有作为单词的c和多余的尾随空格全部删除
    var pattern = new RegExp(&quot;\\b&quot; + c + &quot;\\b\\s*&quot;, &quot;g&quot;);
    this.e.className = this.e.className.replace(pattern, &quot;&quot;);
}; //如果c不存在，将c添加到e.className中，并返回true
//否则，将在e.className中出现的所有c都删除，并返回false
CSSClassList.prototype.toggle = function (c) {
    if (this.contains(c)) { //如果e.className包含c
        this.remove(c); //删除它
        return false;
    } else { //否则
        this.add(c); //添加它
        return true;
    }
}; //返回e.className本身
CSSClassList.prototype.toString = function () {
    return this.e.className;
}; //返回在e.className中的类名
CSSClassList.prototype.toArray = function () {
    return this.e.className.match(/\b\w+\b/g) || [];
};
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查询纯文本形式的内容"><a href="#查询纯文本形式的内容" class="headerlink" title="查询纯文本形式的内容"></a>查询纯文本形式的内容</h2><pre><code>/**
 *一个参数，返回元素的textContent或innerText
 *两个参数，用value参数的值设置元素的textContent或innerText
 */
function textContent(element, value) {
    var content = element.textContent; //检测textContent是否有定义
    if (value === undefined) { //没传递value，因此返回当前文本
        if (content !== undefined) return content;
        else return element.innerText;
    } else { //传递了value，因此设置文本
        if (content !== undefined) element.textContent = value;
        else element.innerText = value;
    }
}
</code></pre><p>textContent属性在除了IE的所有当前的浏览器中都支持。在IE中，可以用Element的innerText属性来代替。 <a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="查找元素的后代中节点中的所有Text节点"><a href="#查找元素的后代中节点中的所有Text节点" class="headerlink" title="查找元素的后代中节点中的所有Text节点"></a>查找元素的后代中节点中的所有Text节点</h2><pre><code>//返回元素e的纯文本内容，递归进入其子元素
//该方法的效果类似于textContent属性
function textContent(e) {
    var child, type, s = &quot;&quot;; //s保存所有子节点的文本
    for (child = e.firstChild; child != null; child = child.nextSibling) {
        type = child.nodeType;
        if (type === 3 || type === 4) //Text和CDATASection节点
            s += child.nodeValue;
        else if (type === 1) //递归Element节点
            s += textContent(child);
    }
    return s;
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用innerHTML实现insertAdjacentHTML"><a href="#使用innerHTML实现insertAdjacentHTML" class="headerlink" title="使用innerHTML实现insertAdjacentHTML()"></a>使用innerHTML实现insertAdjacentHTML()</h2><pre><code>//本模块为不支持它的浏览器定义了Element.insertAdjacentHTML
//还定义了一些可移植的HTML插入函数，它们的名字比insertAdjacentHTML更符合逻辑：
//Insert.before()、Insert.after()、Insert.atStart()和Insert.atEnd()
var Insert = (function () { //如果元素有原生的insertAdjacentHTML，
    //在4个函数名更明了的HTML插入函数中使用它
    if (document.createElement(&quot;div&quot;).insertAdjacentHTML) {
        return {
            before: function (e, h) {
                e.insertAdjacentHTML(&quot;beforebegin&quot;, h);
            },
            after: function (e, h) {
                e.insertAdjacentHTML(&quot;afterend&quot;, h);
            },
            atStart: function (e, h) {
                e.insertAdjacentHTML(&quot;afterbegin&quot;, h);
            },
            atEnd: function (e, h) {
                e.insertAdjacentHTML(&quot;beforeend&quot;, h);
            }
        };
    }
    //否则，无原生的insertAdjacentHTML
    //实现同样的4个插入函数，并使用它们来定义insertAdjacentHTML
    //首先，定义一个工具函数，传入HTML字符串，返回一个DocumentFragment，
    //它包含了解析后的HTML的表示
    function fragment(html) {
        var elt = document.createElement(&quot;div&quot;); //创建空元素
        var frag = document.createDocumentFragment(); //创建空文档片段
        elt.innerHTML = html; //设置元素内容
        while (elt.firstChild) //移动所有的节点
            frag.appendChild(elt.firstChild); //从elt到frag
        return frag; //然后返回frag
    }
    var Insert = {
        before: function (elt, html) {
            elt.parentNode.insertBefore(fragment(html), elt);
        },
        after: function (elt, html) {
            elt.parentNode.insertBefore(fragment(html), elt.nextSibling);
        },
        atStart: function (elt, html) {
            elt.insertBefore(fragment(html), elt.firstChild);
        },
        atEnd: function (elt, html) {
            elt.appendChild(fragment(html));
        }
    }; //基于以上函数实现insertAdjacentHTML
    Element.prototype.insertAdjacentHTML = function (pos, html) {
        switch (pos.toLowerCase()) {
            case &quot;beforebegin&quot;:
                return Insert.before(this, html);
            case &quot;afterend&quot;:
                return Insert.after(this, html);
            case &quot;afterbegin&quot;:
                return Insert.atStart(this, html);
            case &quot;beforeend&quot;:
                return Insert.atEnd(this, html);
        }
    };
    return Insert; //最后返回4个插入函数
}());
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><pre><code>/**
 *Drag.js：拖动绝对定位的HTML元素
 *
 *这个模块定义了一个drag()函数，它用于mousedown事件处理程序的调用
 *随后的mousemove事件将移动指定元素，mouseup事件将终止拖动
 *这些实现能同标准和IE两种事件模型一起工作
 *
 *参数：
 *
 *elementToDrag：接收mousedown事件的元素或某些包含元素
 *它必须是定位的元素,元素的样式必须是行内样式
 *它的style.left和style.top值将随着用户的拖动而改变
 *
 *event：mousedown事件对象
 **/
function drag(elementToDrag, event) { //初始鼠标位置，转换为文档坐标
    var startX = event.clientX;
    var startY = event.clientY; //在文档坐标下，待拖动元素的初始位置
    //因为elementToDrag是绝对定位的，
    //所以我们可以假设它的offsetParent就是文档的body元素
    var origX = parseFloat(elementToDrag.style.left);
    var origY = parseFloat(elementToDrag.style.top); //计算mousedown事件和元素左上角之间的距离
    //我们将它另存为鼠标移动的距离
    if (document.addEventListener) { //标准事件模型
        //在document对象上注册捕获事件处理程序
        document.addEventListener(&quot;mousemove&quot;, moveHandler, true);
        document.addEventListener(&quot;mouseup&quot;, upHandler, true);
    } else if (document.attachEvent) { //用于IE5～8的IE事件模型
        //在IE事件模型中，
        //捕获事件是通过调用元素上的setCapture()捕获它们
        elementToDrag.setCapture();
        elementToDrag.attachEvent(&quot;onmousemove&quot;, moveHandler);
        elementToDrag.attachEvent(&quot;onmouseup&quot;, upHandler); //作为mouseup事件看待鼠标捕获的丢失
        elementToDrag.attachEvent(&quot;onlosecapture&quot;, upHandler);
    }
    //我们处理了这个事件，不让任何其他元素看到它
    if (event.stopPropagation) event.stopPropagation(); //标准模型
    else event.cancelBubble = true; //IE
    //现在阻止任何默认操作
    if (event.preventDefault) event.preventDefault(); //标准模型
    else event.returnValue = false; //IE
    /**
     * 当元素正在被拖动时， 这就是捕获mousemove事件的处理程序
     *它用于移动这个元素 
     **/
    function moveHandler(e) {
        if (!e) e = window.event; //IE事件模型
        //移动这个元素到当前鼠标位置，
        //通过滚动条的位置和初始单击的偏移量来调整
        var targetLeft = e.clientX - startX + origX;
        var targetTop = e.clientY - startY + origY;
        var minLeft = 0;
        var minTop = 0;
        var maxLeft = (document.documentElement.clientWidth || document.body.clientWidth) - elementToDrag.offsetWidth;
        var maxTop = (document.documentElement.clientHeight || document.body.clientHeight) - elementToDrag.offsetHeight;
        targetLeft = targetLeft &gt; maxLeft ? maxLeft : (targetLeft &lt; minLeft ? minLeft : targetLeft);
        targetTop = targetTop &gt; maxTop ? maxTop : (targetTop &lt; minTop ? minTop : targetTop);
        elementToDrag.style.left = targetLeft + &quot;px&quot;;
        elementToDrag.style.top = targetTop + &quot;px&quot;;
        if (e.stopPropagation) e.stopPropagation(); //标准
        else e.cancelBubble = true; //IE
    }
    /**
     *这是捕获在拖动结束时发生的最终mouseup事件的处理程序
     **/
    function upHandler(e) {
        if (!e) e = window.event; //IE事件模型
        //注销捕获事件处理程序
        if (document.removeEventListener) { //DOM事件模型
            document.removeEventListener(&quot;mouseup&quot;, upHandler, true);
            document.removeEventListener(&quot;mousemove&quot;, moveHandler, true);
        } else if (document.detachEvent) { //IE 5+事件模型
            elementToDrag.detachEvent(&quot;onlosecapture&quot;, upHandler);
            elementToDrag.detachEvent(&quot;onmouseup&quot;, upHandler);
            elementToDrag.detachEvent(&quot;onmousemove&quot;, moveHandler);
            elementToDrag.releaseCapture();
        }
        //并且不让事件进一步传播
        if (e.stopPropagation) e.stopPropagation(); //标准模型
        else e.cancelBubble = true; //IE
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在谷歌地图上显示地理位置信息"><a href="#在谷歌地图上显示地理位置信息" class="headerlink" title="在谷歌地图上显示地理位置信息"></a>在谷歌地图上显示地理位置信息</h2><pre><code>//获取当前位置然后通过Google地图显示
//如果当前浏览器不支持地理位置API，则抛出一个错误
function getmap() { //检查是否支持地理位置API
    if (!navigator.geolocation) throw &quot;Geolocation not supported&quot;; //开始请求地理位置信息，
    navigator.geolocation.getCurrentPosition(setMapURL);
    function setMapURL(pos) { //从参数对象（pos）中获取位置信息
        var latitude = pos.coords.latitude; //经度
        var longitude = pos.coords.longitude; //纬度
        var accuracy = pos.coords.accuracy; //米
        var scale = 10; //比例
        //构造一个URL，用于跳转到Google地图
        var url = &quot;https://www.google.com/maps/@&quot; + latitude + &quot;,&quot; + longitude + &quot;,&quot; + scale + &quot;z&quot;; //设置一个大致的缩放级别
        location = url;
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用所有地理位置特性"><a href="#使用所有地理位置特性" class="headerlink" title="使用所有地理位置特性"></a>使用所有地理位置特性</h2><pre><code>//异步的获取我的位置，并在指定的元素中展示出来
function whereami(elt) { //将此对象作为第三个参数传递给getCurrentPosition()方法
    var options = { //设置为true，表示如果可以的话
        //获取高精度的位置信息（例如，通过GPS获取）
        //但是，要注意的是，这会影响电池寿命
        enableHighAccuracy: false, //可以近似：这是默认值
        //如果获取缓存过的位置信息就足够的话，可以设置此属性
        //默认值为0,表示强制检查新的位置信息
        maximumAge: 300000, //5分钟左后
        //愿意等待多长时间来获取位置信息？
        //默认值为无限长 [2] ，getCurrentPosition()方法永不超时
        timeout: 15000 //不要超过15秒
    };
    if (navigator.geolocation) //如果支持的话，就获取位置信息
        navigator.geolocation.getCurrentPosition(success, error, options);
    else
        elt.innerHTMl = &quot;Geolocation not supported in this browser&quot;; //当获取位置信息失败的时候，会调用此函数

    function error(e) { //error对象包含一些数字编码和文本消息，如下所示：
        //1:用户不允许分享他/她的位置信息
        //2:浏览器无法确定位置
        //3:发生超时
        elt.innerHTML = &quot;Geolocation error&quot; + e.code + &quot;:&quot; + e.message;
    }
    //当获取位置信息成功的时候，会调用此函数
    function success(pos) { //总是可以获取如下这些字段
        //但是要注意的是时间戳信息在outer对象中，而不在inner、coords对象中
        var msg = &quot;时间是&quot; +
            new Date(pos.timestamp).toLocaleString() + &quot;地理位置是&quot; +
            pos.coords.accuracy + &quot;米范围内经度是&quot; +
            pos.coords.latitude + &quot;纬度是&quot; +
            pos.coords.longitude + &quot;.&quot;; //如果设备还返回了海拔信息，则将其添加进去
        if (pos.coords.altitude) {
            msg += &quot;海拔是&quot; + pos.coords.altitude + &quot;±&quot; +
                pos.coords.altitudeAccuracy + &quot;千米.&quot;;
        }
        //如果设备还返回了速度和航向信息，也将它们添加进去
        if (pos.coords.speed) {
            msg += &quot;速度是&quot; +
                pos.coords.speed + &quot;m/s方向是&quot; +
                pos.coords.heading + &quot;.&quot;;
        }
        elt.innerHTML = msg; //显示所有的位置信息
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="优雅的图片翻转实现"><a href="#优雅的图片翻转实现" class="headerlink" title="优雅的图片翻转实现"></a>优雅的图片翻转实现</h2><pre><code>/**
 *优雅的图片翻转实现方式
 *
 *要创建图片翻转效果，将此模块引入到HTML文件中
 *然后在任意＜img＞元素上使用data-rollover属性来指定翻转图片的URL即可
 *如下所示:
 *
 *&lt;img src=&quot;normal_image.png &quot;data-rollover=&quot;rollover_image.png&quot;&gt;
 *
 */
function changeImage() { //所有处理逻辑都在一个匿名函数中:不定义任何符号
    //遍历所有的图片，查找data-rollover属性
    for (var i = 0; i &lt; document.images.length; i++) {
        var img = document.images[i];
        var rollover = img.getAttribute(&quot;data-rollover&quot;);
        if (!rollover) continue; //跳过没有data-rollover属性的图片
        //确保将翻转的图片缓存起来
        (new Image()).src = rollover; //定义一个属性来标识默认的图片URL
        img.setAttribute(&quot;data-rollout&quot;, img.src); //注册事件处理函数来创建翻转效果
        img.onmouseover = function () {
            this.src = this.getAttribute(&quot;data-rollover&quot;);
        };
        img.onmouseout = function () {
            this.src = this.getAttribute(&quot;data-rollout&quot;);
        };
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用canvas绘制多边形"><a href="#使用canvas绘制多边形" class="headerlink" title="使用canvas绘制多边形"></a>使用canvas绘制多边形</h2><pre><code>//定义一个以(x,y)为中心，半径为r的规则n边形,c可以通过调用画布getContext()方法得到
//每个顶点都是均匀分布在圆周上
//将第一个顶点放置在最上面，或者指定一定角度
//除非最后一个参数是true，否则顺时针旋转
function polygon(c, n, x, y, r, angle, counterclockwise) {
    angle = angle || 0;
    counterclockwise = counterclockwise || false;
    c.moveTo(x + r * Math.sin(angle), //从第一个顶点开始一条新的子路径
        y - r * Math.cos(angle)); //使用三角法计算位置
    var delta = 2 * Math.PI / n; //两个顶点之间的夹角
    for (var i = 1; i &lt; n; i++) { //循环剩余的每个顶点
        angle += counterclockwise ? -delta : delta; //调整角度
        c.lineTo(x + r * Math.sin(angle), //以下个顶点为端点添加线段
            y - r * Math.cos(angle));
    }
    c.closePath(); //将最后一个顶点和起点连接起来
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="使用canvas绘制雪花"><a href="#使用canvas绘制雪花" class="headerlink" title="使用canvas绘制雪花"></a>使用canvas绘制雪花</h2><pre><code>var deg = Math.PI / 180; //用于角度制到弧度制的转换
//在画布的上下文c中，以左下角的点(x,y)和边长len，绘制一个n级别的科赫雪花分形
function snowflake(c, n, x, y, len) {
    c.save(); //保存当前变换
    c.translate(x, y); //变换原点为起始点
    c.moveTo(0, 0); //从新的原点开始一条新的子路径
    leg(n); //绘制雪花的第一条边
    c.rotate(-120 * deg); //现在沿着逆时针方向旋转120 o
    leg(n); //绘制第二条边
    c.rotate(-120 * deg); //再次旋转
    leg(n); //画最后一条边
    c.closePath(); //闭合子路径
    c.restore(); //恢复初始的变换
    //绘制n级别的科赫雪花的一条边
    //此函数在画完一条边的时候就离开当前点，
    //然后通过坐标系变换将当前点又转换成(0,0,)
    //这意味着画完一条边之后可以很简单地调用rotate()进行旋转
    function leg(n) {
        c.save(); //保存当前坐标系变换
        if (n == 0) { //不需要递归的情况下:
            c.lineTo(len, 0); //就绘制一条水平线段
        } else { //递归情况下：绘制4条子边，类似这个样子： - \/ -
            c.scale(1 / 3, 1 / 3); //子边长度为原边长的1/3
            leg(n - 1); //递归第一条子边
            c.rotate(60 * deg); //顺时针旋转60 o
            leg(n - 1); //第二条子边
            c.rotate(-120 * deg); //逆时针旋转120 o
            leg(n - 1); //第三条子边
            c.rotate(60 * deg); //通过旋转回到初始状态
            leg(n - 1); //最后一条边
        }
        c.restore(); //恢复坐标系变换
        c.translate(len, 0); //但是通过转换使得边的结束点为(0,0)
    }
}
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p>
<h2 id="在Web-Worker中发起同步XMLHtttpRequest"><a href="#在Web-Worker中发起同步XMLHtttpRequest" class="headerlink" title="在Web Worker中发起同步XMLHtttpRequest"></a>在Web Worker中发起同步XMLHtttpRequest</h2><pre><code>//此文件会通过一个新的Worker()来载入，因此，它是运行在独立的线程中的，
//可以放心地使用同步XMLHttpRequest API
//消息是URL数组的形式。以字符串形式同步获取每个URL指定的内容，
//并将这些字符串数组传递回去。
onmessage = function (e) {
    var urls = e.data; //输入：要获取的URL
    var contents = []; //输出：URL指定的内容
    for (var i = 0; i &lt; urls.length; i++) {
        var url = urls[i]; //每个URL
        var xhr = new XMLHttpRequest(); //开始一个HTTP请求
        xhr.open(&quot;GET&quot;, url, false); //false则表示进行同步请求
        xhr.send(); //阻塞住，一直到响应完成
        if (xhr.status !== 200) //如果请求失败则抛出错误
            throw Error(xhr.status + &quot; &quot; + xhr.statusText + &quot;: &quot; + url);
        contents.push(xhr.responseText); //否则，存储通过URL获取得到的内容
    }
    //最后，将这些URL内容以数组的形式传递回主线程
    postMessage(contents);
}
</code></pre><p>善于利用JS中的小技巧，不仅可以使代码更加简洁，而且逼格更高。</p>
<h2 id="使用-模拟Boolean-函数"><a href="#使用-模拟Boolean-函数" class="headerlink" title="使用!!模拟Boolean()函数"></a>使用!!模拟Boolean()函数</h2><p>原理：逻辑非操作一个数据对象时，会先将数据对象转换为布尔值，然后取反，两个!!重复取反，就实现了转换为布尔值的效果。</p>
<h2 id="使用一元加-模拟Number-函数"><a href="#使用一元加-模拟Number-函数" class="headerlink" title="使用一元加(+)模拟Number()函数"></a>使用一元加(+)模拟Number()函数</h2><p>原理：对非数值类型的数据使用一元加(+)，会起到与Number()函数相同的效果。</p>
<p>null转换为0</p>
<p>undefined转换为NaN</p>
<p>false转换为0，true转换为1</p>
<p>对于字符串： </p>
<p>空字串转换为0</p>
<p>含有数字或者浮点数或者十六进制格式的数据(11, 0.3, 0xfe等)，转换为相应的数值</p>
<p>含有其他格式字符，无法转换为数值的字符串，转换为NaN</p>
<p>对于对象，先调用valueOf()方法，在转换，若结果为NaN，那么再调用toString()方法，之后再转换</p>
<h2 id="使用逻辑与-amp-amp-进行短路操作"><a href="#使用逻辑与-amp-amp-进行短路操作" class="headerlink" title="使用逻辑与(&amp;&amp;)进行短路操作"></a>使用逻辑与(&amp;&amp;)进行短路操作</h2><pre><code>if(connected){
    login();
}
</code></pre><p>以上代码可以简写为:</p>
<p><code>connected &amp;&amp; login();</code></p>
<p>也可用这种方法来检查对象中是否拥有某个属性</p>
<pre><code>user &amp;&amp; user.name
</code></pre><p>原理：逻辑与(&amp;&amp;)会首先对第一个操作数进行求值，只有求值结果为true时才会对第二个操作数求值。connected &amp;&amp; login()中，若判断connected不为true,则不再进行下一步操作。<br>所谓的短路操作即第一个操作数可以决定结果，则不再对第二个操作数进行求值。</p>
<h2 id="使用逻辑或-设置默认值"><a href="#使用逻辑或-设置默认值" class="headerlink" title="使用逻辑或(||)设置默认值"></a>使用逻辑或(||)设置默认值</h2><p>逻辑或(||)也属于短路操作，即当第一个操作数可以决定结果时，不再对第二个操作数进行求值。利用这个特点，我们可以给赋值语句设置默认值。只有当第一个操作数为null或者undefined时，才会把第二个操作数赋值给目标。</p>
<pre><code>function User(name, age){
    this.name = name || &quot;Liming&quot;;
}
</code></pre><p>上述代码中，如果函数中没有传入name参数，name的值为undefined，那么就会给this.name赋值为”Liming”。<br>ES6中可以为函数设置默认值，所以这种方法可能要成为过去式，但是其他地方还是很有用的。<br>ES6 写法 简洁了许多</p>
<pre><code>let User = (name=&quot;Liming&quot;, age) =&gt; { }
</code></pre><h2 id="获取数组最后n个元素"><a href="#获取数组最后n个元素" class="headerlink" title="获取数组最后n个元素"></a>获取数组最后n个元素</h2><p>可以使用以下代码获取数组中最后n个元素</p>
<pre><code>var array = [1, 2, 3, 4, 5, 6];
console.log(array.slice(-1));  //[6]
console.log(array.slice(-2));  //[5, 6]
</code></pre><p>原理:Array.prototype.slice(begin,end)可以用来裁剪数组，第二个参数的默认值是数组的长度值。若值传入一个参数，则会返回从指定索引开始到数组结尾的所有值。<br>而slice()方法还可以接收负值，当传入负值时，会自动加上数组的长度值使其转换为正值，于是便得到了最后的n个值。</p>
<h2 id="合并大数组"><a href="#合并大数组" class="headerlink" title="合并大数组"></a>合并大数组</h2><p>常用的合并数组的方式是使用Array.concat()函数。该函数会创建一个新数组，将两个数组连接起来存储到新数组中，这会大量消耗内存。可以使用Array.push.apply(arr1, arr2)，它不会创建新数组，而是将第二个数组合并到第一个数组中，以减少内存的消耗。</p>
<pre><code>var a = [1,2];
var b = [3,4];
console.log(a.push.apply(a, b));      // [1,2,3,4]
//或者
Array.prototype.push.apply(a, b);      // a变成了[1,2,3,4]
console.log(a); //[1,2,3,4]
</code></pre><p>原理: Array.push()是在数组的末尾增加元素，但是如果使用a.push(b)会把整个数组b当作一个元素添加到数组a中。<br>而apply()方法，则允许将某个方法的参数以数组的形式传入，所以起到了将数组b中的元素追加到数组a中的效果。</p>
<h2 id="NodeList转换为数组"><a href="#NodeList转换为数组" class="headerlink" title="NodeList转换为数组"></a>NodeList转换为数组</h2><p>使用document.querySelectorAll(‘div’)返回的是NodeList对象，虽然它很像数组，但是并不能使用诸如sort()，filter()等方法。你可以将其转换为真正的数组。</p>
<pre><code>var eles = document.querySelectorAll(&apos;p&apos;);  //NodeList
var arrayElements = [].slice.call(eles);       //转化为数组
// 或者
var arrayElements = Array.prototype.slice.call(eles);
// 或者
var arrayElements = Array.from(eles); 
</code></pre><p>原理:</p>
<p>[].slice.call(eles):<br>首先创建了一个空数组[]，然后调用他的slice()方法，但是在slice()方法的执行中，把this对象指向了eles,所以会对eles进行裁减，由于对slice()方法没有传入参数，所以相当于slice(0,eles.length),会按照元长度返回一个数组。</p>
<p>Array.prototype.slice.call(eles): 原理与上面相似，只不过这次没有创建空数组，而是直接使用了原型中的方法 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


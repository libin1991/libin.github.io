<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/blog/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/blog/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="舞动乾坤">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="舞动乾坤">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="舞动乾坤">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/">





  <title>舞动乾坤 - 星光不问赶路人 岁月不负有心人</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
    	<div id="sky">
				<div id="background" class="container">
			<!-- svg file -->
			<svg id="svgout" height="100%" width="100%" viewbox="0 0 550 400">
				<defs>
					<g id="bottomShadow">
						<path fill="#000000" stroke="none" d="
		M 270.5 225.95
		L 127.35 316.65 266.8 400 409.6 309.25 270.5 225.95 Z"/>
					</g>
					<g id="Layer52_0_FILL">
						<path class="topGrass" fill="#B9D668" stroke="none" d="
	M 397.85 229.3
	L 397.85 225.6 269.85 152 135.75 228.6 135.75 233.65 262.1 306.55 397.85 229.3 Z"/>
					</g>
					<g id="Layer51_0_FILL">
						<path class="leftSideGrass" fill="#6E9E4F" stroke="none" d="
	M 135.1 229.95
	L 135.1 256.85 262.1 328.4 262.1 301.85 135.1 229.95 Z"/>
					</g>
					<g id="Layer50_0_FILL">
						<path class="rightGrassTop" fill="#8CB154" stroke="none" d="
	M 397.85 225.95
	L 395.8 225.95 261.75 301.55 261.75 328.4 397.85 251.15 397.85 225.95 Z"/>
					</g>
					<g id="Layer48_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.45 282.4
	L 135.75 298.15 262.1 372.1 261.75 355.65 135.45 282.4 Z"/>
					</g>
					<g id="Layer47_0_FILL">
						<path class="middleLeftCrust" fill="#C77E61" stroke="none" d="
	M 135.1 270.3
	L 135.1 283.05 275.9 364.35 271.85 348.9 135.1 270.3 Z"/>
					</g>
					<g id="Layer46_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.1 255.15
	L 135.1 270.3 262.1 343.55 262.1 328.05 135.1 255.15 Z"/>
					</g>
					<g id="Layer45_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 294.5
	L 397.5 277 261.75 355.3 261.75 372.75 397.5 294.5 Z"/>
					</g>
					<g id="Layer44_0_FILL">
						<path class="middleRightCrust" fill="#C89451" stroke="none" d="
	M 397.5 269.95
	L 397.15 266.6 262.1 343.2 262.1 355.95 397.5 279.7 397.5 269.95 Z"/>
					</g>
					<g id="Layer43_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 266.6
	L 397.5 250.45 261.75 328.4 261.75 343.85 397.5 266.6 Z"/>
					</g>
					<g id="Layer41_0_FILL">
						<path class="greyRoad" fill="#B2B2B1" stroke="none" d="
	M 295.05 283.05
	Q 299.05 280.35 308.45 275.3 317.85 269.95 323.6 266.9
	L 268.8 233.65 338.05 191.35 309.15 174.55 177.75 254.5
	Q 191.55 262.2 198.25 266.25 204.65 269.95 209.7 271.95
	L 241.6 250.45 295.05 283.05 Z"/>
					</g>
					<g id="Layer40_0_FILL">
						<path fill="#FFFFFF" stroke="none" d="
	M 199.95 256.85
	Q 194.55 261.2 191.9 262.2
	L 194.9 263.9 200.95 259.2 199.95 256.85
	M 225.8 243.75
	L 224.8 241.75 211.05 250.8 212.05 252.8 225.8 243.75
	M 308.15 275.65
	L 296.7 266.6 295.35 268.6 306.8 277.7 308.15 275.65
	M 275.9 253.5
	L 274.55 255.5 285.95 264.55 287.3 262.55 275.9 253.5
	M 251.7 227.3
	L 250.7 225.25 236.9 234.35 237.9 236.35 251.7 227.3
	M 257.05 240.7
	L 254.05 240.7 268.8 249.8 269.5 247.75 257.05 240.7
	M 277.2 207.8
	L 263.45 216.85 264.45 218.9 278.25 209.8 277.2 207.8
	M 305.1 192.65
	L 304.1 190.65 290.3 199.75 291.35 201.75 305.1 192.65 Z"/>
					</g>
					<g id="Layer38_0_FILL">
						<path class="frontFascia" fill="#ECB27B" stroke="none" d="
	M 359.25 187.95
	L 346.4 174.95 333.85 202.9 359.25 187.95 Z"/>
					</g>
					<g id="Layer37_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 334 201.05
	L 334.35 232 359.2 217.55 359.25 187.95 334 201.05 Z"/>
					</g>
					<g id="Layer36_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 334.35 232.3
	L 334.35 205.1 305.1 191.35 305.1 216.85 334.35 232.3 Z"/>
					</g>
					<g id="Layer35_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 329.7 167.9
	L 331.05 167.9 344.55 176.7 347.85 176.7 363 192.25 363.15 189.55 350.65 176.7 350.55 176.7 334.25 167.5 334.25 159.1 329.7 159.1 329.7 164.9 322.65 160.95 322.3 162.15 329.7 167 329.7 167.9 Z"/>
					</g>
					<g id="Layer34_0_FILL">
						<path class="leftRoof" fill="#F2563B" stroke="none" d="
	M 334.05 207.05
	L 350.65 176.7 322.1 160.45 302.1 192.05 334.05 207.05 Z"/>
					</g>
					<g id="Layer30_0_FILL">
						<path id="windowFour" class="windows" stroke="none" fill="#975A42" d="
	M 341.35 203.3
	Q 340.9 203.45 340.5 203.8 340.1 204.2 339.85 204.75 339.7 205 339.7 205.3 339.6 205.75 339.7 206.1 339.7 206.15 339.7 206.2 339.8 206.5 340 206.8 340.55 207.4 341.45 207.4 342.35 207.4 343 206.8 343.4 206.5 343.65 206.1 343.85 205.75 343.95 205.3 344.05 204.4 343.55 203.8 343.3 203.45 343 203.3 342.65 203.15 342.2 203.15 341.8 203.15 341.35 203.3
	M 355.85 198.45
	Q 355.8 198.2 355.6 198 355.1 197.4 354.2 197.4 353.35 197.4 352.6 198 351.85 198.65 351.7 199.55 351.7 199.7 351.7 199.85 351.6 200.5 352 201.05 352.55 201.65 353.45 201.65 354.3 201.65 355.05 201.05 355.45 200.7 355.7 200.25 355.8 200.05 355.9 199.85 355.95 199.7 355.95 199.55 356.05 198.95 355.85 198.45 Z"/>
						<path class="door" fill="#B65041" stroke="none" d="
	M 351.95 211.2
	L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2
	M 351.2 211.2
	L 351.35 211.2 351.35 211.1 351.2 211.2 Z"/>
					</g>
					<g>
						<path id="Layer30_0_FILL" fill="#000000" fill-opacity="1" stroke="none" d="
	M 183.7 215.3
	L 183.7 215.6
	Q 187.25 231.75 212.25 234.35
	L 183.7 215.3 Z"/>
					</g>
					<g id="Layer29_0_FILL">
						<path fill="#000000" fill-opacity="0.4" stroke="none" d="
	M 305.1 216.85
	L 305.15 217.2
	Q 309.45 233.2 334.35 232.3
	L 305.1 216.85 Z"/>
					</g>
					<g id="Layer27_0_FILL">
						<path class="vegetation" fill="#78A950" stroke="none" d="
	M 177.45 231.65
	Q 175.75 235.35 181.8 239.35 185.5 235.7 185.15 231.3 182.8 230.65 181.45 234 179.45 231.3 177.45 231.65
	M 236.9 266.6
	Q 235.2 270.3 241.25 274.3 244.95 270.6 244.65 266.25 242.3 265.6 240.95 268.95 238.9 266.25 236.9 266.6
	M 254.7 277
	Q 253.05 280.7 259.1 284.75 262.75 281.05 262.45 276.65 260.1 276 258.75 279.35 256.7 276.65 254.7 277
	M 315.5 245.75
	Q 313.5 243.05 311.5 243.4 309.8 247.1 315.85 251.15 319.55 247.45 319.2 243.05 316.85 242.4 315.5 245.75
	M 295.35 232.65
	Q 293.7 236.35 299.75 240.4 303.45 236.7 303.1 232.3 300.75 231.65 299.4 235 297.4 232.3 295.35 232.65
	M 277.2 171.85
	Q 275.55 175.55 281.6 179.55 285.3 175.85 284.95 171.5 282.6 170.85 281.25 174.2 279.25 171.5 277.2 171.85 Z"/>
					</g>
					<g id="Layer26_0_FILL">
						<path class="treeWood" fill="#AE663D" stroke="none" d="
	M 175.1 177.55
	L 172.05 177.55 172.05 191.1 159.3 172.85
	Q 154.6 171.5 172.05 195.7
	L 172.05 212.5 175.1 212.5 175.1 177.55
	M 252.7 151.35
	L 249 151.35 249 176.9 252.7 176.9 252.7 151.35 Z"/>
					</g>
					<g id="Layer25_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 192.55 179.55
	Q 200.95 173.5 200.95 165.1 200.95 156.4 192.55 150 184.15 144.3 172.05 144.3 160.3 144.3 151.9 150 143.15 156.4 143.15 165.1 143.15 173.5 151.9 179.55 160.3 185.95 172.05 185.95 184.15 185.95 192.55 179.55
	M 236.25 106.65
	Q 230.2 116.05 230.2 129.15 230.2 142.25 236.25 151.35 242.3 160.75 250.7 160.75 258.75 160.75 264.8 151.35 270.85 142.25 270.85 129.15 270.85 116.05 264.8 106.65 258.75 97.6 250.7 97.6 242.3 97.6 236.25 106.65 Z"/>
					</g>
					<g id="Layer24_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 158.3 221.9
	Q 160.65 221.9 161.95 220.2 163 219.55 163.3 218.55 164.65 218.9 166.35 218.9 170.05 218.9 172.4 216.2 175.1 213.85 175.1 210.15 175.1 206.45 172.4 203.75 170.05 201.4 166.35 201.4 162.65 201.4 159.95 203.75 157.6 206.45 157.6 210.15 157.6 210.8 157.6 211.15 155.95 211.5 154.6 212.5 152.9 214.15 152.9 216.55 152.9 218.9 154.6 220.2 156.25 221.9 158.3 221.9
	M 338.35 240.05
	Q 341.05 237.7 341.05 234 341.05 230.3 338.35 227.6 336 225.25 332.3 225.25 328.65 225.25 325.95 227.6 323.6 230.3 323.6 234 323.6 237.7 325.95 240.05 328.65 242.75 332.3 242.75 336 242.75 338.35 240.05 Z"/>
					</g>
					<g id="Layer22_0_FILL">
						<path class="rightRoof" fill="#D05041" stroke="none" d="
	M 220 173.85
	L 236.8 186.7 264.35 171.15 244.5 159.55 220 173.85 Z"/>
					</g>
					<g id="Layer21_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 212.25 191.35
	L 183.35 172.3 183.7 215.3 212.25 234.35 212.25 191.35 Z"/>
					</g>
					<g id="Layer20_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 192.1 149.85
	L 236.45 174.8 243.1 171.4
	Q 220.05 150.55 196.3 139.95
	L 192.1 149.85 Z"/>
					</g>
					<g id="Layer19_0_FILL">
						<path class="frontFascia" fill="#EBB17B" stroke="none" d="
	M 226.85 160.95
	L 212 190.6 229.75 192.6 239.75 172.85 226.85 160.95 Z"/>
					</g>
					<g id="Layer18_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 240.15 172.65
	L 211.9 191.6 212.25 233.65 264.35 201.7 264.35 170.8 240.8 184.45 240.15 172.65 Z"/>
					</g>
					<g id="Layer17_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 210.9 142.2
	L 205.9 142.2 205.9 152.65 210.9 152.65 210.9 142.2 Z"/>
					</g>
					<g>
						<path id="Layer16_0_FILL" class="leftRoof" fill="#F2563B" stroke="none" d="
	M 210.25 195.5
	L 227.4 160.95 195.45 141.35 177.65 175.85 210.25 195.5 Z"/>
					</g>
					<g>
						<path id="sun" fill="#E3BD0E" stroke="none" d="
	M 257.05 15.95
	Q 251.7 15.95 248 19.65 244.3 23.35 244.3 28.7 244.3 34.1 248 37.8 251.7 41.5 257.05 41.5 262.45 41.5 266.15 37.8 269.85 34.1 269.85 28.7 269.85 23.35 266.15 19.65 262.45 15.95 257.05 15.95 Z"/>
					</g>
					<g id="Layer8_0_FILL">
						<path fill="#975A42" stroke="none" d="
	M 238.45 189.65
	Q 238.295703125 189.362109375 238.05 189.1 237.35 188.3 236.2 188.3 235.05 188.3 234.15 189.1 233.3 189.9 233.2 191.05 233.1 192.2 233.8 193 234.55 193.8 235.7 193.8 236.85 193.8 237.7 193 238.1970703125 192.558203125 238.45 192 238.6552734375 191.56484375 238.7 191.05 238.7671875 190.276953125 238.45 189.65
	M 220.55 197.55
	Q 220 197.55 219.5 197.75 218.95 197.95 218.5 198.35 217.933203125 198.8833984375 217.7 199.55 217.5833984375 199.916796875 217.55 200.3 217.4923828125 200.96171875 217.7 201.5 217.852734375 201.9103515625 218.15 202.25 218.95 203.05 220.1 203.05 221.25 203.05 222.05 202.25 222.95 201.45 223.05 200.3 223.15 199.15 222.4 198.35 222.05 197.95 221.65 197.75 221.15 197.55 220.55 197.55 Z"/>
					</g>
					<g id="Layer7_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 233.55 206.75
	L 225.9 211.95 226.25 225.5 233.95 220.35 233.55 206.75 Z"/>
					</g>
					<g>
						<path id="windowOne" class="windows" fill="#975A42" stroke="none" d="
	M 188.65 198.4
	L 188.8 204.1 198.65 210.45 198.55 204.75 188.65 198.4
	M 208.45 216.8
	L 208.35 211.1 198.55 204.75 198.65 210.45 208.45 216.8
	M 188.8 204.1
	L 188.95 209.8 198.8 216.15 198.65 210.45 188.8 204.1
	M 208.6 222.5
	L 208.45 216.8 198.65 210.45 198.8 216.15 208.6 222.5 Z"/>
					</g>
					<g>
						<path id="windowThree" class="windows" fill="#975A42" stroke="none" d="
	M 311.7 214.1
	L 318.55 217.55 318.45 211.9 311.6 208.45 311.7 214.1
	M 325.4 221
	L 325.25 215.35 318.45 211.9 318.55 217.55 325.4 221
	M 318.4 206.2
	L 311.5 202.75 311.6 208.45 318.45 211.9 318.4 206.2
	M 325.25 215.35
	L 325.2 209.7 318.4 206.2 318.45 211.9 325.25 215.35 Z"/>
					</g>
					<g id="Layer2_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 259.7 183.25
	L 244.6 191.9 244.6 213.8 259.7 204.55 259.7 183.25 Z"/>
					</g>
					<path id="windowTwo" fill="#975A42" class="windows" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" d="
	M 223.05 200.3
	Q 222.95 201.45 222.05 202.25 221.25 203.05 220.1 203.05 218.95 203.05 218.15 202.25 217.852734375 201.9103515625 217.7 201.5 217.4923828125 200.96171875 217.55 200.3 217.5833984375 199.916796875 217.7 199.575 217.933203125 198.8833984375 218.5 198.35 218.95 197.95 219.5 197.75 220 197.55 220.55 197.55 221.15 197.55 221.65 197.75 222.05 197.95 222.4 198.35 223.15 199.15 223.05 200.3 Z
	M 238.7 191.05
	Q 238.6552734375 191.56484375 238.45 192 238.1970703125 192.558203125 237.7 193 236.85 193.8 235.7 193.8 234.55 193.8 233.8 193 233.1 192.2 233.2 191.05 233.3 189.9 234.15 189.1 235.05 188.3 236.2 188.3 237.35 188.3 238.05 189.1 238.295703125 189.362109375 238.45 189.65 238.7671875 190.276953125 238.7 191.05 Z"/>
					<path fill="#F2563B" stroke="none" d=" M 351.95 211.2 L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2 Z"/>
					<path id="Layer6_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 198.55 204.75
	L 208.35 211.1 208.45 216.8 208.6 222.5 198.8 216.15 188.95 209.8 188.8 204.1 188.65 198.4 198.55 204.75 198.65 210.45 208.45 216.8
	M 198.8 216.15
	L 198.65 210.45 188.8 204.1"/>
					<path id="Layer5_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 325.25 215.35
	L 325.4 221 318.55 217.55 311.7 214.1 311.6 208.45 311.5 202.75 318.4 206.2 325.2 209.7 325.25 215.35 318.45 211.9 318.55 217.55
	M 318.4 206.2
	L 318.45 211.9 311.6 208.45"/>
				</defs>
				<g id="shadow">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use xlink:href="#bottomShadow"/>
					</g>
				</g>
				<g transform="matrix( 1, 0, 0, 1, 0,0) ">
					<use xlink:href="#sun"/>
				</g>
				<g id="earth">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer52_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer51_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer50_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer48_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer47_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer46_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer45_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer44_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer43_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer41_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer40_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer38_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer37_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer36_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer35_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer34_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowFour"/>
						<use class="element" xlink:href="#Layer32_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer30_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer27_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer26_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer25_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer24_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer22_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer21_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer20_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer19_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer18_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer17_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer16_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer8_0_FILL"/>
						<use class="element" xlink:href="#windowTwo"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer7_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowOne"/>
						<use class="element" xlink:href="#Layer6_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowThree"/>
						<use class="element" xlink:href="#Layer5_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer2_0_FILL"/>
					</g>
				</g>
			</svg>
			<! -- End of SVG file -->
			<! -- Moon/Sun Toggle -->
			<div id="toggleButton" class="day-toggle">
				<div class="sun-icon"></div>
				<label class="switch">
            <input id="toggleCheckbox" type="checkbox">
            <div class="slider"></div>
        </label>
				<div class="cloud-icon"></div>
			</div>
			<! -- Moon/Sun Toggle -->
			<! -- End of Container -->
		</div>
			</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">舞动乾坤</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">星光不问赶路人 岁月不负有心人</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/blog/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/08/11/Raect-异步加载组件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/11/Raect-异步加载组件/" itemprop="url">React 异步加载组件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-11T23:09:27+08:00">
                2018-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先需要知道的是dynamic import通过返回Promise的方式实现异步加载功能。</p>
<pre><code>import(&apos;./component.js&apos;)  
    .then((m) =&gt; {
        // 处理异步加载到的模块m
    })
    .catch((err) =&gt; {
        // 错误处理
    });
</code></pre><p>要注意的是import的参数不能使用变量，简单原则是至少要让Webpack知晓应该预先加载哪些内容。这里的参数除了使用常量之外，还可以使用模板字符串<code>componentDir/${name}.js</code>。</p>
<p>其实到这里基本完成代码切割了，接下来做得就是结合react-router实现按模块异步加载。这是跟业务代码相关的，因此每个人的做法都是不一样的。所以以下代码仅供参考。</p>
<p>异步加载</p>
<p>我参考react-router的例子写了个简单的异步加载组件AsyncLoader.js，内容：</p>
<pre><code>import React from &apos;react&apos;;

export default class AsyncLoader extends React.Component {

  static propTypes = {
    path: React.PropTypes.string.isRequired,
    loading: React.PropTypes.element,
  };

  static defaultProps = {
    path: &apos;&apos;,
    loading: &lt;p&gt;Loading...&lt;/p&gt;,
    error: &lt;p&gt;Error&lt;/p&gt;
  };

  constructor(props) {
    super(props);
    this.state = {
      module: null
    };
  }

  componentWillMount() {
    this.load(this.props);
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.path !== this.props.path
      || nextProps.error !== this.props.error
      || nextProps.loading !== this.props.loading) {
      this.load(nextProps);
    }
  }

  load(props) {

    this.setState({module: props.loading});

    // TODO：异步代码的路径希望做成可以配置的方式
    import(`./path/${props.path}`)
      .then((m) =&gt; {
        let Module = m.default ? m.default : m;
        console.log(&quot;module: &quot;, Module);
        this.setState({module: &lt;Module/&gt;});
      }).catch(() =&gt; {
        this.setState({module: props.error});
      });
  }

  render() {
    return this.state.module;
  }
}
</code></pre><p>使用方法</p>
<pre><code>&lt;Route  
    exact path=&apos;/book&apos; 
    render={()=&gt;&lt;AsyncLoader path={&apos;./components/Book.js&apos;}/&gt;} 
/&gt;
</code></pre><p>Webpack打包的时候会根据import的参数生成相应的js文件，默认使用id（webpack生成的，从0开始）命名这个文件。</p>
<pre><code>const Search = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;search&quot; */ &quot;./containers/Search/SearchContainer&quot;))
const BookList = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;bookList&quot; */ &quot;./containers/BookList/BookListContainer&quot;))


import React from &apos;react&apos;
export const asyncComponent = loadComponent =&gt; (
    class AsyncComponent extends React.Component {
        state = {
            Component: null,
        }

        componentWillMount() {
            if (this.hasLoadedComponent()) {
                return;
            }

            loadComponent()
                .then(module =&gt; module.default) ////兼容 module.default ? module.default : module
                .then((Component) =&gt; {
                    this.setState({ Component });
                })
                .catch((err) =&gt; {
                    console.error(`Cannot load component in &lt;AsyncComponent /&gt;`);
                    throw err;
                });
        }

        hasLoadedComponent() {
            return this.state.Component !== null;
        }

        render() {
            const { Component } = this.state;
            return (Component) ? &lt;Component {...this.props} /&gt; : null;
        }
    }
); 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/08/04/JS面试之数组对象解构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/04/JS面试之数组对象解构/" itemprop="url">JS面试之数组对象解构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-04T21:25:38+08:00">
                2018-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构:"></a>数组解构:</h3><blockquote>
<p>将 destructuringArray([1, [2, 3], 4], “[a, [b], c]”) =&gt; {a: 1, b: 2, c: 4}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 将 destructuringArray([1, [2, 3], 4], &quot;[a, [b], c]&quot;) =&gt; &#123;a: 1, b: 2, c: 4&#125;</span><br><span class="line">const targetArray = [1, [2, 3], 4];</span><br><span class="line">const formater = &quot;[a, [b], c]&quot;;</span><br><span class="line"></span><br><span class="line">const destructuringArray = (values, keys) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const obj = &#123;&#125;;</span><br><span class="line">    if (typeof keys === &apos;string&apos;) &#123;</span><br><span class="line">      keys = JSON.parse(keys.replace(/\w+/g, &apos;&quot;$&amp;&quot;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const iterate = (values, keys) =&gt;</span><br><span class="line">      keys.forEach((key, i) =&gt; &#123;</span><br><span class="line">        if(Array.isArray(key)) iterate(values[i], key)</span><br><span class="line">        else obj[key] = values[i]</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    iterate(values, keys)</span><br><span class="line">    </span><br><span class="line">    return obj;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><blockquote>
<p>实现一个get函数，使得下面的调用可以输出正确的结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;);</span><br><span class="line">// [ &apos;FE Coder&apos;, 1, &apos;byted&apos;]</span><br></pre></td></tr></table></figure>
<p>乍眼一看，这不就是实现一个lodash.get方法吗？看上去好像很简单。所以我就开始写了第一个版本。思想其实很简单，遍历传进来的参数，使用split将每一个参数分隔开，然后遍历取值，最终返回结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	return args.map((item) =&gt; &#123;</span><br><span class="line">		const paths = item.split(&apos;.&apos;);</span><br><span class="line">		let res = data;</span><br><span class="line">		paths.map(path =&gt; res = res[path]);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">	selector: &#123;</span><br><span class="line">		to: &#123;</span><br><span class="line">			toutiao: &quot;FE Coder&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	target: [1, 2, &#123;</span><br><span class="line">		name: &apos;byted&apos;</span><br><span class="line">	&#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get(obj, ...list) &#123;</span><br><span class="line">	return list.map((item) =&gt; &#123;</span><br><span class="line">		return item.split(&quot;.&quot;).reduce((a = &#123;&#125;, b) =&gt; &#123;</span><br><span class="line">			if(/\[([0-9])\]/g.test(b))&#123;</span><br><span class="line">				var c=/(\w+)\[([0-9])\]/g.exec(b)</span><br><span class="line">				return a[c[1]]&amp;&amp;a[c[1]][c[2]]</span><br><span class="line">			&#125;</span><br><span class="line">			return a[b]</span><br><span class="line">		&#125;, obj)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line">get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;)</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;));</span><br></pre></td></tr></table></figure>
<p>一运行，果不其然，报错了。<br>后来仔细看了一下提供的测试代码，发现居然有target[0]这种东西。。居然还带了个数组索引。<br> 冷静分析一下，对于后面带了个索引的类型，比如’target[0]’,我们肯定是要特殊对待的。所以，我们首先得先识别到这种特殊的类型，然后再对它进行额外处理。</p>
<p>这个时候，很快的就可以想到使用正则表达式来做这个事情。为什么呢？因为像这种带有索引的类型，他们都有一个特色，就是有固定的格式：[num]，那么我们只需要能构造出可以匹配这种固定格式的正则，就可以解决这个问题。</p>
<p>对于这种格式，不难想到可以用这个正则表达式来做判断：/[[0-9]+]/gi，可是我们还需要将匹配值取出来。这个时候查了下正则表达式的文档(<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString%2Fmatch" target="_blank" rel="noopener">文档点击这里</a>)，发现有一个match方法，可以返回匹配成功的结果。那么就让我们来做个测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\[[0-9]+\]/gi;</span><br><span class="line">const str = &quot;target[123123]&quot;;</span><br><span class="line">const str1 = &quot;target[]&quot;</span><br><span class="line">if (reg.test(str)) &#123;</span><br><span class="line">    console.log(&apos;test success&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!reg.test(str1)) &#123;</span><br><span class="line">    console.log(&apos;test fail&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const matchResult = str.match(reg);</span><br><span class="line">console.log(matchResult); // [&quot;[123123]&quot;]</span><br></pre></td></tr></table></figure></p>
<p>诶，我们现在已经找到了解决这种问题的方法，那让我们赶紧来继续改进下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	const reg = /\[[0-9]+\]/gi;</span><br><span class="line">	return args.map((item) =&gt; &#123;</span><br><span class="line">		const paths = item.split(&apos;.&apos;);</span><br><span class="line">		let res = data;</span><br><span class="line">		paths.map((path) =&gt; &#123;</span><br><span class="line">                  if (reg.test(path)) &#123;</span><br><span class="line">                    const match = path.match(reg)[0];</span><br><span class="line">                    // 将target[0]里的target储存到cmd里</span><br><span class="line">                    const cmd = path.replace(match, &apos;&apos;);</span><br><span class="line">                    // 获取数组索引</span><br><span class="line">                    const arrIndex = match.replace(/[\[\]]/gi, &apos;&apos;);</span><br><span class="line">                    res = res[cmd][arrIndex];</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    res = res[path];</span><br><span class="line">                  &#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;));</span><br></pre></td></tr></table></figure></p>
<p>写完赶紧运行一下，完美，输出了正确的结果了。那么到这里就结束了?</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>可是总感觉有点不妥，感觉事情没有那么简单。一般来说，面试题除了考验你解决问题的能力之外，可能还考验着你思考问题的全面性、严谨性。像上面那种写法，<br>如果用户传入了一个不存在的path链或者一些其他特殊情况，就可能导致整个程序crash掉。想下lodash.get调用方式，<br>即使你传入了错误的path，他也可以帮你做处理，并且返回一个undefined。因此，我们还需要完善这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	const reg = /\[[0-9]+\]/gi;</span><br><span class="line">	return args.map((item) =&gt; &#123;</span><br><span class="line">		const paths = item.split(&apos;.&apos;);</span><br><span class="line">		let res = data;</span><br><span class="line">		paths.map(path =&gt; &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				if (reg.test(path)) &#123;</span><br><span class="line">					const match = path.match(reg)[0];</span><br><span class="line">					const cmd = path.replace(match, &apos;&apos;);</span><br><span class="line">					const arrIndex = match.replace(/[\[\]]/gi, &apos;&apos;);</span><br><span class="line">					res = res[cmd][arrIndex];</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					res = res[path];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; catch (err) &#123;</span><br><span class="line">				console.error(err);</span><br><span class="line">				res = undefined;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		return res;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们对每一个path的处理进行了try catch处理。若出错了，则返回undefined。哇，这样看起来就比较稳了。</p>
<p><strong>那么，有没有别的解决方法呢？</strong></p>
<p>群里有一个大佬提出了一种更简单也很取巧的解决方案，就是通过构建一个Function解决这个问题(Function的详细介绍点击<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction" target="_blank" rel="noopener">这里</a>)。由于代码很简单，我就直接贴出来了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	const res = JSON.stringify(data);</span><br><span class="line">	return args.map((item) =&gt; (new Function(`try &#123;return $&#123;res&#125;.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;, &apos;asd&apos;));</span><br></pre></td></tr></table></figure></p>
<p>看完之后，就两个字，牛逼。<br> 这种方法我承认一开始我确实没想到，确实是很奇技淫巧。不过仔细思考了下，其实很多框架都用到了这个奇技淫巧。比如说vue里，就使用new Function的方式来动态创建函数，解决执行动态生成的代码的问题。<br><img src="/2018/08/04/JS面试之数组对象解构/1.webp" alt=""><br>再比如说，Function.prototype.bind方法里(我写了个类似的bind方法:<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fchenjigeng%2Fsomething%2Fblob%2Fmaster%2Fbind%2Fbind.js" target="_blank" rel="noopener">仓库</a>)，也使用了Function来解决一些问题(fn.length丢失问题)。说明这个东西还是挺有用的，得学习了解一波，说不定哪天就用到了。<br><img src="/2018/08/04/JS面试之数组对象解构/2.webp" alt=""><br><strong>更新</strong></p>
<p>有人提到了那种Function的方式没办法处理以下的处理:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;time : new Date(), a : &quot;this is a&quot;, b : 30&#125;;</span><br></pre></td></tr></table></figure></p>
<p>因为JSON.stringfy后，Date、Function和RegExp类型的变量都会失效。对于这种情况，评论区有个大佬(<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fu%2Ffenghengzhi%2Fabout" target="_blank" rel="noopener">冯恒智</a>)也提到了一种很好的解决方案:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; (new Function(&apos;data&apos;,`try &#123;return data.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，另一种解决方案，就是将”target[0]”分为两个key，也很简单粗暴，就是将在split之前，将字符串里的’[‘替换为’.’,将’]’直接去掉。这样就可以将”target[0]”变为”target.0”。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; &#123;</span><br><span class="line">				let res = data;</span><br><span class="line">				item</span><br><span class="line">					.replace(/\[/g, &quot;.&quot;)</span><br><span class="line">					.replace(/\]/g, &quot;&quot;)</span><br><span class="line">					.split(&apos;.&apos;)</span><br><span class="line">					.map(path =&gt; res = res &amp;&amp; res[path]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而且这两种方式的好处在于，它也可以处理多维数组的情况。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学习完之后，最重要就是要总结，只有总结下来了，知识才是你自己的。那么我来总结下文章想表达的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">	const res = JSON.stringify(data);</span><br><span class="line">	return args.map((item) =&gt; (new Function(`try &#123;return $&#123;res&#125;.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;, &apos;asd&apos;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get1(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; (new Function(&apos;data&apos;,`try &#123;return data.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get2(data, ...args) &#123;</span><br><span class="line">  return args.map(item =&gt; &#123;</span><br><span class="line">    const reg = /\[([0-9])\]/g;</span><br><span class="line">    if (reg.test(item)) &#123;</span><br><span class="line">      item = item.replace(reg, &apos;.$1&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    const paths = item.split(&apos;.&apos;);</span><br><span class="line">    return paths.reduce((result, current) =&gt; &#123;</span><br><span class="line">      return result[current];</span><br><span class="line">    &#125;, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const get3 = (obj, ...args) =&gt; args.map(key =&gt; eval(`obj.$&#123;key&#125;`));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get4(obj, ...list) &#123;   //自己实现</span><br><span class="line">	return list.map((item) =&gt; &#123;</span><br><span class="line">		return item.split(&quot;.&quot;).reduce((a = &#123;&#125;, b) =&gt; &#123;</span><br><span class="line">			if(/\[([0-9])\]/g.test(b))&#123;</span><br><span class="line">				var c=/(\w+)\[([0-9])\]/g.exec(b)</span><br><span class="line">				return a[c[1]]&amp;&amp;a[c[1]][c[2]]</span><br><span class="line">			&#125;</span><br><span class="line">			return a[b]</span><br><span class="line">		&#125;, obj)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get4(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>对于具有固定格式的字符串，可以考虑使用正则表达式来识别和匹配。</li>
<li>实现一个功能的时候，不要只考虑正常情况，要多考虑一些非正常情况，比如输入格式不对、用户不按套路来或者因为一些奇奇怪怪的事情报错。并且能对可预见的非正常情况做一个容错处理。</li>
<li>有时候还是可以多学习了解一下一些黑科技(比如Function)，说不定哪天就可以用它来解决问题。</li>
</ol>
<h3 id="一道面试题引起的思考"><a href="#一道面试题引起的思考" class="headerlink" title="一道面试题引起的思考"></a><a href="https://juejin.im/post/5bf769e0518825773a2ebfe5" target="_blank" rel="noopener">一道面试题引起的思考</a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/08/03/JS获取深层次属性-一道很经典的面试题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/08/03/JS获取深层次属性-一道很经典的面试题/" itemprop="url">js获取深层次属性,一道很经典的面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-03T21:09:05+08:00">
                2018-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："><a href="#题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：" class="headerlink" title="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："></a>题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="string">'ScriptOJ'</span> &#125; &#125; &#125;</span><br><span class="line">data.a.b.c <span class="comment">// = scriptoj</span></span><br><span class="line">data.a.b.c.d <span class="comment">// = 报错，代码停止执行console.log('ScriptOJ') // = 不会被执行</span></span><br></pre></td></tr></table></figure>
<p>请你完成一个 safeGet 函数，可以安全的获取无限多层次的数据，一旦数据不存在不会报错，会返回 undefined，<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="string">'ScriptOJ'</span> &#125; &#125; &#125;</span><br><span class="line">safeGet(data, <span class="string">'a.b.c'</span>) <span class="comment">// = scriptoj</span></span><br><span class="line">safeGet(data, <span class="string">'a.b.c.d'</span>) <span class="comment">// = 返回 undefined</span></span><br><span class="line">safeGet(data, <span class="string">'a.b.c.d.e.f.g'</span>) <span class="comment">// = 返回 undefined</span></span><br></pre></td></tr></table></figure></p>
<p> 答案1：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> safeGet = (o, path) = &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.split(<span class="string">'.'</span>).reduce((o, k) = o[k], o)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 答案2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeGet</span>(<span class="params">o, path</span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> path.split(<span class="string">'.'</span>).reduce((o=&#123;&#125;,b)=&#123;   <span class="comment">//用到参数默认值</span></span><br><span class="line">     </span><br><span class="line">      <span class="keyword">return</span> o[b]  </span><br><span class="line">   &#125;,o)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="shvl"><a href="#shvl" class="headerlink" title="shvl"></a>shvl</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save shvl</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span> (<span class="params">object, path, def</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (object = (path.split ? path.split(<span class="string">'.'</span>) : path).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">obj, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; obj[p]</span><br><span class="line">  &#125;, object)) === <span class="literal">undefined</span> ? def : object;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span>  (<span class="params">object, path, val, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((path = path.split ? path.split(<span class="string">'.'</span>) : path).slice(<span class="number">0</span>, <span class="number">-1</span>).reduce(<span class="function"><span class="keyword">function</span> (<span class="params">obj, p</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[p] = obj[p] || &#123;&#125;;</span><br><span class="line">  &#125;, obj = object)[path.pop()] = val), object;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="USE"><a href="#USE" class="headerlink" title="USE"></a>USE</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> shvl <span class="keyword">from</span> <span class="string">'shvl'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: <span class="number">1</span></span><br><span class="line">            d: <span class="literal">undefined</span></span><br><span class="line">            e: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Use dot notation for keys</span></span><br><span class="line">shvl.set(obj, <span class="string">'a.b.c'</span>, <span class="number">2</span>);</span><br><span class="line">shvl.get(obj, <span class="string">'a.b.c'</span>) === <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Or use an array as key</span></span><br><span class="line">shvl.get(obj, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) === <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Returns undefined if the path does not exist and no default is specified</span></span><br><span class="line">shvl.get(obj, <span class="string">'a.b.c.f'</span>) === <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.b = [<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">this</span>.a];</span><br><span class="line"><span class="keyword">this</span>.c = &#123; <span class="attr">demo</span>: <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a , <span class="keyword">this</span>.b , <span class="keyword">this</span>.c.demo );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.b.push(<span class="keyword">this</span>.a);</span><br><span class="line"><span class="keyword">this</span>.a = <span class="keyword">this</span>.b.length;</span><br><span class="line"><span class="keyword">this</span>.c.demo = <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); </span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">parent.show();<span class="comment">//Q1</span></span><br><span class="line">child1.show();<span class="comment">//Q2</span></span><br><span class="line">child2.show();<span class="comment">//Q3</span></span><br><span class="line"></span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line"></span><br><span class="line">parent.show();<span class="comment">//Q4</span></span><br><span class="line">child1.show();<span class="comment">//Q5</span></span><br><span class="line">child2.show();<span class="comment">//Q6</span></span><br></pre></td></tr></table></figure>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li><p>原型链的查找规则</p>
<ul>
<li>当实例上存在属性时， 用实例上的</li>
<li>如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的</li>
<li>如果原型链都不存在，就用Object原型对象上的</li>
<li>如果Object原型对象都不存在， 就是undefined</li>
</ul>
</li>
<li>数组和字面量对象都是引用</li>
<li><p>this指向在引用时确认而不是定义时</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>下面分别模拟Q1-Q6的执行情况</p>
<h5 id="Q1："><a href="#Q1：" class="headerlink" title="Q1："></a>Q1：</h5><p>直接调用<code>parent.show()</code>,此时this指向parent,语句中的三条语句相当于分别在给window对象上赋值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.a = <span class="number">1</span>;</span><br><span class="line">parent.b = [<span class="number">1</span>, <span class="number">2</span>, parent.a];</span><br><span class="line">parent.c = &#123; <span class="attr">demo</span>: <span class="number">8</span> &#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 此时，parent对象应为：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">a:<span class="number">1</span>,</span><br><span class="line">b:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">c:&#123;</span><br><span class="line">demo:<span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Q2"><a href="#Q2" class="headerlink" title="Q2:"></a>Q2:</h5><p> 在执行<code>var child1 = new Child();</code>语句时，child对象的a值为2，而因为后被手动赋值为11，所以child实例上的a被改为11，这时调用原型链上的<code>show()</code>方法，依次打印,</p>
<p> 这里<code>this.a</code>根据原型链的查找规则，在实例上有a的赋值，所以直接使用实例上的值也就是11，其他值实例上没有，需要在原型上寻找，所以输出b为<code>[1,2,this.a]</code>,</p>
<p> 而这里的this.b因为是数组，为引用类型，在执行<code>var parent = new Parent();</code>时被定义在parent实例上，所有this.a的指针指向共同的引用地址，所以为1 ,</p>
<p> this.c因为也是引用类型，指针也被指向共同的引用对象地址。</p>
<h5 id="Q3："><a href="#Q3：" class="headerlink" title="Q3："></a>Q3：</h5><p> 实例上的a被重新赋值，所以<code>this.a</code>的输出被改为12，其余执行步骤同Q2。</p>
<h5 id="Q4："><a href="#Q4：" class="headerlink" title="Q4："></a>Q4：</h5><p> 相当于再次调用parent实例上的show方法，因为数据没有发生变动，所以输出值同Q1。</p>
<h5 id="Q5："><a href="#Q5：" class="headerlink" title="Q5："></a>Q5：</h5><p> 因为在调用<code>this.change</code>时，this.a的值被赋值为this.b数组的长度，所有这里的a输出为4，this.b的值使用引用地址b数组，因为在下一步中又执行了一次对this.b数组的push，所以这里打印this.b是被push两次后的数组，而this.c也是被push两次后的数组的长度，注意因为this.a和this.c的数据类型不同，所以this.a是单独的内存，而this.c则是使用相同一块内存。</p>
<h5 id="Q6"><a href="#Q6" class="headerlink" title="Q6:"></a>Q6:</h5><p> 又对this.b数组执行了一次push，所以这次this.a的输出应为数组的当前长度也就是5，this.c的值也是数组长度也就是5。</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p> 在chrome控制台中运行代码得到结果如下：</p>
<p> <img src="https://user-images.githubusercontent.com/29997411/50052858-bca89400-0165-11e9-866f-baa5371500b6.jpg" alt="jietu20181216-183105"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/30/关于-ES6-中-Promise-的面试题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/30/关于-ES6-中-Promise-的面试题/" itemprop="url">关于 ES6 中 Promise 的面试题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-30T20:16:20+08:00">
                2018-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>最近在复习 Promise 的知识，所以就做了一些题，这里挑出几道题，大家一起看看吧。</p>
<h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><pre><code>const promise = newPromise((resolve, reject) =&gt; {
    console.log(1);
    resolve();
    console.log(2);
})

promise.then(() =&gt; {
    console.log(3);
})

console.log(4);
</code></pre><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>首先 Promise 新建后立即执行，所以会先输出 1，2，而 <code>Promise.then()</code> 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3。</p>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><pre><code>1243
</code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><pre><code>const promise = newPromise((resolve, reject) =&gt; {
    resolve(&apos;success1&apos;);
    reject(&apos;error&apos;);
    resolve(&apos;success2&apos;);
});

promise.then((res) =&gt; {
    console.log(&apos;then:&apos;, res);
}).catch((err) =&gt; {
    console.log(&apos;catch:&apos;, err);
})
</code></pre><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p><code>resolve 函数</code>将 Promise 对象的状态从<code>“未完成”变为“成功”</code>（即从 <code>pending 变为 resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p>
<p><code>reject 函数</code>将 Promise 对象的状态从<code>“未完成”变为“失败”</code>（即从 <code>pending 变为 rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>而一旦状态改变，就不会再变。<br>所以 代码中的<code>reject(&#39;error&#39;);</code> 不会有作用。</p>
<p>Promise 只能 resolve 一次，剩下的调用都会被忽略。<br>所以 第二次的 <code>resolve(&#39;success2&#39;);</code> 也不会有作用。</p>
<h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><pre><code>then: success1
</code></pre><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><pre><code>Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
</code></pre><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p><code>Promise.resolve</code> 方法的参数如果是一个原始值，或者是一个不具有 <code>then</code> 方法的对象，则 <code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为<code>resolved</code>，<code>Promise.resolve</code> 方法的参数，会同时传给回调函数。</p>
<p><code>then</code> 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 <code>then(null)</code>，这就会导致前一个 <code>Promise</code> 的结果会穿透下面。</p>
<h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><pre><code>1
</code></pre><h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promse实现）三个亮灯函数已经存在：</p>
<pre><code>functionred() {
    console.log(&apos;red&apos;);
}
functiongreen() {
    console.log(&apos;green&apos;);
}
functionyellow() {
    console.log(&apos;yellow&apos;);
}
</code></pre><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，意思就是3秒，执行一次 red 函数，2秒执行一次 green 函数，1秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以就利用递归来实现。</p>
<h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><pre><code>functionred() {
    console.log(&apos;red&apos;);
}
functiongreen() {
    console.log(&apos;green&apos;);
}
functionyellow() {
    console.log(&apos;yellow&apos;);
}

var light = function (timmer, cb) {
    returnnewPromise(function (resolve, reject) {
        setTimeout(function () {
            cb();
            resolve();
        }, timmer);
    });
};

var step = function () {
    Promise.resolve().then(function () {
        return light(3000, red);
    }).then(function () {
        return light(2000, green);
    }).then(function () {
        return light(1000, yellow);
    }).then(function () {
        step();
    });
}

step();
</code></pre><p>这个答案，看上去已经很不错了，不过经小伙伴提醒，如果一直这么递归下去，会有栈溢出的问题，对于这个问题，其他小伙伴有什么优化建议的话，可以在评论区展示出来。</p>
<h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><p>实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。</p>
<pre><code>const timeout = ms =&gt;newPromise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve();
    }, ms);
});

const ajax1 = () =&gt; timeout(2000).then(() =&gt; {
    console.log(&apos;1&apos;);
    return1;
});

const ajax2 = () =&gt; timeout(1000).then(() =&gt; {
    console.log(&apos;2&apos;);
    return2;
});

const ajax3 = () =&gt; timeout(2000).then(() =&gt; {
    console.log(&apos;3&apos;);
    return3;
});

const mergePromise = ajaxArray =&gt; {
    // 在这里实现你的代码

};

mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; {
    console.log(&apos;done&apos;);
    console.log(data); // data 为 [1, 2, 3]
});

// 要求分别输出// 1// 2// 3// done// [1, 2, 3]
</code></pre><h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><p>首先 <code>ajax1 、ajax2、ajax3</code> 都是函数，只是这些函数执行后会返回一个 <code>Promise</code>，按题目的要求我们只要顺序执行这三个函数就好了，然后把结果放到 <code>data</code> 中，但是这些函数里都是异步操作，想要按顺序执行，然后输出 1，2，3并没有那么简单，看个例子。</p>
<pre><code>functionA() {
    setTimeout(function () {
        console.log(&apos;a&apos;);
    }, 3000);
}

functionB() {
    setTimeout(function () {
        console.log(&apos;b&apos;);
    }, 1000);
}

A();
B();

// b// a
</code></pre><p>例子中我们是按顺序执行的 <code>A</code>，<code>B</code> 但是输出的结果却是 <code>b</code>，<code>a</code> 对于这些异步函数来说，并不会按顺序执行完一个，再执行后一个。<br>这道题就是考用 <code>Promise</code> 控制异步流程，我们要想办法，让这些函数，一个执行完之后，再执行下一个，看答案吧。</p>
<h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><pre><code>// 保存数组中的函数执行后的结果var data = [];

// Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。var sequence = Promise.resolve();

ajaxArray.forEach(function (item) {
    // 第一次的 then 方法用来执行数组中的每个函数，// 第二次的 then 方法接受数组中的函数执行后返回的结果，// 并把结果添加到 data 中，然后把 data 返回。
    sequence = sequence.then(item).then(function (res) {
        data.push(res);
        return data;
    });
})

// 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。return sequence;
</code></pre><h3 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h3><p>以下代码最后输出什么？</p>
<pre><code>const first = () =&gt; (newPromise((resolve, reject) =&gt; {
    console.log(3);
    let p = newPromise((resolve, reject) =&gt; {
        console.log(7);
        setTimeout(() =&gt; {
            console.log(5);
            resolve(6);
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) =&gt; {
        console.log(arg);
    });

}));

first().then((arg) =&gt; {
    console.log(arg);
});
console.log(4);
</code></pre><h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><p>这道题就其实和 <code>Promise</code> 的关系不太大，主要是需要理解 JS执行机制，才能很好的解决这道题，对于 JS 执行机制不了解的朋友推荐看看这篇文章</p>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p>
<h4 id="第一轮事件循环"><a href="#第一轮事件循环" class="headerlink" title="第一轮事件循环"></a>第一轮事件循环</h4><p>先执行宏任务，主script ，new Promise立即执行，输出【3】，</p>
<p>执行 p 这个new Promise 操作，输出【7】，</p>
<p>发现 setTimeout，将回调放入下一轮任务队列（Event Queue），p 的 then，姑且叫做 then1，放入微任务队列，发现 first 的 then，叫 then2，放入微任务队列。执行<code>console.log(4)</code>，输出【4】，宏任务执行结束。</p>
<p>再执行微任务，执行 then1，输出【1】，</p>
<p>执行 then2，输出【2】。</p>
<p>到此为止，第一轮事件循环结束。开始执行第二轮。</p>
<h4 id="第二轮事件循环"><a href="#第二轮事件循环" class="headerlink" title="第二轮事件循环"></a>第二轮事件循环</h4><p>先执行宏任务里面的，也就是 setTimeout 的回调，输出【5】。<br><code>resolve(6)</code> 不会生效，因为 p 这个 Promise 的状态一旦改变就不会在改变了。</p>
<h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><pre><code>374125
</code></pre><h3 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h3><p>有 8 个图片资源的 url，已经存储在数组 <code>urls</code> 中（即<code>urls = [&#39;http://example.com/1.jpg&#39;, ...., &#39;http://example.com/8.jpg&#39;]）</code>，而且已经有一个函数 <code>function loadImg</code>，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。<br>但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。<br>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p>
<pre><code>var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;];
functionloadImg(url) {
    returnnewPromise((resolve, reject) =&gt; {
        const img = new Image()
        img.onload = function () {
            console.log(&apos;一张图片加载完成&apos;);
            resolve();
        }
        img.onerror = reject
        img.src = url
    })
};
</code></pre><h3 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h3><p>题目的意思是需要我们这么做，先并发请求 3 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 3 个，直到需要加载的图片都全部发起请求。</p>
<p>用 Promise 来实现就是，先并发请求3个图片资源，这样可以得到 3 个 Promise，组成一个数组，就叫<code>promises</code> 吧，然后不断的调用 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise%23Promise-race" target="_blank" rel="noopener">Promise.race</a> 来返回最快改变状态的 Promise，然后从数组（<code>promises</code>）中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 url 被取完，最后再使用 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise%23Promise-all" target="_blank" rel="noopener">Promise.all</a> 来处理一遍数组（<code>promises</code>）中没有改变状态的 Promise。</p>
<h3 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h3><pre><code>var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;];
functionloadImg(url) {
    returnnewPromise((resolve, reject) =&gt; {
        const img = new Image()
        img.onload = function () {
            console.log(&apos;一张图片加载完成&apos;);
            resolve();
        }
        img.onerror = reject
        img.src = url
    })
};

functionlimitLoad(urls, handler, limit) {
    // 对数组做一个拷贝const sequence = [].concat(urls)
    let promises = [];

    //并发请求到最大数
    promises = sequence.splice(0, limit).map((url, index) =&gt; {
        // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标return handler(url).then(() =&gt; {
            return index
        }); 
    });

    // 利用数组的 reduce 方法来以队列的形式执行return sequence.reduce((last, url, currentIndex) =&gt; {
        return last.then(() =&gt; {
            // 返回最快改变状态的 PromisereturnPromise.race(promises)
        }).catch(err =&gt; {
            // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误// 更重要的是防止中断整个链式调用console.error(err)
        }).then((res) =&gt; {
            // 用新的 Promise 替换掉最快改变状态的 Promise
            promises[res] = handler(sequence[currentIndex]).then(() =&gt; { return res });
        })
    }, Promise.resolve()).then(() =&gt; {
        returnPromise.all(promises)
    })

}
limitLoad(urls, loadImg, 3)

/*
因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用

limitLoad(urls, loadImg, 3).then(() =&gt; {
    console.log(&apos;所有图片加载完成&apos;);
}).catch(err =&gt; {
    console.error(err);
})
*/
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/07/02/Vue安全权限控制axios拦截/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/07/02/Vue安全权限控制axios拦截/" itemprop="url">Vue安全权限控制axios拦截</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T22:57:53+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>何为权限控制</p>
<pre><code>//请求失败后的统一拦截，以及ajax的基本设置
import axios from &apos;axios&apos;;
import qs from &apos;qs&apos;;

function cleanRequest(req) {
  for (const i in req) {
    /* eslint guard-for-in: 0 */
    if (req[i] !== 0 &amp;&amp; !req[i]) {
      delete req[i];
    }
  }
}

axios.defaults.withCredentials = true;
axios.defaults.xsrfCookieName = null;
axios.defaults.headers.common[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos;;
axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;
//系统弹层
import Toast from &apos;mint-ui/lib/toast&apos;;
import &apos;mint-ui/lib/toast/style.css&apos;;

module.exports.install = function (Vue) {
  axios.defaults.baseURL=&quot;/&quot;;
  Vue.prototype.$http = axios;
  Vue.http = axios;

  axios.interceptors.request.use(
    function (request) {
      const params = request.params;
      if (params) {
        cleanRequest(params);
      }
      if (request.data) {
        cleanRequest(request.data);
        request.data=qs.stringify(Object.assign(request.data,Bus.movieConfig))
      }else{
        request.data=qs.stringify(Bus.movieConfig)
      }
      return request;
    },
    function (error) {
      return Promise.reject(error);
    }
  );

  // Add a response interceptor
  axios.interceptors.response.use(
    function (response) {
      return response;
    },
    function (error) {
      Toast(&apos;系统繁忙，请稍后重试!&apos;);
      // Do something with response error
      return Promise.reject(error);
    }
  );
};
</code></pre><p>权限控制大致分为两个维度:</p>
<ul>
<li>垂直维度: 控制用户可以访问哪些url的权限</li>
<li>水平维度: 控制用户访问特定url，获取哪些数据的权限（e.g. 普通用户、管理员、超级管理员访问同一url，获取的数据是不同的）</li>
</ul>
<p>Web权限控制方案List</p>
<ul>
<li>前后端不分离：以Java为例，后端通过jsp、freemark、thmeleaf等模板来渲染相应权限的数据，渲染完呈现在浏览器端</li>
<li>前后端分离：<br>▫SPA单页面应用，路由由前端控制，前端通过js控制hash路由的权限<br>▫SSR服务端渲染，Node中间层做代理路由，判断权限渲染特定的路由至浏览器端</li>
</ul>
<p>SPA前端权限控制方案</p>
<p>SPA: 单页Web应用（single page web application）将所有web活动局限于一个html页面中，利用js通过hash或者浏览器history api来实现无刷新路由跳转，前后端通过ajax数据通信，避免了浏览器的刷新重新加载，为用户提供流程的操作体验。这意味着前端接管了路由层，需要通过调用前端自身的MVC模块，来渲染不同的页面。</p>
<blockquote>
<p>Base on：</p>
</blockquote>
<ul>
<li>Vue 前端MVVM框架</li>
<li>Vuex 状态管理机</li>
<li>Vue-router 路由</li>
<li>Axios HTTP请求库</li>
</ul>
<p>1.登陆事件Login</p>
<pre><code>// 1.触发登陆事件
dispatch(&apos;login&apos;)

// actions
commit(types.LOGIN_SUCCESS, res.data.data)
...
</code></pre><p>2.获取Token，经Base64编码后存至sessionStorage</p>
<pre><code>// mutations
const mutations = {
    [types.LOGIN_SUCCESS] (state, data) {
        state.authlock = false
    // 2.登陆成功回调拿到token,经Base64 编码后存入本地sessionStorage
        let token = Base64.encode(data + &apos;:HIKDATAE&apos;)
        sessionStorage.setItem(&apos;userToken&apos;, token)
    // 路由跳转至目标页面
        router.push({name: &apos;xxx&apos;})
    },
    [types.LOGOUT_SUCCESS] (state) {
        state.authlock = true
    // 登出成功回调,移除本地token
        sessionStorage.removeItem(&apos;userToken&apos;)
        router.push({name: &apos;Login&apos;})
    }
}
</code></pre><p>3.所有HTTP Header Authorization 加上编码后的token(前后端可约定规则)</p>
<pre><code>// Axios 请求钩子（request）
axios.interceptors.request.use(req =&gt; {
    let token = sessionStorage.getItem(&apos;user&apos;)     
    if (token) {         
        // 3.token 存在,则在之后所有请求的http请求头 Authorization 带上base64编码后的token,后台拿到token后进行验证权限         
        req.headers.Authorization = `Basic ${token}`     
    }
    req.data = qs.stringify(req.data)     
    return req 
}, error =&gt; {
    return Promise.reject(error) 
})
</code></pre><p>浏览器http header<br><img src="https://pic4.zhimg.com/v2-48ee52913451d66397f33a47f6af3374_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-48ee52913451d66397f33a47f6af3374_hd.jpg" alt=""></p>
<p>4.请求拦截：后台拿到token后对每个请求进行校验，若校验失败返回401，前端response钩子里统一catch error 跳转至登陆页面。</p>
<pre><code>// Axios 请求钩子（response）
axios.interceptors.response.use(res =&gt; {
    return res
}, error =&gt; {
    if (error.response) {
        switch (error.response.status) {
        // 4.所有接口response校验钩子,若token检验失败,后台返回 401 error code, 清除token信息并跳转到登录页面
            case 401:
                store.commit(types.LOGOUT)
                router.replace({
                    path: &apos;/login&apos;
        })
    }
    }
    return Promise.reject(error)
})
</code></pre><p>5.路由跳转拦截：任意路由跳转时，在路由beforeEach钩子里校验本地是否存在token，若没有，则跳转至登陆页面</p>
<pre><code>// 路由钩子(每个路由跳转前调起beforeEach钩子)
router.beforeEach((to, from, next) =&gt; {
  if (to.path === &apos;/login&apos;) {
    sessionStorage.removeItem(&apos;userToken&apos;)
  }
  let user = sessionStorage.getItem(&apos;userToken&apos;)
  if (!user &amp;&amp; to.path !== &apos;/login&apos;) {
    // 若本地token不存在,则任意路由跳转的时候,重定向至login 登陆页面
    next({ path: &apos;/login&apos; })
  } else {
    next()
  }
})
</code></pre><p>6.登出Logout：清楚本地sessionStorage的token信息</p>
<pre><code>// mutations
const mutations = {
    ...
    [types.LOGOUT_SUCCESS] (state) {
        state.authlock = true
    // 登出成功回调,移除本地token
        sessionStorage.removeItem(&apos;userToken&apos;)
    router.push({name: &apos;Login&apos;})
    }
}
</code></pre><p>流程示意图如下:<br><img src="https://pic2.zhimg.com/v2-064f7b05f15399ac9ff6aa03ee1cb710_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-064f7b05f15399ac9ff6aa03ee1cb710_hd.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/06/21/移动端设置了overflow-hidden和border-radius，子元素超出部分不隐藏问题？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/21/移动端设置了overflow-hidden和border-radius，子元素超出部分不隐藏问题？/" itemprop="url">移动端设置了overflow:hidden和border-radius，子元素超出部分不隐藏问题？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T14:41:09+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;
        &lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; href=&quot;css/SB.css&quot; /&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .main {
                width: 300px;
                height: 100px;
                border: 1px solid red;
                border-radius: 15px;
                overflow: hidden;
                /*transform:rotate(0deg); */
            }

            .con {
                display: block;
                overflow: scroll;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
                white-space: nowrap;
                font-size: 0px;
            }

            .item {
                width: 100px;
                height: 100px;
                background: green;
                display: inline-block;
                position: relative;
            }

            .item:nth-child(2n) {
                background: red;
            }
            .item p{
                width: 50px;
                height: 20px;
                color: white;
                text-align: center;
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 0px;
                background: blue;
                font-size: 12px;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div class=&quot;main&quot;&gt;
            &lt;div class=&quot;con&quot;&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
                &lt;div class=&quot;item&quot;&gt;
                    &lt;p&gt;快点&lt;/p&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;

&lt;/html&gt;
复制代码
</code></pre><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d69655dafdb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d6a28737a214?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>解决办法：</p>
<pre><code>.main {
                width: 300px;
                height: 100px;
                border: 1px solid red;
                border-radius: 15px;
                overflow: hidden;
                transform:rotate(0deg);  /*transform: scale(1);也可以*/
            }
复制代码
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d6b547a6dd86?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/06/03/JavaScript的事件循环/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/06/03/JavaScript的事件循环/" itemprop="url">JavaScript的事件循环</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T11:15:38+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Node-js-事件循环一-浅析"><a href="#Node-js-事件循环一-浅析" class="headerlink" title="Node.js 事件循环一: 浅析"></a>Node.js 事件循环一: 浅析</h2><blockquote>
<p>理解事件循环系列第一步 浅析和总览</p>
</blockquote>
<p>多数的网站不需要大量计算，程序花费的时间主要集中在磁盘 I/O 和网络 I/O 上面</p>
<p>SSD读取很快，但和CPU处理指令的速度比起来也不在一个数量级上，而且网络上一个数据包来回的时间更慢：</p>
<p><img src="https://pic1.zhimg.com/v2-67a42368c7dffa3348730760c9c0b907_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-67a42368c7dffa3348730760c9c0b907_hd.jpg" alt=""></p>
<p>一个数据包来回的延迟平均320ms(我网速慢，ping国内网站会更快)，这段时间内一个普通 cpu 执行几千万个周期应该没问题</p>
<p>因此异步IO就要发挥作用了，比如用多线程，如果用 Java 去读一个文件，这是一个阻塞的操作，在等待数据返回的过程中什么也干不了，因此就开一个新的线程来处理文件读取，读取操作结束后再去通知主线程。</p>
<p>这样虽然行得通，但是代码写起来比较麻烦。像 Node.js V8 这种无法开一个线程的怎么办？</p>
<p>先看下面函数执行过程</p>
<h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>当我们调用一个函数，它的地址、参数、局部变量都会压入到一个 stack 中</p>
<pre><code>function fire() {
    const result = sumSqrt(3, 4)
    console.log(result);
}
function sumSqrt(x, y) {
    const s1 = square(x)
    const s2 = square(y)
    const sum = s1 + s2;
    return Math.sqrt(sum)
}
function square(x) {
    return x * x;
}

fire()
</code></pre><blockquote>
<p>下面的图都是用 keynote 做的 <a href="https://link.zhihu.com/?target=https%3A//github.com/ccforward/cc/blob/master/Blog/pic/event-loop.key" target="_blank" rel="noopener">keynote地址</a></p>
</blockquote>
<p>函数 <code>fire</code> 首先被调用</p>
<p><img src="https://pic3.zhimg.com/v2-a3840ed51ad7ccaedb915e05b087e1e4_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-a3840ed51ad7ccaedb915e05b087e1e4_hd.jpg" alt=""></p>
<p><code>fire</code> 调用 <code>sumSqrt</code> 函数 参数为3和4</p>
<p><img src="https://pic4.zhimg.com/v2-5871549477044a0e7a657f9a16e9367c_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-5871549477044a0e7a657f9a16e9367c_hd.jpg" alt=""></p>
<p>之后调用 <code>square</code> 参数为 x, x==3</p>
<p><img src="https://pic2.zhimg.com/v2-ced7e64c06861509c593cdb0cfbc594e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-ced7e64c06861509c593cdb0cfbc594e_hd.jpg" alt=""></p>
<p>当 <code>square</code> 执行结束返回时，从 stack 中弹出，并将返回值赋值给 s1<br>s1加入到 sumSqrt 的 stack frame 中</p>
<p><img src="https://pic2.zhimg.com/v2-0f214a42ee6c2226c343edb7431116be_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-0f214a42ee6c2226c343edb7431116be_hd.jpg" alt=""></p>
<p>以同样的方式调用下一个 <code>square</code> 函数</p>
<p><img src="https://pic4.zhimg.com/v2-6488db685f7ba396d9bb72b80daf0465_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6488db685f7ba396d9bb72b80daf0465_hd.jpg" alt=""></p>
<p><img src="https://pic1.zhimg.com/v2-4900e4ce2e398d085ceb6f2ea31ad6d9_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-4900e4ce2e398d085ceb6f2ea31ad6d9_hd.jpg" alt=""></p>
<p>在下一行的表达式中计算出 s1+s2 并赋值给 sum</p>
<p><img src="https://pic3.zhimg.com/v2-0045b1427a3fd41aa31cbac4271b6200_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-0045b1427a3fd41aa31cbac4271b6200_hd.jpg" alt=""></p>
<p>之后调用 <code>Math.sqrt</code> 参数为sum</p>
<p><img src="https://pic4.zhimg.com/v2-89dc079ce6308a32fbf78c29b67c4985_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-89dc079ce6308a32fbf78c29b67c4985_hd.jpg" alt=""></p>
<p>现在就剩下 <code>sumSqrt</code> 函数返回计算结果了</p>
<p><img src="https://pic2.zhimg.com/v2-3fe1e6705f665c11f3c350bdd4f643c9_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3fe1e6705f665c11f3c350bdd4f643c9_hd.jpg" alt=""></p>
<p>返回值赋值给 result</p>
<p><img src="https://pic4.zhimg.com/v2-d55914f97f05518c2f31b10909efb4f4_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-d55914f97f05518c2f31b10909efb4f4_hd.jpg" alt=""></p>
<p>在 console 中打印出 result</p>
<p><img src="https://pic3.zhimg.com/v2-99d7b0ece63e888549b258944fe0e1e4_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-99d7b0ece63e888549b258944fe0e1e4_hd.jpg" alt=""></p>
<p>最终 <code>fire</code> 没有任何返回值 从stack中弹出 stack也清空了</p>
<p><img src="https://pic4.zhimg.com/v2-bd4e4983cbba11fe080913f2a1d0ef43_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-bd4e4983cbba11fe080913f2a1d0ef43_hd.jpg" alt=""></p>
<p>当函数执行完毕后本地变量会从 stack 中弹出，这只有在使用 numbers string boolean 这种基本数据类型时才会发生。而对象、数组的值是存在于 heap(堆) 中的，stack 只存放了他们对应的指针。</p>
<p>当函数之行结束从 stack 中弹出来时，只有对象的指针被弹出，而真正的值依然存在 heap 中，然后由垃圾回收器自动的清理回收。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>通过一个例子来了解函数的执行顺序</p>
<pre><code>&apos;use strict&apos;

const express = require(&apos;express&apos;)
const superagent = require(&apos;superagent&apos;)
const app = express()

app.get(&apos;/&apos;, getArticle)

function getArticle(req, res) {
    fetchArticle(req, res)
    print()
}

const aids = [4564824, 4506868, 4767667, 4856099, 7456996];

function fetchArticle(req, res) {
    const aid = aids[Math.floor(Math.random() * aids.length)]
    superagent.get(`http://news-at.zhihu.com/api/4/news/${aid}`)
        .end((err, res) =&gt; {
            if(err) {
                console.log(&apos;error ......&apos;);
                return res.status(500).send(&apos;an error ......&apos;)
            }
            const article = res.body
            res.send(article)
            console.log(&apos;Got an article&apos;)
        })

    console.log(&apos;Now is fetching an article&apos;)
}

function print(){
    console.log(&apos;Print something&apos;)
}


app.listen(&apos;5000&apos;)
</code></pre><p>请求 <code>http://localhost:5000/</code> 后打印出</p>
<pre><code>Now is fetching an article

Print something

Got an article
</code></pre><p>虽然 V8 是单线程的，但底层的 C++ API 却不是。这意味着当我们执行一些非阻塞的操作，Node会调用一些代码，与引擎里的js代码同时执行。一旦这个隐藏的线程收到了等待的返回值或者抛出一个异常，之前提供的回调函数就会执行。</p>
<p>上面的说的Node调用的一些代码其实就是 <a href="https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>，一个开源的跨平台的异步 I/O 。最初就是为 Node.js 开发的，现在<a href="https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv/wiki/Projects-that-use-libuv" target="_blank" rel="noopener">很多项目</a>都在用</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>javascript 是单线程事件驱动的语言，那我们可以给时间添加监听器，当事件触发时，监听器就能执行回调函数。</p>
<p>当我们去调用 <code>setTimeout`</code>http.get<code></code>fs.readFile`, Node.js 会把这些定时器、http、IO操作发送给另一个线程以保证V8继续执行我们的代码。</p>
<p>然而我们只有一个主线程和一个 call-stack ，这样当一个读取文件的操作还在执行时，有一个网络请求request过来，那这时他的回调就需要等stack变空才能执行。</p>
<p>回调函数正在等待轮到自己执行所排的队就被称为任务队列(或者事件队列、消息队列)。每当主线程完成前一个任务，回调函数就会在一个无限循环圈里被调用，因此这个圈被称为事件循环。</p>
<p>我们前面那个获取文章的例子的执行顺序就会如下：</p>
<ol>
<li>express 给 request 事件注册了一个 handler，并且当请求到达路径 ‘/‘ 时来触发handler</li>
<li>调过各个函数并且在端口 5000 上启动监听</li>
<li>stack 为空，等待 <code>request</code> 事件触发</li>
<li>根据传入的请求，事件触发，express 调用之前提供的函数 <code>getArticle</code></li>
<li><code>getArticle</code> 压入(push) stack</li>
<li><code>fetchArticle</code> 被调用 同时压入 stack</li>
<li><code>Math.floor</code> 和 <code>Math.random</code> 被调用压入 stack 然后再 弹出(pop), 从 aids 里面取出的一个值被赋值给变量 aid</li>
<li><code>superagent.get</code> 被执行，参数为 <code>&#39;http://news-at.zhihu.com/api/4/news/${aid}&#39;</code> ,并且回调函数注册给了 <code>end</code> 事件</li>
<li>到 <code>http://news-at.zhihu.com/api/4/news/${aid}</code> 的HTTP请求被发送到后台线程，然后函数继续往下执行</li>
<li><code>&#39;Now is fetching an article&#39;</code> 打印在 console 中。 函数 <code>fetchArticle</code> 返回</li>
<li><code>print</code> 函数被调用, <code>&#39;Print something&#39;</code> 打印在 console 中</li>
<li>函数 <code>getArticle</code> 返回，并从 stack 中弹出， stack 为空</li>
<li>等待 <code>http://news-at.zhihu.com/api/4/news/${aid}</code> 发送相应信息</li>
<li>响应信息到达，<code>end</code> 事件被触发</li>
<li>注册给 <code>end</code> 事件的匿名回调函数被执行，这个匿名函数和他闭包中的所有变量压入 stack，这意味着这个匿名函数可以访问并修改 <code>express</code>, <code>superagent</code>, <code>app</code>, <code>aids</code>, <code>req</code>, <code>res</code>, <code>aid</code> 的值以及之前所有已经定义的函数</li>
<li>函数 <code>res.send()</code> 伴随着 200 或 500 的状态码被执行，但同时又被放入到后台线程中，因此 响应流 不会阻塞我们函数的执行。匿名函数也被 pop 出 stack。</li>
</ol>
<h2 id="Microtasks-Macrotasks"><a href="#Microtasks-Macrotasks" class="headerlink" title="Microtasks Macrotasks"></a>Microtasks Macrotasks</h2><p>任务队列不止一个，还有 microtasks 和 macrotasks</p>
<p>microtasks:</p>
<ul>
<li>process.nextTick</li>
<li>promise</li>
<li>Object.observe</li>
</ul>
<p>macrotasks:</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmediate</li>
<li>I/O</li>
</ul>
<p>这两个的详细区别下一篇再写，先看一段代码</p>
<pre><code>console.log(&apos;start&apos;)

const interval = setInterval(() =&gt; {  
  console.log(&apos;setInterval&apos;)
}, 0)

setTimeout(() =&gt; {  
  console.log(&apos;setTimeout 1&apos;)
  Promise.resolve()
      .then(() =&gt; {
        console.log(&apos;promise 3&apos;)
      })
      .then(() =&gt; {
        console.log(&apos;promise 4&apos;)
      })
      .then(() =&gt; {
        setTimeout(() =&gt; {
          console.log(&apos;setTimeout 2&apos;)
          Promise.resolve()
              .then(() =&gt; {
                console.log(&apos;promise 5&apos;)
              })
              .then(() =&gt; {
                console.log(&apos;promise 6&apos;)
              })
              .then(() =&gt; {
                clearInterval(interval)
              })
        }, 0)
      })
}, 0)

Promise.resolve()
    .then(() =&gt; {  
        console.log(&apos;promise 1&apos;)
    })
    .then(() =&gt; {
        console.log(&apos;promise 2&apos;)
    })
</code></pre><p>理解了node的事件循环还是比较容易得出答案的：</p>
<pre><code>start
promise 1
promise 2
setInterval
setTimeout 1
promise 3
promise 4
setInterval
setTimeout 2
promise 5
promise 6
</code></pre><p>根据 <a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">WHATVG</a> 的说明，在一个事件循环的周期(cycle)中一个 (macro)task 应该从 macrotask 队列开始执行。当这个 macrotask 结束后，所有的 microtasks 将在同一个 cycle 中执行。在 microtasks 执行时还可以加入更多的 microtask，然后一个一个的执行，直到 microtask 队列清空。</p>
<p>规范理解起来有点晦涩，来看下上面的例子</p>
<h2 id="Cycle-1"><a href="#Cycle-1" class="headerlink" title="Cycle 1"></a>Cycle 1</h2><p>1)<code>setInterval</code> 被列为 task</p>
<p>2)<code>setTimeout 1</code> 被列为 task</p>
<p>3)<code>Promise.resolve 1</code> 中两个 <code>then</code> 被列为 microtask</p>
<p>4) stack 清空 microtasks 执行</p>
<p>任务队列： <code>setInterval`</code>setTimeout 1`</p>
<h2 id="Cycle-2"><a href="#Cycle-2" class="headerlink" title="Cycle 2"></a>Cycle 2</h2><p>5) microtasks 队列清空 <code>setInteval</code> 的回调可以执行。另一个 <code>setInterval</code> 被列为 task , 位于 <code>setTimeout 1</code>后面</p>
<p>任务队列： <code>setTimeout 1`</code>setInterval`</p>
<h2 id="Cycle-3"><a href="#Cycle-3" class="headerlink" title="Cycle 3"></a>Cycle 3</h2><p>6) microtask 队列清空，<code>setTimeout 1</code> 的回调可以执行，<code>promise 3</code> 和 <code>promise 4</code> 被列为 microtasks</p>
<p>7)<code>promise 3</code> 和 <code>promise 4</code> 执行。 <code>setTimeout 2</code> 被列为 task</p>
<p>任务队列 <code>setInterval`</code>setTimeout 2`</p>
<h2 id="Cycle-4"><a href="#Cycle-4" class="headerlink" title="Cycle 4"></a>Cycle 4</h2><p>8) microtask 队列清空 <code>setInteval</code> 的回调可以执行。然后另一个 <code>setInterval</code> 被列为 task ，位于 <code>setTimeout 2</code> 后面</p>
<p>任务队列： <code>setTimeout 2`</code>setInterval`</p>
<p>9)<code>setTimeout 2</code> 的回调执行， <code>promise 5</code> 和 <code>promise 6</code> 被列为 microtasks</p>
<p>现在 <code>promise 5</code> 和 <code>promise 6</code> 的回调应该执行，并且 clear 掉 <code>interval</code>。 但有的时候不知道为什么 <code>setInterval</code> 还会在执行一遍，变成下面结果</p>
<pre><code>...
setTimeout 2
setInterval
promise 5
promise 6
</code></pre><p>但是把上面的代码放入 chrome console 中执行却没有问题。这一点还要再根据不同的 node版本 查一下。</p>
<h2 id="关于-macrotask-和-microtask"><a href="#关于-macrotask-和-microtask" class="headerlink" title="关于 macrotask 和 microtask"></a>关于 macrotask 和 microtask</h2><p>用例子简单理解了下 macrotask 和 microtask</p>
<p>这里再详细的总结下两者的区别和使用</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个事件循环(EventLoop)中会有一个正在执行的任务(Task)，而这个任务就是从 macrotask 队列中来的。在<a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">whatwg规范</a>中有 queue 就是任务队列。当这个 macrotask 执行结束后所有可用的 microtask 将会在同一个事件循环中执行，当这些 microtask 执行结束后还能继续添加 microtask 一直到真个 microtask 队列执行结束。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>基本来说，当我们想以同步的方式来处理异步任务时候就用 microtask（比如我们需要直接在某段代码后就去执行某个任务，就像Promise一样）。</p>
<p>其他情况就直接用 macrotask。</p>
<h2 id="两者的具体实现"><a href="#两者的具体实现" class="headerlink" title="两者的具体实现"></a>两者的具体实现</h2><ul>
<li>macrotasks: setTimeout setInterval setImmediate I/O UI渲染</li>
<li>microtasks: Promise process.nextTick Object.observe MutationObserver</li>
</ul>
<h2 id="从规范中理解"><a href="#从规范中理解" class="headerlink" title="从规范中理解"></a>从规范中理解</h2><p>whatwg规范：<a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/webappapis.html#task-queue</a></p>
<ul>
<li>一个事件循环(event loop)会有一个或多个任务队列(task queue) task queue 就是 macrotask queue</li>
<li>每一个 event loop 都有一个 microtask queue</li>
<li>task queue == macrotask queue != microtask queue</li>
<li>一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中</li>
<li>当一个 task 被放入队列 queue(macro或micro) 那这个 task 就可以被立即执行了</li>
</ul>
<p>再来回顾下事件循环如何执行一个任务的流程</p>
<p>当执行栈(call stack)为空的时候，开始依次执行：</p>
<ol>
<li>把最早的任务(task A)放入任务队列</li>
<li>如果 task A 为null (那任务队列就是空)，直接跳到第6步</li>
<li>将 currently running task 设置为 task A</li>
<li>执行 task A (也就是执行回调函数)</li>
<li>将 currently running task 设置为 null 并移出 task A</li>
<li>执行 microtask 队列</li>
</ol>
<ul>
<li>a: 在 microtask 中选出最早的任务 task X</li>
<li>b: 如果 task X 为null (那 microtask 队列就是空)，直接跳到 g</li>
<li>c: 将 currently running task 设置为 task X</li>
<li>d: 执行 task X</li>
<li>e: 将 currently running task 设置为 null 并移出 task X</li>
<li>f: 在 microtask 中选出最早的任务 , 跳到 b</li>
<li>g: 结束 microtask 队列</li>
</ul>
<ol>
<li>跳到第一步</li>
</ol>
<p>上面就算是一个简单的 event-loop 执行模型</p>
<p>再简单点可以总结为：</p>
<ol>
<li>在 macrotask 队列中执行最早的那个 task ，然后移出</li>
<li>执行 microtask 队列中所有可用的任务，然后移出</li>
<li>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>当一个task(在 macrotask 队列中)正处于执行状态，也可能会有新的事件被注册，那就会有新的 task 被创建。比如下面两个</li>
</ul>
<ol>
<li>promiseA.then() 的回调就是一个 task</li>
</ol>
<ul>
<li>promiseA 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promiseA 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li><p>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</p>
</li>
<li><p>microtask queue 中的 task 会在事件循环的当前回合中执行，因此 macrotask queue 中的 task 就只能等到事件循环的下一个回合中执行了</p>
</li>
<li>click ajax setTimeout 的回调是都是 task, 同时，包裹在一个 script 标签中的js代码也是一个 task 确切说是 macrotask。</li>
</ul>
<p>两者的具体实现</p>
<ul>
<li>macrotasks: setTimeout ，setInterval， setImmediate， I/O ，UI渲染，requestAnimationFrame</li>
<li>microtasks: Promise， process.nextTick， Object.observe， MutationObserver</li>
</ul>
<p>再简单点可以总结为：<br><img src="https://pic1.zhimg.com/v2-e92a4f5f686d115832b63b9b9e3ac2cd_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-e92a4f5f686d115832b63b9b9e3ac2cd_hd.jpg" alt=""></p>
<ol>
<li>在 macrotask 队列中执行最早的那个 task ，然后移出</li>
<li>再执行 microtask 队列中所有可用的任务，然后移出</li>
<li>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</li>
</ol>
<p>这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。<br>优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。<br>如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。</p>
<p>为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到：</p>
<blockquote>
<p>JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。<br>setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、 MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。<br>要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。<br>实在不行，只能用 setTimeout 创建 task 了。<br>为啥要用 microtask？<br>根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。<br>反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</p>
</blockquote>
<p>首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调，</p>
<p>MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。</p>
<p>setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行：</p>
<pre><code>setTimeout(function(){
    console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;);
},0);
</code></pre><p>它会将回调函数加入task中，等到执行。<br><img src="https://pic2.zhimg.com/v2-59cf9f88d7daac690d39edfb9fffc8b8_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-59cf9f88d7daac690d39edfb9fffc8b8_hd.jpg" alt=""></p>
<pre><code>setTimeout(function(){console.log(4)},0);
new Promise(function(resolve){
    console.log(1)
    for( var i=0 ; i&lt;10000 ; i++ ){
        i==9999 &amp;&amp; resolve()
    }
    console.log(2)
}).then(function(){
    console.log(5)
});
console.log(3);
结果是：
1,2,3,5,4
</code></pre><p>再看这个，两个自执行同时执行：</p>
<pre><code>&lt;script&gt;
(function test() {
  setTimeout(function () {
    console.log(4)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(1);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(2);
  }).then(function() {
    console.log(5);
  });
  console.log(3);
})()

(function test2() {
  setTimeout(function () {
    console.log(42)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(12);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(22);
  }).then(function() {
    console.log(52);
  });
  console.log(32);
})()
&lt;/script&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-cd18c572eb05069895ede7e34388bb8d_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-cd18c572eb05069895ede7e34388bb8d_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-afcb6fa6fb862818359f757107b769ab_b.jpg" alt=""><br>整个执行过程是一个 main thread 【<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/link%3Furl%3DCV-egCVH8yK1w-ilUqGsztryG8s2mbuhAliIC_L1n_-BSZ_KJ16tAfaNkmbcRtU8" target="_blank" rel="noopener">主线程</a>】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的<code>setTimeout</code>进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。</p>
<p>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：</p>
<p>1.先执行 macrotasks：I/O -》 UI渲染</p>
<p>2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe</p>
<p>3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：</p>
<p>setTimeout ，setInterval –》setImmediate</p>
<p>综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</p>
<pre><code>setImmediate(function(){
    console.log(1);
},0);
setTimeout(function(){
    console.log(2);
},0);
new Promise(function(resolve){
    console.log(3);
    resolve();
    console.log(4);
}).then(function(){
    console.log(5);
});
console.log(6);
process.nextTick(function(){
    console.log(7);
});
console.log(8);
结果是：3 4 6 8 7 5 2 1 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/05/30/深入理解ES6  Async Functions/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/05/30/深入理解ES6  Async Functions/" itemprop="url">深入理解ES6 Async Functions (异步函数)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-30T18:35:10+08:00">
                2018-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="async-异步-函数变体"><a href="#async-异步-函数变体" class="headerlink" title="async(异步) 函数变体"></a>async(异步) 函数变体</h2><p>以下是已经存在的异步函数变体。请注意无处不在的 <code>async</code> 关键字。</p>
<ul>
<li>异步函数声明： <code>async function foo() {}</code></li>
<li>异步函数表达式： <code>const foo = async function () {};</code></li>
<li>异步函数定义：<code>let obj = { async foo() {} }</code></li>
<li>异步箭头函数： <code>const foo = async () =&gt; {};</code></li>
</ul>
<h2 id="async-异步-函数总是返回-Promises"><a href="#async-异步-函数总是返回-Promises" class="headerlink" title="async(异步) 函数总是返回 Promises"></a>async(异步) 函数总是返回 Promises</h2><p>async(异步) 函数的 Promise 完成状态：</p>
<pre><code>async function asyncFunc() {
return 123;
}

asyncFunc()
.then(x =&gt; console.log(x));
// 123
</code></pre><p>async(异步) 函数的 Promise 拒绝状态：</p>
<pre><code>async function asyncFunc() {
throw new Error(&apos;Problem!&apos;);
}

asyncFunc()
.catch(err =&gt; console.log(err));
// Error: Problem!
</code></pre><h2 id="通过-await-处理-async-异步-计算的结果和错误"><a href="#通过-await-处理-async-异步-计算的结果和错误" class="headerlink" title="通过 await 处理 async(异步) 计算的结果和错误"></a>通过 <code>await</code> 处理 async(异步) 计算的结果和错误</h2><p><code>await</code>（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise 返回：</p>
<ul>
<li>如果 Promise 是完成状态，<code>await</code> 的结果是完成态的值。</li>
<li>如果 Promise 是拒绝状态，<code>await</code> 会抛出拒绝值。</li>
</ul>
<p>处理单个 async(异步) 返回值：</p>
<pre><code>async function asyncFunc() {
const result = await otherAsyncFunc();
   console.log(result);
}

// 等价于:
function asyncFunc() {
return otherAsyncFunc()
.then(result =&gt; {
       console.log(result);
});
}
</code></pre><p>按顺序处理多个 async(异步) 返回值：</p>
<pre><code>async function asyncFunc() {
const result1 = await otherAsyncFunc1();
   console.log(result1);
const result2 = await otherAsyncFunc2();
   console.log(result2);
}

// 等价于:
function asyncFunc() {
return otherAsyncFunc1()
.then(result1 =&gt; {
       console.log(result1);
return otherAsyncFunc2();
})
.then(result2 =&gt; {
       console.log(result2);
});
}
</code></pre><p>并行处理多个 async(异步) 返回值：</p>
<pre><code>async function asyncFunc() {
const [result1, result2] = await Promise.all([
       otherAsyncFunc1(),
       otherAsyncFunc2(),
]);
   console.log(result1, result2);
}

// 等价于:
function asyncFunc() {
return Promise.all([
       otherAsyncFunc1(),
       otherAsyncFunc2(),
])
.then([result1, result2] =&gt; {
       console.log(result1, result2);
});
}
</code></pre><p>错误处理：</p>
<pre><code>async function asyncFunc() {
try {
await otherAsyncFunc();
} catch (err) {
       console.error(err);
}
}

// 等价于:
function asyncFunc() {
return otherAsyncFunc()
.catch(err =&gt; {
       console.error(err);
});
}
</code></pre><h2 id="理解-async-异步-函数"><a href="#理解-async-异步-函数" class="headerlink" title="理解 async(异步) 函数"></a>理解 async(异步) 函数</h2><p>在我解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。</p>
<p>对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 <a href="https://link.zhihu.com/?target=https%3A//fetch.spec.whatwg.org/%23concept-request" target="_blank" rel="noopener">客户端 fetch API</a> ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下：</p>
<pre><code>function fetchJson(url) {
return fetch(url)
.then(request =&gt; request.text())
.then(text =&gt; {
return JSON.parse(text);
})
.catch(error =&gt; {
       console.log(`ERROR: ${error.stack}`);
});
}
fetchJson(&apos;http://example.com/some_file.json&apos;)
.then(obj =&gt; console.log(obj));
</code></pre><h2 id="通过-generator-来编写异步代码"><a href="#通过-generator-来编写异步代码" class="headerlink" title="通过 generator 来编写异步代码"></a>通过 generator 来编写异步代码</h2><p>co 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同：</p>
<pre><code>const fetchJson = co.wrap(function* (url) {
try {
let request = yield fetch(url);
let text = yield request.text();
return JSON.parse(text);
}
catch (error) {
       console.log(`ERROR: ${error.stack}`);
}
});
</code></pre><p>每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，<code>yield</code> 返回完成状态的值，如果处于拒绝状态，<code>yield</code> 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于 <code>then()</code> 所做的工作）。</p>
<h2 id="通过-async-异步-函数来编写异步代码"><a href="#通过-async-异步-函数来编写异步代码" class="headerlink" title="通过 async(异步) 函数来编写异步代码"></a>通过 async(异步) 函数来编写异步代码</h2><p>async(异步) 函数用的特定语法基本上和 co 类似：</p>
<pre><code>async function fetchJson(url) {
try {
let request = await fetch(url);
let text = await request.text();
return JSON.parse(text);
}
catch (error) {
       console.log(`ERROR: ${error.stack}`);
}
}
</code></pre><p>在内部，异步函数写法更类似于 generators 。</p>
<h2 id="以同步开始，异步处理的-async-异步-函数"><a href="#以同步开始，异步处理的-async-异步-函数" class="headerlink" title="以同步开始，异步处理的 async(异步) 函数"></a>以同步开始，异步处理的 async(异步) 函数</h2><p>以下是 async(异步)函数是如何工作的：</p>
<ol>
<li>async(异步) 函数总是返回一个 Promise 对象 <code>p</code> 。Promise 对象在 async(异步) 函数开始执行时被创建。</li>
<li>函数体执行过程中，可以通过 <code>return</code> 或 <code>throw</code> 终止执行。或者通过 <code>await</code> 暂停执行，在这种情况下，通常会在以后继续执行。</li>
<li>返回 Promise 对象 <code>p</code>。</li>
</ol>
<p>当执行 async(异步) 函数的函数体时，<code>return x</code> 中的 <code>x</code> 是 Promise 对象 <code>p</code> 的完成状态的结果，而 <code>throw err</code> 是 <code>p</code> 的拒绝状态的结果。执行结果是异步返回的。换句话说：<code>then()</code> 和 <code>catch()</code> 的回调总是在当前代码完成后执行。</p>
<p>以下是代码示例：</p>
<pre><code>async function asyncFunc() {
   console.log(&apos;asyncFunc()&apos;); // (A)
return &apos;abc&apos;;
}
asyncFunc().
then(x =&gt; console.log(`Resolved: ${x}`)); // (B)
console.log(&apos;main&apos;); // (C)

// Output:
// asyncFunc()
// main
// Resolved: abc
</code></pre><p>您可以认为是以下的执行顺序：</p>
<ol>
<li>行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 <code>return</code> 来返回完成状态的结果。</li>
<li>行C：执行继续。</li>
<li>行B：Promise 完成状态通知是异步发生的。</li>
</ol>
<h2 id="返回不被包裹的-Promise-对象"><a href="#返回不被包裹的-Promise-对象" class="headerlink" title="返回不被包裹的 Promise 对象"></a>返回不被包裹的 Promise 对象</h2><p>Promise 的 resolve 是一项标准操作。 <code>return</code> 就是使用它来 resolve async(异步) 函数的 Promise <code>p</code> 的。这意味着：</p>
<ol>
<li>返回一个非 Promise 值，该值将被处理成 <code>p</code> 的完成状态值。</li>
<li>返回一个 Promise 对象，那么 <code>p</code> 此时相当于是该 Promise 的状态。</li>
</ol>
<p>因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：</p>
<pre><code>async function asyncFunc() {
return Promise.resolve(123);
}
asyncFunc()
.then(x =&gt; console.log(x)) // 123
</code></pre><p>有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 <code>throw</code> ）：</p>
<pre><code>async function asyncFunc() {
return Promise.reject(new Error(&apos;Problem!&apos;));
}
asyncFunc()
.catch(err =&gt; console.error(err)); // Error: Problem!
</code></pre><p>这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 <code>await</code> 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：</p>
<pre><code>async function asyncFunc() {
return anotherAsyncFunc();
}
</code></pre><p>上面的代码示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹 <code>anotherAsyncFunc()</code> 的 Promise ，而是包裹 <code>anotherAsyncFunc()</code> 本身 ）：</p>
<pre><code>async function asyncFunc() {
return await anotherAsyncFunc();
}
</code></pre><h2 id="使用-await-小贴士"><a href="#使用-await-小贴士" class="headerlink" title="使用 await 小贴士"></a>使用 <code>await</code> 小贴士</h2><h2 id="不要忘记使用-await"><a href="#不要忘记使用-await" class="headerlink" title="不要忘记使用 await"></a>不要忘记使用 <code>await</code></h2><p>在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 <code>await</code> ：</p>
<pre><code>async function asyncFunc() {
const value = otherAsyncFunc(); // missing `await`!
···
}
</code></pre><p>在这个例子中，方法执行返回的 Promise 对象赋值给了 <code>value</code> ，它通常不是你在 async(异步) 函数中想要的结果。</p>
<p>await 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：</p>
<pre><code>async function foo() {
await step1(); // (A)
···
}
</code></pre><p>行A中的 <code>await</code> 确保在执行 <code>foo()</code> 剩余部分之前， <code>step1()</code> 已经执行完成。</p>
<h2 id="不需要使用-await-的情况"><a href="#不需要使用-await-的情况" class="headerlink" title="不需要使用 await 的情况"></a>不需要使用 await 的情况</h2><p>有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：</p>
<pre><code>async function asyncFunc() {
const writer = openFile(&apos;someFile.txt&apos;);
   writer.write(&apos;hello&apos;); // don’t wait
   writer.write(&apos;world&apos;); // don’t wait
await writer.close(); // wait for file to close
}
</code></pre><p>在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。</p>
<p><code>asyncFunc()</code> 函数最后一行的 <code>await</code> 确保该函数仅在文件写入关闭后才会执行。</p>
<p>由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 <code>return</code> 替换 <code>await writer.close()</code> ：</p>
<pre><code>async function asyncFunc() {
const writer = openFile(&apos;someFile.txt&apos;);
   writer.write(&apos;hello&apos;);
   writer.write(&apos;world&apos;);
return writer.close();
}
</code></pre><p>这两个版本各有利弊，<code>await</code> 版本可能稍微更容易理解。</p>
<h2 id="await-是顺序执行的，Promise-all-是并行的"><a href="#await-是顺序执行的，Promise-all-是并行的" class="headerlink" title="await 是顺序执行的，Promise.all() 是并行的"></a>await 是顺序执行的，Promise.all() 是并行的</h2><p>下面的代码调用了两个 async(异步) 函数， <code>asyncFunc1()</code> 和 <code>asyncFunc1()</code> 。</p>
<pre><code>async function foo() {
const result1 = await asyncFunc1();
const result2 = await asyncFunc2();
}
</code></pre><p>这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ：</p>
<pre><code>async function foo() {
const [result1, result2] = await Promise.all([
       asyncFunc1(),
       asyncFunc2(),
]);
}
</code></pre><p>我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。</p>
<h2 id="异步函数和回调"><a href="#异步函数和回调" class="headerlink" title="异步函数和回调"></a>异步函数和回调</h2><p>async(异步) 函数的一个限制是 <code>await</code>(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 <code>await</code>(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 <code>map()</code> 和 <code>forEach()</code>。</p>
<h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><p>我们从数组方法 <code>map()</code> 开始讲解。在下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。</p>
<pre><code>async function downloadContent(urls) {
return urls.map(url =&gt; {
// 错误的语法!
const content = await httpGet(url);
return content;
});
}
</code></pre><p>这不起作用，因为在正常箭头函数中 <code>await</code> 语法上是非法的(愚人码头注： <code>await</code>(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？</p>
<pre><code>async function downloadContent(urls) {
return urls.map(async (url) =&gt; { // 注意这一行中的 async ;
const content = await httpGet(url);
return content;
});
}
</code></pre><p>这段代码有两个问题：</p>
<ul>
<li>现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。</li>
<li>一旦 <code>map()</code> 执行完成，回调执行的工作并不能同时完成，因为 <code>await</code> 只暂停了包裹它的箭头函数 和 <code>httpGet()</code> 异步执行达到完成状态。这意味着你不能使用 <code>await</code>，来等待 <code>downloadContent()</code> 执行结束。</li>
</ul>
<p>我们可以通过 <code>Promise.all()</code> 来解决这两个问题，<code>Promise.all()</code> 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：</p>
<pre><code>async function downloadContent(urls) {
const promiseArray = urls.map(async (url) =&gt; {
const content = await httpGet(url);
return content;
});
return await Promise.all(promiseArray);
}
</code></pre><p><code>map()</code> 的回调并不对 <code>httpGet()</code> 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。</p>
<pre><code>async function downloadContent(urls) {
const promiseArray = urls.map(
       url =&gt; httpGet(url));
return await Promise.all(promiseArray);
}
</code></pre><p>我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 <code>await</code> 来解开 <code>Promise.all()</code> 的结果，然后通过 <code>return</code> 再次包裹它。 假设 <code>return</code> 不包裹 Promises，我们可以直接返回 <code>Promise.all()</code> 的结果：</p>
<pre><code>async function downloadContent(urls) {
const promiseArray = urls.map(
       url =&gt; httpGet(url));
return Promise.all(promiseArray);
}
</code></pre><h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h2><p>我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：</p>
<pre><code>async function logContent(urls) {
   urls.forEach(url =&gt; {
// Wrong syntax
const content = await httpGet(url);
       console.log(content);
});
}
</code></pre><p>同样的，这里的代码会产生一个语法错误，因为你不能在通常的箭头函数内部使用 <code>await</code> 。</p>
<p>我们换作异步箭头函数：</p>
<pre><code>async function logContent(urls) {
   urls.forEach(async url =&gt; {
const content = await httpGet(url);
       console.log(content);
});
// Not finished here
}
</code></pre><p>这段代码起作用了，但是会出现一个警告：<code>httpGet()</code> 返回的 Promise 对象是异步完成的，这也意味着当 <code>forEach()</code> 返回的时候回调可能还没有结束，因此你无法等到 <code>logContent()</code> 只能结束。</p>
<p>如果你并不想要这个结果，你可以将 <code>forEach()</code> 转换为 <code>for-of</code> 循环。</p>
<pre><code>async function logContent(urls) {
for (const url of urls) {
const content = await httpGet(url);
       console.log(content);
}
}
</code></pre><p>现在一切都在 <code>for-of</code> 循环完成后完成。但是，处理步骤依次发生：<code>httpGet()</code> 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 <code>Promise.all()</code>：</p>
<pre><code>async function logContent(urls) {
await Promise.all(urls.map(
async url =&gt; {
const content = await httpGet(url);
           console.log(content);
}));
}
</code></pre><p><code>map()</code> 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 <code>await</code>(等待) 所有方法执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 <code>Promise.all()</code> ，但是该函数的结果是一个数组，其元素都是未完成状态的。</p>
<h2 id="使用异步函数小贴士"><a href="#使用异步函数小贴士" class="headerlink" title="使用异步函数小贴士"></a>使用异步函数小贴士</h2><h2 id="了解你的-Promises"><a href="#了解你的-Promises" class="headerlink" title="了解你的 Promises"></a>了解你的 Promises</h2><p>async(异步) 函数的基础就是 <a href="https://link.zhihu.com/?target=http%3A//exploringjs.com/es6/ch_promises.html" target="_blank" rel="noopener">Promises</a> 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。</p>
<p>举个例子，这里有个 “promisified” 版本的 <code>XMLHttpRequest</code> ：</p>
<pre><code>function httpGet(url, responseType=&quot;&quot;) {
return new Promise(
function (resolve, reject) {
const request = new XMLHttpRequest();
           request.onload = function () {
if (this.status === 200) {
// Success
                   resolve(this.response);
} else {
// Something went wrong (404 etc.)
                   reject(new Error(this.statusText));
}
};
           request.onerror = function () {
               reject(new Error(
&apos;XMLHttpRequest Error: &apos;+this.statusText));
};
           request.open(&apos;GET&apos;, url);
           xhr.responseType = responseType;
           request.send();
});
}
</code></pre><p>XMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 <code>return</code> 或者 <code>throw</code> 来完成这样的操作。你不能从回调函数内部 <code>return</code> 一个函数的结果。<code>throw</code>也有类似的约束。</p>
<p>因此，异步函数的通用编码风格是：</p>
<ul>
<li>直接使用 Promise 对象来构建异步原语。</li>
<li>用异步函数来使用这些原语。</li>
</ul>
<p>扩展阅读：“Exploring ES6” 中的 “<a href="https://link.zhihu.com/?target=http%3A//exploringjs.com/es6/ch_promises.html" target="_blank" rel="noopener">异步编程中的 Promises 对象</a>” 章节</p>
<h2 id="立即调用异步函数表达式"><a href="#立即调用异步函数表达式" class="headerlink" title="立即调用异步函数表达式"></a>立即调用异步函数表达式</h2><p>有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 <code>main()</code> 并立即调用它：</p>
<pre><code>async function main() {
   console.log(await asyncFunction());
}
main();
</code></pre><p>或者您可以使用立即调用异步函数表达式：</p>
<pre><code>(async function () {
   console.log(await asyncFunction());
})();
</code></pre><p>另一个选择是立即调用异步箭头函数：</p>
<pre><code>(async () =&gt; {
   console.log(await asyncFunction());
})();
</code></pre><h2 id="用异步函数进行单元测试"><a href="#用异步函数进行单元测试" class="headerlink" title="用异步函数进行单元测试"></a>用异步函数进行单元测试</h2><p>以下代码使用 <a href="https://link.zhihu.com/?target=https%3A//mochajs.org/" target="_blank" rel="noopener">测试框架 mocha</a> 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试：</p>
<pre><code>import assert from &apos;assert&apos;;

// Bug: the following test always succeeds
test(&apos;Testing async code&apos;, function () {
   asyncFunc1() // (A)
.then(result1 =&gt; {
assert.strictEqual(result1, &apos;a&apos;); // (B)
return asyncFunc2();
})
.then(result2 =&gt; {
assert.strictEqual(result2, &apos;b&apos;); // (C)
});
});
</code></pre><p>然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。</p>
<p>你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。</p>
<pre><code>return asyncFunc1() // (A)
</code></pre><p>异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：</p>
<pre><code>import assert from &apos;assert&apos;;
test(&apos;Testing async code&apos;, async function () {
const result1 = await asyncFunc1();
assert.strictEqual(result1, &apos;a&apos;);
const result2 = await asyncFunc2();
assert.strictEqual(result2, &apos;b&apos;);
});
</code></pre><p>在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。</p>
<h2 id="不要担心没有处理的拒绝拒态"><a href="#不要担心没有处理的拒绝拒态" class="headerlink" title="不要担心没有处理的拒绝拒态"></a>不要担心没有处理的拒绝拒态</h2><p>当前的 JavaScript 引擎可以在拒绝态未处理的情况下提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告：</p>
<pre><code>JavaScript 代码:
async function foo() {
throw new Error(&apos;Problem!&apos;);
}
foo();
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/05/08/TypeScript入门/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/05/08/TypeScript入门/" itemprop="url">TypeScript入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T21:04:54+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前angular、deno已经开始使用typescript，并且我们熟知的vue，在3.0也即将会使用typescript，可以说，前端领域，typescript会逐渐变为必备的技能，那么，为什么typescript变得越来越火呢？</p>
<p>网上有各种typescript和javascript的对比，那么在我的角度的理解，javascript是解释型（动态）语言，可以说是从上到下执行，在我们开发过程中，比如有语法错误等等，需要执行到这一行代码才能知道，而typescript则像写易语言那样生成exe时，需要静态编译，而静态编译这个过程，会把代码都检查一遍，看是否通过检测，最终才生成exe，typescript最终是也是编译成javascript原生代码的，只是在这个生成过程中，会进行各种检测，来检查代码是否符合语法啊规则啊，符合的话最终再编译成javascript，规范了我们代码的编写，同时也提高了代码的复用以及组件化，在runtime阶段为我们提前找到错误。<br><img src="/2018/05/08/TypeScript入门/1.webp" alt=""><br>typescript支持es5/es6的语法，并且扩展了javascript语法，更像java、c#、swift这种语言了。</p>
<p>在前端nodejs很火，但是为什么在后端却不火，很大程度也是因为nodejs也是解释型（动态）语言，优势就是解释型语言比较灵活，但是缺点也很明显，用node开发后台程序，开发一直爽，重构火葬场.一旦重构了，就会出现很多问题，像Java、c#这类语言，非常严谨，类型检查等非常严谨，而javascript呢，一般是靠我们用肉眼去排查，很麻烦，typescript就是解决这一类问题的。</p>
<p>总而言之，typescript是未来的趋势，也是谷歌推荐的框架，我也是刚学typescript，很多都是站在前辈的肩膀总结的，废话不多说，我们开始进入正题吧！</p>
<hr>
<h2 id="TypeScript-安装"><a href="#TypeScript-安装" class="headerlink" title="TypeScript 安装"></a>TypeScript 安装</h2><p>首先我们全局安装</p>
<p><code>npm i typescript -g</code></p>
<p>全局安装完成后，我们新建一个<code>hello.ts</code>的ts文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;TypeScript&quot;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个ts文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;TypeScript&quot;</span><br></pre></td></tr></table></figure></p>
<p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，我平时使用vscode来开发，需要配置一下vscode就可以。</p>
<p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    /* Basic Options */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                          /* Specify ECMAScript target version: &apos;ES3&apos; (default), &apos;ES5&apos;, &apos;ES2015&apos;, &apos;ES2016&apos;, &apos;ES2017&apos;,&apos;ES2018&apos; or &apos;ESNEXT&apos;. */</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                     /* Specify module code generation: &apos;none&apos;, &apos;commonjs&apos;, &apos;amd&apos;, &apos;system&apos;, &apos;umd&apos;, &apos;es2015&apos;, or &apos;ESNext&apos;. */</span><br><span class="line">    // &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */</span><br><span class="line">    // &quot;allowJs&quot;: true,                       /* Allow javascript files to be compiled. */</span><br><span class="line">    // &quot;checkJs&quot;: true,                       /* Report errors in .js files. */</span><br><span class="line">    // &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &apos;preserve&apos;, &apos;react-native&apos;, or &apos;react&apos;. */</span><br><span class="line">    // &quot;declaration&quot;: true,                   /* Generates corresponding &apos;.d.ts&apos; file. */</span><br><span class="line">    // &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &apos;.d.ts&apos; file. */</span><br><span class="line">    // &quot;sourceMap&quot;: true,                     /* Generates corresponding &apos;.map&apos; file. */</span><br><span class="line">    // &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */</span><br><span class="line">     &quot;outDir&quot;: &quot;./dist&quot;,                        /* Redirect output structure to the directory. */</span><br><span class="line">    // &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span><br><span class="line">    // &quot;composite&quot;: true,                     /* Enable project compilation */</span><br><span class="line">    // &quot;removeComments&quot;: true,                /* Do not emit comments to output. */</span><br><span class="line">    // &quot;noEmit&quot;: true,                        /* Do not emit outputs. */</span><br><span class="line">    // &quot;importHelpers&quot;: true,                 /* Import emit helpers from &apos;tslib&apos;. */</span><br><span class="line">    // &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &apos;for-of&apos;, spread, and destructuring when targeting &apos;ES5&apos; or &apos;ES3&apos;. */</span><br><span class="line">    // &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &apos;ts.transpileModule&apos;). */</span><br><span class="line"></span><br><span class="line">    /* Strict Type-Checking Options */</span><br><span class="line">    &quot;strict&quot;: true,                           /* Enable all strict type-checking options. */</span><br><span class="line">    // &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied &apos;any&apos; type. */</span><br><span class="line">    // &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */</span><br><span class="line">    // &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span><br><span class="line">    // &quot;strictBindCallApply&quot;: true,           /* Enable strict &apos;bind&apos;, &apos;call&apos;, and &apos;apply&apos; methods on functions. */</span><br><span class="line">    // &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span><br><span class="line">    // &quot;noImplicitThis&quot;: true,                /* Raise error on &apos;this&apos; expressions with an implied &apos;any&apos; type. */</span><br><span class="line">    // &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span><br><span class="line"></span><br><span class="line">    /* Additional Checks */</span><br><span class="line">    // &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */</span><br><span class="line">    // &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */</span><br><span class="line">    // &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */</span><br><span class="line">    // &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */</span><br><span class="line"></span><br><span class="line">    /* Module Resolution Options */</span><br><span class="line">    // &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &apos;node&apos; (Node.js) or &apos;classic&apos; (TypeScript pre-1.6). */</span><br><span class="line">    // &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */</span><br><span class="line">    // &quot;paths&quot;: &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the &apos;baseUrl&apos;. */</span><br><span class="line">    // &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span><br><span class="line">    // &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */</span><br><span class="line">    // &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */</span><br><span class="line">    // &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span><br><span class="line">    &quot;esModuleInterop&quot;: true                   /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &apos;allowSyntheticDefaultImports&apos;. */</span><br><span class="line">    // &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    // &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span><br><span class="line">    // &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */</span><br><span class="line">    // &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */</span><br><span class="line">    // &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &apos;--inlineSourceMap&apos; or &apos;--sourceMap&apos; to be set. */</span><br><span class="line"></span><br><span class="line">    /* Experimental Options */</span><br><span class="line">    // &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */</span><br><span class="line">    // &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个json文件里有很多选项</p>
<ul>
<li><code>target</code>是选择编译到什么语法</li>
<li><code>module</code>则是模块类型</li>
<li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li>
</ul>
<p>接下来我们需要开启监控了，在vscode任务栏中<br><img src="/2018/05/08/TypeScript入门/2.webp" alt=""><br><img src="/2018/05/08/TypeScript入门/3.webp" alt=""><br><img src="/2018/05/08/TypeScript入门/4.webp" alt=""><br>此时就会开启监控了，会监听ts的变化，然后自动去编译。</p>
<hr>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>java、c#是强类型语言，而js是弱类型语言，强弱类语言有什么区别呢？typescript最大的优点就是类型检查，可以帮你检查你定义的类型和赋值的类型。</p>
<h4 id="布尔类型boolean"><a href="#布尔类型boolean" class="headerlink" title="布尔类型boolean"></a>布尔类型boolean</h4><pre><code>// 在js中，定义isFlag为true，为布尔类型boolean
let isFlag = true;
// 但是我们也可以重新给它赋值为字符串
isFlag = &quot;hello swr&quot;;

// 在ts中，定义isFlag为true，为布尔类型boolean
// 在变量名后加冒号和类型，如  :boolean
let isFlag:boolean = true
// 重新赋值到字符串类型会报错
isFlag = &quot;hello swr&quot; 

// 在java中，一般是这样定义，要写变量名也要写类型名
// int a = 10; 
// string name = &quot;TypeScript&quot;
</code></pre><h4 id="数字类型number"><a href="#数字类型number" class="headerlink" title="数字类型number"></a>数字类型number</h4><pre><code>let age:number = 28;
age = 29;
</code></pre><h4 id="字符串类型string"><a href="#字符串类型string" class="headerlink" title="字符串类型string"></a>字符串类型string</h4><pre><code>let name:string = &quot;TypeScript&quot;
name = &quot;iamswr&quot;
</code></pre><p>以上<code>boolean、number、string</code>类型有个共性，就是可以通过<code>typeof</code>来获取到是什么类型，是基本数据类型。</p>
<p>那么复杂的数据类型是怎么处理的呢？</p>
<h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h4><pre><code>// 在js中
let pets = [&quot;旺财&quot;,&quot;小黑&quot;];

// 在ts中
// 需要注意的是，这个是一个字符串类型的数组
// 只能往里面写字符串，写别的类型会报错
let pets:string[] = [&quot;旺财&quot;,&quot;小黑&quot;];

// 另外一种ts写法
let pets:Array&lt;string&gt; = [&quot;旺财&quot;,&quot;小黑&quot;];

// 那么如果想在数组里放对象呢？
let pets:Array&lt;object&gt; = [{name:&quot;旺财&quot;},{name:&quot;小黑&quot;}];

// 那么怎样在一个数组中，随意放string、number、boolean类型呢？
// 这里的 | 相当于 或 的意思
let arr:Array&lt;string|number|boolean&gt; = [&quot;hello swr&quot;,28];

// 想在数组中放任意类型
let arr:Array&lt;any&gt; = [&quot;hello swr&quot;,28,true]
</code></pre><h4 id="元组类型tuple"><a href="#元组类型tuple" class="headerlink" title="元组类型tuple"></a>元组类型tuple</h4><p>什么是元组类型？其实元组是数组的一种。</p>
<pre><code>let person:[string,number] = [&apos;TypeScript&apos;,28]
</code></pre><p>有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上，多了少了或者类型不对都会报错。</p>
<p>元组类型是一个不可变的数组，长度、类型是不可变的。</p>
<h4 id="枚举类型enum"><a href="#枚举类型enum" class="headerlink" title="枚举类型enum"></a>枚举类型enum</h4><p>枚举在java中是从6.0才引入的一种类型，在java和ts中的关键字都是<code>enum</code>。</p>
<p>什么是枚举？枚举有点类似一一列举，一个一个数出来，在易语言中，我们会经常枚举窗口，来找到自己想要的，一般用于值是某几个固定的值，比如生肖（有12种）、星座（有12种）、性别（男女）等，这些值是固定的，可以一个一个数出来。</p>
<p>为什么我们要用枚举呢？我们可以定义一些值，定义完了后可以直接拿来用了，用的时候也不会赋错值。</p>
<p>比如我们普通赋值</p>
<pre><code>// 我们给性别赋值一个boy，但是我们有时候手误，可能输成boy1、boy2了
// 这样就会导致我们赋值错误了
let sex = &quot;boy&quot;
</code></pre><p>既然这样容易导致手误赋错值，那么我们可以定义一个枚举</p>
<pre><code>// 定义一个枚举类型的值
enum sex {
  BOY,
  GIRL
}
console.log(sex)
console.log(`TypeScript是${sex.BOY}`)
</code></pre><p>我们看看转为es5语法是怎样的</p>
<pre><code>// 转为es5语法
&quot;use strict&quot;;
var sex;
(function (sex) {
    sex[sex[&quot;BOY&quot;] = 0] = &quot;BOY&quot;;
    sex[sex[&quot;GIRL&quot;] = 1] = &quot;GIRL&quot;;
})(sex || (sex = {}));
console.log(sex); // 打印输出{ &apos;0&apos;: &apos;BOY&apos;, &apos;1&apos;: &apos;GIRL&apos;, BOY: 0, GIRL: 1 }
console.log(&quot;\u90B5\u5A01\u5112\u662F&quot; + sex.BOY); // 打印输出 TypeScript是0
</code></pre><p>是不是感觉有点像给对象添加各种属性，然后这个属性又有点像常量，然后通过对象去取这个属性？</p>
<p>上面这样写，不是很友好，那么我们还可以给<code>BOY`</code>GIRL`赋值</p>
<pre><code>enum sex{
    BOY=&quot;男&quot;,
    GIRL=&quot;女&quot;
}


// 转化为es5语法
// 我们顺便看看实现的原理
&quot;use strict&quot;;
var sex;
// 首先这里是一个自执行函数
// 并且把sex定义为对象，传参进给自执行函数
// 然后给sex对象添加属性并且赋值
(function (sex) {
    sex[&quot;BOY&quot;] = &quot;\u7537&quot;;
    sex[&quot;GIRL&quot;] = &quot;\u5973&quot;;
})(sex || (sex = {}));
console.log(sex); // 打印输出 { BOY: &apos;男&apos;, GIRL: &apos;女&apos; }
console.log(&quot;\u90B5\u5A01\u5112\u662F&quot; + sex.BOY); // 打印输出 TypeScript是男
</code></pre><p>比如我们实际项目中，特别是商城类，订单会存在很多状态流转，那么非常适合用枚举</p>
<pre><code>enum orderStatus {
    WAIT_FOR_PAY = &quot;待支付&quot;,
    UNDELIVERED = &quot;完成支付，待发货&quot;,
    DELIVERED = &quot;已发货&quot;,
    COMPLETED = &quot;已确认收货&quot;
}
</code></pre><p>到这里，我们会有一个疑虑，为什么我们不这样写呢？</p>
<pre><code>let orderStatus2 = {
    WAIT_FOR_PAY : &quot;待支付&quot;,
    ...
}
</code></pre><p>如果我们直接写对象的键值对方式，是可以在外部修改这个值的，而我们通过<code>enum</code>则不能修改定义好的值了，更加严谨。</p>
<h4 id="任意类型-any"><a href="#任意类型-any" class="headerlink" title="任意类型 any"></a>任意类型 any</h4><p><code>any</code>有好处也有坏处，特别是前端，很多时候写类型的时候，几乎分不清楚类型，任意去写，写起来很爽，但是对于后续的重构、迭代等是非常不友好的，会暴露出很多问题，某种程度来说，any类型就是放弃了类型检查了。。。</p>
<p>比如我们有这样一个场景，就是需要获取某一个dom节点</p>
<pre><code>let btn = document.getElementById(&apos;btn&apos;);
btn.style.color = &quot;blue&quot;;
</code></pre><p>此时我们发现在ts中会报错<br> <img src="/2018/05/08/TypeScript入门/5.webp" alt=""><br> 因为我们取这个dom节点，有可能取到，也有可能没取到，当没取到的时候，相当于是null，是没有style这个属性的。</p>
<p>那么我们可以给它添加一个类型为<code>any</code></p>
<pre><code>// 添加一个any类型，此时就不会报错了，但是也相当于放弃了类型检查了
let btn:any = document.getElementById(&apos;btn&apos;);
btn.style.color = &quot;blue&quot;;

// 当然也有粗暴一些的方式，利用 ! 强制断言
let btn = document.getElementById(&quot;btn&quot;);
btn!.style!.color = &quot;blue&quot;;

// 可以赋值任何类型的值
// 跟以前我们var let声明的一模一样的
let person:any = &quot;TypeScript&quot;
person = 28
</code></pre><h4 id="null-undefined类型"><a href="#null-undefined类型" class="headerlink" title="null undefined类型"></a>null undefined类型</h4><p>这个也没什么好说的，不过可以看下下面的例子</p>
<pre><code>// (string | number | null | undefined) 相当于这几种类型
// 是 string 或 number 或 null 或 undefined
let str:(string | number | null | undefined)
str = &quot;hello swr&quot;
str = 28
str = null
str = undefined
</code></pre><h4 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h4><p>void表示没有任何类型，一般是定义函数没有返回值。</p>
<pre><code>// ts写法
function say(name:string):void {
  console.log(&quot;hello&quot;,name)
}
say(&quot;swr&quot;)


// 转为es5
&quot;use strict&quot;;
function say(name) {
    console.log(&quot;hello&quot;, name);
}
say(&quot;swr&quot;);
</code></pre><p>怎么理解叫没有返回值呢？此时我们给函数return一个值</p>
<pre><code>function say(name:string):void {
  console.log(&quot;hello&quot;,name)
  // return&quot;ok&quot; 会报错
  return&quot;ok&quot;
  // return undefined 不会报错
  // return 不会报错
}
say(&quot;swr&quot;)
</code></pre><p>那么此时我们希望这个函数返回一个字符串类型怎么办？</p>
<pre><code>function say(name:string):string {
  console.log(&quot;hello&quot;,name)
  return&quot;ok&quot;
}
say(&quot;swr&quot;)
</code></pre><h4 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h4><p>这个用得很少，一般是用于抛出异常。</p>
<pre><code>let xx:never;
function error(message: string): never {
  throw new Error(message);
}

error(&quot;error&quot;)
</code></pre><h4 id="我们要搞明白any、never、void"><a href="#我们要搞明白any、never、void" class="headerlink" title="我们要搞明白any、never、void"></a>我们要搞明白any、never、void</h4><ul>
<li>any是任意的值</li>
<li>void是不能有任何值</li>
<li>never永远不会有返回值</li>
</ul>
<p><code>any</code>比较好理解，就是任何值都可以</p>
<pre><code>let str:any = &quot;hello swr&quot;
str = 28
str = true
</code></pre><p><code>void</code>不能有任何值(返回值)</p>
<pre><code>function say():void {

}
</code></pre><p><code>never</code>则不好理解，什么叫永远不会有返回值？</p>
<pre><code>// 除了上面举例的抛出异常以外，我们看一下这个例子
// 这个loop函数，一旦开始执行，就永远不会结束
// 可以看出在while中，是死循环，永远都不会有返回值，包括undefined

function loop():never {
    while(true){
        console.log(&quot;陷入死循环啦&quot;)
    }
}

loop()

// 包括比如JSON.parse也是使用这种 never | any
function parse(str:string):(never | any){
    return JSON.parse(str)
}
// 首先在正常情况下，我们传一个JSON格式的字符串，是可以正常得到一个JSON对象的
let json = parse(&apos;{&quot;name&quot;:&quot;TypeScript&quot;}&apos;)
// 但是有时候，传进去的不一定是JSON格式的字符串，那么就会抛出异常
// 此时就需要never了
let json = parse(&quot;iamswr&quot;)
</code></pre><p>也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。</p>
<p>实际开发中，是never和联合类型来一起用，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():(never | string) &#123;</span><br><span class="line">  return &quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是这样定义的</p>
<pre><code>function say(name:string):void {
  console.log(&quot;hello&quot;,name)
}
say(&quot;TypeScript&quot;)
</code></pre><p>形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数放在后面</p>
<pre><code>// 形参和实参一一对应，完全一样
function say(name:string,age:number):void {
  console.log(&quot;hello&quot;,name,age)
}
say(&quot;TypeScript&quot;,28)


// 可选参数，用 ？ 处理，只能放在后面
function say(name:string,age?:number):void {
  console.log(&quot;hello&quot;,name,age)
}
say(&quot;TypeScript&quot;)
</code></pre><p>那么如何设置默认参数呢？</p>
<pre><code>// 在js中我们是这样写的
function ajax(url,method=&quot;get&quot;){
    console.log(url,method)
}

// 在ts中我们是这样写的
function ajax(url:string,method:string = &quot;GET&quot;) {
  console.log(url,method)
}
</code></pre><p>那么如何设置剩余参数呢？可以利用扩展运算符</p>
<pre><code>function sum(...args:Array&lt;number&gt;):number {
  returneval(args.join(&quot;+&quot;))
}
let total:number = sum(1,2,3,4,5)
console.log(total)
</code></pre><p>那么如何实现函数重载呢？函数重载是java中非常有名的，在java中函数的重载，是指两个或者两个以上的同名函数，参数的个数和类型不一样</p>
<pre><code>// 比如说我们现在有2个同名函数
function say(name:string){

}
function say(name:string,age:number){

}
// 那么我想达到一个效果
// 当我传参数name时，执行name:string这个函数
// 当我传参数name和age时，执行name:string,age:number这个函数
// 此时该怎么办？
</code></pre><h4 id="接下来看一下typescript中的函数重载"><a href="#接下来看一下typescript中的函数重载" class="headerlink" title="接下来看一下typescript中的函数重载"></a>接下来看一下typescript中的函数重载</h4><pre><code>// 首先声明两个函数名一样的函数
function say(val: string): void; // 函数的声明
function say(val: number): void; // 函数的声明
// 函数的实现，注意是在这里是有函数体的
// 其实下面的say()无论怎么执行，实际上就是执行下面的函数
function say(val: any):void {
  console.log(val)
}

say(&quot;hello swr&quot;)
say(28)
</code></pre><p>在typescript中主要体现是同一个同名函数提供多个函数类型定义，函数实际上就只有一个，就是拥有函数体那个，如果想根据传入值类型的不一样执行不同逻辑，则需要在这个函数里面进行一个类型判断。</p>
<p>那么这个函数重载有什么作用呢？其实在ts中，函数重载只是用来限制参数的个数和类型，用来检查类型的，而且重载不能拆开几个函数，这一点和java的处理是不一样的，需要注意。</p>
<hr>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="如何定义一个类？"><a href="#如何定义一个类？" class="headerlink" title="如何定义一个类？"></a>如何定义一个类？</h4><pre><code>// ts写法
// 其实跟es6非常像，没太大的区别
class Person{
  // 这里声明的变量，是实例上的属性
  name:string
  age:number
  constructor(name:string,age:number){
    // this.name和this.age必须在前面先声明好类型
    // name:string   age:number
    this.name = name
    this.age = age
  }
  // 原型方法
  say():string{
    return&quot;hello swr&quot;
  }
}

let p = new Person(&quot;TypeScript&quot;,28)


// 那么转为es5呢？
&quot;use strict&quot;;
var Person = /** @class */ (function () {
    function Person(name, age) {
        this.name = name;
        this.age = age;
    }
    Person.prototype.say = function () {
        return&quot;hello swr&quot;;
    };
    return Person;
}());
var p = new Person(&quot;TypeScript&quot;, 28);
</code></pre><h4 id="可以发现，其实跟我们es6的class是非常像的，那么类的继承是怎样实现呢？"><a href="#可以发现，其实跟我们es6的class是非常像的，那么类的继承是怎样实现呢？" class="headerlink" title="可以发现，其实跟我们es6的class是非常像的，那么类的继承是怎样实现呢？"></a>可以发现，其实跟我们es6的class是非常像的，那么类的继承是怎样实现呢？</h4><pre><code>// 类的继承和es6也是差不多
class Parent{
  // 这里声明的变量，是实例上的属性
  name:string
  age:number
  constructor(name:string,age:number){
    // this.name和this.age必须在前面先声明好类型
    // name:string   age:number
    this.name = name
    this.age = age
  }
  // 原型方法
  say():string{
    return&quot;hello swr&quot;
  }
}

class Child extends Parent{
  childName:string
  constructor(name:string,age:number,childName:string){
    super(name,age)
    this.childName = childName
  }
  childSay():string{
    return this.childName
  }
}

let child = new Child(&quot;TypeScript&quot;,28,&quot;bb&quot;)
console.log(child)
</code></pre><h4 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h4><ul>
<li><code>public</code>公开的，可以供自己、子类以及其它类访问</li>
<li><code>protected</code>受保护的，可以供自己、子类访问，但是其他就访问不了</li>
<li><code>private</code>私有的，只有自己访问，而子类、其他都访问不了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">  public name:string</span><br><span class="line">  protected age:number</span><br><span class="line">  private money:number</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 也可以简写为</span><br><span class="line">   * constructor(public name:string,protected age:number,private money:number)</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  constructor(name:string,age:number,money:number)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">    this.money = money</span><br><span class="line">  &#125;</span><br><span class="line">  getName():string&#123;</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">  getAge():number&#123;</span><br><span class="line">    return this.age</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney():number&#123;</span><br><span class="line">    return this.money</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Parent(&quot;TypeScript&quot;,28,10)</span><br><span class="line">console.log(p.name)</span><br><span class="line">console.log(p.age) // 报错</span><br><span class="line">console.log(p.money) // 报错</span><br></pre></td></tr></table></figure>
<h4 id="静态属性、静态方法，跟es6差不多"><a href="#静态属性、静态方法，跟es6差不多" class="headerlink" title="静态属性、静态方法，跟es6差不多"></a>静态属性、静态方法，跟es6差不多</h4><pre><code>class Person{
    // 这是类的静态属性
    static name = &quot;TypeScript&quot;
    // 这是类的静态方法，需要通过这个类去调用
    static say(){
        console.log(&quot;hello swr&quot;)
    }
}
let p = new Person()
Person.say() // hello swr
p.say() // 报错
</code></pre><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类和方法，有点类似抽取共性出来，但是又不是具体化，比如说，世界上的动物都需要吃东西，那么会把吃东西这个行为，抽象出来。</p>
<p>如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错。</p>
<pre><code>// 关键字 abstract 抽象的意思
// 首先定义个抽象类Animal
// Animal类有一个抽象方法eat
abstract class Animal{
    // 实际上是使用了public修饰符
    // 如果添加private修饰符则会报错
    abstract eat():void;
}

// 需要注意的是，这个Animal类是不能实例化的
let animal = new Animal() // 报错

// 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中
// 实现这个抽象方法，不然会报错
// 报错，因为在子类中没有实现eat抽象方法
class Person extends Animal{
    eat1(){
        console.log(&quot;吃米饭&quot;)
    }
}

// Dog类继承Animal类后并且实现了抽象方法eat，所以不会报错
class Dog extends Animal{
    eat(){
        console.log(&quot;吃骨头&quot;)
    }
}
</code></pre><hr>
<h2 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h2><p>这里的接口，主要是一种规范，规范某些类必须遵守规范，和抽象类有点类似，但是不局限于类，还有属性、函数等。</p>
<h4 id="首先我们看看接口是如何规范对象的"><a href="#首先我们看看接口是如何规范对象的" class="headerlink" title="首先我们看看接口是如何规范对象的"></a>首先我们看看接口是如何规范对象的</h4><pre><code>// 假设我需要获取用户信息
// 我们通过这样的方式，规范必须传name和age的值
function getUserInfo(user:{name:string,age:number}){
    console.log(`${user.name}${user.age}`)
}
getUserInfo({name:&quot;TypeScript&quot;,age:28})
</code></pre><p>这样看，还是挺完美的，那么问题就出现了，如果我另外还有一个方法，也是需要这个规范呢？</p>
<pre><code>function getUserInfo(user:{name:string,age:number}){
    console.log(`${user.name}${user.age}`)
}
function getInfo(user:{name:string,age:number}){
    console.log(`${user.name}${user.age}`)
}
getUserInfo({name:&quot;TypeScript&quot;,age:28})
getInfo({name:&quot;iamswr&quot;,age:28})
</code></pre><p>可以看出，函数<code>getUserInfo</code>和<code>getInfo</code>都遵循同一个规范，那么我们有办法对这个规范复用吗？</p>
<pre><code>// 首先把需要复用的规范，写到接口中 关键字 interface
interface infoInterface{
    name:string,
    age:number
}
// 然后把这个接口，替换到我们需要复用的地方
function getUserInfo(user:infoInterface){
    console.log(`${user.name}${user.age}`)
}
function getInfo(user:infoInterface){
    console.log(`${user.name}${user.age}`)
}
getUserInfo({name:&quot;TypeScript&quot;,age:28})
getInfo({name:&quot;iamswr&quot;,age:28})
</code></pre><p>那么有些参数可传可不传，该怎么处理呢？</p>
<pre><code>interface infoInterface{
    name:string,
    age:number,
    city?:string // 该参数为可选参数
}
function getUserInfo(user:infoInterface){
    console.log(`${user.name}${user.age}${user.city}`)
}
function getInfo(user:infoInterface){
    console.log(`${user.name}${user.age}`)
}
getUserInfo({name:&quot;TypeScript&quot;,age:28,city:&quot;深圳&quot;})
getInfo({name:&quot;iamswr&quot;,age:28})
</code></pre><h4 id="接口是如何规范函数的"><a href="#接口是如何规范函数的" class="headerlink" title="接口是如何规范函数的"></a>接口是如何规范函数的</h4><pre><code>// 对一个函数的参数和返回值进行规范
interface mytotal {
  // 左侧是函数的参数，右侧是函数的返回类型
  (a:number,b:number) : number
}

let total:mytotal = function (a:number,b:number):number {
  return a + b
}

console.log(total(10,20))
</code></pre><h4 id="接口是如何规范数组的"><a href="#接口是如何规范数组的" class="headerlink" title="接口是如何规范数组的"></a>接口是如何规范数组的</h4><pre><code>interface userInterface {
  // index为数组的索引，类型是number
  // 右边是数组里为字符串的数组成员
  [index: number]: string
}
let arr: userInterface = [&apos;TypeScript&apos;, &apos;iamswr&apos;];
console.log(arr);
</code></pre><h4 id="接口是如何规范类的"><a href="#接口是如何规范类的" class="headerlink" title="接口是如何规范类的"></a>接口是如何规范类的</h4><p>这个比较重要，因为写react的时候会经常使用到类</p>
<pre><code>// 首先实现一个接口
interface Animal{
    // 这个类必须有name
    name:string,
    // 这个类必须有eat方法
    // 规定eat方法的参数类型以及返回值类型
    eat(any:string):void
}
// 关键字 implements 实现
// 因为接口是抽象的，需要通过子类去实现它
class Person implements Animal{
    name:string
    constructor(name:string){
        this.name = name
    }
    eat(any:string):void{
        console.log(`吃${any}`)
    }
}
</code></pre><p>那么如果想遵循多个接口呢？</p>
<pre><code>interface Animal{
    name:string,
    eat(any:string):void
}
// 新增一个接口
interface Animal2{
    sleep():void
}
// 可以在implements后面通过逗号添加，和java是一样的
// 一个类只能继承一个父类，但是却能遵循多个接口
class Person implements Animal,Animal2{
    name:string
    constructor(name:string){
        this.name = name
    }
    eat(any:string):void{
        console.log(`吃${any}`)
    }
    sleep(){
        console.log(&apos;睡觉&apos;)
    }
}
</code></pre><h4 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h4><pre><code>interface Animal{
    name:string,
    eat(any:string):void
}
// 像类一样，通过extends继承
interface Animal2 extends Animal{
    sleep():void
}
// 因为Animal2类继承了Animal
// 所以这里遵循Animal2就相当于把Animal也继承了
class Person implements Animal2{
    name:string
    constructor(name:string){
        this.name = name
    }
    eat(any:string):void{
        console.log(`吃${any}`)
    }
    sleep(){
        console.log(&apos;睡觉&apos;)
    }
}
</code></pre><hr>
<h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><p>泛型可以支持不特定的数据类型，什么叫不特定呢？比如我们有一个方法，里面接收参数，但是参数类型我们是不知道，但是这个类型在方法里面很多地方会用到，参数和返回值要保持一致性</p>
<pre><code>// 假设我们有一个需求，我们不知道函数接收什么类型的参数，也不知道返回值的类型
// 而我们又需要传进去的参数类型和返回值的类型保持一致，那么我们就需要用到泛型

// &lt;T&gt;的意思是泛型，即generic type
// 可以看出value的类型也为T，返回值的类型也为T
function deal&lt;T&gt;(value:T):T{
    return value
}
// 下面的&lt;string&gt;、&lt;number&gt;实际上用的时候再传给上面的&lt;T&gt;
console.log(deal&lt;string&gt;(&quot;TypeScript&quot;))
console.log(deal&lt;number&gt;(28))
</code></pre><h4 id="实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的"><a href="#实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的" class="headerlink" title="实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的"></a>实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的</h4><pre><code>class MyMath&lt;T&gt;{
  // 定义一个私有属性
  private arr:T[] = []
  // 规定传参类型
  add(value:T){
    this.arr.push(value)
  }
  // 规定返回值的类型
  max():T{
    return Math.max.apply(null,this.arr)
  }
}

// 这里规定了类型为number
// 相当于把T都替换成number
let mymath = new MyMath&lt;number&gt;()
mymath.add(1)
mymath.add(2)
mymath.add(3)
console.log(mymath.max())

// 假设我们传个字符串呢？
// 则会报错:类型“&quot;TypeScript&quot;”的参数不能赋给类型“number”的参数。
mymath.add(&quot;TypeScript&quot;)
</code></pre><p>那么我们会思考，有了接口为什么还需要抽象类？</p>
<p>接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。</p>
<p>比如说，我们父类有10个方法，其中9个是实现过的方法，有1个是抽象的方法，那么子类继承过来，只需要实现这一个抽象的方法就可以了，但是接口的话，则是全是抽象的，子类都要实现这些方法，简而言之，接口里面不可以放实现，而抽象类可以放实现。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/2018/05/02/20个CSS高级技巧汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/blog/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2018/05/02/20个CSS高级技巧汇总/" itemprop="url">20个 CSS高级技巧汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T16:24:04+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用技巧会让人变的越来越懒，没错，我就是想让你变懒。下面是我收集的CSS高级技巧，希望你懒出境界。</p>
<h2 id="1-黑白图像"><a href="#1-黑白图像" class="headerlink" title="1. 黑白图像"></a>1. 黑白图像</h2><p>这段代码会让你的彩色照片显示为黑白照片，是不是很酷？</p>
<pre><code>img.desaturate {
 filter: grayscale(100%);
-webkit-filter: grayscale(100%);
-moz-filter: grayscale(100%);
-ms-filter: grayscale(100%);
-o-filter: grayscale(100%);
}
</code></pre><h2 id="2-使用-not-在菜单上应用-取消应用边框"><a href="#2-使用-not-在菜单上应用-取消应用边框" class="headerlink" title="2. 使用 :not() 在菜单上应用/取消应用边框"></a>2. 使用 <code>:not()</code> 在菜单上应用/取消应用边框</h2><p>先给每一个菜单项添加边框</p>
<pre><code>/* add border */
.nav li {
 border-right: 1px solid #666;
}
</code></pre><p>然后再除去最后一个元素</p>
<pre><code>// remove border /

.nav li:last-child {
 border-right: none;
}
</code></pre><p>可以直接使用 :not() 伪类来应用元素：</p>
<pre><code>.nav li:not(:last-child) {
 border-right: 1px solid #666;
}
</code></pre><p>这样代码就干净，易读，易于理解了。</p>
<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>
<pre><code>.nav li:first-child ~ li {
 border-left: 1px solid #666;
}
</code></pre><h2 id="3-页面顶部阴影"><a href="#3-页面顶部阴影" class="headerlink" title="3. 页面顶部阴影"></a>3. 页面顶部阴影</h2><p>下面这个简单的 CSS3 代码片段可以给网页加上漂亮的顶部阴影效果：</p>
<pre><code>body:before {
 content: &quot;&quot;;
 position: fixed;
 top: -10px;
 left: 0;
 width: 100%;
 height: 10px;

-webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
-moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
 box-shadow: 0px 0px 10px rgba(0,0,0,.8);

 z-index: 100;
}
</code></pre><h2 id="4-给-body-添加行高"><a href="#4-给-body-添加行高" class="headerlink" title="4. 给 body 添加行高"></a>4. 给 body 添加行高</h2><p>你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可：</p>
<pre><code>body {
 line-height: 1;
}
</code></pre><p>这样文本元素就可以很容易地从 body 继承。</p>
<h2 id="5-所有一切都垂直居中"><a href="#5-所有一切都垂直居中" class="headerlink" title="5. 所有一切都垂直居中"></a>5. 所有一切都垂直居中</h2><p>要将所有元素垂直居中，太简单了：</p>
<pre><code>html, body {
 height: 100%;
 margin: 0;
}

body {
-webkit-align-items: center; 
-ms-flex-align: center; 
 align-items: center;
 display: -webkit-flex;
 display: flex;
}
</code></pre><p>看，是不是很简单。</p>
<p>注意：在IE11中要小心flexbox</p>
<h2 id="6-逗号分隔的列表"><a href="#6-逗号分隔的列表" class="headerlink" title="6. 逗号分隔的列表"></a>6. 逗号分隔的列表</h2><p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>
<pre><code>ul &gt; li:not(:last-child)::after {
 content: &quot;,&quot;;
}
</code></pre><p>对最后一个列表项使用 :not() 伪类。</p>
<h2 id="7-使用负的-nth-child-选择项目"><a href="#7-使用负的-nth-child-选择项目" class="headerlink" title="7. 使用负的 nth-child 选择项目"></a>7. 使用负的 nth-child 选择项目</h2><p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>
<pre><code>li {
 display: none;
}

/* select items 1 through 3 and display them */
li:nth-child(-n+3) {
 display: block;
}
</code></pre><h2 id="8-对图标使用-SVG"><a href="#8-对图标使用-SVG" class="headerlink" title="8. 对图标使用 SVG"></a>8. 对图标使用 SVG</h2><p>我们没有理由不对图标使用SVG：</p>
<pre><code>.logo {
 background: url(&quot;logo.svg&quot;);
}
</code></pre><p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>
<h2 id="9-优化显示文本"><a href="#9-优化显示文本" class="headerlink" title="9. 优化显示文本"></a>9. 优化显示文本</h2><p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>
<pre><code>html {
-moz-osx-font-smoothing: grayscale;
-webkit-font-smoothing: antialiased;
 text-rendering: optimizeLegibility;
}
</code></pre><p>注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。</p>
<h2 id="10-对纯-CSS-滑块使用-max-height"><a href="#10-对纯-CSS-滑块使用-max-height" class="headerlink" title="10. 对纯 CSS 滑块使用 max-height"></a>10. 对纯 CSS 滑块使用 max-height</h2><p>使用 max-height 和溢出隐藏来实现只有CSS的滑块：</p>
<pre><code>.slider ul {
 max-height: 0;
 overlow: hidden;
}

.slider:hover ul {
 max-height: 1000px;
 transition: .3s ease;
}
</code></pre><h2 id="11-继承-box-sizing"><a href="#11-继承-box-sizing" class="headerlink" title="11. 继承 box-sizing"></a>11. 继承 box-sizing</h2><p>让 box-sizing 继承 html：</p>
<pre><code>html {
 box-sizing: border-box;
}

*, *:before, *:after {
 box-sizing: inherit;
}
</code></pre><p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。</p>
<h2 id="12-表格单元格等宽"><a href="#12-表格单元格等宽" class="headerlink" title="12. 表格单元格等宽"></a>12. 表格单元格等宽</h2><p>表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽：</p>
<pre><code>.calendar {
 table-layout: fixed;
}
</code></pre><h2 id="13-用-Flexbox-摆脱外边距的各种-hack"><a href="#13-用-Flexbox-摆脱外边距的各种-hack" class="headerlink" title="13. 用 Flexbox 摆脱外边距的各种 hack"></a>13. 用 Flexbox 摆脱外边距的各种 hack</h2><p>当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了：</p>
<pre><code>.list {
 display: flex;
 justify-content: space-between;
}

.list .person {
 flex-basis: 23%;
}
</code></pre><p>现在，列表分隔符就会在均匀间隔的位置出现。</p>
<h2 id="14-使用属性选择器用于空链接"><a href="#14-使用属性选择器用于空链接" class="headerlink" title="14. 使用属性选择器用于空链接"></a>14. 使用属性选择器用于空链接</h2><p>当a元素没有文本值，但 href 属性有链接的时候显示链接：</p>
<pre><code>a[href^=&quot;http&quot;]:empty::before {
 content: attr(href);
}
</code></pre><p>相当方便。</p>
<h2 id="15-检测鼠标双击"><a href="#15-检测鼠标双击" class="headerlink" title="15. 检测鼠标双击"></a>15. 检测鼠标双击</h2><p>HTML：</p>
<pre><code>&lt;div class=&quot;test3&quot;&gt;
&lt;span&gt;&lt;input type=&quot;text&quot; value=&quot; &quot; readonly=&quot;true&quot; /&gt;
&lt;a href=&quot;http://renpingjun.com&quot;&gt;Double click me&lt;/a&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>CSS：</p>
<pre><code>.test3 span {
 position: relative;
}
.test3 span a {
 position: relative;
 z-index: 2;
}
.test3 span a:hover, .test3 span a:active {
 z-index: 4;
}
.test3 span input {
 background: transparent;
 border: 0;
 cursor: pointer;
 position: absolute;
 top: -1px;
 left: 0;
 width: 101%; /* Hacky */
 height: 301%; /* Hacky */
 z-index: 3;
}
.test3 span input:focus {
 background: transparent;
 border: 0;
 z-index: 1;
}
</code></pre><h2 id="16-CSS-写出三角形"><a href="#16-CSS-写出三角形" class="headerlink" title="16. CSS 写出三角形"></a>16. CSS 写出三角形</h2><pre><code>/* create an arrow that points up */
div.arrow-up {
 width:0px;
 height:0px;
 border-left:5px solid transparent; /* left arrow slant */
 border-right:5px solid transparent; /* right arrow slant */
 border-bottom:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points down */
div.arrow-down {
 width:0px;
 height:0px;
 border-left:5px solid transparent;
 border-right:5px solid transparent;
 border-top:5px solid #2f2f2f;
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points left */
div.arrow-left {
 width:0px;
 height:0px;
 border-bottom:5px solid transparent; /* left arrow slant */
 border-top:5px solid transparent; /* right arrow slant */
 border-right:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points right */
div.arrow-right {
 width:0px;
 height:0px;
 border-bottom:5px solid transparent; /* left arrow slant */
 border-top:5px solid transparent; /* right arrow slant */
 border-left:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}
</code></pre><h2 id="17-CSS3-calc-的使用"><a href="#17-CSS3-calc-的使用" class="headerlink" title="17. CSS3 calc() 的使用"></a>17. CSS3 calc() 的使用</h2><p>calc() 用法类似于函数，能够给元素设置动态的值：</p>
<pre><code>/* basic calc */
.simpleBlock {
 width: calc(100% - 100px);
}

/* calc in calc */
.complexBlock {
 width: calc(100% - 50% / 3);
 padding: 5px calc(3% - 2px);
 margin-left: calc(10% + 10px);
}
</code></pre><h2 id="18-文本渐变"><a href="#18-文本渐变" class="headerlink" title="18. 文本渐变"></a>18. 文本渐变</h2><p>文本渐变效果很流行，使用 CSS3 能够很简单就实现：</p>
<pre><code>h2[data-text] {
 position: relative;
}
h2[data-text]::after {
 content: attr(data-text);
 z-index: 10;
 color: #e3e3e3;
 position: absolute;
 top: 0;
 left: 0;
-webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));}
</code></pre><h2 id="19-禁用鼠标事件"><a href="#19-禁用鼠标事件" class="headerlink" title="19. 禁用鼠标事件"></a>19. 禁用鼠标事件</h2><p>CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。</p>
<pre><code>.disabled { pointer-events: none; }
</code></pre><h2 id="20-模糊文本"><a href="#20-模糊文本" class="headerlink" title="20. 模糊文本"></a>20. 模糊文本</h2><p>简单但很漂亮的文本模糊效果，简单又好看！</p>
<pre><code>.blur {
  color: transparent;
  text-shadow: 0 0 5px rgba(0,0,0,0.5);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/blog/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/blog/page/15/">15</a><a class="extend next" rel="next" href="/blog/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/tx.jpg" alt="李斌">
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">150</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/blog/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


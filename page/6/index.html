<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/CSS等比例缩放的盒子/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/CSS等比例缩放的盒子/" itemprop="url">CSS等比例缩放的盒子</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-19T22:43:07+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>你肯定已经知道，对于一个 img 元素而言，你可以单独地修改它的 width 或者 height 属性来设置它的大小，同时图片的比例还能够保持不变。</p>
<p>如下图所示，最上面是原始大小的图片，下面两张则分别是设置了 width: 50% 和 height: 50% 属性后的样子。</p>
<p><img src="https://pic4.zhimg.com/v2-7d10c44225e25e1929ef517567b2494e_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-7d10c44225e25e1929ef517567b2494e_hd.jpg" alt=""></p>
<p>可以看到把宽度设置为了原来的一半的同时，图片的高度并不是保持原来的大小，而是相应的也变成了原来的一半，使得图片仍能够保持原有的比例。同理把高度设成原来的一半也如此。</p>
<p>作为对照，我们看看单独修改其他元素的宽和高会产生什么样的效果：</p>
<p><img src="https://pic2.zhimg.com/v2-cc30532f26d4295a7e0462953833552f_b.jpg" alt=""></p>
<p>上图最左边的蓝色矩形是原始的 div 元素，之后两个分别是对其设置了 width: 50% 和 height: 50% 属性后的样子。可见与 img 元素不同，单独设置 div 元素的宽度（高度）时，对应的高度（宽度）并不会改变，从而导致元素的比例发生变化。这一结果相信每个稍微对前端有些了解的同学都能猜到。但是究竟是什么导致了同样的属性用于 img 和 div 后会产生不同的结果呢？</p>
<p>img 在元素分类中属于 replaced （被替换的）元素。replaced 元素表示这个元素内容的显示不是由 CSS 控制的。换句话说，对于 img 元素而言，图片的内容并不是由 CSS 定义的，而是通过其 src 属性指向的资源决定的。很多 replaced 元素来都会有自己的固有尺寸（Intrinsic dimension），img 也不例外<a href="https://link.zhihu.com/?target=https%3A//w3ctech.com/topic/1483%23fn1" target="_blank" rel="noopener">1</a>。当 img 的高度改变后，浏览器会计算出其缩放比例，而当元素的宽度是 auto（即默认值）时，浏览器则以原始宽度 * 缩放比例来作为元素的新宽度。从而使得 img 元素的比例始终保持一致。</p>
<p>然而这都并不是这篇文章讨论的重点。（那位同学请不要说脏话，不文明</p>
<p>重点是什么？重点就是题目：实现等比例缩放的盒子。</p>
<p>在响应式设计逐渐成为主流的今天，流式布局这个词即使放在一两年前也绝算不得是个新鲜词汇。下面是一个布局实例：</p>
<p><img src="https://pic2.zhimg.com/v2-2779b8fa48f397ead12b687f02268f79_b.jpg" alt=""></p>
<p>上图中每个蓝色的矩形分别对应一个 div 元素，每个元素的宽度占窗口宽度的四分之一（图示中为了演示方便给每个元素加了边距效果）。如果不做额外处理，当窗口宽度变小时上图的页面会变为如下所示：</p>
<p><img src="https://pic1.zhimg.com/v2-2c13b3a8546f34fba43822499db2795b_b.jpg" alt=""></p>
<p>可见每个元素的宽度进行了缩放，但高度并没有变化，看起来并不是很协调。所以有些场景下我们需要实现当窗口宽度缩放时，使得元素宽度自适应的同时，保证每个元素的宽高比例不变。</p>
<p>很多同学在我话还没讲完时，就已经纷纷掏出 JavaScript 大锤着手实现了起来。然而这个系列文章的标题是《你不知道的 CSS》，自然不会介绍 CSS 实现不了这种打自己脸的需求，而且就此例而言，使用 JavaScript 实现效果并不好，绑定 onresize 事件后在拖拽时某些星座的朋友会察觉出来些许卡顿（你试试便知），而且在 JavaScript 加载完成前是看不出效果的。</p>
<p>其实用 CSS 可以很容易地实现这样的效果，用的属性也是我们每个工作日和周末（如果加班的话）都会用到的：padding-bottom。padding-bottom 有一个让人很容易忽略的特性是当它的值是百分比形式时，百分比的基数是其所在元素的父元素的宽度而不是高度（同 padding-left 和 padding-right 一样）。这样解决方案也就非常明显了：</p>
<ol>
<li>将元素的 height 设成 0，使得元素的高度等于 padding-bottom；</li>
<li>合理设置 padding-bottom 的值。比如每个元素的 width 是 25%，现在想让元素的高度始终保持为其宽度的两倍，则 padding-bottom 的值应该设置为 50%。</li>
</ol>
<p>结果如下图所示：</p>
<p><img src="https://pic3.zhimg.com/v2-7b00baecc0fe2eac37eb4515b29314b4_b.jpg" alt=""></p>
<p>相应的代码可以参见：<a href="https://link.zhihu.com/?target=http%3A//jsfiddle.net/luin/25BbH/7/" target="_blank" rel="noopener">http://jsfiddle.net/luin/25BbH/7/</a>。</p>
<p>然而至此，这篇文章还没完。肯定会有很多同学疑惑既然 height 被设成了 0，那么如果元素的 overflow 为 hidden，里面的文字会不会因为超出了元素高度而被隐藏呢？</p>
<p>答案是不会。根据 CSS 2.1 规范<a href="https://link.zhihu.com/?target=https%3A//w3ctech.com/topic/1483%23fn2" target="_blank" rel="noopener">2</a>，overflow 只会对处于 padding edge 外面的内容生效，即只有超出了 padding 区域的内容才会被 overflow 属性隐藏掉。</p>
<ol>
<li>其实有一点例外的情况是当 img 的图片是 svg 时，它是没有固有尺寸的。 <a href="https://link.zhihu.com/?target=https%3A//w3ctech.com/topic/1483%23ffn1" target="_blank" rel="noopener">↩</a></li>
<li><p><a href="https://link.zhihu.com/?target=http%3A//www.w3.org/TR/CSS2/visufx.html" target="_blank" rel="noopener">http://www.w3.org/TR/CSS2/visufx.html</a><a href="https://link.zhihu.com/?target=https%3A//w3ctech.com/topic/1483%23ffn2" target="_blank" rel="noopener">↩</a></p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;style type=&quot;text/css&quot;&gt;
            .item {
                float: left;
                width: 21%;
                margin: 10px 2%;
                height: 0;
                padding-bottom: 33.98%;
                background-color: #dbe0e4;
            }
        &lt;/style&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;
    &lt;/body&gt;

&lt;/html&gt;
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/18/探索webpack-机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/18/探索webpack-机制/" itemprop="url">探索webpack 机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-18T22:20:52+08:00">
                2018-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文从简单的例子入手，从打包文件去分析以下三个问题：webpack打包文件是怎样的？如何做到兼容各大模块化方案的？webpack3带来的新特性又是什么？</p>
<h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>webpack配置</p>
<pre><code>// webpack.config.js
module.exports = {
  entry: &apos;./src/index.js&apos;,
  output: {
    filename: &apos;bundle.js&apos;,
    path: path.resolve(__dirname, &apos;dist&apos;)
  },
};
</code></pre><p>简单的js文件</p>
<pre><code>// src/index.js
 console.log(&apos;hello world&apos;);
</code></pre><p>webpack打包后的代码</p>
<pre><code>// dist/bundle.js
 /******/ (function(modules) { // webpackBootstrap
/******/     // The module cache
/******/     var installedModules = {};
/******/
/******/     // The require function
/******/     function __webpack_require__(moduleId) {
/******/
/******/         // Check if module is in cache
/******/         if(installedModules[moduleId]) {
/******/             return installedModules[moduleId].exports;
/******/         }
/******/         // Create a new module (and put it into the cache)
/******/         var module = installedModules[moduleId] = {
/******/             i: moduleId,
/******/             l: false,
/******/             exports: {}
/******/         };
/******/
/******/         // Execute the module function
/******/         modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/         // Flag the module as loaded
/******/         module.l = true;
/******/
/******/         // Return the exports of the module
/******/         return module.exports;
/******/     }
/******/
/******/
/******/     // expose the modules object (__webpack_modules__)
/******/     __webpack_require__.m = modules;
/******/
/******/     // expose the module cache
/******/     __webpack_require__.c = installedModules;
/******/
/******/     // define getter function for harmony exports
/******/     __webpack_require__.d = function(exports, name, getter) {
/******/         if(!__webpack_require__.o(exports, name)) {
/******/             Object.defineProperty(exports, name, {
/******/                 configurable: false,
/******/                 enumerable: true,
/******/                 get: getter
/******/             });
/******/         }
/******/     };
/******/
/******/     // getDefaultExport function for compatibility with non-harmony modules
/******/     __webpack_require__.n = function(module) {
/******/         var getter = module &amp;&amp; module.__esModule ?
/******/             function getDefault() { return module[&apos;default&apos;]; } :
/******/             function getModuleExports() { return module; };
/******/         __webpack_require__.d(getter, &apos;a&apos;, getter);
/******/         return getter;
/******/     };
/******/
/******/     // Object.prototype.hasOwnProperty.call
/******/     __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/     // __webpack_public_path__
/******/     __webpack_require__.p = &quot;&quot;;
/******/
/******/     // Load entry module and return exports
/******/     return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

console.log(&apos;hello world&apos;);


/***/ })
/******/ ]);
</code></pre><p>一看你就会想，我就一行代码，你给我打包那么多？？？（黑人问号）</p>
<p>我们来分析一下这部分代码，先精简一下，其实整体就是一个自执行函数，然后传入一个模块数组</p>
<pre><code>(function(modules) { 
     //...
 })([function(module, exports) {
     //..
 }])
</code></pre><p>好了，传入模块数组做了什么(其实注释都很明显了，我只是大概翻译一下）</p>
<pre><code>/******/ (function(modules) { // webpackBootstrap
/******/     // The module cache  缓存已经load过的模块
/******/     var installedModules = {};
/******/
/******/     // The require function  引用的函数
/******/     function __webpack_require__(moduleId) {
/******/
/******/         // Check if module is in cache 假如在缓存里就直接返回
/******/         if(installedModules[moduleId]) {
/******/             return installedModules[moduleId].exports;
/******/         }
/******/         // Create a new module (and put it into the cache) 构造一个模块并放入缓存
/******/         var module = installedModules[moduleId] = {
/******/             i: moduleId, //模块id
/******/             l: false, // 是否已经加载完毕
/******/             exports: {} // 对外暴露的内容
/******/         };
/******/
/******/         // Execute the module function 传入模块参数，并执行模块
/******/         modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/         // Flag the module as loaded 标记模块已经加载完毕
/******/         module.l = true;
/******/
/******/         // Return the exports of the module 返回模块暴露的内容
/******/         return module.exports;
/******/     }
/******/
/******/
/******/     // expose the modules object (__webpack_modules__) 暴露模块数组
/******/     __webpack_require__.m = modules;
/******/
/******/     // expose the module cache 暴露缓存数组
/******/     __webpack_require__.c = installedModules;
/******/
/******/     // define getter function for harmony exports 为ES6 exports定义getter
/******/     __webpack_require__.d = function(exports, name, getter) {
/******/         if(!__webpack_require__.o(exports, name)) { // 假如exports本身不含有name这个属性
/******/             Object.defineProperty(exports, name, {
/******/                 configurable: false,
/******/                 enumerable: true,
/******/                 get: getter
/******/             });
/******/         }
/******/     };
/******/
/******/     // getDefaultExport function for compatibility with non-harmony modules 解决ES module和Common js module的冲突，ES则返回module[&apos;default&apos;]
/******/     __webpack_require__.n = function(module) {
/******/         var getter = module &amp;&amp; module.__esModule ?
/******/             function getDefault() { return module[&apos;default&apos;]; } :
/******/             function getModuleExports() { return module; };
/******/         __webpack_require__.d(getter, &apos;a&apos;, getter);
/******/         return getter;
/******/     };
/******/
/******/     // Object.prototype.hasOwnProperty.call
/******/     __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/     // __webpack_public_path__ webpack配置下的公共路径
/******/     __webpack_require__.p = &quot;&quot;;
/******/
/******/     // Load entry module and return exports 最后执行entry模块并且返回它的暴露内容
/******/     return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

console.log(&apos;hello world&apos;);


/***/ })
/******/ ]);
</code></pre><p>整体流程是怎样的呢</p>
<ul>
<li>传入module数组</li>
<li><p>调用<strong>webpack_require</strong>(<strong>webpack_require</strong>.s = 0)</p>
</li>
<li><p>构造module对象，放入缓存</p>
</li>
<li>调用module,传入相应参数modules[moduleId].call(module.exports, module, module.exports, <strong>webpack_require</strong>); （这里exports会被函数内部的东西修改）</li>
<li>标记module对象已经加载完毕</li>
<li><p>返回模块暴露的内容（注意到上面函数传入了module.exports,可以对引用进行修改）</p>
</li>
<li><p>模块函数中传入module, module.exports, webpack_require</p>
</li>
<li>执行过程中通过对上面三者的引用修改，完成变量暴露和引用</li>
</ul>
<h2 id="webpack模块机制是怎样的"><a href="#webpack模块机制是怎样的" class="headerlink" title="webpack模块机制是怎样的"></a>webpack模块机制是怎样的</h2><p>我们可以去官网看下webpack模块</p>
<blockquote>
<p><a href="https://link.zhihu.com/?target=https%3A//doc.webpack-china.org/concepts/modules%23-webpack-" target="_blank" rel="noopener">https://doc.webpack-china.org/concepts/modules#-webpack-</a><br>webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：</p>
</blockquote>
<ul>
<li>ES2015 import 语句</li>
<li>CommonJS require() 语句</li>
<li>AMD define 和 require 语句</li>
<li>css/sass/less 文件中的 @import 语句。</li>
<li>样式(url(…))或 HTML 文件(<img src="/2018/05/18/探索webpack-机制/...">)中的图片链接(image url)</li>
</ul>
<p>强大的webpack模块可以兼容各种模块化方案，并且无侵入性(non-opinionated)</p>
<p>我们可以再编写例子一探究竟</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>修改src/index.js</p>
<pre><code>var cj = require(&apos;./cj.js&apos;);

console.log(&apos;hello world&apos;);
cj();
</code></pre><p>新增src/cj.js，保持前面例子其他不变</p>
<pre><code>// src/cj.js
function a() {
    console.log(&quot;CommonJS&quot;);
}
module.exports = a;
</code></pre><p>再次运行webpack</p>
<pre><code>/******/ (function(modules) { // webpackBootstrap
  //... 省略代码
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

let cj = __webpack_require__(1);

console.log(&apos;hello world&apos;);
cj();


/***/ }),
/* 1 */
/***/ (function(module, exports) {

function a() {
    console.log(&quot;CommonJS&quot;);
}
module.exports = a;


/***/ })
/******/ ]);
</code></pre><p>我们可以看到模块数组多了个引入的文件，然后index.js模块函数多了个参数<strong>webpack_require</strong>，去引用文件（<strong>webpack_require</strong>在上一节有介绍），整体上就是依赖的模块修改了module.exports，然后主模块执行依赖模块，获取exports即可</p>
<h2 id="ES2015-import"><a href="#ES2015-import" class="headerlink" title="ES2015 import"></a>ES2015 import</h2><p>新增src/es.js</p>
<pre><code>// src/es.js
export default function b() {
    console.log(&apos;ES Modules&apos;);
}
</code></pre><p>修改src/index.js</p>
<pre><code>// src/index.js
import es from &apos;./es.js&apos;;

console.log(&apos;hello world&apos;);
es();
</code></pre><p>webpack.config.js不变，执行webpack</p>
<pre><code>/******/ (function(modules) { // webpackBootstrap
// ... 省略代码
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__es_js__ = __webpack_require__(1);


console.log(&apos;hello world&apos;);
Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;a&quot; /* default */])();


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
/* harmony export (immutable) */ __webpack_exports__[&quot;a&quot;] = b;
function b() {
    console.log(&apos;ES Modules&apos;);
}


/***/ })
/******/ ]);
</code></pre><p>我们可以看到它们都变成了严格模式，webpack自动采用的</p>
<p>表现其实跟CommonJS相似，也是传入export然后修改，在主模块再require进来，</p>
<p>我们可以看到这个</p>
<pre><code>Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });
</code></pre><p>这个干嘛用的？其实就是标记当前的exports是es模块，还记得之前的<strong>webpack_require</strong>.n吗，我们再拿出来看看</p>
<pre><code>/******/     // getDefaultExport function for compatibility with non-harmony modules 解决ES module和Common js module的冲突，ES则返回module[&apos;default&apos;]
/******/     __webpack_require__.n = function(module) {
/******/         var getter = module &amp;&amp; module.__esModule ?
/******/             function getDefault() { return module[&apos;default&apos;]; } :
/******/             function getModuleExports() { return module; };
/******/         __webpack_require__.d(getter, &apos;a&apos;, getter);
/******/         return getter;
/******/     };
</code></pre><p>为了避免跟非ES Modules冲突？冲突在哪里呢？<br>其实这部分如果你看到babel转换ES Modules源码就知道了，为了兼容模块，会把ES Modules直接挂在exports.default上，然后加上__esModule属性，引入的时候判断一次是否是转换模块，是则引入module[‘default’]，不是则引入module</p>
<p>我们再多引入几个ES Modules看看效果</p>
<pre><code>// src/es.js
export function es() {
    console.log(&apos;ES Modules&apos;);
}

export function esTwo() {
    console.log(&apos;ES Modules Two&apos;);
}

export function esThree() {
    console.log(&apos;ES Modules Three&apos;);
}

export function esFour() {
    console.log(&apos;ES Modules Four&apos;);
}
</code></pre><p>我们多引入esTwo和esFour，但是不使用esFour</p>
<pre><code>// src/index.js
import { es, esTwo, esFour} from &apos;./es.js&apos;;

console.log(&apos;hello world&apos;);
es();
esTwo();
</code></pre><p>得出</p>
<pre><code>/******/ (function(modules) { // webpackBootstrap
// ...
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__es_js__ = __webpack_require__(1);


console.log(&apos;hello world&apos;);
Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;a&quot; /* es */])();
Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;b&quot; /* esTwo */])();


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
/* harmony export (immutable) */ __webpack_exports__[&quot;a&quot;] = es;
/* harmony export (immutable) */ __webpack_exports__[&quot;b&quot;] = esTwo;
/* unused harmony export esThree */
/* unused harmony export esFour */
function es() {
    console.log(&apos;ES Modules&apos;);
}

function esTwo() {
    console.log(&apos;ES Modules Two&apos;);
}

function esThree() {
    console.log(&apos;ES Modules Three&apos;);
}

function esFour() {
    console.log(&apos;ES Modules Four&apos;);
}



/***/ })
/******/ ]);
</code></pre><p>嗯嗯其实跟前面是一样的，举出这个例子重点在哪里呢，有没有注意到注释中</p>
<pre><code>/* unused harmony export esThree */
/* unused harmony export esFour */
</code></pre><p>esThree是我们没有引入的模块，esFour是我们引用但是没有使用的模块，webpack均对它们做了unused的标记，其实这个如果你使用了webpack插件uglify，通过标记，就会把esThree和esFour这两个未使用的代码消除（其实它就是tree-shaking)</p>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>我们再来看看webpack怎么支持AMD</p>
<p>新增src/amd.js</p>
<pre><code>// src/amd.js
define([
],function(){
    return {
        amd:function(){
            console.log(&apos;AMD&apos;);
        }
    };
});
</code></pre><p>修改index.js</p>
<pre><code>// src/index.js
define([
    &apos;./amd.js&apos;
],function(amdModule){
    amdModule.amd();
});
</code></pre><p>得到</p>
<pre><code>/******/ (function(modules) { // webpackBootstrap
// ... 省略代码
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(1)
], __WEBPACK_AMD_DEFINE_RESULT__ = function(amdModule){
    amdModule.amd();
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
], __WEBPACK_AMD_DEFINE_RESULT__ = function(){
    return {
        amd:function(){
            console.log(&apos;AMD&apos;);
        }
    };
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));


/***/ })
/******/ ]);
</code></pre><p>先看amd.js整理一下代码</p>
<pre><code>function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__;

    !(
        __WEBPACK_AMD_DEFINE_ARRAY__ = [],

        __WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return {
                amd: function() {
                    console.log(&apos;AMD&apos;);
                }
            };
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),

        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp;
        (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)

    );
})
</code></pre><p>简单来讲收集define Array然后置入返回函数，根据参数获取依赖</p>
<blockquote>
<p>apply对数组拆解成一个一个参数</p>
</blockquote>
<p>再看index.js模块部分</p>
<pre><code>function(module, exports, __webpack_require__) {

    var __WEBPACK_AMD_DEFINE_ARRAY__,
        __WEBPACK_AMD_DEFINE_RESULT__;
    !(
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)],
        __WEBPACK_AMD_DEFINE_RESULT__ = function(amdModule) {
                amdModule.amd();
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),

        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; 
        (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
    );
}
</code></pre><p>其实就是引入了amd.js暴露的{amd:[Function: amd]}</p>
<h2 id="css-image"><a href="#css-image" class="headerlink" title="css/image?"></a>css/image?</h2><p>css和image也可以成为webpack的模块，这是令人震惊的，这就不能通过普通的hack commonjs或者函数调用简单去调用了，这就是anything to JS，它就需要借助webpack loader去实现了</p>
<blockquote>
<p>像css就是转换成一段js代码，通过处理，调用时就是可以用js将这段css插入到style中，image也类似，这部分就不详细阐述了，有兴趣的读者可以深入去研究</p>
</blockquote>
<h2 id="webpack3新特性"><a href="#webpack3新特性" class="headerlink" title="webpack3新特性"></a>webpack3新特性</h2><p>我们可以再顺便看下webpack3新特性的表现<br>具体可以看这里<a href="https://link.zhihu.com/?target=https%3A//medium.com/webpack/webpack-3-official-release-15fd2dd8f07b" target="_blank" rel="noopener">https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b</a></p>
<h2 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h2><p>我们可以发现模块数组是一个一个独立的函数然后闭包引用webpack主函数的相应内容，每个模块都是独立的，然后带来的结果是在浏览器中执行速度变慢，然后webpack3学习了Closure Compiler和RollupJS这两个工具，连接所有闭包到一个闭包里，放入一个函数，让执行速度更快,并且整体代码体积也会有所缩小</p>
<p>我们可以实际看一下效果（要注意的是这个特性只支持ES Modules,是不支持CommonJs和AMD的）<br>使用上面的例子，配置webpack.config.js，增加new webpack.optimize.ModuleConcatenationPlugin()</p>
<pre><code>const path = require(&apos;path&apos;);
const webpack = require(&apos;webpack&apos;);

module.exports = {
  entry: &apos;./src/index.js&apos;,
  output: {
    filename: &apos;bundle.js&apos;,
    path: path.resolve(__dirname, &apos;dist&apos;)
  },
  module: {
  },
  plugins: [
    new webpack.optimize.ModuleConcatenationPlugin(),
  ]
};
</code></pre><p>打包</p>
<pre><code>/******/ (function(modules) { // webpackBootstrap
// ... 省略代码
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

&quot;use strict&quot;;
Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });

// CONCATENATED MODULE: ./src/es.js
function es() {
    console.log(&apos;ES Modules&apos;);
}

function esTwo() {
    console.log(&apos;ES Modules Two&apos;);
}

function esThree() {
    console.log(&apos;ES Modules Three&apos;);
}

function esFour() {
    console.log(&apos;ES Modules Four&apos;);
}


// CONCATENATED MODULE: ./src/index.js
// src/index.js


console.log(&apos;hello world&apos;);
es();


/***/ })
/******/ ]);
</code></pre><p>我们可以惊喜的发现没有什么require了，它们拼接成了一个函数，good!?</p>
<h2 id="Magic-Comments"><a href="#Magic-Comments" class="headerlink" title="Magic Comments"></a>Magic Comments</h2><p>code splitting是webpack一个重点特性之一，涉及到要动态引入的时候，webpack可以使用 require.ensure去实现，后来webpack2支持使用了符合 ECMAScript 提案 的 import() 语法，但是它有个不足之处，无法指定chunk的名称chunkName,为了解决这个问题，出现了Magic Comments，支持用注释的方式去指定，如下</p>
<pre><code>import(/* webpackChunkName: &quot;my-chunk-name&quot; */ &apos;module&apos;);
</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>webpack是一个强大的模块打包工具，在处理依赖、模块上都很优秀，本文从bundle.js文件分析出发去探索了不同模块方案的加载机制，初步去理解webpack，并且对webpack3特性进行阐述，当然，webpack还有很多地方需要去探索深究，敬请期待以后的文章吧～</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/Vue源码必知必会/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/Vue源码必知必会/" itemprop="url">Vue源码必知必会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T16:24:04+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Vue.js源码分析，记录了个人学习Vue.js源码的过程中的一些心得以及收获。以及对于Vue框架，周边库的一些学习心得和个人见解。</p>
<p>在学习的过程中我分别为Vue.js、Vuex、Vue-router加上了注释，分别在文件夹<a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/vue-src" target="_blank" rel="noopener">vue-src</a>、<a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/vuex-src" target="_blank" rel="noopener">vuex-src</a>以及<a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/vue-router-src" target="_blank" rel="noopener">vue-router-src</a>中，希望可以帮助有需要的同学更好地学习理解Vue.js及周边库的源码。</p>
<p>感谢尤大提高生产力。</p>
<p>当前Vue.js源码版本2.3.0，Vuex版本为2.4.0，Vue-router版本为3.0.1。</p>
<p>本项目希望对Vue.js做更进一步的探索与学习，Vue.js基础内容请参考Vue.js官网，<a href="https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a>。 可能会有理解存在偏差的地方，欢迎提issue指出，共同学习，共同进步。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h2 id="源码相关"><a href="#源码相关" class="headerlink" title="源码相关"></a>源码相关</h2><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E5%258E%259F%25E7%2590%2586.MarkDown" target="_blank" rel="noopener">Vue.js响应式原理</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E4%25BE%259D%25E8%25B5%2596%25E6%2594%25B6%25E9%259B%2586.MarkDown" target="_blank" rel="noopener">Vue.js依赖收集</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E4%25BB%258E%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%2592%25E5%25BA%25A6%25E5%2586%258D%25E7%259C%258B%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2591%25E5%25AE%259A.MarkDown" target="_blank" rel="noopener">从Vue.js源码角度再看数据绑定</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/Vue%25E4%25BA%258B%25E4%25BB%25B6%25E6%259C%25BA%25E5%2588%25B6.MarkDown" target="_blank" rel="noopener">Vue.js事件机制</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/VNode%25E8%258A%2582%25E7%2582%25B9.MarkDown" target="_blank" rel="noopener">VNode节点(Vue.js实现)</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/VirtualDOM%25E4%25B8%258Ediff%28Vue%25E5%25AE%259E%25E7%258E%25B0%29.MarkDown" target="_blank" rel="noopener">Virtual DOM与diff(Vue.js实现)</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E8%2581%258A%25E8%2581%258AVue%25E7%259A%2584template%25E7%25BC%2596%25E8%25AF%2591.MarkDown" target="_blank" rel="noopener">聊聊Vue.js的template编译</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/Vue.js%25E5%25BC%2582%25E6%25AD%25A5%25E6%259B%25B4%25E6%2596%25B0DOM%25E7%25AD%2596%25E7%2595%25A5%25E5%258F%258AnextTick.MarkDown" target="_blank" rel="noopener">Vue.js异步更新DOM策略及nextTick</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E4%25BB%258Etemplate%25E5%2588%25B0DOM%28Vue.js%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%2592%25E5%25BA%25A6%25E7%259C%258B%25E5%2586%2585%25E9%2583%25A8%25E8%25BF%2590%25E8%25A1%258C%25E6%259C%25BA%25E5%2588%25B6%29.MarkDown" target="_blank" rel="noopener">从template到DOM（Vue.js源码角度看内部运行机制）</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/Vuex%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E6%259E%2590.MarkDown" target="_blank" rel="noopener">Vuex源码解析</a></p>
<h2 id="随笔杂谈"><a href="#随笔杂谈" class="headerlink" title="随笔杂谈"></a>随笔杂谈</h2><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/Vue%25E7%25BB%2584%25E4%25BB%25B6%25E9%2597%25B4%25E9%2580%259A%25E4%25BF%25A1.MarkDown" target="_blank" rel="noopener">Vue组件间通信</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E8%25AF%25B4%25E8%25AF%25B4element%25E7%25BB%2584%25E4%25BB%25B6%25E5%25BA%2593broadcast%25E4%25B8%258Edispatch.MarkDown" target="_blank" rel="noopener">说说element组件库broadcast与dispatch</a></p>
<p>该源码分析，会带着大家一起学习<code>Vue</code>的大部分代码，而不是简单的讲一下它的原理，我会尽可能的多解释每一行主要的代码含义，另外一些辅助方法什么的，大家可以在学习的过程中，自己看一眼就知道了。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/Vue%25E6%25BA%2590%25E7%25A0%2581%25E7%259B%25AE%25E5%25BD%2595%25E7%25BB%2593%25E6%259E%2584%25E6%2595%25B4%25E7%2590%2586.md" target="_blank" rel="noopener">Vue源码目录结构整理</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E4%25BB%258E%25E5%2585%25A5%25E5%258F%25A3%25E6%2596%2587%25E4%25BB%25B6%25E6%259F%25A5%25E7%259C%258BVue%25E6%25BA%2590%25E7%25A0%2581.md" target="_blank" rel="noopener">从入口文件查看Vue源码</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E4%25BB%258E%25E4%25B8%2580%25E4%25B8%25AA%25E5%25B0%258F%25E6%25A0%2597%25E5%25AD%2590%25E6%259F%25A5%25E7%259C%258BVue%25E7%259A%2584%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F.md" target="_blank" rel="noopener">从小栗子查看Vue的生命周期</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E5%258F%258C%25E5%2590%2591%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2591%25E5%25AE%259A.md" target="_blank" rel="noopener">双向数据绑定</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/compile%25E6%25A6%2582%25E8%25BF%25B0.md" target="_blank" rel="noopener">compile概述</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/compile%25E2%2580%2594%25E2%2580%2594%25E7%2594%259F%25E6%2588%2590ast.md" target="_blank" rel="noopener">compile——生成ast</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/compile%25E2%2580%2594%25E2%2580%2594%25E4%25BC%2598%25E5%258C%2596%25E9%259D%2599%25E6%2580%2581%25E5%2586%2585%25E5%25AE%25B9.md" target="_blank" rel="noopener">compile——优化静态内容</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/compile%25E2%2580%2594%25E2%2580%2594%25E7%2594%259F%25E6%2588%2590render%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2.md" target="_blank" rel="noopener">compile——生成render字符串</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/vdom%25E6%25A6%2582%25E8%25BF%25B0.md" target="_blank" rel="noopener">vdom概述</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/Vue.extend.md" target="_blank" rel="noopener">Vue.extend</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/vdom%25E2%2580%2594%25E2%2580%2594VNode.md" target="_blank" rel="noopener">vdom——VNode</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/children%25E7%259A%2584%25E5%25BD%2592%25E4%25B8%2580%25E5%258C%2596%25E5%25A4%2584%25E7%2590%2586.md" target="_blank" rel="noopener">children的归一化处理</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/patch%25E2%2580%2594%25E2%2580%2594%25E5%2588%259B%25E5%25BB%25BAdom.md" target="_blank" rel="noopener">patch——创建dom</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/patch%25E2%2580%2594%25E2%2580%2594diff.md" target="_blank" rel="noopener">patch——diff</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/patch%25E2%2580%2594%25E2%2580%2594%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589%25E7%25BB%2584%25E4%25BB%25B6%25E7%259A%2584%25E5%25A4%2584%25E7%2590%2586%25E6%25B5%2581%25E7%25A8%258B.md" target="_blank" rel="noopener">patch——自定义组件的处理流程</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E4%25BA%258B%25E4%25BB%25B6%25E5%25A4%2584%25E7%2590%2586.md" target="_blank" rel="noopener">事件处理</a></p>
<p>指令的处理</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/directives%25E6%25A6%2582%25E8%25BF%25B0.md" target="_blank" rel="noopener">directives概述</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589%25E6%258C%2587%25E4%25BB%25A4.md" target="_blank" rel="noopener">自定义指令</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-for.md" target="_blank" rel="noopener">v-for</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-if.md" target="_blank" rel="noopener">v-if</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-once.md" target="_blank" rel="noopener">v-once</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-show.md" target="_blank" rel="noopener">v-show</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-text%25E3%2580%2581v-html%25E3%2580%2581v-cloak%25E3%2580%2581v-pre.md" target="_blank" rel="noopener">v-text、v-html、v-cloak、v-pre</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-model.md" target="_blank" rel="noopener">v-model</a></p>
<p>内置组件和标签</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/slot%25E5%2592%258C%25E4%25BD%259C%25E7%2594%25A8%25E5%259F%259F%25E6%258F%2592%25E6%25A7%25BD.md" target="_blank" rel="noopener">slot和作用域插槽</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/keep-alive.md" target="_blank" rel="noopener">keep-alive</a></p>
<p>以下是整理一些比较零散的数据，主要是记录结构中每个数据表示什么意思，会不断完善更新：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/Vue-globals.md" target="_blank" rel="noopener">Vue全局属性</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/Vue%25E5%25AE%259E%25E4%25BE%258B%25E5%25B1%259E%25E6%2580%25A7.md" target="_blank" rel="noopener">Vue实例属性</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/AstElement.md" target="_blank" rel="noopener">AstElement</a></p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/VNode.md" target="_blank" rel="noopener">VNode</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/20个CSS高级技巧汇总/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/20个CSS高级技巧汇总/" itemprop="url">20个 CSS高级技巧汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T16:24:04+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用技巧会让人变的越来越懒，没错，我就是想让你变懒。下面是我收集的CSS高级技巧，希望你懒出境界。</p>
<h2 id="1-黑白图像"><a href="#1-黑白图像" class="headerlink" title="1. 黑白图像"></a>1. 黑白图像</h2><p>这段代码会让你的彩色照片显示为黑白照片，是不是很酷？</p>
<pre><code>img.desaturate {
 filter: grayscale(100%);
-webkit-filter: grayscale(100%);
-moz-filter: grayscale(100%);
-ms-filter: grayscale(100%);
-o-filter: grayscale(100%);
}
</code></pre><h2 id="2-使用-not-在菜单上应用-取消应用边框"><a href="#2-使用-not-在菜单上应用-取消应用边框" class="headerlink" title="2. 使用 :not() 在菜单上应用/取消应用边框"></a>2. 使用 <code>:not()</code> 在菜单上应用/取消应用边框</h2><p>先给每一个菜单项添加边框</p>
<pre><code>/* add border */
.nav li {
 border-right: 1px solid #666;
}
</code></pre><p>然后再除去最后一个元素</p>
<pre><code>// remove border /

.nav li:last-child {
 border-right: none;
}
</code></pre><p>可以直接使用 :not() 伪类来应用元素：</p>
<pre><code>.nav li:not(:last-child) {
 border-right: 1px solid #666;
}
</code></pre><p>这样代码就干净，易读，易于理解了。</p>
<p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p>
<pre><code>.nav li:first-child ~ li {
 border-left: 1px solid #666;
}
</code></pre><h2 id="3-页面顶部阴影"><a href="#3-页面顶部阴影" class="headerlink" title="3. 页面顶部阴影"></a>3. 页面顶部阴影</h2><p>下面这个简单的 CSS3 代码片段可以给网页加上漂亮的顶部阴影效果：</p>
<pre><code>body:before {
 content: &quot;&quot;;
 position: fixed;
 top: -10px;
 left: 0;
 width: 100%;
 height: 10px;

-webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
-moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8);
 box-shadow: 0px 0px 10px rgba(0,0,0,.8);

 z-index: 100;
}
</code></pre><h2 id="4-给-body-添加行高"><a href="#4-给-body-添加行高" class="headerlink" title="4. 给 body 添加行高"></a>4. 给 body 添加行高</h2><p>你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可：</p>
<pre><code>body {
 line-height: 1;
}
</code></pre><p>这样文本元素就可以很容易地从 body 继承。</p>
<h2 id="5-所有一切都垂直居中"><a href="#5-所有一切都垂直居中" class="headerlink" title="5. 所有一切都垂直居中"></a>5. 所有一切都垂直居中</h2><p>要将所有元素垂直居中，太简单了：</p>
<pre><code>html, body {
 height: 100%;
 margin: 0;
}

body {
-webkit-align-items: center; 
-ms-flex-align: center; 
 align-items: center;
 display: -webkit-flex;
 display: flex;
}
</code></pre><p>看，是不是很简单。</p>
<p>注意：在IE11中要小心flexbox</p>
<h2 id="6-逗号分隔的列表"><a href="#6-逗号分隔的列表" class="headerlink" title="6. 逗号分隔的列表"></a>6. 逗号分隔的列表</h2><p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p>
<pre><code>ul &gt; li:not(:last-child)::after {
 content: &quot;,&quot;;
}
</code></pre><p>对最后一个列表项使用 :not() 伪类。</p>
<h2 id="7-使用负的-nth-child-选择项目"><a href="#7-使用负的-nth-child-选择项目" class="headerlink" title="7. 使用负的 nth-child 选择项目"></a>7. 使用负的 nth-child 选择项目</h2><p>在CSS中使用负的 nth-child 选择项目1到项目n。</p>
<pre><code>li {
 display: none;
}

/* select items 1 through 3 and display them */
li:nth-child(-n+3) {
 display: block;
}
</code></pre><h2 id="8-对图标使用-SVG"><a href="#8-对图标使用-SVG" class="headerlink" title="8. 对图标使用 SVG"></a>8. 对图标使用 SVG</h2><p>我们没有理由不对图标使用SVG：</p>
<pre><code>.logo {
 background: url(&quot;logo.svg&quot;);
}
</code></pre><p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p>
<h2 id="9-优化显示文本"><a href="#9-优化显示文本" class="headerlink" title="9. 优化显示文本"></a>9. 优化显示文本</h2><p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p>
<pre><code>html {
-moz-osx-font-smoothing: grayscale;
-webkit-font-smoothing: antialiased;
 text-rendering: optimizeLegibility;
}
</code></pre><p>注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。</p>
<h2 id="10-对纯-CSS-滑块使用-max-height"><a href="#10-对纯-CSS-滑块使用-max-height" class="headerlink" title="10. 对纯 CSS 滑块使用 max-height"></a>10. 对纯 CSS 滑块使用 max-height</h2><p>使用 max-height 和溢出隐藏来实现只有CSS的滑块：</p>
<pre><code>.slider ul {
 max-height: 0;
 overlow: hidden;
}

.slider:hover ul {
 max-height: 1000px;
 transition: .3s ease;
}
</code></pre><h2 id="11-继承-box-sizing"><a href="#11-继承-box-sizing" class="headerlink" title="11. 继承 box-sizing"></a>11. 继承 box-sizing</h2><p>让 box-sizing 继承 html：</p>
<pre><code>html {
 box-sizing: border-box;
}

*, *:before, *:after {
 box-sizing: inherit;
}
</code></pre><p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。</p>
<h2 id="12-表格单元格等宽"><a href="#12-表格单元格等宽" class="headerlink" title="12. 表格单元格等宽"></a>12. 表格单元格等宽</h2><p>表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽：</p>
<pre><code>.calendar {
 table-layout: fixed;
}
</code></pre><h2 id="13-用-Flexbox-摆脱外边距的各种-hack"><a href="#13-用-Flexbox-摆脱外边距的各种-hack" class="headerlink" title="13. 用 Flexbox 摆脱外边距的各种 hack"></a>13. 用 Flexbox 摆脱外边距的各种 hack</h2><p>当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了：</p>
<pre><code>.list {
 display: flex;
 justify-content: space-between;
}

.list .person {
 flex-basis: 23%;
}
</code></pre><p>现在，列表分隔符就会在均匀间隔的位置出现。</p>
<h2 id="14-使用属性选择器用于空链接"><a href="#14-使用属性选择器用于空链接" class="headerlink" title="14. 使用属性选择器用于空链接"></a>14. 使用属性选择器用于空链接</h2><p>当a元素没有文本值，但 href 属性有链接的时候显示链接：</p>
<pre><code>a[href^=&quot;http&quot;]:empty::before {
 content: attr(href);
}
</code></pre><p>相当方便。</p>
<h2 id="15-检测鼠标双击"><a href="#15-检测鼠标双击" class="headerlink" title="15. 检测鼠标双击"></a>15. 检测鼠标双击</h2><p>HTML：</p>
<pre><code>&lt;div class=&quot;test3&quot;&gt;
&lt;span&gt;&lt;input type=&quot;text&quot; value=&quot; &quot; readonly=&quot;true&quot; /&gt;
&lt;a href=&quot;http://renpingjun.com&quot;&gt;Double click me&lt;/a&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre><p>CSS：</p>
<pre><code>.test3 span {
 position: relative;
}
.test3 span a {
 position: relative;
 z-index: 2;
}
.test3 span a:hover, .test3 span a:active {
 z-index: 4;
}
.test3 span input {
 background: transparent;
 border: 0;
 cursor: pointer;
 position: absolute;
 top: -1px;
 left: 0;
 width: 101%; /* Hacky */
 height: 301%; /* Hacky */
 z-index: 3;
}
.test3 span input:focus {
 background: transparent;
 border: 0;
 z-index: 1;
}
</code></pre><h2 id="16-CSS-写出三角形"><a href="#16-CSS-写出三角形" class="headerlink" title="16. CSS 写出三角形"></a>16. CSS 写出三角形</h2><pre><code>/* create an arrow that points up */
div.arrow-up {
 width:0px;
 height:0px;
 border-left:5px solid transparent; /* left arrow slant */
 border-right:5px solid transparent; /* right arrow slant */
 border-bottom:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points down */
div.arrow-down {
 width:0px;
 height:0px;
 border-left:5px solid transparent;
 border-right:5px solid transparent;
 border-top:5px solid #2f2f2f;
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points left */
div.arrow-left {
 width:0px;
 height:0px;
 border-bottom:5px solid transparent; /* left arrow slant */
 border-top:5px solid transparent; /* right arrow slant */
 border-right:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}

/* create an arrow that points right */
div.arrow-right {
 width:0px;
 height:0px;
 border-bottom:5px solid transparent; /* left arrow slant */
 border-top:5px solid transparent; /* right arrow slant */
 border-left:5px solid #2f2f2f; /* bottom, add background color here */
 font-size:0px;
 line-height:0px;
}
</code></pre><h2 id="17-CSS3-calc-的使用"><a href="#17-CSS3-calc-的使用" class="headerlink" title="17. CSS3 calc() 的使用"></a>17. CSS3 calc() 的使用</h2><p>calc() 用法类似于函数，能够给元素设置动态的值：</p>
<pre><code>/* basic calc */
.simpleBlock {
 width: calc(100% - 100px);
}

/* calc in calc */
.complexBlock {
 width: calc(100% - 50% / 3);
 padding: 5px calc(3% - 2px);
 margin-left: calc(10% + 10px);
}
</code></pre><h2 id="18-文本渐变"><a href="#18-文本渐变" class="headerlink" title="18. 文本渐变"></a>18. 文本渐变</h2><p>文本渐变效果很流行，使用 CSS3 能够很简单就实现：</p>
<pre><code>h2[data-text] {
 position: relative;
}
h2[data-text]::after {
 content: attr(data-text);
 z-index: 10;
 color: #e3e3e3;
 position: absolute;
 top: 0;
 left: 0;
-webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));}
</code></pre><h2 id="19-禁用鼠标事件"><a href="#19-禁用鼠标事件" class="headerlink" title="19. 禁用鼠标事件"></a>19. 禁用鼠标事件</h2><p>CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。</p>
<pre><code>.disabled { pointer-events: none; }
</code></pre><h2 id="20-模糊文本"><a href="#20-模糊文本" class="headerlink" title="20. 模糊文本"></a>20. 模糊文本</h2><p>简单但很漂亮的文本模糊效果，简单又好看！</p>
<pre><code>.blur {
  color: transparent;
  text-shadow: 0 0 5px rgba(0,0,0,0.5);
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/02/跨域之由Request-Method-OPTIONS初窥CORS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/02/跨域之由Request-Method-OPTIONS初窥CORS/" itemprop="url">跨域之由Request Method:OPTIONS初窥CORS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-02T11:09:02+08:00">
                2018-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="不就是跨域么-慌个XX-掘金"><a href="#不就是跨域么-慌个XX-掘金" class="headerlink" title="不就是跨域么?慌个XX - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="noopener">不就是跨域么?慌个XX - 掘金</a></h2><p>刚接触前端的时候，以为HTTP的Request Method只有GET与POST两种，后来才了解到，原来还有HEAD、PUT、DELETE、OPTIONS……</p>
<p>目前的工作中，HEAD、PUT、DELETE我是真的没有见过……但是OPTIONS几乎天天都会遇到。本地环境跑公司项目的时候，每次POST之前，为啥浏览器还偷偷给我来一次没有返回的OPTIONS请求？</p>
<blockquote>
<p>原来，浏览器在某些请求中，在正式通信前会增加一次HTTP查询请求，称为”预检”请求（preflight）。OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
</blockquote>
<p>如果这个OPTIONS请求包含一个正文（有Content-Length或Transfer-Encoding存在），则必须有Content-Type来指定媒体类型。虽然规范里没有定义这种正文的用法，但是HTTP将来的扩展可能会用它来查询服务器上更详细的信息。不支持该扩展的服务器可以忽略该请求正文。</p>
<p>如果该URI是一个星号（“<em>”），OPTIONS请求将试图应用于服务器，而不是某个指定资源。由于服务器的通信选项通常依赖于资源，所以此“</em>”请求只能作为“ping”或者“no-op”方法；或者用来测试服务器的性能。例如，用来测试HTTP/1.1代理。</p>
<p>如果该URI不是星号，则只能用来获取该资源通信中可用的选项。</p>
<p>得到的200响应应该包含一个头域，指明服务器实现的和适用于该资源的可选特征（如：Allow），可能还包括该规范尚未定义的扩展。如果有响应正文，则应包含关于通信选项的信息。本规范没有定义该正文格式，但可能在HTTO将来的扩展中定义。可以利用内容协商来选择合适的响应格式。如果没有响应正文，响应必须包含Content-Length，并且值为“0”。</p>
<p>请求头的Max-Forwards用来请求特定代理。当代理收到一个允许URI转发的OPTIONS请求，则检查Max-Forwards。如果Max-Forwards值为0，则不能转发该消息；相反，代理会将自己的通信选项去响应。如果Max-Forwards是正整数，代理转发请求的时候会将该值减1。如果请求中没有Max-Forwards，转发的请求也不会有。</p>
<h2 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h2><p>OPTIONS请求方法的主要用途有两个：</p>
<p>1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。</p>
<p>2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。<br><img src="https://pic3.zhimg.com/v2-8f8d34a757502c306d82fa44f4645068_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8f8d34a757502c306d82fa44f4645068_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-38b8f2ec0da0115511cee8a1b604c6a4_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-38b8f2ec0da0115511cee8a1b604c6a4_hd.jpg" alt=""><br>如上两张图片，图2就是本地环境，本地环境请求接口的时候，每次请求接口之前都会多一次OPTIONS请求。</p>
<p><img src="https://pic4.zhimg.com/v2-31c4436fae8e077e9d935ac58bd861d6_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-31c4436fae8e077e9d935ac58bd861d6_hd.jpg" alt=""></p>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener">XMLHttpRequest</a>请求，从而克服了AJAX只能<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p>
<blockquote>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
</blockquote>
<h2 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h2><p>浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>同时满足以下条件，就是简单请求：</p>
<blockquote>
<p>（1) 请求方法是以下三种方法之一：</p>
</blockquote>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p>
<p>Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。都以Access-Control- 开头：</p>
<p>（1）Access-Control-Allow-Origin</p>
<p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p>
<blockquote>
<p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p>
</blockquote>
<p>（2）Access-Control-Allow-Credentials</p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
<p>（3）Access-Control-Expose-Headers</p>
<p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</p>
<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>我工作中写的所有页面拉的接口都是非简单请求。<br><img src="https://pic1.zhimg.com/v2-6749c6523db660ed4e194e16779c5fa3_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-6749c6523db660ed4e194e16779c5fa3_hd.jpg" alt=""><br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>在页面域名与接口域名不一致的情况下，就出现了每次请求前先发送一个options请求的问题。</p>
<p>OPTIONS请求头信息中，除了Origin字段，还至少会多两个特殊字段：</p>
<p>（1）Access-Control-Request-Method</p>
<p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</p>
<p>（2）Access-Control-Request-Headers</p>
<p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</p>
<p><img src="https://pic3.zhimg.com/v2-da5ae04890068d4ffc9f4714e48719dd_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-da5ae04890068d4ffc9f4714e48719dd_hd.jpg" alt=""><br>至于其他乱七八糟的字段，现在的我还用不到也不懂，将会慢慢深入了解。</p>
<p>服务器收到预检请求后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p>
<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="https://link.zhihu.com/?target=http%3A//lizard.qa.nt.ctripcorp.com" target="_blank" rel="noopener">http://lizard.qa.nt.ctripcorp.com</a>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>
<p>XMLHttpRequest cannot load <a href="https://link.zhihu.com/?target=http%3A//lizard.qa.nt.ctripcorp.com" target="_blank" rel="noopener">http://lizard.qa.nt.ctripcorp.com</a><br>Origin <a href="https://link.zhihu.com/?target=http%3A//lizard.qa.nt.ctripcorp.com" target="_blank" rel="noopener">http://lizard.qa.nt.ctripcorp.com</a> is not allowed by Access-Control-Allow-Origin.</p>
<p>其他字段中Access-Control-Max-Age 用来指定本次预检请求的有效期，单位为秒。该字段可选。</p>
<h2 id="与JSONP的对比"><a href="#与JSONP的对比" class="headerlink" title="与JSONP的对比"></a>与JSONP的对比</h2><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p>
<p>JSONP只支持GET请求，JSONP的优势在于支持老旧浏览器。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/23/前端性能监控：window-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/23/前端性能监控：window-performance/" itemprop="url">前端性能监控：window.performance</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-23T22:51:24+08:00">
                2018-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/2014/WD-navigation-timing-2-20140325/" target="_blank" rel="noopener">window.performance</a> 是W3C性能小组引入的新的API，目前IE9以上的浏览器都支持。一个performance对象的完整结构如下图所示：</p>
<h2 id="Window-performance"><a href="#Window-performance" class="headerlink" title="Window.performance"></a>Window.performance</h2><p>虽然叫 <code>Timing API</code> 但是用起来却是 <code>window.performance</code></p>
<pre><code>// 兼容性写法
const performance = window.performance || 
                      window.msPerformance || 
                      window.webkitPerformance;
</code></pre><p>memory字段代表JavaScript对内存的占用。</p>
<h2 id="performance-memory-内存"><a href="#performance-memory-内存" class="headerlink" title="performance.memory(内存)"></a>performance.memory(内存)</h2><ul>
<li>usedJSHeapSize<br>JS 对象（包括V8引擎内部对象）占用的内存</li>
<li>totalJSHeapSize<br>可使用的内存</li>
<li>jsHeapSizeLimit<br>内存大小限制</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-f4a0fa5f8a8a1c4ef07f83d0f393fd9a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-f4a0fa5f8a8a1c4ef07f83d0f393fd9a_hd.jpg" alt=""></p>
<h2 id="performance-navigation-我从哪里来"><a href="#performance-navigation-我从哪里来" class="headerlink" title="performance.navigation(我从哪里来)"></a>performance.navigation(我从哪里来)</h2><ul>
<li>redirectCount<br>如果有重定向的话，页面通过几次重定向跳转而来</li>
<li><p>type</p>
</li>
<li><p>0 即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</p>
</li>
<li>1 即 TYPE_RELOAD 通过 window.location.reload() 刷新的页面</li>
<li>2 即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</li>
<li>255 即 TYPE_UNDEFINED 非以上方式进入的页面</li>
</ul>
<p>navigation字段统计的是一些网页导航相关的数据：</p>
<ol>
<li>redirectCount:重定向的数量（只读），但是这个接口有同源策略限制，即仅能检测同源的重定向；</li>
<li>type 返回值应该是0,1,2 中的一个。分别对应三个枚举值:</li>
</ol>
<ul>
<li>0 : TYPE_NAVIGATE (用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式)</li>
<li>1 : TYPE_RELOAD (用户通过刷新，包括JS调用刷新接口等方式访问页面)</li>
<li>2 : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面)</li>
</ul>
<p>最重要的是timing字段的统计数据，它包含了网络、解析等一系列的时间数据。</p>
<h2 id="performance-timing-时间"><a href="#performance-timing-时间" class="headerlink" title="performance.timing(时间)"></a>performance.timing(时间)</h2><p><img src="https://pic4.zhimg.com/v2-a9f7be2c5aaa973e405bd0b8da7e6890_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a9f7be2c5aaa973e405bd0b8da7e6890_hd.jpg" alt=""></p>
<p>2.2.1 timing API</p>
<p>timing的整体结构如上图所示：</p>
<p><img src="https://pic2.zhimg.com/v2-95d9e0f1ff8257f3c007045c6a2d07bb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-95d9e0f1ff8257f3c007045c6a2d07bb_hd.jpg" alt=""></p>
<p>各字段的含义如下：</p>
<ul>
<li>startTime：有些浏览器实现为<a href="https://link.zhihu.com/?target=https%3A//msdn.microsoft.com/en-us/library/ff974724%28v%3Dvs.85%29.aspx" target="_blank" rel="noopener">navigationStart</a>，代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览baidu.com，在地址栏输入google.com并回车，浏览器的执行动作依次为：unload当前文档（即<a href="https://link.zhihu.com/?target=http%3A//baidu.com" target="_blank" rel="noopener">http://baidu.com</a>）-&gt;请求下一文档（即<a href="https://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="noopener">http://google.com</a>）。navigationStart的值便是触发unload当前文档的时间节点。</li>
</ul>
<p>如果当前文档为空，则navigationStart的值等于fetchStart。</p>
<ul>
<li>redirectStart和redirectEnd：如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点；</li>
<li>unloadEventStart和unloadEventEnd：如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0；</li>
<li>fetchStart是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存；</li>
<li>domainLookupStart和domainLookupEnd分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart；</li>
<li>connectStart和connectEnd分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd；</li>
<li>secureConnectionStart：可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0；</li>
<li>requestStart代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等；</li>
<li>responseStart和responseEnd分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻；</li>
<li>domLoading代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点；</li>
<li>domInteractive代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点；</li>
<li>domContentLoadedEventStart：代表DOMContentLoaded事件触发的时间节点：</li>
</ul>
<p>页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。</p>
<ul>
<li>domContentLoadedEventEnd：代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间；</li>
<li>domComplete：html文档完全解析完毕的时间节点；</li>
<li>loadEventStart和loadEventEnd分别代表onload事件触发和结束的时间节点</li>
</ul>
<p>2.2.2 计算性能指标</p>
<p>可以使用Navigation.timing 统计到的时间数据来计算一些页面性能指标，比如DNS查询耗时、白屏时间、domready等等。如下：</p>
<ul>
<li>DNS查询耗时 = domainLookupEnd - domainLookupStart</li>
<li>TCP链接耗时 = connectEnd - connectStart</li>
<li>request请求耗时 = responseEnd - responseStart</li>
<li>解析dom树耗时 = domComplete - domInteractive</li>
<li>白屏时间 = domloadng - fetchStart</li>
<li>domready时间 = domContentLoadedEventEnd - fetchStart</li>
<li><p>onload时间 = loadEventEnd - fetchStart</p>
<p>  所以根据上面的时间点，我们可以计算常规的性能值，如下：<br>  （使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。）</p>
<p>  var timing = window.performance &amp;&amp; window.performance.timing;<br>  var navigation = window.performance &amp;&amp; window.performance.navigation;</p>
</li>
</ul>
<pre><code>重定向次数：
var redirectCount = navigation &amp;&amp; navigation.redirectCount;

跳转耗时：
var redirect = timing.redirectEnd - timing.redirectStart;

APP CACHE 耗时：
var appcache = Math.max(timing.domainLookupStart - timing.fetchStart, 0);

DNS 解析耗时：
var dns = timing.domainLookupEnd - timing.domainLookupStart;

TCP 链接耗时：
var conn = timing.connectEnd - timing.connectStart;

等待服务器响应耗时（注意是否存在cache）：
var request = timing.responseStart - timing.requestStart;

内容加载耗时（注意是否存在cache）:
var response = timing.responseEnd - timing.responseStart;

总体网络交互耗时，即开始跳转到服务器资源下载完成：
var network = timing.responseEnd - timing.navigationStart;

渲染处理：
var processing = (timing.domComplete || timing.domLoading) - timing.domLoading;

抛出 load 事件：
var load = timing.loadEventEnd - timing.loadEventStart;

总耗时：
var total = (timing.loadEventEnd || timing.loadEventStart || timing.domComplete || timing.domLoading) - timing.navigationStart;

可交互：
var active = timing.domInteractive - timing.navigationStart;

请求响应耗时，即 T0，注意cache：
var t0 = timing.responseStart - timing.navigationStart;

首次出现内容，即 T1：
var t1 = timing.domLoading - timing.navigationStart;

内容加载完毕，即 T3：
var t3 = timing.loadEventEnd - timing.navigationStart;
</code></pre><p>2.2.3 Resource timing API</p>
<p>Resource timing API是用来统计静态资源相关的时间信息，详细的内容请参考<a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/resource-timing/" target="_blank" rel="noopener">W3C Resource timing</a>。这里我们只介绍performance.getEntries方法，它可以获取页面中每个静态资源的请求，【以百度移动版首页的logo为例】如下：</p>
<p>比较有用的几个属性：</p>
<pre><code>name：资源的链接

initiatorType: 初始类型（注意这个类型并不准确，例如在css中的图片资源会这个值显示css，所以还是推荐用name中的后缀名）

duration: 资源的总耗时（包括等待时长，请求时长，响应时长 相当于responseEnd - startTime）

transferSize: 转换后的文件大小(略大于encodedBodySize, 为什么我取这个呢，因为这个值是和chrome的devtool Network里的size一致) 
</code></pre><p><img src="https://pic4.zhimg.com/v2-cff2a7e449c4e6260c2cb8fa0b18c948_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-cff2a7e449c4e6260c2cb8fa0b18c948_hd.jpg" alt=""></p>
<p>可以看到performance.getEntries返回一个数组，数组的每个元素代表对应的静态资源的信息，比如上图展示的第一个元素对应的资源类型initiatorType是图片img，请求花费的时间就是duration的值。</p>
<p>关于Resource timing API的使用场景，感兴趣的同学可以深入研究。</p>
<p><img src="https://pic2.zhimg.com/v2-23c6a6e3744a117368fbd9b0789867ff_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-23c6a6e3744a117368fbd9b0789867ff_hd.jpg" alt=""></p>
<pre><code>;
(function() {

    handleAddListener(&apos;load&apos;, getTiming)

    function handleAddListener(type, fn) {
        if(window.addEventListener) {
            window.addEventListener(type, fn)
        } else {
            window.attachEvent(&apos;on&apos; + type, fn)
        }
    }

    function getTiming() {
        try {
            var time = performance.timing;
            var timingObj = {};

            var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;

            if(loadTime &lt; 0) {
                setTimeout(function() {
                    getTiming();
                }, 200);
                return;
            }

            timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000;
            timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000;
            timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000;
            timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000;
            timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000;
            timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000;
            timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000;
            timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;
            timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000;
            timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]);

            for(item in timingObj) {
                console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;);
            }

            console.log(performance.timing);

        } catch(e) {
            console.log(timingObj)
            console.log(performance.timing);
        }
    }
})();

&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; /&gt;
        &lt;script src=&quot;&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-23c6a6e3744a117368fbd9b0789867ff_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-23c6a6e3744a117368fbd9b0789867ff_hd.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/22/前端常见跨域解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/22/前端常见跨域解决方案/" itemprop="url">前端常见跨域解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-22T22:23:15+08:00">
                2018-04-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p>
<p>广义的跨域：</p>
<pre><code>1.) 资源跳转： A链接、重定向、表单提交
2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链
3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
</code></pre><p>其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p>
<p>什么是同源策略？<br>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下几种行为：</p>
<pre><code>1.) Cookie、LocalStorage 和 IndexDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送
</code></pre><h2 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h2><pre><code>URL                                      说明                    是否允许通信
http://www.domain.com/a.js
http://www.domain.com/b.js         同一域名，不同文件或路径           允许
http://www.domain.com/lab/c.js

http://www.domain.com:8000/a.js
http://www.domain.com/b.js         同一域名，不同端口                不允许

http://www.domain.com/a.js
https://www.domain.com/b.js        同一域名，不同协议                不允许

http://www.domain.com/a.js
http://192.168.4.12/b.js           域名和域名对应相同ip              不允许

http://www.domain.com/a.js
http://x.domain.com/b.js           主域相同，子域不同                不允许
http://domain.com/c.js

http://www.domain1.com/a.js
http://www.domain2.com/b.js        不同域名                         不允许
</code></pre><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p>
<h2 id="一、-通过jsonp跨域"><a href="#一、-通过jsonp跨域" class="headerlink" title="一、 通过jsonp跨域"></a>一、 通过jsonp跨域</h2><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>
<p>1.）原生实现：</p>
<pre><code>&lt;script&gt;
    var script = document.createElement(&apos;script&apos;);
    script.type = &apos;text/javascript&apos;;

    // 传参并指定回调执行函数为onBack
    script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&apos;;
    document.head.appendChild(script);

    // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    }
 &lt;/script&gt;
</code></pre><p>服务端返回如下（返回时即执行全局函数）：</p>
<pre><code>onBack({&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;})
</code></pre><p>2.）jquery ajax：</p>
<pre><code>$.ajax({
    url: &apos;http://www.domain2.com:8080/login&apos;,
    type: &apos;get&apos;,
    dataType: &apos;jsonp&apos;,  // 请求方式为jsonp
    jsonpCallback: &quot;onBack&quot;,    // 自定义回调函数名
    data: {}
});
</code></pre><p>3.）vue.js：</p>
<pre><code>this.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;, {
    params: {},
    jsonp: &apos;onBack&apos;
}).then((res) =&gt; {
    console.log(res); 
})
</code></pre><p>后端node.js代码示例：</p>
<pre><code>var querystring = require(&apos;querystring&apos;);
var http = require(&apos;http&apos;);
var server = http.createServer();

server.on(&apos;request&apos;, function(req, res) {
    var params = qs.parse(req.url.split(&apos;?&apos;)[1]);
    var fn = params.callback;

    // jsonp返回设置
    res.writeHead(200, { &apos;Content-Type&apos;: &apos;text/javascript&apos; });
    res.write(fn + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;);

    res.end();
});

server.listen(&apos;8080&apos;);
console.log(&apos;Server is running at port 8080...&apos;);
</code></pre><p>jsonp缺点：只能实现get一种请求。</p>
<h2 id="二、-document-domain-iframe跨域"><a href="#二、-document-domain-iframe跨域" class="headerlink" title="二、 document.domain + iframe跨域"></a>二、 document.domain + iframe跨域</h2><p>此方案仅限主域相同，子域不同的跨域应用场景。</p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>1.）父窗口：(<a href="https://link.zhihu.com/?target=http%3A//www.domain.com/a.html%29" target="_blank" rel="noopener">http://www.domain.com/a.html)</a></p>
<pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    document.domain = &apos;domain.com&apos;;
    var user = &apos;admin&apos;;
&lt;/script&gt;
</code></pre><p>2.）子窗口：(<a href="https://link.zhihu.com/?target=http%3A//child.domain.com/b.html%29" target="_blank" rel="noopener">http://child.domain.com/b.html)</a></p>
<pre><code>&lt;script&gt;
    document.domain = &apos;domain.com&apos;;
    // 获取父窗口中变量
    alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);
&lt;/script&gt;
</code></pre><h2 id="三、-location-hash-iframe跨域"><a href="#三、-location-hash-iframe跨域" class="headerlink" title="三、 location.hash + iframe跨域"></a>三、 location.hash + iframe跨域</h2><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<p>1.）a.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/a.html%29" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p>
<pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    var iframe = document.getElementById(&apos;iframe&apos;);

    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + &apos;#user=admin&apos;;
    }, 1000);

    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert(&apos;data from c.html ---&gt; &apos; + res);
    }
&lt;/script&gt;
</code></pre><p>2.）b.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain2.com/b.html%29" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p>
<pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    var iframe = document.getElementById(&apos;iframe&apos;);

    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
&lt;/script&gt;
</code></pre><p>3.）c.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/c.html%29" target="_blank" rel="noopener">http://www.domain1.com/c.html)</a></p>
<pre><code>&lt;script&gt;
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;));
    };
&lt;/script&gt;
</code></pre><h2 id="四、-window-name-iframe跨域"><a href="#四、-window-name-iframe跨域" class="headerlink" title="四、 window.name + iframe跨域"></a>四、 window.name + iframe跨域</h2><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>1.）a.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/a.html%29" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p>
<pre><code>var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement(&apos;iframe&apos;);

    // 加载跨域页面
    iframe.src = url;

    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();

        } else if (state === 0) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;;
            state = 1;
        }
    };

    document.body.appendChild(iframe);

    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write(&apos;&apos;);
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};

// 请求跨域b页面数据
proxy(&apos;http://www.domain2.com/b.html&apos;, function(data){
    alert(data);
});
</code></pre><p>2.）proxy.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/proxy.html%29" target="_blank" rel="noopener">http://www.domain1.com/proxy….</a><br>中间代理页，与a.html同域，内容为空即可。</p>
<p>3.）b.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain2.com/b.html%29" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p>
<pre><code>&lt;script&gt;
    window.name = &apos;This is domain2 data!&apos;;
&lt;/script&gt;
</code></pre><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h2 id="五、-postMessage跨域"><a href="#五、-postMessage跨域" class="headerlink" title="五、 postMessage跨域"></a>五、 postMessage跨域</h2><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p>
<p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p>1.）a.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/a.html%29" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p>
<pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;       
    var iframe = document.getElementById(&apos;iframe&apos;);
    iframe.onload = function() {
        var data = {
            name: &apos;aym&apos;
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;);
    };

    // 接受domain2返回数据
    window.addEventListener(&apos;message&apos;, function(e) {
        alert(&apos;data from domain2 ---&gt; &apos; + e.data);
    }, false);
&lt;/script&gt;
</code></pre><p>2.）b.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain2.com/b.html%29" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p>
<pre><code>&lt;script&gt;
    // 接收domain1的数据
    window.addEventListener(&apos;message&apos;, function(e) {
        alert(&apos;data from domain1 ---&gt; &apos; + e.data);

        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;

            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;);
        }
    }, false);
&lt;/script&gt;
</code></pre><h2 id="六、-跨域资源共享（CORS）"><a href="#六、-跨域资源共享（CORS）" class="headerlink" title="六、 跨域资源共享（CORS）"></a>六、 跨域资源共享（CORS）</h2><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p>
<p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p>
<p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p>
<h2 id="1、-前端设置："><a href="#1、-前端设置：" class="headerlink" title="1、 前端设置："></a>1、 前端设置：</h2><p>1.）原生ajax</p>
<pre><code>// 前端设置是否带cookie
xhr.withCredentials = true;
</code></pre><p>示例代码：</p>
<pre><code>var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容

// 前端设置是否带cookie
xhr.withCredentials = true;

xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);
xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);
xhr.send(&apos;user=admin&apos;);

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
        alert(xhr.responseText);
    }
};
</code></pre><p>2.）jQuery ajax</p>
<pre><code>$.ajax({
    ...
   xhrFields: {
       withCredentials: true    // 前端设置是否带cookie
   },
   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
    ...
});
</code></pre><p>3.）vue框架<br>在vue-resource封装的ajax组件中加入以下代码：</p>
<pre><code>Vue.http.options.credentials = true
</code></pre><h2 id="2、-服务端设置："><a href="#2、-服务端设置：" class="headerlink" title="2、 服务端设置："></a>2、 服务端设置：</h2><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p>
<p>1.）Java后台：</p>
<pre><code>/*
 * 导入包：import javax.servlet.http.HttpServletResponse;
 * 接口参数中定义：HttpServletResponse response
 */
response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;);  // 若有端口需写全（协议+域名+端口）
response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
</code></pre><p>2.）Nodejs后台示例：</p>
<pre><code>var http = require(&apos;http&apos;);
var server = http.createServer();
var qs = require(&apos;querystring&apos;);

server.on(&apos;request&apos;, function(req, res) {
    var postData = &apos;&apos;;

    // 数据块接收中
    req.addListener(&apos;data&apos;, function(chunk) {
        postData += chunk;
    });

    // 数据接收完毕
    req.addListener(&apos;end&apos;, function() {
        postData = qs.parse(postData);

        // 跨域后台设置
        res.writeHead(200, {
            &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;,     // 后端允许发送Cookie
            &apos;Access-Control-Allow-Origin&apos;: &apos;http://www.domain1.com&apos;,    // 允许访问的域（协议+域名+端口）
            &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取cookie
        });

        res.write(JSON.stringify(postData));
        res.end();
    });
});

server.listen(&apos;8080&apos;);
console.log(&apos;Server is running at port 8080...&apos;);
</code></pre><h2 id="七、-nginx代理跨域"><a href="#七、-nginx代理跨域" class="headerlink" title="七、 nginx代理跨域"></a>七、 nginx代理跨域</h2><h2 id="1、-nginx配置解决iconfont跨域"><a href="#1、-nginx配置解决iconfont跨域" class="headerlink" title="1、 nginx配置解决iconfont跨域"></a>1、 nginx配置解决iconfont跨域</h2><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<pre><code>location / {
  add_header Access-Control-Allow-Origin *;
}
</code></pre><h2 id="2、-nginx反向代理接口跨域"><a href="#2、-nginx反向代理接口跨域" class="headerlink" title="2、 nginx反向代理接口跨域"></a>2、 nginx反向代理接口跨域</h2><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<p>nginx具体配置：</p>
<pre><code>#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;

    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
</code></pre><p>1.) 前端代码示例：</p>
<pre><code>var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问nginx中的代理服务器
xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);
xhr.send();
</code></pre><p>2.) Nodejs后台示例：</p>
<pre><code>var http = require(&apos;http&apos;);
var server = http.createServer();
var qs = require(&apos;querystring&apos;);

server.on(&apos;request&apos;, function(req, res) {
    var params = qs.parse(req.url.substring(2));

    // 向前台写cookie
    res.writeHead(200, {
        &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取
    });

    res.write(JSON.stringify(params));
    res.end();
});

server.listen(&apos;8080&apos;);
console.log(&apos;Server is running at port 8080...&apos;);
</code></pre><h2 id="八、-Nodejs中间件代理跨域"><a href="#八、-Nodejs中间件代理跨域" class="headerlink" title="八、 Nodejs中间件代理跨域"></a>八、 Nodejs中间件代理跨域</h2><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<h2 id="1、-非vue框架的跨域（2次跨域）"><a href="#1、-非vue框架的跨域（2次跨域）" class="headerlink" title="1、 非vue框架的跨域（2次跨域）"></a>1、 非vue框架的跨域（2次跨域）</h2><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<p>1.）前端代码示例：</p>
<pre><code>var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问http-proxy-middleware代理服务器
xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true);
xhr.send();
</code></pre><p>2.）中间件服务器：</p>
<pre><code>var express = require(&apos;express&apos;);
var proxy = require(&apos;http-proxy-middleware&apos;);
var app = express();

app.use(&apos;/&apos;, proxy({
    // 代理跨域目标接口
    target: &apos;http://www.domain2.com:8080&apos;,
    changeOrigin: true,

    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;);
        res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);
    },

    // 修改响应信息中的cookie域名
    cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改
}));

app.listen(3000);
console.log(&apos;Proxy server is listen at port 3000...&apos;);
</code></pre><p>3.）Nodejs后台同（六：nginx）</p>
<h2 id="2、-vue框架的跨域（1次跨域）"><a href="#2、-vue框架的跨域（1次跨域）" class="headerlink" title="2、 vue框架的跨域（1次跨域）"></a>2、 vue框架的跨域（1次跨域）</h2><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p>
<p>webpack.config.js部分配置：</p>
<pre><code>module.exports = {
    entry: {},
    module: {},
    ...
    devServer: {
        historyApiFallback: true,
        proxy: [{
            context: &apos;/login&apos;,
            target: &apos;http://www.domain2.com:8080&apos;,  // 代理跨域目标接口
            changeOrigin: true,
            cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改
        }],
        noInfo: true
    }
}
</code></pre><h2 id="九、-WebSocket协议跨域"><a href="#九、-WebSocket协议跨域" class="headerlink" title="九、 WebSocket协议跨域"></a>九、 WebSocket协议跨域</h2><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用<a href="https://link.zhihu.com/?target=http%3A//Socket.io" target="_blank" rel="noopener">http://Socket.io</a>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>1.）前端代码：</p>
<pre><code>&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;
&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var socket = io(&apos;http://www.domain2.com:8080&apos;);

// 连接成功处理
socket.on(&apos;connect&apos;, function() {
    // 监听服务端消息
    socket.on(&apos;message&apos;, function(msg) {
        console.log(&apos;data from server: ---&gt; &apos; + msg); 
    });

    // 监听服务端关闭
    socket.on(&apos;disconnect&apos;, function() { 
        console.log(&apos;Server socket has closed.&apos;); 
    });
});

document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() {
    socket.send(this.value);
};
&lt;/script&gt;
</code></pre><p>2.）Nodejs socket后台：</p>
<pre><code>var http = require(&apos;http&apos;);
var socket = require(&apos;socket.io&apos;);

// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        &apos;Content-type&apos;: &apos;text/html&apos;
    });
    res.end();
});

server.listen(&apos;8080&apos;);
console.log(&apos;Server is running at port 8080...&apos;);

// 监听socket连接
socket.listen(server).on(&apos;connection&apos;, function(client) {
    // 接收信息
    client.on(&apos;message&apos;, function(msg) {
        client.send(&apos;hello：&apos; + msg);
        console.log(&apos;data from client: ---&gt; &apos; + msg);
    });

    // 断开处理
    client.on(&apos;disconnect&apos;, function() {
        console.log(&apos;Client socket has closed.&apos;); 
    });
}); 
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/HTTP三种缓存方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/HTTP三种缓存方式/" itemprop="url">HTTP三种缓存方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T00:03:50+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>依然在学习node的艰辛过程中，最近学习了http相关的知识，学到了东西当然第一时间就来和大家分享分享，今天呢就教大家来看看利用node中的http模块去实现不同的缓存策略！！！</p>
<p>我们都知道，对于我们前端开发来说，缓存是一个十分重要的东西，即希望用户不能每次请求过来都要重复下载我们的页面内容，希望为用户节省流量，并且能提高我们页面的浏览流畅度，但是同时当我们修改了一个bug后，又希望线上能够及时更新，这时候就要求爷爷告奶奶让运维小哥哥帮我们刷新一下缓存了，那么有没有一些比较好的缓存策略可以针对我们修改bug又能不麻烦运维及时更新呢，今天我们就利用node来看一下后端中的缓存策略是如何设置的。</p>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>通常我们对于强制缓存的设置是服务端告诉客户端你刚刚已经请求过一次了，我们约定好十分钟内你再过来请求都直接读取缓存吧，意思也就是当客户端在十分钟内多次请求的话只有第一次会下载页面内容，其他的请求都是直接走缓存，不管我们页面在这期间有没有变化都不会影响客户端读取缓存。<br>那我们来看一下代码的实现</p>
<pre><code>let http = require(&apos;http&apos;);
let path = require(&apos;path&apos;);
let fs = require(&apos;fs&apos;);
let url = require(&apos;url&apos;);
// 创建一个服务
let server = http.createServer();
// 监听请求
server.on(&apos;request&apos;,(req,res)=&gt;{
    // 获取到请求的路径
    let {pathname,query} = url.parse(req.url,true);
    // 将路径拼接成服务器上对应得文件路径
    let readPath = path.join(__dirname, &apos;public&apos;,pathname);
    console.log(readPath)
    try {
        // 获取路径状态
        let statObj = fs.statSync(readPath);
        // 服务端设置响应头 Cache-Control 也就是缓存多久以秒为单位
        res.setHeader(&apos;Cache-Control&apos;,&apos;max-age=10&apos;);
        // 服务器设置响应头Expires 过期时间 获取当前时间加上刚刚设置的缓存秒数
        res.setHeader(&apos;Expires&apos;,new Date(Date.now()+10*1000).toGMTString());
        //判断如果路径是一件文件夹 就默认查找该文件下的index.html
        if(statObj.isDirectory()){
            let p = path.join(readPath,&apos;index.html&apos;);
            console.log(p);
            // 判断是否有index.html 没有就返回404
            fs.statSync(p);
            // 创建文件可读流 并且pipe到响应res可写流中
            fs.createReadStream(p).pipe(res)
        }else{
            // 如果请求的就是一个文件 那么久直接返回
            fs.createReadStream(readPath).pipe(res)
        }
    } catch (error) {
        // 读取不到 返回404 
        console.log(error)
        res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;)
        res.statusCode = 404;
        res.end(`未发现文件`)
    }
})
// 监听3000端口
server.listen(3000)
复制代码
</code></pre><p><a href="https://camo.githubusercontent.com/3ca59134ca5ee58d2a4c0b139c8c829bc81d1965/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396633646236643965613131323f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3ca59134ca5ee58d2a4c0b139c8c829bc81d1965/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396633646236643965613131323f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></a><br>通过上面代码测试我们会发现当我们在10秒内进行对同一文件的请求，那么我们浏览器就会直接走缓存 通过上图可以看到我们重复请求的时候我们会看到css变成from memory cache，我们也看到我们刚刚的响应头也被设置上了</p>
<p><a href="https://camo.githubusercontent.com/efed3949630e898e6f5351b5b47d23e536ae6be8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396633663737303637353231353f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/efed3949630e898e6f5351b5b47d23e536ae6be8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396633663737303637353231353f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></a></p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>上面的强制缓存我们就发现了 就是我们平时改完bug上线要苦苦等待的一个原因了，那么有没有其他的好的缓存处理方法呢，我们设想一下 假如我们能够知道我们文件有没有修改，假如我们修改了服务器就返回最新的内容假如没有修改 就一直默认缓存 ，这样是不是听起来十分的棒！那我们就想如果我们能够知道文件的最后修改时间是不是就可以实现了！</p>
<h3 id="通过文件最后修改时间来缓存"><a href="#通过文件最后修改时间来缓存" class="headerlink" title="通过文件最后修改时间来缓存"></a>通过文件最后修改时间来缓存</h3><pre><code>let http = require(&apos;http&apos;);
let path = require(&apos;path&apos;);
let fs = require(&apos;fs&apos;);
let url = require(&apos;url&apos;);
let server = http.createServer();
server.on(&apos;request&apos;,(req,res)=&gt;{
    // 获取到请求的路径
    let {pathname,query} = url.parse(req.url,true);
    // 将路径拼接成服务器上对应得文件路径
    let readPath = path.join(__dirname, &apos;public&apos;,pathname);
    try {
        // 获取路径状态
        let statObj = fs.statSync(readPath);
        // 为了方便测试 我们告诉客户端不要走强制缓存了
        res.setHeader(&apos;Cache-Control&apos;,&apos;no-cache&apos;);
        if(statObj.isDirectory()){
            let p = path.join(readPath,&apos;index.html&apos;);
            let statObj = fs.statSync(p);
            // 我们通过获取到文件状态来拿到文件的最后修改时间 也就是ctime 我们把这个时间通过响应头Last-Modified来告诉客户端，客户端再下一次请求的时候会通过请求头If-Modified-Since把这个值带给服务端，我们只要判断这两个值是否相等，假如相等那么也就是说 文件没有被修改那么我们就告诉客户端304 你直接读缓存吧
            res.setHeader(&apos;Last-Modified&apos;,statObj.ctime.toGMTString());
            if(req.headers[&apos;if-modified-since&apos;] === statObj.ctime.toGMTString()){
                res.statusCode = 304;
                res.end();
                return
            }
            // 修改了那么我们就直接返回新的内容
            fs.createReadStream(p).pipe(res)
        }else{
            res.setHeader(&apos;Last-Modified&apos;,statObj.ctime.toGMTString());
            if(req.headers[&apos;if-modified-since&apos;] === statObj.ctime.toGMTString()){
                res.statusCode = 304;
                res.end();
                return
            }
            fs.createReadStream(readPath).pipe(res)
        }
    } catch (error) {
        console.log(error)
        res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;)
        res.statusCode = 404;
        res.end(`未发现文件`)
    }
})

server.listen(3000)

复制代码
</code></pre><p><a href="https://camo.githubusercontent.com/2c5d1c2ea01db5d6f83ffda15dd41afcdfc0ed61/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396634386366343637626232303f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/2c5d1c2ea01db5d6f83ffda15dd41afcdfc0ed61/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396634386366343637626232303f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></a></p>
<p>我们通过请求可以看到，当我们第一次请求过后，无论怎么刷新请求都是304 直接读取的缓存，假如我们在服务端把这个文件修改了 那么我们就能看到又能请求到最新的内容了，这就是我们通过协商缓存来处理的，我们通过获取到文件状态来拿到文件的最后修改时间 也就是ctime 我们把这个时间通过响应头Last-Modified来告诉客户端，客户端再下一次请求的时候会通过请求头If-Modified-Since把这个值带给服务端，我们只要判断这两个值是否相等，假如相等那么也就是说 文件没有被修改那么我们就告诉客户端304 你直接读缓存吧</p>
<h3 id="通过文件内容来缓存"><a href="#通过文件内容来缓存" class="headerlink" title="通过文件内容来缓存"></a>通过文件内容来缓存</h3><p>再再再再再假如我们在文件中删除了字符a然后又还原了，那么这时候保存我们的文件的修改时间其实也发生了变化，但是其实我们文件的真正内容并没有发生变化，所以这时候其实客户端继续走缓存也是可以的 ，我们来看看这样的缓存策略如何实现。</p>
<pre><code>let http = require(&apos;http&apos;);
let path = require(&apos;path&apos;);
let fs = require(&apos;fs&apos;);
let url = require(&apos;url&apos;);
let crypto = require(&apos;crypto&apos;);
let server = http.createServer();
server.on(&apos;request&apos;,(req,res)=&gt;{
    // 获取到请求的路径
    let {pathname,query} = url.parse(req.url,true);
    // 将路径拼接成服务器上对应得文件路径
    let readPath = path.join(__dirname, &apos;public&apos;,pathname);
    try {
        // 获取路径状态
        let statObj = fs.statSync(readPath);
        // 为了方便测试 我们告诉客户端不要走强制缓存了
        res.setHeader(&apos;Cache-Control&apos;,&apos;no-cache&apos;);
        if(statObj.isDirectory()){
            let p = path.join(readPath,&apos;index.html&apos;);
            let statObj = fs.statSync(p);
            // 我们通过流把文件读取出来 然后对读取问来的内容进行md5加密 得到一个base64加密hash值
            let rs = fs.createReadStream(p);
            let md5 = crypto.createHash(&apos;md5&apos;);
            let arr = [];
            rs.on(&apos;data&apos;,(data)=&gt;{
                arr.push(data);
                md5.update(data);
            })
            rs.on(&apos;end&apos;,(data)=&gt;{
                let r = md5.digest(&apos;base64&apos;);
                // 然后我们将这个hash值通过响应头Etag传给客户端，客户端再下一次请求的时候会把上一次的Etag值通过请求头if-none-match带过来，然后我们就可以继续比对文件生成的hash值和上次产生的hash是否一样 如果一样说明文件内容没有发生变化 就告诉客户端304 读取缓存
                res.setHeader(&apos;Etag&apos;,r);
                if(req.headers[&apos;if-none-match&apos;]===r){
                    res.statusCode=304;
                    res.end();
                    return;
                }
                res.end(Buffer.concat(arr))
            })
        }else{
            let rs = fs.createReadStream(readPath);
            let md5 = crypto.createHash(&apos;md5&apos;);
            let arr = [];
            rs.on(&apos;data&apos;,(data)=&gt;{
                arr.push(data);
                md5.update(data);
            })
            rs.on(&apos;end&apos;,(data)=&gt;{
                let r = md5.digest(&apos;base64&apos;);
                res.setHeader(&apos;Etag&apos;,r);
                if(req.headers[&apos;if-none-match&apos;]===r){
                    res.statusCode=304;
                    res.end();
                    return;
                }
                res.end(Buffer.concat(arr))
            })
        }
    } catch (error) {
        console.log(error)
        res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;)
        res.statusCode = 404;
        res.end(`未发现文件`)
    }
})

server.listen(3000)

复制代码
</code></pre><p><a href="https://camo.githubusercontent.com/2f8b1e0fdea5971d22f52b82ebae608cf2f8d73b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396665623530666363373334393f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/2f8b1e0fdea5971d22f52b82ebae608cf2f8d73b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396665623530666363373334393f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></a><br>通过控制台我们可以看出来 请求头和响应头中都有我们上面所说的对应的值，但是从代码里我们也能看出来，我们每次在请求到来的时候都会把文件全部读取出来并且进行加密生产hash然后再做对比，这样其实十分的消耗性能，因此这种缓存方式也有他自己的缺点</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过node来亲自实现了三种缓存方式，我们可以总结出每种缓存方式对应的实现：</p>
<ul>
<li>强制缓存 服务端设置响应头Cache-Control:max-age=xxx，并且设置Expires响应头过期时间，客户端自行判断是否读取缓存</li>
<li><p>协商缓存 通过状态码304告诉客户端该走缓存</p>
</li>
<li><p>修改时间：通过文件的最后修改时间判断该不该读取缓存，服务端设置响应头Last-Modified,客户端把上次服务端响应头中的Last-modified值通过if-modified-since 传递给服务端 ， 服务端通过比较当前文件的修改时间和上次修改时间(上次传给客户端的值),如果相等那么说明文件修改时间没变也就是没变化</p>
</li>
<li>文件内容：通过文件的内容来判断该不该读取缓存，服务端通过把文件内容读取出来，通过md5进行base64加密得出hash值，把这个值设置响应头Etag，客户端下一次请求通过if-none-match带过来，服务端再比对当前文件内容加密得出的hash值和上次是否一样，如果一样说明文件内容没有发生改变，这种方式是最准确的方式，但是也是最耗性能</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/10/Vue你可能不知道的7个技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/Vue你可能不知道的7个技巧/" itemprop="url">Vue你可能不知道的7个技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T15:02:13+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、善用watch的immediate属性"><a href="#一、善用watch的immediate属性" class="headerlink" title="一、善用watch的immediate属性"></a>一、善用watch的immediate属性</h2><p>这一点我在项目中也是这么写的。例如有请求需要再也没初始化的时候就执行一次，然后监听他的变化，很多人这么写：</p>
<pre><code>created(){
    this.fetchPostList()
},
watch: {
    searchInputValue(){
        this.fetchPostList()
    }
}
</code></pre><p>上面的这种写法我们可以完全如下写：</p>
<pre><code> watch: {
    searchInputValue:{
        handler: &apos;fetchPostList&apos;,
        immediate: true
    }
}
</code></pre><h2 id="二、组件注册，值得借鉴"><a href="#二、组件注册，值得借鉴" class="headerlink" title="二、组件注册，值得借鉴"></a>二、组件注册，值得借鉴</h2><p>一般情况下，我们组件如下写：</p>
<pre><code>import BaseButton from &apos;./baseButton&apos;
import BaseIcon from &apos;./baseIcon&apos;
import BaseInput from &apos;./baseInput&apos;export default {
  components: {
    BaseButton,
    BaseIcon,
    BaseInput
  }
}
&lt;BaseInput  v-model=&quot;searchText&quot; @keydown.enter=&quot;search&quot; /&gt;
&lt;BaseButton @click=&quot;search&quot;&gt;  &lt;BaseIcon name=&quot;search&quot;/&gt;&lt;/BaseButton&gt;
</code></pre><p>步骤一般有三部，</p>
<blockquote>
<p>第一步，引入、</p>
</blockquote>
<blockquote>
<p>第二步注册、</p>
</blockquote>
<blockquote>
<p>第三步才是正式的使用，</p>
</blockquote>
<p>这也是最常见和通用的写法。但是这种写法经典归经典，好多组件，要引入多次，注册多次，感觉很烦。</p>
<p>我们可以借助一下webpack，使用 require.context() 方法来创建自己的（模块）上下文，从而实现自动动态require组件。</p>
<p>思路是：在src文件夹下面main.js中，借助webpack动态将需要的基础组件统统打包进来。</p>
<p>代码如下：</p>
<pre><code>import Vue from &apos;vue&apos;
import upperFirst from &apos;lodash/upperFirst&apos;
import camelCase from &apos;lodash/camelCase&apos;

// Require in a base component context
const requireComponent = require.context(&apos;./components&apos;, false, /base-[\w-]+\.vue$/)

requireComponent.keys().forEach(fileName =&gt; {
  // Get component config
  const componentConfig = requireComponent(fileName)

  // Get PascalCase name of component
  const componentName = upperFirst(
    camelCase(fileName.replace(/^\.\//, &apos;&apos;).replace(/\.\w+$/, &apos;&apos;))
  )

  // Register component globally
  Vue.component(componentName, componentConfig.default || componentConfig)
})
</code></pre><p>这样我们引入组件只需要第三步就可以了：</p>
<pre><code>&lt;BaseInput
   v-model=&quot;searchText&quot;
   @keydown.enter=&quot;search&quot;
/&gt;
&lt;BaseButton @click=&quot;search&quot;&gt;
   &lt;BaseIcon name=&quot;search&quot;/&gt;
&lt;/BaseButton&gt;
</code></pre><h2 id="三、精简vuex的modules引入"><a href="#三、精简vuex的modules引入" class="headerlink" title="三、精简vuex的modules引入"></a>三、精简vuex的modules引入</h2><p>对于vuex，我们输出store如下写：</p>
<pre><code>import auth from &apos;./modules/auth&apos;
import posts from &apos;./modules/posts&apos;
import comments from &apos;./modules/comments&apos;


export default new Vuex.Store({
  modules: {
    auth,
    posts,
    comments
  }
})
</code></pre><p>要引入好多modules，然后再注册到Vuex.Store中~~</p>
<p>精简的做法和上面类似，也是运用 require.context()读取文件，代码如下：</p>
<pre><code>import camelCase from &apos;lodash/camelCase&apos;
const requireModule = require.context(&apos;.&apos;, false, /\.js$/)
const modules = {}

requireModule.keys().forEach(fileName =&gt; {
// Don&apos;t register this file as a Vuex module
if (fileName === &apos;./index.js&apos;) return

const moduleName = camelCase(
  fileName.replace(/(\.\/|\.js)/g, &apos;&apos;)
)
modules[moduleName] = {
              namespaced: true,
             ...requireModule(fileName),
            }

})

export default modules
</code></pre><p>这样我们只需如下代码就可以了：</p>
<pre><code>import modules from &apos;./modules&apos;
export default new Vuex.Store({
   modules
})
</code></pre><h2 id="四、路由的延迟加载"><a href="#四、路由的延迟加载" class="headerlink" title="四、路由的延迟加载"></a>四、路由的延迟加载</h2><p>这一点，关于vue的引入，我之前在中也提及过，可以通过require方式或者import()方式动态加载组件。</p>
<pre><code>{
 path: &apos;/admin&apos;,
 name: &apos;admin-dashboard&apos;,
 component:require(&apos;@views/admin&apos;).default
}
</code></pre><p>或者</p>
<pre><code>{
  path: &apos;/admin&apos;,
  name: &apos;admin-dashboard&apos;,
  component:() =&gt; import(&apos;@views/admin&apos;)
}
</code></pre><p>加载路由。</p>
<h2 id="五、router-key组件刷新"><a href="#五、router-key组件刷新" class="headerlink" title="五、router key组件刷新"></a>五、router key组件刷新</h2><p>下面这个场景真的是伤透了很多程序员的心…<br> 先默认大家用的是Vue-router来实现路由的控制。 假设我们在写一个博客网站，需求是从/post-haorooms/a，跳转到/post-haorooms/b。然后我们惊人的发现，页面跳转后数据竟然没更新？！原因是vue-router”智能地”发现这是同一个组件，然后它就决定要复用这个组件，所以你在created函数里写的方法压根就没执行。通常的解决方案是监听$route的变化来初始化数据，如下：</p>
<pre><code>data() {
  return {
    loading: false,
    error: null,
    post: null
  }
}, 
watch: {
  &apos;$route&apos;: {
    handler: &apos;resetData&apos;,
    immediate: true
  }
},
methods: {
  resetData() {
    this.loading = false
    this.error = null
    this.post = null
    this.getPost(this.$route.params.id)
  },
  getPost(id){

  }
}
</code></pre><p>bug是解决了，可每次这么写也太不优雅了吧？秉持着能偷懒则偷懒的原则，我们希望代码这样写：</p>
<pre><code>data() {
  return {
    loading: false,
    error: null,
    post: null
  }
},
created () {
  this.getPost(this.$route.params.id)
},
methods () {
  getPost(postId) {
    // ...
  }
}
</code></pre><p>解决方案：给router-view添加一个唯一的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件。</p>
<pre><code>&lt;router-view :key=&quot;$route.fullpath&quot;&gt;&lt;/router-view&gt;
</code></pre><p>注：我个人的经验，这个一般应用在子路由里面，这样才可以不避免大量重绘，假设app.vue根目录添加这个属性，那么每次点击改变地址都会重绘，还是得不偿失的！</p>
<h2 id="六、唯一组件根元素"><a href="#六、唯一组件根元素" class="headerlink" title="六、唯一组件根元素"></a>六、唯一组件根元素</h2><p>场景如下：</p>
<pre><code>(Emitted value instead of an instance of Error)
 Error compiling template:

 &lt;div&gt;&lt;/div&gt;
 &lt;div&gt;&lt;/div&gt;

 - Component template should contain exactly one root element. 
   If you are using v-if on multiple elements, use v-else-if 
   to chain them instead.
</code></pre><p>模板中div只能有一个，不能如上面那么平行2个div。</p>
<p>例如如下代码：</p>
<pre><code>&lt;template&gt;
  &lt;li
    v-for=&quot;route in routes&quot;
    :key=&quot;route.name&quot;
  &gt;
    &lt;router-link :to=&quot;route&quot;&gt;
      {{ route.title }}
    &lt;/router-link&gt;
  &lt;/li&gt;
&lt;/template&gt;
</code></pre><p>会报错！</p>
<p>我们可以用render函数来渲染</p>
<pre><code>functional: true,
render(h, { props }) {
 return props.routes.map(route =&gt;
   &lt;li key={route.name}&gt;
     &lt;router-link to={route}&gt;
       {route.title}
     &lt;/router-link&gt;
   &lt;/li&gt;
 )
}
</code></pre><h2 id="七、组件包装、事件属性穿透问题"><a href="#七、组件包装、事件属性穿透问题" class="headerlink" title="七、组件包装、事件属性穿透问题"></a>七、组件包装、事件属性穿透问题</h2><p>当我们写组件的时候，通常我们都需要从父组件传递一系列的props到子组件，同时父组件监听子组件emit过来的一系列事件。举例子：</p>
<pre><code>//父组件
&lt;BaseInput 
    :value=&quot;value&quot;
    label=&quot;密码&quot; 
    placeholder=&quot;请填写密码&quot;
    @input=&quot;handleInput&quot;
    @focus=&quot;handleFocus&gt;
&lt;/BaseInput&gt;

//子组件
&lt;template&gt;
  &lt;label&gt;
    {{ label }}
    &lt;input
      :value=&quot;value&quot;
      :placeholder=&quot;placeholder&quot;
      @focus=$emit(&apos;focus&apos;, $event)&quot;
      @input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;
    &gt;
  &lt;/label&gt;
&lt;/template&gt;
</code></pre><p>这样写很不精简，很多属性和事件都是手动定义的，我们可以如下写：</p>
<pre><code>&lt;input
    :value=&quot;value&quot;
    v-bind=&quot;$attrs&quot;
    v-on=&quot;listeners&quot;
&gt;

computed: {
  listeners() {
    return {
      ...this.$listeners,
      input: event =&gt; 
        this.$emit(&apos;input&apos;, event.target.value)
    }
  }
}
</code></pre><p>$attrs包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定，并且可以通过 v-bind=”$attrs” 传入内部组件。</p>
<p>$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/vue2-0模板渲染底层思想/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/vue2-0模板渲染底层思想/" itemprop="url">vue2.0模板渲染底层思想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-02T22:34:21+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>初衷</p>
<p>在使用vue2.0的过程，有时看API很难理解vue作者的思想，这促使我想要去深入了解vue底层的思想，了解完底层的一些思想，才能更好的用活框架，虽然网上已经有很多源码解析的文档，但我觉得只有自己动手了，才能更加深印象。</p>
<p>vue2.0和1.0模板渲染的区别</p>
<p>Vue 2.0 中模板渲染与 Vue 1.0 完全不同，1.0 中采用的 DocumentFragment （<a href="https://link.zhihu.com/?target=https%3A//juejin.im/entry/59116fa6a0bb9f0058aaaa4c" target="_blank" rel="noopener">想了解可以观看这篇文章</a>），而 2.0 中借鉴 React 的 Virtual DOM。基于 Virtual DOM，2.0 还可以支持服务端渲染（SSR），也支持 JSX 语法（改良版的 render 函数）。</p>
<p>知识普及</p>
<p>在开始阅读源码之前，先了解一些相关的知识：AST 数据结构，VNode 数据结构，createElement 的问题，render函数。</p>
<p>AST 数据结构</p>
<p>AST 的全称是 Abstract Syntax Tree（抽象语法树），是源代码的抽象语法结构的树状表现形式，计算机学科中编译原理的概念。而vue就是将模板代码映射为AST数据结构，进行语法解析。</p>
<p>我们看一下 Vue 2.0 源码中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/flow/compiler.js%23L63-L142" target="_blank" rel="noopener">AST 数据结构</a> 的定义：</p>
<pre><code>declare type ASTNode = ASTElement | ASTText | ASTExpression
declare type ASTElement = { // 有关元素的一些定义
  type: 1;
  tag: string;
  attrsList: Array&lt;{ name: string; value: string }&gt;;
  attrsMap: { [key: string]: string | null };
  parent: ASTElement | void;
  children: Array&lt;ASTNode&gt;;
  //......
}
declare type ASTExpression = {
  type: 2;
  expression: string;
  text: string;
  static?: boolean;
}
declare type ASTText = {
  type: 3;
  text: string;
  static?: boolean;
}
</code></pre><p>我们看到 ASTNode 有三种形式：ASTElement，ASTText，ASTExpression。用属性 type 区分。</p>
<p>VNode数据结构</p>
<p>下面是 Vue 2.0 源码中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/vdom/vnode.js%23L23-L50" target="_blank" rel="noopener">VNode 数据结构</a> 的定义 (带注释的跟下面介绍的内容有关)：</p>
<pre><code>constructor {
  this.tag = tag   //元素标签
  this.data = data  //属性
  this.children = children  //子元素列表
  this.text = text
  this.elm = elm  //对应的真实 DOM 元素
  this.ns = undefined
  this.context = context 
  this.functionalContext = undefined
  this.key = data &amp;&amp; data.key
  this.componentOptions = componentOptions
  this.componentInstance = undefined
  this.parent = undefined
  this.raw = false
  this.isStatic = false //是否被标记为静态节点
  this.isRootInsert = true
  this.isComment = false
  this.isCloned = false
  this.isOnce = false
}
</code></pre><p>真实DOM存在什么问题，为什么要用虚拟DOM</p>
<p>我们为什么不直接使用原生 DOM 元素，而是使用真实 DOM 元素的简化版 VNode，最大的原因就是 document.createElement 这个方法创建的真实 DOM 元素会带来性能上的损失。我们来看一个 document.createElement 方法的例子</p>
<pre><code>let div = document.createElement(&apos;div&apos;);
for(let k in div) {
  console.log(k);
}
</code></pre><p>打开 console 运行一下上面的代码，会发现打印出来的属性多达 228 个，而这些属性有 90% 多对我们来说都是无用的。VNode 就是简化版的真实 DOM 元素，关联着真实的dom，比如属性elm，只包括我们需要的属性，并新增了一些在 diff 过程中需要使用的属性，例如 isStatic。</p>
<p>render函数</p>
<p>这个函数是通过编译模板文件得到的，其运行结果是 VNode。render 函数 与 JSX 类似，Vue 2.0 中除了 Template 也支持 JSX 的写法。大家可以使用 <a href="https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/api/%3F%23Vue-compile" target="_blank" rel="noopener">Vue.compile(template)</a>方法编译下面这段模板。</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;header&gt;
    &lt;h1&gt;I am a template!&lt;/h1&gt;
  &lt;/header&gt;
  &lt;p v-if=&quot;message&quot;&gt;
    {{ message }}
  &lt;/p&gt;
  &lt;p v-else&gt;
    No message.
  &lt;/p&gt;
&lt;/div&gt;
</code></pre><p>方法会返回一个对象，对象中有 render 和 staticRenderFns 两个值。看一下生成的 render函数</p>
<pre><code>(function() {
  with(this){
    return _c(&apos;div&apos;,{   //创建一个 div 元素
      attrs:{&quot;id&quot;:&quot;app&quot;}  //div 添加属性 id
      },[
        _m(0),  //静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render 函数
        _v(&quot; &quot;), //空的文本节点
        (message) //三元表达式，判断 message 是否存在
         //如果存在，创建 p 元素，元素里面有文本，值为 toString(message)
        ?_c(&apos;p&apos;,[_v(&quot;\n    &quot;+_s(message)+&quot;\n  &quot;)])
        //如果不存在，创建 p 元素，元素里面有文本，值为 No message. 
        :_c(&apos;p&apos;,[_v(&quot;\n    No message.\n  &quot;)])
      ]
    )
  }
})
</code></pre><p>要看懂上面的 render函数，只需要了解 _c，_m，_v，_s 这几个函数的定义，其中 _c 是 createElement（创建元素），_m 是 renderStatic（渲染静态节点），_v 是 createTextVNode（创建文本dom），_s 是 toString （转换为字符串）</p>
<p>除了 render 函数，还有一个 staticRenderFns 数组，这个数组中的函数与 VDOM 中的 diff 算法优化相关，我们会在编译阶段给后面不会发生变化的 VNode 节点打上 static 为 true 的标签，那些被标记为静态节点的 VNode 就会单独生成 staticRenderFns 函数</p>
<pre><code>(function() { //上面 render 函数 中的 _m(0) 会调用这个方法
  with(this){
    return _c(&apos;header&apos;,[_c(&apos;h1&apos;,[_v(&quot;I&apos;m a template!&quot;)])])
  }
})
</code></pre><p>模板渲染过程（重要的函数介绍）</p>
<p>了解完一些基础知识后，接下来我们讲解下模板的渲染过程</p>
<p><img src="https://pic2.zhimg.com/v2-4a8793499b4d1a5395f2b5f7d0584a4b_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-4a8793499b4d1a5395f2b5f7d0584a4b_hd.jpg" alt=""><br><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/entries/web-runtime-with-compiler.js%23L14-L67" target="_blank" rel="noopener">$mount</a> 函数，主要是获取 template，然后进入 compileToFunctions 函数。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/platforms/web/compiler/index.js%23L36-L84" target="_blank" rel="noopener">compileToFunctions</a> 函数，主要将 template 编译成 render 函数。首先读缓存，没有缓存就调用 compile 方法拿到 render 函数 的字符串形式，再通过 new Function 的方式生成 render 函数。</p>
<pre><code>// 有缓存的话就直接在缓存里面拿
const key = options &amp;&amp; options.delimiters
            ? String(options.delimiters) + template
            : template
if (cache[key]) {
    return cache[key]
}
const res = {}
const compiled = compile(template, options) // compile 后面会详细讲
res.render = makeFunction(compiled.render) //通过 new Function 的方式生成 render 函数并缓存
const l = compiled.staticRenderFns.length
res.staticRenderFns = new Array(l)
for (let i = 0; i &lt; l; i++) {
    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i])
}
......
}
return (cache[key] = res) // 记录至缓存中
</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/index.js" target="_blank" rel="noopener">compile</a> 函数就是将 template 编译成 render 函数的字符串形式，后面一小节我们会详细讲到。</p>
<p>完成render方法的生成后，会进入 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/instance/lifecycle.js%23L38-L75" target="_blank" rel="noopener">_mount</a> 中进行DOM更新。该方法的核心逻辑如下：</p>
<pre><code>// 触发 beforeMount 生命周期钩子
callHook(vm, &apos;beforeMount&apos;)
// 重点：新建一个 Watcher 并赋值给 vm._watcher
vm._watcher = new Watcher(vm, function updateComponent () {
  vm._update(vm._render(), hydrating)
}, noop)
hydrating = false
// manually mounted instance, call mounted on self
// mounted is called for render-created child components in its inserted hook
if (vm.$vnode == null) {
  vm._isMounted = true
  callHook(vm, &apos;mounted&apos;)
}
return vm
</code></pre><p>首先会new一个watcher对象（主要是将模板与数据建立联系），在watcher对象创建后，会运行传入的方法 vm._update(vm._render(), hydrating) 。其中的vm._render()主要作用就是运行前面compiler生成的render方法，并返回一个vNode对象。vm.update() 则会对比新的 vdom 和当前 vdom，并把差异的部分渲染到真正的 DOM 树上。<br>（想深入了解watcher的背后实现原理的，可以观看这篇文章 <a href="https://link.zhihu.com/?target=http%3A//zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/" target="_blank" rel="noopener">Vue2.0 源码阅读：响应式原理</a>）</p>
<p>compile</p>
<p>上文中提到 compile 函数就是将 template 编译成 render 函数 的字符串形式。</p>
<pre><code>export function compile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const AST = parse(template.trim(), options) //1. parse
  optimize(AST, options)  //2.optimize
  const code = generate(AST, options) //3.generate
  return {
    AST,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
}
</code></pre><p>这个函数主要有三个步骤组成：parse，optimize 和 generate，分别输出一个包含 AST，staticRenderFns 的对象和 render函数 的字符串。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/parser/index.js" target="_blank" rel="noopener">parse</a> 函数，主要功能是将 template字符串解析成 AST。前面定义了ASTElement的数据结构，parse 函数就是将template里的结构（指令，属性，标签等）转换为AST形式存进ASTElement中，最后解析生成AST。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/optimizer.js%23L21-L29" target="_blank" rel="noopener">optimize</a> 函数（src/compiler/optimizer.js）主要功能就是标记静态节点，为后面 patch 过程中对比新旧 VNode 树形结构做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</p>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js%23L22-L47" target="_blank" rel="noopener">generate</a> 函数（src/compiler/codegen/index.js）主要功能就是根据 AST 结构拼接生成 render 函数的字符串。</p>
<pre><code>const code = AST ? genElement(AST) : &apos;_c(&quot;div&quot;)&apos; 
staticRenderFns = prevStaticRenderFns
onceCount = prevOnceCount
return {
    render: `with(this){return ${code}}`, //最外层包一个 with(this) 之后返回
    staticRenderFns: currentStaticRenderFns
}
</code></pre><p>其中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js%23L49-L83" target="_blank" rel="noopener">genElement</a> 函数（src/compiler/codegen/index.js）是会根据 AST 的属性调用不同的方法生成字符串返回。</p>
<pre><code>function genElement (el: ASTElement): string {
  if (el.staticRoot &amp;&amp; !el.staticProcessed) {
    return genStatic(el)
  } else if (el.once &amp;&amp; !el.onceProcessed) {
    return genOnce(el)
  } else if (el.for &amp;&amp; !el.forProcessed) {
    return genFor(el)
  } else if (el.if &amp;&amp; !el.ifProcessed) {
    return genIf(el)
  } else if (el.tag === &apos;template&apos; &amp;&amp; !el.slotTarget) {
    return genChildren(el) || &apos;void 0&apos;
  } else if (el.tag === &apos;slot&apos;) {
  }
    return code
  }
}
</code></pre><p>以上就是 compile 函数中三个核心步骤的介绍，compile 之后我们得到了 render 函数 的字符串形式，后面通过 new Function 得到真正的渲染函数。数据发现变化后，会执行 Watcher 中的 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/instance/lifecycle.js%23L77-L114" target="_blank" rel="noopener">_update</a> 函数（src/core/instance/lifecycle.js），_update 函数会执行这个渲染函数，输出一个新的 VNode 树形结构的数据。然后在调用 patch 函数，拿这个新的 VNode 与旧的 VNode 进行对比，只有发生了变化的节点才会被更新到真实 DOM 树上。</p>
<p>patch</p>
<p>patch.js 就是新旧 VNode 对比的 diff 函数，主要是为了优化dom，通过算法使操作dom的行为降到最低，diff 算法来源于 snabbdom，是 VDOM 思想的核心。snabbdom 的算法为了 DOM 操作跨层级增删节点较少的这一目标进行优化，它只会在同层级进行, 不会跨层级比较。</p>
<p>想更加深入VNode diff算法原理的，可以观看（<a href="https://link.zhihu.com/?target=https%3A//github.com/aooy/blog/issues/2" target="_blank" rel="noopener">解析vue2.0的diff算法</a>）</p>
<p>总结</p>
<ul>
<li>compile 函数主要是将 template 转换为 AST，优化 AST，再将 AST 转换为 render函数；</li>
<li>render函数 与数据通过 Watcher 产生关联；</li>
<li>在数据发生变化时调用 patch 函数，执行此 render 函数，生成新 VNode，与旧 VNode 进行 diff，最终更新 DOM 树。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">88</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


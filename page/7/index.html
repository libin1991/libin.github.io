<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/01/NPM学习笔记整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/01/NPM学习笔记整理/" itemprop="url">NPM学习笔记整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-01T18:35:10+08:00">
                2018-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="10个-NPM-使用技巧"><a href="#10个-NPM-使用技巧" class="headerlink" title="10个 NPM 使用技巧"></a><a href="https://github.com/dwqs/blog/issues/40" target="_blank" rel="noopener">10个 NPM 使用技巧</a></h1><h1 id="NPM-学习笔记整理"><a href="#NPM-学习笔记整理" class="headerlink" title="NPM 学习笔记整理"></a><a href="https://blog.ihoey.com/posts/Node/2017-05-10-npm.html" target="_blank" rel="noopener">NPM 学习笔记整理</a></h1><hr>
<h1 id="什么是-NPM什么是-NPM"><a href="#什么是-NPM什么是-NPM" class="headerlink" title="什么是-NPM什么是 NPM"></a><a href="#什么是-NPM">什么是-NPM</a>什么是 NPM</h1><p><code>npm</code> 之于 <code>Node</code> ，就像 <code>pip</code> 之于 <code>Python</code> , <code>gem</code> 之于 <code>Ruby</code> , <code>composer</code> 之于 <code>PHP</code> 。</p>
<p><code>npm</code> 是 <code>Node</code> 官方提供的包管理工具，他已经成了 <code>Node</code> 包的标准发布平台，用于 <code>Node</code> 包的发布、传播、依赖控制。<br><code>npm</code> 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p>
<h1 id="为什么要使用-NPM为什么要使用-NPM"><a href="#为什么要使用-NPM为什么要使用-NPM" class="headerlink" title="为什么要使用-NPM为什么要使用 NPM"></a><a href="#为什么要使用-NPM">为什么要使用-NPM</a>为什么要使用 NPM</h1><p><code>npm</code> 是随同 <code>Node</code> 一起安装的包管理工具，能解决 <code>Node</code> 代码部署上的很多问题，常见的场景有以下几种：</p>
<ul>
<li>允许用户从 <code>npm</code> 服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从 <code>npm</code> 服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到 <code>npm</code> 服务器供别人使用。</li>
</ul>
<p><code>npm</code> 的背后，是基于 <code>CouchDB</code> 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。</p>
<h1 id="如何使用-NPM如何使用-NPM"><a href="#如何使用-NPM如何使用-NPM" class="headerlink" title="如何使用-NPM如何使用 NPM"></a><a href="#如何使用-NPM">如何使用-NPM</a>如何使用 NPM</h1><h2 id="安装安装"><a href="#安装安装" class="headerlink" title="安装安装"></a><a href="#安装">安装</a>安装</h2><p><code>npm</code> 不需要单独安装。在安装 <code>Node</code> 的时候，会连带一起安装 <code>npm</code> 。但是，<code>Node</code> 附带的 <code>npm</code> 可能不是最新版本，最后用下面的命令，更新到最新版本。</p>
<pre><code>$ sudo npm install npm@latest -g
</code></pre><p>如果是 Window 系统使用以下命令即可：</p>
<pre><code>npm install npm -g
</code></pre><p>也就是使用 <code>npm</code> 安装自己。之所以可以这样，是因为 <code>npm</code> 本身与 <code>Node</code> 的其他模块没有区别。</p>
<p>然后，运行下面的命令，查看各种信息。</p>
<pre><code># 查看 npm 命令列表
$ npm help

# 查看各个命令的简单用法
$ npm -l

# 查看 npm 的版本
$ npm -v

# 查看 npm 的配置
$ npm config list -l
</code></pre><h2 id="使用使用"><a href="#使用使用" class="headerlink" title="使用使用"></a><a href="#使用">使用</a>使用</h2><h3 id="npm-initnpm-init"><a href="#npm-initnpm-init" class="headerlink" title="npm-initnpm init"></a><a href="#npm-init">npm-init</a>npm init</h3><p><code>npm init</code> 用来初始化生成一个新的 <code>package.json</code> 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。<br>如果使用了 <code>-f</code>（代表<code>force</code>）、<code>-y</code>（代表<code>yes</code>），则跳过提问阶段，直接生成一个新的 <code>package.json</code> 文件。</p>
<pre><code>$ npm init -y
</code></pre><h3 id="npm-setnpm-set"><a href="#npm-setnpm-set" class="headerlink" title="npm-setnpm set"></a><a href="#npm-set">npm-set</a>npm set</h3><p><code>npm set</code> 用来设置环境变量</p>
<pre><code>$ npm set init-author-name &apos;Your name&apos;
$ npm set init-author-email &apos;Your email&apos;
$ npm set init-author-url &apos;http://yourdomain.com&apos;
$ npm set init-license &apos;MIT&apos;
</code></pre><p>上面命令等于为 <code>npm init</code> 设置了默认值，以后执行 <code>npm init</code> 的时候，<code>package.json</code>的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 <code>~/.npmrc</code>文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 <code>npm config</code>。</p>
<h3 id="npm-infonpm-info"><a href="#npm-infonpm-info" class="headerlink" title="npm-infonpm info"></a><a href="#npm-info">npm-info</a>npm info</h3><p><code>npm info</code> 命令可以查看每个模块的具体信息。比如，查看 <code>underscore</code> 模块的信息。</p>
<pre><code>$ npm info underscore
</code></pre><p>上面命令返回一个 <code>JavaScript</code> 对象，包含了 <code>underscore</code> 模块的详细信息。这个对象的每个成员，都可以直接从 <code>info</code> 命令查询。</p>
<pre><code>$ npm info underscore description

$ npm info underscore homepage

$ npm info underscore version
</code></pre><h3 id="npm-searchnpm-search"><a href="#npm-searchnpm-search" class="headerlink" title="npm-searchnpm search"></a><a href="#npm-search">npm-search</a>npm search</h3><p><code>npm search</code> 命令用于搜索 <code>npm</code> 仓库，它后面可以跟字符串，也可以跟正则表达式。</p>
<pre><code>$ npm search &lt;搜索词&gt;
</code></pre><h3 id="npm-listnpm-list"><a href="#npm-listnpm-list" class="headerlink" title="npm-listnpm list"></a><a href="#npm-list">npm-list</a>npm list</h3><p><code>npm list</code> 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。</p>
<pre><code>$ npm list

# 加上 global 参数，会列出全局安装的模块
$ npm list -global

# npm list 命令也可以列出单个模块
$ npm list underscore
</code></pre><h3 id="npm-installnpm-install"><a href="#npm-installnpm-install" class="headerlink" title="npm-installnpm install"></a><a href="#npm-install">npm-install</a>npm install</h3><p>使用 <code>npm</code> 安装包的命令格式为：<code>npm [install/i] [package_name]</code></p>
<h4 id="本地模式和全局模式本地模式和全局模式"><a href="#本地模式和全局模式本地模式和全局模式" class="headerlink" title="本地模式和全局模式本地模式和全局模式"></a><a href="#本地模式和全局模式">本地模式和全局模式</a>本地模式和全局模式</h4><p><code>npm</code> 在默认情况下会从 <a href="http://npmjs.org" target="_blank" rel="noopener">NPM</a> 搜索或下载包，将包安装到当前目录的 <code>node_modules</code> 子目录下。</p>
<p>如果你熟悉 <code>Ruby</code> 的 <code>gem</code> 或者 <code>Python</code> 的 <code>pip</code> ，你会发现 <code>npm</code> 与它们的行为不同， <code>gem</code> 或 <code>pip</code> 总是以全局模式安装，使包可以供所有的程序使用，而 <code>npm</code> 默认会把包安装到当前目录下。这反映了 <code>npm</code> 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 <code>API</code> 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p>
<p>我们在使用 <code>supervisor</code> 的时候使用了 <code>npm install -g supervisor</code> 命令，就是以全局模式安装 <code>supervisor</code> 。</p>
<p>这里注意一点的就是， <code>supervisor</code> 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 <code>npm config set prefix &quot;路径&quot;</code> 安装完以后就可以用 <code>supervisor</code> 来启动服务了。<br><code>supervisor</code> 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 <code>Node</code> 。</p>
<p>一般来说，全局安装只适用于工具模块，比如 <code>eslint</code> 和 <code>gulp</code> 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为 <strong>本地模式不会注册 <code>PATH</code> 环境变量</strong>。<br>“本地安装”指的是将一个模块下载到当前项目的 <code>node_modules</code> 子目录，然后只有在项目目录之中，才能调用这个模块。</p>
<p>本地模式和全局模式的特点如下：<br>模式可通过 require 使用注册 PATH本地模式是否全局模式否是</p>
<pre><code># 本地安装
$ npm install &lt;package name&gt;

# 全局安装
$ sudo npm install -global &lt;package name&gt;
$ sudo npm install -g &lt;package name&gt;
</code></pre><p><code>npm install</code> 也支持直接输入 <code>Github</code> 代码库地址。</p>
<pre><code>$ npm install git://github.com/package/path.git
$ npm install git://github.com/package/path.git#0.1.0
</code></pre><p>安装之前，<code>npm install</code> 会先检查，<code>node_modules</code> 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p>
<p>如果你希望，一个模块不管是否安装过， <code>npm</code> 都要强制重新安装，可以使用 <code>-f</code> 或 <code>--force</code> 参数。</p>
<pre><code>$ npm install &lt;packageName&gt; --force
</code></pre><h4 id="安装不同版本安装不同版本"><a href="#安装不同版本安装不同版本" class="headerlink" title="安装不同版本安装不同版本"></a><a href="#安装不同版本">安装不同版本</a>安装不同版本</h4><p><code>install</code> 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 <code>@</code> 和版本号。</p>
<pre><code>$ npm install sax@latest
$ npm install sax@0.1.1
$ npm install sax@&quot;&gt;=0.1.0 &lt;0.2.0&quot;
</code></pre><p><code>install</code> 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 <code>packages.json</code> 文件的哪一项中。</p>
<blockquote>
<p>–save：模块名将被添加到 dependencies，可以简化为参数-S。<br>–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。</p>
</blockquote>
<pre><code>$ npm install sax --save
$ npm install node-tap --save-dev
# 或者
$ npm install sax -S
$ npm install node-tap -D
</code></pre><h5 id="dependencies-依赖dependencies-依赖"><a href="#dependencies-依赖dependencies-依赖" class="headerlink" title="dependencies-依赖dependencies 依赖"></a><a href="#dependencies-依赖">dependencies-依赖</a>dependencies 依赖</h5><p>这个可以说是我们 <code>npm</code> 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 <code>js</code> 模块包。下面这段代码表示我们依赖了 <code>markdown-it</code> 这个包，版本是 <code>^8.1.0</code> ，代表最小依赖版本是 <code>8.1.0</code> ，如果这个包有更新，那么当我们使用 <code>npm install</code> 命令的时候， <code>npm</code> 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。</p>
<pre><code>&quot;dependencies&quot;: {
&quot;markdown-it&quot;: &quot;^8.1.0&quot;
}
</code></pre><h5 id="devDependencies-开发依赖devDependencies-开发依赖"><a href="#devDependencies-开发依赖devDependencies-开发依赖" class="headerlink" title="devDependencies-开发依赖devDependencies 开发依赖"></a><a href="#devDependencies-开发依赖">devDependencies-开发依赖</a>devDependencies 开发依赖</h5><p>在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 <code>devDependencies</code> 的包，在别人引用的时候不会被 <code>npm</code> 下载。</p>
<pre><code>&quot;devDependencies&quot;: {
&quot;autoprefixer&quot;: &quot;^6.4.0&quot;,
&quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;,
&quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;,
&quot;babel-register&quot;: &quot;^6.0.0&quot;,
&quot;webpack&quot;: &quot;^1.13.2&quot;,
&quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;,
&quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot;,
&quot;webpack-merge&quot;: &quot;^0.14.1&quot;,
&quot;highlightjs&quot;: &quot;^9.8.0&quot;
}
</code></pre><p>当你有了一个完整的 <code>package.json</code>文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 <code>npm install</code> 就可以很方便的下载好这个模块所需要的包。</p>
<p><code>npm install</code> 默认会安装 <code>dependencies</code> 字段和 <code>devDependencies</code> 字段中的所有模块，如果使用 <code>--production</code> 参数，可以只安装 <code>dependencies</code> 字段的模块。</p>
<pre><code>$ npm install --production
# 或者
$ NODE_ENV=production npm install
</code></pre><p>一旦安装了某个模块，就可以在代码中用 <code>require</code> 命令加载这个模块。</p>
<pre><code>var backbone = require(&apos;backbone&apos;)
console.log(backbone.VERSION)
</code></pre><h3 id="npm-runnpm-run"><a href="#npm-runnpm-run" class="headerlink" title="npm-runnpm run"></a><a href="#npm-run">npm-run</a>npm run</h3><p><code>npm</code> 不仅可以用于模块管理，还可以用于执行脚本。<code>package.json</code> 文件有一个 <code>scripts</code> 字段，可以用于指定脚本命令，供 <code>npm</code> 直接调用。<br><code>package.json</code> 文件内容：</p>
<pre><code>{
&quot;name&quot;: &quot;myproject&quot;,
&quot;devDependencies&quot;: {
&quot;jshint&quot;: &quot;latest&quot;,
&quot;browserify&quot;: &quot;latest&quot;,
&quot;mocha&quot;: &quot;latest&quot;
  },
&quot;scripts&quot;: {
&quot;lint&quot;: &quot;jshint **.js&quot;,
&quot;test&quot;: &quot;mocha test/&quot;
  }
}
</code></pre><h4 id="scripts-脚本scripts-脚本"><a href="#scripts-脚本scripts-脚本" class="headerlink" title="scripts-脚本scripts 脚本"></a><a href="#scripts-脚本">scripts-脚本</a>scripts 脚本</h4><p>顾名思义，就是一些脚本代码，可以通过 <code>npm run script-key</code> 来调用，例如在这个 <code>package.json</code> 的文件夹下使用 <code>npm run dev</code> 就相当于运行了 <code>node build/dev-server.js</code> 这一段代码。使用 <code>scripts</code> 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。<br><code>npm run</code> 是 <code>npm run-script</code> 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。</p>
<pre><code>// 脚本
&quot;scripts&quot;: {
&quot;dev&quot;: &quot;node build/dev-server.js&quot;,
&quot;build&quot;: &quot;node build/build.js&quot;,
&quot;docs&quot;: &quot;node build/docs.js&quot;,
&quot;build-docs&quot;: &quot;npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m &apos;auto-pages&apos; &amp; git push &amp; git checkout master&quot;,
&quot;build-publish&quot;: &quot;rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push&quot;,
&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;
}
</code></pre><p><code>npm run</code> 如果不加任何参数，直接运行，会列出 <code>package.json</code> 里面所有可以执行的脚本命令。<br><code>npm</code> 内置了两个命令简写， <code>npm test</code> 等同于执行 <code>npm run test</code> ，<code>npm start</code> 等同于执行 <code>npm run start</code>。</p>
<pre><code>&quot;build&quot;: &quot;npm run build-js &amp;&amp; npm run build-css&quot;
</code></pre><p>上面的写法是先运行 <code>npm run build-js</code> ，然后再运行 <code>npm run build-css</code> ，两个命令中间用 <code>&amp;&amp;</code> 连接。如果希望两个命令同时平行执行，它们中间可以用 <code>&amp;</code> 连接。</p>
<p>写在 <code>scripts</code> 属性中的命令，也可以在 <code>node_modules/.bin</code> 目录中直接写成 <code>bash</code> 脚本。下面是一个 <code>bash</code> 脚本。</p>
<pre><code>#!/bin/bash

cd site/main
browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js
</code></pre><p>假定上面的脚本文件名为 <code>build.sh</code> ，并且权限为可执行，就可以在 <code>scripts</code> 属性中引用该文件。</p>
<pre><code>&quot;build-js&quot;: &quot;bin/build.sh&quot;
</code></pre><h3 id="pre-和-post-脚本pre-和-post-脚本"><a href="#pre-和-post-脚本pre-和-post-脚本" class="headerlink" title="pre-和-post-脚本pre- 和 post- 脚本"></a><a href="#pre-和-post-脚本">pre-和-post-脚本</a>pre- 和 post- 脚本</h3><p><code>npm run</code> 为每条命令提供了 <code>pre-</code> 和 <code>post-</code> 两个钩子（ <code>hook</code> ）。以 <code>npm run lint</code> 为例，执行这条命令之前， <code>npm</code> 会先查看有没有定义 <code>prelint</code> 和 <code>postlint</code> 两个钩子，如果有的话，就会先执行 <code>npm run prelint</code> ，然后执行 <code>npm run lint</code> ，最后执行 <code>npm run postlint</code> 。</p>
<pre><code>{
&quot;name&quot;: &quot;myproject&quot;,
&quot;devDependencies&quot;: {
&quot;eslint&quot;: &quot;latest&quot;
&quot;karma&quot;: &quot;latest&quot;
  },
&quot;scripts&quot;: {
&quot;lint&quot;: &quot;eslint --cache --ext .js --ext .jsx src&quot;,
&quot;test&quot;: &quot;karma start --log-leve=error karma.config.js --single-run=true&quot;,
&quot;pretest&quot;: &quot;npm run lint&quot;,
&quot;posttest&quot;: &quot;echo &apos;Finished running tests&apos;&quot;
  }
}
</code></pre><p>上面代码是一个 <code>package.json</code> 文件的例子。如果执行 <code>npm test</code>，会按下面的顺序执行相应的命令。</p>
<ol>
<li><code>pretest</code></li>
<li><code>test</code></li>
<li><code>posttest</code></li>
</ol>
<p>如果执行过程出错，就不会执行排在后面的脚本，即如果 <code>prelint</code> 脚本执行出错，就不会接着执行 <code>lint</code> 和 <code>postlint</code> 脚本。</p>
<h3 id="npm-binnpm-bin"><a href="#npm-binnpm-bin" class="headerlink" title="npm-binnpm bin"></a><a href="#npm-bin">npm-bin</a>npm bin</h3><p><code>npm bin</code> 命令显示相对于当前目录的，<code>Node</code> 模块的可执行脚本所在的目录（即 <code>.bin</code> 目录）。</p>
<pre><code># 项目根目录下执行
$ npm bin
./node_modules/.bin
</code></pre><h1 id="创建全局链接创建全局链接"><a href="#创建全局链接创建全局链接" class="headerlink" title="创建全局链接创建全局链接"></a><a href="#创建全局链接">创建全局链接</a>创建全局链接</h1><p><code>npm</code> 提供了一个有趣的命令 <code>npm link</code>，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 <code>require</code> 使用。但通过 <code>npm link</code> 命令可以打破这一限制。举个例子，我们已经通过 <code>npm install -g express</code> 安装了 <code>express</code> ，这时在工程的目录下运行命令：<code>npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express</code><br>我们可以在 <code>node_modules</code> 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。<br>除了将全局的包链接到本地以外，使用 <code>npm link</code> 命令还可以将本地的包链接到全局。使用方法是在包目录（<code>package.json</code> 所在目录）中运行 <code>npm link</code> 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。</p>
<h1 id="创建包创建包"><a href="#创建包创建包" class="headerlink" title="创建包创建包"></a><a href="#创建包">创建包</a>创建包</h1><p>包是在模块基础上更深一步的抽象，<code>Node</code> 的包类似于 <code>C/C++</code> 的函数库或者 <code>Java</code> 、<code>.Net</code> 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。<code>Node</code> 根据 <code>CommonJS</code> 规范实现了包机制，开发了 <code>npm</code> 来解决包的发布和获取需求。<br><code>Node</code> 的包是一个目录，其中包含了一个 <code>JSON</code> 格式的包说明文件 <code>package.json</code>。严格符合 <code>CommonJS</code> 规范的包应该具备以下特征：</p>
<ul>
<li><code>package.json</code> 必须在包的顶层目录下；</li>
<li>二进制文件应该在 <code>bin</code> 目录下；</li>
<li><code>JavaScript</code> 代码应该在 <code>lib</code> 目录下；</li>
<li>文档应该在 <code>doc</code> 目录下；</li>
<li>单元测试应该在 <code>test</code> 目录下。</li>
</ul>
<p><code>Node</code> 对包的要求并没有这么严格，只要顶层目录下有 <code>package.json</code>，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 <code>CommonJS</code> 规范。</p>
<p>我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 <code>package.json</code>，我们可以创建更复杂，更完善，更符合规范的包用于发布。</p>
<p><code>Node</code> 在调用某个包时，会首先检查包中 <code>packgage.json</code> 文件的 <code>main</code> 字段，将其作为包的接口模块，如果 <code>package.json</code> 或 <code>main</code> 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p>
<p><code>package.json</code> 是 <code>CommonJS</code> 规定的用来描述包的文件，完全符合规范的 <code>package.json</code> 文件应该含有以下字段：<br>name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。<br>description: 包的简要说明。<br>version: 符合语义化版本识别规范的版本字符串。<br>keywords: 关键字数组，通常用于搜索。<br>maintainers: 维护者数组，每个元素要包含 <code>name</code> 、 <code>email</code>(可选)、 <code>web</code>(可选)字段。<br>contributors: 贡献者数组，格式与 <code>maintainers</code> 相同。包的作者应该是贡献者数组的第一个元素。<br>bugs: 提交 <code>bug</code> 的地址，可以是网址或者电子邮件地址。<br>licenses: 许可证数组，每个元素要包含 <code>type</code> （许可证的名称）和 url（链接到许可证文本的地址）字段。<br>repositories: 仓库托管地址数组，每个元素要包含 <code>type</code> （仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。<br>dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。</p>
<h1 id="包的发布包的发布"><a href="#包的发布包的发布" class="headerlink" title="包的发布包的发布"></a><a href="#包的发布">包的发布</a>包的发布</h1><p>通过使用 <code>npm init</code> 可以根据交互式回答产生一个符合标准的 <code>package.json</code>。创建一个 <code>index.js</code> 作为包的接口,一个简单的包就制作完成了。<br>在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 <code>npm adduser</code> 根据提示完成账号的创建<br>完成后可以使用 <code>npm whoami</code> 检测是否已经取得了账号。<br>接下来,在 <code>package.json</code> 所在目录下运行 <code>npm publish</code>，稍等片刻就可以完成发布了，打开浏览器，访问 <a href="http://search.npmjs.org/" target="_blank" rel="noopener">NPM搜索</a> 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 <code>npm install neveryumodule</code> 命令来安装它。<br>如果你的包将来有更新,只需要在 <code>package.json</code> 文件中修改 <code>version</code> 字段,然后重新使用 <code>npm publish</code>命令就行了。<br>如果你对已发布的包不满意，可以使用 <code>npm unpublish</code> 命令来取消发布。</p>
<p><em>需要说明的是： <code>json</code> 文件不能有注释</em></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package.json 好处</span><br><span class="line"> 1.以json文件格式定义项目所依赖的包；</span><br><span class="line"> 2.确定每个包的使用版本；</span><br><span class="line"> 3.项目构建可重复，多人协助公用一套基础代码；</span><br><span class="line"> 4.npm init 初始化 【必须含有的两个：name 和 version】</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;react-redux-webpack&quot;,</span><br><span class="line">     &quot;version&quot;: &quot;1.1.0&quot;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">devDependencies    ：开发环境和测试环境所依赖的包列表</span><br><span class="line">dependencies       ：在生产环境使用的依赖包列表</span><br><span class="line"></span><br><span class="line">    dependencies下记录的是项目在运行时必须依赖的插件，常见的例如react jquery等，即及时项目打包好了、上线了，</span><br><span class="line">   这些也是需要用的，否则程序无法正常执行。</span><br><span class="line">    devDependencies下记录的是项目在开发过程中使用的插件，例如这里我们开发过程中需要使用webpack打包，</span><br><span class="line">    而我在工作中使用fis3打包，但是一旦项目打包发布、上线了之后，webpack和fis3就都没有用了，可卸磨杀驴。</span><br><span class="line"></span><br><span class="line">本地安装 npm install --save|--save-dev 分别写入  dependencies|devDependencies 中；</span><br><span class="line">简写：     npm i -S pkg      |  npm i -D pkg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">包（package)和模块（module）</span><br><span class="line">包：package.json 文件所描述的文件夹或者文件，符合CommonJS规范</span><br><span class="line">模块：任何被node.js中的require所载入的文件</span><br><span class="line"></span><br><span class="line">~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0</span><br><span class="line">^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0</span><br><span class="line">* 这意味着安装最新版本的依赖包</span><br><span class="line"></span><br><span class="line">常用命令:</span><br><span class="line">    npm init -y    //强制生成</span><br><span class="line">	npm init //在项目中引导创建一个package.json文件</span><br><span class="line">	npm search mkdir   //寻找包使用npm search命令</span><br><span class="line">	npm help //查看某条命令的详细帮助 </span><br><span class="line">	npm root //查看包的安装路径</span><br><span class="line">	npm config //管理npm的配置路径</span><br><span class="line">	npm prefix -g   //查看全局安装的包位置  -g全局</span><br><span class="line">	npm cache  //管理模块的缓存 ,可以使用下面命令，偶尔清楚一下缓存：      eg: npm cache clean</span><br><span class="line">	npm info webpack   //查看webpack 版本信息</span><br><span class="line">	npm install pkg //安装模块 简写：npm i pkg   ,带版本:  npm install underscore@1.8.2</span><br><span class="line">	npm uninstall //卸载模块   eg: npm uninstall webpack</span><br><span class="line">	npm update   // 更新模块   npm update underscore</span><br><span class="line">	npm outdated  //检查模块是否已经过时</span><br><span class="line">	npm ls   //查看安装的模块 </span><br><span class="line">	npm list  //可以查看全局路径下的所有包    eg:   npm list --global</span><br><span class="line">	          //也可以使用--depth=0来缩短返回的结果   eg:     npm list -g --depth=0</span><br><span class="line">	npm stop  //停止模块</span><br><span class="line">	npm restart  //重新启动模块</span><br><span class="line">	npm test //测试模块 </span><br><span class="line">	npm version //查看模块版本</span><br><span class="line">	npm publish //发布模块</span><br><span class="line"></span><br><span class="line">简写:</span><br><span class="line">	npm i – 安装包</span><br><span class="line">	npm i -g – 安装包到全局下</span><br><span class="line">	npm un – 删除本地下包</span><br><span class="line">	npm up – 更新包</span><br><span class="line">	npm t – 运行测试</span><br><span class="line">	npm ls – 罗列已经安装包</span><br><span class="line">	npm ll or npm la – 罗列包时显示额外信息</span><br><span class="line"></span><br><span class="line">    npm i express momemt lodash mongoose  webpack   //也可以一次安装多个包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    yarn cache clean   //删除电脑上所有 yarn 安装的缓存</span><br><span class="line">    yarn   //命令安装项目相关依赖</span><br><span class="line">    yarn cache dir //获取缓存文件夹地址</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/02/vue文件的一个小细节/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/vue文件的一个小细节/" itemprop="url">.vue文件的一个小细节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T23:06:11+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>top.vue</p>
<pre><code>&lt;template&gt;
    &lt;div class=&quot;ds&quot;&gt;
        &lt;div class=&quot;left&quot;&gt;
            &lt;p&gt;SX&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;right&quot;&gt;
            &lt;p&gt;SB&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    console.log(&quot;-------------------------&quot;);     //只执行一次


    export default {
        props: [],
        data() {
            return {}
        },
        components: {

        },
        methods: {

        },
        created() {

        },
        mounted() {
            console.log(&quot;$$$$$$$$$$$$$$$$$$$$$$$&quot;)；  //执行多次
        }
    };
&lt;/script&gt;

&lt;style lang=&quot;scss&quot; scoped=&quot;scoped&quot;&gt;
    .guize {
        box-sizing: border-box;
        padding: 0 0.4rem;
        margin-top: -0.3rem;
        width: 100%;
        height: 1.2rem;
        font-size: 0.24rem;
        color: white;
        position: relative;
        .left {
            color: #abc4ed;
            float: left;
            transform:scale(0.85);
            transform-origin:0 0; 
            p {
                font-size: 0.24rem;
                line-height: 2;
            }
        }
        .right {
            float: left;
            width: 1.6rem;
            height: 0.44rem;
            line-height: 0.44rem;
            border: 1px solid white;
            color: white;
            border-radius: 0.24rem;
            text-align: center;
            position: absolute;
            right: 0.4rem;
            bottom: 0.04rem;
        }
    }
&lt;/style&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-57add9333368254c8b108fdd00160585_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-57add9333368254c8b108fdd00160585_hd.jpg" alt=""><img src="https://pic4.zhimg.com/v2-2ac46bc7c3c82fdde73c1f53cf8e39d5_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-2ac46bc7c3c82fdde73c1f53cf8e39d5_hd.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/02/JS-继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/02/JS-继承/" itemprop="url">JS 继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-02T22:49:01+08:00">
                2018-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>众所周知，在 ES 6 之前没有类的概念，所以不能像 Java 中一个 extends 关键字就搞定了继承关系，需要一些 tricks 来实现，下面就介绍一些比较常用的方法。</p>
<h2 id="一-原型链继承："><a href="#一-原型链继承：" class="headerlink" title="(一) 原型链继承："></a>(一) 原型链继承：</h2><pre><code>function Parent(name) { 
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}
function Child(name) {
    this.name = name;
}

Child.prototype = new Parent(&apos;father&apos;);
Child.prototype.constructor = Child;

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

var child = new Child(&apos;son&apos;);
child.sayName();    // child name: son
</code></pre><p>只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。</p>
<p>这种方法存在两个缺点：</p>
<ol>
<li>子类型无法给超类型传递参数，在面向对象的继承中，我们总希望通过 var child = new Child(‘son’, ‘father’); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent(‘father’) 去调用父类。</li>
<li>Child.prototype.sayName 必须写在 Child.prototype = new Parent(‘father’); 之后，不然就会被覆盖掉。</li>
</ol>
<h2 id="二-类式继承："><a href="#二-类式继承：" class="headerlink" title="(二) 类式继承："></a>(二) 类式继承：</h2><pre><code>function Parent(name) { 
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}
Parent.prototype.doSomthing = function() {
    console.log(&apos;parent do something!&apos;);
}
function Child(name, parentName) {
    Parent.call(this, parentName);
    this.name = name;
}

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

var child = new Child(&apos;son&apos;);
child.sayName();      // child name: son
child.doSomthing();   // TypeError: child.doSomthing is not a function
</code></pre><p>相当于 Parent 这个函数在 Child 函数中执行了一遍，并且将所有与 this 绑定的变量都切换到了 Child 上，这样就克服了第一种方式带来的问题。</p>
<p>缺点：</p>
<ol>
<li>没有原型，每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。</li>
</ol>
<h2 id="三-组合式继承：前两种方式的结合"><a href="#三-组合式继承：前两种方式的结合" class="headerlink" title="(三) 组合式继承：前两种方式的结合"></a>(三) 组合式继承：前两种方式的结合</h2><pre><code>function Parent(name) { 
    this.name = name;
}

Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}
Parent.prototype.doSomething = function() {
    console.log(&apos;parent do something!&apos;);
}
function Child(name, parentName) {
    Parent.call(this, parentName);
    this.name = name;
}

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

Child.prototype = new Parent();      
Child.prototype.construtor = Child;

var child = new Child(&apos;son&apos;);
child.sayName();       // child name: son
child.doSomething();   // parent do something!
</code></pre><p>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p>
<p>这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p>
<p>组合式继承是 JS 最常用的继承模式，但组合继承使用过程中会被调用两次：一次是创建子类型的时候，另一次是在子类型构造函数的内部。</p>
<pre><code>function Parent(name) { 
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}
Parent.prototype.doSomething = function() {
    console.log(&apos;parent do something!&apos;);
}
function Child(name, parentName) {
    Parent.call(this, parentName);      // 第二次调用
    this.name = name;
}

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

Child.prototype = new Parent();         // 第一次调用
Child.prototype.construtor = Child;

var child = new Child(&apos;son&apos;);
child.sayName();      
child.doSomething();   
</code></pre><p>显然从上述的代码中可以看出，第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了，所以这时候你可能会这样写：</p>
<pre><code>Child.prototype = Parent.prototype;
</code></pre><p>这样写显然是不对的：</p>
<ol>
<li>首先，你这样写的话相当于是子类和父类都指向同一个对象，这时候如果你添加了新的方法给 Child 但实际上 Parent 并不需要，相当于强行给 Parent 添加了一个未知的方法。</li>
<li>其次，仔细想想，这样体现不出继承的多态性，比如此时子类想要重写父类的 getName 的方法，那么父类的方法也就会随之修改，这显然违背了多态性。</li>
</ol>
<p>也就是说我们第一次调用构造函数的时候，其实是不管构造函数里面的内容，所以我们何不 new 一个空函数，将其 prototype 指向 Parent.prototype，代码如下：</p>
<h2 id="四-寄生组合式继承："><a href="#四-寄生组合式继承：" class="headerlink" title="(四) 寄生组合式继承："></a>(四) 寄生组合式继承：</h2><pre><code>function Parent(name) {
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}

function Child(name, parentName) {
    Parent.call(this, parentName);  
    this.name = name;    
}

function create(proto) {
    function F(){}
    F.prototype = proto;
    F.prototype.construtor = F;
    return new F();
}

Child.prototype = create(Parent.prototype);
Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}
Child.prototype.construtor = Child;

var parent = new Parent(&apos;father&apos;);
parent.sayName();    // parent name: father


var child = new Child(&apos;son&apos;, &apos;father&apos;);
child.sayName();     // child name: son
</code></pre><p>这就是所谓的寄生组合式继承方式，跟组合式继承的区别在于，他不需要在一次实例中调用两次父类的构造函数，假如说父类的构造器代码很多，还需要调用两次的话对系统肯定会有影响，寄生组合式继承的思想在于：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</p>
<p>在上面的代码中，我们手动创建了一个 create 函数，但是其实是存在于 Object 对象中，不需要我们手动去创建，所以上面的代码可以改为：</p>
<pre><code>function Parent(name) {
    this.name = name;
}
Parent.prototype.sayName = function() {
    console.log(&apos;parent name:&apos;, this.name);
}

function Child(name, parentName) {
    Parent.call(this, parentName);  
    this.name = name;    
}

function inheritPrototype(Parent, Child) {
    Child.prototype = Object.create(Parent.prototype);   //修改
    Child.prototype.construtor = Child;
}

inheritPrototype(Parent, Child);

Child.prototype.sayName = function() {
    console.log(&apos;child name:&apos;, this.name);
}

var parent = new Parent(&apos;father&apos;);
parent.sayName();      // parent name: father

var child = new Child(&apos;son&apos;, &apos;father&apos;);
child.sayName();       // child name: son
</code></pre><h2 id="五-ES-6-继承："><a href="#五-ES-6-继承：" class="headerlink" title="(五) ES 6 继承："></a>(五) ES 6 继承：</h2><p>当然，如果你学习过 ES 6，那么写继承关系就会特别简单，如果你学过 Java 就会发现，ES 6 中的继承跟 Java 太像了，上述的代码可改为：</p>
<pre><code>class Parent {
    constructor(name) {
    this.name = name;
    }
    doSomething() {
    console.log(&apos;parent do something!&apos;);
    }
    sayName() {
    console.log(&apos;parent name:&apos;, this.name);
    }
}

class Child extends Parent {
    constructor(name, parentName) {
    super(parentName);
    this.name = name;
    }
    sayName() {
     console.log(&apos;child name:&apos;, this.name);
    }
}

const child = new Child(&apos;son&apos;, &apos;father&apos;);
child.sayName();            // child name: son
child.doSomething();        // parent do something!

const parent = new Parent(&apos;father&apos;);
parent.sayName();           // parent name: father
</code></pre><p>JavaScript前端开发</p>
<p>JavaScript(ES5)中没有像Java那样类的概念，写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。但是我们可以通过原型链prototype来模拟类，去实现继承的相关功能。下面来看看ES5中实现继承常见的三种方法。代码如下：</p>
<pre><code>/**
 * JavaScript(ES5)中实现继承的几种方法
 */

// 定义基类Person
function Person(name, age) {
  this.name = name;
  this.age = age;
}

// 共享数据
Person.prototype.LEGS_NUM = 2;

// 共享方法
Person.prototype.info = function () {
  console.log(&apos;My name is &apos; + this.name + &apos; .I\&apos;m &apos; + this.age + &apos; years old now&apos;);
};

Person.prototype.walk = function () {
  console.log(this.name + &apos; is walking...&apos;);
};

// Student子类
function Student(name, age, className) {
  // 调用父类
  Person.call(this, name, age);
  this.className = className;
}

// 1⃣️ 方法一：Person.prototype直接赋值给Student.prototype
// Student.prototype = Person.prototype;

// 2⃣️ 方法二：Student.prototype为Person的实例
// Student.prototype = new Person();

// 3⃣️ 方法三：创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype
Student.prototype = Object.create(Person.prototype);

Student.prototype.constructor = Student;

// 覆盖父类的info方法
Student.prototype.info = function () {
  console.log(&apos;My name is &apos; + this.name + &apos;,I\&apos;m &apos; + this.age + &apos; years old now, and from class &apos; + this.className + &apos;.&apos;);
};

// Student类的共享方法
Student.prototype.learn = function (subject) {
  console.log(this.name + &apos; is learning &apos; + subject + &apos;.&apos;);
};

// 测试,创建一个Student的实例
var microzz = new Student(&apos;Microzz&apos;, 22, 5);
microzz.info(); // My name is Microzz,I&apos;m 22 years old now, and from class 5.
console.log(microzz.LEGS_NUM); // 2
microzz.walk(); // Microzz is walking...
microzz.learn(&apos;JavaScript&apos;); // Microzz is learning JavaScript.
console.log(microzz.__proto__.__proto__ === Person.prototype); // true
console.log(microzz.__proto__ === Student.prototype); // true
console.log(microzz.__proto__.constructor === Student); // true
</code></pre><p>三种方法比较</p>
<p>上面代码中有三种方法实现继承，现在我们可以来分析一下这几种方法。<br>1⃣️这种方法中，Person.prototype直接赋值给Student.prototype，但是有一个很严重的问题，如果子类prototype添加新的东西的话也会改写父类。所以这种方法不推荐。<br>2⃣️第二种方法Student.prototype为Person的实例，这也是可以实现的。但是Person构造函数有参数应该传什么呢？传任何一个都是很奇怪的。所以也不推荐。<br>3⃣️第三种方法是比较理想的，创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype。但是Object.create也有一点小瑕疵，因为它是ES5之后才支持的，不过我们可以通过模拟实现Object.create方法。代码如下：</p>
<pre><code>if (!Object.create) {
  Object.prototype.create = function (proto) {
    function F() {}
    F.prototype = proto;
    return new F;
  }
}
</code></pre><p>这样在ES5中就完美实现了继承😄</p>
<h2 id="ES6中的实现"><a href="#ES6中的实现" class="headerlink" title="ES6中的实现"></a>ES6中的实现</h2><p>概述</p>
<p>ES6提供了更接近传统语言”类”的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。下面我们用ES6的语法实现类的继承。</p>
<p>代码</p>
<pre><code>// 基类 Person
class Person {
  // 父类的构造方法
  constructor(name, age) {
    this.name = name;
    this.age = age;
    // 共享变量
    this.LEGS_NUM = 2;
  }
  // 父类的info方法
  info() {
    console.log(`My name is ${this.name}, I\&apos;m ${this.age} years old now.`);
  }

  // 父类的walk方法
  walk() {
    console.log(this.name + &apos; is walking...&apos;);
  }

}

// 子类 Student
class Student extends Person {
  constructor(name, age, className) {
    // 调用基类的构造方法
    super(name, age);
    this.className = className;
  }

  // 覆盖父类的info方法
  info() {
    console.log(`My name is ${this.name}, I\&apos;m ${this.age} years old, and from class ${this.className}.`);
  }
}

// 实例化一个Student的实例
let stu = new Student(&apos;Zhaohui&apos;, 22, 5);
stu.info(); // My name is Zhaohui, I&apos;m 22 years old, and from class 5.
stu.walk(); // Zhaohui is walking...
console.log(stu.LEGS_NUM); // 2
console.log(stu instanceof Student); // true
console.log(stu instanceof Person); // true
</code></pre><p>这样我们就通过ES6中的class实现了“类”的继承了😄</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/Vue大数据渲染虚拟滚动列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/Vue大数据渲染虚拟滚动列表/" itemprop="url">Vue大数据渲染虚拟滚动列表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T22:59:12+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Github：<a href="https://link.zhihu.com/?target=https%3A//github.com/tangbc/vue-virtual-scroll-list" target="_blank" rel="noopener">tangbc/vue-virtual-scroll-list</a><br><img src="https://pic1.zhimg.com/v2-827fdf77d1a145a6d1d3d56f390a37ff_b.gif" alt=""></p>
<p><img src="https://pic1.zhimg.com/v2-827fdf77d1a145a6d1d3d56f390a37ff_b.jpg" alt=""></p>
<pre><code>;
(function(root, factory) {
    var namespace = &apos;VirtualScrollList&apos;
    if(typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;) {
        module.exports = factory(namespace, require(&apos;vue&apos;))
    } else if(typeof define === &apos;function&apos; &amp;&amp; define.amd) {
        define([&apos;vue&apos;], factory.bind(root, namespace))
    } else if(typeof exports === &apos;object&apos;) {
        exports[namespace] = factory(namespace, require(&apos;vue&apos;))
    } else {
        root[namespace] = factory(namespace, root[&apos;Vue&apos;])
    }
})(this, function(namespace, Vue2) {
    if(typeof Vue2 === &apos;object&apos; &amp;&amp; typeof Vue2.default === &apos;function&apos;) {
        Vue2 = Vue2.default
    }

    var _debounce = function(func, wait, immediate) {
        var timeout
        return function() {
            var context = this
            var args = arguments
            var later = function() {
                timeout = null
                if(!immediate) {
                    func.apply(context, args)
                }
            }
            var callNow = immediate &amp;&amp; !timeout
            clearTimeout(timeout)
            timeout = setTimeout(later, wait)
            if(callNow) {
                func.apply(context, args)
            }
        }
    }

    return Vue2.component(namespace, {
        props: {
            size: {
                type: Number,
                required: true
            },
            remain: {
                type: Number,
                required: true
            },
            rtag: {
                type: String,
                default: &apos;div&apos;
            },
            wtag: {
                type: String,
                default: &apos;p&apos;
            },
            wclass: {
                type: String,
                default: &apos;&apos;
            },
            start: {
                type: Number,
                default: 0
            },
            offset: {
                type: Number,
                default: 0
            },
            variable: [Function, Boolean],
            bench: Number,
            debounce: Number,
            totop: Function,
            tobottom: Function,
            onscroll: Function
        },

        data(){
            return {
                delta:{}
            }
        },

        created: function() {   // :size=&quot;60&quot; :remain=&quot;6&quot; :bench=&quot;44&quot; class=&quot;list&quot; :start=&quot;startIndex&quot;
            var start = this.start &gt;= this.remain ? this.start : 0
            var keeps = this.remain + (this.bench || this.remain)

            console.log(start)
            console.log(keeps)

            this.delta = {
                start: start, // start index.   //起始index
                end: start + keeps - 1, // end index.   //显示列表last index
                keeps: keeps, // nums keeping in real dom.      //要显示的列表数据
                total: 0, // all items count, update in filter.    //总的列表数据
                offsetAll: 0, // cache all the scrollable offset.
                paddingTop: 0, // container wrapper real padding-top.
                paddingBottom: 0, // container wrapper real padding-bottom.
                varCache: {}, // object to cache variable index height and scroll offset.
                varAverSize: 0, // average/estimate item height before variable be calculated.
                varLastCalcIndex: 0 // last calculated variable height/offset index, always increase.
            }


        },

        watch: {
            size: function() {
                this.alter = &apos;size&apos;
            },
            remain: function() {
                this.alter = &apos;remain&apos;
            },
            bench: function() {
                this.alter = &apos;bench&apos;
            },
            start: function() {
                this.alter = &apos;start&apos;
            },
            offset: function() {
                this.alter = &apos;offset&apos;
            }
        },

        methods: {
            onScroll: function(e) {
                var delta = this.delta
                var offset = this.$refs.vsl.scrollTop

                if(delta.total &gt; delta.keeps) {
                    this.updateZone(offset)
                } else {
                    delta.end = delta.total - 1
                }

                var offsetAll = delta.offsetAll
                if(this.onscroll) {
                    this.onscroll(e, {
                        offset: offset,
                        offsetAll: offsetAll,
                        start: delta.start,
                        end: delta.end
                    })
                }

                if(!offset &amp;&amp; delta.total) {
                    this.triggerEvent(&apos;totop&apos;)
                }

                if(offset &gt;= offsetAll) {
                    this.triggerEvent(&apos;tobottom&apos;)
                }
            },

            // update render zone by scroll offset.
            updateZone: function(offset) {
                var overs = this.variable ?
                    this.getVarOvers(offset) :
                    Math.floor(offset / this.size)

                var delta = this.delta
                var zone = this.getZone(overs)
                var bench = this.bench || this.remain

                // for better performance, if scroll pass items within now bench, do not update.
                if(!zone.isLast &amp;&amp; (overs &gt; delta.start) &amp;&amp; (overs - delta.start &lt;= bench)) {
                    return
                }

                delta.end = zone.end
                delta.start = zone.start
                this.$forceUpdate()
            },

            // return the scroll passed items count in variable.
            getVarOvers: function(offset) {
                var low = 0
                var middle = 0
                var middleOffset = 0
                var delta = this.delta
                var high = delta.total

                while(low &lt;= high) {
                    middle = low + Math.floor((high - low) / 2)
                    middleOffset = this.getVarOffset(middle)

                    // calculate the average variable height at first binary search.
                    if(!delta.varAverSize) {
                        delta.varAverSize = Math.floor(middleOffset / middle)
                    }

                    if(middleOffset === offset) {
                        return middle
                    } else if(middleOffset &lt; offset) {
                        low = middle + 1
                    } else if(middleOffset &gt; offset) {
                        high = middle - 1
                    }
                }

                return low &gt; 0 ? --low : 0
            },

            // return a variable scroll offset from given index.
            getVarOffset: function(index, nocache) {
                var delta = this.delta
                var cache = delta.varCache[index]

                if(!nocache &amp;&amp; cache) {
                    return cache.offset
                }

                var offset = 0
                for(var i = 0; i &lt; index; i++) {
                    var size = this.getVarSize(i, nocache)
                    delta.varCache[i] = {
                        size: size,
                        offset: offset
                    }
                    offset += size
                }

                delta.varLastCalcIndex = Math.max(delta.varLastCalcIndex, index - 1)
                delta.varLastCalcIndex = Math.min(delta.varLastCalcIndex, delta.total - 1)

                return offset
            },

            // return a variable size (height) from given index.
            getVarSize: function(index, nocache) {
                var cache = this.delta.varCache[index]
                if(!nocache &amp;&amp; cache) {
                    return cache.size
                }

                if(typeof this.variable === &apos;function&apos;) {
                    return this.variable(index) || 0
                } else {
                    var slot = this.$slots.default[index]
                    var style = slot &amp;&amp; slot.data &amp;&amp; slot.data.style
                    if(style &amp;&amp; style.height) {
                        var shm = style.height.match(/^(.*)px$/)
                        return(shm &amp;&amp; +shm[1]) || 0
                    }
                }
                return 0
            },

            // return the variable paddingTop base current zone.
            // @todo: if set a large `start` before variable was calculated,
            // here will also case too much offset calculate when list is very large,
            // consider use estimate paddingTop in this case just like `getVarPaddingBottom`.
            getVarPaddingTop: function() {
                return this.getVarOffset(this.delta.start)
            },

            // return the variable paddingBottom base current zone.
            getVarPaddingBottom: function() {
                var delta = this.delta
                var last = delta.total - 1
                if(delta.total - delta.end &lt;= delta.keeps || delta.varLastCalcIndex === last) {
                    return this.getVarOffset(last) - this.getVarOffset(delta.end)
                } else {
                    // if unreached last zone or uncalculate real behind offset
                    // return the estimate paddingBottom avoid too much calculate.
                    return(delta.total - delta.end) * (delta.varAverSize || this.size)
                }
            },

            // retun the variable all heights use to judge reach bottom.
            getVarAllHeight: function() {
                var delta = this.delta
                if(delta.total - delta.end &lt;= delta.keeps || delta.varLastCalcIndex === delta.total - 1) {
                    return this.getVarOffset(delta.total)
                } else {
                    return this.getVarOffset(delta.start) + (delta.total - delta.end) * (delta.varAverSize || this.size)
                }
            },

            // the ONLY ONE public method, allow the parent update variable by index.
            updateVariable: function(index) {
                // clear/update all the offfsets and heights ahead of index.
                this.getVarOffset(index, true)
            },

            // return the right zone info base on `start/index`.
            getZone: function(index) {
                var start, end
                var delta = this.delta

                index = parseInt(index, 10)
                index = Math.max(0, index)

                var lastStart = delta.total - delta.keeps
                var isLast = (index &lt;= delta.total &amp;&amp; index &gt;= lastStart) || (index &gt; delta.total)
                if(isLast) {
                    end = delta.total - 1
                    start = Math.max(0, lastStart)
                } else {
                    start = index
                    end = start + delta.keeps - 1
                }

                return {
                    end: end,
                    start: start,
                    isLast: isLast
                }
            },

            // trigger a props event on parent.
            triggerEvent: function(event) {
                if(this[event]) {
                    this[event]()
                }
            },

            // set manual scroll top.
            setScrollTop: function(scrollTop) {
                this.$refs.vsl.scrollTop = scrollTop
            },

            // filter the shown items base on `start` and `end`.
            filter: function() {
                var delta = this.delta
                var slots = this.$slots.default

                if(!slots) {
                    slots = []
                    delta.start = 0
                }

                delta.total = slots.length

                var paddingTop, paddingBottom, allHeight;


                var hasPadding = delta.total &gt; delta.keeps

                if(this.variable) {
                    allHeight = this.getVarAllHeight()
                    paddingTop = hasPadding ? this.getVarPaddingTop() : 0
                    paddingBottom = hasPadding ? this.getVarPaddingBottom() : 0
                } else {
                    allHeight = this.size * delta.total
                    paddingTop = this.size * (hasPadding ? delta.start : 0)
                    paddingBottom = this.size * (hasPadding ? delta.total - delta.keeps : 0) - paddingTop
                }

                delta.paddingTop = paddingTop
                delta.paddingBottom = paddingBottom
                delta.offsetAll = allHeight - this.size * this.remain  //总高度减去窗口的高度

                return slots.filter(function(slot, index) {
                    return index &gt;= delta.start &amp;&amp; index &lt;= delta.end
                })
            }
        },

        mounted: function() {
            if(this.start) {
                var start = this.getZone(this.start).start
                this.setScrollTop(this.variable ? this.getVarOffset(start) : start * this.size)
            } else if(this.offset) {
                this.setScrollTop(this.offset)
            }
        },

        // check if delta should update when prorps change.
        beforeUpdate: function() {
            var delta = this.delta
            delta.keeps = this.remain + (this.bench || this.remain)

            var calcstart = this.alter === &apos;start&apos; ? this.start : delta.start
            var zone = this.getZone(calcstart)

            // if start, size or offset change, update scroll position.
            if(~[&apos;start&apos;, &apos;size&apos;, &apos;offset&apos;].indexOf(this.alter)) {
                this.$nextTick(this.setScrollTop.bind(this, this.alter === &apos;offset&apos; ?
                    this.offset : this.variable ?
                    this.getVarOffset(zone.isLast ? delta.total : zone.start) :
                    zone.isLast ? delta.total * this.size : zone.start * this.size))
            }

            // if points out difference, force update once again.
            if(calcstart !== zone.start || delta.end !== zone.end || this.alter) {
                this.alter = &apos;&apos;
                delta.end = zone.end
                delta.start = zone.start
                this.$forceUpdate()
            }
        },

        render: function(h) {
            var list = this.filter()
            var delta = this.delta
            var dbc = this.debounce
            console.log(list)
            return h(this.rtag, {
                &apos;ref&apos;: &apos;vsl&apos;,
                &apos;style&apos;: {
                    &apos;display&apos;: &apos;block&apos;,
                    &apos;overflow-y&apos;: &apos;auto&apos;,
                    &apos;height&apos;: this.size * this.remain + &apos;px&apos;
                },
                &apos;on&apos;: {
                    &apos;scroll&apos;: dbc ? _debounce(this.onScroll.bind(this), dbc) : this.onScroll
                }
            }, [
                h(this.wtag, {
                    &apos;style&apos;: {
                        &apos;display&apos;: &apos;block&apos;,
                        &apos;padding-top&apos;: delta.paddingTop + &apos;px&apos;,
                        &apos;padding-bottom&apos;: delta.paddingBottom + &apos;px&apos;
                    },
                    &apos;class&apos;: this.wclass
                }, list)
            ])
        }
    })
})


&lt;template&gt;
    &lt;div class=&quot;appWraper&quot;&gt;
        &lt;div class=&quot;scrollToIndex&quot;&gt;
            &lt;span&gt;Scroll to index: &lt;/span&gt;
            &lt;input type=&quot;text&quot; v-model.number.lazy=&quot;startIndex&quot;&gt;
            &lt;small&gt;Change and blur to set start index.&lt;/small&gt;
        &lt;/div&gt;
        &lt;VirtualList :size=&quot;60&quot; :remain=&quot;6&quot; :bench=&quot;24&quot; class=&quot;list&quot; :start=&quot;startIndex&quot;&gt;
            &lt;Item v-for=&quot;(udf, index) of items&quot; :index=&quot;index&quot; :key=&quot;index&quot;&gt;&lt;/Item&gt;
        &lt;/VirtualList&gt;




        &lt;div class=&quot;source&quot;&gt;
            &lt;a href=&quot;https://github.com/tangbc/vue-virtual-scroll-list/blob/master/examples/finite/finite.vue#L1&quot;&gt;
                View this demo source code
            &lt;/a&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
    import Item from &apos;./item.vue&apos;
    import VirtualList from &apos;./VirtualScrollList.js&apos;

    export default {
        name: &apos;finite-test&apos;,

        components: {
            Item,
            VirtualList
        },

        data() {
            return {
                startIndex: 9,
                items: new Array(100)
            }
        }
    }
&lt;/script&gt;

&lt;style&gt;

    body {
        background: #fffaf0;
    }
    .appWraper {
        width: 440px;
        margin: 0 auto;
        overflow-y: auto;
    }
    .title {
        font-size: 25px;
        font-weight: 100;
        text-align: center;
    }
    @media (max-width: 640px) {
        .appWraper {
            width: 100%;
        }
        .title {
            font-size: 16px;
        }
    }





    .scrollToIndex {
        padding-bottom: 20px;
    }

    input {
        outline: none;
        padding: .4em .5em;
        width: 55px;
        height: 16px;
        border-radius: 3px;
        border: 1px solid;
        border-color: #dddddd;
        font-size: 16px;
        -webkit-appearance: none;
        -moz-appearance: none;
        appearance: none;
    }

    input:focus {
        border-color: #6495ed;
    }

    small {
        color: #999;
    }

    .list {
        background: #fff;
        border-radius: 3px;
        border: 1px solid #ddd;
        -webkit-overflow-scrolling: touch;
        overflow-scrolling: touch;
    }

    .source {
        text-align: center;
        padding-top: 20px;
    }

    .source a {
        color: #999;
        text-decoration: none;
        font-weight: 100;
    }

    @media (max-width: 640px) {
        small {
            display: none;
        }
    }
&lt;/style&gt;
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/20/promise的模拟实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/promise的模拟实现/" itemprop="url">promise的模拟实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-20T13:11:36+08:00">
                2017-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-什么是promise"><a href="#1-1-什么是promise" class="headerlink" title="1.1 什么是promise"></a>1.1 什么是promise</h2><p><code>Promise</code> 对象是 <code>JavaScript</code> 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。</p>
<h2 id="1-2-promise解决的问题"><a href="#1-2-promise解决的问题" class="headerlink" title="1.2 promise解决的问题"></a>1.2 promise解决的问题</h2><h3 id="1-2-1-回调地狱"><a href="#1-2-1-回调地狱" class="headerlink" title="1.2.1 回调地狱"></a>1.2.1 回调地狱</h3><p><code>Promise</code> 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<h3 id="1-2-2-并行结果"><a href="#1-2-2-并行结果" class="headerlink" title="1.2.2 并行结果"></a>1.2.2 并行结果</h3><p>如果几个异步操作之间并没有前后顺序之分,但需要等多个异步操作都完成后才能执行后续的任务，无法实现并行节约时间。</p>
<h2 id="1-3-promise简介"><a href="#1-3-promise简介" class="headerlink" title="1.3 promise简介"></a>1.3 promise简介</h2><p>在 <code>ES6 Promises</code> 标准中定义的API还不是很多，目前大致有下面三种类型。</p>
<h3 id="1-3-1-consturctor"><a href="#1-3-1-consturctor" class="headerlink" title="1.3.1 consturctor"></a>1.3.1 <strong>consturctor</strong></h3><p>首先，<code>Promise</code> 是一个对象，也是一个构造函数。</p>
<pre><code>functionf1(resolve, reject) {
  // 异步代码...
}

var promise = newPromise(f1);
</code></pre><h3 id="1-3-2-Instance-Method"><a href="#1-3-2-Instance-Method" class="headerlink" title="1.3.2 Instance Method"></a>1.3.2 Instance Method</h3><p><code>Promise</code>对象通过自身的状态，来控制异步操作。Promise实例具有三种状态。</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
<p>这三种的状态的变化途径只有两种。</p>
<ul>
<li>从“未完成”到“成功”</li>
<li>从“未完成”到“失败”</li>
</ul>
<p>所以<code>Promise</code>的最终结果只有两个,</p>
<ul>
<li>异步操作成功，Promise实例传回一个值（value）,状态变为<code>fulfilled</code>。</li>
<li><p>异步操作失败，Promise 实例抛出一个错误（error）,状态变为<code>rejected</code>。</p>
<p>  promise.then(onFulfilled, onRejected)<br>  // resolve(成功)时,onFulfilled 会被调用// reject(失败)时,onRejected 会被调用</p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/5/161f55d1eecd52cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="1-3-3-Static-Method"><a href="#1-3-3-Static-Method" class="headerlink" title="1.3.3 Static Method"></a>1.3.3 Static Method</h3><p>像 <code>Promise</code>这样的全局对象还拥有一些静态方法。包括 <code>Promise.all()</code>还有<code>Promise.resolve()</code> 等在内，主要都是一些对<code>Promise</code>进行操作的辅助方法。</p>
<h1 id="2-Promise的实现"><a href="#2-Promise的实现" class="headerlink" title="2.Promise的实现"></a>2.<code>Promise</code>的实现</h1><h2 id="2-1-resolve和reject"><a href="#2-1-resolve和reject" class="headerlink" title="2.1 resolve和reject"></a>2.1 resolve和reject</h2><p><code>resolve</code>和<code>reject</code>都是函数</p>
<pre><code>//构造函数中functionPromise(executor) {
    let self = this;

    /*初始化status*/
    self.status = &apos;pending&apos;;
    /*初始化value*/
    self.value = undefined;
    /*订阅事件的数组*/
    self.onResolvedCallBacks = [];
    self.onRejectedCallBacks = [];

    /*此函数将Promise实例的状态由pending 转化为 fulfilled*/functionresolve(value) {
        if (value instanceofPromise) {
            return value.then(resolve, reject);
        }
        setTimeout(function () {
            if (self.status === &apos;pending&apos;) {
                self.status = &apos;fulfilled&apos;;
                self.value = value;
                /*发布已经订阅过的事件*/
                self.onResolvedCallBacks.forEach(item =&gt; item(self.value))
            }
        }, 0)
    }
    /*此函数将Promise实例的状态由pending 转化为 rejected*/functionreject(reason) {
        setTimeout(function () {
            if (self.status === &apos;pending&apos;) {
                self.status = &apos;rejected&apos;;
                self.value = reason;
                /*发布已经订阅过的事件*/
                self.onRejectedCallBacks.forEach(item =&gt; item(self.value))
            }
        }, 0)
    }

    // new Promise 的时候，执行器（executor）的代码会立即执行try {
        executor(resolve, reject);
    } catch (e) {
        reject(e);
    }

}
</code></pre><h2 id="2-2-then方法"><a href="#2-2-then方法" class="headerlink" title="2.2 then方法"></a>2.2 then方法</h2><p><code>promise</code>成功后，<code>onFullfilled</code>会被调用。并且把<code>promise</code>的值当做它的第一个参数。<code>promise</code>在成功之前，不会调用它，并且只能被调用一次。<code>reject</code>也一样。</p>
<pre><code>// 先封装一个方法
function resolvePromise(promise2,x,resolve,reject){
//
  if(promise2 === x){
    return reject(new TypeError(&apos;循环引用&apos;));
  }
  // 为了防止resolve和reject同时调用
  let called = false;//promise2是否已经resolve 或reject了
  if(x instanceof Promise){
    if(x.status == PENDING){
      x.then(function(y){
        resolvePromise(promise2,y,resolve,reject);
      },reject);
    }else{
      x.then(resolve,reject);
    }
    //x是一个thenable对象或函数，只要有then方法的对象，
  }elseif(x!= null &amp;&amp;((typeof x==&apos;object&apos;)||(typeof x == &apos;function&apos;))){
    //当我们的promise和别的promise进行交互，编写这段代码的时候尽量的考虑兼容性，
    //允许别人瞎写，x可以是对象，也可以是函数
    try{
      letthen = x.then;
      if(typeof then == &apos;function&apos;){
        //有些promise会同时执行成功和失败的回调
        then.call(x,function(y){
          //如果promise2已经成功或失败了，则不会再处理了
          if(called)return;
          called = true;
          resolvePromise(promise2,y,resolve,reject)
        },function(err){
          if(called)return;
          called = true;
          reject(err);
        });
      }else{
        //到此的话x不是一个thenable对象，那直接把它当成值resolve promise2就可以了
        // 当返回一个对象 {name:&apos;a&apos;,then:{age:8}},对象里的then不是thenable对象
        resolve(x);
      }
    }catch(e){
      if(called)return;
      called = true;
      reject(e);
    }

  }else{
    //如果X是一个普通 的值，则用x的值去resolve promise2
    resolve(x);
  }
}

Promise.prototype.then = function(onFulfilled,onRejected){
  //如果成功和失败的回调没有传，则表示这个then没有任何逻辑，只会把值往后抛,叫做值的穿透
  // 例如：promise.then().then().then(function(data){},function(err){})

  onFulfilled = typeof onFulfilled == &apos;function&apos;?onFulfilled:function(value){return  value};
  onRejected = typeof onRejected == &apos;function&apos;?onRejected:reason=&gt;{throw reason};
  //如果当前promise状态已经是成功态了，onFulfilled直接取值
  let self = this;
  let promise2;
  if(self.status == FULFILLED){
    return promise2 = new Promise(function(resolve,reject){
      setTimeout(function(){
        try{
          let x =onFulfilled(self.value);
          //如果获取到了返回值x,会走解析promise的过程
          resolvePromise(promise2,x,resolve,reject);
        }catch(e){
          //如果执行成功的回调过程中出错了，用错误原因把promise2 reject
          reject(e);
        }
      })

    });
  }
  if(self.status == REJECTED){
    return promise2 = new Promise(function(resolve,reject){
      setTimeout(function(){
        try{
          let x =onRejected(self.value);
          resolvePromise(promise2,x,resolve,reject);
        }catch(e){
          reject(e);
        }
      })
    });
  }
  if(self.status == PENDING){
    return promise2 = new Promise(function(resolve,reject){
      self.onResolvedCallbacks.push(function(){
        try{
          let x =onFulfilled(self.value);
          //如果获取到了返回值x,会走解析promise的过程
          resolvePromise(promise2,x,resolve,reject);
        }catch(e){
          reject(e);
        }

      });
      self.onRejectedCallbacks.push(function(){
        try{
          let x =onRejected(self.value);
          resolvePromise(promise2,x,resolve,reject);
        }catch(e){
          reject(e);
        }
      });
    });
  }

}
</code></pre><h2 id="2-2-catch方法"><a href="#2-2-catch方法" class="headerlink" title="2.2 catch方法"></a>2.2 catch方法</h2><pre><code>Promise.prototype.catch=function (callback) {
  returnthis.then(null,callback);
}
---------使用-------
let promise = newPromise(function (resolve, reject) {
  reject(&apos;错误&apos;);
})
promise.then(function(data){console.log(data)}).catch(e=&gt;{console.log(e)});
</code></pre><h2 id="2-3-all-方法"><a href="#2-3-all-方法" class="headerlink" title="2.3 all 方法"></a>2.3 all 方法</h2><pre><code>Promise.all = function (promises) {
  returnnewPromise(function (resolve,reject) {
    let arr =[];//arr是最终返回值的结果的集合。let j =0;
    functionprocessData(i,data){// 每调用一次此函数，j就会+1；
      arr[i] = data;// 每次成功的结果都放入数组中if(++j===promises.length){
        resolve(arr); //只有promises中的最后一个成功，才能调用resolve方法。
      }
    }
    for(let i=0;i&lt;promises.length;i++){
      promises[i].then(function (data) {
          processData(i,data);
      },reject)// 如果有一个失败，整体就会失败
    }
  })
}
</code></pre><p>使用方法：</p>
<pre><code>functionread(file) {
  returnnew Promise1(function (resolve, reject) {
    require(&apos;fs&apos;).readFile(file,&apos;utf8&apos;,function (err, data) {
      resolve(data);
    })
  })
}

Promise1.all([read(&apos;./1.txt&apos;),read(&apos;./2.txt&apos;)]).then(function (data) {
  console.log(data)
})
// [&apos;file1&apos;,&apos;file2&apos;]
</code></pre><h2 id="2-4-race-方法"><a href="#2-4-race-方法" class="headerlink" title="2.4 race 方法"></a>2.4 race 方法</h2><p>只要有一个promise成功，就会执行成功的回调，参数是由promise组成的数组</p>
<pre><code>Promise.race=function (promises) {
  return new Promise(function (resolve, reject) {
    for(let i=0;i&lt;promises.length;i++){
      promises[i].then(resolve,reject);
    }
  })
}
</code></pre><h2 id="2-5-resolve方法"><a href="#2-5-resolve方法" class="headerlink" title="2.5 resolve方法"></a>2.5 resolve方法</h2><pre><code>Promise.resolve = function (value) {
  return new Promise(function (resolve, reject) {
    resolve(value)
  })
}
</code></pre><h2 id="2-6-reject-方法"><a href="#2-6-reject-方法" class="headerlink" title="2.6 reject 方法"></a>2.6 reject 方法</h2><pre><code>Promise.reject = function (reason) {
  return new Promise(function (resolve, reject) {
    reject(reason);
  })
}
</code></pre><h1 id="3-Promise对象的缺点："><a href="#3-Promise对象的缺点：" class="headerlink" title="3.Promise对象的缺点："></a>3.<code>Promise</code>对象的缺点：</h1><ul>
<li><p>1、无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</p>
</li>
<li><p>2、如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</p>
</li>
<li><p>3、当处于<code>Pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/11/call和apply的第一个参数是null-undefined时函数内的的this指向window或global/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/11/call和apply的第一个参数是null-undefined时函数内的的this指向window或global/" itemprop="url">call和apply的第一个参数是null/undefined时函数内的的this指向window或global</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T23:25:16+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="谁说-JavaScript-很简单了？"><a href="#谁说-JavaScript-很简单了？" class="headerlink" title="谁说 JavaScript 很简单了？"></a><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000009024648" target="_blank" rel="noopener">谁说 JavaScript 很简单了？</a></h2><h2 id="JavaScript系列——数组元素左右移动N位算法实现"><a href="#JavaScript系列——数组元素左右移动N位算法实现" class="headerlink" title="JavaScript系列——数组元素左右移动N位算法实现"></a><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000012882330" target="_blank" rel="noopener">JavaScript系列——数组元素左右移动N位算法实现</a></h2><p>14年的面试题，想不到今天在群里有人还问了这个！<br><img src="https://pic1.zhimg.com/v2-2ba203f9e2e5fd627521c12d5e8f4e91_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-2ba203f9e2e5fd627521c12d5e8f4e91_hd.jpg" alt=""><br>call/apply用来改变函数的执行上下文（this），它们的第一个参数thisArg是个对象，即作为函数内的this。</p>
<p>多数时候你传啥函数内就是啥。仅以call示例</p>
<pre><code>function fun() {
alert(this);
}
fun.call(1);
fun.call(&apos;a&apos;);
fun.call(true);
fun.call({name:&apos;jack&apos;});
</code></pre><p>分别弹出“1”、“a”、“true”、“[object Object]”。</p>
<p>有两种情况需要注意，传null或undefined时，将是JS执行环境的全局变量。浏览器中是window，其它环境（如node）则是global。</p>
<pre><code>fun.call(null); // window or global
fun.call(undefined); // window or global
</code></pre><p>这在ECMAScript5.1 15.3.4.4中有解释，如下<br><img src="https://pic2.zhimg.com/v2-a55dd237510bbfca06ff1f5ad5c1ac2e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-a55dd237510bbfca06ff1f5ad5c1ac2e_hd.jpg" alt=""><br>严格模式下情况又有所不同，ES3比较宽容尽量去揣测代码意图。ES5严格模式（ie6/7/8/9除外）则不再揣测，给call/apply传入的任何参数不再转换。如下</p>
<pre><code>&apos;use strict&apos;
function fun() {
alert(this);
}
fun.call(null)      // null
fun.call(undefined) // undefined 
</code></pre><h2 id="几个面试小题："><a href="#几个面试小题：" class="headerlink" title="几个面试小题："></a>几个面试小题：</h2><p><img src="https://pic1.zhimg.com/v2-99d1bfc9bfa325ea383e8e5209a46384_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-99d1bfc9bfa325ea383e8e5209a46384_hd.jpg" alt=""><br>1.alert(alert(1)&amp;&amp;alert(2)):    第一个alert执行没返回undefined【alert 是函数，alert（1）相当调用，但没有返回值，所以是undefined】，alert（2） 直接短路掉。</p>
<p>2.alert(1&amp;&amp;2)   &amp;&amp;第一个为true，才会执行第二个，如果全部是true返回最后一个值。</p>
<p>3.<br><img src="https://pic3.zhimg.com/v2-3c568d3cbe2ee035f846917f7907903d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-3c568d3cbe2ee035f846917f7907903d_hd.jpg" alt=""><br>多次bind只保留第一次的。</p>
<p>4.<br><img src="https://pic3.zhimg.com/v2-99af21478704f737a974a986e9fd41cc_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-99af21478704f737a974a986e9fd41cc_hd.jpg" alt=""><br>5.<br><img src="https://pic4.zhimg.com/v2-eef9d265365a8782e55efa78ad718b01_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-eef9d265365a8782e55efa78ad718b01_hd.jpg" alt=""><img src="https://pic4.zhimg.com/v2-d355491fab6f0917e3b6b141992dac5c_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-d355491fab6f0917e3b6b141992dac5c_hd.jpg" alt=""><img src="https://pic4.zhimg.com/v2-698cc4f2c86dccb91268ae9b597089dc_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-698cc4f2c86dccb91268ae9b597089dc_hd.jpg" alt=""><br>6.自定义事件</p>
<pre><code>var myEvent = new Event(&apos;myEvent&apos;);
document.addEventListener(&apos;myEvent&apos;, log, false);
function log() {
  console.log(&apos;hello event&apos;);
}
document.dispatchEvent(myEvent);
</code></pre><p>7.数组循环移动<br><img src="https://pic4.zhimg.com/v2-c996087a776f590d84df53c1827872d2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c996087a776f590d84df53c1827872d2_hd.jpg" alt=""><br>需求</p>
<p>假设有这样一个数组</p>
<pre><code>[1,2,3,4,5]
</code></pre><p>现在想要左移或者右移N位，比如移动1位</p>
<pre><code>//左移1位
[2,3,4,5,1]

//右移1位
[5,1,2,3,4]
</code></pre><p>算法实现</p>
<p>这样一道题目，你先不要看我下面的代码，自己思考一下如何实现它，不管是复杂的还是简单的方法。<br>可以先告诉你我用了2行代码实现左、右移动元素。</p>
<p>拆分法</p>
<p>当我们没有具体思路的时候，就先假设数组移动1位的情况。</p>
<pre><code>[1,2,3,4,5]
=&gt;
[null,1,2,3,4] and [5,null,null,null,null]
=&gt;
[5,1,2,3,4]
</code></pre><p>这里可以看成2个数组，一个是没有到达边界的元素移动[null,1,2,3,4]，一个是到达了边界的元素移动[5,null,null,null,null]，当元素到达边界，就会往数组的初始位置移动，形成了一个循环的过程。</p>
<p>很明显，如果我们将这2个移动后的数组合并起来，就是需求的结果。</p>
<p>移动2位</p>
<p>同样符合2个移动后的数组合并起来为结果的情况</p>
<pre><code>[1,2,3,4,5]
=&gt;
[null,null,1,2,3] and [4,5,null,null,null]
=&gt;
[4,5,1,2,3]
</code></pre><p>刚好移动数组长度</p>
<pre><code>[1,2,3,4,5]
=&gt;
[1,2,3,4,5] and [] //如果没有，就假设为空数组
</code></pre><p>合并数组</p>
<p>假设移动1位的情况<br>上面的步骤，我们找到了规律，接下来要做的是找到2个数组，需要用到slice截取数组元素。<br>截取第一个数组</p>
<pre><code>arr.slice(0,-1)
// [1,2,3,4]
</code></pre><p>截取第二个数组</p>
<pre><code>arr.slice(-1)
// [5]
</code></pre><p>合并数组</p>
<pre><code>arr.slice(-1).concat(arr.slice(0,-1))
// [5,1,2,3,4]
</code></pre><p>这样你就实现了移动1位的情况，接着，你继续拿+5和-5范围内的数字进行测试，发现都可以正常移动，当数字大于5或者小于-5的时候，代码就无效了，始终输出[1,2,3,4,5]</p>
<pre><code>arr.slice(-6).concat(arr.slice(0,-6))
// [1,2,3,4,5]
</code></pre><p>我们再加上一个小技巧，求余数，假设是移动6，那么，实际上和移动1是相同的，我们就可以根据公式求余数</p>
<pre><code>n = n%arr.length
// n = 6%5 余1
</code></pre><p>同理，当移动-6时</p>
<pre><code>n = n%arr.length
// n = -6%5 余-1
</code></pre><p>接着带入公式，发现输出全部都正确了！！</p>
<p>思路分析完了，应该很清晰了吧，源码在下面、</p>
<p>算法源码</p>
<p>arr表示原始数组，n表示移动的距离，可以是正数、可以是0、也可以是负数、正数表示右移，负数表示左移，0表示不移动。</p>
<pre><code>function moveElement(arr, n) {
  if(Math.abs(n)&gt;arr.length) n = n%arr.length
  return arr.slice(-n).concat(arr.slice(0,-n))
}

// moveElement(arr, 9)
// moveElement(arr, 0)
// moveElement(arr, -9)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/03/Git-的-4-个阶段的撤销更改/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/03/Git-的-4-个阶段的撤销更改/" itemprop="url">Git 的 4 个阶段的撤销更改</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-03T13:07:36+08:00">
                2017-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽然git诞生距今已有12年之久，网上各种关于git的介绍文章数不胜数，但是依然有很多人（包括我自己在内）对于它的功能不能完全掌握。以下的介绍只是基于我个人对于git的理解，并且可能生编硬造了一些不完全符合git说法的词语。目的只是为了让git通俗化，使初学者也能大概了解如何快速上手git。同时，下面所有讨论，我们都假设只使用一个分支，也就是主分支master的情况，虽然这种作法并不符合git规范，但是现实情况中绝大部分用户是直接在master分支上进行工作的，所以在这里我们不去引入更加复杂的各种分支的情况，也不涉及标签tag的操作，只讲在最简单的主分支上如何回退。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h1><h2 id="3个步骤"><a href="#3个步骤" class="headerlink" title="3个步骤"></a><strong>3个步骤</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwzsRUe3nJiclZIHpg0Mc2EYjcdSxicXjJSJDs9bOYlNEHbwJZzibibQxKpg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<p>正常情况下，我们的工作流就是3个步骤，对应上图中的3个箭头线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  git add .</span><br><span class="line">  </span><br><span class="line">  git commit -m &quot;comment&quot;</span><br><span class="line">  </span><br><span class="line">  git push</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">git add .把所有文件放入暂存区；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">git commit把所有文件从暂存区提交进本地仓库；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">git push把所有文件从本地仓库推送进远程仓库。</span><br></pre></td></tr></table></figure></p>
<h2 id="4个区"><a href="#4个区" class="headerlink" title="4个区"></a><strong>4个区</strong></h2><p>git之所以令人费解，主要是它相比于svn等等传统的版本管理工具，多引入了一个暂存区(Stage)的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么4个区就够了：</p>
<ul>
<li><p>工作区(Working Area)</p>
</li>
<li><p>暂存区(Stage)</p>
</li>
<li><p>本地仓库(Local Repository)</p>
</li>
<li><p>远程仓库(Remote Repository)</p>
</li>
</ul>
<h2 id="5种状态"><a href="#5种状态" class="headerlink" title="5种状态"></a><strong>5种状态</strong></h2><p>以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。以下我们把这5种状态分别命名为：</p>
<ul>
<li><p>未修改(Origin)</p>
</li>
<li><p>已修改(Modified)</p>
</li>
<li><p>已暂存(Staged)</p>
</li>
<li><p>已提交(Committed)</p>
</li>
<li><p>已推送(Pushed)</p>
</li>
</ul>
<h1 id="检查修改"><a href="#检查修改" class="headerlink" title="检查修改"></a><strong>检查修改</strong></h1><p>了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这3个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是diff，只是参数有所不同。</p>
<h2 id="已修改，未暂存"><a href="#已修改，未暂存" class="headerlink" title="已修改，未暂存"></a><strong>已修改，未暂存</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure>
<p>首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做git add .之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwDg9nsy9V0Ra5nMdBquNG1HpYFaOazjo6vl1LPHJpjMia8ibicSXu0Svyw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<p>我们在文件开头的第2行胡乱加了4个数字1234，存盘，这时文件进入了已修改状态，但是还没有进入暂存区，我们运行git diff，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/index.md b/index.md</span><br><span class="line"></span><br><span class="line">index 73ff1ba..1066758 100644</span><br><span class="line"></span><br><span class="line">--- a/index.md</span><br><span class="line"></span><br><span class="line">+++ b/index.md</span><br><span class="line"></span><br><span class="line">@@ -1,5 +1,5 @@</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">-layout: main</span><br><span class="line"></span><br><span class="line">+1234layout: main</span><br><span class="line"></span><br><span class="line">color: black</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>git diff的结果告诉我们哪些文件已经做了哪些修改。</p>
<p><strong>已暂存，未提交</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure></p>
<p>现在我们把修改放入暂存区看一下。先执行git add .，然后执行git diff，你会发现没有任何结果：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwXwBzS1lToMWWjy9lEibicoiaibAAAaZa1HCp2j6v52OTN1cjRDia7VTVE6w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<p>这说明git diff这个命令只检查我们的工作区和暂存区之间的差异，如果我们想看到暂存区和本地仓库之间的差异，就需要加一个参数git diff –cached：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/index.md b/index.md</span><br><span class="line"></span><br><span class="line">index 73ff1ba..1066758 100644</span><br><span class="line"></span><br><span class="line">--- a/index.md</span><br><span class="line"></span><br><span class="line">+++ b/index.md</span><br><span class="line"></span><br><span class="line">@@ -1,5 +1,5 @@</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">-layout: main</span><br><span class="line"></span><br><span class="line">+1234layout: main</span><br><span class="line"></span><br><span class="line">color: black</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>这时候我们看到的差异是暂存区和本地仓库之间的差异。</p>
<p><strong>已提交，未推送</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff master origin/master</span><br></pre></td></tr></table></figure></p>
<p>现在，我们把修改从暂存区提交到本地仓库，再看一下差异。先执行git commit，然后再执行git diff –cached，没有差异，执行git diff master origin/master，可以看到差异：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwNSkuZnLBptQUSBddcyOZURahoMau6Rq0cebaYVniaudrh3kXToVj6WA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<p>在这里，master就是你的本地仓库，而origin/master就是你的远程仓库，master是主分支的意思，因为我们都在主分支上工作，所以这里两边都是master，而origin就代表远程。</p>
<h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a><strong>撤销修改</strong></h1><p>了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。</p>
<h2 id="已修改，未暂存-1"><a href="#已修改，未暂存-1" class="headerlink" title="已修改，未暂存"></a><strong>已修改，未暂存</strong></h2><p>如果我们只是在编辑器里修改了文件，但还没有执行git add .，这时候我们的文件还在工作区，并没有进入暂存区，我们可以用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> git checkout .</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">  git reset --hard</span><br></pre></td></tr></table></figure></p>
<p>来进行撤销操作。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnw3vn4WgIpIIyGGweDCXuZzlhpOwS62ibmJNjwviaXsCp9bwshpI9KAKBQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<p>可以看到，在执行完git checkout .之后，修改已被撤销，git diff没有任何内容了。</p>
<blockquote>
<p>一对反义词 git add .的反义词是git checkout .。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行git add .，如果你想向后退一步，撤销刚才的修改，就执行git checkout .。</p>
</blockquote>
<h2 id="已暂存，未提交"><a href="#已暂存，未提交" class="headerlink" title="已暂存，未提交"></a><strong>已暂存，未提交</strong></h2><p>你已经执行了git add .，但还没有执行git commit -m “comment”。这时候你意识到了错误，想要撤销，你可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br><span class="line"></span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure></p>
<p>git reset只是把修改退回到了git add .之前的状态，也就是说文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行git checkout .。</p>
<p>或许你已经注意到了，以上两个步骤都可以用同一个命令git reset –hard来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到未修改的状态。</p>
<p><strong>已提交，未推送</strong></p>
<p>你的手太快，你既执行了git add .，又执行了git commit，这时候你的代码已经进入了你的本地仓库，然而你后悔了，怎么办？不要着急，还有办法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure></p>
<p>还是这个git reset –hard命令，只不过这次多了一个参数origin/master，正如我们上面讲过的，origin/master代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。</p>
<p><strong>已推送</strong></p>
<p>很不幸，你的手实在是太快了，你既git add了，又git commit了，并且还git push了，这时你的代码已经进入远程仓库。如果你想恢复的话，还好，由于你的本地仓库和远程仓库是等价的，你只需要先恢复本地仓库，再强制push到远程仓库就好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwCtsdla2FrJ4nCjP0tBssNeB7ZqBkQON4Jcxb2ghrAUEibNa2icoiaB3cg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>以上4种状态的撤销我们都用到了同一个命令git reset –hard，前2种状态的用法甚至完全一样，所以只要掌握了git reset –hard这个命令的用法，从此你再也不用担心提交错误了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/29/从Vue-js源码看nextTick机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/29/从Vue-js源码看nextTick机制/" itemprop="url">从Vue.js源码看nextTick机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-29T22:30:13+08:00">
                2017-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://link.zhihu.com/?target=https%3A//chuckliu.me/%23%21/posts/58bd08a2b5187d2fb51c04f9" target="_blank" rel="noopener">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></p>
<h2 id="可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。"><a href="#可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。" class="headerlink" title="可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。"></a>可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。</h2><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>在使用vue.js的时候，有时候因为一些特定的业务场景，不得不去操作DOM，比如这样：</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: &apos;begin&apos;
        };
    },
    methods () {
        handleClick () {
            this.test = &apos;end&apos;;
            console.log(this.$refs.test.innerText);//打印“begin”
        }
    }
}
</code></pre><p>打印的结果是begin，为什么我们明明已经将test设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“begin”呢？</p>
<h2 id="Watcher队列"><a href="#Watcher队列" class="headerlink" title="Watcher队列"></a>Watcher队列</h2><p>带着疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。</p>
<pre><code>update () {
    /* istanbul ignore else */
    if (this.lazy) {
        this.dirty = true
    } else if (this.sync) {
        /*同步则执行run直接渲染视图*/
        this.run()
    } else {
        /*异步推送到观察者队列中，下一个tick时调用。*/
        queueWatcher(this)
    }
}
</code></pre><p>我们发现Vue.js默认是使用<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fguide%252Freactivity.html%2523%25E5%25BC%2582%25E6%25AD%25A5%25E6%259B%25B4%25E6%2596%25B0%25E9%2598%259F%25E5%2588%2597" target="_blank" rel="noopener">异步执行DOM更新</a>。<br>当异步执行update的时候，会调用queueWatcher函数。</p>
<pre><code>/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/
export function queueWatcher (watcher: Watcher) {
  /*获取watcher的id*/
  const id = watcher.id
  /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      /*如果没有flush掉，直接push到队列中即可*/
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i &gt;= 0 &amp;&amp; queue[i].id &gt; watcher.id) {
        i--
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
</code></pre><p>查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</p>
<p>那么，什么是下一个tick？</p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>vue.js提供了一个<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fapi%252F%2523Vue-nextTick" target="_blank" rel="noopener">nextTick</a>函数，其实也就是上面调用的nextTick。</p>
<p>nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion，看一下源码：</p>
<pre><code>/**
 * Defer a task to execute it asynchronously.
 */
 /*
    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function
    这个函数的作用是在task或者microtask中推入一个timerFunc，
    在当前调用栈执行完以后以此执行直到执行到timerFunc
    目的是延迟到当前调用栈执行完以后执行
*/
export const nextTick = (function () {
  /*存放异步执行的回调*/
  const callbacks = []
  /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/
  let pending = false
  /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/
  let timerFunc

  /*下一个tick时的回调*/
  function nextTickHandler () {
    /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/
    pending = false
    /*执行所有callback*/
    const copies = callbacks.slice(0)
    callbacks.length = 0
    for (let i = 0; i &lt; copies.length; i++) {
      copies[i]()
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */

  /*
    这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法
    优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。
    如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
    参考：https://www.zhihu.com/question/55364497
  */
  if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) {
    /*使用Promise*/
    var p = Promise.resolve()
    var logError = err =&gt; { console.error(err) }
    timerFunc = () =&gt; {
      p.then(nextTickHandler).catch(logError)
      // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn&apos;t being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.
      if (isIOS) setTimeout(noop)
    }
  } else if (typeof MutationObserver !== &apos;undefined&apos; &amp;&amp; (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === &apos;[object MutationObserverConstructor]&apos;
  )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/
    var counter = 1
    var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, {
      characterData: true
    })
    timerFunc = () =&gt; {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
    }
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    /*使用setTimeout将回调推入任务队列尾部*/
    timerFunc = () =&gt; {
      setTimeout(nextTickHandler, 0)
    }
  }

  /*
    推送到队列中下一个tick时执行
    cb 回调函数
    ctx 上下文
  */
  return function queueNextTick (cb?: Function, ctx?: Object) {
    let _resolve
    /*cb存到callbacks中*/
    callbacks.push(() =&gt; {
      if (cb) {
        try {
          cb.call(ctx)
        } catch (e) {
          handleError(e, ctx, &apos;nextTick&apos;)
        }
      } else if (_resolve) {
        _resolve(ctx)
      }
    })
    if (!pending) {
      pending = true
      timerFunc()
    }
    if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) {
      return new Promise((resolve, reject) =&gt; {
        _resolve = resolve
      })
    }
  }
})()
</code></pre><p>它是一个立即执行函数,返回一个queueNextTick接口。</p>
<p>传入的cb会被push进callbacks中存放起来，然后执行timerFunc（pending是一个状态标记，保证timerFunc在下一个tick之前只执行一次）。</p>
<p>timerFunc是什么？</p>
<p>看了源码发现timerFunc会检测当前环境而不同实现，其实就是按照Promise，MutationObserver，setTimeout优先级，哪个存在使用哪个，最不济的环境下使用setTimeout。</p>
<p>两者的具体实现</p>
<ul>
<li>macrotasks: setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染</li>
<li>microtasks: Promise， process.nextTick， Object.observe， MutationObserver</li>
</ul>
<p>再简单点可以总结为：<br><img src="https://pic1.zhimg.com/v2-e92a4f5f686d115832b63b9b9e3ac2cd_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-e92a4f5f686d115832b63b9b9e3ac2cd_hd.jpg" alt=""></p>
<ol>
<li>在 macrotask 队列中执行最早的那个 task ，然后移出</li>
<li>再执行 microtask 队列中所有可用的任务，然后移出</li>
<li><p>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</p>
<p>  这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。</p>
<pre><code>优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。
如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
</code></pre></li>
</ol>
<p>为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到：</p>
<blockquote>
<p>  JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。<br>setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、   MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。<br>       要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。<br>       实在不行，只能用 setTimeout 创建 task 了。<br>       为啥要用 microtask？<br>       根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。<br>       反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</p>
</blockquote>
<p>首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调，</p>
<p>MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。</p>
<p>至于 MutationObserver 如何模拟 nextTick 这点，直接看源码，其实就是创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容：    var counter = 1</p>
<pre><code>var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, {
      characterData: true
    })
    timerFunc = () =&gt; {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
    }
</code></pre><p>   setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行：</p>
<pre><code>setTimeout(function(){
    console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;);
},0);
</code></pre><p>它会将回调函数加入task中，等到执行。<br><img src="https://pic2.zhimg.com/v2-59cf9f88d7daac690d39edfb9fffc8b8_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-59cf9f88d7daac690d39edfb9fffc8b8_hd.jpg" alt=""></p>
<pre><code>setTimeout(function(){console.log(4)},0);
new Promise(function(resolve){
    console.log(1)
    for( var i=0 ; i&lt;10000 ; i++ ){
        i==9999 &amp;&amp; resolve()
    }
    console.log(2)
}).then(function(){
    console.log(5)
});
console.log(3);
结果是：
1,2,3,5,4
</code></pre><p>再看这个，两个自执行同时执行：</p>
<pre><code>&lt;script&gt;
(function test() {
  setTimeout(function () {
    console.log(4)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(1);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(2);
  }).then(function() {
    console.log(5);
  });
  console.log(3);
})()

(function test2() {
  setTimeout(function () {
    console.log(42)
  }, 0);
  new Promise(function executor (resolve) {
    console.log(12);
    for(var i = 0; i &lt; 10000; i++) {
      i == 9999 &amp;&amp; resolve();
    }
    console.log(22);
  }).then(function() {
    console.log(52);
  });
  console.log(32);
})()
&lt;/script&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-cd18c572eb05069895ede7e34388bb8d_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-cd18c572eb05069895ede7e34388bb8d_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-afcb6fa6fb862818359f757107b769ab_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-afcb6fa6fb862818359f757107b769ab_hd.jpg" alt=""><br>整个执行过程是一个 main thread 【<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/link%3Furl%3DCV-egCVH8yK1w-ilUqGsztryG8s2mbuhAliIC_L1n_-BSZ_KJ16tAfaNkmbcRtU8" target="_blank" rel="noopener">主线程</a>】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的 <code>setTimeout</code> 进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。</p>
<pre><code>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：
</code></pre><p>   1.先执行 macrotasks：I/O -》 UI渲染</p>
<p>   2.再执行 microtasks ：process.nextTick  -》 Promise  -》MutationObserver -&gt;Object.observe</p>
<p>   3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：</p>
<p>setTimeout ，setInterval –》setImmediate</p>
<pre><code>  综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。

setImmediate(function(){
    console.log(1);
},0);
setTimeout(function(){
    console.log(2);
},0);
new Promise(function(resolve){
    console.log(3);
    resolve();
    console.log(4);
}).then(function(){
    console.log(5);
});
console.log(6);
process.nextTick(function(){
    console.log(7);
});
console.log(8);
结果是：3 4 6 8 7 5 2 1
</code></pre><h2 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h2><pre><code>/*Github:https://github.com/answershuto*/
/**
 * Flush both queues and run the watchers.
 */
 /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component&apos;s user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component&apos;s watcher run,
  //    its watchers can be skipped.
  /*
    给queue排序，这样做可以保证：
    1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。
    2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建
    3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。
  */
  queue.sort((a, b) =&gt; a.id - b.id)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/
  for (index = 0; index &lt; queue.length; index++) {
    watcher = queue[index]
    id = watcher.id
    /*将has的标记删除*/
    has[id] = null
    /*执行watcher*/
    watcher.run()
    // in dev build, check and stop circular updates.
    /*
      在测试环境中，检测watch是否在死循环中
      比如这样一种情况
      watch: {
        test () {
          this.test++;
        }
      }
      持续执行了一百次watch代表可能存在死循环
    */
    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] &gt; MAX_UPDATE_COUNT) {
        warn(
          &apos;You may have an infinite update loop &apos; + (
            watcher.user
              ? `in watcher with expression &quot;${watcher.expression}&quot;`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  /**/
  /*得到队列的拷贝*/
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  /*重置调度者的状态*/
  resetSchedulerState()

  // call component updated and activated hooks
  /*使子组件状态都改编成active同时调用activated钩子*/
  callActivatedHooks(activatedQueue)
  /*调用updated钩子*/
  callUpdateHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools &amp;&amp; config.devtools) {
    devtools.emit(&apos;flush&apos;)
  }
}
</code></pre><p>flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图</p>
<h2 id="为什么要异步更新视图"><a href="#为什么要异步更新视图" class="headerlink" title="为什么要异步更新视图"></a>为什么要异步更新视图</h2><p>来看一下下面这一段代码</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div&gt;{{test}}&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: 0
        };
    },
    created () {
      for(let i = 0; i &lt; 1000; i++) {
        this.test++;
      }
    }
}
</code></pre><p>现在有这样的一种情况，created的时候test的值会被++循环执行1000次。<br>每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。<br>如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。<br>所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。<br>保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</p>
<h2 id="访问真实DOM节点更新后的数据"><a href="#访问真实DOM节点更新后的数据" class="headerlink" title="访问真实DOM节点更新后的数据"></a>访问真实DOM节点更新后的数据</h2><p>所以我们需要在修改data中的数据后访问真实的DOM节点更新后的数据，只需要这样，我们把文章第一个例子进行修改。</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;
    &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt;
    &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;
export default {
    data () {
        return {
            test: &apos;begin&apos;
        };
    },
    methods () {
        handleClick () {
            this.test = &apos;end&apos;;
            this.$nextTick(() =&gt; {
                console.log(this.$refs.test.innerText);//打印&quot;end&quot;
            });
            console.log(this.$refs.test.innerText);//打印“begin”
        }
    }
}
</code></pre><p>使用Vue.js的global API的$nextTick方法，即可在回调中获取已经更新好的DOM实例了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/CSS网格布局（Grid）完全教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/CSS网格布局（Grid）完全教程/" itemprop="url">CSS网格布局（Grid）完全教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T16:25:32+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="CSS网格布局（Grid）完全教程"><a href="#CSS网格布局（Grid）完全教程" class="headerlink" title="CSS网格布局（Grid）完全教程"></a><a href="https://www.zcfy.cc/article/learn-css-grid-a-guide-to-learning-css-grid-jonathan-suh" target="_blank" rel="noopener">CSS网格布局（Grid）完全教程</a></h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/自己动手实现ES6-EventBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/自己动手实现ES6-EventBus/" itemprop="url">自己动手实现ES6 EventBus</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-24T20:18:08+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">class EventBus &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.events = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on(type, callback, scope, ...args) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            this.events[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        this.events[type].push(&#123;scope: scope, callback: callback, args: args&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off(type, callback, scope) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let numOfCallbacks = this.events[type].length;</span><br><span class="line">        let newArray = [];</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = this.events[type][i];</span><br><span class="line">            if (event.scope == scope &amp;&amp; event.callback == callback) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                newArray.push(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.events[type] = newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has(type, callback, scope) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        let numOfCallbacks = this.events[type].length;</span><br><span class="line">        if (callback === undefined &amp;&amp; scope === undefined) &#123;</span><br><span class="line">            return numOfCallbacks &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = this.events[type][i];</span><br><span class="line">            if ((scope ? event.scope == scope : true) &amp;&amp; event.callback == callback) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit(type, target, ...args) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let bag = &#123;</span><br><span class="line">            type: type,</span><br><span class="line">            target: target</span><br><span class="line">        &#125;;</span><br><span class="line">        args = [bag].concat(args);</span><br><span class="line">        let events = this.events[type].slice();</span><br><span class="line">        let numOfCallbacks = events.length;</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = events[i];</span><br><span class="line">            if (event &amp;&amp; event.callback) &#123;</span><br><span class="line">                let concatArgs = args.concat(event.args);</span><br><span class="line">                event.callback.apply(event.scope, concatArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug() &#123;</span><br><span class="line">        let str = &quot;&quot;;</span><br><span class="line">        for (let type in this.events) &#123;</span><br><span class="line">            let numOfCallbacks = this.events[type].length;</span><br><span class="line">            for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">                let event = this.events[type][i];</span><br><span class="line">                let className = &quot;Anonymous&quot;;</span><br><span class="line">                if (event.scope) &#123;</span><br><span class="line">                    if (event.scope.constructor.name) &#123;</span><br><span class="line">                        className = event.scope.constructor.name;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                str += `$&#123;className&#125; listening for &quot;$&#123;type&#125;&quot;\n`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default new EventBus();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;EventBus Examples&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">    import EventBus from &apos;/src/eventbus.js&apos;;</span><br><span class="line">    // Simple example</span><br><span class="line">    &#123;</span><br><span class="line">        function myHandler(event) &#123;</span><br><span class="line">            console.log(&quot;myHandler / type: &quot; + event.type);</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.on(&quot;my_event&quot;, myHandler);</span><br><span class="line">        EventBus.emit(&quot;my_event&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // Keeping the scope</span><br><span class="line">    &#123;</span><br><span class="line">        class TestClass1 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass1&quot;;</span><br><span class="line">                EventBus.on(&quot;callback_event&quot;, this.callback, this);</span><br><span class="line">            &#125;</span><br><span class="line">            callback(event) &#123;</span><br><span class="line">                console.log(this.className + &quot; / type: &quot; + event.type + &quot; / dispatcher: &quot; + event.target.className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class TestClass2 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass2&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch() &#123;</span><br><span class="line">                EventBus.emit(&quot;callback_event&quot;, this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let t1 = new TestClass1();</span><br><span class="line">        let t2 = new TestClass2();</span><br><span class="line">        t2.dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">    // Passing additional parameters</span><br><span class="line">    &#123;</span><br><span class="line">        class TestClass1 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass1&quot;;</span><br><span class="line">                EventBus.on(&quot;custom_event&quot;, this.doSomething, this);</span><br><span class="line">            &#125;</span><br><span class="line">            doSomething(event, param1, param2) &#123;</span><br><span class="line">                console.log(this.className + &quot;.doSomething&quot;);</span><br><span class="line">                console.log(&quot;type=&quot; + event.type);</span><br><span class="line">                console.log(&quot;params=&quot; + param1 + param2);</span><br><span class="line">                console.log(&quot;coming from=&quot; + event.target.className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class TestClass2 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass2&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            ready() &#123;</span><br><span class="line">                EventBus.emit(&quot;custom_event&quot;, this, &quot;javascript events&quot;, &quot; are really useful&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let t1 = new TestClass1();</span><br><span class="line">        let t2 = new TestClass2();</span><br><span class="line">        t2.ready();</span><br><span class="line">    &#125;</span><br><span class="line">    // Debugging</span><br><span class="line">    console.log(EventBus.debug());</span><br><span class="line">    // Removing a registered handler</span><br><span class="line">    &#123;</span><br><span class="line">        var handler = function() &#123;</span><br><span class="line">            console.log(&apos;example callback&apos;);</span><br><span class="line">        &#125;;</span><br><span class="line">        EventBus.on(&apos;EXAMPLE_EVENT&apos;, handler);</span><br><span class="line">        EventBus.emit(&apos;EXAMPLE_EVENT&apos;);</span><br><span class="line">        EventBus.off(&apos;EXAMPLE_EVENT&apos;, handler);</span><br><span class="line">        // Not emitted because event was removed</span><br><span class="line">        EventBus.emit(&apos;EXAMPLE_EVENT&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">88</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="舞动乾坤">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="舞动乾坤">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="舞动乾坤">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/14/">





  <title>舞动乾坤 - 星光不问赶路人 岁月不负有心人</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
    	<div id="sky">
				<div id="background" class="container">
			<!-- svg file -->
			<svg id="svgout" height="100%" width="100%" viewbox="0 0 550 400">
				<defs>
					<g id="bottomShadow">
						<path fill="#000000" stroke="none" d="
		M 270.5 225.95
		L 127.35 316.65 266.8 400 409.6 309.25 270.5 225.95 Z"/>
					</g>
					<g id="Layer52_0_FILL">
						<path class="topGrass" fill="#B9D668" stroke="none" d="
	M 397.85 229.3
	L 397.85 225.6 269.85 152 135.75 228.6 135.75 233.65 262.1 306.55 397.85 229.3 Z"/>
					</g>
					<g id="Layer51_0_FILL">
						<path class="leftSideGrass" fill="#6E9E4F" stroke="none" d="
	M 135.1 229.95
	L 135.1 256.85 262.1 328.4 262.1 301.85 135.1 229.95 Z"/>
					</g>
					<g id="Layer50_0_FILL">
						<path class="rightGrassTop" fill="#8CB154" stroke="none" d="
	M 397.85 225.95
	L 395.8 225.95 261.75 301.55 261.75 328.4 397.85 251.15 397.85 225.95 Z"/>
					</g>
					<g id="Layer48_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.45 282.4
	L 135.75 298.15 262.1 372.1 261.75 355.65 135.45 282.4 Z"/>
					</g>
					<g id="Layer47_0_FILL">
						<path class="middleLeftCrust" fill="#C77E61" stroke="none" d="
	M 135.1 270.3
	L 135.1 283.05 275.9 364.35 271.85 348.9 135.1 270.3 Z"/>
					</g>
					<g id="Layer46_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.1 255.15
	L 135.1 270.3 262.1 343.55 262.1 328.05 135.1 255.15 Z"/>
					</g>
					<g id="Layer45_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 294.5
	L 397.5 277 261.75 355.3 261.75 372.75 397.5 294.5 Z"/>
					</g>
					<g id="Layer44_0_FILL">
						<path class="middleRightCrust" fill="#C89451" stroke="none" d="
	M 397.5 269.95
	L 397.15 266.6 262.1 343.2 262.1 355.95 397.5 279.7 397.5 269.95 Z"/>
					</g>
					<g id="Layer43_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 266.6
	L 397.5 250.45 261.75 328.4 261.75 343.85 397.5 266.6 Z"/>
					</g>
					<g id="Layer41_0_FILL">
						<path class="greyRoad" fill="#B2B2B1" stroke="none" d="
	M 295.05 283.05
	Q 299.05 280.35 308.45 275.3 317.85 269.95 323.6 266.9
	L 268.8 233.65 338.05 191.35 309.15 174.55 177.75 254.5
	Q 191.55 262.2 198.25 266.25 204.65 269.95 209.7 271.95
	L 241.6 250.45 295.05 283.05 Z"/>
					</g>
					<g id="Layer40_0_FILL">
						<path fill="#FFFFFF" stroke="none" d="
	M 199.95 256.85
	Q 194.55 261.2 191.9 262.2
	L 194.9 263.9 200.95 259.2 199.95 256.85
	M 225.8 243.75
	L 224.8 241.75 211.05 250.8 212.05 252.8 225.8 243.75
	M 308.15 275.65
	L 296.7 266.6 295.35 268.6 306.8 277.7 308.15 275.65
	M 275.9 253.5
	L 274.55 255.5 285.95 264.55 287.3 262.55 275.9 253.5
	M 251.7 227.3
	L 250.7 225.25 236.9 234.35 237.9 236.35 251.7 227.3
	M 257.05 240.7
	L 254.05 240.7 268.8 249.8 269.5 247.75 257.05 240.7
	M 277.2 207.8
	L 263.45 216.85 264.45 218.9 278.25 209.8 277.2 207.8
	M 305.1 192.65
	L 304.1 190.65 290.3 199.75 291.35 201.75 305.1 192.65 Z"/>
					</g>
					<g id="Layer38_0_FILL">
						<path class="frontFascia" fill="#ECB27B" stroke="none" d="
	M 359.25 187.95
	L 346.4 174.95 333.85 202.9 359.25 187.95 Z"/>
					</g>
					<g id="Layer37_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 334 201.05
	L 334.35 232 359.2 217.55 359.25 187.95 334 201.05 Z"/>
					</g>
					<g id="Layer36_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 334.35 232.3
	L 334.35 205.1 305.1 191.35 305.1 216.85 334.35 232.3 Z"/>
					</g>
					<g id="Layer35_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 329.7 167.9
	L 331.05 167.9 344.55 176.7 347.85 176.7 363 192.25 363.15 189.55 350.65 176.7 350.55 176.7 334.25 167.5 334.25 159.1 329.7 159.1 329.7 164.9 322.65 160.95 322.3 162.15 329.7 167 329.7 167.9 Z"/>
					</g>
					<g id="Layer34_0_FILL">
						<path class="leftRoof" fill="#F2563B" stroke="none" d="
	M 334.05 207.05
	L 350.65 176.7 322.1 160.45 302.1 192.05 334.05 207.05 Z"/>
					</g>
					<g id="Layer30_0_FILL">
						<path id="windowFour" class="windows" stroke="none" fill="#975A42" d="
	M 341.35 203.3
	Q 340.9 203.45 340.5 203.8 340.1 204.2 339.85 204.75 339.7 205 339.7 205.3 339.6 205.75 339.7 206.1 339.7 206.15 339.7 206.2 339.8 206.5 340 206.8 340.55 207.4 341.45 207.4 342.35 207.4 343 206.8 343.4 206.5 343.65 206.1 343.85 205.75 343.95 205.3 344.05 204.4 343.55 203.8 343.3 203.45 343 203.3 342.65 203.15 342.2 203.15 341.8 203.15 341.35 203.3
	M 355.85 198.45
	Q 355.8 198.2 355.6 198 355.1 197.4 354.2 197.4 353.35 197.4 352.6 198 351.85 198.65 351.7 199.55 351.7 199.7 351.7 199.85 351.6 200.5 352 201.05 352.55 201.65 353.45 201.65 354.3 201.65 355.05 201.05 355.45 200.7 355.7 200.25 355.8 200.05 355.9 199.85 355.95 199.7 355.95 199.55 356.05 198.95 355.85 198.45 Z"/>
						<path class="door" fill="#B65041" stroke="none" d="
	M 351.95 211.2
	L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2
	M 351.2 211.2
	L 351.35 211.2 351.35 211.1 351.2 211.2 Z"/>
					</g>
					<g>
						<path id="Layer30_0_FILL" fill="#000000" fill-opacity="1" stroke="none" d="
	M 183.7 215.3
	L 183.7 215.6
	Q 187.25 231.75 212.25 234.35
	L 183.7 215.3 Z"/>
					</g>
					<g id="Layer29_0_FILL">
						<path fill="#000000" fill-opacity="0.4" stroke="none" d="
	M 305.1 216.85
	L 305.15 217.2
	Q 309.45 233.2 334.35 232.3
	L 305.1 216.85 Z"/>
					</g>
					<g id="Layer27_0_FILL">
						<path class="vegetation" fill="#78A950" stroke="none" d="
	M 177.45 231.65
	Q 175.75 235.35 181.8 239.35 185.5 235.7 185.15 231.3 182.8 230.65 181.45 234 179.45 231.3 177.45 231.65
	M 236.9 266.6
	Q 235.2 270.3 241.25 274.3 244.95 270.6 244.65 266.25 242.3 265.6 240.95 268.95 238.9 266.25 236.9 266.6
	M 254.7 277
	Q 253.05 280.7 259.1 284.75 262.75 281.05 262.45 276.65 260.1 276 258.75 279.35 256.7 276.65 254.7 277
	M 315.5 245.75
	Q 313.5 243.05 311.5 243.4 309.8 247.1 315.85 251.15 319.55 247.45 319.2 243.05 316.85 242.4 315.5 245.75
	M 295.35 232.65
	Q 293.7 236.35 299.75 240.4 303.45 236.7 303.1 232.3 300.75 231.65 299.4 235 297.4 232.3 295.35 232.65
	M 277.2 171.85
	Q 275.55 175.55 281.6 179.55 285.3 175.85 284.95 171.5 282.6 170.85 281.25 174.2 279.25 171.5 277.2 171.85 Z"/>
					</g>
					<g id="Layer26_0_FILL">
						<path class="treeWood" fill="#AE663D" stroke="none" d="
	M 175.1 177.55
	L 172.05 177.55 172.05 191.1 159.3 172.85
	Q 154.6 171.5 172.05 195.7
	L 172.05 212.5 175.1 212.5 175.1 177.55
	M 252.7 151.35
	L 249 151.35 249 176.9 252.7 176.9 252.7 151.35 Z"/>
					</g>
					<g id="Layer25_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 192.55 179.55
	Q 200.95 173.5 200.95 165.1 200.95 156.4 192.55 150 184.15 144.3 172.05 144.3 160.3 144.3 151.9 150 143.15 156.4 143.15 165.1 143.15 173.5 151.9 179.55 160.3 185.95 172.05 185.95 184.15 185.95 192.55 179.55
	M 236.25 106.65
	Q 230.2 116.05 230.2 129.15 230.2 142.25 236.25 151.35 242.3 160.75 250.7 160.75 258.75 160.75 264.8 151.35 270.85 142.25 270.85 129.15 270.85 116.05 264.8 106.65 258.75 97.6 250.7 97.6 242.3 97.6 236.25 106.65 Z"/>
					</g>
					<g id="Layer24_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 158.3 221.9
	Q 160.65 221.9 161.95 220.2 163 219.55 163.3 218.55 164.65 218.9 166.35 218.9 170.05 218.9 172.4 216.2 175.1 213.85 175.1 210.15 175.1 206.45 172.4 203.75 170.05 201.4 166.35 201.4 162.65 201.4 159.95 203.75 157.6 206.45 157.6 210.15 157.6 210.8 157.6 211.15 155.95 211.5 154.6 212.5 152.9 214.15 152.9 216.55 152.9 218.9 154.6 220.2 156.25 221.9 158.3 221.9
	M 338.35 240.05
	Q 341.05 237.7 341.05 234 341.05 230.3 338.35 227.6 336 225.25 332.3 225.25 328.65 225.25 325.95 227.6 323.6 230.3 323.6 234 323.6 237.7 325.95 240.05 328.65 242.75 332.3 242.75 336 242.75 338.35 240.05 Z"/>
					</g>
					<g id="Layer22_0_FILL">
						<path class="rightRoof" fill="#D05041" stroke="none" d="
	M 220 173.85
	L 236.8 186.7 264.35 171.15 244.5 159.55 220 173.85 Z"/>
					</g>
					<g id="Layer21_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 212.25 191.35
	L 183.35 172.3 183.7 215.3 212.25 234.35 212.25 191.35 Z"/>
					</g>
					<g id="Layer20_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 192.1 149.85
	L 236.45 174.8 243.1 171.4
	Q 220.05 150.55 196.3 139.95
	L 192.1 149.85 Z"/>
					</g>
					<g id="Layer19_0_FILL">
						<path class="frontFascia" fill="#EBB17B" stroke="none" d="
	M 226.85 160.95
	L 212 190.6 229.75 192.6 239.75 172.85 226.85 160.95 Z"/>
					</g>
					<g id="Layer18_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 240.15 172.65
	L 211.9 191.6 212.25 233.65 264.35 201.7 264.35 170.8 240.8 184.45 240.15 172.65 Z"/>
					</g>
					<g id="Layer17_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 210.9 142.2
	L 205.9 142.2 205.9 152.65 210.9 152.65 210.9 142.2 Z"/>
					</g>
					<g>
						<path id="Layer16_0_FILL" class="leftRoof" fill="#F2563B" stroke="none" d="
	M 210.25 195.5
	L 227.4 160.95 195.45 141.35 177.65 175.85 210.25 195.5 Z"/>
					</g>
					<g>
						<path id="sun" fill="#E3BD0E" stroke="none" d="
	M 257.05 15.95
	Q 251.7 15.95 248 19.65 244.3 23.35 244.3 28.7 244.3 34.1 248 37.8 251.7 41.5 257.05 41.5 262.45 41.5 266.15 37.8 269.85 34.1 269.85 28.7 269.85 23.35 266.15 19.65 262.45 15.95 257.05 15.95 Z"/>
					</g>
					<g id="Layer8_0_FILL">
						<path fill="#975A42" stroke="none" d="
	M 238.45 189.65
	Q 238.295703125 189.362109375 238.05 189.1 237.35 188.3 236.2 188.3 235.05 188.3 234.15 189.1 233.3 189.9 233.2 191.05 233.1 192.2 233.8 193 234.55 193.8 235.7 193.8 236.85 193.8 237.7 193 238.1970703125 192.558203125 238.45 192 238.6552734375 191.56484375 238.7 191.05 238.7671875 190.276953125 238.45 189.65
	M 220.55 197.55
	Q 220 197.55 219.5 197.75 218.95 197.95 218.5 198.35 217.933203125 198.8833984375 217.7 199.55 217.5833984375 199.916796875 217.55 200.3 217.4923828125 200.96171875 217.7 201.5 217.852734375 201.9103515625 218.15 202.25 218.95 203.05 220.1 203.05 221.25 203.05 222.05 202.25 222.95 201.45 223.05 200.3 223.15 199.15 222.4 198.35 222.05 197.95 221.65 197.75 221.15 197.55 220.55 197.55 Z"/>
					</g>
					<g id="Layer7_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 233.55 206.75
	L 225.9 211.95 226.25 225.5 233.95 220.35 233.55 206.75 Z"/>
					</g>
					<g>
						<path id="windowOne" class="windows" fill="#975A42" stroke="none" d="
	M 188.65 198.4
	L 188.8 204.1 198.65 210.45 198.55 204.75 188.65 198.4
	M 208.45 216.8
	L 208.35 211.1 198.55 204.75 198.65 210.45 208.45 216.8
	M 188.8 204.1
	L 188.95 209.8 198.8 216.15 198.65 210.45 188.8 204.1
	M 208.6 222.5
	L 208.45 216.8 198.65 210.45 198.8 216.15 208.6 222.5 Z"/>
					</g>
					<g>
						<path id="windowThree" class="windows" fill="#975A42" stroke="none" d="
	M 311.7 214.1
	L 318.55 217.55 318.45 211.9 311.6 208.45 311.7 214.1
	M 325.4 221
	L 325.25 215.35 318.45 211.9 318.55 217.55 325.4 221
	M 318.4 206.2
	L 311.5 202.75 311.6 208.45 318.45 211.9 318.4 206.2
	M 325.25 215.35
	L 325.2 209.7 318.4 206.2 318.45 211.9 325.25 215.35 Z"/>
					</g>
					<g id="Layer2_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 259.7 183.25
	L 244.6 191.9 244.6 213.8 259.7 204.55 259.7 183.25 Z"/>
					</g>
					<path id="windowTwo" fill="#975A42" class="windows" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" d="
	M 223.05 200.3
	Q 222.95 201.45 222.05 202.25 221.25 203.05 220.1 203.05 218.95 203.05 218.15 202.25 217.852734375 201.9103515625 217.7 201.5 217.4923828125 200.96171875 217.55 200.3 217.5833984375 199.916796875 217.7 199.575 217.933203125 198.8833984375 218.5 198.35 218.95 197.95 219.5 197.75 220 197.55 220.55 197.55 221.15 197.55 221.65 197.75 222.05 197.95 222.4 198.35 223.15 199.15 223.05 200.3 Z
	M 238.7 191.05
	Q 238.6552734375 191.56484375 238.45 192 238.1970703125 192.558203125 237.7 193 236.85 193.8 235.7 193.8 234.55 193.8 233.8 193 233.1 192.2 233.2 191.05 233.3 189.9 234.15 189.1 235.05 188.3 236.2 188.3 237.35 188.3 238.05 189.1 238.295703125 189.362109375 238.45 189.65 238.7671875 190.276953125 238.7 191.05 Z"/>
					<path fill="#F2563B" stroke="none" d=" M 351.95 211.2 L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2 Z"/>
					<path id="Layer6_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 198.55 204.75
	L 208.35 211.1 208.45 216.8 208.6 222.5 198.8 216.15 188.95 209.8 188.8 204.1 188.65 198.4 198.55 204.75 198.65 210.45 208.45 216.8
	M 198.8 216.15
	L 198.65 210.45 188.8 204.1"/>
					<path id="Layer5_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 325.25 215.35
	L 325.4 221 318.55 217.55 311.7 214.1 311.6 208.45 311.5 202.75 318.4 206.2 325.2 209.7 325.25 215.35 318.45 211.9 318.55 217.55
	M 318.4 206.2
	L 318.45 211.9 311.6 208.45"/>
				</defs>
				<g id="shadow">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use xlink:href="#bottomShadow"/>
					</g>
				</g>
				<g transform="matrix( 1, 0, 0, 1, 0,0) ">
					<use xlink:href="#sun"/>
				</g>
				<g id="earth">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer52_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer51_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer50_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer48_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer47_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer46_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer45_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer44_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer43_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer41_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer40_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer38_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer37_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer36_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer35_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer34_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowFour"/>
						<use class="element" xlink:href="#Layer32_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer30_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer27_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer26_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer25_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer24_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer22_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer21_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer20_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer19_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer18_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer17_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer16_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer8_0_FILL"/>
						<use class="element" xlink:href="#windowTwo"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer7_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowOne"/>
						<use class="element" xlink:href="#Layer6_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowThree"/>
						<use class="element" xlink:href="#Layer5_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer2_0_FILL"/>
					</g>
				</g>
			</svg>
			<! -- End of SVG file -->
			<! -- Moon/Sun Toggle -->
			<div id="toggleButton" class="day-toggle">
				<div class="sun-icon"></div>
				<label class="switch">
            <input id="toggleCheckbox" type="checkbox">
            <div class="slider"></div>
        </label>
				<div class="cloud-icon"></div>
			</div>
			<! -- Moon/Sun Toggle -->
			<! -- End of Container -->
		</div>
			</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">舞动乾坤</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">星光不问赶路人 岁月不负有心人</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/10/01/模拟实现call和apply/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/10/01/模拟实现call和apply/" itemprop="url">模拟实现call和apply</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-01T20:39:27+08:00">
                2016-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>JS 函数 call 和 apply 用来手动改变 this 的指向，call 和 apply  唯一的区别就在于函数参数的传递方式不同，call 是以逗号的形式，apply 是以数组的形式：</p>
<pre><code>let person1 = {
    name: &quot;person1&quot;,
    say: function(age, sex) {
        console.log(this.name + &apos; age: &apos; + age + &apos; sex: &apos; + sex);
    }
}

let person2 = {
    name: &quot;person&quot;
}

person1.say.call(person2, 20, &quot;男&quot;);

person1.say.apply(person2, [20, &quot;男&quot;]);
</code></pre><p>本文就尝试用其他方式来模拟实现 call 和 apply。</p>
<p>首先观察 call 和 apply 有什么特点？</p>
<ol>
<li>被函数调用（函数也是对象），相当于 call 和 apply 是函数的属性</li>
<li>如果没有传入需要 this 指向对象，那么 this 指向全局对象</li>
<li>函数执行了</li>
<li>最后都改变了 this 的指向</li>
</ol>
<h4 id="一、初步实现"><a href="#一、初步实现" class="headerlink" title="一、初步实现"></a>一、初步实现</h4><p>基于 call 函数是调用函数的属性的特点，call 的 this 指向调用函数，我们可以尝试把调用函数的作为传入的新对象的一个属性，执行后，再删除这个属性就好了。</p>
<pre><code>Function.prototype.newCall = function (context) {
    context.fn = this;  // this 指的是 say 函数
    context.fn();
    delete context.fn;
}

var person = {
    name: &quot;jayChou&quot;
};

var say = function() {
    console.log(this.name);
}

say.newCall(person);  // jayChou
</code></pre><p>是不是就初步模拟实现了 call 函数呢，由于 call 还涉及到传参的问题，所以我们进入到下一环节。</p>
<h4 id="二、eval-方式"><a href="#二、eval-方式" class="headerlink" title="二、eval 方式"></a>二、eval 方式</h4><p>在给对象临时一个函数，并执行时，传入的参数是除了 context 其余的参数。那么我们可以截取 arguments 参数数组的第一个后，将剩余的参数传入临时数组。</p>
<p>在前面我有讲过函数 arguments 类数组对象的特点，arguments 是不支持数组的大多数方法, 但是支持for 循环来遍历数组。</p>
<pre><code>Function.prototype.newCall = function (context) {
    context.fn = this;

    let args = [];

    for(let i=1; i&lt; arguments.length; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }
    // args =&gt; [arguments[1], arguments[2], arguments[3], ...]

    context.fn(args.join(&apos;,&apos;));  // ？？？delete context.fn;
}

var person = {
    name: &quot;jayChou&quot;
};

var say = function(age, sex) {
    console.log(`name: ${this.name},age: ${age}, sex: ${sex}`);
}

say.newCall(person);
</code></pre><p>上面传递参数的方式最后肯定是失败的，我们可以尝试 eval 的方式，将参数添加子函数的作用域中。</p>
<blockquote>
<p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码</p>
</blockquote>
<pre><code>Function.prototype.newCall = function (context) {
    context.fn = this;

    let args = [];

    for(var i=1; i&lt; arguments.length; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    // args =&gt; [arguments[1], arguments[2], arguments[3], ...]eval(&apos;context.fn(&apos; + args + &apos;)&apos;);
    delete context.fn;
}

var person = {
    name: &quot;jayChou&quot;
};

functionsay(age, sex) {
    console.log(`name: ${this.name},age: ${age}, sex: ${sex}`);
}

say.newCall(person, 18, &apos;男&apos;);  // name: jayChou,age: 18, sex: 男
</code></pre><p>成功啦！</p>
<p>实现了函数参数的传递，那么函数返回值怎么处理呢。而且，如果传入的对象是 null，又该如何处理？所以还需要再做一些工作：</p>
<pre><code>Function.prototype.newCall = function (context) {
    if (typeof context === &apos;object&apos;) {
        context = context || window
    } else {
        context = Object.create(null);
    }

    context.fn = this;

    let args = [];

    for(var i=1; i&lt; arguments.length; i++) {
        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);
    }

    // args =&gt; [arguments[1], arguments[2], arguments[3], ...]var result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;);  // 处理返回值delete context.fn;
    return result;  // 返回返回值
}

var person = {
    name: &quot;jayChou&quot;
};

functionsay(age, sex) {
    console.log(`name: ${this.name},age: ${age}, sex: ${sex}`);
    return age + sex;
}

var check = say.newCall(person, 18, &apos;男&apos;);
console.log(check); // 18男
</code></pre><p>判断传入对象的类型，如果为 null 就指向 window 对象。利用 eval 来执行字符串代码，并返回字符串代码执行的结果，就完成了模拟 call。<br>大功告成！</p>
<h4 id="三、ES-6-实现"><a href="#三、ES-6-实现" class="headerlink" title="三、ES 6 实现"></a>三、ES 6 实现</h4><p>前面我们用的 eval 方式可以用 ES6 的解决还存在的一些问题，有没有注意到，这段代码是有问题的。</p>
<pre><code>context.fn = this;
</code></pre><p>假如对象在被 call 调用前，已经有 fn 属性怎么办？</p>
<p>ES6 中提供了一种新的基本数据类型，Symbol，表示独一无二的值，另外，Symbol 作为属性的时候，不能使用点运算符。所以再加上 ES 的 rest 剩余参数替代 arguments 遍历的工作就有：</p>
<pre><code>Function.prototype.newCall = function (context,...params) {
    if (typeof context === &apos;object&apos;) {
        context = context || window
    } else {
        context = Object.create(null);
    }
    let fn = Symbol();
    context[fn] = thisvar result = context[fn](...params);

    delete context.fn;
    return result;
}

var person = {
    name: &quot;jayChou&quot;
};

functionsay(age, sex) {
    console.log(`name: ${this.name},age: ${age}, sex: ${sex}`);
    return age + sex;
}

var check = say.newCall(person, 18, &apos;男&apos;);
console.log(check); // 18男
</code></pre><h4 id="四、apply"><a href="#四、apply" class="headerlink" title="四、apply"></a>四、apply</h4><p>apply 和 call 的实现原理，基本类似，区别在于 apply 的参数是以数组的形式传入。</p>
<pre><code>Function.prototype.newApply = function (context, arr) {
    if (typeof context === &apos;object&apos;) {
        context = context || window
    } else {
        context = Object.create(null);
    }
    context.fn = this;

    var result;
    if (!arr) {  // 判断函数参数是否为空
        result = context.fn();
    }
    else {
        var args = [];
        for (var i = 0; i &lt; arr.length; i++) {
            args.push(&apos;arr[&apos; + i + &apos;]&apos;);
        }
        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;);
    }

    delete context.fn;
    return result;
}
</code></pre><p><strong>es6 实现</strong></p>
<pre><code>Function.prototype.newApply = function(context, parameter) {
  if (typeof context === &apos;object&apos;) {
    context = context || window
  } else {
    context = Object.create(null)
  }
  let fn = Symbol()
  context[fn] = this;
  var result = context[fn](...parameter);
  delete context[fn];
  return result;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/16/前端代码异常监控实战/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/16/前端代码异常监控实战/" itemprop="url">前端代码异常监控实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-16T11:22:33+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="把前端监控做到极致-掘金"><a href="#把前端监控做到极致-掘金" class="headerlink" title="把前端监控做到极致 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a52f138f265da3e5b32a41b" target="_blank" rel="noopener">把前端监控做到极致 - 掘金</a></h2><h2 id="线上压缩代码-定位错误-掘金"><a href="#线上压缩代码-定位错误-掘金" class="headerlink" title="线上压缩代码-定位错误 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a4f6886518825734216b352" target="_blank" rel="noopener">线上压缩代码-定位错误 - 掘金</a></h2><p>生产环境没有source-map文件，上报的错误都不好定位，这里实现一个简单的错误定位脚本</p>
<p>1、获取压缩代码错误信息（行数、列数、错误信息，错误文件）</p>
<h2 id="这里通过控制台看错误信息"><a href="#这里通过控制台看错误信息" class="headerlink" title="这里通过控制台看错误信息"></a>这里通过控制台看错误信息</h2><pre><code>window.addEventListener(&apos;error&apos;, function (e) {
    console.debug(&apos;lineno: &apos;, e.lineno, &apos; colno: &apos;, e.colno)
    console.debug(&apos;errorMessage:&apos;, e.message)
    console.debug(&apos;errorFile:&apos;, e.filename)
}, true)
</code></pre><p>我们写一段错误的代码（single.vue的片段）</p>
<pre><code>method: {
   test (option) {
        const data = option.test
        const dataTest = option.data.test
        return data + dataTest
    }
}, 
created () {
    // 设置异步错误的原因是，同步的错误会被vue捕获
    setTimeout(() =&gt; {
        this.test({
          testOption: 1
        })
    }, 300)
}
</code></pre><p>在浏览器中运行，报错结果如下<br><img src="https://pic4.zhimg.com/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_hd.jpg" alt=""></p>
<p>得到错误信息：</p>
<ul>
<li>错误行数：1</li>
<li>错误列数：59236</li>
<li>错误信息：cannot read property ‘test’ of undefined</li>
<li>错误文件：0.0a77f.js</li>
</ul>
<p>2、定位错误的node脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## 安装依赖source-map</span><br><span class="line"></span><br><span class="line"> npm install source-map</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    node脚本如下（map/index.js）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> // 读取文件</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">// souceMap处理文件</span><br><span class="line">var SourceMapConsumer = require(&apos;source-map&apos;).SourceMapConsumer</span><br><span class="line">// 启动构建进程（已构建则不需要）</span><br><span class="line">var exec = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">var lineno = process.argv[2] || 0   // 第一个参数为行数</span><br><span class="line">var columnno = process.argv[3] || 0 // 第二个参数为列数</span><br><span class="line">var fileName = process.argv[4] || &apos;&apos; // 第三个参数为错误文件（错误文件名就好）</span><br><span class="line"></span><br><span class="line">// 构建有map的线上代码</span><br><span class="line">// node build onlineMap为构建命令</span><br><span class="line">exec(&apos;node build onlineMap&apos;, function () &#123;</span><br><span class="line"> // 读取错误文件的map文件</span><br><span class="line"> var consumer = new SourceMapConsumer(fs.readFileSync(&apos;./dist/&apos; + fileName + &apos;.map&apos;, &apos;utf8&apos;))</span><br><span class="line">  // 输出map的错误信息</span><br><span class="line">  console.log(consumer.originalPositionFor(&#123;</span><br><span class="line">    line: +lineno,      // +是为了转化为数字</span><br><span class="line">    column: +columnno</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">    运行node脚本</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> node map 1 59236 0.0a77f.js</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>效果如下：</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/v2-cf68e7b673405c90fe024bf48dfb42c7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf68e7b673405c90fe024bf48dfb42c7_hd.jpg" alt=""></p>
<p>结合控制台输出的信息，就可以定位到错误代码了</p>
<p>我们再来看一下，给代码开启source-map，看错误信息是否一致</p>
<p><img src="https://pic3.zhimg.com/v2-5319b431cef161a0a07ba46f8b0e6a02_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-5319b431cef161a0a07ba46f8b0e6a02_hd.jpg" alt=""><br>错误代码的位置定位是准确的，证明可行。</p>
<p>3、后续扩展思路</p>
<h2 id="目前实现的是比较简单的脚本，所以存在一些问题："><a href="#目前实现的是比较简单的脚本，所以存在一些问题：" class="headerlink" title="目前实现的是比较简单的脚本，所以存在一些问题："></a>目前实现的是比较简单的脚本，所以存在一些问题：</h2><ul>
<li>需要当前构建内容和线上是一致的</li>
<li>操作比较繁琐</li>
</ul>
<p>优化思路如下：</p>
<p><img src="https://pic4.zhimg.com/v2-a8b63ecc364c66c8bf4bbec9880f8c23_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a8b63ecc364c66c8bf4bbec9880f8c23_hd.jpg" alt=""></p>
<p>后续优化慢慢补充~</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在对公司的前端代码脚本错误进行排查，试图降低 JS Error 的错误量，结合自己之前的经验对这方面内容进行了实践并总结，下面就此谈谈我对前端代码异常监控的一些见解。</p>
<p>本文大致围绕下面几点展开讨论：</p>
<ol>
<li>JS 处理异常的方式</li>
<li>上报方式</li>
<li>异常监控上报常见问题</li>
</ol>
<h2 id="JS-异常处理"><a href="#JS-异常处理" class="headerlink" title="JS 异常处理"></a>JS 异常处理</h2><p>对于 Javascript 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>
<ol>
<li>当前代码块将作为一个任务压入任务队列中，JS 线程会不断地从任务队列中提取任务执行。</li>
<li>当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务的执行。</li>
<li><p>JS 线程会继续从任务队列中提取下一个任务继续执行。</p>
 <script>
   error
   console.log('永远不会执行');
 </script>
 <script>
   console.log('我继续执行')
 </script>


</li>
</ol>
<p><img src="https://pic2.zhimg.com/v2-7a136ce7674914bcd7b7f42986d0c5bc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7a136ce7674914bcd7b7f42986d0c5bc_hd.jpg" alt=""></p>
<p>在对脚本错误进行上报之前，我们需要对异常进行处理，程序需要先感知到脚本错误的发生，然后再谈异常上报。</p>
<p>脚本错误一般分为两种：语法错误，运行时错误。</p>
<p>下面就谈谈几种异常监控的处理方式：</p>
<h2 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h2><p>try-catch 在我们的代码中经常见到，通过给代码块进行 try-catch 进行包装后，当代码块发生出错时 catch 将能捕捉到错误的信息，页面也将可以继续执行。</p>
<p>但是 try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误和异步错误就显得无能为力，捕捉不到。</p>
<h2 id="示例：运行时错误"><a href="#示例：运行时错误" class="headerlink" title="示例：运行时错误"></a>示例：运行时错误</h2><pre><code>try {
  error    // 未定义变量 
} catch(e) {
  console.log(&apos;我知道错误了&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-dc8ba7e4b9e56127799c11b46cf7068d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-dc8ba7e4b9e56127799c11b46cf7068d_hd.jpg" alt=""></p>
<p>然而对于语法错误和异步错误就捕捉不到了。</p>
<h2 id="示例：语法错误"><a href="#示例：语法错误" class="headerlink" title="示例：语法错误"></a>示例：语法错误</h2><pre><code>try {
  var error = &apos;error&apos;；   // 大写分号
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-8ddf6acf0f42c4b08ba8b73798b863a0_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8ddf6acf0f42c4b08ba8b73798b863a0_hd.jpg" alt=""></p>
<p>一般语法错误在编辑器就会体现出来，常表现的错误信息为： Uncaught SyntaxError: Invalid or unexpected token xxx 这样。但是这种错误会直接抛出异常，常使程序崩溃，一般在编码时候容易观察得到。</p>
<h2 id="示例：异步错误"><a href="#示例：异步错误" class="headerlink" title="示例：异步错误"></a>示例：异步错误</h2><pre><code>try {
  setTimeout(() =&gt; {
    error        // 异步错误
  })
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic4.zhimg.com/v2-0ed67a00e3c7762e74975bebbbc88274_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-0ed67a00e3c7762e74975bebbbc88274_hd.jpg" alt=""></p>
<p>除非你在 setTimeout 函数中再套上一层 try-catch，否则就无法感知到其错误，但这样代码写起来比较啰嗦。</p>
<h2 id="window-onerror-异常处理"><a href="#window-onerror-异常处理" class="headerlink" title="window.onerror 异常处理"></a>window.onerror 异常处理</h2><p>window.onerror 捕获异常能力比 try-catch 稍微强点，无论是异步还是非异步错误，onerror 都能捕获到运行时错误。</p>
<p>示例：运行时同步错误</p>
<pre><code>/**
 * @param {String}  msg    错误信息
 * @param {String}  url    出错文件
 * @param {Number}  row    行号
 * @param {Number}  col    列号
 * @param {Object}  error  错误详细信息
 */
 window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
error;
</code></pre><p>示例：异步错误</p>
<pre><code>window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道异步错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
setTimeout(() =&gt; {
  error;
});
</code></pre><p><img src="https://pic3.zhimg.com/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_hd.jpg" alt=""></p>
<p>然而 window.onerror 对于语法错误还是无能为力，所以我们在写代码的时候要尽可能避免语法错误的，不过一般这样的错误会使得整个页面崩溃，还是比较容易能够察觉到的。</p>
<p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>
<p>需要注意的是，window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。</p>
<p><img src="https://pic3.zhimg.com/v2-875235a4876ea8429f12e7aaf2f19588_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-875235a4876ea8429f12e7aaf2f19588_hd.jpg" alt=""></p>
<p>关于 window.onerror 还有两点需要值得注意</p>
<ol>
<li>对于 onerror 这种全局捕获，最好写在所有 JS 脚本的前面，因为你无法保证你写的代码是否出错，如果写在后面，一旦发生错误的话是不会被 onerror 捕获到的。</li>
<li>另外 onerror 是无法捕获到网络异常的错误。</li>
</ol>
<p>当我们遇到 <code>&lt;img src=&quot;./404.png&quot;&gt;</code> 报 404 网络请求异常的时候，onerror 是无法帮助我们捕获到异常的。</p>
<pre><code>&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道异步错误了&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot;&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-81341c443f078b6526e0c6031dd40953_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81341c443f078b6526e0c6031dd40953_hd.jpg" alt=""></p>
<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>
<pre><code>&lt;script&gt;
window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我知道 404 错误了&apos;);
  console.log(
    msg, url, row, col, error
  );
  return true;
}, true);
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot; alt=&quot;&quot;&gt;
</code></pre><p><img src="https://pic4.zhimg.com/v2-6d1c1196acd800a4a4475ee6847ee82a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6d1c1196acd800a4a4475ee6847ee82a_hd.jpg" alt=""></p>
<p>这点知识还是需要知道，要不然用户访问网站，图片 CDN 无法服务，图片加载不出来而开发人员没有察觉就尴尬了。</p>
<h2 id="Promise-错误"><a href="#Promise-错误" class="headerlink" title="Promise 错误"></a>Promise 错误</h2><p>通过 Promise 可以帮助我们解决异步回调地狱的问题，但是一旦 Promise 实例抛出异常而你没有用 catch 去捕获的话，onerror 或 try-catch 也无能为力，无法捕捉到错误。</p>
<pre><code>window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我感知不到 promise 错误&apos;);
  console.log(
    msg, url, row, col, error
  );
}, true);
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic4.zhimg.com/v2-1ce580bb2344474b1df1517f2d11aa40_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-1ce580bb2344474b1df1517f2d11aa40_hd.jpg" alt=""></p>
<p>虽然在写 Promise 实例的时候养成最后写上 catch 函数是个好习惯，但是代码写多了就容易糊涂，忘记写 catch。</p>
<p>所以如果你的应用用到很多的 Promise 实例的话，特别是你在一些基于 promise 的异步库比如 axios 等一定要小心，因为你不知道什么时候这些异步请求会抛出异常而你并没有处理它，所以你最好添加一个 Promise 全局异常捕获事件 <strong>unhandledrejection</strong>。</p>
<pre><code>window.addEventListener(&quot;unhandledrejection&quot;, function(e){
  e.preventDefault()
  console.log(&apos;我知道 promise 的错误了&apos;);
  console.log(e.reason);
  return true;
});
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic2.zhimg.com/v2-115d494f26e4f8e2172e1f3b4cb6094f_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-115d494f26e4f8e2172e1f3b4cb6094f_hd.jpg" alt=""></p>
<p>当然，如果你的应用没有做 Promise 全局异常处理的话，那很可能就像某乎首页这样：</p>
<p><img src="https://pic2.zhimg.com/v2-37c6bc3763c147a4c97bdde688a59a5c_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-37c6bc3763c147a4c97bdde688a59a5c_hd.jpg" alt=""></p>
<h2 id="异常上报方式"><a href="#异常上报方式" class="headerlink" title="异常上报方式"></a>异常上报方式</h2><p>监控拿到报错信息之后，接下来就需要将捕捉到的错误信息发送到信息收集平台上，常用的发送形式主要有两种:</p>
<ol>
<li>通过 Ajax 发送数据</li>
<li>动态创建 img 标签的形式</li>
</ol>
<p>实例 - 动态创建 img 标签进行上报</p>
<pre><code>function report(error) {
  var reportUrl = &apos;http://xxxx/report&apos;;
  new Image().src = reportUrl + &apos;error=&apos; + error;
}
</code></pre><h2 id="监控上报常见问题"><a href="#监控上报常见问题" class="headerlink" title="监控上报常见问题"></a>监控上报常见问题</h2><p>下述例子我全部放在我的 github 上，读者可以自行查阅，后面不再赘述。</p>
<pre><code>git clone https://github.com/happylindz/blog.git
cd blog/code/jserror/
npm install
</code></pre><h2 id="Script-error-脚本错误是什么"><a href="#Script-error-脚本错误是什么" class="headerlink" title="Script error 脚本错误是什么"></a>Script error 脚本错误是什么</h2><p>因为我们在线上的版本，经常做静态资源 CDN 化，这就会导致我们常访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。</p>
<p><img src="https://pic3.zhimg.com/v2-840f71bf7014767132b47ad2c6a37238_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-840f71bf7014767132b47ad2c6a37238_hd.jpg" alt=""></p>
<p>可通过 <code>npm run nocors</code> 查看效果。</p>
<p>Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。</p>
<p><img src="https://pic2.zhimg.com/v2-fc3941d89716f96374576d0426ff4ccb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-fc3941d89716f96374576d0426ff4ccb_hd.jpg" alt=""></p>
<p>这样做的目的是避免数据泄露到不安全的域中，举个简单的例子，</p>
<pre><code>&lt;script src=&quot;xxxx.com/login.html&quot;&gt;&lt;/script&gt;
</code></pre><p>上面我们并没有引入一个 js 文件，而是一个 html，这个 html 是银行的登录页面，如果你已经登录了，那 login 页面就会自动跳转到 <code>Welcome xxx...</code>，如果未登录则跳转到 <code>Please Login...</code>，那么报错也会是 <code>Welcome xxx... is not defined，Please Login... is not defined</code>，通过这些信息可以判断一个用户是否登录他的帐号，给入侵者提供了十分便利的判断渠道，这是相当不安全的。</p>
<p>介绍完背景后，那么我们应该去解决这个问题？</p>
<p>首先可以想到的方案肯定是同源化策略，将 JS 文件内联到 html 或者放到同域下，虽然能简单有效地解决 script error 问题，但是这样无法利用好文件缓存和 CDN 的优势，不推荐使用。正确的方法应该是从根本上解决 script error 的错误。</p>
<h2 id="跨源资源共享机制-CORS"><a href="#跨源资源共享机制-CORS" class="headerlink" title="跨源资源共享机制( CORS )"></a>跨源资源共享机制( CORS )</h2><p>首先为页面上的 script 标签添加 crossOrigin 属性</p>
<pre><code>// http://localhost:8080/index.html
&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;script src=&quot;http://localhost:8081/test.js&quot; crossorigin&gt;&lt;/script&gt;

// http://localhost:8081/test.js
setTimeout(() =&gt; {
  console.log(error);
});
</code></pre><p>当你修改完前端代码后，你还需要额外给后端在响应头里加上 <code>Access-Control-Allow-Origin: localhost:8080</code>，这里我以 Koa 为例。</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const path = require(&apos;path&apos;);
const cors = require(&apos;koa-cors&apos;);
const app = new Koa();

app.use(cors());
app.use(require(&apos;koa-static&apos;)(path.resolve(__dirname, &apos;./public&apos;)));

app.listen(8081, () =&gt; {
  console.log(&apos;koa app listening at 8081&apos;)
});
</code></pre><p><img src="https://pic1.zhimg.com/v2-9717062e56340cef40ee67b438b2ba95_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-9717062e56340cef40ee67b438b2ba95_hd.jpg" alt=""></p>
<p>读者可通过 <code>npm run cors</code> 详细的跨域知识我就不展开了，有兴趣可以看看我之前写的文章：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>你以为这样就完了吗？并没有，下面就说一些 Script error 你不常遇见的点：</p>
<p>我们都知道 JSONP 是用来跨域获取数据的，并且兼容性良好，在一些应用中仍然会使用到，所以你的项目中可能会用这样的代码：</p>
<pre><code>// http://localhost:8080/index.html
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，但不知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
function jsonpCallback(data) {
  console.log(data);
}
const url = &apos;http://localhost:8081/data?callback=jsonpCallback&apos;;
const script = document.createElement(&apos;script&apos;);
script.src = url;
document.body.appendChild(script);
</code></pre><p>因为返回的信息会当做脚本文件来执行，一旦返回的脚本内容出错了，也是无法捕捉到错误的信息。</p>
<p><img src="https://pic4.zhimg.com/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_hd.jpg" alt=""></p>
<p>解决办法也不难，跟之前一样，在添加动态添加脚本的时候加上 crossOrigin，并且在后端配上相应的 CORS 字段即可.</p>
<pre><code>const script = document.createElement(&apos;script&apos;);
script.crossOrigin = &apos;anonymous&apos;;
script.src = url;
document.body.appendChild(script);
</code></pre><p>读者可以通过 <code>npm run jsonp</code> 查看效果</p>
<p><img src="https://pic4.zhimg.com/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_hd.jpg" alt=""></p>
<p>知道原理之后你可能会觉得没什么，不就是给每个动态生成的脚本添加 crossOrigin 字段嘛，但是在实际工程中，你可能是面向很多库来编程，比如使用 jQuery，Seajs 或者 webpack 来异步加载脚本，许多库封装了异步加载脚本的能力，以 jQeury 为例你可能是这样来触发异步脚本。</p>
<pre><code>$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>假如这些库中没有提供 crossOrigin 的能力的话(jQuery jsonp 可能有，假装你不知道)，那你只能去修改人家写的源代码了，所以我这里提供一个思路，就是去劫持 document.createElement，从根源上去为每个动态生成的脚本添加 crossOrigin 字段。</p>
<pre><code>document.createElement = (function() {
  const fn = document.createElement.bind(document);
  return function(type) {
    const result = fn(type);
    if(type === &apos;script&apos;) {
      result.crossOrigin = &apos;anonymous&apos;;
    }
    return result;
  }
})();
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，也知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>效果也是一样的，读者可以通过 <code>npm run jsonpjq</code> 来查看效果：</p>
<p><img src="https://pic4.zhimg.com/v2-30d51a96cdb3286edd1e5a88e9f794bb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-30d51a96cdb3286edd1e5a88e9f794bb_hd.jpg" alt=""></p>
<p>这样重写 createElement 理论上没什么问题，但是入侵了原本的代码，不保证一定不会出错，在工程上还是需要多尝试下看看再使用，可能存在兼容性上问题，如果你觉得会出现什么问题的话也欢迎留言讨论下。</p>
<p>关于 Script error 的问题就写到这里，如果你理解了上面的内容，基本上绝大部分的 Script error 都能迎刃而解。</p>
<h2 id="window-onerror-能否捕获-iframe-的错误"><a href="#window-onerror-能否捕获-iframe-的错误" class="headerlink" title="window.onerror 能否捕获 iframe 的错误"></a>window.onerror 能否捕获 iframe 的错误</h2><p>当你的页面有使用 iframe 的时候，你需要对你引入的 iframe 做异常监控的处理，否则一旦你引入的 iframe 页面出现了问题，你的主站显示不出来，而你却浑然不知。</p>
<p>首先需要强调，父窗口直接使用 window.onerror 是无法直接捕获，如果你想要捕获 iframe 的异常的话，有分好几种情况。</p>
<p>如果你的 iframe 页面和你的主站是同域名的话，直接给 iframe 添加 onerror 事件即可。</p>
<pre><code>&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  window.frames[0].onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道 iframe 的错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
</code></pre><p>读者可以通过 <code>npm run iframe</code> 查看效果：</p>
<p><img src="https://pic2.zhimg.com/v2-3edcb5686e27ab11f5f3c9c1644986d0_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3edcb5686e27ab11f5f3c9c1644986d0_hd.jpg" alt=""></p>
<p>如果你嵌入的 iframe 页面和你的主站不是同个域名的，但是 iframe 内容不属于第三方，是你可以控制的，那么可以通过与 iframe 通信的方式将异常信息抛给主站接收。与 iframe 通信的方式有很多，常用的如：postMessage，hash 或者 name 字段跨域等等，这里就不展开了，感兴趣的话可以看：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>如果是非同域且网站不受自己控制的话，除了通过控制台看到详细的错误信息外，没办法捕获，这是出于安全性的考虑，你引入了一个百度首页，人家页面报出的错误凭啥让你去监控呢，这会引出很多安全性的问题。</p>
<h2 id="压缩代码如何定位到脚本异常位置"><a href="#压缩代码如何定位到脚本异常位置" class="headerlink" title="压缩代码如何定位到脚本异常位置"></a>压缩代码如何定位到脚本异常位置</h2><p>线上的代码几乎都经过了压缩处理，几十个文件打包成了一个并丑化代码，当我们收到 <code>a is not defined</code> 的时候，我们根本不知道这个变量 a 究竟是什么含义，此时报错的错误日志显然是无效的。</p>
<p>第一想到的办法是利用 sourcemap 定位到错误代码的具体位置，详细内容可以参考：<a href="https://link.zhihu.com/?target=https%3A//github.com/joeyguo/blog/issues/14" target="_blank" rel="noopener">Sourcemap 定位脚本错误</a></p>
<p>另外也可以通过在打包的时候，在每个合并的文件之间添加几行空格，并相应加上一些注释，这样在定位问题的时候很容易可以知道是哪个文件报的错误，然后再通过一些关键词的搜索，可以快速地定位到问题的所在位置。</p>
<h2 id="收集异常信息量太多，怎么办"><a href="#收集异常信息量太多，怎么办" class="headerlink" title="收集异常信息量太多，怎么办"></a>收集异常信息量太多，怎么办</h2><p>如果你的网站访问量很大，假如网页的 PV 有 1kw，那么一个必然的错误发送的信息就有 1kw 条，我们可以给网站设置一个采集率：</p>
<pre><code>Reporter.send = function(data) {
  // 只采集 30%
  if(Math.random() &lt; 0.3) {
    send(data)      // 上报错误信息
  }
}
</code></pre><p>这个采集率可以通过具体实际的情况来设定，方法多样化，可以使用一个随机数，也可以具体根据用户的某些特征来进行判定。</p>
<h3 id="错误上报的方法："><a href="#错误上报的方法：" class="headerlink" title="错误上报的方法："></a>错误上报的方法：</h3><ul>
<li>一：Ajax上传，Ajax上报就是在上文注释错误捕获的地方发起Ajax请求，来向服务器发送错误信息。</li>
<li>二：利用Image对象发送信息(new Image()).src=”<a href="http://post.error.com?data=xxx&quot;" target="_blank" rel="noopener">http://post.error.com?data=xxx&quot;</a></li>
<li>跨域js文件错误是否可以捕获：<br>   答案是可以，错误提示是   script error<br>解决办法，跨域js文件获取是有限制的，如果想获取其他域下的js错误需要在script标签里添加crossorigin属性，然后服务器端要设置header(‘Access-Control-Allow-Origin: *’),或者 指定域名。</li>
</ul>
<p>上面差不多是我对前端代码监控的一些理解，说起来容易，但是一旦在工程化运用，难免需要考虑到兼容性等种种问题，读者可以通过自己的具体情况进行调整，前端代码异常监控对于我们的网站的稳定性起着至关重要的作用。如若文中所有不对的地方，还望指正。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/14/JavaScript函数柯里化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/14/JavaScript函数柯里化/" itemprop="url">JavaScript函数柯里化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-14T20:00:52+08:00">
                2016-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h2><h2 id="官方的说法"><a href="#官方的说法" class="headerlink" title="官方的说法"></a>官方的说法</h2><p>在计算机科学中，<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%259F%25AF%25E9%2587%258C%25E5%258C%2596" target="_blank" rel="noopener">柯里化</a>（英语：<code>Currying</code>），又译为<code>卡瑞化</code>或<code>加里化</code>，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由<code>克里斯托弗·斯特雷奇</code>以逻辑学家<code>哈斯凯尔·加里</code>命名的，尽管它是<code>Moses Schönfinkel</code>和<code>戈特洛布·弗雷格发明的</code>。</p>
<p>在直觉上，柯里化声称如果你固定某些参数，你将得到接受余下参数的一个函数。</p>
<p>在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的<code>lambda</code>演算中，研究带有多个参数的函数的方式。</p>
<p>函数柯里化的对偶是<code>Uncurrying</code>，一种使用匿名单参数函数来实现多参数函数的方法。</p>
<h2 id="方便的理解"><a href="#方便的理解" class="headerlink" title="方便的理解"></a>方便的理解</h2><blockquote>
<p>Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
</blockquote>
<p>如果我们需要实现一个求三个数之和的函数：</p>
<pre><code>function add(x, y, z) {
  return x + y + z;
}
console.log(add(1, 2, 3)); // 6
var add = function(x) {
  return function(y) {
    return function(z) {
      return x + y + z;
    }
  }
}

var addOne = add(1);
var addOneAndTwo = addOne(2);
var addOneAndTwoAndThree = addOneAndTwo(3);

console.log(addOneAndTwoAndThree);
</code></pre><p>这里我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的<code>curry</code>帮助函数（<code>helper function</code>）使这类函数的定义和调用更加容易。</p>
<p>用<code>ES6</code>的箭头函数，我们可以将上面的<code>add</code>实现成这样：</p>
<pre><code>const add = x =&gt; y =&gt; z =&gt; x + y + z;
</code></pre><p>好像使用箭头函数更清晰了许多。</p>
<h2 id="偏函数？"><a href="#偏函数？" class="headerlink" title="偏函数？"></a>偏函数？</h2><p>来看这个函数：</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}
</code></pre><p>有这样的一个场景：我们需要对多个不同的接口发起<code>HTTP</code>请求，有下列两种做法：</p>
<ul>
<li>在调用<code>ajax()</code>函数时，传入全局<code>URL</code>常量。</li>
<li>创建一个已经预设<code>URL</code>实参的函数引用。</li>
</ul>
<p>下面我们创建一个新函数，其内部仍然发起<code>ajax()</code>请求，此外在等待接收另外两个实参的同时，我们手动将<code>ajax()</code>第一个实参设置成你关心的<code>API</code>地址。</p>
<p>对于第一种做法，我们可能产生如下调用方式：</p>
<pre><code>function ajaxTest1(data, callback) {
  ajax(&apos;http://www.test.com/test1&apos;, data, callback);
}

function ajaxTest2(data, callback) {
  ajax(&apos;http://www.test.com/test2&apos;, data, callback);
}
</code></pre><p>对于这两个类似的函数，我们还可以提取出如下的模式：</p>
<pre><code>function beginTest(callback) {
  ajaxTest1({
    data: GLOBAL_TEST_1,
  }, callback);
}
</code></pre><p>相信您已经看到了这样的模式：我们在函数调用现场（<code>function call-site</code>），将实参应用（<code>apply</code>） 于形参。如你所见，我们一开始仅应用了部分实参 —— 具体是将实参应用到<code>URL</code>形参 —— 剩下的实参稍后再应用。</p>
<p>上述概念即为偏函数的定义，偏函数一个减少函数参数个数的过程；这里的参数个数指的是希望传入的形参的数量。我们通过<code>ajaxTest1()</code>把原函数<code>ajax()</code>的参数个数从<code>3</code>个减少到了<code>2</code>个。</p>
<p>我们这样定义一个<code>partial()</code>函数：</p>
<pre><code>function partial(fn, ...presetArgs) {
  return function partiallyApplied(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  }
}
</code></pre><p><code>partial()</code>函数接收<code>fn</code>参数，来表示被我们偏应用实参（<code>partially apply</code>）的函数。接着，<code>fn</code>形参之后，<code>presetArgs</code>数组收集了后面传入的实参，保存起来稍后使用。</p>
<p>我们创建并<code>return</code>了一个新的内部函数（为了清晰明了，我们把它命名为<code>partiallyApplied(..)</code>），该函数中，<code>laterArgs</code>数组收集了全部实参。</p>
<p>使用箭头函数，则更为简洁：</p>
<pre><code>var partial =
  (fn, ...presetArgs) =&gt;
    (...laterArgs) =&gt;
      fn(...presetArgs, ...laterArgs);
</code></pre><p>使用偏函数的这种模式，我们重构之前的代码：</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}

var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);
var ajaxTest2 = partial(ajax, &apos;http://www.test.com/test1&apos;);
</code></pre><p>再次思考<code>beginTest()</code>函数，我们使用<code>partial()</code>来重构它应该怎么做呢？</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}

// 版本1
var beginTest = partial(ajax, &apos;http://www.test.com/test1&apos;, {
  data: GLOBAL_TEST_1,
});

// 版本2
var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);
var beginTest = partial(ajaxTest1, {
  data: GLOBAL_TEST_1,
});
</code></pre><h2 id="一次传一个"><a href="#一次传一个" class="headerlink" title="一次传一个"></a>一次传一个</h2><p>相信你已经在上述例子中看到了版本2比起版本1的优势所在了，没错，柯里化就是：将一个带有多个参数的函数转换为一次一个的函数的过程。每次调用函数时，它只接受一个参数，并返回一个函数，直到传递所有参数为止。</p>
<blockquote>
<p>The process of converting a function that takes multiple arguments into a function that takes them one at a time.</p>
<p>Each time the function is called it only accepts one argument and returns a function that takes one argument until all arguments are passed.</p>
</blockquote>
<p>假设我们已经创建了一个柯里化版本的<code>ajax()</code>函数<code>curriedAjax()</code>：</p>
<pre><code>curriedAjax(&apos;http://www.test.com/test1&apos;)
  ({
    data: GLOBAL_TEST_1,
  })
  (function callback(data) {
    // dosomething
  });
</code></pre><p>我们将三次调用分别拆解开来，这也许有助于我们理解整个过程：</p>
<pre><code>var ajaxTest1 = curriedAjax(&apos;http://www.test.com/test1&apos;);

var beginTest = ajaxTest1({
  data: GLOBAL_TEST_1,
});

var ajaxCallback = beginTest(function callback(data) {
  // dosomething
});
</code></pre><h2 id="实现柯里化"><a href="#实现柯里化" class="headerlink" title="实现柯里化"></a>实现柯里化</h2><p>那么，我们如何来实现一个自动的柯里化的函数呢？</p>
<pre><code>var currying = function(fn) {
  var args = [];

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}
</code></pre><p>调用上述<code>currying()</code>函数：</p>
<pre><code>var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = currying(cost);

cost(100); // 传入了参数，不真正求值
cost(200); // 传入了参数，不真正求值
cost(300); // 传入了参数，不真正求值

console.log(cost()); // 求值并且输出600
</code></pre><p>上述函数是我之前的<a href="http://link.zhihu.com/?target=https%3A//github.com/xingbofeng/JavaScript-design-patterns/blob/master/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0.md%23currying" target="_blank" rel="noopener">JavaScript设计模式与开发实践读书笔记之闭包与高阶函数</a>所写的<code>currying</code>版本，现在仔细思考后发现仍旧有一些问题。</p>
<blockquote>
<p>我们在使用柯里化时，要注意同时为函数预传的参数的情况。</p>
</blockquote>
<p>因此把上述柯里化函数更改如下：</p>
<pre><code>var currying = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}
</code></pre><p>使用实例：</p>
<pre><code>var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = currying(cost, 100);
cost(200); // 传入了参数，不真正求值
cost(300); // 传入了参数，不真正求值

console.log(cost()); // 求值并且输出600
</code></pre><p>你可能会觉得每次都要在最后调用一下不带参数的<code>cost()</code>函数比较麻烦，并且在<code>cost()</code>函数都要使用<code>arguments</code>参数不符合你的预期。我们知道函数都有一个<code>length</code>属性，表明函数期望接受的参数个数。因此我们可以充分利用预传参数的这个特点。</p>
<p>借鉴自<a href="http://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">mqyqingfeng</a>：</p>
<pre><code>function sub_curry(fn) {
  var args = [].slice.call(arguments, 1);
  return function() {
    return fn.apply(this, args.concat([].slice.call(arguments)));
  };
}

function curry(fn, length) {

  length = length || fn.length;

  var slice = Array.prototype.slice;

  return function() {
    if (arguments.length &lt; length) {
      var combined = [fn].concat(slice.call(arguments));
      return curry(sub_curry.apply(this, combined), length - arguments.length);
    } else {
      return fn.apply(this, arguments);
    }
  };
}
</code></pre><p>在上述函数中，我们在currying的返回函数中，每次把<code>arguments.length</code>和<code>fn.length</code>作比较，一旦<code>arguments.length</code>达到了<code>fn.length</code>的数量，我们就去调用<code>fn</code>(<code>return fn.apply(this, arguments);</code>)</p>
<p>验证：</p>
<pre><code>var fn = curry(function(a, b, c) {
  return [a, b, c];
});

fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><h2 id="bind方法的实现"><a href="#bind方法的实现" class="headerlink" title="bind方法的实现"></a>bind方法的实现</h2><p>使用柯里化，能够很方便地借用<code>call()</code>或者<code>apply()</code>实现<code>bind()</code>方法的<code>polyfill</code>。</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function(context) {
  var me = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var innerArgs = Array.prototype.slice.call(arguments);
    var finalArgs = args.concat(innerArgs);
    return me.apply(contenxt, finalArgs);
  }
}
</code></pre><p>上述函数有的问题在于不能兼容构造函数。我们通过判断this指向的对象的原型属性，来判断这个函数是否通过<code>new</code>作为构造函数调用，来使得上述<code>bind</code>方法兼容构造函数。</p>
<p><a href="http://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind() by MDN</a>如下说到：</p>
<blockquote>
<p>绑定函数适用于用new操作符 new 去构造一个由目标函数创建的新的实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。然而, 原先提供的那些参数仍然会被前置到构造函数调用的前面。</p>
</blockquote>
<p>这是<a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/10733304/" target="_blank" rel="noopener">基于MVC的JavaScript Web富应用开发</a>的<code>bind()</code>方法实现：</p>
<pre><code>Function.prototype.bind = function(oThis) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
  }

  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function() {},
    fBound = function() {
      return fToBind.apply(
        this instanceof fNOP &amp;&amp; oThis ? this : oThis || window,
        aArgs.concat(Array.prototype.slice.call(arguments))
      );
    };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
</code></pre><h2 id="反柯里化（uncurrying）"><a href="#反柯里化（uncurrying）" class="headerlink" title="反柯里化（uncurrying）"></a>反柯里化（uncurrying）</h2><p>可能遇到这种情况：拿到一个柯里化后的函数，却想要它柯里化之前的版本，这本质上就是想将类似<code>f(1)(2)(3)</code>的函数变回类似<code>g(1,2,3)</code>的函数。</p>
<p>下面是简单的<code>uncurrying</code>的实现方式：</p>
<pre><code>function uncurrying(fn) {
  return function(...args) {
    var ret = fn;

    for (let i = 0; i &lt; args.length; i++) {
      ret = ret(args[i]); // 反复调用currying版本的函数
    }

    return ret; // 返回结果
  };
}
</code></pre><blockquote>
<p>注意，不要以为uncurrying后的函数和currying之前的函数一模一样，它们只是行为类似！</p>
</blockquote>
<pre><code>var currying = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}

function uncurrying(fn) {
  return function(...args) {
    var ret = fn;

    for (let i = 0; i &lt; args.length; i++) {
      ret = ret(args[i]); // 反复调用currying版本的函数
    }

    return ret; // 返回结果
  };
}

var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var curryingCost = currying(cost);
var uncurryingCost = uncurrying(curryingCost);
console.log(uncurryingCost(100, 200, 300)()); // 600
</code></pre><h2 id="柯里化或偏函数有什么用？"><a href="#柯里化或偏函数有什么用？" class="headerlink" title="柯里化或偏函数有什么用？"></a>柯里化或偏函数有什么用？</h2><p>无论是柯里化还是偏应用，我们都能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。</p>
<p>另一个最能体现柯里化应用的的是，当函数只有一个形参时，我们能够比较容易地组合它们（<code>单一职责原则（Single responsibility principle）</code>）。因此，如果一个函数最终需要三个实参，那么它被柯里化以后会变成需要三次调用，每次调用需要一个实参的函数。当我们组合函数时，这种单元函数的形式会让我们处理起来更简单。</p>
<p>归纳下来，主要为以下常见的三个用途：</p>
<ul>
<li>延迟计算</li>
<li>参数复用</li>
<li>动态生成函数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/08/HTML5的Websocket/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/HTML5的Websocket/" itemprop="url">HTML5的Websocket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-08T22:18:50+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>先请来TA的邻居：*<br>http：无状态、基于tcp请求/响应模式的应用层协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么）tcp：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) 传输层协议。（看啊，大阅兵，如此规整有秩序）</li>
</ul>
</blockquote>
<h2 id="为什么要引入Websocket："><a href="#为什么要引入Websocket：" class="headerlink" title="为什么要引入Websocket："></a>为什么要引入Websocket：</h2><blockquote>
<p>RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。</p>
</blockquote>
<p>long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。</p>
<p><img src="https://pic3.zhimg.com/v2-b900392bfe564de524ec5460a2b5d235_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b900392bfe564de524ec5460a2b5d235_hd.jpg" alt=""></p>
<p>从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p>
<p>这个时候，Websocket出现了。</p>
<h2 id="Websocket是什么："><a href="#Websocket是什么：" class="headerlink" title="Websocket是什么："></a>Websocket是什么：</h2><blockquote>
<p>RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。</p>
</blockquote>
<p>对，划重点：双向通信</p>
<p>Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以主动向客户端推送消息。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。</p>
<p>其特点：</p>
<p>（1）握手阶段采用 HTTP 协议，默认端口是80和443</p>
<p>（2）建立在TCP协议基础之上，和http协议同属于应用层</p>
<p>（4）可以发送文本，也可以发送二进制数据</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信</p>
<p>（6）协议标识符是ws（如果加密，为wss），如ws://localhost:8023</p>
<p>简单来说，Websocket协议分为两部分：握手和数据传输。</p>
<p><img src="https://pic2.zhimg.com/v2-5b1e92b99d352ba977f69cbe28604ecf_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5b1e92b99d352ba977f69cbe28604ecf_hd.jpg" alt=""></p>
<h2 id="Websocket-API："><a href="#Websocket-API：" class="headerlink" title="Websocket API："></a>Websocket API：</h2><blockquote>
<p>这里是指客户端 API。</p>
</blockquote>
<h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><ol>
<li><code>通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。</code></li>
<li><code>const ws =`</code>new<code></code>WebSocket(‘ws://localhost:8023’);`</li>
</ol>
<h2 id="Websocket事件"><a href="#Websocket事件" class="headerlink" title="Websocket事件"></a>Websocket事件</h2><ol>
<li><code>WebSocket`</code>是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。`</li>
</ol>
<p>open:</p>
<p>服务端响应WebSocket连接请求，就会触发open事件。onopen是响应的回调函数。</p>
<p><code>// 连接请求open事件处理：</code></p>
<pre><code>ws.onopen=e=&gt;{
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果要指定多个回调函数，可以使用addEventListener方法。</p>
<pre><code>ws.addEventListener(&apos;open&apos;, e =&gt; {
 ws.send(`Hello ${e}`);
});
</code></pre><p>当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。</p>
<p>Message:</p>
<p>收到服务器数据，会触发消息事件，onmessage是响应的回调函数。如下：</p>
<pre><code>// 接受文本消息的事件处理：
ws.onmessage = e =&gt; {
const data = e.data;
if (typeof data === &quot;string&quot;) {
       console.log(&quot;Received string message &quot;,data);
} else if (data instanceof Blob) {
       console.log(&quot;Received blob message &quot;, data);
}
};
</code></pre><p>服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p>
<p>Error</p>
<p>发生错误会触发error事件, onerror是响应的回调函数, 会导致连接关闭。</p>
<pre><code>//异常处理
ws.onerror = e =&gt; {
   console.log(&quot;WebSocket Error: &quot; , e);
   handleErrors(e);
};
</code></pre><p>当连接关闭时触发close事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再通信。</p>
<p>WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧）</p>
<pre><code>//关闭连接处理
ws.onclose = e =&gt; {
const code = e.code;
const reason = e.reason;
   console.log(&quot;Connection close&quot;, code, reason);
};
</code></pre><h2 id="WebSocket-方法："><a href="#WebSocket-方法：" class="headerlink" title="WebSocket 方法："></a>WebSocket 方法：</h2><blockquote>
<p>WebSocket 对象有两个方法：send 和 close</p>
</blockquote>
<p>send:</p>
<p>客户端和服务器建立连接后，可以调用send方法去发送消息。</p>
<pre><code>//发送一个文本消息
ws.send(&quot;this is websocket&quot;);
</code></pre><p>在open事件的回调中调用send()方法传送数据：</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;);
ws.onopen = e =&gt; {
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState.</p>
<p>close</p>
<p>close方法用来关闭连接。调用close方法后，将不能发送数据。close方法可以传入两个可选的参数，code 和reason, 以告诉服务端为什么终止连接。</p>
<pre><code>ws.close();

//1000是状态码，代表正常结束。
ws.close(1000, &quot;Closing normally&quot;);
</code></pre><h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><ul>
<li>readyState：</li>
</ul>
<p>readyState值表示连接状态，是只读属性。它有以下四个值：</p>
<blockquote>
<p>WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开</p>
</blockquote>
<p>除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。</p>
<pre><code>function bindEventHandler(data) {
if (ws.readyState === WebSocket.OPEN) {
       ws.send(data);
} else {
//do something
}
} 
</code></pre><p>bufferedAmount：</p>
<p>当客户端传输大量数据时，浏览器会缓存将要流出的数据，bufferedAmount属性可判断有多少字节的二进制数据没有发送出去，发送是否结束。</p>
<pre><code>ws.onopen = function () {
   setInterval( function() {
//缓存未满的时候发送
if (ws.bufferedAmount &lt; 1024 * 5) {
           ws.send(data);
}
}, 2000);
};
</code></pre><p>protocol：</p>
<p>protocol代表客户端使用的WebSocket协议。当握手协议未成功，这个属性是空。</p>
<ul>
<li>接下来，我们说说握手阶段过程。*</li>
</ul>
<p>当我们创建Websocket实例对象与服务器建立连接时，</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;)；
</code></pre><p>首先客户端向服务器发起一个握手请求，其请求报文的内容如下：</p>
<pre><code>GET /game HTTP/1.1
Host: 10.242.17.102:8023
Cache-Control: no-cache
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Protocol: game
Sec-WebSocket-Version: 10
Origin: http://192.168.185.16
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
</code></pre><p>从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。</p>
<ul>
<li>Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。</li>
<li>Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信</li>
<li>Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议</li>
<li>Sec-WebSocket-Version: 通知服务器所使用的协议版本</li>
</ul>
<p>服务器响应：</p>
<pre><code>当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。 
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ=
</code></pre><ul>
<li>101 状态码，表示要转换协议啦</li>
<li>Upgrde: 通知客户端将要升级成Websocket协议</li>
<li>Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-05e821d0db32cf8cb5ebf51625870cb1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-05e821d0db32cf8cb5ebf51625870cb1_hd.jpg" alt=""></p>
<p>至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/25/移动端H5页面返回并且刷新页面/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/25/移动端H5页面返回并且刷新页面/" itemprop="url">移动端H5页面返回并且刷新页面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-25T20:08:31+08:00">
                2016-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目中的需求：点击浏览器中的返回按钮，要让页面重新加载资源。因为这部分的资源每次去加载的内容都不一样，如果返回的时候，还是看到原先的内容，那做这个内容块的意义就很小了；而如果用户看完了这部分内容，再返回来的时候，这个地方换成了新的内容，这样就能体现这部分的价值了。</p>
<p>而对于浏览器来说，大部分浏览器的返回是直接使用缓存的，不会执行任何的javascript代码。原因：部分浏览器在后退时不会触发onload事件，這是HTML5世代浏览器新增的特性之一——Back-Forward Cache(简称bfcache)</p>
<p><strong>什么是bfcache？</strong></p>
<p>bfcache，即back-forward cache，可称为“往返缓存”，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存不仅保存页面数据，还保存了DOM和JS的状态，实际上是将整个页面都保存在内存里。如果页面位于bfcache中，那么再次打开该页面就不会触发onload事件</p>
<h3 id="pageshow事件"><a href="#pageshow事件" class="headerlink" title="pageshow事件"></a>pageshow事件</h3><p>这个事件在用户浏览网页时触发，pageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， pageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发。</p>
<h3 id="pagehide事件"><a href="#pagehide事件" class="headerlink" title="pagehide事件"></a>pagehide事件</h3><p>该事件会在用户离开网页时触发。离开网页有多种方式。如点击一个链接，刷新页面，提交表单，关闭浏览器等。pagehide 事件有时可以替代 unload事件，但 unload 事件触发后无法缓存页面。</p>
<h3 id="persisted属性"><a href="#persisted属性" class="headerlink" title="persisted属性"></a>persisted属性</h3><p>pageshow事件和pagehide事件的event对象还包含一个名为persisted的布尔值属性。</p>
<ul>
<li>对于pageshow事件，如果页面是从bfcache中加载的，则这个属性的值为true；否则，这个属性的值为false。</li>
<li>对于pagehide事件，如果页面在卸载之后被保存在bfcache中，则这个属性的值为true；否则，这个属性的值为false。</li>
</ul>
<p>不同的浏览器在对当前窗口‘打开’历史记录中的前一个页面的表现上并不统一，这和浏览器的实现以及页面本身的设置有关系。</p>
<p><strong>解决方案：</strong></p>
<p><strong>javascript监听pageshow事件阻止页面进入bfcache</strong></p>
<pre><code> window.addEventListener(&apos;pageshow&apos;, function (e) {
     if (e.persisted) {
         window.location.reload()
     }
})
</code></pre><p>在uc和微信中测试通过，但是在某些安卓手机自带的浏览器中无效。</p>
<p><strong>javascript监听pagehide事件阻止页面进入bfcache</strong></p>
<pre><code>window.addEventListener(&apos;pagehide&apos;, function (e) {
    var dom = document.body;
    dom.children.remove();
    setTimeout(function () {
        dom.appendChild(&quot;&lt;script type=&apos;text/javascript&apos;&gt;window.location.reload();&lt;\/script&gt;&quot;);
    });
});
</code></pre><p><strong>设置meta标签，清除页面缓存</strong></p>
<pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt;
&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;
&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;
</code></pre><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下<br>Public指示响应可被任何缓存区缓存<br>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。<br>注：有些情况下设置清除缓存也没有起到作用，我自己做的这个h5页面就没有起到效果。具体情况还是要具体分析。</p>
<p><strong>我遇到的情况：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">     &lt;iframe id=&quot;iframe&quot; src=&quot;https://cpu.baidu.com/xx/xx/xxx&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个iframe中的地址每次刷新页面都会有不同的内容推送给用户。进入iframe中的内容之后，按返回按钮返回来想进行页面自动刷新，为的就是让用户看到新的内容。</p>
<p>做法：</p>
<p>使用pageshow进行整个页面刷新</p>
<pre><code>window.addEventListener(&apos;pageshow&apos;, function (e) {
    if (e.persisted) {
        window.location.reload()
    }
})
</code></pre><p>这样可以实现。</p>
<p>后面又觉得不妥，没有因为这个小部分而进行整个页面刷新，想到了另一种思路：因为这个iframe中的内容是动态的，可以对其进行定时器设置，如下：</p>
<pre><code>let iframe = document.getElementById(&apos;iframe&apos;)
setInterval(() =&gt; {
    iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
},15000)
</code></pre><p>这样也可以实现自己的功能。</p>
<p>最后可以结合一下：</p>
<pre><code>let iframe = document.getElementById(&apos;iframe&apos;)
window.addEventListener(&apos;pageshow&apos;, function (e) {
    if (e.persisted) {
        iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
    }
})
</code></pre><p>这样做也有好处，可以避免使用定时器，对网页的性能也是比较好。但是这个方法在返回的时候，可以看到iframe里面内容的重新加载，会有一个时间间隙。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/21/跨域，你需要知道的全在这里/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/21/跨域，你需要知道的全在这里/" itemprop="url">跨域，你需要知道的全在这里</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-21T11:05:10+08:00">
                2016-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在面试的时候常被问到如何解决跨域的问题，看了网上的一些文章后，许多文章并没有介绍清楚，经常使读者(我)感到困惑，所以今天我整理一下常用的跨域技巧，写这篇关于跨域的文章目的在于：</p>
<ol>
<li>介绍常见的跨域的解决方案以及其优缺点</li>
<li>模拟实际的跨域场景，在每种方案后给出一个简单的实例，能够让读者和我一起敲代码，直观地理解这些跨域技巧</li>
</ol>
<p>如果觉得本文有帮助，可以点 star 鼓励下，本文所有代码都可以从 github 仓库下载，读者可以按照下述打开:</p>
<pre><code>git clone https://github.com/happylindz/blog.git
cd blog/code/crossOrigin/
yarn
</code></pre><p>建议你 clone 下来，方便你阅读代码，跟我一起测试。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>使用过 Ajax 的同学都知道其便利性，可以在不向服务端提交完整页面的情况下，实现局部刷新，在当今 SPA 应用普遍使用，但是浏览器处于对安全方面的考虑，不允许跨域调用其它页面的对象，这对于我们在注入 iframe 或是 ajax 应用上带来不少麻烦。</p>
<p>简单来说，只有当协议，域名，端口号相同的时候才算是同一个域名，否则，均认为需要做跨域处理。</p>
<p><img src="https://pic4.zhimg.com/v2-5fa29773fc875bf58e4513fdba402bf0_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-5fa29773fc875bf58e4513fdba402bf0_hd.jpg" alt=""></p>
<h2 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h2><p>今天一共介绍七种常用的跨域技巧，关于跨域技巧大致可以分为 iframe 跨域和 API 跨域请求。</p>
<p>下面就先介绍三种 API 跨域的方法:</p>
<h2 id="1-JSONP："><a href="#1-JSONP：" class="headerlink" title="1. JSONP："></a>1. JSONP：</h2><p>只要说到跨域，就必须聊到 JSONP，JSONP 全称为：JSON with padding，可用于解决老版本浏览器的跨域数据访问问题。</p>
<p>由于 web 页面上调用 js 文件不受浏览器同源策略的影响，所以通过 script 标签可以进行跨域请求：</p>
<ol>
<li>首先前端需要先设置好回调函数，并将其作为 url 的参数。</li>
<li>服务端接收到请求后，通过该参数获取到回调函数名，并将数据放在参数中将其返回</li>
<li>收到结果后因为是 script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的</li>
</ol>
<p>jsonp 之所以能够跨域的关键在于页面调用 JS 脚本是不受同源策略的影响，相当于向后端发起一条 http 请求，跟后端约定好函数名，后端拿到函数名，动态计算出返回结果并返回给前端执行 JS 脚本，相当于是一种 “动态 JS 脚本”</p>
<p>接下来我们通过一个实例来尝试：</p>
<p>后端逻辑：</p>
<pre><code>// jsonp/server.js
const url = require(&apos;url&apos;);

require(&apos;http&apos;).createServer((req, res) =&gt; {
    const data = {
        x: 10
    };
    // 拿到回调函数名
    const callback = url.parse(req.url, true).query.callback;
    console.log(callback);
    res.writeHead(200);
    res.end(`${callback}(${JSON.stringify(data)})`);

}).listen(3000, &apos;127.0.0.1&apos;);

console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);
</code></pre><p>前端逻辑：</p>
<pre><code>// jsonp/index.html
&lt;script&gt;
    function jsonpCallback(data) {
        alert(&apos;获得 X 数据:&apos; + data.x);
    }
&lt;/script&gt;
&lt;script src=&quot;http://127.0.0.1:3000?callback=jsonpCallback&quot;&gt;&lt;/script&gt;
</code></pre><p>然后在终端开启服务：</p>
<p>之所以能用脚本指令，是因为我在 package.json 里面设置好了脚本命令：</p>
<pre><code>{
  // 输入 yarn jsonp 等于 &quot;node ./jsonp/server.js &amp; http-server ./jsonp&quot;
  &quot;scripts&quot;: {
    &quot;jsonp&quot;: &quot;node ./jsonp/server.js &amp; http-server ./jsonp&quot;,
    &quot;cors&quot;: &quot;node ./cors/server.js &amp; http-server ./cors&quot;,
    &quot;proxy&quot;: &quot;node ./serverProxy/server.js&quot;,
    &quot;hash&quot;: &quot;http-server ./hash/client/ -p 8080 &amp; http-server ./hash/server/ -p 8081&quot;,
    &quot;name&quot;: &quot;http-server ./name/client/ -p 8080 &amp; http-server ./name/server/ -p 8081&quot;,
    &quot;postMessage&quot;: &quot;http-server ./postMessage/client/ -p 8080 &amp; http-server ./postMessage/server/ -p 8081&quot;,
    &quot;domain&quot;: &quot;http-server ./domain/client/ -p 8080 &amp; http-server ./domain/server/ -p 8081&quot;
  },
  // ...
}

yarn jsonp
// 因为端口 3000 和 8080 分别属于不同域名下
// 在 localhost:3000 查看效果，即可收到后台返回的数据 10
</code></pre><p>打开浏览器访问 <code>localhost:8080</code> 即可看到获取到的数据。</p>
<p><img src="https://pic2.zhimg.com/v2-1bd48c160110899a8ad7e08e56d36560_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-1bd48c160110899a8ad7e08e56d36560_hd.jpg" alt=""></p>
<p>至此，通过 JSONP 跨域获取数据已经成功了，但是通过这种方式也存在着一定的优缺点：</p>
<p>优点：</p>
<ol>
<li>它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制</li>
<li>兼容性很好，在古老的浏览器也能很好的运行</li>
<li>不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。</li>
</ol>
<p>缺点：</p>
<ol>
<li>它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。</li>
<li>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题</li>
<li>无法捕获 Jsonp 请求时的连接异常，只能通过超时进行处理</li>
</ol>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS:"></a>CORS:</h2><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。</p>
<p>CORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p>
<p>前端逻辑很简单，只要正常发起 ajax 请求即可:</p>
<pre><code>// cors/index.html
&lt;script&gt;
    const xhr = new XMLHttpRequest();
    xhr.open(&apos;GET&apos;, &apos;http://127.0.0.1:3000&apos;, true);
    xhr.onreadystatechange = function() {
        if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
            alert(xhr.responseText);
        }
    }
    xhr.send(null);
&lt;/script&gt;
</code></pre><p>这似乎跟一次正常的异步 ajax 请求没有什么区别，关键是在服务端收到请求后的处理：</p>
<pre><code>// cors/server.js
require(&apos;http&apos;).createServer((req, res) =&gt; {

    res.writeHead(200, {
        &apos;Access-Control-Allow-Origin&apos;: &apos;http://localhost:8080&apos;,
        &apos;Content-Type&apos;: &apos;text/html;charset=utf-8&apos;,
    });
    res.end(&apos;这是你要的数据：1111&apos;);

}).listen(3000, &apos;127.0.0.1&apos;);

console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);
</code></pre><p>关键是在于设置相应头中的 Access-Control-Allow-Origin，该值要与请求头中 Origin 一致才能生效，否则将跨域失败。</p>
<p>然后我们执行命令：<code>yarn cors</code> 打开浏览器访问 <code>localhost:3000</code> 即可看到效果：</p>
<p><img src="https://pic2.zhimg.com/v2-13ee0a40a998948019749da80e1d259a_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-13ee0a40a998948019749da80e1d259a_hd.jpg" alt=""></p>
<p>成功的关键在于 Access-Control-Allow-Origin 是否包含请求页面的域名，如果不包含的话，浏览器将认为这是一次失败的异步请求，将会调用 xhr.onerror 中的函数。</p>
<p>CORS 的优缺点：</p>
<ol>
<li>使用简单方便，更为安全</li>
<li>支持 POST 请求方式</li>
<li>CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上</li>
</ol>
<p>这里只是对 CORS 做一个简单的介绍，如果想更详细地了解其原理的话，可以看看下面这篇文章：</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></p>
<h2 id="3-服务端代理："><a href="#3-服务端代理：" class="headerlink" title="3. 服务端代理："></a>3. 服务端代理：</h2><p>服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。</p>
<p>假设有这样的一个场景，你的页面需要获取 <a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/api" target="_blank" rel="noopener">CNode：Node.js专业中文社区</a> 论坛上一些数据，如通过 <code>https://cnodejs.org/api/v1/topics</code>，当时因为不同域，所以你可以将请求后端，让其对该请求代为转发。</p>
<p>代码如下：</p>
<pre><code>// serverProxy/server.js
const url = require(&apos;url&apos;);
const http = require(&apos;http&apos;);
const https = require(&apos;https&apos;);

const server = http.createServer((req, res) =&gt; {
    const path = url.parse(req.url).path.slice(1);
    if(path === &apos;topics&apos;) {
        https.get(&apos;https://cnodejs.org/api/v1/topics&apos;, (resp) =&gt; {
            let data = &quot;&quot;;
            resp.on(&apos;data&apos;, chunk =&gt; {
                data += chunk;
            });
            resp.on(&apos;end&apos;, () =&gt; {
                res.writeHead(200, {
                    &apos;Content-Type&apos;: &apos;application/json; charset=utf-8&apos;
                });
                res.end(data);
            });
        })        
    }
}).listen(3000, &apos;127.0.0.1&apos;);
console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);
</code></pre><p>通过代码你可以看出，当你访问 <code>http://127.0.0.1:3000/topics</code> 的时候，服务器收到请求，会代你发送请求 <code>https://cnodejs.org/api/v1/topics</code> 最后将获取到的数据发送给浏览器。</p>
<p>启动服务 <code>yarn proxy</code> 并访问 <code>http://localhost:3000/topics</code> 即可看到效果：<br><img src="https://pic1.zhimg.com/v2-a14f2dd5cfd124187cabff0fdfabe5a9_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-a14f2dd5cfd124187cabff0fdfabe5a9_hd.jpg" alt=""></p>
<p>跨域请求成功。纯粹的获取跨域获取后端数据的请求的方式已经介绍完了，另外介绍四种通过 iframe 跨域与其它页面通信的方式。</p>
<h2 id="location-hash："><a href="#location-hash：" class="headerlink" title="location.hash："></a>location.hash：</h2><p>在 url 中，<code>http://www.baidu.com#helloworld</code> 的 “#helloworld” 就是 location.hash，改变 hash 值不会导致页面刷新，所以可以利用 hash 值来进行数据的传递，当然数据量是有限的。</p>
<p>假设 <code>localhost:8080</code> 下有文件 index.html 要和 <code>localhost:8081</code> 下的 data.html 传递消息，index.html 首先创建一个隐藏的 iframe，iframe 的 src 指向 <code>localhost:8081/data.html</code>，这时的 hash 值就可以做参数传递。</p>
<pre><code>// hash/client/index.html 对应 localhost:8080/index.html
&lt;script&gt;
    let ifr = document.createElement(&apos;iframe&apos;);
    ifr.style.display = &apos;none&apos;;
    ifr.src = &quot;http://localhost:8081/data.html#data&quot;;
    document.body.appendChild(ifr);

    function checkHash() {
        try {
            let data = location.hash ? location.hash.substring(1) : &apos;&apos;;
            console.log(&apos;获得到的数据是：&apos;, data);
        }catch(e) {

        }
    }
    window.addEventListener(&apos;hashchange&apos;, function(e) {
        console.log(&apos;获得的数据是：&apos;, location.hash.substring(1));
    });
&lt;/script&gt;
</code></pre><p>data.html 收到消息后通过 parent.location.hash 值来修改 index.html 的 hash 值，从而达到数据传递。</p>
<pre><code>// hash/server/data.html 对应 localhost:8081/data.html
&lt;script&gt;
    switch(location.hash) {
        case &quot;#data&quot;:
            callback();
            break;
    }
    function callback() {
        const data = &quot;data.html 的数据&quot;
        try {
            parent.location.hash = data;
        }catch(e) {
            // ie, chrome 下的安全机制无法修改 parent.location.hash
            // 所以要利用一个中间的代理 iframe 
            var ifrproxy = document.createElement(&apos;iframe&apos;);
            ifrproxy.style.display = &apos;none&apos;;
            ifrproxy.src = &apos;http://localhost:8080/proxy.html#&apos; + data;     // 该文件在 client 域名的域下
            document.body.appendChild(ifrproxy);
        }
    }
&lt;/script&gt;
</code></pre><p>由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于 <code>localhost:8080</code> 域名下的一个代理 iframe 的 proxy.html 页面</p>
<pre><code>// hash/client/proxy.html 对应 localhost:8080/proxy.html
&lt;script&gt;
    parent.parent.location.hash = self.location.hash.substring(1);
&lt;/script&gt;
</code></pre><p>之后启动服务 <code>yarn hash</code>，即可在 <code>localhost:8080</code> 下观察到：</p>
<p><img src="https://pic2.zhimg.com/v2-278b33c730dc9aaf499f172424adde00_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-278b33c730dc9aaf499f172424adde00_hd.jpg" alt=""></p>
<p>当然这种方法存在着诸多的缺点：</p>
<ol>
<li>数据直接暴露在了 url 中</li>
<li>数据容量和类型都有限等等</li>
</ol>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name:"></a>window.name:</h2><p>window.name（一般在 js 代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，这里要注意的是每个 iframe 都有包裹它的 window，而这个 window 是 top window 的子窗口，而它自然也有 window.name 的属性，window.name 属性的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。</p>
<p>举个简单的例子：</p>
<p>你在某个页面的控制台输入：</p>
<pre><code>window.name = &quot;Hello World&quot;
window.location = &quot;http://www.baidu.com&quot;
</code></pre><p>页面跳转到了百度首页，但是 window.name 却被保存了下来，还是 Hello World，跨域解决方案似乎可以呼之欲出了：</p>
<p>前端逻辑：</p>
<pre><code>// name/client/index.html 对应 localhost:8080/index.html 
&lt;script&gt;
    let data = &apos;&apos;;
    const ifr = document.createElement(&apos;iframe&apos;);
    ifr.src = &quot;http://localhost:8081/data.html&quot;;
    ifr.style.display = &apos;none&apos;;
    document.body.appendChild(ifr);
    ifr.onload = function() {
        ifr.onload = function() {
            data = ifr.contentWindow.name;
            console.log(&apos;收到数据:&apos;, data);
        }
        ifr.src = &quot;http://localhost:8080/proxy.html&quot;;
    }
&lt;/script&gt;
</code></pre><p>数据页面：</p>
<pre><code>// name/server/data.html 对应 localhost:8081/data.html
&lt;script&gt;
    window.name = &quot;data.html 的数据!&quot;;
&lt;/script&gt;
</code></pre><p><code>localhost:8080index.html</code> 在请求数据端 <code>localhost:8081/data.html</code> 时，我们可以在该页面新建一个 iframe，该 iframe 的 src 指向数据端地址(利用 iframe 标签的跨域能力)，数据端文件设置好 window.name 的值。</p>
<p>但是由于 index.html 页面与该页面 iframe 的 src 如果不同源的话，则无法操作 iframe 里的任何东西，所以就取不到 iframe 的 name 值，所以我们需要在 data.html 加载完后重新换个 src 去指向一个同源的 html 文件，或者设置成 ‘about:blank;’ 都行，这时候我只要在 index.html 相同目录下新建一个 proxy.html 的空页面即可。如果不重新指向 src 的话直接获取的 window.name 的话会报错：</p>
<p><img src="https://pic2.zhimg.com/v2-7bd77f4df4565cd258bbeeed28515152_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7bd77f4df4565cd258bbeeed28515152_hd.jpg" alt=""></p>
<p>之后运行 <code>yarn name</code> 即可看到效果：</p>
<p><img src="https://pic4.zhimg.com/v2-4dcf4a5d25982ce71bdbe6f14af4620c_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-4dcf4a5d25982ce71bdbe6f14af4620c_hd.jpg" alt=""></p>
<h2 id="6-postMessage"><a href="#6-postMessage" class="headerlink" title="6.postMessage"></a>6.postMessage</h2><p>postMessage 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能，使用起来也特别简单。</p>
<p>前端逻辑：</p>
<pre><code>// postMessage/client/index.html 对应 localhost:8080/index.html
&lt;iframe src=&quot;http://localhost:8081/data.html&quot; style=&apos;display: none;&apos;&gt;&lt;/iframe&gt;
&lt;script&gt;
    window.onload = function() {
        let targetOrigin = &apos;http://localhost:8081&apos;;
        window.frames[0].postMessage(&apos;index.html 的 data!&apos;, targetOrigin);
    }
    window.addEventListener(&apos;message&apos;, function(e) {
        console.log(&apos;index.html 接收到的消息:&apos;, e.data);
    });
&lt;/script&gt;
</code></pre><p>创建一个 iframe，使用 iframe 的一个方法 postMessage 可以想 <code>http://localhost:8081/data.html</code> 发送消息，然后监听 message，可以获得其文档发来的消息。</p>
<p>数据端逻辑：</p>
<pre><code>// postMessage/server/data.html 对应 localhost:8081/data.html
&lt;script&gt;
    window.addEventListener(&apos;message&apos;, function(e) {
        if(e.source != window.parent) {
            return;
        }
        let data = e.data;
        console.log(&apos;data.html 接收到的消息:&apos;, data);
        parent.postMessage(&apos;data.html 的 data!&apos;, e.origin);
    });
&lt;/script&gt;
</code></pre><p>启动服务：<code>yarn postMessage</code> 并打开浏览器访问：</p>
<p><img src="https://pic1.zhimg.com/v2-62c2ff153980a18ddd08110cd41cfde4_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-62c2ff153980a18ddd08110cd41cfde4_hd.jpg" alt=""></p>
<p>对 postMessage 感兴趣的详细内容可以看看教程：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/PostMessage/6373972%3Ffr%3Daladdin" target="_blank" rel="noopener">PostMessage_百度百科</a><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">Window.postMessage()</a></p>
<h2 id="7-document-domain"><a href="#7-document-domain" class="headerlink" title="7.document.domain"></a>7.document.domain</h2><p>对于主域相同而子域不同的情况下，可以通过设置 document.domain 的办法来解决，具体做法是可以在 <code>http://www.example.com/index.html</code> 和 <code>http://sub.example.com/data.html</code> 两个文件分别加上 <code>document.domain = &quot;example.com&quot;</code> 然后通过 index.html 文件创建一个 iframe，去控制 iframe 的 window，从而进行交互，当然这种方法只能解决主域相同而二级域名不同的情况，如果你异想天开的把 script.example.com 的 domain 设为 qq.com 显然是没用的，那么如何测试呢？</p>
<p>测试的方式稍微复杂点，需要安装 nginx 做域名映射，如果你电脑没有安装 nginx，请先去安装一下: <a href="https://link.zhihu.com/?target=http%3A//nginx.org/" target="_blank" rel="noopener">nginx</a></p>
<p>前端逻辑：</p>
<pre><code>// domain/client/index.html 对应 sub1.example.com/index.html
&lt;script&gt;
    document.domain = &apos;example.com&apos;;
    let ifr = document.createElement(&apos;iframe&apos;);
    ifr.src = &apos;http://sub2.example.com/data.html&apos;;
    ifr.style.display = &apos;none&apos;;
    document.body.append(ifr);
    ifr.onload = function() {
        let win = ifr.contentWindow;
        alert(win.data);
    }
&lt;/script&gt;
</code></pre><p>数据端逻辑：</p>
<pre><code>// domain/server/data 对应 sub2.example.com/data.html
&lt;script&gt;
    document.domain = &apos;example.com&apos;;
    window.data = &apos;data.html 的数据！&apos;;
&lt;/script&gt;
</code></pre><p>打开操作系统下的 hosts 文件：mac 是位于 /etc/hosts 文件，并添加：</p>
<pre><code>127.0.0.1 sub1.example.com
127.0.0.1 sub2.example.com
</code></pre><p>之后打开 nginx 的配置文件：/usr/local/etc/nginx/nginx.conf，并在 http 模块里添加，记得输入 nginx 启动 nginx 服务：</p>
<pre><code>/usr/local/etc/nginx/nginx.conf
http {
    // ...
    server {
        listen 80;
        server_name sub1.example.com;
        location / {
            proxy_pass http://127.0.0.1:8080/;
        }
    }
    server {
        listen 80;
        server_name sub2.example.com;
        location / {
            proxy_pass http://127.0.0.1:8081/;
        }
    }
    // ...
}
</code></pre><p>相当于是讲 <code>sub1.example.com</code> 和 <code>sub2.example.com</code> 这些域名地址指向本地 <code>127.0.0.1:80</code>，然后用 nginx 做反向代理分别映射到 8080 和 8081 端口。</p>
<p>这样访问 <code>sub1(2).example.com</code> 等于访问 <code>127.0.0.1:8080(1)</code></p>
<p>启动服务 <code>yarn domain</code> 访问浏览器即可看到效果：</p>
<p><img src="https://pic2.zhimg.com/v2-19277c077856648ca1d593f44afadf6e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-19277c077856648ca1d593f44afadf6e_hd.jpg" alt=""></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>前面七种跨域方式我已经全部讲完，其实讲道理，常用的也就是前三种方式，后面四种更多时候是一些小技巧，虽然在工作中不一定会用到，但是如果你在面试过程中能够提到这些跨域的技巧，无疑在面试官的心中是一个加分项。</p>
<p>上面阐述方法的时候可能有些讲的不明白，希望在阅读的过程中建议你跟着我敲代码，当你打开浏览器看到结果的时候，你也就能掌握到这种方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/23/前端性能监控：window-performance/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/23/前端性能监控：window-performance/" itemprop="url">前端性能监控：window.performance</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-23T22:51:24+08:00">
                2016-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/2014/WD-navigation-timing-2-20140325/" target="_blank" rel="noopener">window.performance</a> 是W3C性能小组引入的新的API，目前IE9以上的浏览器都支持。一个performance对象的完整结构如下图所示：</p>
<h2 id="Window-performance"><a href="#Window-performance" class="headerlink" title="Window.performance"></a>Window.performance</h2><p>虽然叫 <code>Timing API</code> 但是用起来却是 <code>window.performance</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 兼容性写法</span><br><span class="line">const performance = window.performance || </span><br><span class="line">                      window.msPerformance || </span><br><span class="line">                      window.webkitPerformance;</span><br></pre></td></tr></table></figure></p>
<p>memory字段代表JavaScript对内存的占用。</p>
<h2 id="performance-memory-内存"><a href="#performance-memory-内存" class="headerlink" title="performance.memory(内存)"></a>performance.memory(内存)</h2><ul>
<li>usedJSHeapSize<br>JS 对象（包括V8引擎内部对象）占用的内存</li>
<li>totalJSHeapSize<br>可使用的内存</li>
<li>jsHeapSizeLimit<br>内存大小限制</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-f4a0fa5f8a8a1c4ef07f83d0f393fd9a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-f4a0fa5f8a8a1c4ef07f83d0f393fd9a_hd.jpg" alt=""></p>
<h2 id="performance-navigation-我从哪里来"><a href="#performance-navigation-我从哪里来" class="headerlink" title="performance.navigation(我从哪里来)"></a>performance.navigation(我从哪里来)</h2><ul>
<li>redirectCount<br>如果有重定向的话，页面通过几次重定向跳转而来</li>
<li><p>type</p>
</li>
<li><p>0 即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</p>
</li>
<li>1 即 TYPE_RELOAD 通过 window.location.reload() 刷新的页面</li>
<li>2 即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</li>
<li>255 即 TYPE_UNDEFINED 非以上方式进入的页面</li>
</ul>
<p>navigation字段统计的是一些网页导航相关的数据：</p>
<ol>
<li>redirectCount:重定向的数量（只读），但是这个接口有同源策略限制，即仅能检测同源的重定向；</li>
<li>type 返回值应该是0,1,2 中的一个。分别对应三个枚举值:</li>
</ol>
<ul>
<li>0 : TYPE_NAVIGATE (用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式)</li>
<li>1 : TYPE_RELOAD (用户通过刷新，包括JS调用刷新接口等方式访问页面)</li>
<li>2 : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面)</li>
</ul>
<p>最重要的是timing字段的统计数据，它包含了网络、解析等一系列的时间数据。</p>
<h2 id="performance-timing-时间"><a href="#performance-timing-时间" class="headerlink" title="performance.timing(时间)"></a>performance.timing(时间)</h2><p><img src="https://pic4.zhimg.com/v2-a9f7be2c5aaa973e405bd0b8da7e6890_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a9f7be2c5aaa973e405bd0b8da7e6890_hd.jpg" alt=""></p>
<p>2.2.1 timing API</p>
<p>timing的整体结构如上图所示：</p>
<p><img src="https://pic2.zhimg.com/v2-95d9e0f1ff8257f3c007045c6a2d07bb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-95d9e0f1ff8257f3c007045c6a2d07bb_hd.jpg" alt=""></p>
<p>各字段的含义如下：</p>
<ul>
<li>startTime：有些浏览器实现为<a href="https://link.zhihu.com/?target=https%3A//msdn.microsoft.com/en-us/library/ff974724%28v%3Dvs.85%29.aspx" target="_blank" rel="noopener">navigationStart</a>，代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览baidu.com，在地址栏输入google.com并回车，浏览器的执行动作依次为：unload当前文档（即<a href="https://link.zhihu.com/?target=http%3A//baidu.com" target="_blank" rel="noopener">http://baidu.com</a>）-&gt;请求下一文档（即<a href="https://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="noopener">http://google.com</a>）。navigationStart的值便是触发unload当前文档的时间节点。</li>
</ul>
<p>如果当前文档为空，则navigationStart的值等于fetchStart。</p>
<ul>
<li>redirectStart和redirectEnd：如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点；</li>
<li>unloadEventStart和unloadEventEnd：如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0；</li>
<li>fetchStart是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存；</li>
<li>domainLookupStart和domainLookupEnd分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart；</li>
<li>connectStart和connectEnd分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd；</li>
<li>secureConnectionStart：可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0；</li>
<li>requestStart代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等；</li>
<li>responseStart和responseEnd分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻；</li>
<li>domLoading代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点；</li>
<li>domInteractive代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点；</li>
<li>domContentLoadedEventStart：代表DOMContentLoaded事件触发的时间节点：</li>
</ul>
<p>页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。</p>
<ul>
<li>domContentLoadedEventEnd：代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间；</li>
<li>domComplete：html文档完全解析完毕的时间节点；</li>
<li>loadEventStart和loadEventEnd分别代表onload事件触发和结束的时间节点</li>
</ul>
<p>2.2.2 计算性能指标</p>
<p>可以使用Navigation.timing 统计到的时间数据来计算一些页面性能指标，比如DNS查询耗时、白屏时间、domready等等。如下：</p>
<ul>
<li>DNS查询耗时 = domainLookupEnd - domainLookupStart</li>
<li>TCP链接耗时 = connectEnd - connectStart</li>
<li>request请求耗时 = responseEnd - responseStart</li>
<li>解析dom树耗时 = domComplete - domInteractive</li>
<li>白屏时间 = domloadng - fetchStart</li>
<li>domready时间 = domContentLoadedEventEnd - fetchStart</li>
<li><p>onload时间 = loadEventEnd - fetchStart</p>
<p>  所以根据上面的时间点，我们可以计算常规的性能值，如下：<br>  （使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">var timing = window.performance &amp;&amp; window.performance.timing;</span><br><span class="line">var navigation = window.performance &amp;&amp; window.performance.navigation;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">重定向次数：</span><br><span class="line">var redirectCount = navigation &amp;&amp; navigation.redirectCount;</span><br><span class="line"> </span><br><span class="line">跳转耗时：</span><br><span class="line">var redirect = timing.redirectEnd - timing.redirectStart;</span><br><span class="line"> </span><br><span class="line">APP CACHE 耗时：</span><br><span class="line">var appcache = Math.max(timing.domainLookupStart - timing.fetchStart, 0);</span><br><span class="line"> </span><br><span class="line">DNS 解析耗时：</span><br><span class="line">var dns = timing.domainLookupEnd - timing.domainLookupStart;</span><br><span class="line"> </span><br><span class="line">TCP 链接耗时：</span><br><span class="line">var conn = timing.connectEnd - timing.connectStart;</span><br><span class="line"> </span><br><span class="line">等待服务器响应耗时（注意是否存在cache）：</span><br><span class="line">var request = timing.responseStart - timing.requestStart;</span><br><span class="line"> </span><br><span class="line">内容加载耗时（注意是否存在cache）:</span><br><span class="line">var response = timing.responseEnd - timing.responseStart;</span><br><span class="line"> </span><br><span class="line">总体网络交互耗时，即开始跳转到服务器资源下载完成：</span><br><span class="line">var network = timing.responseEnd - timing.navigationStart;</span><br><span class="line"> </span><br><span class="line">渲染处理：</span><br><span class="line">var processing = (timing.domComplete || timing.domLoading) - timing.domLoading;</span><br><span class="line"> </span><br><span class="line">抛出 load 事件：</span><br><span class="line">var load = timing.loadEventEnd - timing.loadEventStart;</span><br><span class="line"> </span><br><span class="line">总耗时：</span><br><span class="line">var total = (timing.loadEventEnd || timing.loadEventStart || timing.domComplete || timing.domLoading) - timing.navigationStart;</span><br><span class="line"> </span><br><span class="line">可交互：</span><br><span class="line">var active = timing.domInteractive - timing.navigationStart;</span><br><span class="line"> </span><br><span class="line">请求响应耗时，即 T0，注意cache：</span><br><span class="line">var t0 = timing.responseStart - timing.navigationStart;</span><br><span class="line"> </span><br><span class="line">首次出现内容，即 T1：</span><br><span class="line">var t1 = timing.domLoading - timing.navigationStart;</span><br><span class="line"> </span><br><span class="line">内容加载完毕，即 T3：</span><br><span class="line">var t3 = timing.loadEventEnd - timing.navigationStart;</span><br></pre></td></tr></table></figure>
<p>2.2.3 Resource timing API</p>
<p>Resource timing API是用来统计静态资源相关的时间信息，详细的内容请参考<a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/resource-timing/" target="_blank" rel="noopener">W3C Resource timing</a>。这里我们只介绍performance.getEntries方法，它可以获取页面中每个静态资源的请求，【以百度移动版首页的logo为例】如下：</p>
<p>比较有用的几个属性：</p>
<pre><code>name：资源的链接

initiatorType: 初始类型（注意这个类型并不准确，例如在css中的图片资源会这个值显示css，所以还是推荐用name中的后缀名）

duration: 资源的总耗时（包括等待时长，请求时长，响应时长 相当于responseEnd - startTime）

transferSize: 转换后的文件大小(略大于encodedBodySize, 为什么我取这个呢，因为这个值是和chrome的devtool Network里的size一致) 
</code></pre><p><img src="https://pic4.zhimg.com/v2-cff2a7e449c4e6260c2cb8fa0b18c948_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-cff2a7e449c4e6260c2cb8fa0b18c948_hd.jpg" alt=""></p>
<p>可以看到performance.getEntries返回一个数组，数组的每个元素代表对应的静态资源的信息，比如上图展示的第一个元素对应的资源类型initiatorType是图片img，请求花费的时间就是duration的值。</p>
<p>关于Resource timing API的使用场景，感兴趣的同学可以深入研究。</p>
<p><img src="https://pic2.zhimg.com/v2-23c6a6e3744a117368fbd9b0789867ff_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-23c6a6e3744a117368fbd9b0789867ff_hd.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(function() &#123;</span><br><span class="line"></span><br><span class="line">	handleAddListener(&apos;load&apos;, getTiming)</span><br><span class="line"></span><br><span class="line">	function handleAddListener(type, fn) &#123;</span><br><span class="line">		if(window.addEventListener) &#123;</span><br><span class="line">			window.addEventListener(type, fn)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			window.attachEvent(&apos;on&apos; + type, fn)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	function getTiming() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			var time = performance.timing;</span><br><span class="line">			var timingObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">			var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;</span><br><span class="line"></span><br><span class="line">			if(loadTime &lt; 0) &#123;</span><br><span class="line">				setTimeout(function() &#123;</span><br><span class="line">					getTiming();</span><br><span class="line">				&#125;, 200);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000;</span><br><span class="line">			timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000;</span><br><span class="line">			timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000;</span><br><span class="line">			timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000;</span><br><span class="line">			timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000;</span><br><span class="line">			timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000;</span><br><span class="line">			timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000;</span><br><span class="line">			timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;</span><br><span class="line">			timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000;</span><br><span class="line">			timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]);</span><br><span class="line"></span><br><span class="line">			for(item in timingObj) &#123;</span><br><span class="line">				console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			console.log(performance.timing);</span><br><span class="line"></span><br><span class="line">		&#125; catch(e) &#123;</span><br><span class="line">			console.log(timingObj)</span><br><span class="line">			console.log(performance.timing);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">		&lt;title&gt;&lt;/title&gt;</span><br><span class="line">		&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;</span><br><span class="line">		&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; /&gt;</span><br><span class="line">		&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</span><br><span class="line">		&lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line"></span><br><span class="line">	&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://pic2.zhimg.com/v2-23c6a6e3744a117368fbd9b0789867ff_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-23c6a6e3744a117368fbd9b0789867ff_hd.jpg" alt=""></p>
<h2 id="性能监控-数据上报"><a href="#性能监控-数据上报" class="headerlink" title="性能监控,数据上报"></a>性能监控,数据上报</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WBP</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="built_in">Date</span>.prototype.Format = <span class="function"><span class="keyword">function</span>(<span class="params">fmt</span>) </span>&#123; <span class="comment">// author: meizz</span></span><br><span class="line">			<span class="keyword">var</span> o = &#123;</span><br><span class="line">				<span class="string">"M+"</span>: <span class="keyword">this</span>.getMonth() + <span class="number">1</span>, <span class="comment">// 月份</span></span><br><span class="line">				<span class="string">"d+"</span>: <span class="keyword">this</span>.getDate(), <span class="comment">// 日</span></span><br><span class="line">				<span class="string">"h+"</span>: <span class="keyword">this</span>.getHours(), <span class="comment">// 小时</span></span><br><span class="line">				<span class="string">"m+"</span>: <span class="keyword">this</span>.getMinutes(), <span class="comment">// 分</span></span><br><span class="line">				<span class="string">"s+"</span>: <span class="keyword">this</span>.getSeconds(), <span class="comment">// 秒</span></span><br><span class="line">				<span class="string">"q+"</span>: <span class="built_in">Math</span>.floor((<span class="keyword">this</span>.getMonth() + <span class="number">3</span>) / <span class="number">3</span>), <span class="comment">// 季度</span></span><br><span class="line">				<span class="string">"S"</span>: <span class="keyword">this</span>.getMilliseconds() <span class="comment">// 毫秒</span></span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="keyword">if</span>(<span class="regexp">/(y+)/</span>.test(fmt))</span><br><span class="line">				fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="keyword">this</span>.getFullYear() + <span class="string">""</span>).substr(<span class="number">4</span> - <span class="built_in">RegExp</span>.$<span class="number">1.</span>length));</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> o)</span><br><span class="line">				<span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"("</span> + k + <span class="string">")"</span>).test(fmt)) fmt = fmt.replace(<span class="built_in">RegExp</span>.$<span class="number">1</span>, (<span class="built_in">RegExp</span>.$<span class="number">1.</span>length == <span class="number">1</span>) ? (o[k]) : ((<span class="string">"00"</span> + o[k]).substr((<span class="string">""</span> + o[k]).length)));</span><br><span class="line">			<span class="keyword">return</span> fmt;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> w = <span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth; <span class="comment">//浏览器宽度</span></span><br><span class="line">		<span class="keyword">var</span> h = <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight; <span class="comment">//浏览器高度</span></span><br><span class="line">		<span class="keyword">var</span> opt = &#123;</span><br><span class="line">			ps: <span class="number">1</span>, <span class="comment">//采样比率</span></span><br><span class="line">			device: &#123;</span><br><span class="line">				clientW: w,</span><br><span class="line">				clientH: h,</span><br><span class="line">			&#125;,</span><br><span class="line">			t: <span class="keyword">new</span> <span class="built_in">Date</span>().Format(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>),</span><br><span class="line">			pid: <span class="string">"123"</span>,</span><br><span class="line">			errorList: []</span><br><span class="line">		&#125;;　　　　</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> option) &#123;　　　　　　</span><br><span class="line">			opt[i] = option[i];　　　　</span><br><span class="line">		&#125;　　　　</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">getExplore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> sys = &#123;&#125;,</span><br><span class="line">				ua = navigator.userAgent.toLowerCase(),</span><br><span class="line">				s;</span><br><span class="line">			(s = ua.match(<span class="regexp">/rv:([\d.]+)\) like gecko/</span>)) ? sys.ie = s[<span class="number">1</span>]:</span><br><span class="line">				(s = ua.match(<span class="regexp">/msie ([\d\.]+)/</span>)) ? sys.ie = s[<span class="number">1</span>] :</span><br><span class="line">				(s = ua.match(<span class="regexp">/edge\/([\d\.]+)/</span>)) ? sys.edge = s[<span class="number">1</span>] :</span><br><span class="line">				(s = ua.match(<span class="regexp">/firefox\/([\d\.]+)/</span>)) ? sys.firefox = s[<span class="number">1</span>] :</span><br><span class="line">				(s = ua.match(<span class="regexp">/(?:opera|opr).([\d\.]+)/</span>)) ? sys.opera = s[<span class="number">1</span>] :</span><br><span class="line">				(s = ua.match(<span class="regexp">/micromessenger\/([\d\.]+)/i</span>)) ? sys.weixin = s[<span class="number">1</span>] :</span><br><span class="line">				(s = ua.match(<span class="regexp">/chrome\/([\d\.]+)/</span>)) ? sys.chrome = s[<span class="number">1</span>] :</span><br><span class="line">				(s = ua.match(<span class="regexp">/version\/([\d\.]+).*safari/</span>)) ? sys.safari = s[<span class="number">1</span>] :</span><br><span class="line">				(s = ua.match(<span class="regexp">/weibo\/([\d\.]+)/i</span>)) ? sys.weibo = s[<span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 根据关系进行判断 </span></span><br><span class="line">			<span class="keyword">if</span>(sys.ie) <span class="keyword">return</span>(<span class="string">'IE: '</span> + sys.ie)</span><br><span class="line">			<span class="keyword">if</span>(sys.edge) <span class="keyword">return</span>(<span class="string">'EDGE: '</span> + sys.edge)</span><br><span class="line">			<span class="keyword">if</span>(sys.firefox) <span class="keyword">return</span>(<span class="string">'Firefox: '</span> + sys.firefox)</span><br><span class="line">			<span class="keyword">if</span>(sys.weixin) <span class="keyword">return</span>(<span class="string">'weixin: '</span> + sys.weixin)</span><br><span class="line">			<span class="keyword">if</span>(sys.chrome) <span class="keyword">return</span>(<span class="string">'Chrome: '</span> + sys.chrome)</span><br><span class="line">			<span class="keyword">if</span>(sys.opera) <span class="keyword">return</span>(<span class="string">'Opera: '</span> + sys.opera)</span><br><span class="line">			<span class="keyword">if</span>(sys.safari) <span class="keyword">return</span>(<span class="string">'Safari: '</span> + sys.safari)</span><br><span class="line">			<span class="keyword">if</span>(sys.weibo) <span class="keyword">return</span>(<span class="string">'weibo: '</span> + sys.weibo)</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'Unkonwn'</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">getOS</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> userAgent = <span class="string">'navigator'</span> <span class="keyword">in</span> <span class="built_in">window</span> &amp;&amp; <span class="string">'userAgent'</span> <span class="keyword">in</span> navigator &amp;&amp; navigator.userAgent.toLowerCase() || <span class="string">''</span>;</span><br><span class="line">			<span class="keyword">var</span> vendor = <span class="string">'navigator'</span> <span class="keyword">in</span> <span class="built_in">window</span> &amp;&amp; <span class="string">'vendor'</span> <span class="keyword">in</span> navigator &amp;&amp; navigator.vendor.toLowerCase() || <span class="string">''</span>;</span><br><span class="line">			<span class="keyword">var</span> appVersion = <span class="string">'navigator'</span> <span class="keyword">in</span> <span class="built_in">window</span> &amp;&amp; <span class="string">'appVersion'</span> <span class="keyword">in</span> navigator &amp;&amp; navigator.appVersion.toLowerCase() || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(<span class="regexp">/mac/i</span>.test(appVersion)) <span class="keyword">return</span> <span class="string">'MacOSX'</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="regexp">/win/i</span>.test(appVersion)) <span class="keyword">return</span> <span class="string">'windows'</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="regexp">/linux/i</span>.test(appVersion)) <span class="keyword">return</span> <span class="string">'linux'</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="regexp">/iphone/i</span>.test(userAgent) || <span class="regexp">/ipad/i</span>.test(userAgent) || <span class="regexp">/ipod/i</span>.test(userAgent)) <span class="string">'ios'</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="regexp">/android/i</span>.test(userAgent)) <span class="keyword">return</span> <span class="string">'android'</span></span><br><span class="line">			<span class="keyword">if</span>(<span class="regexp">/win/i</span>.test(appVersion) &amp;&amp; <span class="regexp">/phone/i</span>.test(userAgent)) <span class="keyword">return</span> <span class="string">'windowsPhone'</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">perforPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> performance = <span class="built_in">window</span>.performance ||</span><br><span class="line">				<span class="built_in">window</span>.msPerformance ||</span><br><span class="line">				<span class="built_in">window</span>.webkitPerformance;</span><br><span class="line">			<span class="keyword">if</span>(!performance) <span class="keyword">return</span>;</span><br><span class="line">			<span class="keyword">var</span> time = performance.timing</span><br><span class="line">			<span class="keyword">var</span> timingObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">			timingObj[<span class="string">'rdit'</span>] = (time.redirectEnd - time.redirectStart) / <span class="number">1000</span>; <span class="comment">//页面重定向时间</span></span><br><span class="line">			timingObj[<span class="string">'dnst'</span>] = (time.domainLookupEnd - time.domainLookupStart) / <span class="number">1000</span>; <span class="comment">// DNS解析时间</span></span><br><span class="line">			timingObj[<span class="string">'tcpt'</span>] = (time.connectEnd - time.connectStart) / <span class="number">1000</span>; <span class="comment">//TCP建立时间</span></span><br><span class="line">			timingObj[<span class="string">'httpt'</span>] = (time.responseEnd - time.requestStart) / <span class="number">1000</span>; <span class="comment">//HTTP请求响应完成时间</span></span><br><span class="line">			timingObj[<span class="string">'domst'</span>] = (time.responseEnd - time.navigationStart) / <span class="number">1000</span>; <span class="comment">//DOM开始加载前所花费时间</span></span><br><span class="line">			timingObj[<span class="string">'doml'</span>] = (time.domComplete - time.domLoading) / <span class="number">1000</span>; <span class="comment">//DOM加载完成时间</span></span><br><span class="line">			timingObj[<span class="string">'domr'</span>] = (time.domInteractive - time.domLoading) / <span class="number">1000</span>; <span class="comment">//DOM结构解析完成时间</span></span><br><span class="line">			timingObj[<span class="string">'jst'</span>] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / <span class="number">1000</span>; <span class="comment">//脚本加载时间</span></span><br><span class="line">			timingObj[<span class="string">'loadt'</span>] = (time.loadEventEnd - time.loadEventStart) / <span class="number">1000</span>; <span class="comment">//onload事件时间</span></span><br><span class="line">			timingObj[<span class="string">'allt'</span>] = (timingObj[<span class="string">'rdit'</span>] + timingObj[<span class="string">'dnst'</span>] + timingObj[<span class="string">'tcpt'</span>] + timingObj[<span class="string">'httpt'</span>] + timingObj[<span class="string">'domr'</span>] + timingObj[<span class="string">'doml'</span>]);</span><br><span class="line"></span><br><span class="line">			timingObj[<span class="string">'reqt'</span>] = time.responseEnd - time.requestStart || <span class="number">0</span>; <span class="comment">//request请求耗时</span></span><br><span class="line">			timingObj[<span class="string">'wit'</span>] = time.responseStart - time.navigationStart || <span class="number">0</span>; <span class="comment">// 白屏时间</span></span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">			<span class="keyword">return</span> timingObj;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> defaults = &#123;</span><br><span class="line">				msg: <span class="string">''</span>,</span><br><span class="line">				h: <span class="string">''</span></span><br><span class="line">			&#125;;</span><br><span class="line">			defaults.msg = e.type + <span class="string">":"</span> + e.target.localName + <span class="string">' is load error'</span>;</span><br><span class="line">			defaults.h = e.target.href || e.target.currentSrc || e.target.src;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span>(e.target != <span class="built_in">window</span>) opt.errorList.push(defaults)</span><br><span class="line">		&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">msg, _url, line, col, error</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> defaults = &#123;</span><br><span class="line">				line: line,</span><br><span class="line">				col: col || (<span class="built_in">window</span>.event &amp;&amp; <span class="built_in">window</span>.event.errorCharacter) || <span class="number">0</span>,</span><br><span class="line">				msg: error &amp;&amp; error.stack ? error.stack.toString() : msg</span><br><span class="line">			&#125;;</span><br><span class="line">			opt.errorList.push(defaults)</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">window</span>.addEventListener(<span class="string">'unhandledrejection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">var</span> defaults = &#123;</span><br><span class="line">				msg: e.type + <span class="string">":"</span> + e.reason</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="built_in">console</span>.log(defaults)</span><br><span class="line">			opt.errorList.push(defaults)</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">formatParams</span>(<span class="params">data, random</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> arr = [];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> name <span class="keyword">in</span> data) &#123;</span><br><span class="line">				arr.push(<span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(data[name]));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(random) &#123;</span><br><span class="line">				arr.push((<span class="string">"v="</span> + <span class="built_in">Math</span>.random()).replace(<span class="string">"."</span>, <span class="string">""</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> arr.join(<span class="string">"&amp;"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">_confuse</span>(<span class="params">str, sign</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">typeof</span> str !== <span class="string">'string'</span> || !str) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">var</span> newStr = <span class="string">''</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">				newStr += <span class="built_in">String</span>.fromCharCode(str.charCodeAt(i) + sign * <span class="number">2</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> newStr;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">var</span> softdog = &#123;</span><br><span class="line">			encrypt: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> _confuse(str, <span class="number">1</span>);</span><br><span class="line">			&#125;,</span><br><span class="line">			decrypt: <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> _confuse(str, <span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			opt.device.pfm = perforPage();</span><br><span class="line">			opt.device.browser = getExplore();</span><br><span class="line">			opt.device.os = getOS()</span><br><span class="line">            opt.referrer=<span class="built_in">document</span>.referrer &amp;&amp; <span class="built_in">document</span>.referrer !== location.href ? <span class="built_in">document</span>.referrer : <span class="string">''</span>,  <span class="comment">//页面来源</span></span><br><span class="line">			<span class="keyword">var</span> str = softdog.encrypt(<span class="built_in">JSON</span>.stringify(opt))</span><br><span class="line">			<span class="built_in">console</span>.log(str)</span><br><span class="line">			<span class="built_in">console</span>.log(softdog.decrypt(str))</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">Math</span>.random()&lt;=opt.ps)&#123;   <span class="comment">//抽样采样</span></span><br><span class="line">				<span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">			    img.src = <span class="string">'./img/sky.png?opt='</span> + str;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据上报字符串加密解密"><a href="#数据上报字符串加密解密" class="headerlink" title="数据上报字符串加密解密"></a>数据上报字符串加密解密</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * @module &#123;Object&#125; softdog 简单的字符串加密|解密，防止密码提交拦截</span></span><br><span class="line"><span class="comment"> * @interface Softdog</span></span><br><span class="line"><span class="comment"> * @method encrypt  ----------  字符串加密</span></span><br><span class="line"><span class="comment"> * @method decrypt  ----------  字符串解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> v = factory(<span class="built_in">require</span>, exports);</span><br><span class="line">        <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="built_in">module</span>.exports = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">"function"</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([<span class="string">"require"</span>, <span class="string">"exports"</span>], factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="comment">// 功能函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_confuse</span>(<span class="params">str, sign</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> str !== <span class="string">'string'</span> || !str) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> newStr = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            newStr += <span class="built_in">String</span>.fromCharCode(str.charCodeAt(i) + sign * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">var</span> softdog = &#123;</span><br><span class="line">        encrypt: <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _confuse(str, <span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        decrypt: <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _confuse(str, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> softdog;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="仿百度上报"><a href="#仿百度上报" class="headerlink" title="仿百度上报"></a>仿百度上报</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">router.afterEach( <span class="function">(<span class="params"> to, <span class="keyword">from</span>, next </span>) =&gt;</span> &#123;</span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> _hmt = _hmt || [];</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//每次执行前，先移除上次插入的代码</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'baidu_tj'</span>) &amp;&amp; <span class="built_in">document</span>.getElementById(<span class="string">'baidu_tj'</span>).remove();</span><br><span class="line">    <span class="keyword">var</span> hm = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    hm.src = <span class="string">"https://hm.baidu.com/hm.js?xxxx"</span>;</span><br><span class="line">    hm.id = <span class="string">"baidu_tj"</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"script"</span>)[<span class="number">0</span>];</span><br><span class="line">    s.parentNode.insertBefore(hm, s);</span><br><span class="line">   &#125;)();</span><br><span class="line"> &#125;,<span class="number">0</span>);</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<h3 id="js-判断-wifi-and-‘2g’-‘3g’-‘4g’"><a href="#js-判断-wifi-and-‘2g’-‘3g’-‘4g’" class="headerlink" title="js 判断 wifi and ‘2g’, ‘3g’, ‘4g’"></a>js 判断 wifi and ‘2g’, ‘3g’, ‘4g’</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection || &#123; <span class="attr">tyep</span>: <span class="string">'unknown'</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> type_text = [<span class="string">'unknown'</span>, <span class="string">'ethernet'</span>, <span class="string">'wifi'</span>, <span class="string">'2g'</span>, <span class="string">'3g'</span>, <span class="string">'4g'</span>, <span class="string">'none'</span>];</span><br><span class="line"> </span><br><span class="line">alert(connection.type);</span><br><span class="line"><span class="keyword">var</span> re_el = <span class="built_in">document</span>.getElementById(<span class="string">"re"</span>);</span><br><span class="line"><span class="keyword">var</span> btn_el = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_status</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (connection.type) == <span class="string">"number"</span>) &#123;</span><br><span class="line">        connection.type_text = type_text[connection.type];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        connection.type_text = connection.type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> (connection.bandwidth) == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connection.bandwidth &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            connection.type = <span class="string">'wifi'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection.bandwidth &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            connection.type = <span class="string">'3g'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection.bandwidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            connection.type = <span class="string">'2g'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (connection.bandwidth == <span class="number">0</span>) &#123;</span><br><span class="line">            connection.type = <span class="string">'none'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            connection.type = <span class="string">'unknown'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> html = <span class="string">'Type : '</span> + connection.type_text;</span><br><span class="line">    html += <span class="string">'Bandwidth : '</span> + connection.bandwidth;</span><br><span class="line">    html += <span class="string">'isOnline : '</span> + navigator.onLine;</span><br><span class="line">    re_el.innerHTML = html;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">btn_el.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    re_el.innerHTML = <span class="string">'Waiting...'</span>;</span><br><span class="line">    get_status();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设备选型"><a href="#设备选型" class="headerlink" title="设备选型"></a>设备选型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> s = <span class="string">""</span>;</span><br><span class="line">        s += <span class="string">" 网页可见区域宽:"</span>+ <span class="built_in">document</span>.body.clientWidth+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页可见区域高:"</span>+ <span class="built_in">document</span>.body.clientHeight+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页可见区域宽:"</span>+ <span class="built_in">document</span>.body.offsetWidth + <span class="string">" (包括边线和滚动条的宽)"</span>+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页可见区域高:"</span>+ <span class="built_in">document</span>.body.offsetHeight + <span class="string">" (包括边线的宽)"</span>+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页正文全文宽:"</span>+ <span class="built_in">document</span>.body.scrollWidth+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页正文全文高:"</span>+ <span class="built_in">document</span>.body.scrollHeight+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页被卷去的高(ff):"</span>+ <span class="built_in">document</span>.body.scrollTop+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页被卷去的高(ie):"</span>+ <span class="built_in">document</span>.documentElement.scrollTop+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页被卷去的左:"</span>+ <span class="built_in">document</span>.body.scrollLeft+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页正文部分上:"</span>+ <span class="built_in">window</span>.screenTop+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 网页正文部分左:"</span>+ <span class="built_in">window</span>.screenLeft+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 屏幕分辨率的高:"</span>+ <span class="built_in">window</span>.screen.height+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 屏幕分辨率的宽:"</span>+ <span class="built_in">window</span>.screen.width+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 屏幕可用工作区高度:"</span>+ <span class="built_in">window</span>.screen.availHeight+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 屏幕可用工作区宽度:"</span>+ <span class="built_in">window</span>.screen.availWidth+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 你的屏幕设置是 "</span>+ <span class="built_in">window</span>.screen.colorDepth +<span class="string">" 位彩色"</span>+<span class="string">"\n"</span>;</span><br><span class="line">        s += <span class="string">" 你的屏幕设置 "</span>+ <span class="built_in">window</span>.screen.deviceXDPI +<span class="string">" 像素/英寸"</span>+<span class="string">"\n"</span>;</span><br><span class="line">        alert (s);</span><br><span class="line">    &#125;</span><br><span class="line">    getInfo();</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/28/eval-和-new-Function-执行JS代码/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/28/eval-和-new-Function-执行JS代码/" itemprop="url">eval() 和 new Function() 执行JS代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-28T10:03:24+08:00">
                2016-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global scope&apos;</span><br><span class="line">function b()&#123;</span><br><span class="line">   var a = &apos;local scope&apos;</span><br><span class="line">   eval(&apos;console.log(a)&apos;)   //local scope</span><br><span class="line">   ;(new Function(&apos;&apos;,&apos;console.log(a)&apos;))()  //global scope</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">b()</span><br><span class="line"> </span><br><span class="line">local scope</span><br><span class="line">global scope</span><br></pre></td></tr></table></figure>
<blockquote>
<p>eval中的代码执行时的作用域为当前作用域。它可以访问到函数中的局部变量。</p>
</blockquote>
<blockquote>
<p>new Function中的代码执行时的作用域为全局作用域，不论它的在哪个地方调用的。所以它访问的是全局变量a。它根本无法访问b函数内的局部变量。</p>
</blockquote>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>以 str 的方式运行 JavaScript 代码，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; var a = 12;</span><br><span class="line">&gt; eval( &apos;a+5&apos; );</span><br><span class="line">&gt; 17</span><br></pre></td></tr></table></figure></p>
<p>注意语句上下文 eval()的解析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval( &apos;&#123; foo: 123 &#125;&apos; );</span><br><span class="line">&gt; 123</span><br><span class="line">&gt; eval( &apos;(&#123; foo: 123 &#125;)&apos; );</span><br><span class="line">&gt; &#123; foo: 123 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="严格模式下的-eval"><a href="#严格模式下的-eval" class="headerlink" title="严格模式下的 eval()"></a>严格模式下的 eval()</h3><p>对于 eval()，理应当在严格模式下使用。在松散模式下运行代码会在当前的作用域中创建局部变量：</p>
<pre><code>function f(){ 
       eval( &apos;var foo = 1&apos; );
       console.log( foo ); // 1
    } 
</code></pre><p>严格模式下就不会出现该情况。但是，运行代码仍然具有读写当前作用域中变量的权限。你需要通过间接调用 eval() 来阻止这种权限。</p>
<h3 id="全局作用域下间接执行-eval-有两种调用-eval-的方式："><a href="#全局作用域下间接执行-eval-有两种调用-eval-的方式：" class="headerlink" title="全局作用域下间接执行 eval() 有两种调用 eval() 的方式："></a>全局作用域下间接执行 eval() 有两种调用 eval() 的方式：</h3><ol>
<li>直接方式：通过直接调用名为 “eval” 的函数。</li>
<li><p>间接方式：使用其他的一些方式。（通过 call 调用，将其以其他名字作为 window 下的一个方法存储，在那里进行调用） 之前已经看过，在当前作用域直接使用 eval 执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = &apos;global&apos;; </span><br><span class="line">   function directEval()&#123;</span><br><span class="line">       &apos;use strict&apos;;</span><br><span class="line">        var x = &apos;local&apos;;</span><br><span class="line">        console.log( eval(&apos;x&apos;) ); // local</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 反之，在全局作用域中间接调用 eval。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var x = &apos;global&apos;; </span><br><span class="line">function indirectEval()&#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    var x = &apos;local&apos;;</span><br><span class="line">    // 不同方式调用 call </span><br><span class="line">    console.log( eval.call(null, &apos;x&apos;) ); // global</span><br><span class="line">    console.log( window.eval(&apos;x&apos;) ); // global</span><br><span class="line">    console.log( (1,eval)(&apos;x&apos;) ); // global (1)</span><br><span class="line">    var xeval = eval;</span><br><span class="line">    console.log( xeval(&apos;x&apos;) ); // global</span><br><span class="line">    var obj = &#123; eval: eval &#125;</span><br><span class="line">    console.log( obj.eval(&apos;x&apos;) ); // global</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：当你通过一个名称来引用一个变量的时候，其初始值为一个所谓的引用，数据结构分为两部分： </p>
<ol>
<li>基础是指向存储变量的值的数据结构。 </li>
<li>引用名是变量的名称<br>在一个函数调用 eval 的时候，该函数的调用操作符（括号）遇到一个对 eval 的引用可以确定被调用函数的名称。所以此时函数会触发一个直接的 eval 调用。当然你可以不给调用操作符引用来强制间接调用 eval。这是由于在操作符运行之前获取引用的值来实现的。在 （1）标注的那一行，逗号操作符为我们实现的这点。这个运算符运行了第一个运算元并返回了第二个运算元的结果。运算结果总是返回 值 的，意味着引用已经被解析。 间接的运行代码总是松散的。这是由于代码被独立的在当前环境中运行的结果。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function strictFunc()&#123; </span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    var code = &apos;(function()&#123; return this; &#125;())&apos;;</span><br><span class="line">    var result = eval.call( null, code );</span><br><span class="line">    console.log( result !== undefined ); // true sloppy mode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function()"></a>new Function()</h2><p>Function 构造函数的函数签名。<br>new Function( param1, param2, …, paramN,funcBody );<br>它创建一个包含0个或者过个参数名为 param1 等的函数，函数体为 funcBody。相当于如下方式创建函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ( (param1), (param2), ..., (paramN) )&#123; </span><br><span class="line">        (funcBody)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x+y&apos;); </span><br><span class="line">f( 3, 4 )</span><br></pre></td></tr></table></figure>
<p>与间接 eval 调用类似，newFunction() 创建的函数作用域也是全局的。 </p>
<pre><code>var x = &apos;global&apos;; 
function strictFunc(){
   &apos;use strict&apos;;
   var x = &apos;local&apos;;
   var f = new Function(&apos;return x&apos;);
   console.log( f() ); //global
} 
</code></pre><p>以下的函数也是默认松散模式 </p>
<pre><code>function strictFunc(){ 
    &apos;use strict&apos;;
    var sl = newFunction( &apos;return this&apos; );
    console.log( sl() !== undefined ); // true, sloppy modevar st = newFunction( &apos;&quot;use strict&quot;; return this;&apos; );
    console.log( st() !== undefined ); // true, strict mode
} 
</code></pre><ol>
<li>eval() 对比 new Function()<font color="#ff0000">一般来说，使用 new Function() 运行代码比 eval() 更为好一些：函数的参数提供了清晰的接口来运行代码，而没有必要使用较为笨拙的语法来间接的调用 eval() 确保代码只能访问自己的和全局的变量。</font></li>
<li>最佳实践<br><font color="#ff0000">通常：避免使用 eval() 和 new Function() 。动态运行代码不但速度较慢，还有潜在的安全风险。一般都可以找到更好地替代方案。</font><br>你也不应该使用 eval() 或者 newFunction() 来解析 JSON格式的数据。那也是不安全的。要么使用 ECMAScript 5 内置的对JSON的支持方法，要么使用一个类库。<br>合理使用实例。依旧有一些较为合理，对 eval() 和 newFunction() 使用较为高级的：配置函数数据（JSON 不允许），模板库，解析，命令行和模块系统。 </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/25/JS常用设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/25/JS常用设计模式/" itemprop="url">JS常用设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-25T19:50:28+08:00">
                2016-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>由于 JS 或者前端的场景限制，并不是 23 种设计模式都常用。</p>
<p>有的是没有使用场景，有的模式使用场景非常少，所以只是列举 7 个常见的模式</p>
<blockquote>
<p>本文的脉络：</p>
</blockquote>
<ul>
<li>设计与模式</li>
<li>5 大设计原则</li>
<li>7 种常见的设计模式</li>
</ul>
<blockquote>
<p>一句话解释含义</p>
</blockquote>
<ul>
<li>列举生活中的场景 、 业务代码场景</li>
<li>js 代码演示</li>
</ul>
<h2 id="设计与模式"><a href="#设计与模式" class="headerlink" title="设计与模式"></a>设计与模式</h2><p>之前一直以为「设计模式」是一个完整的名词</p>
<p>其实「设计」和「模式」是要分开来说的</p>
<ul>
<li>「设计」：5 个常见的设计原则</li>
<li>「模式」：代码中常见的”套路”,被程序员总结成了相对固定的写法，称之为「模式」</li>
</ul>
<p>也就是说学习”设计模式”,首先肯定要学习和理解 5 个设计原则。</p>
<p>因为所有的模式，都是肯定是符合 5 大设计原则中的几个，至少不违背设计原则的。</p>
<p>所以我们在学习模式时，不能上来就把 23 种模式的 js 实现看一遍，这样是很难理解的。</p>
<p>我觉得正确的学习顺序是：</p>
<ul>
<li>先学习 5 大设计原则</li>
<li>再学习 23 种模式</li>
</ul>
<p>而「模式」的学习顺序是：</p>
<ul>
<li>1.尝试用一句话概括这个模式。 （不理解也没关系，至少对定义有一个大致印象）</li>
<li>2.联想在生活中的例子。（模式往往反映一种思想）</li>
<li>3.更重要的是理解「模式」的代码中的应用（有的模式思想在生活中可能没有合适的例子）</li>
<li>4.最后才是用 js 代码去演示和实现「模式」</li>
</ul>
<p>「模式」的学习步骤中，我觉得<strong>理解在代码中应用场景</strong>是最重要的</p>
<p>这也是为什么所谓 23 种「模式」，这个文章只是大致讲了 7 种。</p>
<p>因为我觉得没有很多场景的模式，学习了意义也不大。</p>
<h2 id="5-大设计原则"><a href="#5-大设计原则" class="headerlink" title="5 大设计原则"></a>5 大设计原则</h2><p>5 大设计原则，可能书和书的叫法不太一样。</p>
<p>但是我觉得最重要的是，理解意思即可，毕竟实际上并不是所有「模式」都满足 5 大设计原则</p>
<p>往往只是满足 1、2 条，然后不违反其他原则，这样。</p>
<ul>
<li><strong>1.单一职责原则</strong></li>
<li><strong>2.开放-封闭原则</strong></li>
<li><strong>3.面向接口编程</strong></li>
<li>4.李氏置换原则</li>
<li>5.接口独立原则</li>
</ul>
<p>个人理解 前 3 点 比较常见，后面的 2 个原则我也不太理解，或者可能前端场景下比较少见。</p>
<blockquote>
<p>单一职责原则</p>
</blockquote>
<p>一个函数只做一件事，如果功能过于复杂，最好让一段代码只负责一部分逻辑。</p>
<blockquote>
<p>开放-封闭原则</p>
</blockquote>
<p>对拓展开放，对修改封闭。</p>
<ul>
<li>比如常见的 Vue 和 jQuery 都提供插件拓展机制，你如果希望增加功能，可以拓展某一个技术栈的生态。而不是直接修改源码</li>
</ul>
<blockquote>
<p>面向接口编程</p>
</blockquote>
<p>调用者时，只按照接口，不必清楚接口内部的类如何实现。</p>
<ul>
<li>比如前后分离开发时，前端只需要关注接口文档，不必了解具体实现</li>
<li>比如设计 UI 组件时，我只需要考虑用户需要如何调用，不用让他操心，我的内部实现。</li>
</ul>
<h2 id="7-种常见的设计模式"><a href="#7-种常见的设计模式" class="headerlink" title="7 种常见的设计模式"></a>7 种常见的设计模式</h2><p>我们要说的 7 种常见设计模式如下：</p>
<ul>
<li>工厂模式</li>
<li>单例模式</li>
<li>适配器模式</li>
<li>装饰器模式</li>
<li>代理模式</li>
<li>观察者模式</li>
<li>迭代器模式</li>
</ul>
<p>每 1 个模式的学习顺序遵循以下 3 点</p>
<ul>
<li><p>一句话概括这个模式的思想</p>
</li>
<li><p>生活场景的应用 和 业务场景的应用(重点理解业务场景)</p>
</li>
<li><p>js 演示该模式</p>
</li>
</ul>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>一句话描述: 工厂模式将 new 操作符封装，拓展一个 create 的接口开发给调用者</p>
</blockquote>
<p>业务场景</p>
<ul>
<li>jQuery 的 $()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.$ = function(selector) &#123;</span><br><span class="line">    returnnew jQuery(selector);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比如 jQuery 把 $暴露给开发者，类似于 create 方法。</p>
<p>有了$一般我们也不会使用 new jQuery() 来创建 jquery 对象</p>
<p>这样做的好处:</p>
<ul>
<li>$作为 create 写起来更加简单</li>
<li>做了一层拓展，这样暴露给用户的是$,内部源码可以做各种修改，甚至不叫jQuery叫xQuery也可以，只要最终还是暴露$,对用户来说就是一样的。</li>
</ul>
<p><strong>符合开放-封闭原则</strong></p>
<blockquote>
<p>js 演示</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Product&#123;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.name = options.name;</span><br><span class="line">        this.time = options.time;</span><br><span class="line">        this.init();</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        console.log(`产品名：$&#123;this.name&#125; 保质期：$&#123;this.time&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    create(options) &#123;</span><br><span class="line">        returnnew Product(options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let factory = new Factory();</span><br><span class="line">let product1 = factory.create(&#123; name: &quot;面包&quot;, time: &quot;1个月&quot; &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote>
<p>一句话描述：一个类只有一个实例<br>业务场景</p>
</blockquote>
<ul>
<li>场景 1: 比如 Vue 的插件机制。Vue.use()多次，也只存在第一个插件实例。</li>
<li>场景 2: 比如 Vuex 的 Store 在实例化时，就算你实例化多个，也只存在一个 Store,这样才能保证共享数据嘛。</li>
<li>场景 3: 创建一个购物车组件。因为购物车往往整个项目只需要 1 个</li>
</ul>
<p>比如 Vue.use 时，我们知道 Vue 源码中会去做判断调用插件的 install 方法</p>
<p>但是只要 Vue.use 就直接调用的。</p>
<p>Vue 会把 Vue.use 的东西 push 到一个数组，每次执行 use 方法都会先检查数组里是否已经有这个插件了，没有就 push，有的话就不再执行后面的逻辑了。</p>
<p>这样保证项目，这个插件的 install 只初始化 1 次。</p>
<p>我觉得这就是单例模式思想的一种应用。来避免多次初始化可能造成的问题。</p>
<blockquote>
<p>js 实现演示</p>
</blockquote>
<p>实现思路</p>
<ul>
<li>给 SingleObject 添加一个静态方法 getInstance</li>
<li>将来实例化时，不是通过 new，而是 SingleObject.getInstance()</li>
<li>getInstance 内部的实现就是，第一次调用是用变量缓存实例。之后调用时判断该变量是否有值，没有值就可以 new，有值就把这个变量 return</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function SingleObject() &#123;</span><br><span class="line">    this.instance = null;</span><br><span class="line">    this.name = &quot;单例&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleObject.getInstance = function() &#123;</span><br><span class="line">    if (this.instance === null) &#123;</span><br><span class="line">        this.instance = new SingleObject();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        returnthis.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = SingleObject.getInstance();</span><br><span class="line">var obj2 = SingleObject.getInstance();</span><br><span class="line"></span><br><span class="line">console.log(obj1 === obj2);</span><br></pre></td></tr></table></figure>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><blockquote>
<p>一句话描述： 接口不兼容时，对旧接口做一层包装，来适配新需求。<br>生活场景</p>
</blockquote>
<p>插头的电压，不同国家是存在差异的嘛，经常有电源适配器来做一层包装，从而适配我们的电压。</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<ul>
<li>Vue 的 computed 提供给函数和对象 2 种写法。Vue 内部需要做一层适配</li>
<li>Node.js 中间层</li>
</ul>
<p>比如 Vue 源码内部遍历 computed 对象后，需要把用户传递的函数作为该计算属性的 getter 的返回值嘛</p>
<p>但是用户有可能会传递 fn，也可能传递一个带 get、set 方法的对象</p>
<p>那么 Vue 面对用户提供的不同接口，它就需要做一层适配。</p>
<p>无论函数直接提供函数，还是提供的对象，Vue 都转化为一个函数</p>
<p>Vue 类似这种处理非常多，因为 Vue 提供给用户很宽松的写法嘛。比如你可以用 template 也可以用 render，但是最终 template 一定会被适配成 render 来调用</p>
<p>另一个例子，我觉得现在流行的 Node.js 中间层，也算是适配器模式的应用。</p>
<p>后端提供一些基础数据，但是移动端和 PC 端要求的数据格式是不同，且经常变化的。</p>
<p>Node.js 中间层的作用，可以让后端的基础数据不做变化，只是对数据在 Node 中再包装一次，来适配具体的业务场景</p>
<blockquote>
<p>js 实现演示</p>
</blockquote>
<p>重点理解这个适配器，在业务的应用。</p>
<p>感觉单纯用 js 代码演示可能比较呆板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 新增加的适配器</span><br><span class="line">class Adaptee&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name = &quot;我是适配器&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parse() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 原来的旧代码</span><br><span class="line">class OldApi&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = &apos;我是旧的接口&apos;this.adaptee = new Adaptee()</span><br><span class="line">        this.adaptee.parse()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var oldApi = new OldApi()</span><br></pre></td></tr></table></figure></p>
<p>这样我们拓展了一个新的叫做适配器的类，利用它来处理旧数据，而不是直接去具体修改旧数据</p>
<p>对拓展开发，对修改封闭，典型的符合开发-封闭的设计原则</p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><blockquote>
<p>一句话描述： 1.为对象装饰一些新功能，2.旧的功能属性全都保留<br>生活场景</p>
</blockquote>
<p>手机壳对于手机，就是一种装饰器</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<ul>
<li>ES7的装饰器语法</li>
</ul>
<p>下面介绍了「ES7的 @ 装饰符」的使用，可以直接跳过。</p>
<ul>
<li>可以修饰类</li>
</ul>
<p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function decorator(target)&#123;</span><br><span class="line">    target.type = &apos;人类&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">class Animal&#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(Animal.type)</span><br></pre></td></tr></table></figure></p>
<p><strong>不传递参数时 @ 就相当于 Animal = decorator(Animal) || Animal</strong></p>
<p>也可以传递参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function setType(type)&#123;</span><br><span class="line">    returnfunction(target)&#123;</span><br><span class="line">        target.type = type</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@setType(&apos;人类&apos;)</span><br><span class="line">classAnimal&#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(Animal.type)</span><br></pre></td></tr></table></figure></p>
<p><strong>传递参数时 @ 就相当于 Animal = setType(type)(Animal) || Animal</strong></p>
<ul>
<li>也可以修饰类中的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; return`$&#123;this.first&#125;$&#123;this.last&#125;` &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function readonly(target, name, descriptor)&#123;</span><br><span class="line">  descriptor.writable = false;</span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>readonly的3个参数含义如下</p>
<ul>
<li>target： Person.prototype</li>
<li>name : key</li>
<li>descriptor : 描述器</li>
</ul>
<blockquote>
<p>js演示</p>
</blockquote>
<p>实现东西</p>
<p>就是我有一个Circle类，用circle.draw()可以画一个圆</p>
<p>经过装饰后，可以画一个带红色边框的圆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Circle&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">        console.log(&quot;draw&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Decorator&#123;</span><br><span class="line">    constructor(circle) &#123;</span><br><span class="line">        this.circle = circle</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setRedBorder() &#123;</span><br><span class="line">        console.log(&apos;border装饰为红色&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw() &#123;</span><br><span class="line">        this.circle.draw()</span><br><span class="line">        this.setRedBorder()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let circle = new Circle()</span><br><span class="line">let decorator = new Decorator(circle)</span><br><span class="line"></span><br><span class="line">circle.draw()</span><br><span class="line">decorator.draw()</span><br></pre></td></tr></table></figure></p>
<p>符合单一职责原则，和开放-封闭原则</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>一句话描述: 无法直接访问时，通过代理来访问目标对象</p>
</blockquote>
<p>这里区分一下适配器模式、代理模式、装饰器模式</p>
<ul>
<li><p>适配器模式是在原来的基础上，做了一层包装。虽然没有动原来的接口，但最终我们是用包装好的适配后的数据，肯定有修改的。</p>
</li>
<li><p>代理模式，是通过代理，访问原数据。没有什么包装和修改。</p>
</li>
<li><p>装饰器模式，是原来的功能和函数都还要用的的基础上，增加一些拓展功能。而适配的话是在包装时做一些改造。</p>
</li>
</ul>
<blockquote>
<p>生活场景</p>
</blockquote>
<ul>
<li>翻墙用的VPN</li>
<li>海外代购</li>
<li>各级代理商</li>
</ul>
<blockquote>
<p>业务场景</p>
</blockquote>
<ul>
<li>绑定多个li时的事件代理</li>
<li>Vue的data、props被访问时，就做了代理。</li>
<li>ES6的proxy的代理</li>
</ul>
<p>ul下多个li，通过给父元素绑定click事件，实现对多个li的监听。叫做事件代理</p>
<p>当然这里能实现代理，也依靠了事件冒泡。但是不过是利用什么机制做的代理。这种思想可以看做是代理的思想。</p>
<p>Vue的data，在Vue初始化时，this._init() ==&gt; this.initState() ==&gt; this.initData()</p>
<p>在initData中，除了递归循环把vm的data全都包装为响应式对象之外，还调用了proxy()</p>
<p>这个proxy内部实现的，就是当你访问this.msg时，实际上就访问了this.data.msg</p>
<p>毕竟我们不可能真的把msg挂到Vue.prototype上。</p>
<p>这也是代理的思想。但是当然不是冒泡机制实现的，这里是利用引用的传递。</p>
<p>ES6还提供了Proxy,被Proxy包装的对象，也是一种代理。</p>
<p>原对象和包装后的对象，很像明星和经纪人之间的关系</p>
<blockquote>
<p>js演示</p>
</blockquote>
<p>实现的效果就是proxyData.getName()，代理的是data.getName()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Data&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = &apos;元数据&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getName()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyData&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.data = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getName()&#123;</span><br><span class="line">        this.data.getName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let data = new Data()</span><br><span class="line">let proxyData = new ProxyData(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data.getName()</span><br><span class="line">proxyData.getName()</span><br></pre></td></tr></table></figure></p>
<p>代理模式符合开放-封闭原则</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote>
<p>一句话描述：把watcher收集到一个队列，等到发布时再依次通知watcher，来实现异步的一种模式。<br>生活场景</p>
</blockquote>
<p>观察者模式被广泛的应用在日常生活和开发实践中</p>
<ul>
<li>斗鱼主播是发布者，观众但是订阅者。</li>
<li>猎头是发布者，候选人是订阅者</li>
<li>赛跑时，裁判开枪来发布，所有的运动员就是订阅者。</li>
</ul>
<p>这里订阅者也可以理解为观察者。</p>
<blockquote>
<p>业务场景</p>
</blockquote>
<ul>
<li>1.Vue的收集依赖、派发更新</li>
<li>2.浏览器事件机制</li>
<li>3.Promise.then的异步事件</li>
<li>4.Vue的生命周期钩子</li>
<li>5.Node.js的eventEmitter</li>
<li>场景1：Vue的收集依赖、派发更新</li>
</ul>
<p>「订阅」: Vue的响应式数据，在页面渲染时，触发getter收集watcher依赖。</p>
<p>「发布」:数据变化时，触发setter，Notify所有的watcher调用他们的update方法</p>
<ul>
<li>场景2：浏览器事件机制</li>
</ul>
<p>「订阅」: btn绑定了click事件，那个fn就被放到事件队列中<br>「发布」: 用户点击时，触发click事件。</p>
<ul>
<li>场景3 : Promise.then</li>
</ul>
<p>「订阅」: then调用时，把then的成功函数保存在一个变量中</p>
<p>「发布」: 当调用resolve时，状态变化，并且把保存的then的成功函数调用</p>
<ul>
<li>场景4: Vue的生命周期钩子</li>
</ul>
<p>「订阅」: 在option上写beforeCreate对应的函数</p>
<p>「发布」: 当组件初始化阶段，到了对应时机，vue帮你调用用户提供的函数</p>
<blockquote>
<p>js实现一个eventEmiiter</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.eventMap = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on( type, fn ) &#123;</span><br><span class="line">        if ( !this.eventMap[type] ) &#123;</span><br><span class="line">            this.eventMap[type] = []</span><br><span class="line">        &#125; </span><br><span class="line">        this.eventMap[type].push(fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit( type, ...params ) &#123;</span><br><span class="line">        this.eventMap[type].forEach(fn =&gt; &#123;</span><br><span class="line">            fn(...params);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off( type, fn ) &#123;</span><br><span class="line">        let list = this.eventMap[type];</span><br><span class="line">        let atIndex = list.indexOf(fn);</span><br><span class="line">        </span><br><span class="line">        if (atIndex !== -1) &#123;</span><br><span class="line">            list.splice(atIndex, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><blockquote>
<p>一句话描述： 1.按顺序访问集合, 2.调用者不用关系内部的数据结构</p>
</blockquote>
<p>ES6之后，我们知道除了数组之外的有序集合挺多的</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>nodelist</li>
<li>arguments</li>
</ul>
<p>那数组的迭代，或者遍历可以用10几种API</p>
<p>那么如果要遍历Map/Set或者nodelist呢。如果给每一种数据结构都搞一套API就会很麻烦</p>
<p>包括JQ都有each遍历。</p>
<p>会导致api泛滥的，所以我们把遍历这种行为，抽象成一种模式。</p>
<blockquote>
<p>场景</p>
</blockquote>
<ul>
<li>ES6的iterator</li>
<li>为什么需要iterator</li>
<li>iterator是什么</li>
</ul>
<p>了解一下iterator的内容，如果已经了解可以直接跳过</p>
<blockquote>
<p>为什么需要iterator</p>
</blockquote>
<p>因为js需要遍历的数据结构越来越多，如果给每一个数据结构都搞一套API会很麻烦。</p>
<p>所以，需要有一个统一的接口，可以遍历各种数据结构。</p>
<blockquote>
<p>iterator是什么</p>
</blockquote>
<p>就是比如Array.prototype就有一个[Symbol.iterator]属性</p>
<p>这个属性对应的是一个函数，函数调用后，得到一个迭代器</p>
<p>我们用这个迭代器就可以遍历各种符合iterator标准的数据结构啦。</p>
<p>怎么遍历呢？ 迭代器有next，用while去迭代</p>
<p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function each(data) &#123;</span><br><span class="line">    let iterator = data[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">    let item = &#123; done: false &#125;;</span><br><span class="line">    while (item.done === false) &#123;</span><br><span class="line">        item = iterator.next();</span><br><span class="line">        if ( item.done ) return item</span><br><span class="line">        console.log(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4];</span><br><span class="line">let nodeList = document.querySelectorAll(&quot;p&quot;);</span><br><span class="line">let m = newMap();</span><br><span class="line">m.set(&quot;a&quot;, 100);</span><br><span class="line">m.set(&quot;b&quot;, 100);</span><br><span class="line"></span><br><span class="line">each(arr)</span><br><span class="line">each(nodeList)</span><br><span class="line">each(m)</span><br></pre></td></tr></table></figure></p>
<p>那么，难道每一个开发者，都需要自己封装一个each方法吗？</p>
<p>ES6提供的for…of就是类似于each，用来遍历符合iterator接口的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( let v of nodeList ) &#123;</span><br><span class="line">    console.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>迭代器模式的js实现</p>
</blockquote>
<p>这个要关注实现思路。</p>
<p>这里只是把数组设计成迭代器，有一个next方法和hasNext方法</p>
<p>需要有2个类</p>
<ul>
<li>1.Wrapper类，提供一个getIterator方法，可以生成一个迭代器</li>
<li>2.Iterator类，迭代器。有next和hasNext方法</li>
</ul>
<pre><code>class Iterator{
    constructor(wrapper) {
        this.list = wrapper.list
        this.index = 0
    }

    next() {
        if ( this.hasNext() ) {
            returnthis.list[this.index++]
        } else {
            returnnull            
        }
    }

    hasNext() {
        returnthis.index &lt; this.list.length
    }
}


class Wrapper{
    constructor(list) {
        this.list = list
    }

    getIterator(iterator) {
        returnnew Iterator(this)
    }
}

var arr = [1, 2, 3]
var iterator = new Wrapper( arr ).getIterator()
while ( iterator.hasNext() ) {
    console.log(iterator.next())
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/11/防抖和节流原理分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/11/防抖和节流原理分析/" itemprop="url">防抖和节流原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-11T14:51:19+08:00">
                2016-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>窗口的resize、scroll、输入框内容校验等操作时，如果这些<strong>操作处理函数</strong>是较为复杂或页面频繁重渲染等操作时，在这种情况下如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来<strong>减少触发的频率</strong>，同时又不影响实际效果。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>debounce（防抖），简单来说就是防止抖动。</p>
<p>当持续触发事件时，debounce 会<strong>合并事件且不会去触发事件</strong>，<strong>当一定时间内没有触发再这个事件时，才真正去触发事件</strong>。</p>
<h3 id="非立即执行版"><a href="#非立即执行版" class="headerlink" title="非立即执行版"></a>非立即执行版</h3><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p>
<pre><code>const debounce = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() =&gt; {
      func.apply(context, args)
    },wait);
  }
}
</code></pre><p>如此调用：</p>
<pre><code>content.onmousemove = debounce(count,1000);
</code></pre><h3 id="立即执行版"><a href="#立即执行版" class="headerlink" title="立即执行版"></a>立即执行版</h3><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p>
<pre><code>const debounce = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if (timeout) cleatTimeout(timeout);
    let callNow = !timeout;
    timeout = setTimeout(() =&gt; {
      timeout = null;
    },wait)

    if(callNow) func.apply(context,args)
   }
}
</code></pre><h3 id="结合版"><a href="#结合版" class="headerlink" title="结合版"></a>结合版</h3><pre><code>/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */functiondebounce(func,wait,immediate) {
    var timeout;

    returnfunction () {
        var context = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}
</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>throttle（节流），当持续触发事件时，<strong>保证隔间时间触发一次事件</strong>。</p>
<p>持续触发事件时，throttle 会合并一定时间内的事件，并在该时间结束时真正去触发一次事件。</p>
<h3 id="时间戳版"><a href="#时间戳版" class="headerlink" title="时间戳版"></a>时间戳版</h3><p>在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。</p>
<pre><code>const throttle = (func, wait, ...args) =&gt; {
  let pre = 0;
  returnfunction(){
    const context = this;
    let now = Date.now();
    if (now - pre &gt;= wait){
       func.apply(context, args);
       pre = Date.now();
    }
  }
}
</code></pre><h3 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版"></a>定时器版</h3><p>在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p>
<pre><code>const throttle = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if(!timeout){
      timeout = setTimeout(() =&gt; {
        timeout = null;
        func.apply(context,args);
      },wait)
    }
  }
}
</code></pre><h3 id="结合版-1"><a href="#结合版-1" class="headerlink" title="结合版"></a>结合版</h3><p>其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p>
<pre><code>/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */functionthrottle(func, wait ,type) {
    if(type===1){
        var previous = 0;
    }elseif(type===2){
        var timeout;
    }

    returnfunction() {
        var context = this;
        var args = arguments;
        if(type===1){
            var now = Date.now();

            if (now - previous &gt; wait) {
                func.apply(context, args);
                previous = now;
            }
        }elseif(type===2){
            if (!timeout) {
                timeout = setTimeout(function() {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }

    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tx.jpg" alt="李斌">
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">157</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">111</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
  <!--
  	描述：点击红心
  -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
  <!--
  	描述：复制代码
  -->
  <script type="text/javascript" src="/js/src/clipboard.min.js"></script>
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
</body>
</html>



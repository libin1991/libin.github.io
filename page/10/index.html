<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Blog">
<meta property="og:type" content="website">
<meta property="og:title" content="LuckDay">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="LuckDay">
<meta property="og:description" content="Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LuckDay">
<meta name="twitter:description" content="Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/10/"/>





  <title>LuckDay - 想要飞得高，那就把地平线忘掉</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div class="sky">
	<div class="clouds_one"></div>
	<div class="clouds_two"></div>
	<div class="clouds_three"></div>
</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LuckDay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">想要飞得高，那就把地平线忘掉</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/16/前端代码异常监控实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/16/前端代码异常监控实战/" itemprop="url">前端代码异常监控实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-16T11:22:33+08:00">
                2016-09-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="把前端监控做到极致-掘金"><a href="#把前端监控做到极致-掘金" class="headerlink" title="把前端监控做到极致 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a52f138f265da3e5b32a41b" target="_blank" rel="noopener">把前端监控做到极致 - 掘金</a></h2><h2 id="线上压缩代码-定位错误-掘金"><a href="#线上压缩代码-定位错误-掘金" class="headerlink" title="线上压缩代码-定位错误 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a4f6886518825734216b352" target="_blank" rel="noopener">线上压缩代码-定位错误 - 掘金</a></h2><p>生产环境没有source-map文件，上报的错误都不好定位，这里实现一个简单的错误定位脚本</p>
<p>1、获取压缩代码错误信息（行数、列数、错误信息，错误文件）</p>
<h2 id="这里通过控制台看错误信息"><a href="#这里通过控制台看错误信息" class="headerlink" title="这里通过控制台看错误信息"></a>这里通过控制台看错误信息</h2><pre><code>window.addEventListener(&apos;error&apos;, function (e) {
    console.debug(&apos;lineno: &apos;, e.lineno, &apos; colno: &apos;, e.colno)
    console.debug(&apos;errorMessage:&apos;, e.message)
    console.debug(&apos;errorFile:&apos;, e.filename)
}, true)
</code></pre><p>我们写一段错误的代码（single.vue的片段）</p>
<pre><code>method: {
   test (option) {
        const data = option.test
        const dataTest = option.data.test
        return data + dataTest
    }
}, 
created () {
    // 设置异步错误的原因是，同步的错误会被vue捕获
    setTimeout(() =&gt; {
        this.test({
          testOption: 1
        })
    }, 300)
}
</code></pre><p>在浏览器中运行，报错结果如下<br><img src="https://pic4.zhimg.com/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_hd.jpg" alt=""></p>
<p>得到错误信息：</p>
<ul>
<li>错误行数：1</li>
<li>错误列数：59236</li>
<li>错误信息：cannot read property ‘test’ of undefined</li>
<li>错误文件：0.0a77f.js</li>
</ul>
<p>2、定位错误的node脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## 安装依赖source-map</span><br><span class="line"></span><br><span class="line"> npm install source-map</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    node脚本如下（map/index.js）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> // 读取文件</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">// souceMap处理文件</span><br><span class="line">var SourceMapConsumer = require(&apos;source-map&apos;).SourceMapConsumer</span><br><span class="line">// 启动构建进程（已构建则不需要）</span><br><span class="line">var exec = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">var lineno = process.argv[2] || 0   // 第一个参数为行数</span><br><span class="line">var columnno = process.argv[3] || 0 // 第二个参数为列数</span><br><span class="line">var fileName = process.argv[4] || &apos;&apos; // 第三个参数为错误文件（错误文件名就好）</span><br><span class="line"></span><br><span class="line">// 构建有map的线上代码</span><br><span class="line">// node build onlineMap为构建命令</span><br><span class="line">exec(&apos;node build onlineMap&apos;, function () &#123;</span><br><span class="line"> // 读取错误文件的map文件</span><br><span class="line"> var consumer = new SourceMapConsumer(fs.readFileSync(&apos;./dist/&apos; + fileName + &apos;.map&apos;, &apos;utf8&apos;))</span><br><span class="line">  // 输出map的错误信息</span><br><span class="line">  console.log(consumer.originalPositionFor(&#123;</span><br><span class="line">    line: +lineno,      // +是为了转化为数字</span><br><span class="line">    column: +columnno</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">    运行node脚本</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> node map 1 59236 0.0a77f.js</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>效果如下：</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/v2-cf68e7b673405c90fe024bf48dfb42c7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf68e7b673405c90fe024bf48dfb42c7_hd.jpg" alt=""></p>
<p>结合控制台输出的信息，就可以定位到错误代码了</p>
<p>我们再来看一下，给代码开启source-map，看错误信息是否一致</p>
<p><img src="https://pic3.zhimg.com/v2-5319b431cef161a0a07ba46f8b0e6a02_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-5319b431cef161a0a07ba46f8b0e6a02_hd.jpg" alt=""><br>错误代码的位置定位是准确的，证明可行。</p>
<p>3、后续扩展思路</p>
<h2 id="目前实现的是比较简单的脚本，所以存在一些问题："><a href="#目前实现的是比较简单的脚本，所以存在一些问题：" class="headerlink" title="目前实现的是比较简单的脚本，所以存在一些问题："></a>目前实现的是比较简单的脚本，所以存在一些问题：</h2><ul>
<li>需要当前构建内容和线上是一致的</li>
<li>操作比较繁琐</li>
</ul>
<p>优化思路如下：</p>
<p><img src="https://pic4.zhimg.com/v2-a8b63ecc364c66c8bf4bbec9880f8c23_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a8b63ecc364c66c8bf4bbec9880f8c23_hd.jpg" alt=""></p>
<p>后续优化慢慢补充~</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在对公司的前端代码脚本错误进行排查，试图降低 JS Error 的错误量，结合自己之前的经验对这方面内容进行了实践并总结，下面就此谈谈我对前端代码异常监控的一些见解。</p>
<p>本文大致围绕下面几点展开讨论：</p>
<ol>
<li>JS 处理异常的方式</li>
<li>上报方式</li>
<li>异常监控上报常见问题</li>
</ol>
<h2 id="JS-异常处理"><a href="#JS-异常处理" class="headerlink" title="JS 异常处理"></a>JS 异常处理</h2><p>对于 Javascript 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p>
<ol>
<li>当前代码块将作为一个任务压入任务队列中，JS 线程会不断地从任务队列中提取任务执行。</li>
<li>当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务的执行。</li>
<li><p>JS 线程会继续从任务队列中提取下一个任务继续执行。</p>
 <script>
   error
   console.log('永远不会执行');
 </script>
 <script>
   console.log('我继续执行')
 </script>


</li>
</ol>
<p><img src="https://pic2.zhimg.com/v2-7a136ce7674914bcd7b7f42986d0c5bc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7a136ce7674914bcd7b7f42986d0c5bc_hd.jpg" alt=""></p>
<p>在对脚本错误进行上报之前，我们需要对异常进行处理，程序需要先感知到脚本错误的发生，然后再谈异常上报。</p>
<p>脚本错误一般分为两种：语法错误，运行时错误。</p>
<p>下面就谈谈几种异常监控的处理方式：</p>
<h2 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h2><p>try-catch 在我们的代码中经常见到，通过给代码块进行 try-catch 进行包装后，当代码块发生出错时 catch 将能捕捉到错误的信息，页面也将可以继续执行。</p>
<p>但是 try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误和异步错误就显得无能为力，捕捉不到。</p>
<h2 id="示例：运行时错误"><a href="#示例：运行时错误" class="headerlink" title="示例：运行时错误"></a>示例：运行时错误</h2><pre><code>try {
  error    // 未定义变量 
} catch(e) {
  console.log(&apos;我知道错误了&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-dc8ba7e4b9e56127799c11b46cf7068d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-dc8ba7e4b9e56127799c11b46cf7068d_hd.jpg" alt=""></p>
<p>然而对于语法错误和异步错误就捕捉不到了。</p>
<h2 id="示例：语法错误"><a href="#示例：语法错误" class="headerlink" title="示例：语法错误"></a>示例：语法错误</h2><pre><code>try {
  var error = &apos;error&apos;；   // 大写分号
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic3.zhimg.com/v2-8ddf6acf0f42c4b08ba8b73798b863a0_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8ddf6acf0f42c4b08ba8b73798b863a0_hd.jpg" alt=""></p>
<p>一般语法错误在编辑器就会体现出来，常表现的错误信息为： Uncaught SyntaxError: Invalid or unexpected token xxx 这样。但是这种错误会直接抛出异常，常使程序崩溃，一般在编码时候容易观察得到。</p>
<h2 id="示例：异步错误"><a href="#示例：异步错误" class="headerlink" title="示例：异步错误"></a>示例：异步错误</h2><pre><code>try {
  setTimeout(() =&gt; {
    error        // 异步错误
  })
} catch(e) {
  console.log(&apos;我感知不到错误&apos;);
  console.log(e);
}
</code></pre><p><img src="https://pic4.zhimg.com/v2-0ed67a00e3c7762e74975bebbbc88274_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-0ed67a00e3c7762e74975bebbbc88274_hd.jpg" alt=""></p>
<p>除非你在 setTimeout 函数中再套上一层 try-catch，否则就无法感知到其错误，但这样代码写起来比较啰嗦。</p>
<h2 id="window-onerror-异常处理"><a href="#window-onerror-异常处理" class="headerlink" title="window.onerror 异常处理"></a>window.onerror 异常处理</h2><p>window.onerror 捕获异常能力比 try-catch 稍微强点，无论是异步还是非异步错误，onerror 都能捕获到运行时错误。</p>
<p>示例：运行时同步错误</p>
<pre><code>/**
 * @param {String}  msg    错误信息
 * @param {String}  url    出错文件
 * @param {Number}  row    行号
 * @param {Number}  col    列号
 * @param {Object}  error  错误详细信息
 */
 window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
error;
</code></pre><p>示例：异步错误</p>
<pre><code>window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道异步错误了&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
setTimeout(() =&gt; {
  error;
});
</code></pre><p><img src="https://pic3.zhimg.com/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_hd.jpg" alt=""></p>
<p>然而 window.onerror 对于语法错误还是无能为力，所以我们在写代码的时候要尽可能避免语法错误的，不过一般这样的错误会使得整个页面崩溃，还是比较容易能够察觉到的。</p>
<p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p>
<p>需要注意的是，window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。</p>
<p><img src="https://pic3.zhimg.com/v2-875235a4876ea8429f12e7aaf2f19588_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-875235a4876ea8429f12e7aaf2f19588_hd.jpg" alt=""></p>
<p>关于 window.onerror 还有两点需要值得注意</p>
<ol>
<li>对于 onerror 这种全局捕获，最好写在所有 JS 脚本的前面，因为你无法保证你写的代码是否出错，如果写在后面，一旦发生错误的话是不会被 onerror 捕获到的。</li>
<li>另外 onerror 是无法捕获到网络异常的错误。</li>
</ol>
<p>当我们遇到 <code>&lt;img src=&quot;./404.png&quot;&gt;</code> 报 404 网络请求异常的时候，onerror 是无法帮助我们捕获到异常的。</p>
<pre><code>&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道异步错误了&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot;&gt;
</code></pre><p><img src="https://pic3.zhimg.com/v2-81341c443f078b6526e0c6031dd40953_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81341c443f078b6526e0c6031dd40953_hd.jpg" alt=""></p>
<p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p>
<pre><code>&lt;script&gt;
window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我知道 404 错误了&apos;);
  console.log(
    msg, url, row, col, error
  );
  return true;
}, true);
&lt;/script&gt;
&lt;img src=&quot;./404.png&quot; alt=&quot;&quot;&gt;
</code></pre><p><img src="https://pic4.zhimg.com/v2-6d1c1196acd800a4a4475ee6847ee82a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6d1c1196acd800a4a4475ee6847ee82a_hd.jpg" alt=""></p>
<p>这点知识还是需要知道，要不然用户访问网站，图片 CDN 无法服务，图片加载不出来而开发人员没有察觉就尴尬了。</p>
<h2 id="Promise-错误"><a href="#Promise-错误" class="headerlink" title="Promise 错误"></a>Promise 错误</h2><p>通过 Promise 可以帮助我们解决异步回调地狱的问题，但是一旦 Promise 实例抛出异常而你没有用 catch 去捕获的话，onerror 或 try-catch 也无能为力，无法捕捉到错误。</p>
<pre><code>window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {
  console.log(&apos;我感知不到 promise 错误&apos;);
  console.log(
    msg, url, row, col, error
  );
}, true);
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic4.zhimg.com/v2-1ce580bb2344474b1df1517f2d11aa40_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-1ce580bb2344474b1df1517f2d11aa40_hd.jpg" alt=""></p>
<p>虽然在写 Promise 实例的时候养成最后写上 catch 函数是个好习惯，但是代码写多了就容易糊涂，忘记写 catch。</p>
<p>所以如果你的应用用到很多的 Promise 实例的话，特别是你在一些基于 promise 的异步库比如 axios 等一定要小心，因为你不知道什么时候这些异步请求会抛出异常而你并没有处理它，所以你最好添加一个 Promise 全局异常捕获事件 <strong>unhandledrejection</strong>。</p>
<pre><code>window.addEventListener(&quot;unhandledrejection&quot;, function(e){
  e.preventDefault()
  console.log(&apos;我知道 promise 的错误了&apos;);
  console.log(e.reason);
  return true;
});
Promise.reject(&apos;promise error&apos;);
new Promise((resolve, reject) =&gt; {
  reject(&apos;promise error&apos;);
});
new Promise((resolve) =&gt; {
  resolve();
}).then(() =&gt; {
  throw &apos;promise error&apos;
});
</code></pre><p><img src="https://pic2.zhimg.com/v2-115d494f26e4f8e2172e1f3b4cb6094f_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-115d494f26e4f8e2172e1f3b4cb6094f_hd.jpg" alt=""></p>
<p>当然，如果你的应用没有做 Promise 全局异常处理的话，那很可能就像某乎首页这样：</p>
<p><img src="https://pic2.zhimg.com/v2-37c6bc3763c147a4c97bdde688a59a5c_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-37c6bc3763c147a4c97bdde688a59a5c_hd.jpg" alt=""></p>
<h2 id="异常上报方式"><a href="#异常上报方式" class="headerlink" title="异常上报方式"></a>异常上报方式</h2><p>监控拿到报错信息之后，接下来就需要将捕捉到的错误信息发送到信息收集平台上，常用的发送形式主要有两种:</p>
<ol>
<li>通过 Ajax 发送数据</li>
<li>动态创建 img 标签的形式</li>
</ol>
<p>实例 - 动态创建 img 标签进行上报</p>
<pre><code>function report(error) {
  var reportUrl = &apos;http://xxxx/report&apos;;
  new Image().src = reportUrl + &apos;error=&apos; + error;
}
</code></pre><h2 id="监控上报常见问题"><a href="#监控上报常见问题" class="headerlink" title="监控上报常见问题"></a>监控上报常见问题</h2><p>下述例子我全部放在我的 github 上，读者可以自行查阅，后面不再赘述。</p>
<pre><code>git clone https://github.com/happylindz/blog.git
cd blog/code/jserror/
npm install
</code></pre><h2 id="Script-error-脚本错误是什么"><a href="#Script-error-脚本错误是什么" class="headerlink" title="Script error 脚本错误是什么"></a>Script error 脚本错误是什么</h2><p>因为我们在线上的版本，经常做静态资源 CDN 化，这就会导致我们常访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。</p>
<p><img src="https://pic3.zhimg.com/v2-840f71bf7014767132b47ad2c6a37238_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-840f71bf7014767132b47ad2c6a37238_hd.jpg" alt=""></p>
<p>可通过 <code>npm run nocors</code> 查看效果。</p>
<p>Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。</p>
<p><img src="https://pic2.zhimg.com/v2-fc3941d89716f96374576d0426ff4ccb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-fc3941d89716f96374576d0426ff4ccb_hd.jpg" alt=""></p>
<p>这样做的目的是避免数据泄露到不安全的域中，举个简单的例子，</p>
<pre><code>&lt;script src=&quot;xxxx.com/login.html&quot;&gt;&lt;/script&gt;
</code></pre><p>上面我们并没有引入一个 js 文件，而是一个 html，这个 html 是银行的登录页面，如果你已经登录了，那 login 页面就会自动跳转到 <code>Welcome xxx...</code>，如果未登录则跳转到 <code>Please Login...</code>，那么报错也会是 <code>Welcome xxx... is not defined，Please Login... is not defined</code>，通过这些信息可以判断一个用户是否登录他的帐号，给入侵者提供了十分便利的判断渠道，这是相当不安全的。</p>
<p>介绍完背景后，那么我们应该去解决这个问题？</p>
<p>首先可以想到的方案肯定是同源化策略，将 JS 文件内联到 html 或者放到同域下，虽然能简单有效地解决 script error 问题，但是这样无法利用好文件缓存和 CDN 的优势，不推荐使用。正确的方法应该是从根本上解决 script error 的错误。</p>
<h2 id="跨源资源共享机制-CORS"><a href="#跨源资源共享机制-CORS" class="headerlink" title="跨源资源共享机制( CORS )"></a>跨源资源共享机制( CORS )</h2><p>首先为页面上的 script 标签添加 crossOrigin 属性</p>
<pre><code>// http://localhost:8080/index.html
&lt;script&gt;
  window.onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
&lt;script src=&quot;http://localhost:8081/test.js&quot; crossorigin&gt;&lt;/script&gt;

// http://localhost:8081/test.js
setTimeout(() =&gt; {
  console.log(error);
});
</code></pre><p>当你修改完前端代码后，你还需要额外给后端在响应头里加上 <code>Access-Control-Allow-Origin: localhost:8080</code>，这里我以 Koa 为例。</p>
<pre><code>const Koa = require(&apos;koa&apos;);
const path = require(&apos;path&apos;);
const cors = require(&apos;koa-cors&apos;);
const app = new Koa();

app.use(cors());
app.use(require(&apos;koa-static&apos;)(path.resolve(__dirname, &apos;./public&apos;)));

app.listen(8081, () =&gt; {
  console.log(&apos;koa app listening at 8081&apos;)
});
</code></pre><p><img src="https://pic1.zhimg.com/v2-9717062e56340cef40ee67b438b2ba95_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-9717062e56340cef40ee67b438b2ba95_hd.jpg" alt=""></p>
<p>读者可通过 <code>npm run cors</code> 详细的跨域知识我就不展开了，有兴趣可以看看我之前写的文章：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>你以为这样就完了吗？并没有，下面就说一些 Script error 你不常遇见的点：</p>
<p>我们都知道 JSONP 是用来跨域获取数据的，并且兼容性良好，在一些应用中仍然会使用到，所以你的项目中可能会用这样的代码：</p>
<pre><code>// http://localhost:8080/index.html
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，但不知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
function jsonpCallback(data) {
  console.log(data);
}
const url = &apos;http://localhost:8081/data?callback=jsonpCallback&apos;;
const script = document.createElement(&apos;script&apos;);
script.src = url;
document.body.appendChild(script);
</code></pre><p>因为返回的信息会当做脚本文件来执行，一旦返回的脚本内容出错了，也是无法捕捉到错误的信息。</p>
<p><img src="https://pic4.zhimg.com/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_hd.jpg" alt=""></p>
<p>解决办法也不难，跟之前一样，在添加动态添加脚本的时候加上 crossOrigin，并且在后端配上相应的 CORS 字段即可.</p>
<pre><code>const script = document.createElement(&apos;script&apos;);
script.crossOrigin = &apos;anonymous&apos;;
script.src = url;
document.body.appendChild(script);
</code></pre><p>读者可以通过 <code>npm run jsonp</code> 查看效果</p>
<p><img src="https://pic4.zhimg.com/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_hd.jpg" alt=""></p>
<p>知道原理之后你可能会觉得没什么，不就是给每个动态生成的脚本添加 crossOrigin 字段嘛，但是在实际工程中，你可能是面向很多库来编程，比如使用 jQuery，Seajs 或者 webpack 来异步加载脚本，许多库封装了异步加载脚本的能力，以 jQeury 为例你可能是这样来触发异步脚本。</p>
<pre><code>$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>假如这些库中没有提供 crossOrigin 的能力的话(jQuery jsonp 可能有，假装你不知道)，那你只能去修改人家写的源代码了，所以我这里提供一个思路，就是去劫持 document.createElement，从根源上去为每个动态生成的脚本添加 crossOrigin 字段。</p>
<pre><code>document.createElement = (function() {
  const fn = document.createElement.bind(document);
  return function(type) {
    const result = fn(type);
    if(type === &apos;script&apos;) {
      result.crossOrigin = &apos;anonymous&apos;;
    }
    return result;
  }
})();
window.onerror = function (msg, url, row, col, error) {
  console.log(&apos;我知道错误了，也知道错误信息&apos;);
  console.log({
    msg,  url,  row, col, error
  })
  return true;
};
$.ajax({
  url: &apos;http://localhost:8081/data&apos;,
  dataType: &apos;jsonp&apos;,
  success: (data) =&gt; {
    console.log(data);
  }
})
</code></pre><p>效果也是一样的，读者可以通过 <code>npm run jsonpjq</code> 来查看效果：</p>
<p><img src="https://pic4.zhimg.com/v2-30d51a96cdb3286edd1e5a88e9f794bb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-30d51a96cdb3286edd1e5a88e9f794bb_hd.jpg" alt=""></p>
<p>这样重写 createElement 理论上没什么问题，但是入侵了原本的代码，不保证一定不会出错，在工程上还是需要多尝试下看看再使用，可能存在兼容性上问题，如果你觉得会出现什么问题的话也欢迎留言讨论下。</p>
<p>关于 Script error 的问题就写到这里，如果你理解了上面的内容，基本上绝大部分的 Script error 都能迎刃而解。</p>
<h2 id="window-onerror-能否捕获-iframe-的错误"><a href="#window-onerror-能否捕获-iframe-的错误" class="headerlink" title="window.onerror 能否捕获 iframe 的错误"></a>window.onerror 能否捕获 iframe 的错误</h2><p>当你的页面有使用 iframe 的时候，你需要对你引入的 iframe 做异常监控的处理，否则一旦你引入的 iframe 页面出现了问题，你的主站显示不出来，而你却浑然不知。</p>
<p>首先需要强调，父窗口直接使用 window.onerror 是无法直接捕获，如果你想要捕获 iframe 的异常的话，有分好几种情况。</p>
<p>如果你的 iframe 页面和你的主站是同域名的话，直接给 iframe 添加 onerror 事件即可。</p>
<pre><code>&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
  window.frames[0].onerror = function (msg, url, row, col, error) {
    console.log(&apos;我知道 iframe 的错误了，也知道错误信息&apos;);
    console.log({
      msg,  url,  row, col, error
    })
    return true;
  };
&lt;/script&gt;
</code></pre><p>读者可以通过 <code>npm run iframe</code> 查看效果：</p>
<p><img src="https://pic2.zhimg.com/v2-3edcb5686e27ab11f5f3c9c1644986d0_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3edcb5686e27ab11f5f3c9c1644986d0_hd.jpg" alt=""></p>
<p>如果你嵌入的 iframe 页面和你的主站不是同个域名的，但是 iframe 内容不属于第三方，是你可以控制的，那么可以通过与 iframe 通信的方式将异常信息抛给主站接收。与 iframe 通信的方式有很多，常用的如：postMessage，hash 或者 name 字段跨域等等，这里就不展开了，感兴趣的话可以看：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p>
<p>如果是非同域且网站不受自己控制的话，除了通过控制台看到详细的错误信息外，没办法捕获，这是出于安全性的考虑，你引入了一个百度首页，人家页面报出的错误凭啥让你去监控呢，这会引出很多安全性的问题。</p>
<h2 id="压缩代码如何定位到脚本异常位置"><a href="#压缩代码如何定位到脚本异常位置" class="headerlink" title="压缩代码如何定位到脚本异常位置"></a>压缩代码如何定位到脚本异常位置</h2><p>线上的代码几乎都经过了压缩处理，几十个文件打包成了一个并丑化代码，当我们收到 <code>a is not defined</code> 的时候，我们根本不知道这个变量 a 究竟是什么含义，此时报错的错误日志显然是无效的。</p>
<p>第一想到的办法是利用 sourcemap 定位到错误代码的具体位置，详细内容可以参考：<a href="https://link.zhihu.com/?target=https%3A//github.com/joeyguo/blog/issues/14" target="_blank" rel="noopener">Sourcemap 定位脚本错误</a></p>
<p>另外也可以通过在打包的时候，在每个合并的文件之间添加几行空格，并相应加上一些注释，这样在定位问题的时候很容易可以知道是哪个文件报的错误，然后再通过一些关键词的搜索，可以快速地定位到问题的所在位置。</p>
<h2 id="收集异常信息量太多，怎么办"><a href="#收集异常信息量太多，怎么办" class="headerlink" title="收集异常信息量太多，怎么办"></a>收集异常信息量太多，怎么办</h2><p>如果你的网站访问量很大，假如网页的 PV 有 1kw，那么一个必然的错误发送的信息就有 1kw 条，我们可以给网站设置一个采集率：</p>
<pre><code>Reporter.send = function(data) {
  // 只采集 30%
  if(Math.random() &lt; 0.3) {
    send(data)      // 上报错误信息
  }
}
</code></pre><p>这个采集率可以通过具体实际的情况来设定，方法多样化，可以使用一个随机数，也可以具体根据用户的某些特征来进行判定。</p>
<h3 id="错误上报的方法："><a href="#错误上报的方法：" class="headerlink" title="错误上报的方法："></a>错误上报的方法：</h3><ul>
<li>一：Ajax上传，Ajax上报就是在上文注释错误捕获的地方发起Ajax请求，来向服务器发送错误信息。</li>
<li>二：利用Image对象发送信息(new Image()).src=”<a href="http://post.error.com?data=xxx&quot;" target="_blank" rel="noopener">http://post.error.com?data=xxx&quot;</a></li>
<li>跨域js文件错误是否可以捕获：<br>   答案是可以，错误提示是   script error<br>解决办法，跨域js文件获取是有限制的，如果想获取其他域下的js错误需要在script标签里添加crossorigin属性，然后服务器端要设置header(‘Access-Control-Allow-Origin: *’),或者 指定域名。</li>
</ul>
<p>上面差不多是我对前端代码监控的一些理解，说起来容易，但是一旦在工程化运用，难免需要考虑到兼容性等种种问题，读者可以通过自己的具体情况进行调整，前端代码异常监控对于我们的网站的稳定性起着至关重要的作用。如若文中所有不对的地方，还望指正。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/14/JavaScript函数柯里化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/14/JavaScript函数柯里化/" itemprop="url">JavaScript函数柯里化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-14T20:00:52+08:00">
                2016-08-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h2><h2 id="官方的说法"><a href="#官方的说法" class="headerlink" title="官方的说法"></a>官方的说法</h2><p>在计算机科学中，<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%259F%25AF%25E9%2587%258C%25E5%258C%2596" target="_blank" rel="noopener">柯里化</a>（英语：<code>Currying</code>），又译为<code>卡瑞化</code>或<code>加里化</code>，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由<code>克里斯托弗·斯特雷奇</code>以逻辑学家<code>哈斯凯尔·加里</code>命名的，尽管它是<code>Moses Schönfinkel</code>和<code>戈特洛布·弗雷格发明的</code>。</p>
<p>在直觉上，柯里化声称如果你固定某些参数，你将得到接受余下参数的一个函数。</p>
<p>在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的<code>lambda</code>演算中，研究带有多个参数的函数的方式。</p>
<p>函数柯里化的对偶是<code>Uncurrying</code>，一种使用匿名单参数函数来实现多参数函数的方法。</p>
<h2 id="方便的理解"><a href="#方便的理解" class="headerlink" title="方便的理解"></a>方便的理解</h2><blockquote>
<p>Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p>
</blockquote>
<p>如果我们需要实现一个求三个数之和的函数：</p>
<pre><code>function add(x, y, z) {
  return x + y + z;
}
console.log(add(1, 2, 3)); // 6
var add = function(x) {
  return function(y) {
    return function(z) {
      return x + y + z;
    }
  }
}

var addOne = add(1);
var addOneAndTwo = addOne(2);
var addOneAndTwoAndThree = addOneAndTwo(3);

console.log(addOneAndTwoAndThree);
</code></pre><p>这里我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的<code>curry</code>帮助函数（<code>helper function</code>）使这类函数的定义和调用更加容易。</p>
<p>用<code>ES6</code>的箭头函数，我们可以将上面的<code>add</code>实现成这样：</p>
<pre><code>const add = x =&gt; y =&gt; z =&gt; x + y + z;
</code></pre><p>好像使用箭头函数更清晰了许多。</p>
<h2 id="偏函数？"><a href="#偏函数？" class="headerlink" title="偏函数？"></a>偏函数？</h2><p>来看这个函数：</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}
</code></pre><p>有这样的一个场景：我们需要对多个不同的接口发起<code>HTTP</code>请求，有下列两种做法：</p>
<ul>
<li>在调用<code>ajax()</code>函数时，传入全局<code>URL</code>常量。</li>
<li>创建一个已经预设<code>URL</code>实参的函数引用。</li>
</ul>
<p>下面我们创建一个新函数，其内部仍然发起<code>ajax()</code>请求，此外在等待接收另外两个实参的同时，我们手动将<code>ajax()</code>第一个实参设置成你关心的<code>API</code>地址。</p>
<p>对于第一种做法，我们可能产生如下调用方式：</p>
<pre><code>function ajaxTest1(data, callback) {
  ajax(&apos;http://www.test.com/test1&apos;, data, callback);
}

function ajaxTest2(data, callback) {
  ajax(&apos;http://www.test.com/test2&apos;, data, callback);
}
</code></pre><p>对于这两个类似的函数，我们还可以提取出如下的模式：</p>
<pre><code>function beginTest(callback) {
  ajaxTest1({
    data: GLOBAL_TEST_1,
  }, callback);
}
</code></pre><p>相信您已经看到了这样的模式：我们在函数调用现场（<code>function call-site</code>），将实参应用（<code>apply</code>） 于形参。如你所见，我们一开始仅应用了部分实参 —— 具体是将实参应用到<code>URL</code>形参 —— 剩下的实参稍后再应用。</p>
<p>上述概念即为偏函数的定义，偏函数一个减少函数参数个数的过程；这里的参数个数指的是希望传入的形参的数量。我们通过<code>ajaxTest1()</code>把原函数<code>ajax()</code>的参数个数从<code>3</code>个减少到了<code>2</code>个。</p>
<p>我们这样定义一个<code>partial()</code>函数：</p>
<pre><code>function partial(fn, ...presetArgs) {
  return function partiallyApplied(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  }
}
</code></pre><p><code>partial()</code>函数接收<code>fn</code>参数，来表示被我们偏应用实参（<code>partially apply</code>）的函数。接着，<code>fn</code>形参之后，<code>presetArgs</code>数组收集了后面传入的实参，保存起来稍后使用。</p>
<p>我们创建并<code>return</code>了一个新的内部函数（为了清晰明了，我们把它命名为<code>partiallyApplied(..)</code>），该函数中，<code>laterArgs</code>数组收集了全部实参。</p>
<p>使用箭头函数，则更为简洁：</p>
<pre><code>var partial =
  (fn, ...presetArgs) =&gt;
    (...laterArgs) =&gt;
      fn(...presetArgs, ...laterArgs);
</code></pre><p>使用偏函数的这种模式，我们重构之前的代码：</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}

var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);
var ajaxTest2 = partial(ajax, &apos;http://www.test.com/test1&apos;);
</code></pre><p>再次思考<code>beginTest()</code>函数，我们使用<code>partial()</code>来重构它应该怎么做呢？</p>
<pre><code>function ajax(url, data, callback) {
  // ..
}

// 版本1
var beginTest = partial(ajax, &apos;http://www.test.com/test1&apos;, {
  data: GLOBAL_TEST_1,
});

// 版本2
var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);
var beginTest = partial(ajaxTest1, {
  data: GLOBAL_TEST_1,
});
</code></pre><h2 id="一次传一个"><a href="#一次传一个" class="headerlink" title="一次传一个"></a>一次传一个</h2><p>相信你已经在上述例子中看到了版本2比起版本1的优势所在了，没错，柯里化就是：将一个带有多个参数的函数转换为一次一个的函数的过程。每次调用函数时，它只接受一个参数，并返回一个函数，直到传递所有参数为止。</p>
<blockquote>
<p>The process of converting a function that takes multiple arguments into a function that takes them one at a time.</p>
<p>Each time the function is called it only accepts one argument and returns a function that takes one argument until all arguments are passed.</p>
</blockquote>
<p>假设我们已经创建了一个柯里化版本的<code>ajax()</code>函数<code>curriedAjax()</code>：</p>
<pre><code>curriedAjax(&apos;http://www.test.com/test1&apos;)
  ({
    data: GLOBAL_TEST_1,
  })
  (function callback(data) {
    // dosomething
  });
</code></pre><p>我们将三次调用分别拆解开来，这也许有助于我们理解整个过程：</p>
<pre><code>var ajaxTest1 = curriedAjax(&apos;http://www.test.com/test1&apos;);

var beginTest = ajaxTest1({
  data: GLOBAL_TEST_1,
});

var ajaxCallback = beginTest(function callback(data) {
  // dosomething
});
</code></pre><h2 id="实现柯里化"><a href="#实现柯里化" class="headerlink" title="实现柯里化"></a>实现柯里化</h2><p>那么，我们如何来实现一个自动的柯里化的函数呢？</p>
<pre><code>var currying = function(fn) {
  var args = [];

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}
</code></pre><p>调用上述<code>currying()</code>函数：</p>
<pre><code>var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = currying(cost);

cost(100); // 传入了参数，不真正求值
cost(200); // 传入了参数，不真正求值
cost(300); // 传入了参数，不真正求值

console.log(cost()); // 求值并且输出600
</code></pre><p>上述函数是我之前的<a href="http://link.zhihu.com/?target=https%3A//github.com/xingbofeng/JavaScript-design-patterns/blob/master/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0.md%23currying" target="_blank" rel="noopener">JavaScript设计模式与开发实践读书笔记之闭包与高阶函数</a>所写的<code>currying</code>版本，现在仔细思考后发现仍旧有一些问题。</p>
<blockquote>
<p>我们在使用柯里化时，要注意同时为函数预传的参数的情况。</p>
</blockquote>
<p>因此把上述柯里化函数更改如下：</p>
<pre><code>var currying = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}
</code></pre><p>使用实例：</p>
<pre><code>var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = currying(cost, 100);
cost(200); // 传入了参数，不真正求值
cost(300); // 传入了参数，不真正求值

console.log(cost()); // 求值并且输出600
</code></pre><p>你可能会觉得每次都要在最后调用一下不带参数的<code>cost()</code>函数比较麻烦，并且在<code>cost()</code>函数都要使用<code>arguments</code>参数不符合你的预期。我们知道函数都有一个<code>length</code>属性，表明函数期望接受的参数个数。因此我们可以充分利用预传参数的这个特点。</p>
<p>借鉴自<a href="http://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">mqyqingfeng</a>：</p>
<pre><code>function sub_curry(fn) {
  var args = [].slice.call(arguments, 1);
  return function() {
    return fn.apply(this, args.concat([].slice.call(arguments)));
  };
}

function curry(fn, length) {

  length = length || fn.length;

  var slice = Array.prototype.slice;

  return function() {
    if (arguments.length &lt; length) {
      var combined = [fn].concat(slice.call(arguments));
      return curry(sub_curry.apply(this, combined), length - arguments.length);
    } else {
      return fn.apply(this, arguments);
    }
  };
}
</code></pre><p>在上述函数中，我们在currying的返回函数中，每次把<code>arguments.length</code>和<code>fn.length</code>作比较，一旦<code>arguments.length</code>达到了<code>fn.length</code>的数量，我们就去调用<code>fn</code>(<code>return fn.apply(this, arguments);</code>)</p>
<p>验证：</p>
<pre><code>var fn = curry(function(a, b, c) {
  return [a, b, c];
});

fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
</code></pre><h2 id="bind方法的实现"><a href="#bind方法的实现" class="headerlink" title="bind方法的实现"></a>bind方法的实现</h2><p>使用柯里化，能够很方便地借用<code>call()</code>或者<code>apply()</code>实现<code>bind()</code>方法的<code>polyfill</code>。</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function(context) {
  var me = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var innerArgs = Array.prototype.slice.call(arguments);
    var finalArgs = args.concat(innerArgs);
    return me.apply(contenxt, finalArgs);
  }
}
</code></pre><p>上述函数有的问题在于不能兼容构造函数。我们通过判断this指向的对象的原型属性，来判断这个函数是否通过<code>new</code>作为构造函数调用，来使得上述<code>bind</code>方法兼容构造函数。</p>
<p><a href="http://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind() by MDN</a>如下说到：</p>
<blockquote>
<p>绑定函数适用于用new操作符 new 去构造一个由目标函数创建的新的实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。然而, 原先提供的那些参数仍然会被前置到构造函数调用的前面。</p>
</blockquote>
<p>这是<a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/10733304/" target="_blank" rel="noopener">基于MVC的JavaScript Web富应用开发</a>的<code>bind()</code>方法实现：</p>
<pre><code>Function.prototype.bind = function(oThis) {
  if (typeof this !== &quot;function&quot;) {
    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);
  }

  var aArgs = Array.prototype.slice.call(arguments, 1),
    fToBind = this,
    fNOP = function() {},
    fBound = function() {
      return fToBind.apply(
        this instanceof fNOP &amp;&amp; oThis ? this : oThis || window,
        aArgs.concat(Array.prototype.slice.call(arguments))
      );
    };

  fNOP.prototype = this.prototype;
  fBound.prototype = new fNOP();

  return fBound;
};
</code></pre><h2 id="反柯里化（uncurrying）"><a href="#反柯里化（uncurrying）" class="headerlink" title="反柯里化（uncurrying）"></a>反柯里化（uncurrying）</h2><p>可能遇到这种情况：拿到一个柯里化后的函数，却想要它柯里化之前的版本，这本质上就是想将类似<code>f(1)(2)(3)</code>的函数变回类似<code>g(1,2,3)</code>的函数。</p>
<p>下面是简单的<code>uncurrying</code>的实现方式：</p>
<pre><code>function uncurrying(fn) {
  return function(...args) {
    var ret = fn;

    for (let i = 0; i &lt; args.length; i++) {
      ret = ret(args[i]); // 反复调用currying版本的函数
    }

    return ret; // 返回结果
  };
}
</code></pre><blockquote>
<p>注意，不要以为uncurrying后的函数和currying之前的函数一模一样，它们只是行为类似！</p>
</blockquote>
<pre><code>var currying = function(fn) {
  var args = Array.prototype.slice.call(arguments, 1);

  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, args); // 没传参数时，调用这个函数
    } else {
      [].push.apply(args, arguments); // 传入了参数，把参数保存下来
      return arguments.callee; // 返回这个函数的引用
    }
  }
}

function uncurrying(fn) {
  return function(...args) {
    var ret = fn;

    for (let i = 0; i &lt; args.length; i++) {
      ret = ret(args[i]); // 反复调用currying版本的函数
    }

    return ret; // 返回结果
  };
}

var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0; i &lt; arguments.length; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var curryingCost = currying(cost);
var uncurryingCost = uncurrying(curryingCost);
console.log(uncurryingCost(100, 200, 300)()); // 600
</code></pre><h2 id="柯里化或偏函数有什么用？"><a href="#柯里化或偏函数有什么用？" class="headerlink" title="柯里化或偏函数有什么用？"></a>柯里化或偏函数有什么用？</h2><p>无论是柯里化还是偏应用，我们都能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。</p>
<p>另一个最能体现柯里化应用的的是，当函数只有一个形参时，我们能够比较容易地组合它们（<code>单一职责原则（Single responsibility principle）</code>）。因此，如果一个函数最终需要三个实参，那么它被柯里化以后会变成需要三次调用，每次调用需要一个实参的函数。当我们组合函数时，这种单元函数的形式会让我们处理起来更简单。</p>
<p>归纳下来，主要为以下常见的三个用途：</p>
<ul>
<li>延迟计算</li>
<li>参数复用</li>
<li>动态生成函数</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/08/HTML5的Websocket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/08/HTML5的Websocket/" itemprop="url">HTML5的Websocket</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-08T22:18:50+08:00">
                2016-08-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<ul>
<li>先请来TA的邻居：*<br>http：无状态、基于tcp请求/响应模式的应用层协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么）tcp：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) 传输层协议。（看啊，大阅兵，如此规整有秩序）</li>
</ul>
</blockquote>
<h2 id="为什么要引入Websocket："><a href="#为什么要引入Websocket：" class="headerlink" title="为什么要引入Websocket："></a>为什么要引入Websocket：</h2><blockquote>
<p>RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。</p>
</blockquote>
<p>long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。</p>
<p><img src="https://pic3.zhimg.com/v2-b900392bfe564de524ec5460a2b5d235_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b900392bfe564de524ec5460a2b5d235_hd.jpg" alt=""></p>
<p>从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p>
<p>这个时候，Websocket出现了。</p>
<h2 id="Websocket是什么："><a href="#Websocket是什么：" class="headerlink" title="Websocket是什么："></a>Websocket是什么：</h2><blockquote>
<p>RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。</p>
</blockquote>
<p>对，划重点：双向通信</p>
<p>Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以主动向客户端推送消息。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。</p>
<p>其特点：</p>
<p>（1）握手阶段采用 HTTP 协议，默认端口是80和443</p>
<p>（2）建立在TCP协议基础之上，和http协议同属于应用层</p>
<p>（4）可以发送文本，也可以发送二进制数据</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信</p>
<p>（6）协议标识符是ws（如果加密，为wss），如ws://localhost:8023</p>
<p>简单来说，Websocket协议分为两部分：握手和数据传输。</p>
<p><img src="https://pic2.zhimg.com/v2-5b1e92b99d352ba977f69cbe28604ecf_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5b1e92b99d352ba977f69cbe28604ecf_hd.jpg" alt=""></p>
<h2 id="Websocket-API："><a href="#Websocket-API：" class="headerlink" title="Websocket API："></a>Websocket API：</h2><blockquote>
<p>这里是指客户端 API。</p>
</blockquote>
<h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><ol>
<li><code>通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。</code></li>
<li><code>const ws =`</code>new<code></code>WebSocket(‘ws://localhost:8023’);`</li>
</ol>
<h2 id="Websocket事件"><a href="#Websocket事件" class="headerlink" title="Websocket事件"></a>Websocket事件</h2><ol>
<li><code>WebSocket`</code>是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。`</li>
</ol>
<p>open:</p>
<p>服务端响应WebSocket连接请求，就会触发open事件。onopen是响应的回调函数。</p>
<p><code>// 连接请求open事件处理：</code></p>
<pre><code>ws.onopen=e=&gt;{
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果要指定多个回调函数，可以使用addEventListener方法。</p>
<pre><code>ws.addEventListener(&apos;open&apos;, e =&gt; {
 ws.send(`Hello ${e}`);
});
</code></pre><p>当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。</p>
<p>Message:</p>
<p>收到服务器数据，会触发消息事件，onmessage是响应的回调函数。如下：</p>
<pre><code>// 接受文本消息的事件处理：
ws.onmessage = e =&gt; {
const data = e.data;
if (typeof data === &quot;string&quot;) {
       console.log(&quot;Received string message &quot;,data);
} else if (data instanceof Blob) {
       console.log(&quot;Received blob message &quot;, data);
}
};
</code></pre><p>服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p>
<p>Error</p>
<p>发生错误会触发error事件, onerror是响应的回调函数, 会导致连接关闭。</p>
<pre><code>//异常处理
ws.onerror = e =&gt; {
   console.log(&quot;WebSocket Error: &quot; , e);
   handleErrors(e);
};
</code></pre><p>当连接关闭时触发close事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再通信。</p>
<p>WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧）</p>
<pre><code>//关闭连接处理
ws.onclose = e =&gt; {
const code = e.code;
const reason = e.reason;
   console.log(&quot;Connection close&quot;, code, reason);
};
</code></pre><h2 id="WebSocket-方法："><a href="#WebSocket-方法：" class="headerlink" title="WebSocket 方法："></a>WebSocket 方法：</h2><blockquote>
<p>WebSocket 对象有两个方法：send 和 close</p>
</blockquote>
<p>send:</p>
<p>客户端和服务器建立连接后，可以调用send方法去发送消息。</p>
<pre><code>//发送一个文本消息
ws.send(&quot;this is websocket&quot;);
</code></pre><p>在open事件的回调中调用send()方法传送数据：</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;);
ws.onopen = e =&gt; {
   console.log(&apos;Connection success&apos;);
   ws.send(`Hello ${e}`);
};
</code></pre><p>如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState.</p>
<p>close</p>
<p>close方法用来关闭连接。调用close方法后，将不能发送数据。close方法可以传入两个可选的参数，code 和reason, 以告诉服务端为什么终止连接。</p>
<pre><code>ws.close();

//1000是状态码，代表正常结束。
ws.close(1000, &quot;Closing normally&quot;);
</code></pre><h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><ul>
<li>readyState：</li>
</ul>
<p>readyState值表示连接状态，是只读属性。它有以下四个值：</p>
<blockquote>
<p>WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开</p>
</blockquote>
<p>除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。</p>
<pre><code>function bindEventHandler(data) {
if (ws.readyState === WebSocket.OPEN) {
       ws.send(data);
} else {
//do something
}
} 
</code></pre><p>bufferedAmount：</p>
<p>当客户端传输大量数据时，浏览器会缓存将要流出的数据，bufferedAmount属性可判断有多少字节的二进制数据没有发送出去，发送是否结束。</p>
<pre><code>ws.onopen = function () {
   setInterval( function() {
//缓存未满的时候发送
if (ws.bufferedAmount &lt; 1024 * 5) {
           ws.send(data);
}
}, 2000);
};
</code></pre><p>protocol：</p>
<p>protocol代表客户端使用的WebSocket协议。当握手协议未成功，这个属性是空。</p>
<ul>
<li>接下来，我们说说握手阶段过程。*</li>
</ul>
<p>当我们创建Websocket实例对象与服务器建立连接时，</p>
<pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;)；
</code></pre><p>首先客户端向服务器发起一个握手请求，其请求报文的内容如下：</p>
<pre><code>GET /game HTTP/1.1
Host: 10.242.17.102:8023
Cache-Control: no-cache
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Protocol: game
Sec-WebSocket-Version: 10
Origin: http://192.168.185.16
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
</code></pre><p>从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。</p>
<ul>
<li>Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。</li>
<li>Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信</li>
<li>Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议</li>
<li>Sec-WebSocket-Version: 通知服务器所使用的协议版本</li>
</ul>
<p>服务器响应：</p>
<pre><code>当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。 
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ=
</code></pre><ul>
<li>101 状态码，表示要转换协议啦</li>
<li>Upgrde: 通知客户端将要升级成Websocket协议</li>
<li>Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-05e821d0db32cf8cb5ebf51625870cb1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-05e821d0db32cf8cb5ebf51625870cb1_hd.jpg" alt=""></p>
<p>至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/25/移动端H5页面返回并且刷新页面/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/25/移动端H5页面返回并且刷新页面/" itemprop="url">移动端H5页面返回并且刷新页面</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-25T20:08:31+08:00">
                2016-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>项目中的需求：点击浏览器中的返回按钮，要让页面重新加载资源。因为这部分的资源每次去加载的内容都不一样，如果返回的时候，还是看到原先的内容，那做这个内容块的意义就很小了；而如果用户看完了这部分内容，再返回来的时候，这个地方换成了新的内容，这样就能体现这部分的价值了。</p>
<p>而对于浏览器来说，大部分浏览器的返回是直接使用缓存的，不会执行任何的javascript代码。原因：部分浏览器在后退时不会触发onload事件，這是HTML5世代浏览器新增的特性之一——Back-Forward Cache(简称bfcache)</p>
<p><strong>什么是bfcache？</strong></p>
<p>bfcache，即back-forward cache，可称为“往返缓存”，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存不仅保存页面数据，还保存了DOM和JS的状态，实际上是将整个页面都保存在内存里。如果页面位于bfcache中，那么再次打开该页面就不会触发onload事件</p>
<h3 id="pageshow事件"><a href="#pageshow事件" class="headerlink" title="pageshow事件"></a>pageshow事件</h3><p>这个事件在用户浏览网页时触发，pageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， pageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发。</p>
<h3 id="pagehide事件"><a href="#pagehide事件" class="headerlink" title="pagehide事件"></a>pagehide事件</h3><p>该事件会在用户离开网页时触发。离开网页有多种方式。如点击一个链接，刷新页面，提交表单，关闭浏览器等。pagehide 事件有时可以替代 unload事件，但 unload 事件触发后无法缓存页面。</p>
<h3 id="persisted属性"><a href="#persisted属性" class="headerlink" title="persisted属性"></a>persisted属性</h3><p>pageshow事件和pagehide事件的event对象还包含一个名为persisted的布尔值属性。</p>
<ul>
<li>对于pageshow事件，如果页面是从bfcache中加载的，则这个属性的值为true；否则，这个属性的值为false。</li>
<li>对于pagehide事件，如果页面在卸载之后被保存在bfcache中，则这个属性的值为true；否则，这个属性的值为false。</li>
</ul>
<p>不同的浏览器在对当前窗口‘打开’历史记录中的前一个页面的表现上并不统一，这和浏览器的实现以及页面本身的设置有关系。</p>
<p><strong>解决方案：</strong></p>
<p><strong>javascript监听pageshow事件阻止页面进入bfcache</strong></p>
<pre><code> window.addEventListener(&apos;pageshow&apos;, function (e) {
     if (e.persisted) {
         window.location.reload()
     }
})
</code></pre><p>在uc和微信中测试通过，但是在某些安卓手机自带的浏览器中无效。</p>
<p><strong>javascript监听pagehide事件阻止页面进入bfcache</strong></p>
<pre><code>window.addEventListener(&apos;pagehide&apos;, function (e) {
    var dom = document.body;
    dom.children.remove();
    setTimeout(function () {
        dom.appendChild(&quot;&lt;script type=&apos;text/javascript&apos;&gt;window.location.reload();&lt;\/script&gt;&quot;);
    });
});
</code></pre><p><strong>设置meta标签，清除页面缓存</strong></p>
<pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt;
&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;
&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;
</code></pre><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下<br>Public指示响应可被任何缓存区缓存<br>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。<br>注：有些情况下设置清除缓存也没有起到作用，我自己做的这个h5页面就没有起到效果。具体情况还是要具体分析。</p>
<p><strong>我遇到的情况：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">     &lt;iframe id=&quot;iframe&quot; src=&quot;https://cpu.baidu.com/xx/xx/xxx&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个iframe中的地址每次刷新页面都会有不同的内容推送给用户。进入iframe中的内容之后，按返回按钮返回来想进行页面自动刷新，为的就是让用户看到新的内容。</p>
<p>做法：</p>
<p>使用pageshow进行整个页面刷新</p>
<pre><code>window.addEventListener(&apos;pageshow&apos;, function (e) {
    if (e.persisted) {
        window.location.reload()
    }
})
</code></pre><p>这样可以实现。</p>
<p>后面又觉得不妥，没有因为这个小部分而进行整个页面刷新，想到了另一种思路：因为这个iframe中的内容是动态的，可以对其进行定时器设置，如下：</p>
<pre><code>let iframe = document.getElementById(&apos;iframe&apos;)
setInterval(() =&gt; {
    iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
},15000)
</code></pre><p>这样也可以实现自己的功能。</p>
<p>最后可以结合一下：</p>
<pre><code>let iframe = document.getElementById(&apos;iframe&apos;)
window.addEventListener(&apos;pageshow&apos;, function (e) {
    if (e.persisted) {
        iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
    }
})
</code></pre><p>这样做也有好处，可以避免使用定时器，对网页的性能也是比较好。但是这个方法在返回的时候，可以看到iframe里面内容的重新加载，会有一个时间间隙。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/05/21/跨域，你需要知道的全在这里/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/21/跨域，你需要知道的全在这里/" itemprop="url">跨域，你需要知道的全在这里</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-21T11:05:10+08:00">
                2016-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在面试的时候常被问到如何解决跨域的问题，看了网上的一些文章后，许多文章并没有介绍清楚，经常使读者(我)感到困惑，所以今天我整理一下常用的跨域技巧，写这篇关于跨域的文章目的在于：</p>
<ol>
<li>介绍常见的跨域的解决方案以及其优缺点</li>
<li>模拟实际的跨域场景，在每种方案后给出一个简单的实例，能够让读者和我一起敲代码，直观地理解这些跨域技巧</li>
</ol>
<p>如果觉得本文有帮助，可以点 star 鼓励下，本文所有代码都可以从 github 仓库下载，读者可以按照下述打开:</p>
<pre><code>git clone https://github.com/happylindz/blog.git
cd blog/code/crossOrigin/
yarn
</code></pre><p>建议你 clone 下来，方便你阅读代码，跟我一起测试。</p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>使用过 Ajax 的同学都知道其便利性，可以在不向服务端提交完整页面的情况下，实现局部刷新，在当今 SPA 应用普遍使用，但是浏览器处于对安全方面的考虑，不允许跨域调用其它页面的对象，这对于我们在注入 iframe 或是 ajax 应用上带来不少麻烦。</p>
<p>简单来说，只有当协议，域名，端口号相同的时候才算是同一个域名，否则，均认为需要做跨域处理。</p>
<p><img src="https://pic4.zhimg.com/v2-5fa29773fc875bf58e4513fdba402bf0_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-5fa29773fc875bf58e4513fdba402bf0_hd.jpg" alt=""></p>
<h2 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h2><p>今天一共介绍七种常用的跨域技巧，关于跨域技巧大致可以分为 iframe 跨域和 API 跨域请求。</p>
<p>下面就先介绍三种 API 跨域的方法:</p>
<h2 id="1-JSONP："><a href="#1-JSONP：" class="headerlink" title="1. JSONP："></a>1. JSONP：</h2><p>只要说到跨域，就必须聊到 JSONP，JSONP 全称为：JSON with padding，可用于解决老版本浏览器的跨域数据访问问题。</p>
<p>由于 web 页面上调用 js 文件不受浏览器同源策略的影响，所以通过 script 标签可以进行跨域请求：</p>
<ol>
<li>首先前端需要先设置好回调函数，并将其作为 url 的参数。</li>
<li>服务端接收到请求后，通过该参数获取到回调函数名，并将数据放在参数中将其返回</li>
<li>收到结果后因为是 script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的</li>
</ol>
<p>jsonp 之所以能够跨域的关键在于页面调用 JS 脚本是不受同源策略的影响，相当于向后端发起一条 http 请求，跟后端约定好函数名，后端拿到函数名，动态计算出返回结果并返回给前端执行 JS 脚本，相当于是一种 “动态 JS 脚本”</p>
<p>接下来我们通过一个实例来尝试：</p>
<p>后端逻辑：</p>
<pre><code>// jsonp/server.js
const url = require(&apos;url&apos;);

require(&apos;http&apos;).createServer((req, res) =&gt; {
    const data = {
        x: 10
    };
    // 拿到回调函数名
    const callback = url.parse(req.url, true).query.callback;
    console.log(callback);
    res.writeHead(200);
    res.end(`${callback}(${JSON.stringify(data)})`);

}).listen(3000, &apos;127.0.0.1&apos;);

console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);
</code></pre><p>前端逻辑：</p>
<pre><code>// jsonp/index.html
&lt;script&gt;
    function jsonpCallback(data) {
        alert(&apos;获得 X 数据:&apos; + data.x);
    }
&lt;/script&gt;
&lt;script src=&quot;http://127.0.0.1:3000?callback=jsonpCallback&quot;&gt;&lt;/script&gt;
</code></pre><p>然后在终端开启服务：</p>
<p>之所以能用脚本指令，是因为我在 package.json 里面设置好了脚本命令：</p>
<pre><code>{
  // 输入 yarn jsonp 等于 &quot;node ./jsonp/server.js &amp; http-server ./jsonp&quot;
  &quot;scripts&quot;: {
    &quot;jsonp&quot;: &quot;node ./jsonp/server.js &amp; http-server ./jsonp&quot;,
    &quot;cors&quot;: &quot;node ./cors/server.js &amp; http-server ./cors&quot;,
    &quot;proxy&quot;: &quot;node ./serverProxy/server.js&quot;,
    &quot;hash&quot;: &quot;http-server ./hash/client/ -p 8080 &amp; http-server ./hash/server/ -p 8081&quot;,
    &quot;name&quot;: &quot;http-server ./name/client/ -p 8080 &amp; http-server ./name/server/ -p 8081&quot;,
    &quot;postMessage&quot;: &quot;http-server ./postMessage/client/ -p 8080 &amp; http-server ./postMessage/server/ -p 8081&quot;,
    &quot;domain&quot;: &quot;http-server ./domain/client/ -p 8080 &amp; http-server ./domain/server/ -p 8081&quot;
  },
  // ...
}

yarn jsonp
// 因为端口 3000 和 8080 分别属于不同域名下
// 在 localhost:3000 查看效果，即可收到后台返回的数据 10
</code></pre><p>打开浏览器访问 <code>localhost:8080</code> 即可看到获取到的数据。</p>
<p><img src="https://pic2.zhimg.com/v2-1bd48c160110899a8ad7e08e56d36560_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-1bd48c160110899a8ad7e08e56d36560_hd.jpg" alt=""></p>
<p>至此，通过 JSONP 跨域获取数据已经成功了，但是通过这种方式也存在着一定的优缺点：</p>
<p>优点：</p>
<ol>
<li>它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制</li>
<li>兼容性很好，在古老的浏览器也能很好的运行</li>
<li>不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。</li>
</ol>
<p>缺点：</p>
<ol>
<li>它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。</li>
<li>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题</li>
<li>无法捕获 Jsonp 请求时的连接异常，只能通过超时进行处理</li>
</ol>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS:"></a>CORS:</h2><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。</p>
<p>CORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p>
<p>前端逻辑很简单，只要正常发起 ajax 请求即可:</p>
<pre><code>// cors/index.html
&lt;script&gt;
    const xhr = new XMLHttpRequest();
    xhr.open(&apos;GET&apos;, &apos;http://127.0.0.1:3000&apos;, true);
    xhr.onreadystatechange = function() {
        if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) {
            alert(xhr.responseText);
        }
    }
    xhr.send(null);
&lt;/script&gt;
</code></pre><p>这似乎跟一次正常的异步 ajax 请求没有什么区别，关键是在服务端收到请求后的处理：</p>
<pre><code>// cors/server.js
require(&apos;http&apos;).createServer((req, res) =&gt; {

    res.writeHead(200, {
        &apos;Access-Control-Allow-Origin&apos;: &apos;http://localhost:8080&apos;,
        &apos;Content-Type&apos;: &apos;text/html;charset=utf-8&apos;,
    });
    res.end(&apos;这是你要的数据：1111&apos;);

}).listen(3000, &apos;127.0.0.1&apos;);

console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);
</code></pre><p>关键是在于设置相应头中的 Access-Control-Allow-Origin，该值要与请求头中 Origin 一致才能生效，否则将跨域失败。</p>
<p>然后我们执行命令：<code>yarn cors</code> 打开浏览器访问 <code>localhost:3000</code> 即可看到效果：</p>
<p><img src="https://pic2.zhimg.com/v2-13ee0a40a998948019749da80e1d259a_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-13ee0a40a998948019749da80e1d259a_hd.jpg" alt=""></p>
<p>成功的关键在于 Access-Control-Allow-Origin 是否包含请求页面的域名，如果不包含的话，浏览器将认为这是一次失败的异步请求，将会调用 xhr.onerror 中的函数。</p>
<p>CORS 的优缺点：</p>
<ol>
<li>使用简单方便，更为安全</li>
<li>支持 POST 请求方式</li>
<li>CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上</li>
</ol>
<p>这里只是对 CORS 做一个简单的介绍，如果想更详细地了解其原理的话，可以看看下面这篇文章：</p>
<p><a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></p>
<h2 id="3-服务端代理："><a href="#3-服务端代理：" class="headerlink" title="3. 服务端代理："></a>3. 服务端代理：</h2><p>服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。</p>
<p>假设有这样的一个场景，你的页面需要获取 <a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/api" target="_blank" rel="noopener">CNode：Node.js专业中文社区</a> 论坛上一些数据，如通过 <code>https://cnodejs.org/api/v1/topics</code>，当时因为不同域，所以你可以将请求后端，让其对该请求代为转发。</p>
<p>代码如下：</p>
<pre><code>// serverProxy/server.js
const url = require(&apos;url&apos;);
const http = require(&apos;http&apos;);
const https = require(&apos;https&apos;);

const server = http.createServer((req, res) =&gt; {
    const path = url.parse(req.url).path.slice(1);
    if(path === &apos;topics&apos;) {
        https.get(&apos;https://cnodejs.org/api/v1/topics&apos;, (resp) =&gt; {
            let data = &quot;&quot;;
            resp.on(&apos;data&apos;, chunk =&gt; {
                data += chunk;
            });
            resp.on(&apos;end&apos;, () =&gt; {
                res.writeHead(200, {
                    &apos;Content-Type&apos;: &apos;application/json; charset=utf-8&apos;
                });
                res.end(data);
            });
        })        
    }
}).listen(3000, &apos;127.0.0.1&apos;);
console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);
</code></pre><p>通过代码你可以看出，当你访问 <code>http://127.0.0.1:3000/topics</code> 的时候，服务器收到请求，会代你发送请求 <code>https://cnodejs.org/api/v1/topics</code> 最后将获取到的数据发送给浏览器。</p>
<p>启动服务 <code>yarn proxy</code> 并访问 <code>http://localhost:3000/topics</code> 即可看到效果：<br><img src="https://pic1.zhimg.com/v2-a14f2dd5cfd124187cabff0fdfabe5a9_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-a14f2dd5cfd124187cabff0fdfabe5a9_hd.jpg" alt=""></p>
<p>跨域请求成功。纯粹的获取跨域获取后端数据的请求的方式已经介绍完了，另外介绍四种通过 iframe 跨域与其它页面通信的方式。</p>
<h2 id="location-hash："><a href="#location-hash：" class="headerlink" title="location.hash："></a>location.hash：</h2><p>在 url 中，<code>http://www.baidu.com#helloworld</code> 的 “#helloworld” 就是 location.hash，改变 hash 值不会导致页面刷新，所以可以利用 hash 值来进行数据的传递，当然数据量是有限的。</p>
<p>假设 <code>localhost:8080</code> 下有文件 index.html 要和 <code>localhost:8081</code> 下的 data.html 传递消息，index.html 首先创建一个隐藏的 iframe，iframe 的 src 指向 <code>localhost:8081/data.html</code>，这时的 hash 值就可以做参数传递。</p>
<pre><code>// hash/client/index.html 对应 localhost:8080/index.html
&lt;script&gt;
    let ifr = document.createElement(&apos;iframe&apos;);
    ifr.style.display = &apos;none&apos;;
    ifr.src = &quot;http://localhost:8081/data.html#data&quot;;
    document.body.appendChild(ifr);

    function checkHash() {
        try {
            let data = location.hash ? location.hash.substring(1) : &apos;&apos;;
            console.log(&apos;获得到的数据是：&apos;, data);
        }catch(e) {

        }
    }
    window.addEventListener(&apos;hashchange&apos;, function(e) {
        console.log(&apos;获得的数据是：&apos;, location.hash.substring(1));
    });
&lt;/script&gt;
</code></pre><p>data.html 收到消息后通过 parent.location.hash 值来修改 index.html 的 hash 值，从而达到数据传递。</p>
<pre><code>// hash/server/data.html 对应 localhost:8081/data.html
&lt;script&gt;
    switch(location.hash) {
        case &quot;#data&quot;:
            callback();
            break;
    }
    function callback() {
        const data = &quot;data.html 的数据&quot;
        try {
            parent.location.hash = data;
        }catch(e) {
            // ie, chrome 下的安全机制无法修改 parent.location.hash
            // 所以要利用一个中间的代理 iframe 
            var ifrproxy = document.createElement(&apos;iframe&apos;);
            ifrproxy.style.display = &apos;none&apos;;
            ifrproxy.src = &apos;http://localhost:8080/proxy.html#&apos; + data;     // 该文件在 client 域名的域下
            document.body.appendChild(ifrproxy);
        }
    }
&lt;/script&gt;
</code></pre><p>由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于 <code>localhost:8080</code> 域名下的一个代理 iframe 的 proxy.html 页面</p>
<pre><code>// hash/client/proxy.html 对应 localhost:8080/proxy.html
&lt;script&gt;
    parent.parent.location.hash = self.location.hash.substring(1);
&lt;/script&gt;
</code></pre><p>之后启动服务 <code>yarn hash</code>，即可在 <code>localhost:8080</code> 下观察到：</p>
<p><img src="https://pic2.zhimg.com/v2-278b33c730dc9aaf499f172424adde00_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-278b33c730dc9aaf499f172424adde00_hd.jpg" alt=""></p>
<p>当然这种方法存在着诸多的缺点：</p>
<ol>
<li>数据直接暴露在了 url 中</li>
<li>数据容量和类型都有限等等</li>
</ol>
<h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name:"></a>window.name:</h2><p>window.name（一般在 js 代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，这里要注意的是每个 iframe 都有包裹它的 window，而这个 window 是 top window 的子窗口，而它自然也有 window.name 的属性，window.name 属性的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。</p>
<p>举个简单的例子：</p>
<p>你在某个页面的控制台输入：</p>
<pre><code>window.name = &quot;Hello World&quot;
window.location = &quot;http://www.baidu.com&quot;
</code></pre><p>页面跳转到了百度首页，但是 window.name 却被保存了下来，还是 Hello World，跨域解决方案似乎可以呼之欲出了：</p>
<p>前端逻辑：</p>
<pre><code>// name/client/index.html 对应 localhost:8080/index.html 
&lt;script&gt;
    let data = &apos;&apos;;
    const ifr = document.createElement(&apos;iframe&apos;);
    ifr.src = &quot;http://localhost:8081/data.html&quot;;
    ifr.style.display = &apos;none&apos;;
    document.body.appendChild(ifr);
    ifr.onload = function() {
        ifr.onload = function() {
            data = ifr.contentWindow.name;
            console.log(&apos;收到数据:&apos;, data);
        }
        ifr.src = &quot;http://localhost:8080/proxy.html&quot;;
    }
&lt;/script&gt;
</code></pre><p>数据页面：</p>
<pre><code>// name/server/data.html 对应 localhost:8081/data.html
&lt;script&gt;
    window.name = &quot;data.html 的数据!&quot;;
&lt;/script&gt;
</code></pre><p><code>localhost:8080index.html</code> 在请求数据端 <code>localhost:8081/data.html</code> 时，我们可以在该页面新建一个 iframe，该 iframe 的 src 指向数据端地址(利用 iframe 标签的跨域能力)，数据端文件设置好 window.name 的值。</p>
<p>但是由于 index.html 页面与该页面 iframe 的 src 如果不同源的话，则无法操作 iframe 里的任何东西，所以就取不到 iframe 的 name 值，所以我们需要在 data.html 加载完后重新换个 src 去指向一个同源的 html 文件，或者设置成 ‘about:blank;’ 都行，这时候我只要在 index.html 相同目录下新建一个 proxy.html 的空页面即可。如果不重新指向 src 的话直接获取的 window.name 的话会报错：</p>
<p><img src="https://pic2.zhimg.com/v2-7bd77f4df4565cd258bbeeed28515152_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7bd77f4df4565cd258bbeeed28515152_hd.jpg" alt=""></p>
<p>之后运行 <code>yarn name</code> 即可看到效果：</p>
<p><img src="https://pic4.zhimg.com/v2-4dcf4a5d25982ce71bdbe6f14af4620c_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-4dcf4a5d25982ce71bdbe6f14af4620c_hd.jpg" alt=""></p>
<h2 id="6-postMessage"><a href="#6-postMessage" class="headerlink" title="6.postMessage"></a>6.postMessage</h2><p>postMessage 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能，使用起来也特别简单。</p>
<p>前端逻辑：</p>
<pre><code>// postMessage/client/index.html 对应 localhost:8080/index.html
&lt;iframe src=&quot;http://localhost:8081/data.html&quot; style=&apos;display: none;&apos;&gt;&lt;/iframe&gt;
&lt;script&gt;
    window.onload = function() {
        let targetOrigin = &apos;http://localhost:8081&apos;;
        window.frames[0].postMessage(&apos;index.html 的 data!&apos;, targetOrigin);
    }
    window.addEventListener(&apos;message&apos;, function(e) {
        console.log(&apos;index.html 接收到的消息:&apos;, e.data);
    });
&lt;/script&gt;
</code></pre><p>创建一个 iframe，使用 iframe 的一个方法 postMessage 可以想 <code>http://localhost:8081/data.html</code> 发送消息，然后监听 message，可以获得其文档发来的消息。</p>
<p>数据端逻辑：</p>
<pre><code>// postMessage/server/data.html 对应 localhost:8081/data.html
&lt;script&gt;
    window.addEventListener(&apos;message&apos;, function(e) {
        if(e.source != window.parent) {
            return;
        }
        let data = e.data;
        console.log(&apos;data.html 接收到的消息:&apos;, data);
        parent.postMessage(&apos;data.html 的 data!&apos;, e.origin);
    });
&lt;/script&gt;
</code></pre><p>启动服务：<code>yarn postMessage</code> 并打开浏览器访问：</p>
<p><img src="https://pic1.zhimg.com/v2-62c2ff153980a18ddd08110cd41cfde4_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-62c2ff153980a18ddd08110cd41cfde4_hd.jpg" alt=""></p>
<p>对 postMessage 感兴趣的详细内容可以看看教程：</p>
<p><a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/PostMessage/6373972%3Ffr%3Daladdin" target="_blank" rel="noopener">PostMessage_百度百科</a><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">Window.postMessage()</a></p>
<h2 id="7-document-domain"><a href="#7-document-domain" class="headerlink" title="7.document.domain"></a>7.document.domain</h2><p>对于主域相同而子域不同的情况下，可以通过设置 document.domain 的办法来解决，具体做法是可以在 <code>http://www.example.com/index.html</code> 和 <code>http://sub.example.com/data.html</code> 两个文件分别加上 <code>document.domain = &quot;example.com&quot;</code> 然后通过 index.html 文件创建一个 iframe，去控制 iframe 的 window，从而进行交互，当然这种方法只能解决主域相同而二级域名不同的情况，如果你异想天开的把 script.example.com 的 domain 设为 qq.com 显然是没用的，那么如何测试呢？</p>
<p>测试的方式稍微复杂点，需要安装 nginx 做域名映射，如果你电脑没有安装 nginx，请先去安装一下: <a href="https://link.zhihu.com/?target=http%3A//nginx.org/" target="_blank" rel="noopener">nginx</a></p>
<p>前端逻辑：</p>
<pre><code>// domain/client/index.html 对应 sub1.example.com/index.html
&lt;script&gt;
    document.domain = &apos;example.com&apos;;
    let ifr = document.createElement(&apos;iframe&apos;);
    ifr.src = &apos;http://sub2.example.com/data.html&apos;;
    ifr.style.display = &apos;none&apos;;
    document.body.append(ifr);
    ifr.onload = function() {
        let win = ifr.contentWindow;
        alert(win.data);
    }
&lt;/script&gt;
</code></pre><p>数据端逻辑：</p>
<pre><code>// domain/server/data 对应 sub2.example.com/data.html
&lt;script&gt;
    document.domain = &apos;example.com&apos;;
    window.data = &apos;data.html 的数据！&apos;;
&lt;/script&gt;
</code></pre><p>打开操作系统下的 hosts 文件：mac 是位于 /etc/hosts 文件，并添加：</p>
<pre><code>127.0.0.1 sub1.example.com
127.0.0.1 sub2.example.com
</code></pre><p>之后打开 nginx 的配置文件：/usr/local/etc/nginx/nginx.conf，并在 http 模块里添加，记得输入 nginx 启动 nginx 服务：</p>
<pre><code>/usr/local/etc/nginx/nginx.conf
http {
    // ...
    server {
        listen 80;
        server_name sub1.example.com;
        location / {
            proxy_pass http://127.0.0.1:8080/;
        }
    }
    server {
        listen 80;
        server_name sub2.example.com;
        location / {
            proxy_pass http://127.0.0.1:8081/;
        }
    }
    // ...
}
</code></pre><p>相当于是讲 <code>sub1.example.com</code> 和 <code>sub2.example.com</code> 这些域名地址指向本地 <code>127.0.0.1:80</code>，然后用 nginx 做反向代理分别映射到 8080 和 8081 端口。</p>
<p>这样访问 <code>sub1(2).example.com</code> 等于访问 <code>127.0.0.1:8080(1)</code></p>
<p>启动服务 <code>yarn domain</code> 访问浏览器即可看到效果：</p>
<p><img src="https://pic2.zhimg.com/v2-19277c077856648ca1d593f44afadf6e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-19277c077856648ca1d593f44afadf6e_hd.jpg" alt=""></p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>前面七种跨域方式我已经全部讲完，其实讲道理，常用的也就是前三种方式，后面四种更多时候是一些小技巧，虽然在工作中不一定会用到，但是如果你在面试过程中能够提到这些跨域的技巧，无疑在面试官的心中是一个加分项。</p>
<p>上面阐述方法的时候可能有些讲的不明白，希望在阅读的过程中建议你跟着我敲代码，当你打开浏览器看到结果的时候，你也就能掌握到这种方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/23/前端性能监控：window-performance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/23/前端性能监控：window-performance/" itemprop="url">前端性能监控：window.performance</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-23T22:51:24+08:00">
                2016-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/2014/WD-navigation-timing-2-20140325/" target="_blank" rel="noopener">window.performance</a> 是W3C性能小组引入的新的API，目前IE9以上的浏览器都支持。一个performance对象的完整结构如下图所示：</p>
<h2 id="Window-performance"><a href="#Window-performance" class="headerlink" title="Window.performance"></a>Window.performance</h2><p>虽然叫 <code>Timing API</code> 但是用起来却是 <code>window.performance</code></p>
<pre><code>// 兼容性写法
const performance = window.performance || 
                      window.msPerformance || 
                      window.webkitPerformance;
</code></pre><p>memory字段代表JavaScript对内存的占用。</p>
<h2 id="performance-memory-内存"><a href="#performance-memory-内存" class="headerlink" title="performance.memory(内存)"></a>performance.memory(内存)</h2><ul>
<li>usedJSHeapSize<br>JS 对象（包括V8引擎内部对象）占用的内存</li>
<li>totalJSHeapSize<br>可使用的内存</li>
<li>jsHeapSizeLimit<br>内存大小限制</li>
</ul>
<p><img src="https://pic4.zhimg.com/v2-f4a0fa5f8a8a1c4ef07f83d0f393fd9a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-f4a0fa5f8a8a1c4ef07f83d0f393fd9a_hd.jpg" alt=""></p>
<h2 id="performance-navigation-我从哪里来"><a href="#performance-navigation-我从哪里来" class="headerlink" title="performance.navigation(我从哪里来)"></a>performance.navigation(我从哪里来)</h2><ul>
<li>redirectCount<br>如果有重定向的话，页面通过几次重定向跳转而来</li>
<li><p>type</p>
</li>
<li><p>0 即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</p>
</li>
<li>1 即 TYPE_RELOAD 通过 window.location.reload() 刷新的页面</li>
<li>2 即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</li>
<li>255 即 TYPE_UNDEFINED 非以上方式进入的页面</li>
</ul>
<p>navigation字段统计的是一些网页导航相关的数据：</p>
<ol>
<li>redirectCount:重定向的数量（只读），但是这个接口有同源策略限制，即仅能检测同源的重定向；</li>
<li>type 返回值应该是0,1,2 中的一个。分别对应三个枚举值:</li>
</ol>
<ul>
<li>0 : TYPE_NAVIGATE (用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式)</li>
<li>1 : TYPE_RELOAD (用户通过刷新，包括JS调用刷新接口等方式访问页面)</li>
<li>2 : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面)</li>
</ul>
<p>最重要的是timing字段的统计数据，它包含了网络、解析等一系列的时间数据。</p>
<h2 id="performance-timing-时间"><a href="#performance-timing-时间" class="headerlink" title="performance.timing(时间)"></a>performance.timing(时间)</h2><p><img src="https://pic4.zhimg.com/v2-a9f7be2c5aaa973e405bd0b8da7e6890_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a9f7be2c5aaa973e405bd0b8da7e6890_hd.jpg" alt=""></p>
<p>2.2.1 timing API</p>
<p>timing的整体结构如上图所示：</p>
<p><img src="https://pic2.zhimg.com/v2-95d9e0f1ff8257f3c007045c6a2d07bb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-95d9e0f1ff8257f3c007045c6a2d07bb_hd.jpg" alt=""></p>
<p>各字段的含义如下：</p>
<ul>
<li>startTime：有些浏览器实现为<a href="https://link.zhihu.com/?target=https%3A//msdn.microsoft.com/en-us/library/ff974724%28v%3Dvs.85%29.aspx" target="_blank" rel="noopener">navigationStart</a>，代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览baidu.com，在地址栏输入google.com并回车，浏览器的执行动作依次为：unload当前文档（即<a href="https://link.zhihu.com/?target=http%3A//baidu.com" target="_blank" rel="noopener">http://baidu.com</a>）-&gt;请求下一文档（即<a href="https://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="noopener">http://google.com</a>）。navigationStart的值便是触发unload当前文档的时间节点。</li>
</ul>
<p>如果当前文档为空，则navigationStart的值等于fetchStart。</p>
<ul>
<li>redirectStart和redirectEnd：如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点；</li>
<li>unloadEventStart和unloadEventEnd：如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0；</li>
<li>fetchStart是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存；</li>
<li>domainLookupStart和domainLookupEnd分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart；</li>
<li>connectStart和connectEnd分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd；</li>
<li>secureConnectionStart：可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0；</li>
<li>requestStart代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等；</li>
<li>responseStart和responseEnd分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻；</li>
<li>domLoading代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点；</li>
<li>domInteractive代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点；</li>
<li>domContentLoadedEventStart：代表DOMContentLoaded事件触发的时间节点：</li>
</ul>
<p>页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。</p>
<ul>
<li>domContentLoadedEventEnd：代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间；</li>
<li>domComplete：html文档完全解析完毕的时间节点；</li>
<li>loadEventStart和loadEventEnd分别代表onload事件触发和结束的时间节点</li>
</ul>
<p>2.2.2 计算性能指标</p>
<p>可以使用Navigation.timing 统计到的时间数据来计算一些页面性能指标，比如DNS查询耗时、白屏时间、domready等等。如下：</p>
<ul>
<li>DNS查询耗时 = domainLookupEnd - domainLookupStart</li>
<li>TCP链接耗时 = connectEnd - connectStart</li>
<li>request请求耗时 = responseEnd - responseStart</li>
<li>解析dom树耗时 = domComplete - domInteractive</li>
<li>白屏时间 = domloadng - fetchStart</li>
<li>domready时间 = domContentLoadedEventEnd - fetchStart</li>
<li><p>onload时间 = loadEventEnd - fetchStart</p>
<p>  所以根据上面的时间点，我们可以计算常规的性能值，如下：<br>  （使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。）</p>
<p>  var timing = window.performance &amp;&amp; window.performance.timing;<br>  var navigation = window.performance &amp;&amp; window.performance.navigation;</p>
</li>
</ul>
<pre><code>重定向次数：
var redirectCount = navigation &amp;&amp; navigation.redirectCount;

跳转耗时：
var redirect = timing.redirectEnd - timing.redirectStart;

APP CACHE 耗时：
var appcache = Math.max(timing.domainLookupStart - timing.fetchStart, 0);

DNS 解析耗时：
var dns = timing.domainLookupEnd - timing.domainLookupStart;

TCP 链接耗时：
var conn = timing.connectEnd - timing.connectStart;

等待服务器响应耗时（注意是否存在cache）：
var request = timing.responseStart - timing.requestStart;

内容加载耗时（注意是否存在cache）:
var response = timing.responseEnd - timing.responseStart;

总体网络交互耗时，即开始跳转到服务器资源下载完成：
var network = timing.responseEnd - timing.navigationStart;

渲染处理：
var processing = (timing.domComplete || timing.domLoading) - timing.domLoading;

抛出 load 事件：
var load = timing.loadEventEnd - timing.loadEventStart;

总耗时：
var total = (timing.loadEventEnd || timing.loadEventStart || timing.domComplete || timing.domLoading) - timing.navigationStart;

可交互：
var active = timing.domInteractive - timing.navigationStart;

请求响应耗时，即 T0，注意cache：
var t0 = timing.responseStart - timing.navigationStart;

首次出现内容，即 T1：
var t1 = timing.domLoading - timing.navigationStart;

内容加载完毕，即 T3：
var t3 = timing.loadEventEnd - timing.navigationStart;
</code></pre><p>2.2.3 Resource timing API</p>
<p>Resource timing API是用来统计静态资源相关的时间信息，详细的内容请参考<a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/resource-timing/" target="_blank" rel="noopener">W3C Resource timing</a>。这里我们只介绍performance.getEntries方法，它可以获取页面中每个静态资源的请求，【以百度移动版首页的logo为例】如下：</p>
<p>比较有用的几个属性：</p>
<pre><code>name：资源的链接

initiatorType: 初始类型（注意这个类型并不准确，例如在css中的图片资源会这个值显示css，所以还是推荐用name中的后缀名）

duration: 资源的总耗时（包括等待时长，请求时长，响应时长 相当于responseEnd - startTime）

transferSize: 转换后的文件大小(略大于encodedBodySize, 为什么我取这个呢，因为这个值是和chrome的devtool Network里的size一致) 
</code></pre><p><img src="https://pic4.zhimg.com/v2-cff2a7e449c4e6260c2cb8fa0b18c948_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-cff2a7e449c4e6260c2cb8fa0b18c948_hd.jpg" alt=""></p>
<p>可以看到performance.getEntries返回一个数组，数组的每个元素代表对应的静态资源的信息，比如上图展示的第一个元素对应的资源类型initiatorType是图片img，请求花费的时间就是duration的值。</p>
<p>关于Resource timing API的使用场景，感兴趣的同学可以深入研究。</p>
<p><img src="https://pic2.zhimg.com/v2-23c6a6e3744a117368fbd9b0789867ff_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-23c6a6e3744a117368fbd9b0789867ff_hd.jpg" alt=""></p>
<pre><code>;
(function() {

    handleAddListener(&apos;load&apos;, getTiming)

    function handleAddListener(type, fn) {
        if(window.addEventListener) {
            window.addEventListener(type, fn)
        } else {
            window.attachEvent(&apos;on&apos; + type, fn)
        }
    }

    function getTiming() {
        try {
            var time = performance.timing;
            var timingObj = {};

            var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;

            if(loadTime &lt; 0) {
                setTimeout(function() {
                    getTiming();
                }, 200);
                return;
            }

            timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000;
            timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000;
            timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000;
            timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000;
            timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000;
            timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000;
            timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000;
            timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;
            timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000;
            timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]);

            for(item in timingObj) {
                console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;);
            }

            console.log(performance.timing);

        } catch(e) {
            console.log(timingObj)
            console.log(performance.timing);
        }
    }
})();

&lt;!DOCTYPE html&gt;
&lt;html&gt;

    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; /&gt;
        &lt;script src=&quot;&quot;&gt;&lt;/script&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body&gt;

    &lt;/body&gt;

&lt;/html&gt;
</code></pre><p><img src="https://pic2.zhimg.com/v2-23c6a6e3744a117368fbd9b0789867ff_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-23c6a6e3744a117368fbd9b0789867ff_hd.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/28/eval-和-new-Function-执行JS代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/28/eval-和-new-Function-执行JS代码/" itemprop="url">eval() 和 new Function() 执行JS代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-28T10:03:24+08:00">
                2016-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global scope&apos;</span><br><span class="line">function b()&#123;</span><br><span class="line">   var a = &apos;local scope&apos;</span><br><span class="line">   eval(&apos;console.log(a)&apos;)   //local scope</span><br><span class="line">   ;(new Function(&apos;&apos;,&apos;console.log(a)&apos;))()  //global scope</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">b()</span><br><span class="line"> </span><br><span class="line">local scope</span><br><span class="line">global scope</span><br></pre></td></tr></table></figure>
<blockquote>
<p>eval中的代码执行时的作用域为当前作用域。它可以访问到函数中的局部变量。</p>
</blockquote>
<blockquote>
<p>new Function中的代码执行时的作用域为全局作用域，不论它的在哪个地方调用的。所以它访问的是全局变量a。它根本无法访问b函数内的局部变量。</p>
</blockquote>
<h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>以 str 的方式运行 JavaScript 代码，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; var a = 12;</span><br><span class="line">&gt; eval( &apos;a+5&apos; );</span><br><span class="line">&gt; 17</span><br></pre></td></tr></table></figure></p>
<p>注意语句上下文 eval()的解析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval( &apos;&#123; foo: 123 &#125;&apos; );</span><br><span class="line">&gt; 123</span><br><span class="line">&gt; eval( &apos;(&#123; foo: 123 &#125;)&apos; );</span><br><span class="line">&gt; &#123; foo: 123 &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="严格模式下的-eval"><a href="#严格模式下的-eval" class="headerlink" title="严格模式下的 eval()"></a>严格模式下的 eval()</h3><p>对于 eval()，理应当在严格模式下使用。在松散模式下运行代码会在当前的作用域中创建局部变量：</p>
<pre><code>function f(){ 
       eval( &apos;var foo = 1&apos; );
       console.log( foo ); // 1
    } 
</code></pre><p>严格模式下就不会出现该情况。但是，运行代码仍然具有读写当前作用域中变量的权限。你需要通过间接调用 eval() 来阻止这种权限。</p>
<h3 id="全局作用域下间接执行-eval-有两种调用-eval-的方式："><a href="#全局作用域下间接执行-eval-有两种调用-eval-的方式：" class="headerlink" title="全局作用域下间接执行 eval() 有两种调用 eval() 的方式："></a>全局作用域下间接执行 eval() 有两种调用 eval() 的方式：</h3><ol>
<li>直接方式：通过直接调用名为 “eval” 的函数。</li>
<li><p>间接方式：使用其他的一些方式。（通过 call 调用，将其以其他名字作为 window 下的一个方法存储，在那里进行调用） 之前已经看过，在当前作用域直接使用 eval 执行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = &apos;global&apos;; </span><br><span class="line">   function directEval()&#123;</span><br><span class="line">       &apos;use strict&apos;;</span><br><span class="line">        var x = &apos;local&apos;;</span><br><span class="line">        console.log( eval(&apos;x&apos;) ); // local</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p> 反之，在全局作用域中间接调用 eval。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var x = &apos;global&apos;; </span><br><span class="line">function indirectEval()&#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    var x = &apos;local&apos;;</span><br><span class="line">    // 不同方式调用 call </span><br><span class="line">    console.log( eval.call(null, &apos;x&apos;) ); // global</span><br><span class="line">    console.log( window.eval(&apos;x&apos;) ); // global</span><br><span class="line">    console.log( (1,eval)(&apos;x&apos;) ); // global (1)</span><br><span class="line">    var xeval = eval;</span><br><span class="line">    console.log( xeval(&apos;x&apos;) ); // global</span><br><span class="line">    var obj = &#123; eval: eval &#125;</span><br><span class="line">    console.log( obj.eval(&apos;x&apos;) ); // global</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>说明：当你通过一个名称来引用一个变量的时候，其初始值为一个所谓的引用，数据结构分为两部分： </p>
<ol>
<li>基础是指向存储变量的值的数据结构。 </li>
<li>引用名是变量的名称<br>在一个函数调用 eval 的时候，该函数的调用操作符（括号）遇到一个对 eval 的引用可以确定被调用函数的名称。所以此时函数会触发一个直接的 eval 调用。当然你可以不给调用操作符引用来强制间接调用 eval。这是由于在操作符运行之前获取引用的值来实现的。在 （1）标注的那一行，逗号操作符为我们实现的这点。这个运算符运行了第一个运算元并返回了第二个运算元的结果。运算结果总是返回 值 的，意味着引用已经被解析。 间接的运行代码总是松散的。这是由于代码被独立的在当前环境中运行的结果。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function strictFunc()&#123; </span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    var code = &apos;(function()&#123; return this; &#125;())&apos;;</span><br><span class="line">    var result = eval.call( null, code );</span><br><span class="line">    console.log( result !== undefined ); // true sloppy mode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function()"></a>new Function()</h2><p>Function 构造函数的函数签名。<br>new Function( param1, param2, …, paramN,funcBody );<br>它创建一个包含0个或者过个参数名为 param1 等的函数，函数体为 funcBody。相当于如下方式创建函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ( (param1), (param2), ..., (paramN) )&#123; </span><br><span class="line">        (funcBody)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x+y&apos;); </span><br><span class="line">f( 3, 4 )</span><br></pre></td></tr></table></figure>
<p>与间接 eval 调用类似，newFunction() 创建的函数作用域也是全局的。 </p>
<pre><code>var x = &apos;global&apos;; 
function strictFunc(){
   &apos;use strict&apos;;
   var x = &apos;local&apos;;
   var f = new Function(&apos;return x&apos;);
   console.log( f() ); //global
} 
</code></pre><p>以下的函数也是默认松散模式 </p>
<pre><code>function strictFunc(){ 
    &apos;use strict&apos;;
    var sl = newFunction( &apos;return this&apos; );
    console.log( sl() !== undefined ); // true, sloppy modevar st = newFunction( &apos;&quot;use strict&quot;; return this;&apos; );
    console.log( st() !== undefined ); // true, strict mode
} 
</code></pre><ol>
<li>eval() 对比 new Function()<font color="#ff0000">一般来说，使用 new Function() 运行代码比 eval() 更为好一些：函数的参数提供了清晰的接口来运行代码，而没有必要使用较为笨拙的语法来间接的调用 eval() 确保代码只能访问自己的和全局的变量。</font></li>
<li>最佳实践<br><font color="#ff0000">通常：避免使用 eval() 和 new Function() 。动态运行代码不但速度较慢，还有潜在的安全风险。一般都可以找到更好地替代方案。</font><br>你也不应该使用 eval() 或者 newFunction() 来解析 JSON格式的数据。那也是不安全的。要么使用 ECMAScript 5 内置的对JSON的支持方法，要么使用一个类库。<br>合理使用实例。依旧有一些较为合理，对 eval() 和 newFunction() 使用较为高级的：配置函数数据（JSON 不允许），模板库，解析，命令行和模块系统。 </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/02/11/防抖和节流原理分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/11/防抖和节流原理分析/" itemprop="url">防抖和节流原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-11T14:51:19+08:00">
                2016-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>窗口的resize、scroll、输入框内容校验等操作时，如果这些<strong>操作处理函数</strong>是较为复杂或页面频繁重渲染等操作时，在这种情况下如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来<strong>减少触发的频率</strong>，同时又不影响实际效果。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>debounce（防抖），简单来说就是防止抖动。</p>
<p>当持续触发事件时，debounce 会<strong>合并事件且不会去触发事件</strong>，<strong>当一定时间内没有触发再这个事件时，才真正去触发事件</strong>。</p>
<h3 id="非立即执行版"><a href="#非立即执行版" class="headerlink" title="非立即执行版"></a>非立即执行版</h3><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p>
<pre><code>const debounce = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() =&gt; {
      func.apply(context, args)
    },wait);
  }
}
</code></pre><p>如此调用：</p>
<pre><code>content.onmousemove = debounce(count,1000);
</code></pre><h3 id="立即执行版"><a href="#立即执行版" class="headerlink" title="立即执行版"></a>立即执行版</h3><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p>
<pre><code>const debounce = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if (timeout) cleatTimeout(timeout);
    let callNow = !timeout;
    timeout = setTimeout(() =&gt; {
      timeout = null;
    },wait)

    if(callNow) func.apply(context,args)
   }
}
</code></pre><h3 id="结合版"><a href="#结合版" class="headerlink" title="结合版"></a>结合版</h3><pre><code>/**
 * @desc 函数防抖
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表立即执行，false 表非立即执行
 */functiondebounce(func,wait,immediate) {
    var timeout;

    returnfunction () {
        var context = this;
        var args = arguments;

        if (timeout) clearTimeout(timeout);
        if (immediate) {
            var callNow = !timeout;
            timeout = setTimeout(function(){
                timeout = null;
            }, wait)
            if (callNow) func.apply(context, args)
        }
        else {
            timeout = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }
}
</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>throttle（节流），当持续触发事件时，<strong>保证隔间时间触发一次事件</strong>。</p>
<p>持续触发事件时，throttle 会合并一定时间内的事件，并在该时间结束时真正去触发一次事件。</p>
<h3 id="时间戳版"><a href="#时间戳版" class="headerlink" title="时间戳版"></a>时间戳版</h3><p>在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。</p>
<pre><code>const throttle = (func, wait, ...args) =&gt; {
  let pre = 0;
  returnfunction(){
    const context = this;
    let now = Date.now();
    if (now - pre &gt;= wait){
       func.apply(context, args);
       pre = Date.now();
    }
  }
}
</code></pre><h3 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版"></a>定时器版</h3><p>在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p>
<pre><code>const throttle = (func, wait, ...args) =&gt; {
  let timeout;
  return function(){
    const context = this;
    if(!timeout){
      timeout = setTimeout(() =&gt; {
        timeout = null;
        func.apply(context,args);
      },wait)
    }
  }
}
</code></pre><h3 id="结合版-1"><a href="#结合版-1" class="headerlink" title="结合版"></a>结合版</h3><p>其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p>
<pre><code>/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 表时间戳版，2 表定时器版
 */functionthrottle(func, wait ,type) {
    if(type===1){
        var previous = 0;
    }elseif(type===2){
        var timeout;
    }

    returnfunction() {
        var context = this;
        var args = arguments;
        if(type===1){
            var now = Date.now();

            if (now - previous &gt; wait) {
                func.apply(context, args);
                previous = now;
            }
        }elseif(type===2){
            if (!timeout) {
                timeout = setTimeout(function() {
                    timeout = null;
                    func.apply(context, args)
                }, wait)
            }
        }

    }
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/25/defer和async的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/25/defer和async的区别/" itemprop="url">defer和async的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-25T21:24:11+08:00">
                2016-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先来试个一句话解释仨，当浏览器碰到 <code>script</code> 脚本的时候：</p>
<ol>
<li><code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></li>
</ol>
<p>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 <code>script</code> 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
<ol start="2">
<li><code>&lt;script async src=&quot;&quot;&gt;&lt;/script&gt;</code></li>
</ol>
<p>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）。</p>
<ol start="3">
<li><code>&lt;script defer src=&quot;&quot;&gt;&lt;/script&gt;</code></li>
</ol>
<p>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</p>
<p>然后从实用角度来说呢，首先把所有脚本都丢到 <code>&lt;/body&gt;</code> 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p>
<p>接着，我们来看一张图咯：</p>
<p><img src="/2016/01/25/defer和async的区别/1.png" alt=""></p>
<h4 id="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】"><a href="#蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】" class="headerlink" title="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】"></a>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】</h4><p>此图告诉我们以下几个要点：</p>
<ol>
<li>defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>
<li>它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的</li>
<li>关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>
<li>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>
<li>仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/22/FastClick-源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LuckDay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/22/FastClick-源码解析/" itemprop="url">FastClick-源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-22T19:45:27+08:00">
                2016-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(function() &#123;</span><br><span class="line">	&apos;use strict&apos;;</span><br><span class="line">	//构造函数</span><br><span class="line">	function FastClick(layer, options) &#123;</span><br><span class="line">		var oldOnClick;</span><br><span class="line">		options = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">		//是否开始追踪click事件</span><br><span class="line">		this.trackingClick = false;</span><br><span class="line"></span><br><span class="line">		//存储第一次按下时间戳</span><br><span class="line">		this.trackingClickStart = 0;</span><br><span class="line"></span><br><span class="line">		//目标元素</span><br><span class="line">		this.targetElement = null;</span><br><span class="line"></span><br><span class="line">		//存放坐标值X</span><br><span class="line">		this.touchStartX = 0;</span><br><span class="line"></span><br><span class="line">		//存放坐标值Y</span><br><span class="line">		this.touchStartY = 0;</span><br><span class="line"></span><br><span class="line">		//主要hack iOS4下的一个怪异问题</span><br><span class="line">		this.lastTouchIdentifier = 0;</span><br><span class="line"></span><br><span class="line">		//用于区分是click还是Touchmove，若出点移动超过该值则视为touchmove</span><br><span class="line">		this.touchBoundary = options.touchBoundary || 10;</span><br><span class="line"></span><br><span class="line">		// 绑定了FastClick的元素，一般是是body</span><br><span class="line">		this.layer = layer;</span><br><span class="line"></span><br><span class="line">		//双击最小点击时间差</span><br><span class="line">		this.tapDelay = options.tapDelay || 200;</span><br><span class="line"></span><br><span class="line">		//长按最大时间</span><br><span class="line">		this.tapTimeout = options.tapTimeout || 700;</span><br><span class="line"></span><br><span class="line">		//如果是属于不需要处理的元素类型，则直接返回</span><br><span class="line">		if(FastClick.notNeeded(layer)) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//语法糖，兼容一些用不了 Function.prototype.bind 的旧安卓</span><br><span class="line">		//所以后面不走 layer.addEventListener(&apos;click&apos;, this.onClick.bind(this), true);</span><br><span class="line">		function bind(method, context) &#123;</span><br><span class="line">			return function() &#123;</span><br><span class="line">				return method.apply(context, arguments);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		var methods = [&apos;onMouse&apos;, &apos;onClick&apos;, &apos;onTouchStart&apos;, &apos;onTouchMove&apos;, &apos;onTouchEnd&apos;, &apos;onTouchCancel&apos;];</span><br><span class="line">		var context = this;</span><br><span class="line">		for(var i = 0, l = methods.length; i &lt; l; i++) &#123;</span><br><span class="line">			context[methods[i]] = bind(context[methods[i]], context);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//安卓则做额外处理</span><br><span class="line">		if(deviceIsAndroid) &#123;</span><br><span class="line">			layer.addEventListener(&apos;mouseover&apos;, this.onMouse, true);</span><br><span class="line">			layer.addEventListener(&apos;mousedown&apos;, this.onMouse, true);</span><br><span class="line">			layer.addEventListener(&apos;mouseup&apos;, this.onMouse, true);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		layer.addEventListener(&apos;click&apos;, this.onClick, true);</span><br><span class="line">		layer.addEventListener(&apos;touchstart&apos;, this.onTouchStart, false);</span><br><span class="line">		layer.addEventListener(&apos;touchmove&apos;, this.onTouchMove, false);</span><br><span class="line">		layer.addEventListener(&apos;touchend&apos;, this.onTouchEnd, false);</span><br><span class="line">		layer.addEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false);</span><br><span class="line"></span><br><span class="line">		// 兼容不支持 stopImmediatePropagation 的浏览器(比如 Android 2)</span><br><span class="line">		if(!Event.prototype.stopImmediatePropagation) &#123;</span><br><span class="line">			layer.removeEventListener = function(type, callback, capture) &#123;</span><br><span class="line">				var rmv = Node.prototype.removeEventListener;</span><br><span class="line">				if(type === &apos;click&apos;) &#123;</span><br><span class="line">					rmv.call(layer, type, callback.hijacked || callback, capture);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					rmv.call(layer, type, callback, capture);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			layer.addEventListener = function(type, callback, capture) &#123;</span><br><span class="line">				var adv = Node.prototype.addEventListener;</span><br><span class="line">				if(type === &apos;click&apos;) &#123;</span><br><span class="line">					//留意这里 callback.hijacked 中会判断 event.propagationStopped 是否为真来确保（安卓的onMouse事件）只执行一次</span><br><span class="line">					//在 onMouse 事件里会给 event.propagationStopped 赋值 true</span><br><span class="line">					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) &#123;</span><br><span class="line">						if(!event.propagationStopped) &#123;</span><br><span class="line">							callback(event);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;), capture);</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					adv.call(layer, type, callback, capture);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 如果layer直接在DOM上写了 onclick 方法，那我们需要把它替换为 addEventListener 绑定形式</span><br><span class="line">		if(typeof layer.onclick === &apos;function&apos;) &#123;</span><br><span class="line">			oldOnClick = layer.onclick;</span><br><span class="line">			layer.addEventListener(&apos;click&apos;, function(event) &#123;</span><br><span class="line">				oldOnClick(event);</span><br><span class="line">			&#125;, false);</span><br><span class="line">			layer.onclick = null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * Android requires exceptions.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsAndroid = navigator.userAgent.indexOf(&apos;Android&apos;) &gt; 0 &amp;&amp; !deviceIsWindowsPhone;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * iOS requires exceptions.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * iOS 4 requires an exception for select elements.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsIOS4 = deviceIsIOS &amp;&amp; (/OS 4_\d(_\d)?/).test(navigator.userAgent);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * iOS 6.0-7.* requires the target element to be manually derived</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsIOSWithBadTarget = deviceIsIOS &amp;&amp; (/OS [6-7]_\d/).test(navigator.userAgent);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * BlackBerry requires exceptions.</span><br><span class="line">	 *</span><br><span class="line">	 * @type boolean</span><br><span class="line">	 */</span><br><span class="line">	var deviceIsBlackBerry10 = navigator.userAgent.indexOf(&apos;BB10&apos;) &gt; 0;</span><br><span class="line"></span><br><span class="line">	//判断元素是否要保留穿透功能</span><br><span class="line">	FastClick.prototype.needsClick = function(target) &#123;</span><br><span class="line">		switch(target.nodeName.toLowerCase()) &#123;</span><br><span class="line"></span><br><span class="line">			// disabled的input</span><br><span class="line">			case &apos;button&apos;:</span><br><span class="line">			case &apos;select&apos;:</span><br><span class="line">			case &apos;textarea&apos;:</span><br><span class="line">				if(target.disabled) &#123;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				break;</span><br><span class="line">			case &apos;input&apos;:</span><br><span class="line"></span><br><span class="line">				// file组件必须通过原生click事件点击才有效</span><br><span class="line">				if((deviceIsIOS &amp;&amp; target.type === &apos;file&apos;) || target.disabled) &#123;</span><br><span class="line">					return true;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				break;</span><br><span class="line">			case &apos;label&apos;:</span><br><span class="line">			case &apos;iframe&apos;:</span><br><span class="line">			case &apos;video&apos;:</span><br><span class="line">				return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//元素带了名为“bneedsclick”的class也返回true</span><br><span class="line">		return(/\bneedsclick\b/).test(target.className);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//判断给定元素是否需要通过合成click事件来模拟聚焦</span><br><span class="line">	FastClick.prototype.needsFocus = function(target) &#123;</span><br><span class="line">		switch(target.nodeName.toLowerCase()) &#123;</span><br><span class="line">			case &apos;textarea&apos;:</span><br><span class="line">				return true;</span><br><span class="line">			case &apos;select&apos;:</span><br><span class="line">				return !deviceIsAndroid; //iOS下的select得走穿透点击才行</span><br><span class="line">			case &apos;input&apos;:</span><br><span class="line">				switch(target.type) &#123;</span><br><span class="line">					case &apos;button&apos;:</span><br><span class="line">					case &apos;checkbox&apos;:</span><br><span class="line">					case &apos;file&apos;:</span><br><span class="line">					case &apos;image&apos;:</span><br><span class="line">					case &apos;radio&apos;:</span><br><span class="line">					case &apos;submit&apos;:</span><br><span class="line">						return false;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				return !target.disabled &amp;&amp; !target.readOnly;</span><br><span class="line">			default:</span><br><span class="line">				//带有名为“bneedsfocus”的class则返回true</span><br><span class="line">				return(/\bneedsfocus\b/).test(target.className);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//合成一个click事件并在指定元素上触发</span><br><span class="line">	FastClick.prototype.sendClick = function(targetElement, event) &#123;</span><br><span class="line">		var clickEvent, touch;</span><br><span class="line"></span><br><span class="line">		// 在一些安卓机器中，得让页面所存在的 activeElement（聚焦的元素，比如input）失焦，否则合成的click事件将无效</span><br><span class="line">		if(document.activeElement &amp;&amp; document.activeElement !== targetElement) &#123;</span><br><span class="line">			document.activeElement.blur();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		touch = event.changedTouches[0];</span><br><span class="line"></span><br><span class="line">		// 合成(Synthesise) 一个 click 事件</span><br><span class="line">		// 通过一个额外属性确保它能被追踪（tracked）</span><br><span class="line">		clickEvent = document.createEvent(&apos;MouseEvents&apos;);</span><br><span class="line">		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);</span><br><span class="line">		clickEvent.forwardedTouchEvent = true; // fastclick的内部变量，用来识别click事件是原生还是合成的</span><br><span class="line">		targetElement.dispatchEvent(clickEvent); //立即触发其click事件</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.determineEventType = function(targetElement) &#123;</span><br><span class="line"></span><br><span class="line">		//安卓设备下 Select 无法通过合成的 click 事件被展开，得改为 mousedown</span><br><span class="line">		if(deviceIsAndroid &amp;&amp; targetElement.tagName.toLowerCase() === &apos;select&apos;) &#123;</span><br><span class="line">			return &apos;mousedown&apos;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return &apos;click&apos;;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//设置元素聚焦事件</span><br><span class="line">	FastClick.prototype.focus = function(targetElement) &#123;</span><br><span class="line">		var length;</span><br><span class="line"></span><br><span class="line">		// 组件建议通过setSelectionRange(selectionStart, selectionEnd)来设定光标范围（注意这样还没有聚焦</span><br><span class="line">		// 要等到后面触发 sendClick 事件才会聚焦）</span><br><span class="line">		// 另外 iOS7 下有些input元素(比如 date datetime month) 的 selectionStart 和 selectionEnd 特性是没有整型值的，</span><br><span class="line">		// 导致会抛出一个关于 setSelectionRange 的模糊错误，它们需要改用 focus 事件触发</span><br><span class="line">		if(deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&apos;date&apos;) !== 0 &amp;&amp; targetElement.type !== &apos;time&apos; &amp;&amp; targetElement.type !== &apos;month&apos;) &#123;</span><br><span class="line">			length = targetElement.value.length;</span><br><span class="line">			targetElement.setSelectionRange(length, length);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			//直接触发其focus事件</span><br><span class="line">			targetElement.focus();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 检查target是否一个滚动容器里的子元素，如果是则给它加个标记</span><br><span class="line">	 */</span><br><span class="line">	FastClick.prototype.updateScrollParent = function(targetElement) &#123;</span><br><span class="line">		var scrollParent, parentElement;</span><br><span class="line"></span><br><span class="line">		scrollParent = targetElement.fastClickScrollParent;</span><br><span class="line"></span><br><span class="line">		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the</span><br><span class="line">		// target element was moved to another parent.</span><br><span class="line">		if(!scrollParent || !scrollParent.contains(targetElement)) &#123;</span><br><span class="line">			parentElement = targetElement;</span><br><span class="line">			do &#123;</span><br><span class="line">				if(parentElement.scrollHeight &gt; parentElement.offsetHeight) &#123;</span><br><span class="line">					scrollParent = parentElement;</span><br><span class="line">					targetElement.fastClickScrollParent = parentElement;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				parentElement = parentElement.parentElement;</span><br><span class="line">			&#125; while (parentElement);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 给滚动容器加个标志fastClickLastScrollTop，值为其当前垂直滚动偏移</span><br><span class="line">		if(scrollParent) &#123;</span><br><span class="line">			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	 * 返回目标元素</span><br><span class="line">	 */</span><br><span class="line">	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) &#123;</span><br><span class="line"></span><br><span class="line">		// 一些较老的浏览器，target 可能会是一个文本节点，得返回其DOM节点</span><br><span class="line">		if(eventTarget.nodeType === Node.TEXT_NODE) &#123;</span><br><span class="line">			return eventTarget.parentNode;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return eventTarget;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.onTouchStart = function(event) &#123;</span><br><span class="line">		var targetElement, touch, selection;</span><br><span class="line"></span><br><span class="line">		// 多指触控的手势则忽略</span><br><span class="line">		if(event.targetTouches.length &gt; 1) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		targetElement = this.getTargetElementFromEventTarget(event.target); //一些较老的浏览器，target 可能会是一个文本节点，得返回其DOM节点</span><br><span class="line">		touch = event.targetTouches[0];</span><br><span class="line"></span><br><span class="line">		if(deviceIsIOS) &#123; //IOS处理</span><br><span class="line"></span><br><span class="line">			// 若用户已经选中了一些内容（比如选中了一段文本打算复制），则忽略</span><br><span class="line">			selection = window.getSelection();</span><br><span class="line">			if(selection.rangeCount &amp;&amp; !selection.isCollapsed) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if(!deviceIsIOS4) &#123; //是否IOS4</span><br><span class="line"></span><br><span class="line">				//怪异特性处理——若click事件回调打开了一个alert/confirm，用户下一次tap页面的其它地方时，新的touchstart和touchend</span><br><span class="line">				//事件会拥有同一个touch.identifier（新的 touch event 会跟上一次触发alert点击的 touch event 一样），</span><br><span class="line">				//为避免将新的event当作之前的event导致问题，这里需要禁用默认事件</span><br><span class="line">				//另外chrome的开发工具启用&apos;Emulate touch events&apos;后，iOS UA下的 identifier 会变成0，所以要做容错避免调试过程也被禁用事件了</span><br><span class="line">				if(touch.identifier &amp;&amp; touch.identifier === this.lastTouchIdentifier) &#123;</span><br><span class="line">					event.preventDefault();</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				this.lastTouchIdentifier = touch.identifier;</span><br><span class="line"></span><br><span class="line">				// 如果target是一个滚动容器里的一个子元素(使用了 -webkit-overflow-scrolling: touch) ，而且满足:</span><br><span class="line">				// 1) 用户非常快速地滚动外层滚动容器</span><br><span class="line">				// 2) 用户通过tap停止住了这个快速滚动</span><br><span class="line">				// 这时候最后的&apos;touchend&apos;的event.target会变成用户最终手指下的那个元素</span><br><span class="line">				// 所以当快速滚动开始的时候，需要做检查target是否滚动容器的子元素，如果是，做个标记</span><br><span class="line">				// 在touchend时检查这个标记的值（滚动容器的scrolltop）是否改变了，如果是则说明页面在滚动中，需要取消fastclick处理</span><br><span class="line">				this.updateScrollParent(targetElement);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		this.trackingClick = true; //做个标志表示开始追踪click事件了</span><br><span class="line">		this.trackingClickStart = event.timeStamp; //标记下touch事件开始的时间戳</span><br><span class="line">		this.targetElement = targetElement;</span><br><span class="line"></span><br><span class="line">		//标记touch起始点的页面偏移值</span><br><span class="line">		this.touchStartX = touch.pageX;</span><br><span class="line">		this.touchStartY = touch.pageY;</span><br><span class="line"></span><br><span class="line">		// this.lastClickTime 是在 touchend 里标记的事件时间戳</span><br><span class="line">		// this.tapDelay 为常量 200 （ms）</span><br><span class="line">		// 此举用来避免 phantom 的双击（200ms内快速点了两次）触发 click</span><br><span class="line">		// 反正200ms内的第二次点击会禁止触发点击的默认事件</span><br><span class="line">		if((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123;</span><br><span class="line">			event.preventDefault();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return true;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//判断是否移动了</span><br><span class="line">	//this.touchBoundary是常量，值为10</span><br><span class="line">	//如果touch已经移动了10个偏移量单位，则应当作为移动事件处理而非click事件</span><br><span class="line">	FastClick.prototype.touchHasMoved = function(event) &#123;</span><br><span class="line">		var touch = event.changedTouches[0],</span><br><span class="line">			boundary = this.touchBoundary;</span><br><span class="line"></span><br><span class="line">		if(Math.abs(touch.pageX - this.touchStartX) &gt; boundary || Math.abs(touch.pageY - this.touchStartY) &gt; boundary) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.onTouchMove = function(event) &#123;</span><br><span class="line">		//不是需要被追踪click的事件则忽略</span><br><span class="line">		if(!this.trackingClick) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 如果target突然改变了，或者用户其实是在移动手势而非想要click</span><br><span class="line">		// 则应该清掉this.trackingClick和this.targetElement，告诉后面的事件你们也不用处理了</span><br><span class="line">		if(this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) &#123;</span><br><span class="line">			this.trackingClick = false;</span><br><span class="line">			this.targetElement = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return true;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//找到label标签所映射的组件，方便让用户点label的时候直接激活该组件</span><br><span class="line">	FastClick.prototype.findControl = function(labelElement) &#123;</span><br><span class="line"></span><br><span class="line">		// 有缓存则直接读缓存着的</span><br><span class="line">		if(labelElement.control !== undefined) &#123;</span><br><span class="line">			return labelElement.control;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 获取指向的组件</span><br><span class="line">		if(labelElement.htmlFor) &#123;</span><br><span class="line">			return document.getElementById(labelElement.htmlFor);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 没有for属性则激活页面第一个组件（labellable 元素）</span><br><span class="line">		return labelElement.querySelector(&apos;button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea&apos;);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.onTouchEnd = function(event) &#123;</span><br><span class="line">		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;</span><br><span class="line"></span><br><span class="line">		if(!this.trackingClick) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 避免 phantom 的双击（200ms内快速点了两次）触发 click</span><br><span class="line">		// 我们在 ontouchstart 里已经做过一次判断了（仅仅禁用默认事件），这里再做一次判断</span><br><span class="line">		if((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123;</span><br><span class="line">			this.cancelNextClick = true; //该属性会在 onMouse 事件中被判断，为true则彻底禁用事件和冒泡</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//this.tapTimeout是常量，值为700</span><br><span class="line">		//识别是否为长按事件，如果是（大于700ms）则忽略</span><br><span class="line">		if((event.timeStamp - this.trackingClickStart) &gt; this.tapTimeout) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 得重置为false，避免input事件被意外取消</span><br><span class="line">		// 例子见 https://github.com/ftlabs/fastclick/issues/156</span><br><span class="line">		this.cancelNextClick = false;</span><br><span class="line"></span><br><span class="line">		this.lastClickTime = event.timeStamp; //标记touchend时间，方便下一次的touchstart做双击校验</span><br><span class="line"></span><br><span class="line">		trackingClickStart = this.trackingClickStart;</span><br><span class="line">		//重置 this.trackingClick 和 this.trackingClickStart</span><br><span class="line">		this.trackingClick = false;</span><br><span class="line">		this.trackingClickStart = 0;</span><br><span class="line"></span><br><span class="line">		// iOS 6.0-7.*版本下有个问题 —— 如果layer处于transition或scroll过程，event所提供的target是不正确的</span><br><span class="line">		// 所以咱们得重找 targetElement（这里通过 document.elementFromPoint 接口来寻找）</span><br><span class="line">		if(deviceIsIOSWithBadTarget) &#123; //iOS 6.0-7.*版本</span><br><span class="line">			touch = event.changedTouches[0]; //手指离开前的触点</span><br><span class="line"></span><br><span class="line">			// 有些情况下 elementFromPoint 里的参数是预期外/不可用的, 所以还得避免 targetElement 为 null</span><br><span class="line">			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;</span><br><span class="line">			// target可能不正确需要重找，但fastClickScrollParent是不会变的</span><br><span class="line">			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		targetTagName = targetElement.tagName.toLowerCase();</span><br><span class="line">		if(targetTagName === &apos;label&apos;) &#123; //是label则激活其指向的组件</span><br><span class="line">			forElement = this.findControl(targetElement);</span><br><span class="line">			if(forElement) &#123;</span><br><span class="line">				this.focus(targetElement);</span><br><span class="line">				//安卓直接返回（无需合成click事件触发，因为点击和激活元素不同，不存在点透）</span><br><span class="line">				if(deviceIsAndroid) &#123;</span><br><span class="line">					return false;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				targetElement = forElement;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else if(this.needsFocus(targetElement)) &#123; //非label则识别是否需要focus的元素</span><br><span class="line"></span><br><span class="line">			//手势停留在组件元素时长超过100ms，则置空this.targetElement并返回</span><br><span class="line">			//（而不是通过调用this.focus来触发其聚焦事件，走的原生的click/focus事件触发流程）</span><br><span class="line">			//这也是为何文章开头提到的问题中，稍微久按一点（超过100ms）textarea是可以把光标定位在正确的地方的原因</span><br><span class="line">			//另外iOS下有个意料之外的bug——如果被点击的元素所在文档是在iframe中的，手动调用其focus的话，</span><br><span class="line">			//会发现你往其中输入的text是看不到的（即使value做了更新），so这里也直接返回</span><br><span class="line">			if((event.timeStamp - trackingClickStart) &gt; 100 || (deviceIsIOS &amp;&amp; window.top !== window &amp;&amp; targetTagName === &apos;input&apos;)) &#123;</span><br><span class="line">				this.targetElement = null;</span><br><span class="line">				return false;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			this.focus(targetElement);</span><br><span class="line">			this.sendClick(targetElement, event); //立即触发其click事件，而无须等待300ms</span><br><span class="line"></span><br><span class="line">			//iOS4下的 select 元素不能禁用默认事件（要确保它能被穿透），否则不会打开select目录</span><br><span class="line">			//有时候 iOS6/7 下（VoiceOver开启的情况下）也会如此</span><br><span class="line">			if(!deviceIsIOS || targetTagName !== &apos;select&apos;) &#123;</span><br><span class="line">				this.targetElement = null;</span><br><span class="line">				event.preventDefault();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(deviceIsIOS &amp;&amp; !deviceIsIOS4) &#123;</span><br><span class="line"></span><br><span class="line">			// 滚动容器的垂直滚动偏移改变了，说明是容器在做滚动而非点击，则忽略</span><br><span class="line">			scrollParent = targetElement.fastClickScrollParent;</span><br><span class="line">			if(scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 查看元素是否无需处理的白名单内（比如加了名为“needsclick”的class）</span><br><span class="line">		// 不是白名单的则照旧预防穿透处理，立即触发合成的click事件</span><br><span class="line">		if(!this.needsClick(targetElement)) &#123;</span><br><span class="line">			event.preventDefault();</span><br><span class="line">			this.sendClick(targetElement, event);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.prototype.onTouchCancel = function() &#123;</span><br><span class="line">		this.trackingClick = false;</span><br><span class="line">		this.targetElement = null;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//用于决定是否允许穿透事件（触发layer的click默认事件）</span><br><span class="line">	FastClick.prototype.onMouse = function(event) &#123;</span><br><span class="line"></span><br><span class="line">		// touch事件一直没触发</span><br><span class="line">		if(!this.targetElement) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(event.forwardedTouchEvent) &#123; //触发的click事件是合成的</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 编程派生的事件所对应元素事件可以被允许</span><br><span class="line">		// 确保其没执行过 preventDefault 方法（event.cancelable 不为 true）即可</span><br><span class="line">		if(!event.cancelable) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 需要做预防穿透处理的元素，或者做了快速（200ms）双击的情况</span><br><span class="line">		if(!this.needsClick(this.targetElement) || this.cancelNextClick) &#123;</span><br><span class="line">			//停止当前默认事件和冒泡</span><br><span class="line">			if(event.stopImmediatePropagation) &#123;</span><br><span class="line">				event.stopImmediatePropagation();</span><br><span class="line">			&#125; else &#123;</span><br><span class="line"></span><br><span class="line">				// 不支持 stopImmediatePropagation 的设备(比如Android 2)做标记，</span><br><span class="line">				// 确保该事件回调不会执行（见126行）</span><br><span class="line">				event.propagationStopped = true;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			// 取消事件和冒泡</span><br><span class="line">			event.stopPropagation();</span><br><span class="line">			event.preventDefault();</span><br><span class="line"></span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//允许穿透</span><br><span class="line">		return true;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//click事件常规都是touch事件衍生来的，也排在touch后面触发。</span><br><span class="line">	//对于那些我们在touch事件过程没有禁用掉默认事件的event来说，我们还需要在click的捕获阶段进一步</span><br><span class="line">	//做判断决定是否要禁掉点击事件（防穿透）</span><br><span class="line">	FastClick.prototype.onClick = function(event) &#123;</span><br><span class="line">		var permitted;</span><br><span class="line"></span><br><span class="line">		// 如果还有 trackingClick 存在，可能是某些UI事件阻塞了touchEnd 的执行</span><br><span class="line">		if(this.trackingClick) &#123;</span><br><span class="line">			this.targetElement = null;</span><br><span class="line">			this.trackingClick = false;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 依旧是对 iOS 怪异行为的处理 —— 如果用户点击了iOS模拟器里某个表单中的一个submit元素</span><br><span class="line">		// 或者点击了弹出来的键盘里的“Go”按钮，会触发一个“伪”click事件（target是一个submit-type的input元素）</span><br><span class="line">		if(event.target.type === &apos;submit&apos; &amp;&amp; event.detail === 0) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		permitted = this.onMouse(event);</span><br><span class="line"></span><br><span class="line">		if(!permitted) &#123; //如果点击是被允许的，将this.targetElement置空可以确保onMouse事件里不会阻止默认事件</span><br><span class="line">			this.targetElement = null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		//没有多大意义</span><br><span class="line">		return permitted;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//销毁Fastclick所注册的监听事件。是给外部实例去调用的</span><br><span class="line">	FastClick.prototype.destroy = function() &#123;</span><br><span class="line">		var layer = this.layer;</span><br><span class="line"></span><br><span class="line">		if(deviceIsAndroid) &#123;</span><br><span class="line">			layer.removeEventListener(&apos;mouseover&apos;, this.onMouse, true);</span><br><span class="line">			layer.removeEventListener(&apos;mousedown&apos;, this.onMouse, true);</span><br><span class="line">			layer.removeEventListener(&apos;mouseup&apos;, this.onMouse, true);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		layer.removeEventListener(&apos;click&apos;, this.onClick, true);</span><br><span class="line">		layer.removeEventListener(&apos;touchstart&apos;, this.onTouchStart, false);</span><br><span class="line">		layer.removeEventListener(&apos;touchmove&apos;, this.onTouchMove, false);</span><br><span class="line">		layer.removeEventListener(&apos;touchend&apos;, this.onTouchEnd, false);</span><br><span class="line">		layer.removeEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	//是否没必要使用到 Fastclick 的检测</span><br><span class="line">	FastClick.notNeeded = function(layer) &#123;</span><br><span class="line">		var metaViewport;</span><br><span class="line">		var chromeVersion;</span><br><span class="line">		var blackberryVersion;</span><br><span class="line">		var firefoxVersion;</span><br><span class="line"></span><br><span class="line">		// 不支持触摸的设备</span><br><span class="line">		if(typeof window.ontouchstart === &apos;undefined&apos;) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 获取Chrome版本号，若非Chrome则返回0</span><br><span class="line">		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];</span><br><span class="line"></span><br><span class="line">		if(chromeVersion) &#123;</span><br><span class="line"></span><br><span class="line">			if(deviceIsAndroid) &#123; //安卓</span><br><span class="line">				metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line"></span><br><span class="line">				if(metaViewport) &#123;</span><br><span class="line">					// 安卓下，带有 user-scalable=&quot;no&quot; 的 meta 标签的 chrome 是会自动禁用 300ms 延迟的，所以无需 Fastclick</span><br><span class="line">					if(metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1) &#123;</span><br><span class="line">						return true;</span><br><span class="line">					&#125;</span><br><span class="line">					// 安卓Chrome 32 及以上版本，若带有 width=device-width 的 meta 标签也是无需 FastClick 的</span><br><span class="line">					if(chromeVersion &gt; 31 &amp;&amp; document.documentElement.scrollWidth &lt;= window.outerWidth) &#123;</span><br><span class="line">						return true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// 其它的就肯定是桌面级的 Chrome 了，更不需要 FastClick 啦</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if(deviceIsBlackBerry10) &#123; //黑莓，和上面安卓同理，就不写注释了</span><br><span class="line">			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);</span><br><span class="line"></span><br><span class="line">			if(blackberryVersion[1] &gt;= 10 &amp;&amp; blackberryVersion[2] &gt;= 3) &#123;</span><br><span class="line">				metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line"></span><br><span class="line">				if(metaViewport) &#123;</span><br><span class="line">					if(metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1) &#123;</span><br><span class="line">						return true;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					if(document.documentElement.scrollWidth &lt;= window.outerWidth) &#123;</span><br><span class="line">						return true;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// 带有 -ms-touch-action: none / manipulation 特性的 IE10 会禁用双击放大，也没有 300ms 时延</span><br><span class="line">		if(layer.style.msTouchAction === &apos;none&apos; || layer.style.touchAction === &apos;manipulation&apos;) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// Firefox检测，同上</span><br><span class="line">		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];</span><br><span class="line"></span><br><span class="line">		if(firefoxVersion &gt;= 27) &#123;</span><br><span class="line"></span><br><span class="line">			metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line">			if(metaViewport &amp;&amp; (metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1 || document.documentElement.scrollWidth &lt;= window.outerWidth)) &#123;</span><br><span class="line">				return true;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		// IE11 推荐使用没有“-ms-”前缀的 touch-action 样式特性名</span><br><span class="line">		if(layer.style.touchAction === &apos;none&apos; || layer.style.touchAction === &apos;manipulation&apos;) &#123;</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return false;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	FastClick.attach = function(layer, options) &#123;</span><br><span class="line">		return new FastClick(layer, options);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	if(typeof define === &apos;function&apos; &amp;&amp; typeof define.amd === &apos;object&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line"></span><br><span class="line">		// AMD. Register as an anonymous module.</span><br><span class="line">		define(function() &#123;</span><br><span class="line">			return FastClick;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; else if(typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class="line">		module.exports = FastClick.attach;</span><br><span class="line">		module.exports.FastClick = FastClick;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		window.FastClick = FastClick;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">		&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">		&lt;title&gt;Demo&lt;/title&gt;</span><br><span class="line">		&lt;script src=&quot;./fastclick.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">		&lt;style&gt;</span><br><span class="line">			div &#123;</span><br><span class="line">				width: 200px;</span><br><span class="line">				background: red;Y</span><br><span class="line">				margin: 0 auto;</span><br><span class="line">				height: 200px;</span><br><span class="line">				color: wheat;</span><br><span class="line">				font-size: 25px;</span><br><span class="line">				display: flex;</span><br><span class="line">				justify-content: center;</span><br><span class="line">				align-items: center;</span><br><span class="line">			&#125;</span><br><span class="line">		&lt;/style&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		&lt;div id=&quot;main&quot;&gt;FastClick&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">		&lt;script&gt;</span><br><span class="line">			FastClick.attach(document.body);</span><br><span class="line">			document.getElementById(&quot;main&quot;).addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class="line">				console.log(event.target.innerText)</span><br><span class="line">			&#125;, false)</span><br><span class="line">		&lt;/script&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/tx.jpg"
                alt="李斌" />
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">114</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">92</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="3120217729@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


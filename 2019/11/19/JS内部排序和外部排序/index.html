<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="排序算法的有关文章已经很多了，他也是面试经常(100%)会问到的一个考点。这里主要是我来尝试自己针对网上各式的排序算法进行一份浅显的个人总结，从而温故知新。 内排序与外排序由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：内部排序  与 外部排序 。 概念 内部排序：【内存排序】待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。内排序效率用比较">
<meta property="og:type" content="article">
<meta property="og:title" content="JS内部排序和外部排序">
<meta property="og:url" content="http://yoursite.com/2019/11/19/JS内部排序和外部排序/index.html">
<meta property="og:site_name" content="啷哩咯啷">
<meta property="og:description" content="排序算法的有关文章已经很多了，他也是面试经常(100%)会问到的一个考点。这里主要是我来尝试自己针对网上各式的排序算法进行一份浅显的个人总结，从而温故知新。 内排序与外排序由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：内部排序  与 外部排序 。 概念 内部排序：【内存排序】待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。内排序效率用比较">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68931452-84716180-07cb-11ea-923b-560fc304a6a7.png">
<meta property="og:image" content="https://camo.githubusercontent.com/bc20131e2ee7ad70c06e7c71eefc04c3a3cc18a2/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393136313630373438333839">
<meta property="og:image" content="https://camo.githubusercontent.com/603dd620708cd52e8d60af45ffbcb1c7986c98ba/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393136313634373534303133">
<meta property="og:image" content="https://camo.githubusercontent.com/419cbfed21e0d421b56abc402563649d73dcc453/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393136313733383032353937">
<meta property="og:image" content="http://qcyoung.qiniudn.com/qcyoung/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/shellsort.jpeg">
<meta property="og:image" content="https://camo.githubusercontent.com/0a7ed1ffe79aba1d560a6ab75823f9e74ad122da/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137303031333236323534">
<meta property="og:image" content="https://camo.githubusercontent.com/253b22840353c9759694d63839fe7565d48f9df6/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137303033303034393036">
<meta property="og:image" content="https://camo.githubusercontent.com/146edaa09f8c3b584236c33594d33e7be67e14fc/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137313035353032383533">
<meta property="og:image" content="https://camo.githubusercontent.com/016361c57b8a949ec57103de45a35b34e16332d0/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137313130363431343739">
<meta property="og:image" content="http://qcyoung.qiniudn.com/qcyoung/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/bucketsort.jpeg">
<meta property="og:image" content="https://camo.githubusercontent.com/a46fad9480fac227626a6798ae98ba3a6231ebc8/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137313233333133363539">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68932049-c5b64100-07cc-11ea-975f-799088e2f06c.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68932066-ccdd4f00-07cc-11ea-848d-3b97d9afe91d.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68932078-cfd83f80-07cc-11ea-83a3-9d287fd65e9c.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933115-f39c8500-07ce-11ea-9db1-57df9c682dcb.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933141-feefb080-07ce-11ea-8531-e9aa9c76f382.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933174-10d15380-07cf-11ea-98be-7309e3864bd4.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933186-1cbd1580-07cf-11ea-9ded-783c20850e5b.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933245-3a8a7a80-07cf-11ea-8618-9defab974659.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933276-46763c80-07cf-11ea-997a-0db3dc4005f3.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933304-51c96800-07cf-11ea-8541-a39c9d5325b0.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933318-5c83fd00-07cf-11ea-8520-7890401c4842.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933340-686fbf00-07cf-11ea-8721-385ea949cf46.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933550-d87e4500-07cf-11ea-92ce-9028db5fb1da.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933660-167b6900-07d0-11ea-9895-0f07f005df2f.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933714-3874eb80-07d0-11ea-8019-2d6a15e1d6be.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933725-40cd2680-07d0-11ea-9485-0815778d69e4.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933735-475b9e00-07d0-11ea-8fe7-a8125412f1bc.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933744-4dea1580-07d0-11ea-93ba-a58df82b0fee.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933756-55112380-07d0-11ea-9c3e-60455481dfe7.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933782-60fce580-07d0-11ea-8806-9707c31219c4.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933806-69552080-07d0-11ea-8c4a-4e7fddec8f7e.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933823-707c2e80-07d0-11ea-9043-4e59dd22a667.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933842-7a9e2d00-07d0-11ea-9099-e44883ec25ca.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933858-825dd180-07d0-11ea-81a3-441fc997b21b.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933879-8b4ea300-07d0-11ea-9086-4c709660a35d.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/16753554/68933902-94d80b00-07d0-11ea-9a12-0a2bbb3dadad.png">
<meta property="og:updated_time" content="2019-11-17T07:09:24.203Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS内部排序和外部排序">
<meta name="twitter:description" content="排序算法的有关文章已经很多了，他也是面试经常(100%)会问到的一个考点。这里主要是我来尝试自己针对网上各式的排序算法进行一份浅显的个人总结，从而温故知新。 内排序与外排序由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：内部排序  与 外部排序 。 概念 内部排序：【内存排序】待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。内排序效率用比较">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/16753554/68931452-84716180-07cb-11ea-923b-560fc304a6a7.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/19/JS内部排序和外部排序/">





  <title>JS内部排序和外部排序 | 啷哩咯啷</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
    	<div id="sky">
				<div id="background" class="container">
			<!-- svg file -->
			<svg id="svgout" height="100%" width="100%" viewbox="0 0 550 400">
				<defs>
					<g id="bottomShadow">
						<path fill="#000000" stroke="none" d="
		M 270.5 225.95
		L 127.35 316.65 266.8 400 409.6 309.25 270.5 225.95 Z"/>
					</g>
					<g id="Layer52_0_FILL">
						<path class="topGrass" fill="#B9D668" stroke="none" d="
	M 397.85 229.3
	L 397.85 225.6 269.85 152 135.75 228.6 135.75 233.65 262.1 306.55 397.85 229.3 Z"/>
					</g>
					<g id="Layer51_0_FILL">
						<path class="leftSideGrass" fill="#6E9E4F" stroke="none" d="
	M 135.1 229.95
	L 135.1 256.85 262.1 328.4 262.1 301.85 135.1 229.95 Z"/>
					</g>
					<g id="Layer50_0_FILL">
						<path class="rightGrassTop" fill="#8CB154" stroke="none" d="
	M 397.85 225.95
	L 395.8 225.95 261.75 301.55 261.75 328.4 397.85 251.15 397.85 225.95 Z"/>
					</g>
					<g id="Layer48_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.45 282.4
	L 135.75 298.15 262.1 372.1 261.75 355.65 135.45 282.4 Z"/>
					</g>
					<g id="Layer47_0_FILL">
						<path class="middleLeftCrust" fill="#C77E61" stroke="none" d="
	M 135.1 270.3
	L 135.1 283.05 275.9 364.35 271.85 348.9 135.1 270.3 Z"/>
					</g>
					<g id="Layer46_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.1 255.15
	L 135.1 270.3 262.1 343.55 262.1 328.05 135.1 255.15 Z"/>
					</g>
					<g id="Layer45_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 294.5
	L 397.5 277 261.75 355.3 261.75 372.75 397.5 294.5 Z"/>
					</g>
					<g id="Layer44_0_FILL">
						<path class="middleRightCrust" fill="#C89451" stroke="none" d="
	M 397.5 269.95
	L 397.15 266.6 262.1 343.2 262.1 355.95 397.5 279.7 397.5 269.95 Z"/>
					</g>
					<g id="Layer43_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 266.6
	L 397.5 250.45 261.75 328.4 261.75 343.85 397.5 266.6 Z"/>
					</g>
					<g id="Layer41_0_FILL">
						<path class="greyRoad" fill="#B2B2B1" stroke="none" d="
	M 295.05 283.05
	Q 299.05 280.35 308.45 275.3 317.85 269.95 323.6 266.9
	L 268.8 233.65 338.05 191.35 309.15 174.55 177.75 254.5
	Q 191.55 262.2 198.25 266.25 204.65 269.95 209.7 271.95
	L 241.6 250.45 295.05 283.05 Z"/>
					</g>
					<g id="Layer40_0_FILL">
						<path fill="#FFFFFF" stroke="none" d="
	M 199.95 256.85
	Q 194.55 261.2 191.9 262.2
	L 194.9 263.9 200.95 259.2 199.95 256.85
	M 225.8 243.75
	L 224.8 241.75 211.05 250.8 212.05 252.8 225.8 243.75
	M 308.15 275.65
	L 296.7 266.6 295.35 268.6 306.8 277.7 308.15 275.65
	M 275.9 253.5
	L 274.55 255.5 285.95 264.55 287.3 262.55 275.9 253.5
	M 251.7 227.3
	L 250.7 225.25 236.9 234.35 237.9 236.35 251.7 227.3
	M 257.05 240.7
	L 254.05 240.7 268.8 249.8 269.5 247.75 257.05 240.7
	M 277.2 207.8
	L 263.45 216.85 264.45 218.9 278.25 209.8 277.2 207.8
	M 305.1 192.65
	L 304.1 190.65 290.3 199.75 291.35 201.75 305.1 192.65 Z"/>
					</g>
					<g id="Layer38_0_FILL">
						<path class="frontFascia" fill="#ECB27B" stroke="none" d="
	M 359.25 187.95
	L 346.4 174.95 333.85 202.9 359.25 187.95 Z"/>
					</g>
					<g id="Layer37_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 334 201.05
	L 334.35 232 359.2 217.55 359.25 187.95 334 201.05 Z"/>
					</g>
					<g id="Layer36_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 334.35 232.3
	L 334.35 205.1 305.1 191.35 305.1 216.85 334.35 232.3 Z"/>
					</g>
					<g id="Layer35_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 329.7 167.9
	L 331.05 167.9 344.55 176.7 347.85 176.7 363 192.25 363.15 189.55 350.65 176.7 350.55 176.7 334.25 167.5 334.25 159.1 329.7 159.1 329.7 164.9 322.65 160.95 322.3 162.15 329.7 167 329.7 167.9 Z"/>
					</g>
					<g id="Layer34_0_FILL">
						<path class="leftRoof" fill="#F2563B" stroke="none" d="
	M 334.05 207.05
	L 350.65 176.7 322.1 160.45 302.1 192.05 334.05 207.05 Z"/>
					</g>
					<g id="Layer30_0_FILL">
						<path id="windowFour" class="windows" stroke="none" fill="#975A42" d="
	M 341.35 203.3
	Q 340.9 203.45 340.5 203.8 340.1 204.2 339.85 204.75 339.7 205 339.7 205.3 339.6 205.75 339.7 206.1 339.7 206.15 339.7 206.2 339.8 206.5 340 206.8 340.55 207.4 341.45 207.4 342.35 207.4 343 206.8 343.4 206.5 343.65 206.1 343.85 205.75 343.95 205.3 344.05 204.4 343.55 203.8 343.3 203.45 343 203.3 342.65 203.15 342.2 203.15 341.8 203.15 341.35 203.3
	M 355.85 198.45
	Q 355.8 198.2 355.6 198 355.1 197.4 354.2 197.4 353.35 197.4 352.6 198 351.85 198.65 351.7 199.55 351.7 199.7 351.7 199.85 351.6 200.5 352 201.05 352.55 201.65 353.45 201.65 354.3 201.65 355.05 201.05 355.45 200.7 355.7 200.25 355.8 200.05 355.9 199.85 355.95 199.7 355.95 199.55 356.05 198.95 355.85 198.45 Z"/>
						<path class="door" fill="#B65041" stroke="none" d="
	M 351.95 211.2
	L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2
	M 351.2 211.2
	L 351.35 211.2 351.35 211.1 351.2 211.2 Z"/>
					</g>
					<g>
						<path id="Layer30_0_FILL" fill="#000000" fill-opacity="1" stroke="none" d="
	M 183.7 215.3
	L 183.7 215.6
	Q 187.25 231.75 212.25 234.35
	L 183.7 215.3 Z"/>
					</g>
					<g id="Layer29_0_FILL">
						<path fill="#000000" fill-opacity="0.4" stroke="none" d="
	M 305.1 216.85
	L 305.15 217.2
	Q 309.45 233.2 334.35 232.3
	L 305.1 216.85 Z"/>
					</g>
					<g id="Layer27_0_FILL">
						<path class="vegetation" fill="#78A950" stroke="none" d="
	M 177.45 231.65
	Q 175.75 235.35 181.8 239.35 185.5 235.7 185.15 231.3 182.8 230.65 181.45 234 179.45 231.3 177.45 231.65
	M 236.9 266.6
	Q 235.2 270.3 241.25 274.3 244.95 270.6 244.65 266.25 242.3 265.6 240.95 268.95 238.9 266.25 236.9 266.6
	M 254.7 277
	Q 253.05 280.7 259.1 284.75 262.75 281.05 262.45 276.65 260.1 276 258.75 279.35 256.7 276.65 254.7 277
	M 315.5 245.75
	Q 313.5 243.05 311.5 243.4 309.8 247.1 315.85 251.15 319.55 247.45 319.2 243.05 316.85 242.4 315.5 245.75
	M 295.35 232.65
	Q 293.7 236.35 299.75 240.4 303.45 236.7 303.1 232.3 300.75 231.65 299.4 235 297.4 232.3 295.35 232.65
	M 277.2 171.85
	Q 275.55 175.55 281.6 179.55 285.3 175.85 284.95 171.5 282.6 170.85 281.25 174.2 279.25 171.5 277.2 171.85 Z"/>
					</g>
					<g id="Layer26_0_FILL">
						<path class="treeWood" fill="#AE663D" stroke="none" d="
	M 175.1 177.55
	L 172.05 177.55 172.05 191.1 159.3 172.85
	Q 154.6 171.5 172.05 195.7
	L 172.05 212.5 175.1 212.5 175.1 177.55
	M 252.7 151.35
	L 249 151.35 249 176.9 252.7 176.9 252.7 151.35 Z"/>
					</g>
					<g id="Layer25_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 192.55 179.55
	Q 200.95 173.5 200.95 165.1 200.95 156.4 192.55 150 184.15 144.3 172.05 144.3 160.3 144.3 151.9 150 143.15 156.4 143.15 165.1 143.15 173.5 151.9 179.55 160.3 185.95 172.05 185.95 184.15 185.95 192.55 179.55
	M 236.25 106.65
	Q 230.2 116.05 230.2 129.15 230.2 142.25 236.25 151.35 242.3 160.75 250.7 160.75 258.75 160.75 264.8 151.35 270.85 142.25 270.85 129.15 270.85 116.05 264.8 106.65 258.75 97.6 250.7 97.6 242.3 97.6 236.25 106.65 Z"/>
					</g>
					<g id="Layer24_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 158.3 221.9
	Q 160.65 221.9 161.95 220.2 163 219.55 163.3 218.55 164.65 218.9 166.35 218.9 170.05 218.9 172.4 216.2 175.1 213.85 175.1 210.15 175.1 206.45 172.4 203.75 170.05 201.4 166.35 201.4 162.65 201.4 159.95 203.75 157.6 206.45 157.6 210.15 157.6 210.8 157.6 211.15 155.95 211.5 154.6 212.5 152.9 214.15 152.9 216.55 152.9 218.9 154.6 220.2 156.25 221.9 158.3 221.9
	M 338.35 240.05
	Q 341.05 237.7 341.05 234 341.05 230.3 338.35 227.6 336 225.25 332.3 225.25 328.65 225.25 325.95 227.6 323.6 230.3 323.6 234 323.6 237.7 325.95 240.05 328.65 242.75 332.3 242.75 336 242.75 338.35 240.05 Z"/>
					</g>
					<g id="Layer22_0_FILL">
						<path class="rightRoof" fill="#D05041" stroke="none" d="
	M 220 173.85
	L 236.8 186.7 264.35 171.15 244.5 159.55 220 173.85 Z"/>
					</g>
					<g id="Layer21_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 212.25 191.35
	L 183.35 172.3 183.7 215.3 212.25 234.35 212.25 191.35 Z"/>
					</g>
					<g id="Layer20_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 192.1 149.85
	L 236.45 174.8 243.1 171.4
	Q 220.05 150.55 196.3 139.95
	L 192.1 149.85 Z"/>
					</g>
					<g id="Layer19_0_FILL">
						<path class="frontFascia" fill="#EBB17B" stroke="none" d="
	M 226.85 160.95
	L 212 190.6 229.75 192.6 239.75 172.85 226.85 160.95 Z"/>
					</g>
					<g id="Layer18_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 240.15 172.65
	L 211.9 191.6 212.25 233.65 264.35 201.7 264.35 170.8 240.8 184.45 240.15 172.65 Z"/>
					</g>
					<g id="Layer17_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 210.9 142.2
	L 205.9 142.2 205.9 152.65 210.9 152.65 210.9 142.2 Z"/>
					</g>
					<g>
						<path id="Layer16_0_FILL" class="leftRoof" fill="#F2563B" stroke="none" d="
	M 210.25 195.5
	L 227.4 160.95 195.45 141.35 177.65 175.85 210.25 195.5 Z"/>
					</g>
					<g>
						<path id="sun" fill="#E3BD0E" stroke="none" d="
	M 257.05 15.95
	Q 251.7 15.95 248 19.65 244.3 23.35 244.3 28.7 244.3 34.1 248 37.8 251.7 41.5 257.05 41.5 262.45 41.5 266.15 37.8 269.85 34.1 269.85 28.7 269.85 23.35 266.15 19.65 262.45 15.95 257.05 15.95 Z"/>
					</g>
					<g id="Layer8_0_FILL">
						<path fill="#975A42" stroke="none" d="
	M 238.45 189.65
	Q 238.295703125 189.362109375 238.05 189.1 237.35 188.3 236.2 188.3 235.05 188.3 234.15 189.1 233.3 189.9 233.2 191.05 233.1 192.2 233.8 193 234.55 193.8 235.7 193.8 236.85 193.8 237.7 193 238.1970703125 192.558203125 238.45 192 238.6552734375 191.56484375 238.7 191.05 238.7671875 190.276953125 238.45 189.65
	M 220.55 197.55
	Q 220 197.55 219.5 197.75 218.95 197.95 218.5 198.35 217.933203125 198.8833984375 217.7 199.55 217.5833984375 199.916796875 217.55 200.3 217.4923828125 200.96171875 217.7 201.5 217.852734375 201.9103515625 218.15 202.25 218.95 203.05 220.1 203.05 221.25 203.05 222.05 202.25 222.95 201.45 223.05 200.3 223.15 199.15 222.4 198.35 222.05 197.95 221.65 197.75 221.15 197.55 220.55 197.55 Z"/>
					</g>
					<g id="Layer7_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 233.55 206.75
	L 225.9 211.95 226.25 225.5 233.95 220.35 233.55 206.75 Z"/>
					</g>
					<g>
						<path id="windowOne" class="windows" fill="#975A42" stroke="none" d="
	M 188.65 198.4
	L 188.8 204.1 198.65 210.45 198.55 204.75 188.65 198.4
	M 208.45 216.8
	L 208.35 211.1 198.55 204.75 198.65 210.45 208.45 216.8
	M 188.8 204.1
	L 188.95 209.8 198.8 216.15 198.65 210.45 188.8 204.1
	M 208.6 222.5
	L 208.45 216.8 198.65 210.45 198.8 216.15 208.6 222.5 Z"/>
					</g>
					<g>
						<path id="windowThree" class="windows" fill="#975A42" stroke="none" d="
	M 311.7 214.1
	L 318.55 217.55 318.45 211.9 311.6 208.45 311.7 214.1
	M 325.4 221
	L 325.25 215.35 318.45 211.9 318.55 217.55 325.4 221
	M 318.4 206.2
	L 311.5 202.75 311.6 208.45 318.45 211.9 318.4 206.2
	M 325.25 215.35
	L 325.2 209.7 318.4 206.2 318.45 211.9 325.25 215.35 Z"/>
					</g>
					<g id="Layer2_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 259.7 183.25
	L 244.6 191.9 244.6 213.8 259.7 204.55 259.7 183.25 Z"/>
					</g>
					<path id="windowTwo" fill="#975A42" class="windows" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" d="
	M 223.05 200.3
	Q 222.95 201.45 222.05 202.25 221.25 203.05 220.1 203.05 218.95 203.05 218.15 202.25 217.852734375 201.9103515625 217.7 201.5 217.4923828125 200.96171875 217.55 200.3 217.5833984375 199.916796875 217.7 199.575 217.933203125 198.8833984375 218.5 198.35 218.95 197.95 219.5 197.75 220 197.55 220.55 197.55 221.15 197.55 221.65 197.75 222.05 197.95 222.4 198.35 223.15 199.15 223.05 200.3 Z
	M 238.7 191.05
	Q 238.6552734375 191.56484375 238.45 192 238.1970703125 192.558203125 237.7 193 236.85 193.8 235.7 193.8 234.55 193.8 233.8 193 233.1 192.2 233.2 191.05 233.3 189.9 234.15 189.1 235.05 188.3 236.2 188.3 237.35 188.3 238.05 189.1 238.295703125 189.362109375 238.45 189.65 238.7671875 190.276953125 238.7 191.05 Z"/>
					<path fill="#F2563B" stroke="none" d=" M 351.95 211.2 L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2 Z"/>
					<path id="Layer6_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 198.55 204.75
	L 208.35 211.1 208.45 216.8 208.6 222.5 198.8 216.15 188.95 209.8 188.8 204.1 188.65 198.4 198.55 204.75 198.65 210.45 208.45 216.8
	M 198.8 216.15
	L 198.65 210.45 188.8 204.1"/>
					<path id="Layer5_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 325.25 215.35
	L 325.4 221 318.55 217.55 311.7 214.1 311.6 208.45 311.5 202.75 318.4 206.2 325.2 209.7 325.25 215.35 318.45 211.9 318.55 217.55
	M 318.4 206.2
	L 318.45 211.9 311.6 208.45"/>
				</defs>
				<g id="shadow">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use xlink:href="#bottomShadow"/>
					</g>
				</g>
				<g transform="matrix( 1, 0, 0, 1, 0,0) ">
					<use xlink:href="#sun"/>
				</g>
				<g id="earth">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer52_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer51_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer50_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer48_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer47_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer46_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer45_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer44_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer43_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer41_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer40_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer38_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer37_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer36_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer35_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer34_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowFour"/>
						<use class="element" xlink:href="#Layer32_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer30_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer27_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer26_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer25_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer24_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer22_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer21_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer20_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer19_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer18_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer17_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer16_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer8_0_FILL"/>
						<use class="element" xlink:href="#windowTwo"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer7_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowOne"/>
						<use class="element" xlink:href="#Layer6_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowThree"/>
						<use class="element" xlink:href="#Layer5_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer2_0_FILL"/>
					</g>
				</g>
			</svg>
			<! -- End of SVG file -->
			<! -- Moon/Sun Toggle -->
			<div id="toggleButton" class="day-toggle">
				<div class="sun-icon"></div>
				<label class="switch">
            <input id="toggleCheckbox" type="checkbox">
            <div class="slider"></div>
        </label>
				<div class="cloud-icon"></div>
			</div>
			<! -- Moon/Sun Toggle -->
			<! -- End of Container -->
		</div>
			</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">啷哩咯啷</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">打工是不可能打工的， 这辈子都不可能打工的！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/19/JS内部排序和外部排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="啷哩咯啷">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JS内部排序和外部排序</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-19T21:55:25+08:00">
                2019-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>排序算法的有关文章已经很多了，他也是面试经常(100%)会问到的一个考点。这里主要是我来尝试自己针对网上各式的排序算法进行一份浅显的个人总结，从而温故知新。</p>
<h2 id="内排序与外排序"><a href="#内排序与外排序" class="headerlink" title="内排序与外排序"></a>内排序与外排序</h2><p>由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：<strong>内部排序 </strong> 与 <strong>外部排序 </strong>。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li><p><strong>内部排序</strong>：<font color="#ff0000"><strong>【内存排序】</strong></font>待排序记录存放在计算机随机存储器中（说简单点，就是内存）进行的排序过程。内排序效率用比较次数来衡量。按所用策略不同，内排序又可分为插入排序、选择排序、交换排序、归并排序及基数排序等几大类。<strong>内排序是排序的基础！</strong></p>
</li>
<li><p><strong>外部排序</strong>：<font color="#ff0000"><strong>【大数据小内存】</strong></font>待排序记录的数量很大，以致于内存不能一次容纳全部记录，所以在排序过程中需要对外存进行访问的排序过程。在数据量大的情况下，只能分块排序，但块与块间不能保证有序。外排序用读/写外存的次数来衡量其效率。</p>
</li>
</ul>
<h3 id="衡量效率的方法"><a href="#衡量效率的方法" class="headerlink" title="衡量效率的方法"></a>衡量效率的方法</h3><ul>
<li><strong>内部排序</strong>：比较次数，也就是时间复杂度</li>
<li><strong>外部排序</strong>：IO次数，也就是读写外存的次数</li>
</ul>
<h3 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h3><ul>
<li><strong>内部排序</strong>：插入排序、快速排序、选择排序、归并排序、基数排序等</li>
<li><strong>外部排序</strong>： 外部排序基本上由两个相对独立的阶段组成。首先，按可用内存大小，将外存上含n个记录的文件分成若干长度为l的子文件或段，依次读入内存并利用有效的内部排序方法对他们进行排序，并将排序后得到的有序子文件重新写入外存，通常称这些有序子文件为归并段；然后，对这些归并段进行逐趟归并，使归并段逐渐由小至大，直至得到整个有序文件为止。</li>
</ul>
<blockquote>
<p>读了上面这段文字之后，我们可以知道，第一阶段就是内部排序，这个我们都知道怎么做，那么第二阶段呢？也就是归并的过程是怎么实现的，常用的有两种方法，一，多路平衡归并；二，置换-选择排序。</p>
</blockquote>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="算法优劣评价术语"><a href="#算法优劣评价术语" class="headerlink" title="算法优劣评价术语"></a>算法优劣评价术语</h3><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul>
<li>稳定：如果 <code>a</code> 原本在 <code>b</code> 前面，而 <code>a = b</code>，排序之后 <code>a</code> 仍然在 <code>b</code> 的前面；</li>
<li>不稳定：如果 <code>a</code> 原本在 <code>b</code> 的前面，而 <code>a = b</code>，排序之后 <code>a</code> 可能会出现在 <code>b</code> 的后面；</li>
</ul>
<h4 id="排序方式"><a href="#排序方式" class="headerlink" title="排序方式"></a>排序方式</h4><ul>
<li>内排序：所有排序操作都在内存中完成，占用常数内存，不占用额外内存。</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行，占用额外内存。</li>
</ul>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul>
<li>时间复杂度: 一个算法执行所耗费的时间。</li>
<li>空间复杂度: 运行完一个程序所需内存的大小。</li>
</ul>
<h4 id="排序算法图片总结"><a href="#排序算法图片总结" class="headerlink" title="排序算法图片总结"></a>排序算法图片总结</h4><p>名词解释：<br><code>n</code> : 数据规模<br><code>k</code> : 桶的个数</p>
<table>
<thead>
<tr>
<th style="text-align:left">排序算法</th>
<th style="text-align:center">平均时间复杂度</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">空间复杂度</th>
<th style="text-align:center">排序方式</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">冒泡排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:left">选择排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:left">插入排序</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:left">希尔排序</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n(\log_2^2 n))$</td>
<td style="text-align:center">$O(n(\log_2^2 n))$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:left">归并排序</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">外排序</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:left">快速排序</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(\log n)$</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:left">堆排序</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">内排序</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:left">计数排序</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">$O(k)$</td>
<td style="text-align:center">外排序</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:left">桶排序</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">外排序</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:left">基数排序</td>
<td style="text-align:center">$O(n × k)$</td>
<td style="text-align:center">$O(n × k)$</td>
<td style="text-align:center">$O(n × k)$</td>
<td style="text-align:center">$O(n + k)$</td>
<td style="text-align:center">外排序</td>
<td style="text-align:center">稳定</td>
</tr>
</tbody>
</table>
<h3 id="从分类上来讲"><a href="#从分类上来讲" class="headerlink" title="从分类上来讲:"></a>从分类上来讲:</h3> 
<table>
    <tr>
        <td rowspan="5">排序算法</td>
        <td><b>交换排序</b></td>
        <td>冒泡排序</td>
        <td>快速排序</td>
    </tr>
    <tr>
        <td><b>选择排序</b></td>
        <td>选择排序</td>
        <td>堆排序</td>
    </tr>
    <tr>
        <td><b>插入排序</b></td>
        <td>插入排序</td>
        <td>希尔排序</td>
    </tr>
    <tr>
        <td><b>归并排序</b></td>
        <td>归并排序</td>
    </tr>
    <tr>
        <td><b>分布排序</b></td>
        <td>计数排序</td>
        <td>桶排序</td>
        <td>基数排序</td>
    </tr>
</table>

<p><img src="https://user-images.githubusercontent.com/16753554/68931452-84716180-07cb-11ea-923b-560fc304a6a7.png" alt="image"></p>
<h2 id="冒泡排序（Bubble-Sort）-冒泡排序概念"><a href="#冒泡排序（Bubble-Sort）-冒泡排序概念" class="headerlink" title="冒泡排序（Bubble Sort）[^冒泡排序概念]"></a>冒泡排序（Bubble Sort）[^冒泡排序概念]</h2><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换时，此时该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<p>图解如下:</p>
<p><img src="https://camo.githubusercontent.com/bc20131e2ee7ad70c06e7c71eefc04c3a3cc18a2/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393136313630373438333839" alt></p>
<h3 id="算法描述与实现"><a href="#算法描述与实现" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤 $1~3$，直到排序完成。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; len - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(bubbleSort(arr)); <span class="comment">//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>改进冒泡排序： 我们设置一个标志性变量 <code>pos</code>，用于记录每趟排序中最后一次进行交换的位置。由于 <code>pos</code> 位置之后的元素均已交换到位，故在进行下一趟排序时只要扫描到 <code>pos</code> 位置即可。 这样的优化方式可以在最好情况下把复杂度降到 $O(n)$。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort2 = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        pos = j; <span class="comment">//记录交换的位置</span></span><br><span class="line">        <span class="keyword">let</span> tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    i = pos; <span class="comment">//为下一趟排序作准备</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另外传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值，我们可以考虑利用在每趟排序中进行正向和反向两遍冒泡的方法来一次得到两个最终值(最大者和最小者)，从而继续优化使排序趟数几乎减少一半。（这就是<a href="https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">鸡尾酒排序</a>）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cooktailSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> max = arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(min &lt; max)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = min;j &lt; max;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = arr[j];</span><br><span class="line">        arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">        arr[j+<span class="number">1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    -- max;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = max;j &gt; min;j--)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; arr[j<span class="number">-1</span>])&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = arr[j]</span><br><span class="line">        arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        arr[j<span class="number">-1</span>] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++ min;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>冒泡排序对有 $n$ 个元素的项目平均需要 $O(n^2)$ 次比较次数，它可以原地排序，并且是能简单实现的几种排序算法之一，但是它对于少数元素之外的数列排序是很没有效率的。</p>
<ul>
<li>最佳情况： $T(n) = O(n)$ </li>
<li>最差情况： $T(n) = O(n^2)$ </li>
<li>平均情况： $T(n) = O(n^2)$</li>
</ul>
<h2 id="选择排序（Selection-sort）-选择排序概念"><a href="#选择排序（Selection-sort）-选择排序概念" class="headerlink" title="选择排序（Selection sort）[^选择排序概念]"></a>选择排序（Selection sort）[^选择排序概念]</h2><h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
</blockquote>
<p>图解如下:</p>
<p><img src="https://camo.githubusercontent.com/603dd620708cd52e8d60af45ffbcb1c7986c98ba/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393136313634373534303133" alt></p>
<h3 id="算法描述与实现-1"><a href="#算法描述与实现-1" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<p>$n$ 个记录的直接选择排序可经过 $n - 1$ 趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>初始状态：无序区为 <code>R[1 ... n]</code>，有序区为空；</li>
<li>第 $i$ 趟排序$(i = 1, 2, 3 … n - 1)$开始时，当前有序区和无序区分别为 $R[1 … i - 1]$ 和 $R(i … n)$。该趟排序从当前无序区中选出关键字最小的记录 $R[k]$，将它与无序区的第 1 个记录 $R$ 交换，使 $R[1 … i]$ 和 $R[i + 1 … n]$ 分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；</li>
<li>$n - 1$ 趟结束后，数组有序化。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SelectionSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> minIndex, tmp;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'选择排序耗时'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; len - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[minIndex] &gt; arr[j])&#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp = arr[i];</span><br><span class="line">    arr[i] = arr[minIndex];</span><br><span class="line">    arr[minIndex] = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'选择排序耗时'</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h3><p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 $n$ 个元素的表进行排序总共进行至多 $n - 1$ 次交换。在所有的<em>完全依靠交换</em>去移动元素的排序方法中，选择排序属于非常好的一种。<br>但原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p>
<ul>
<li>最佳情况： $T(n) = O(n^2)$ </li>
<li>最差情况： $T(n) = O(n^2)$</li>
<li>平均情况： $T(n) = O(n^2)$</li>
</ul>
<h2 id="插入排序（Insertion-sort）-插入排序概念"><a href="#插入排序（Insertion-sort）-插入排序概念" class="headerlink" title="插入排序（Insertion sort）[^插入排序概念]"></a>插入排序（Insertion sort）[^插入排序概念]</h2><h3 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前s扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 $O(1)$ 的额外空间的排序），因而在从后向前的扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<p>图解如下:</p>
<p><img src="https://camo.githubusercontent.com/419cbfed21e0d421b56abc402563649d73dcc453/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393136313733383032353937" alt></p>
<h3 id="算法描述与实现-2"><a href="#算法描述与实现-2" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤 $2~5$</li>
</ol>
<p>如果<em>比较操作</em>的代价比<em>交换操作大</em>的话，可以采用<em>二分查找法</em>来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为<a href><em>二分查找插入排序</em></a>。</p>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'插入排序耗时'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>;i &lt; len; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i]; </span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key)&#123;</span><br><span class="line">      arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+<span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'插入排序耗时'</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>改进插入排序：查找插入位置时使用二分查找的方式。</p>
</blockquote>
<p>具体思路如下：</p>
<ol>
<li>在插入第 $i$ 个元素时，对前面的 $0 ~ i-1$ 元素进行折半。</li>
<li>与前面的 $0 ~ i-1$ 个元素中间的元素进行比较，如果小，则对前半再进行折半，否则对后半进行折半。</li>
<li>直到 left &gt; right，再把第 $i$ 个元素前 1 位和目标位置间的所有元素后移，把第 $i$ 个元素放在目标位置上。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> binaryInsertionSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'二分插入排序耗时：'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i], left = <span class="number">0</span>, right = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">      <span class="keyword">let</span> middle = <span class="built_in">parseInt</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (key &lt; arr[middle])&#123;</span><br><span class="line">        right = middle - <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left = middle + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= left; j--)&#123;</span><br><span class="line">      arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[left] = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'二分插入排序耗时：'</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li>最佳情况： $T(n) = O(n)$ </li>
<li>最差情况： $T(n) = O(n^2)$</li>
<li>平均情况： $T(n) = O(n^2)$</li>
</ul>
<h2 id="希尔排序（Shell-sort）-希尔排序概念"><a href="#希尔排序（Shell-sort）-希尔排序概念" class="headerlink" title="希尔排序（Shell sort）[^希尔排序概念]"></a>希尔排序（Shell sort）[^希尔排序概念]</h2><h3 id="算法原理-3"><a href="#算法原理-3" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。它是非稳定排序算法。</p>
</blockquote>
<p>希尔排序基于插入排序的以下两点性质提出了改进方法：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li>
</ol>
<p>它与插入排序的不同之处在于，它会优先比较距离较远的元素。因此希尔排序又叫缩小增量排序。</p>
<p>图解如下:</p>
<p><img src="http://qcyoung.qiniudn.com/qcyoung/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/shellsort.jpeg" alt></p>
<h3 id="算法描述与实现-3"><a href="#算法描述与实现-3" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ol>
<li>选择一个增量序列$t1，t2，…，tk$，其中 $ti &gt; tj(i &gt; j)$，$tk = 1$；</li>
<li>按增量序列个数 $k$，对序列进行 $k$ 趟排序；</li>
<li>每趟排序，根据对应的增量 $ti$，将待排序列分割成若干长度为 $m$ 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shellSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'希尔排序耗时:'</span>);</span><br><span class="line">  <span class="keyword">let</span> len = arr.length,temp,gap = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(gap &lt; len / <span class="number">5</span>) &#123; <span class="comment">// 动态定义间隔序列步长为 5</span></span><br><span class="line">      gap = gap * <span class="number">5</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">5</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      temp = arr[i];</span><br><span class="line">      <span class="keyword">let</span> j;</span><br><span class="line">      <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j + gap] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + gap] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'希尔排序耗时:'</span>);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li>最佳情况： $T_(n) = O_(n\log_2 n)$ </li>
<li>最差情况： $T_(n) = O_(n\log_2 n)$</li>
<li>平均情况： $T_(n) = O_(n\log n)$</li>
</ul>
<h2 id="归并排序（Merge-sort）-归并排序概念"><a href="#归并排序（Merge-sort）-归并排序概念" class="headerlink" title="归并排序（Merge sort）[^归并排序概念]"></a>归并排序（Merge sort）[^归并排序概念]</h2><h3 id="算法原理-4"><a href="#算法原理-4" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
</blockquote>
<p>图解如下：</p>
<p><img src="https://camo.githubusercontent.com/0a7ed1ffe79aba1d560a6ab75823f9e74ad122da/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137303031333236323534" alt></p>
<h3 id="算法描述与实现-4"><a href="#算法描述与实现-4" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<ol>
<li>把长度为 n 的输入序列分成两个长度为 n/2 的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">const</span> mergeSort = <span class="function">(<span class="params">arr</span>) =&gt;</span>&#123;  <span class="comment">//采用自上而下的递归方法</span></span><br><span class="line">    <span class="keyword">let</span> len = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> merge = <span class="function">(<span class="params">left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line">    <span class="keyword">while</span> (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'归并排序耗时'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mergeSort(arr));</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'归并排序耗时'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但它的表现比选择排序要好，因为它始终都是 $O_(n\log n)$ 的时间复杂度。但代价是需要额外的内存空间。</p>
<ul>
<li>最佳情况： $T_(n) = O_(n)$ </li>
<li>最差情况： $T_(n) = O_(n\log n)$</li>
<li>平均情况： $T_(n) = O_(n\log n)$</li>
</ul>
<h2 id="快速排序（Quick-sort）-快速排序概念"><a href="#快速排序（Quick-sort）-快速排序概念" class="headerlink" title="快速排序（Quick sort）[^快速排序概念]"></a>快速排序（Quick sort）[^快速排序概念]</h2><h3 id="算法原理-5"><a href="#算法原理-5" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/253b22840353c9759694d63839fe7565d48f9df6/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137303033303034393036" alt></p>
<h3 id="算法描述与实现-5"><a href="#算法描述与实现-5" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">let</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> left = [];</span><br><span class="line">    <span class="keyword">let</span> right = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">    　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">    　　　　left.push(arr[i]);</span><br><span class="line">    　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    　　　　right.push(arr[i]);</span><br><span class="line">    　　&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'快速排序耗时'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'快速排序耗时'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li>最佳情况： $T_(n) = O_(n\log n)$ </li>
<li>最差情况： $T_(n) = O_(n^2)$</li>
<li>平均情况： $T_(n) = O_(n\log n)$</li>
</ul>
<h2 id="堆排序（Heap-sort）-堆排序概念"><a href="#堆排序（Heap-sort）-堆排序概念" class="headerlink" title="堆排序（Heap sort）[^堆排序概念]"></a>堆排序（Heap sort）[^堆排序概念]</h2><h3 id="算法原理-6"><a href="#算法原理-6" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。它利用堆这种数据结构所设计。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/146edaa09f8c3b584236c33594d33e7be67e14fc/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137313035353032383533" alt></p>
<h3 id="算法描述与实现-6"><a href="#算法描述与实现-6" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<ol>
<li>将初始待排序关键字序列 $(R1,R2…,Rn)$ 构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素 $R[1]$ 与最后一个元素 $R[n]$ 交换，此时得到新的无序区 $(R1,R2,……,Rn-1)$ 和新的有序区 $(Rn)$ ，且满足 $R[1,2…,n-1] &lt;= R[n]$；</li>
<li>由于交换后新的堆顶 $R[1]$ 可能违反堆的性质，因此需要对当前无序区 $(R1,R2,……,Rn-1)$ 调整为新堆，然后再次将 $R[1]$ 与无序区最后一个元素交换，得到新的无序区 $(R1,R2…,Rn-2)$ 和新的有序区 $(Rn-1,Rn)$。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">const</span> heapSort = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'堆排序耗时'</span>);</span><br><span class="line">    <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">let</span> heapSize = array.length, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(heapSize / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(array, i, heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = heapSize - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">        temp = array[<span class="number">0</span>];</span><br><span class="line">        array[<span class="number">0</span>] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">        heapify(array, <span class="number">0</span>, --heapSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'堆排序耗时'</span>);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*方法说明：维护堆的性质</span></span><br><span class="line"><span class="comment">@param  arr 数组</span></span><br><span class="line"><span class="comment">@param  x   数组下标</span></span><br><span class="line"><span class="comment">@param  len 堆大小*/</span></span><br><span class="line"><span class="keyword">const</span> heapify = <span class="function">(<span class="params">arr, x, len</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> l = <span class="number">2</span> * x + <span class="number">1</span>, r = <span class="number">2</span> * x + <span class="number">2</span>, largest = x, temp;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; len &amp;&amp; arr[l] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; len &amp;&amp; arr[r] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (largest != x) &#123;</span><br><span class="line">        temp = arr[x];</span><br><span class="line">        arr[x] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line">        heapify(arr, largest, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr=[<span class="number">91</span>,<span class="number">60</span>,<span class="number">96</span>,<span class="number">13</span>,<span class="number">35</span>,<span class="number">65</span>,<span class="number">46</span>,<span class="number">65</span>,<span class="number">10</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">31</span>,<span class="number">77</span>,<span class="number">81</span>,<span class="number">22</span>];</span><br><span class="line"><span class="built_in">console</span>.log(heapSort(arr));</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h3><ul>
<li>最佳情况： $T_(n) = O_(n\log n)$ </li>
<li>最差情况： $T_(n) = O_(n\log n)$</li>
<li>平均情况： $T_(n) = O_(n\log n)$</li>
</ul>
<h2 id="计数排序（Counting-sort）-计数排序概念"><a href="#计数排序（Counting-sort）-计数排序概念" class="headerlink" title="计数排序（Counting sort）[^计数排序概念]"></a>计数排序（Counting sort）[^计数排序概念]</h2><h3 id="算法原理-7"><a href="#算法原理-7" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/016361c57b8a949ec57103de45a35b34e16332d0/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137313130363431343739" alt></p>
<h3 id="算法描述与实现-7"><a href="#算法描述与实现-7" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<ol>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li>
<li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素 i 放在新数组的第 $C(i)$ 项，每放一个元素就将 $C(i)$ 减去 1。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> countingSort = <span class="function">(<span class="params">array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = array.length,</span><br><span class="line">        result = [],</span><br><span class="line">        C = [],</span><br><span class="line">        min,max;</span><br><span class="line">        min = max = array[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'计数排序耗时'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        min = min &lt;= array[i] ? min : array[i];</span><br><span class="line">        max = max &gt;= array[i] ? max : array[i];</span><br><span class="line">        C[array[i]] = C[array[i]] ? C[array[i]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = min; j &lt; max; j++) &#123;</span><br><span class="line">        C[j + <span class="number">1</span>] = (C[j + <span class="number">1</span>] || <span class="number">0</span>) + (C[j] || <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k = len - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">        result[C[array[k]] - <span class="number">1</span>] = array[k];</span><br><span class="line">        C[array[k]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'计数排序耗时'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(countingSort(arr));</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。<br>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p>
<ul>
<li>最佳情况： $T_(n) = O_(n+k)$ </li>
<li>最差情况： $T_(n) = O_(n+k)$</li>
<li>平均情况： $T_(n) = O_(n+k)$</li>
</ul>
<h2 id="桶排序（Bucket-sort）-桶排序概念"><a href="#桶排序（Bucket-sort）-桶排序概念" class="headerlink" title="桶排序（Bucket sort）[^桶排序概念]"></a>桶排序（Bucket sort）[^桶排序概念]</h2><h3 id="算法原理-8"><a href="#算法原理-8" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）</p>
</blockquote>
<p><img src="http://qcyoung.qiniudn.com/qcyoung/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/bucketsort.jpeg" alt></p>
<h3 id="算法描述与实现-8"><a href="#算法描述与实现-8" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"><span class="keyword">const</span> bucketSort = <span class="function">(<span class="params">array, num</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> len = array.length, buckets = [], result = [], min = max = array[<span class="number">0</span>], regex = <span class="string">'/^[1-9]+[0-9]*$/'</span>, space, n = <span class="number">0</span>;</span><br><span class="line">    num = num || ((num &gt; <span class="number">1</span> &amp;&amp; regex.test(num)) ? num : <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'桶排序耗时'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        min = min &lt;= array[i] ? min : array[i];</span><br><span class="line">        max = max &gt;= array[i] ? max : array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    space = (max - min + <span class="number">1</span>) / num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="keyword">var</span> index = <span class="built_in">Math</span>.floor((array[j] - min) / space);</span><br><span class="line">        <span class="keyword">if</span> (buckets[index]) &#123;   <span class="comment">//  非空桶，插入排序</span></span><br><span class="line">            <span class="keyword">var</span> k = buckets[index].length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; buckets[index][k] &gt; array[j]) &#123;</span><br><span class="line">                buckets[index][k + <span class="number">1</span>] = buckets[index][k];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            buckets[index][k + <span class="number">1</span>] = array[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">//空桶，初始化</span></span><br><span class="line">            buckets[index] = [];</span><br><span class="line">            buckets[index].push(array[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n &lt; num) &#123;</span><br><span class="line">        result = result.concat(buckets[n]);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'桶排序耗时'</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">3</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">36</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">4</span>,<span class="number">19</span>,<span class="number">50</span>,<span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(bucketSort(arr,<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序最好情况下使用线性时间 $O(n)$，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 $O(n)$。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p>
<ul>
<li>最佳情况： $T_(n) = O_(n+k)$ </li>
<li>最差情况： $T_(n) = O_(n+k)$</li>
<li>平均情况： $T_(n) = O_(n^2)$</li>
</ul>
<h2 id="基数排序（Radix-sort）-基数排序概念"><a href="#基数排序（Radix-sort）-基数排序概念" class="headerlink" title="基数排序（Radix sort）[^基数排序概念]"></a>基数排序（Radix sort）[^基数排序概念]</h2><h3 id="算法原理-9"><a href="#算法原理-9" class="headerlink" title="算法原理"></a>算法原理</h3><blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
</blockquote>
<p><img src="https://camo.githubusercontent.com/a46fad9480fac227626a6798ae98ba3a6231ebc8/687474703a2f2f696d672e626c6f672e6373646e2e6e65742f3230313630393137313233333133363539" alt></p>
<h3 id="算法描述与实现-9"><a href="#算法描述与实现-9" class="headerlink" title="算法描述与实现"></a>算法描述与实现</h3><ul>
<li>具体算法描述如下：</li>
</ul>
<ol>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr 为原始数组，从最低位开始取每个位组成 radix 数组；</li>
<li>对 radix 进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ol>
<ul>
<li>代码实现如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">const</span> radixSort = <span class="function">(<span class="params">arr, maxDigit</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> mod = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> dev = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> counter = [];</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'基数排序耗时'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</span><br><span class="line">            <span class="keyword">if</span>(counter[bucket]== <span class="literal">null</span>) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">            <span class="keyword">var</span> value = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(counter[j]!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'基数排序耗时'</span>);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>];</span><br><span class="line"><span class="built_in">console</span>.log(radixSort(arr,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h3 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h3><p>基数排序有两种方法：</p>
<p>MSD 从高位开始进行排序<br>LSD 从低位开始进行排序</p>
<ul>
<li>最佳情况： $T_(n) = O_(n^2)$ </li>
<li>最差情况： $T_(n) = O_(n^2)$</li>
<li>平均情况： $T_(n) = O_(n^2)$</li>
</ul>
<p>基数排序 vs 计数排序 vs 桶排序</p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<p>基数排序：根据键值的每位数字来分配桶<br>计数排序：每个桶只存储单一键值<br>桶排序：每个桶存储一定范围的数值</p>
<p><strong>以上代码可访问 <a href="https://github.com/yangzj1992/Use-Javascript-Solve-Logic-Questions/tree/master/data-structure/Sort" target="_blank" rel="noopener">GitHub 具体查看</a></strong></p>
<h2 id="JS-原生函数中的排序"><a href="#JS-原生函数中的排序" class="headerlink" title="JS 原生函数中的排序"></a>JS 原生函数中的排序</h2><p>说到前端排序，自然首先会想到 JavaScript 的原生接口 <code>Array.prototype.sort</code></p>
<p>这个接口自 <code>ECMAScript 1st Edition</code> 起就被设计存在。而在规范中关于它的描述是这样的：[^Array.prototype.sort(compareFn)]</p>
<p><code>Array.prototype.sort(compareFn)</code></p>
<blockquote>
<p>The elements of this array are sorted. The sort is not necessarily stable (that is, elements that compare equal do not necessarily remain in their original order). If comparefn is not undefined, it should be a function that accepts two arguments x and y and returns a negative value if x &lt; y, zero if x = y, or a positive value if x &gt; y. </p>
</blockquote>
<p>显然，规范里并没有限定 <code>sort</code> 内部需要用什么排序算法。在这样的背景下，前端排序这件事完全取决于各家浏览器内核的具体实现。</p>
<h3 id="Chrome-的实现"><a href="#Chrome-的实现" class="headerlink" title="Chrome 的实现"></a>Chrome 的实现</h3><p>Chrome 的 JavaScript 引擎是 v8。由于它是开源的，所以可以直接看<a href="https://github.com/v8/v8" target="_blank" rel="noopener">源代码</a>。</p>
<p>整个 <a href="https://github.com/v8/v8/blob/master/src/js/array.js" target="_blank" rel="noopener">array.js</a> 都是用 JavaScript 语言实现的。排序方法部分很明显比通常看到的快速排序要复杂得多，但显然核心算法还是快速排序的思想。算法复杂的原因在于 v8 出于性能考虑进行了很多优化。(后续会展开说)</p>
<h3 id="Firefox中的实现"><a href="#Firefox中的实现" class="headerlink" title="Firefox中的实现"></a>Firefox中的实现</h3><p>暂时无法确定 Firefox 的 JavaScript 引擎即将使用的数组排序算法会是什么。</p>
<p>按照现有的信息，SpiderMoney 内部实现了归并排序。（这里不多做叙述）</p>
<h3 id="Microsoft-Edge中的实现"><a href="#Microsoft-Edge中的实现" class="headerlink" title="Microsoft Edge中的实现"></a>Microsoft Edge中的实现</h3><p>Microsoft Edge 的 JavaScript 引擎 Chakra 的核心部分代码已经于 2016 年初在 Github 开源。</p>
<p>通过<a href="https://github.com/Microsoft/ChakraCore/blob/master/lib/Runtime/Library/JavascriptArray.cpp" target="_blank" rel="noopener">源代码</a>可以发现，Chakra 的数组排序算法也主要是以快速排序为主。并针对其他具体特殊情况进行具体优化。</p>
<h3 id="排序的差异"><a href="#排序的差异" class="headerlink" title="排序的差异"></a>排序的差异</h3><p>如上所述，快速排序是一种不稳定的排序算法，而归并排序是一种稳定的排序算法。由于不同引擎在算法选择上可能存在差异，导致前端如果依赖 <code>Array.prototype.sort</code> 接口实现的 JavaScript 代码，在浏览器中实际执行的排序效果是不一致的。</p>
<p>而排序稳定性的差异其实也只是在特定的场景才会体现出问题；在很多情况下，不稳定的排序也并不会造成什么影响。所以假如实际项目开发中，对于数组的排序没有稳定性的需求，那么看到这里就可以了。</p>
<p>但是若项目要求排序必须是稳定的，那么这些差异的存在将无法满足需求。我们需要为此进行一些额外的工作。</p>
<p>举个例子：</p>
<p>某市的机动车牌照拍卖系统，最终中标的规则为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 按价格进行倒排序；</span><br><span class="line">2. 相同价格则按照竞标顺位（即价格提交时间）进行正排序。</span><br></pre></td></tr></table></figure>
<p>排序若是在前端进行，那么采用快速排序的浏览器中显示的中标者很可能是不符合预期的。</p>
<p>此外例如：<br><a href="http://www.cnblogs.com/cchust/p/5304594.html" target="_blank" rel="noopener">MySQL 5.6 的 <code>limit M,N</code> 语句实现</a><br>等情况都是不稳定排序的特征。</p>
<h3 id="背后的原因"><a href="#背后的原因" class="headerlink" title="背后的原因"></a>背后的原因</h3><h4 id="Chrome为什么采用快速排序"><a href="#Chrome为什么采用快速排序" class="headerlink" title="Chrome为什么采用快速排序"></a>Chrome为什么采用快速排序</h4><p>其实这个情况从一开始便存在。</p>
<p>Chrome测试版于<a href="https://zh.wikipedia.org/wiki/Google_Chrome#.E7.99.BC.E5.B8.83" target="_blank" rel="noopener">2008年9月2日发布</a> (这里附上当时随版本发布的漫画，还是很有意思的<a href="http://blogoscoped.com/google-chrome/" target="_blank" rel="noopener">Google on Google Chrome - comic book</a>)，然而发布后不久，就有开发者向 Chromium 开发组提交 <a href="https://bugs.chromium.org/p/v8/issues/detail?id=90" target="_blank" rel="noopener">#90 Bug V8 doesn’t stable sort</a> 反馈 v8 的数组排序实现不是稳定排序的。</p>
<p>这个 Bug ISSUE 讨论的时间跨度很大。时至今日，仍然有开发者对 v8 的数组排序的实现提出评论。</p>
<p>同时我们还注意到，该 ISSUE 曾经已被关闭。但是于 2013 年 6 月被开发组成员重新打开，作为 ECMAScript Next 规范讨论的参考。</p>
<p>而 <a href="https://mail.mozilla.org/pipermail/es-discuss/2013-June/031276.html" target="_blank" rel="noopener">es-discuss</a> 的最后结论是这样的</p>
<blockquote>
<p>It does not change. Stable is a subset of unstable. And vice versa, every unstable algorithm returns a stable result for some inputs. Mark’s point is that requiring “always unstable” has no meaning, no matter what language you chose.</p>
</blockquote>
<p>这也正如本文前段所引用的已定稿 <code>ECMAScript 2015</code> 规范中的描述一样。</p>
<h4 id="时代特点"><a href="#时代特点" class="headerlink" title="时代特点"></a>时代特点</h4><p>IMHO，Chrome 发布之初即被报告出这个问题可能是有其特殊的时代特点。</p>
<p>上文已经说到，Chrome 第一版是 2008 年 9 月发布的。根据 <a href="http://gs.statcounter.com/#browser-ww-monthly-200809-200809-bar" target="_blank" rel="noopener">statcounter</a> 的统计数据，那个时期市场占有率最高的两款浏览器分别是 IE(那时候只有 IE6 和 IE7) 和 Firefox，市场占有率分别达到了 67.16% 和 25.77%。也就是说，两个浏览器加起来的市场占有率超过了 90%。</p>
<p>而根据另一份<a href="http://ofb.net/~sethml/is-sort-stable.html" target="_blank" rel="noopener">浏览器排序算法稳定性的统计</a>数据显示，这两款超过了 90% 市场占有率的浏览器都采用了稳定的数组排序。所以 Chrome 发布之初被开发者质疑也是合情合理的。</p>
<p>我们从 ISSUE 讨论的过程中，可以大概理解开发组成员对于引擎实现采用快速排序的一些考量。他们认为引擎必须遵守 ECMAScript 规范。由于规范不要求稳定排序的描述，故他们认为 v8 的实现也是完全符合规范的。</p>
<h4 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h4><p>另外，他们认为 v8 设计的一个重要考量在于引擎的性能。</p>
<p><strong>快速排序</strong>相比较于<strong>归并排序</strong>，在整体性能上表现更好：</p>
<ul>
<li>更高的计算效率。快速排序在实际计算机执行环境中比同等时间复杂度的其他排序算法更快（不命中最差组合的情况下）</li>
<li>更低的空间成本。前者仅有 $O(logn)$ 的空间复杂度，相比较后者 $O(n)$ 的空间复杂度在运行时的内存消耗更少</li>
</ul>
<h4 id="v8-在数组排序算法中的性能优化"><a href="#v8-在数组排序算法中的性能优化" class="headerlink" title="v8 在数组排序算法中的性能优化"></a>v8 在数组排序算法中的性能优化</h4><p>既然说 v8 非常看中引擎的性能，那么在数组排序中它做了哪些事呢？</p>
<p>通过阅读源代码，还是粗浅地学习了一些皮毛。</p>
<ul>
<li>混合插入排序<br>快速排序是分治的思想，将大数组分解，逐层往下递归。但是若递归深度太大，为了维持递归，调用栈的内存资源消耗也会很大。优化不好甚至可能造成栈溢出。</li>
</ul>
<p>目前 v8 的实现是设定一个阈值，对最下层的 10 个及以下长度的小数组使用插入排序。</p>
<p>根据代码注释以及 Wikipedia 中的描述，虽然插入排序的平均时间复杂度为 $O(n^2)$ 差于快速排序的 $O(nlogn)$。但是在运行环境，小数组使用插入排序的效率反而比快速排序会更高，这里不再展开。</p>
<p><a href="https://github.com/v8/v8/blob/master/src/js/array.js" target="_blank" rel="noopener">v8 代码示例</a>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> QuickSort = <span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">a, from, to</span>) </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// Insertion sort is faster for short arrays.</span></span><br><span class="line">        <span class="keyword">if</span> (to - <span class="keyword">from</span> &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            InsertionSort(a, <span class="keyword">from</span>, to);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>三数取中</li>
</ul>
<p>正如已知的，快速排序的阿克琉斯之踵在于，最差数组组合情况下会算法退化。</p>
<p>快速排序的算法核心在于选择一个基准(<strong>pivot</strong>)，将经过比较交换的数组按基准分解为两个数区进行后续递归。试想如果对一个已经有序的数组，每次选择基准元素时总是选择第一个或者最后一个元素，那么每次都会有一个数区是空的，递归的层数将达到 <strong>n</strong>，最后导致算法的时间复杂度退化为 $O(n^2)$。因此 pivot 的选择非常重要。</p>
<p>v8采用的是<strong>三数取中(median-of-three)</strong>的优化：除了头尾两个元素再额外选择一个元素参与基准元素的竞争。</p>
<p>第三个元素的选取策略大致为：</p>
<ol>
<li>当数组长度小于等于 <strong>1000</strong> 时，选择折半位置的元素作为目标元素。</li>
<li>当数组长度超过 <strong>1000</strong> 时，每隔 <strong>200-215</strong> 个(<em>非固定，跟着数组长度而变化</em>)左右选择一个元素来先确定一批候选元素。接着在这批候选元素中进行一次排序，将所得的中位值作为目标元素</li>
</ol>
<p>最后取三个元素的中位值作为 <strong>pivot</strong>。</p>
<p>v8 代码示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> GetThirdIndex = <span class="function"><span class="keyword">function</span>(<span class="params">a, from, to</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t_array = <span class="keyword">new</span> InternalArray();</span><br><span class="line">    <span class="comment">// Use both 'from' and 'to' to determine the pivot candidates.</span></span><br><span class="line">    <span class="keyword">var</span> increment = <span class="number">200</span> + ((to - <span class="keyword">from</span>) &amp; <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">from</span> += <span class="number">1</span>;</span><br><span class="line">    to -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">from</span>; i &lt; to; i += increment) &#123;</span><br><span class="line">        t_array[j] = [i, a[i]];</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    t_array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comparefn(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> third_index = t_array[t_array.length &gt;&gt; <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> third_index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> QuickSort = <span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">a, from, to</span>) </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (to - <span class="keyword">from</span> &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">            third_index = GetThirdIndex(a, <span class="keyword">from</span>, to);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            third_index = <span class="keyword">from</span> + ((to - <span class="keyword">from</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>原地排序</li>
</ul>
<p>目前，大多数快速排序算法中大部分的代码实现如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> quickSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) &#123; <span class="keyword">return</span> arr; &#125;</span><br><span class="line">　　<span class="keyword">var</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">　　<span class="keyword">var</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">　　<span class="keyword">var</span> left = [];</span><br><span class="line">　　<span class="keyword">var</span> right = [];</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">　　　　<span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">　　　　　　left.push(arr[i]);</span><br><span class="line">　　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　　　right.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上代码存在一个问题在于：利用 left 和 right 两个数区存储递归的子数组，因此它需要 $O(n)$ 的额外存储空间。这与理论上的平均空间复杂度 $O(logn)$ 相比差距较大。</p>
<p>额外的空间开销，同样会影响实际运行时的整体速度。（这也是快速排序在实际运行时的表现可以超过同等时间复杂度级别的其他排序算法的其中一个原因。）所以一般来说，性能较好的快速排序会采用原地(in-place)排序的方式。</p>
<p>v8 源代码中的实现是对原数组进行元素交换。</p>
<h4 id="Firefox-为什么采用归并排序"><a href="#Firefox-为什么采用归并排序" class="headerlink" title="Firefox 为什么采用归并排序"></a>Firefox 为什么采用归并排序</h4><p>它的背后也是有故事的。</p>
<p>Firefox 其实在一开始发布的时候对于数组排序的实现并不是采用稳定的排序算法，这块有据可考。</p>
<p>Firefox(Firebird) 最初版本实现的数组排序算法是堆排序，这也是一种不稳定的排序算法。因此，后来有人对此提交了一个 <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=224128" target="_blank" rel="noopener">Bug</a>。</p>
<p>Mozilla开发组内部针对这个问题进行了一系列<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=224128#c2" target="_blank" rel="noopener">讨论</a>。</p>
<p>从讨论的过程我们能够得出几点</p>
<ul>
<li>同时期 Mozilla 的竞争对手是 <strong>IE6</strong>，从上文的统计数据可知 IE6 是稳定排序的</li>
<li>JavaScript 之父 Brendan Eich 觉得 <strong>Stability is good</strong></li>
<li>Firefox在采用<strong>堆排序</strong>之前采用的是<strong>快速排序</strong></li>
</ul>
<p>基于开发组成员倾向于实现稳定的排序算法为主要前提，<strong>Firefox3</strong> 将<strong>归并排序</strong>作为了数组排序的新实现。</p>
<h3 id="解决排序稳定性的差异"><a href="#解决排序稳定性的差异" class="headerlink" title="解决排序稳定性的差异"></a>解决排序稳定性的差异</h3><p>以上说了这么多，主要是为了讲述各个浏览器对于排序实现的差异，以及解释为什么存在这些差异的一些比较表层的原因。</p>
<p>但是读到这里，读者可能还是会有疑问：如果我的项目就是需要依赖稳定排序，那该怎么办呢？</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>其实解决这个问题的思路比较简单。</p>
<p>浏览器出于不同考虑选择不同排序算法。可能某些偏向于追求极致的性能，某些偏向于提供良好的开发体验，但是有规律可循。</p>
<p>从目前已知的情况来看，所有主流浏览器（包括IE6，7，8）对于数组排序算法的实现基本可以枚举：</p>
<ul>
<li>归并排序 / Timsort</li>
<li>快速排序</li>
</ul>
<p>所以，我们将快速排序经过定制改造，变成稳定排序的是不是就可以了？</p>
<p>一般来说，针对对象数组使用不稳定排序会影响结果。而其他类型数组本身使用稳定排序或不稳定排序的结果是相等的。因此方案大致如下：</p>
<ul>
<li>将待排序数组进行预处理，为每个待排序的对象增加自然序属性，不与对象的其他属性冲突即可。</li>
<li>自定义排序比较方法 compareFn，总是将自然序作为前置判断相等时的第二判断维度。</li>
</ul>
<p>面对归并排序这类实现时由于算法本身就是稳定的，额外增加的自然序比较并不会改变排序结果，所以方案兼容性比较好。</p>
<p>但是涉及修改待排序数组，而且需要开辟额外空间用于存储自然序属性，可想而知v8这类引擎应该不会采用类似手段。不过作为开发者自行定制的排序方案是可行的。</p>
<h4 id="方案代码示例"><a href="#方案代码示例" class="headerlink" title="方案代码示例"></a>方案代码示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> INDEX = <span class="built_in">Symbol</span>(<span class="string">'index'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComparer</span>(<span class="params">compare</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> result = compare(left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result === <span class="number">0</span> ? left[INDEX] - right[INDEX] : result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array, compare</span>) </span>&#123;</span><br><span class="line">    array = array.map(</span><br><span class="line">        (item, index) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">'object'</span>) &#123;</span><br><span class="line">                item[INDEX] = index;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> array.sort(getComparer(compare));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上只是一个简单的满足稳定排序的算法改造示例。</p>
<p>之所以说简单，是因为实际生产环境中作为数组输入的数据结构冗杂，需要根据实际情况判断是否需要进行更多样的排序前类型检测。</p>
<h2 id="选择排序算法的参考方法："><a href="#选择排序算法的参考方法：" class="headerlink" title="选择排序算法的参考方法："></a>选择排序算法的参考方法：</h2><p>影响排序的因素有很多，平均时间复杂度低的算法并不一定就是最优的。相反，有时平均时间复杂度高的算法可能更适合某些特殊情况。同时，选择算法时还得考虑它的可读性，以利于软件的维护。一般而言，需要考虑的因素有以下四点：</p>
<ol>
<li><p>待排序的记录数目 n 的大小；</p>
</li>
<li><p>记录本身数据量的大小，也就是记录中除关键字外的其他信息量的大小；</p>
</li>
<li><p>关键字的结构及其分布情况；</p>
</li>
<li><p>对排序稳定性的要求。</p>
</li>
</ol>
<p>设待排序元素的个数为 n。选择的大致方案如下：</p>
<ol>
<li>当 n 较大，则应采用时间复杂度为 $O(nlogn)$ 的排序方法：快速排序、堆排序或归并排序。</li>
</ol>
<ul>
<li>快速排序：是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；</li>
<li>堆排序：如果内存空间允许且要求稳定性的，</li>
<li>归并排序：它有一定数量的数据移动，所以我们可能过与插入排序组合，先获得一定长度的序列，然后再合并，在效率上将有所提高。</li>
</ul>
<ol start="2">
<li><p>当 n 较大，内存空间允许，且要求稳定性则选择归并排序</p>
</li>
<li><p>当 n 较小，可采用直接插入或直接选择排序。</p>
</li>
</ol>
<p>直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。</p>
<p>直接选择排序：元素分布有序，如果不要求稳定性，选择直接选择排序</p>
<ol start="4">
<li><p>一般不使用或不直接使用传统的冒泡排序。</p>
</li>
<li><p>基数排序：<br>它是一种稳定的排序算法，但有一定的局限性，最好满足：</p>
</li>
</ol>
<ul>
<li>关键字可分解。</li>
<li>记录的关键字位数较少，如果密集更好</li>
<li><p>如果是数字时，最好是无符号的，否则将增加相应的映射复杂度，可先将其正负分开排序。</p>
<h2 id="三路快排"><a href="#三路快排" class="headerlink" title="三路快排"></a>三路快排</h2></li>
</ul>
<p>快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一不部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。<br>整个排序过程只需要三步：</p>
<ul>
<li>在数据集之中，选择一个元素作为”基准”（pivot）。</li>
<li>所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。</li>
<li>对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</li>
</ul>
<blockquote>
<p>引自wikipedia 快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序n个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n)算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
</blockquote>
<p>步骤</p>
<ul>
<li>找到该数组的基准点(中间数)，并创建两个空数组left和right；<br>遍历数组，拿出数组中的每个数和基准点进行比较，如果比基准点小就放到left数组中，如果比基准点- </li>
<li>大就放到right数组中；</li>
<li>对数组left和right进行递归调用。</li>
</ul>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr.length&lt;=<span class="number">1</span>) &#123;<span class="keyword">return</span> arr;&#125;</span><br><span class="line">	<span class="keyword">var</span> left = [],</span><br><span class="line">		right = [],</span><br><span class="line">		baseDot =<span class="built_in">Math</span>.round(arr.length/<span class="number">2</span>),</span><br><span class="line">		base =arr.splice(baseDot, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt;arr.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i] &lt; base) &#123;</span><br><span class="line">			left.push(arr[i])</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			right.push(arr[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> quickSort(left).concat([base], quickSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 实现一个quickSort的封装，并且定义left和right，找到数组的基准点baseDot和对应的基数base，然后遍历数组的每一项和base进行对比，最后递归调用，给出一个跳出条件if (arr.length &lt;= 1) {return arr;}</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> length =array.length;</span><br><span class="line">		left =<span class="keyword">typeof</span> left ===<span class="string">'number'</span>? left :<span class="number">0</span>,</span><br><span class="line">		right =<span class="keyword">typeof</span> right ===<span class="string">'number'</span>? right : length<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">var</span> index = left <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[right]) &#123;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">var</span> temp = array[index];</span><br><span class="line">                array[index] = array[i];</span><br><span class="line">                array[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(array, left, index <span class="number">-1</span>);</span><br><span class="line">        quickSort(array, index +<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序的基本思想就是分治法</p>
<blockquote>
<p>引自wikipedia 在计算机科学中，分治法是建基于多项分支递归的一种很重要的算法范式。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p>
</blockquote>
<h3 id="快速排序的改进方法：三路快排"><a href="#快速排序的改进方法：三路快排" class="headerlink" title="快速排序的改进方法：三路快排"></a>快速排序的改进方法：三路快排</h3><blockquote>
<p>定义</p>
</blockquote>
<p>三路快速排序是快速排序的的一个优化版本， 将数组分成三段， 即小于基准元素、 等于 基准元素和大于基准元素， 这样可以比较高效的处理数组中存在相同元素的情况,其它特征与快速排序基本相同。</p>
<p>我这里简单概括一下思路，有兴趣的同学可到上面的链接上阅读：快速排序及优化(Java实现)</p>
<ul>
<li>随机选取基准值base(支点随机选取),参考快速排序算法的优化思路总结</li>
<li>配合着使用插入排序(当问题规模较小时，近乎有序时，插入排序表现的很好)</li>
<li>当大量数据，<strong>且重复数多时，用三路快排</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.time(<span class="string">"test0"</span>)</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">qSort</span>(<span class="params">arr</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(arr.length == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">return</span> [];</span></span><br><span class="line">				&#125;</span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> left = [];</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> right = [];</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> pivot = arr[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">				<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 注意这里的起始值，因为有一个作为flag了</span></span></span><br><span class="line"><span class="javascript">					<span class="keyword">if</span>(arr[i] &lt; pivot) &#123;</span></span><br><span class="line">						left.push(arr[i]);</span><br><span class="line"><span class="javascript">					&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">						right.push(arr[i]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="javascript">				<span class="keyword">return</span> [...qSort(left), pivot, ...qSort(right)];</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(qSort([<span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>]));</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.timeEnd(<span class="string">"test0"</span>)</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.time(<span class="string">"test1"</span>)</span></span><br><span class="line"><span class="javascript">			<span class="function"><span class="keyword">function</span> <span class="title">qSort3</span>(<span class="params">arr</span>) </span>&#123;       <span class="comment">//三路快排</span></span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(arr.length == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">return</span> [];</span></span><br><span class="line">				&#125;</span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> left = [];</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> center = [];</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> right = [];</span></span><br><span class="line"><span class="javascript">				<span class="keyword">var</span> pivot = arr[<span class="number">0</span>];    <span class="comment">//偷懒，直接取第一个,实际取值情况 参考[快速排序算法的优化思路总结]</span></span></span><br><span class="line"><span class="javascript">				<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;      </span></span><br><span class="line"><span class="javascript">					<span class="keyword">if</span>(arr[i] &lt; pivot) &#123;</span></span><br><span class="line">						left.push(arr[i]);</span><br><span class="line"><span class="javascript">					&#125; <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == pivot) &#123;</span></span><br><span class="line">						center.push(arr[i]);</span><br><span class="line"><span class="javascript">					&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">						right.push(arr[i]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"><span class="javascript">				<span class="keyword">return</span> [...qSort3(left), ...center, ...qSort3(right)];</span></span><br><span class="line">			&#125;</span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.log(qSort3([<span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span>]))</span></span><br><span class="line"><span class="javascript">			<span class="built_in">console</span>.timeEnd(<span class="string">"test1"</span>)</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/16753554/68932049-c5b64100-07cc-11ea-975f-799088e2f06c.png" alt="image"><br><img src="https://user-images.githubusercontent.com/16753554/68932066-ccdd4f00-07cc-11ea-848d-3b97d9afe91d.png" alt="image"><br><img src="https://user-images.githubusercontent.com/16753554/68932078-cfd83f80-07cc-11ea-83a3-9d287fd65e9c.png" alt="image"></p>
<p>可以看到对有重复数据的数据优化还是很可观的。。</p>
<h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><p>给你一个包含20亿个int类型整数的文件，计算机的内存只有2GB，怎么给它们排序？一个int数占4个字节，20个亿需要80亿字节，大概占用8GB的内存，而计算机只有2GB的内存，数据都装不下！可以把8GB分割成4个2GB的数据来排，然后在把他们拼凑回去。如下图：<br><img src="https://user-images.githubusercontent.com/16753554/68933115-f39c8500-07ce-11ea-9db1-57df9c682dcb.png" alt="image"><br>排序的时候可以选择快速排序或归并排序等算法。为了方便，我们把排序好的2G有序数据称为有序子串。接着把两个小的有序子串合并成一个大的有序子串。<br><img src="https://user-images.githubusercontent.com/16753554/68933141-feefb080-07ce-11ea-8531-e9aa9c76f382.png" alt="image"><br> 注意:读取的时候是每次读取一个int数，通过比较之后再输出。</p>
<p>按照这个方法来回合并，总共经过三次合并之后就可以得到8G的有序子串。</p>
<h3 id="外排思想"><a href="#外排思想" class="headerlink" title="外排思想"></a>外排思想</h3><p>我们假设需要排序的int数有12个，内存一次只能装下3个int数。<br><img src="https://user-images.githubusercontent.com/16753554/68933174-10d15380-07cf-11ea-98be-7309e3864bd4.png" alt="image"><br>接下来把12个数据分成4份，然后排序成有序子串：<br><img src="https://user-images.githubusercontent.com/16753554/68933186-1cbd1580-07cf-11ea-9ded-783c20850e5b.png" alt="image"><br> 然后把子串进行两两合并：<br><img src="https://user-images.githubusercontent.com/16753554/68933245-3a8a7a80-07cf-11ea-8618-9defab974659.png" alt="image"><br>输出哪个元素就在那个元素所在的有序子串再次读入一个元素：<br><img src="https://user-images.githubusercontent.com/16753554/68933276-46763c80-07cf-11ea-997a-0db3dc4005f3.png" alt="image"><br>继续<br><img src="https://user-images.githubusercontent.com/16753554/68933304-51c96800-07cf-11ea-8541-a39c9d5325b0.png" alt="image"><br>重复直到合并成一个包含6个int有序子串：<br><img src="https://user-images.githubusercontent.com/16753554/68933318-5c83fd00-07cf-11ea-8520-7890401c4842.png" alt="image"><br>再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串：<br><img src="https://user-images.githubusercontent.com/16753554/68933340-686fbf00-07cf-11ea-8721-385ea949cf46.png" alt="image"></p>
<h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><p>因为硬盘的读写速度比内存要慢的多，按照以上这种方法，每个数据都从硬盘读了三次，写了三次，要花很多时间。</p>
<p>解释下：例如对于数据2，我们把无序的12个数据分成有序的4个子串需要读写各一次，把2份3个有序子串合并成6个有序子串读写各一次；把2份6个有序子串合并从12个有序子串读写各一次，一共需要读写各3次。</p>
<p>在进行有序子串合并的时候，不采取两两合并的方法，而是可以3个子串，或4个子串一起来合并。</p>
<h4 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h4><p>为了方便讲解，我们假设内存一共可以装4个int型数据。</p>
<p> 刚才我们是采取两两合并的方式，现在我们可以采取4个有序子串一起合并的方式，这样的话，每个数据从硬盘读写的次数各需要2次就可以了。如图：<br><img src="https://user-images.githubusercontent.com/16753554/68933550-d87e4500-07cf-11ea-92ce-9028db5fb1da.png" alt="image"><br>4个有序子串的合并，叫4路归并。如果是n个有序子串的合并，就把它称为n路归并。n并非越大越好。</p>
<h4 id="置换选择"><a href="#置换选择" class="headerlink" title="置换选择"></a>置换选择</h4><p>n不是越大越好，那么我们可以想办法减少有序子串的总个数。这样，也能减少数据从硬盘读写的次数。</p>
<p>以前面的12个无序数据为例：</p>
<p><img src="https://user-images.githubusercontent.com/16753554/68933660-167b6900-07d0-11ea-9895-0f07f005df2f.png" alt="image"></p>
<p>例如我们可以从12个数据读取3个存到内存中，然后从内存中选出最小的那个数放进子串p1里；之后再从剩余的9个数据读取一个放到内存中，然后再从内存中选出一个数放进子串p1里，这个数必须满足比p1中的其他数大，且在内存中尽量小。这样一直重复，直到内存中的数都比p1中的数小，这时p1子串存放结束，继续来p2子串的存放，例如（这时假设内存只能存放3个int型数据）：</p>
<p>读入3个到内存中，且选出一个最小的到子串p1：</p>
<p><img src="https://user-images.githubusercontent.com/16753554/68933714-3874eb80-07d0-11ea-8019-2d6a15e1d6be.png" alt="image"></p>
<p>从内存中再次读取一个元素86：</p>
<p><img src="https://user-images.githubusercontent.com/16753554/68933725-40cd2680-07d0-11ea-9485-0815778d69e4.png" alt="image"><br>从内存中再次读取一个元素3：</p>
<p><img src="https://user-images.githubusercontent.com/16753554/68933735-475b9e00-07d0-11ea-8fe7-a8125412f1bc.png" alt="image"><br>从内存中再次读取一个元素24：</p>
<p><img src="https://user-images.githubusercontent.com/16753554/68933744-4dea1580-07d0-11ea-93ba-a58df82b0fee.png" alt="image"><br>从内存中再次读取一个元素8：<br><img src="https://user-images.githubusercontent.com/16753554/68933756-55112380-07d0-11ea-9c3e-60455481dfe7.png" alt="image"></p>
<p>这个时候已经没有符合要求的数了，且内存已满，进而用p2子串来存放，以此类推。</p>
<p>通过这种方法，p1子串存放了4个数据，而原来的那种方法p1子串只能存放3个数据。</p>
<p>我们要如何从内存中选出这个目的数呢？难道每次都把内存中的数据进行排序，然后再逐个比较选择吗？其实我们可以构建一个最小堆来帮助我们选择目的数。具体如下：</p>
<p>从12个数据中读取3个数据，构建一个最小堆，然后从堆顶选择一个数写入到p1中。之后再从剩余的9个数中读取一个数，如果这个数比刚才那个写入到p1中的数大，则把这个数插入到最小堆中，重新调整最小堆结构，然后在堆顶选一个数写入到p1中。否则，把这个数暂放在一边，暂时不处理。之后一样需要调整堆结构，从堆顶选择一个数写入到p1中。</p>
<p>这里说明一下，那个被放在一边的数是不能在放入p1中的了，因为它一定比p1中的数都要小，所以它会放在下一个子串中。如下图所示：</p>
<p>从12个数据中读取3个数据：</p>
<p><img src="https://user-images.githubusercontent.com/16753554/68933782-60fce580-07d0-11ea-8806-9707c31219c4.png" alt="image"></p>
<p>构建最小堆，且选出目标数：</p>
<p><img src="https://user-images.githubusercontent.com/16753554/68933806-69552080-07d0-11ea-8c4a-4e7fddec8f7e.png" alt="image"><br>读入下一个数86：</p>
<p><img src="https://user-images.githubusercontent.com/16753554/68933823-707c2e80-07d0-11ea-9043-4e59dd22a667.png" alt="image"><br>读入下一个数3，比70小，暂放一边，不加入堆结构中：<br><img src="https://user-images.githubusercontent.com/16753554/68933842-7a9e2d00-07d0-11ea-9099-e44883ec25ca.png" alt="image"><br>读入下一个数据24，比81小，不加入堆结构：<br><img src="https://user-images.githubusercontent.com/16753554/68933858-825dd180-07d0-11ea-81a3-441fc997b21b.png" alt="image"><br> 读入下一个数据8，比86小，不加入堆结构。此时p1已经完成了，把那些刚才暂放一边的数重新构成一个堆，继续p2的存放：<br><img src="https://user-images.githubusercontent.com/16753554/68933879-8b4ea300-07d0-11ea-9086-4c709660a35d.png" alt="image"><br> 以此类推…最后生成的p2如下：<br><img src="https://user-images.githubusercontent.com/16753554/68933902-94d80b00-07d0-11ea-9a12-0a2bbb3dadad.png" alt="image"><br>这样子的话，最后只生成了2个有序子串，我们把这种方法称之为置换选择。按照这种方法，最好的情况下，所有数据只生成一个有序子串；最坏的情况下，和原来没采取置换选择算法一样，还是4个子串，那平均性能如何呢？</p>
<p>结论：如果内存可以容纳n个元素的话，那么平均每个子串的长度为2m，也就是说，使用置换选择算法我们可以减少一半的子串数。</p>
<p>这种方法适合要排序的数据太多，以至于内存一次性装载不下。只能通过把数据分几次的方式来排序，把这种方法称为外部排序。</p>
<h4 id="以上对外部排序如何使用归并算法进行排序进行了简要总结，提高外部排序需要考虑以下问题："><a href="#以上对外部排序如何使用归并算法进行排序进行了简要总结，提高外部排序需要考虑以下问题：" class="headerlink" title="以上对外部排序如何使用归并算法进行排序进行了简要总结，提高外部排序需要考虑以下问题："></a>以上对外部排序如何使用归并算法进行排序进行了简要总结，提高外部排序需要考虑以下问题：</h4><p>1、如何减少排序所需的归并趟数。</p>
<p>2、如果高效利用程序缓冲区，使得输入、输出和CPU运行尽可能地重叠。</p>
<p>3、如何生成初始归并段（Segment）和如何对归并段进行归并。</p>
<h2 id="摔鸡蛋问题"><a href="#摔鸡蛋问题" class="headerlink" title="摔鸡蛋问题"></a>摔鸡蛋问题</h2><blockquote>
<p>你拿着两个鸡蛋站在在一栋100层的大楼前。这两个鸡蛋或许很结实，就算是从100层大楼的楼顶掉下也不会摔破</p>
</blockquote>
<ul>
<li>“对于100层的大楼来说 ，最多只需做19次实验就可以得出结果。首先，先每隔十层楼将鸡蛋丢下，从10层、20层、30层……依次丢下一个鸡蛋。这样最差的情况是在第100层楼上，鸡蛋被摔碎。然后，从第91层开始每隔一层丢一次，最差的情况是到第99层摔碎。这样，最多实验19次就可以找到鸡蛋不被摔碎的最高楼层。”</li>
<li>要求最少次数，就得保证每次都一样多的测试次数，假设在第n层放一次，如果最坏就是n次，如果不碎，就在n+(n-1)层放一次，不成功刚好也是1+(n-1)=n次，以此类推，就是n+(n-1)+(n-2)+…+1&gt;=100时n的最小值，得出(n+1)*n/2&gt;=100，n=14<br>所以最坏情况下只要十四次<br>投放楼层为14，27，35，46，56，65，73，80，86，91，95，98，100<br>每次不成功就从上一次投放地点的上一次投放，最坏为14次</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><h3 id="https-github-com-yangzj1992-articles"><a href="#https-github-com-yangzj1992-articles" class="headerlink" title="https://github.com/yangzj1992/articles"></a><a href="https://github.com/yangzj1992/articles" target="_blank" rel="noopener">https://github.com/yangzj1992/articles</a></h3><h3 id="海量数据中寻找中位数"><a href="#海量数据中寻找中位数" class="headerlink" title="海量数据中寻找中位数"></a><a href="https://segmentfault.com/a/1190000019890273" target="_blank" rel="noopener">海量数据中寻找中位数</a></h3><h3 id="JavaScript-排序算法汇总"><a href="#JavaScript-排序算法汇总" class="headerlink" title="JavaScript 排序算法汇总"></a><a href="https://github.com/yangzj1992/articles/blob/master/JavaScript%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB.md" target="_blank" rel="noopener">JavaScript 排序算法汇总</a></h3><h3 id="排序-——-外部排序"><a href="#排序-——-外部排序" class="headerlink" title="排序 —— 外部排序"></a><a href="https://blog.csdn.net/starter_____/article/details/94436782" target="_blank" rel="noopener">排序 —— 外部排序</a></h3><h3 id="什么是外部排序算法"><a href="#什么是外部排序算法" class="headerlink" title="什么是外部排序算法"></a><a href="http://c.biancheng.net/view/3452.html" target="_blank" rel="noopener">什么是外部排序算法</a></h3><h3 id="【漫画】什么是外部排序？"><a href="#【漫画】什么是外部排序？" class="headerlink" title="【漫画】什么是外部排序？ "></a><a href="http://www.sohu.com/a/258751244_818692" target="_blank" rel="noopener">【漫画】什么是外部排序？ </a></h3><h3 id="排序之外部排序"><a href="#排序之外部排序" class="headerlink" title="排序之外部排序"></a><a href="https://www.cnblogs.com/codeMedita/p/7425291.html" target="_blank" rel="noopener">排序之外部排序</a></h3><h3 id="外部排序-amp-多路归并排序"><a href="#外部排序-amp-多路归并排序" class="headerlink" title="外部排序&amp;多路归并排序"></a><a href="https://www.cnblogs.com/LUO77/p/5838206.html" target="_blank" rel="noopener">外部排序&amp;多路归并排序</a></h3><h3 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a><a href="https://blog.csdn.net/ailunlee/article/details/84548950" target="_blank" rel="noopener">外部排序</a></h3><h3 id="十大排序算法的Javascript实现"><a href="#十大排序算法的Javascript实现" class="headerlink" title="十大排序算法的Javascript实现"></a><a href="https://merrier.wang/20170318/js-implementation-of-ten-sorting-algorithms.html" target="_blank" rel="noopener">十大排序算法的Javascript实现</a></h3><h3 id="经典面试题楼层丢鸡蛋问题的动态规划解法与数学解法"><a href="#经典面试题楼层丢鸡蛋问题的动态规划解法与数学解法" class="headerlink" title="经典面试题楼层丢鸡蛋问题的动态规划解法与数学解法"></a><a href="https://www.cnblogs.com/taoshiqian/p/9277626.html" target="_blank" rel="noopener">经典面试题楼层丢鸡蛋问题的动态规划解法与数学解法</a></h3><h3 id="100层楼扔鸡蛋，最快速度找出，哪层是鸡蛋碎的临界点"><a href="#100层楼扔鸡蛋，最快速度找出，哪层是鸡蛋碎的临界点" class="headerlink" title="100层楼扔鸡蛋，最快速度找出，哪层是鸡蛋碎的临界点"></a><a href="https://blog.csdn.net/qq_38316721/article/details/81351297" target="_blank" rel="noopener">100层楼扔鸡蛋，最快速度找出，哪层是鸡蛋碎的临界点</a></h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/19/一道面试题引发的思考5/" rel="next" title="一道面试题引发的思考5">
                <i class="fa fa-chevron-left"></i> 一道面试题引发的思考5
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/01/Docker基础入门笔记/" rel="prev" title="Docker基础入门笔记">
                Docker基础入门笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tx.jpg" alt="李斌">
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">人生如逆旅     我亦是行人</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">207</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">121</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#内排序与外排序"><span class="nav-number">1.</span> <span class="nav-text">内排序与外排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#衡量效率的方法"><span class="nav-number">1.2.</span> <span class="nav-text">衡量效率的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序方法"><span class="nav-number">1.3.</span> <span class="nav-text">排序方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-number">2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法优劣评价术语"><span class="nav-number">2.1.</span> <span class="nav-text">算法优劣评价术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#稳定性"><span class="nav-number">2.1.1.</span> <span class="nav-text">稳定性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序方式"><span class="nav-number">2.1.2.</span> <span class="nav-text">排序方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复杂度"><span class="nav-number">2.1.3.</span> <span class="nav-text">复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序算法图片总结"><span class="nav-number">2.1.4.</span> <span class="nav-text">排序算法图片总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从分类上来讲"><span class="nav-number">2.2.</span> <span class="nav-text">从分类上来讲:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序（Bubble-Sort）-冒泡排序概念"><span class="nav-number">3.</span> <span class="nav-text">冒泡排序（Bubble Sort）[^冒泡排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理"><span class="nav-number">3.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现"><span class="nav-number">3.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析"><span class="nav-number">3.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序（Selection-sort）-选择排序概念"><span class="nav-number">4.</span> <span class="nav-text">选择排序（Selection sort）[^选择排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-1"><span class="nav-number">4.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-1"><span class="nav-number">4.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-1"><span class="nav-number">4.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序（Insertion-sort）-插入排序概念"><span class="nav-number">5.</span> <span class="nav-text">插入排序（Insertion sort）[^插入排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-2"><span class="nav-number">5.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-2"><span class="nav-number">5.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-2"><span class="nav-number">5.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序（Shell-sort）-希尔排序概念"><span class="nav-number">6.</span> <span class="nav-text">希尔排序（Shell sort）[^希尔排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-3"><span class="nav-number">6.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-3"><span class="nav-number">6.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-3"><span class="nav-number">6.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序（Merge-sort）-归并排序概念"><span class="nav-number">7.</span> <span class="nav-text">归并排序（Merge sort）[^归并排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-4"><span class="nav-number">7.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-4"><span class="nav-number">7.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-4"><span class="nav-number">7.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序（Quick-sort）-快速排序概念"><span class="nav-number">8.</span> <span class="nav-text">快速排序（Quick sort）[^快速排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-5"><span class="nav-number">8.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-5"><span class="nav-number">8.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-5"><span class="nav-number">8.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序（Heap-sort）-堆排序概念"><span class="nav-number">9.</span> <span class="nav-text">堆排序（Heap sort）[^堆排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-6"><span class="nav-number">9.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-6"><span class="nav-number">9.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-6"><span class="nav-number">9.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计数排序（Counting-sort）-计数排序概念"><span class="nav-number">10.</span> <span class="nav-text">计数排序（Counting sort）[^计数排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-7"><span class="nav-number">10.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-7"><span class="nav-number">10.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-7"><span class="nav-number">10.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#桶排序（Bucket-sort）-桶排序概念"><span class="nav-number">11.</span> <span class="nav-text">桶排序（Bucket sort）[^桶排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-8"><span class="nav-number">11.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-8"><span class="nav-number">11.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-8"><span class="nav-number">11.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基数排序（Radix-sort）-基数排序概念"><span class="nav-number">12.</span> <span class="nav-text">基数排序（Radix sort）[^基数排序概念]</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法原理-9"><span class="nav-number">12.1.</span> <span class="nav-text">算法原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法描述与实现-9"><span class="nav-number">12.2.</span> <span class="nav-text">算法描述与实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分析-9"><span class="nav-number">12.3.</span> <span class="nav-text">算法分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS-原生函数中的排序"><span class="nav-number">13.</span> <span class="nav-text">JS 原生函数中的排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Chrome-的实现"><span class="nav-number">13.1.</span> <span class="nav-text">Chrome 的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Firefox中的实现"><span class="nav-number">13.2.</span> <span class="nav-text">Firefox中的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Microsoft-Edge中的实现"><span class="nav-number">13.3.</span> <span class="nav-text">Microsoft Edge中的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序的差异"><span class="nav-number">13.4.</span> <span class="nav-text">排序的差异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#背后的原因"><span class="nav-number">13.5.</span> <span class="nav-text">背后的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Chrome为什么采用快速排序"><span class="nav-number">13.5.1.</span> <span class="nav-text">Chrome为什么采用快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时代特点"><span class="nav-number">13.5.2.</span> <span class="nav-text">时代特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能考虑"><span class="nav-number">13.5.3.</span> <span class="nav-text">性能考虑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#v8-在数组排序算法中的性能优化"><span class="nav-number">13.5.4.</span> <span class="nav-text">v8 在数组排序算法中的性能优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Firefox-为什么采用归并排序"><span class="nav-number">13.5.5.</span> <span class="nav-text">Firefox 为什么采用归并排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决排序稳定性的差异"><span class="nav-number">13.6.</span> <span class="nav-text">解决排序稳定性的差异</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解决方案"><span class="nav-number">13.6.1.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方案代码示例"><span class="nav-number">13.6.2.</span> <span class="nav-text">方案代码示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序算法的参考方法："><span class="nav-number">14.</span> <span class="nav-text">选择排序算法的参考方法：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三路快排"><span class="nav-number">15.</span> <span class="nav-text">三路快排</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法一"><span class="nav-number">15.1.</span> <span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法二"><span class="nav-number">15.2.</span> <span class="nav-text">方法二</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序的改进方法：三路快排"><span class="nav-number">15.3.</span> <span class="nav-text">快速排序的改进方法：三路快排</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#外排序"><span class="nav-number">16.</span> <span class="nav-text">外排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#外排思想"><span class="nav-number">16.1.</span> <span class="nav-text">外排思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化策略"><span class="nav-number">16.2.</span> <span class="nav-text">优化策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多路归并"><span class="nav-number">16.2.1.</span> <span class="nav-text">多路归并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#置换选择"><span class="nav-number">16.2.2.</span> <span class="nav-text">置换选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以上对外部排序如何使用归并算法进行排序进行了简要总结，提高外部排序需要考虑以下问题："><span class="nav-number">16.2.3.</span> <span class="nav-text">以上对外部排序如何使用归并算法进行排序进行了简要总结，提高外部排序需要考虑以下问题：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#摔鸡蛋问题"><span class="nav-number">17.</span> <span class="nav-text">摔鸡蛋问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">18.</span> <span class="nav-text">参考文档</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#https-github-com-yangzj1992-articles"><span class="nav-number">18.1.</span> <span class="nav-text">https://github.com/yangzj1992/articles</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#海量数据中寻找中位数"><span class="nav-number">18.2.</span> <span class="nav-text">海量数据中寻找中位数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JavaScript-排序算法汇总"><span class="nav-number">18.3.</span> <span class="nav-text">JavaScript 排序算法汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序-——-外部排序"><span class="nav-number">18.4.</span> <span class="nav-text">排序 —— 外部排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是外部排序算法"><span class="nav-number">18.5.</span> <span class="nav-text">什么是外部排序算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#【漫画】什么是外部排序？"><span class="nav-number">18.6.</span> <span class="nav-text">【漫画】什么是外部排序？ </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序之外部排序"><span class="nav-number">18.7.</span> <span class="nav-text">排序之外部排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部排序-amp-多路归并排序"><span class="nav-number">18.8.</span> <span class="nav-text">外部排序&amp;多路归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部排序"><span class="nav-number">18.9.</span> <span class="nav-text">外部排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#十大排序算法的Javascript实现"><span class="nav-number">18.10.</span> <span class="nav-text">十大排序算法的Javascript实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经典面试题楼层丢鸡蛋问题的动态规划解法与数学解法"><span class="nav-number">18.11.</span> <span class="nav-text">经典面试题楼层丢鸡蛋问题的动态规划解法与数学解法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100层楼扔鸡蛋，最快速度找出，哪层是鸡蛋碎的临界点"><span class="nav-number">18.12.</span> <span class="nav-text">100层楼扔鸡蛋，最快速度找出，哪层是鸡蛋碎的临界点</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
  <!--
  	描述：点击红心
  -->
  <script type="text/javascript" src="/js/src/clicklove.js"></script>
  <!--
  	描述：复制代码
  -->
  <script type="text/javascript" src="/js/src/clipboard.min.js"></script>
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
</body>
</html>



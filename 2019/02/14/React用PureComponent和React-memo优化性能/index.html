<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><script src="/lib/pace/pace.min.js?v=1.0.2"></script><link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Hexo, NexT"><meta name="description" content="本文将从 render 函数的角度总结 React App 的优化技巧。 需要提醒的是，文中将涉及 React 16.8.2 版本的内容(也即 Hooks），因此请至少了解 useState 以保证食用效果。 当我们讨论 React App 的性能问题时，组件的渲染速度是一个重要问题。在进入到具体优化建议之前，我们先要理解以下 3 点：  当我们在说「render」时，我们在说什么？ 什么时候会执"><meta property="og:type" content="article"><meta property="og:title" content="React用PureComponent和React.memo优化性能"><meta property="og:url" content="http://yoursite.com/2019/02/14/React用PureComponent和React-memo优化性能/index.html"><meta property="og:site_name" content="舞动乾坤"><meta property="og:description" content="本文将从 render 函数的角度总结 React App 的优化技巧。 需要提醒的是，文中将涉及 React 16.8.2 版本的内容(也即 Hooks），因此请至少了解 useState 以保证食用效果。 当我们讨论 React App 的性能问题时，组件的渲染速度是一个重要问题。在进入到具体优化建议之前，我们先要理解以下 3 点：  当我们在说「render」时，我们在说什么？ 什么时候会执"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2019-02-24T08:32:58.236Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="React用PureComponent和React.memo优化性能"><meta name="twitter:description" content="本文将从 render 函数的角度总结 React App 的优化技巧。 需要提醒的是，文中将涉及 React 16.8.2 版本的内容(也即 Hooks），因此请至少了解 useState 以保证食用效果。 当我们讨论 React App 的性能问题时，组件的渲染速度是一个重要问题。在进入到具体优化建议之前，我们先要理解以下 3 点：  当我们在说「render」时，我们在说什么？ 什么时候会执"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://yoursite.com/2019/02/14/React用PureComponent和React-memo优化性能/"><title>React用PureComponent和React.memo优化性能 | 舞动乾坤</title></head><body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"><div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div></div><header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader"><div id="sky"><div id="background" class="container"><svg id="svgout" height="100%" width="100%" viewbox="0 0 550 400"><defs><g id="bottomShadow"><path fill="#000000" stroke="none" d="M270.5 225.95 127.35 316.65 266.8 400 409.6 309.25 270.5 225.95Z"/></g><g id="Layer52_0_FILL"><path class="topGrass" fill="#B9D668" stroke="none" d="M397.85 229.3 397.85 225.6 269.85 152 135.75 228.6 135.75 233.65 262.1 306.55 397.85 229.3Z"/></g><g id="Layer51_0_FILL"><path class="leftSideGrass" fill="#6E9E4F" stroke="none" d="M135.1 229.95 135.1 256.85 262.1 328.4 262.1 301.85 135.1 229.95Z"/></g><g id="Layer50_0_FILL"><path class="rightGrassTop" fill="#8CB154" stroke="none" d="M397.85 225.95 395.8 225.95 261.75 301.55 261.75 328.4 397.85 251.15 397.85 225.95Z"/></g><g id="Layer48_0_FILL"><path class="crustLeftTop" fill="#955541" stroke="none" d="M135.45 282.4 135.75 298.15 262.1 372.1 261.75 355.65 135.45 282.4Z"/></g><g id="Layer47_0_FILL"><path class="middleLeftCrust" fill="#C77E61" stroke="none" d="M135.1 270.3 135.1 283.05 275.9 364.35 271.85 348.9 135.1 270.3Z"/></g><g id="Layer46_0_FILL"><path class="crustLeftTop" fill="#955541" stroke="none" d="M135.1 255.15 135.1 270.3 262.1 343.55 262.1 328.05 135.1 255.15Z"/></g><g id="Layer45_0_FILL"><path class="topRightCrust" fill="#A47237" stroke="none" d="M397.5 294.5 397.5 277 261.75 355.3 261.75 372.75 397.5 294.5Z"/></g><g id="Layer44_0_FILL"><path class="middleRightCrust" fill="#C89451" stroke="none" d="M397.5 269.95 397.15 266.6 262.1 343.2 262.1 355.95 397.5 279.7 397.5 269.95Z"/></g><g id="Layer43_0_FILL"><path class="topRightCrust" fill="#A47237" stroke="none" d="M397.5 266.6 397.5 250.45 261.75 328.4 261.75 343.85 397.5 266.6Z"/></g><g id="Layer41_0_FILL"><path class="greyRoad" fill="#B2B2B1" stroke="none" d="M295.05 283.05Q299.05 280.35 308.45 275.3 317.85 269.95 323.6 266.9L268.8 233.65 338.05 191.35 309.15 174.55 177.75 254.5Q191.55 262.2 198.25 266.25 204.65 269.95 209.7 271.95L241.6 250.45 295.05 283.05Z"/></g><g id="Layer40_0_FILL"><path fill="#FFFFFF" stroke="none" d="M199.95 256.85Q194.55 261.2 191.9 262.2L194.9 263.9 200.95 259.2 199.95 256.85M225.8 243.75 224.8 241.75 211.05 250.8 212.05 252.8 225.8 243.75M308.15 275.65 296.7 266.6 295.35 268.6 306.8 277.7 308.15 275.65M275.9 253.5 274.55 255.5 285.95 264.55 287.3 262.55 275.9 253.5M251.7 227.3 250.7 225.25 236.9 234.35 237.9 236.35 251.7 227.3M257.05 240.7 254.05 240.7 268.8 249.8 269.5 247.75 257.05 240.7M277.2 207.8 263.45 216.85 264.45 218.9 278.25 209.8 277.2 207.8M305.1 192.65 304.1 190.65 290.3 199.75 291.35 201.75 305.1 192.65Z"/></g><g id="Layer38_0_FILL"><path class="frontFascia" fill="#ECB27B" stroke="none" d="M359.25 187.95 346.4 174.95 333.85 202.9 359.25 187.95Z"/></g><g id="Layer37_0_FILL"><path class="frontWall" fill="#EFA258" stroke="none" d="M334 201.05 334.35 232 359.2 217.55 359.25 187.95 334 201.05Z"/></g><g id="Layer36_0_FILL"><path class="leftWall" fill="#C57F42" stroke="none" d="M334.35 232.3 334.35 205.1 305.1 191.35 305.1 216.85 334.35 232.3Z"/></g><g id="Layer35_0_FILL"><path class="rightRoof" fill="#EF4427" stroke="none" d="M329.7 167.9 331.05 167.9 344.55 176.7 347.85 176.7 363 192.25 363.15 189.55 350.65 176.7 350.55 176.7 334.25 167.5 334.25 159.1 329.7 159.1 329.7 164.9 322.65 160.95 322.3 162.15 329.7 167 329.7 167.9Z"/></g><g id="Layer34_0_FILL"><path class="leftRoof" fill="#F2563B" stroke="none" d="M334.05 207.05 350.65 176.7 322.1 160.45 302.1 192.05 334.05 207.05Z"/></g><g id="Layer30_0_FILL"><path id="windowFour" class="windows" stroke="none" fill="#975A42" d="M341.35 203.3Q340.9 203.45 340.5 203.8 340.1 204.2 339.85 204.75 339.7 205 339.7 205.3 339.6 205.75 339.7 206.1 339.7 206.15 339.7 206.2 339.8 206.5 340 206.8 340.55 207.4 341.45 207.4 342.35 207.4 343 206.8 343.4 206.5 343.65 206.1 343.85 205.75 343.95 205.3 344.05 204.4 343.55 203.8 343.3 203.45 343 203.3 342.65 203.15 342.2 203.15 341.8 203.15 341.35 203.3M355.85 198.45Q355.8 198.2 355.6 198 355.1 197.4 354.2 197.4 353.35 197.4 352.6 198 351.85 198.65 351.7 199.55 351.7 199.7 351.7 199.85 351.6 200.5 352 201.05 352.55 201.65 353.45 201.65 354.3 201.65 355.05 201.05 355.45 200.7 355.7 200.25 355.8 200.05 355.9 199.85 355.95 199.7 355.95 199.55 356.05 198.95 355.85 198.45Z"/><path class="door" fill="#B65041" stroke="none" d="M351.95 211.2 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2M351.2 211.2 351.35 211.2 351.35 211.1 351.2 211.2Z"/></g><g><path id="Layer30_0_FILL" fill="#000000" fill-opacity="1" stroke="none" d="M183.7 215.3 183.7 215.6Q187.25 231.75 212.25 234.35L183.7 215.3Z"/></g><g id="Layer29_0_FILL"><path fill="#000000" fill-opacity="0.4" stroke="none" d="M305.1 216.85 305.15 217.2Q309.45 233.2 334.35 232.3L305.1 216.85Z"/></g><g id="Layer27_0_FILL"><path class="vegetation" fill="#78A950" stroke="none" d="M177.45 231.65Q175.75 235.35 181.8 239.35 185.5 235.7 185.15 231.3 182.8 230.65 181.45 234 179.45 231.3 177.45 231.65M236.9 266.6Q235.2 270.3 241.25 274.3 244.95 270.6 244.65 266.25 242.3 265.6 240.95 268.95 238.9 266.25 236.9 266.6M254.7 277Q253.05 280.7 259.1 284.75 262.75 281.05 262.45 276.65 260.1 276 258.75 279.35 256.7 276.65 254.7 277M315.5 245.75Q313.5 243.05 311.5 243.4 309.8 247.1 315.85 251.15 319.55 247.45 319.2 243.05 316.85 242.4 315.5 245.75M295.35 232.65Q293.7 236.35 299.75 240.4 303.45 236.7 303.1 232.3 300.75 231.65 299.4 235 297.4 232.3 295.35 232.65M277.2 171.85Q275.55 175.55 281.6 179.55 285.3 175.85 284.95 171.5 282.6 170.85 281.25 174.2 279.25 171.5 277.2 171.85Z"/></g><g id="Layer26_0_FILL"><path class="treeWood" fill="#AE663D" stroke="none" d="M175.1 177.55 172.05 177.55 172.05 191.1 159.3 172.85Q154.6 171.5 172.05 195.7L172.05 212.5 175.1 212.5 175.1 177.55M252.7 151.35 249 151.35 249 176.9 252.7 176.9 252.7 151.35Z"/></g><g id="Layer25_0_FILL"><path class="vegetation" fill="#77A951" stroke="none" d="M192.55 179.55Q200.95 173.5 200.95 165.1 200.95 156.4 192.55 150 184.15 144.3 172.05 144.3 160.3 144.3 151.9 150 143.15 156.4 143.15 165.1 143.15 173.5 151.9 179.55 160.3 185.95 172.05 185.95 184.15 185.95 192.55 179.55M236.25 106.65Q230.2 116.05 230.2 129.15 230.2 142.25 236.25 151.35 242.3 160.75 250.7 160.75 258.75 160.75 264.8 151.35 270.85 142.25 270.85 129.15 270.85 116.05 264.8 106.65 258.75 97.6 250.7 97.6 242.3 97.6 236.25 106.65Z"/></g><g id="Layer24_0_FILL"><path class="vegetation" fill="#77A951" stroke="none" d="M158.3 221.9Q160.65 221.9 161.95 220.2 163 219.55 163.3 218.55 164.65 218.9 166.35 218.9 170.05 218.9 172.4 216.2 175.1 213.85 175.1 210.15 175.1 206.45 172.4 203.75 170.05 201.4 166.35 201.4 162.65 201.4 159.95 203.75 157.6 206.45 157.6 210.15 157.6 210.8 157.6 211.15 155.95 211.5 154.6 212.5 152.9 214.15 152.9 216.55 152.9 218.9 154.6 220.2 156.25 221.9 158.3 221.9M338.35 240.05Q341.05 237.7 341.05 234 341.05 230.3 338.35 227.6 336 225.25 332.3 225.25 328.65 225.25 325.95 227.6 323.6 230.3 323.6 234 323.6 237.7 325.95 240.05 328.65 242.75 332.3 242.75 336 242.75 338.35 240.05Z"/></g><g id="Layer22_0_FILL"><path class="rightRoof" fill="#D05041" stroke="none" d="M220 173.85 236.8 186.7 264.35 171.15 244.5 159.55 220 173.85Z"/></g><g id="Layer21_0_FILL"><path class="leftWall" fill="#C57F42" stroke="none" d="M212.25 191.35 183.35 172.3 183.7 215.3 212.25 234.35 212.25 191.35Z"/></g><g id="Layer20_0_FILL"><path class="rightRoof" fill="#EF4427" stroke="none" d="M192.1 149.85 236.45 174.8 243.1 171.4Q220.05 150.55 196.3 139.95L192.1 149.85Z"/></g><g id="Layer19_0_FILL"><path class="frontFascia" fill="#EBB17B" stroke="none" d="M226.85 160.95 212 190.6 229.75 192.6 239.75 172.85 226.85 160.95Z"/></g><g id="Layer18_0_FILL"><path class="frontWall" fill="#EFA258" stroke="none" d="M240.15 172.65 211.9 191.6 212.25 233.65 264.35 201.7 264.35 170.8 240.8 184.45 240.15 172.65Z"/></g><g id="Layer17_0_FILL"><path class="rightRoof" fill="#EF4427" stroke="none" d="M210.9 142.2 205.9 142.2 205.9 152.65 210.9 152.65 210.9 142.2Z"/></g><g><path id="Layer16_0_FILL" class="leftRoof" fill="#F2563B" stroke="none" d="M210.25 195.5 227.4 160.95 195.45 141.35 177.65 175.85 210.25 195.5Z"/></g><g><path id="sun" fill="#E3BD0E" stroke="none" d="M257.05 15.95Q251.7 15.95 248 19.65 244.3 23.35 244.3 28.7 244.3 34.1 248 37.8 251.7 41.5 257.05 41.5 262.45 41.5 266.15 37.8 269.85 34.1 269.85 28.7 269.85 23.35 266.15 19.65 262.45 15.95 257.05 15.95Z"/></g><g id="Layer8_0_FILL"><path fill="#975A42" stroke="none" d="M238.45 189.65Q238.295703125 189.362109375 238.05 189.1 237.35 188.3 236.2 188.3 235.05 188.3 234.15 189.1 233.3 189.9 233.2 191.05 233.1 192.2 233.8 193 234.55 193.8 235.7 193.8 236.85 193.8 237.7 193 238.1970703125 192.558203125 238.45 192 238.6552734375 191.56484375 238.7 191.05 238.7671875 190.276953125 238.45 189.65M220.55 197.55Q220 197.55 219.5 197.75 218.95 197.95 218.5 198.35 217.933203125 198.8833984375 217.7 199.55 217.5833984375 199.916796875 217.55 200.3 217.4923828125 200.96171875 217.7 201.5 217.852734375 201.9103515625 218.15 202.25 218.95 203.05 220.1 203.05 221.25 203.05 222.05 202.25 222.95 201.45 223.05 200.3 223.15 199.15 222.4 198.35 222.05 197.95 221.65 197.75 221.15 197.55 220.55 197.55Z"/></g><g id="Layer7_0_FILL"><path class="door" fill="#B65041" stroke="none" d="M233.55 206.75 225.9 211.95 226.25 225.5 233.95 220.35 233.55 206.75Z"/></g><g><path id="windowOne" class="windows" fill="#975A42" stroke="none" d="M188.65 198.4 188.8 204.1 198.65 210.45 198.55 204.75 188.65 198.4M208.45 216.8 208.35 211.1 198.55 204.75 198.65 210.45 208.45 216.8M188.8 204.1 188.95 209.8 198.8 216.15 198.65 210.45 188.8 204.1M208.6 222.5 208.45 216.8 198.65 210.45 198.8 216.15 208.6 222.5Z"/></g><g><path id="windowThree" class="windows" fill="#975A42" stroke="none" d="M311.7 214.1 318.55 217.55 318.45 211.9 311.6 208.45 311.7 214.1M325.4 221 325.25 215.35 318.45 211.9 318.55 217.55 325.4 221M318.4 206.2 311.5 202.75 311.6 208.45 318.45 211.9 318.4 206.2M325.25 215.35 325.2 209.7 318.4 206.2 318.45 211.9 325.25 215.35Z"/></g><g id="Layer2_0_FILL"><path class="door" fill="#B65041" stroke="none" d="M259.7 183.25 244.6 191.9 244.6 213.8 259.7 204.55 259.7 183.25Z"/></g><path id="windowTwo" fill="#975A42" class="windows" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" d="M223.05 200.3Q222.95 201.45 222.05 202.25 221.25 203.05 220.1 203.05 218.95 203.05 218.15 202.25 217.852734375 201.9103515625 217.7 201.5 217.4923828125 200.96171875 217.55 200.3 217.5833984375 199.916796875 217.7 199.575 217.933203125 198.8833984375 218.5 198.35 218.95 197.95 219.5 197.75 220 197.55 220.55 197.55 221.15 197.55 221.65 197.75 222.05 197.95 222.4 198.35 223.15 199.15 223.05 200.3ZM238.7 191.05Q238.6552734375 191.56484375 238.45 192 238.1970703125 192.558203125 237.7 193 236.85 193.8 235.7 193.8 234.55 193.8 233.8 193 233.1 192.2 233.2 191.05 233.3 189.9 234.15 189.1 235.05 188.3 236.2 188.3 237.35 188.3 238.05 189.1 238.295703125 189.362109375 238.45 189.65 238.7671875 190.276953125 238.7 191.05Z"/><path fill="#F2563B" stroke="none" d="M351.95 211.2 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2Z"/><path id="Layer6_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="M198.55 204.75 208.35 211.1 208.45 216.8 208.6 222.5 198.8 216.15 188.95 209.8 188.8 204.1 188.65 198.4 198.55 204.75 198.65 210.45 208.45 216.8M198.8 216.15 198.65 210.45 188.8 204.1"/><path id="Layer5_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="M325.25 215.35 325.4 221 318.55 217.55 311.7 214.1 311.6 208.45 311.5 202.75 318.4 206.2 325.2 209.7 325.25 215.35 318.45 211.9 318.55 217.55M318.4 206.2 318.45 211.9 311.6 208.45"/></defs><g id="shadow"><g transform="matrix( 1, 0, 0, 1, 0,0) "><use xlink:href="#bottomShadow"/></g></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use xlink:href="#sun"/></g><g id="earth"><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer52_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer51_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer50_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer48_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer47_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer46_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer45_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer44_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer43_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer41_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer40_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer38_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer37_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer36_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer35_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer34_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#windowFour"/><use class="element" xlink:href="#Layer32_0_1_STROKES"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer30_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer27_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer26_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer25_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer24_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer22_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer21_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer20_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer19_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer18_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer17_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer16_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer8_0_FILL"/><use class="element" xlink:href="#windowTwo"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer7_0_FILL"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#windowOne"/><use class="element" xlink:href="#Layer6_0_1_STROKES"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#windowThree"/><use class="element" xlink:href="#Layer5_0_1_STROKES"/></g><g transform="matrix( 1, 0, 0, 1, 0,0) "><use class="element" xlink:href="#Layer2_0_FILL"/></g></g></svg><div id="toggleButton" class="day-toggle"><div class="sun-icon"></div> <label class="switch"><input id="toggleCheckbox" type="checkbox"><div class="slider"></div></label><div class="cloud-icon"></div></div></div></div><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">舞动乾坤</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">星光不问赶路人 岁月不负有心人</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/14/React用PureComponent和React-memo优化性能/"><span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person"><meta itemprop="name" content="李斌"><meta itemprop="description" content=""><meta itemprop="image" content="/images/tx.jpg"></span><span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization"><meta itemprop="name" content="舞动乾坤"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">React用PureComponent和React.memo优化性能</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T15:38:13+08:00">2019-02-14</time></span></div></header><div class="post-body" itemprop="articleBody"><p>本文将从 render 函数的角度总结 React App 的优化技巧。</p><p>需要提醒的是，文中将涉及 React 16.8.2 版本的内容(也即 Hooks），因此请至少了解 useState 以保证食用效果。</p><p>当我们讨论 React App 的性能问题时，组件的<strong>渲染</strong>速度是一个重要问题。在进入到具体优化建议之前，我们先要理解以下 3 点：</p><ol><li>当我们在说「render」时，我们在说什么？</li><li>什么时候会执行「render」？</li><li>在「render」过程中会发生什么？</li></ol><h2 id="解读-render-函数"><a href="#解读-render-函数" class="headerlink" title="解读 render 函数"></a>解读 render 函数</h2><p>这部分涉及 reconciliation 和 diffing 的概念，当然官方文档在<a href="https://link.juejin.im?target=https%3A%2F%2Freactjs.org%2Fdocs%2Freconciliation.html" target="_blank" rel="noopener">这里</a>。</p><h3 id="当我们在说「render」时，我们在说什么？"><a href="#当我们在说「render」时，我们在说什么？" class="headerlink" title="当我们在说「render」时，我们在说什么？"></a>当我们在说「render」时，我们在说什么？</h3><p>这个问题其实写过 React 的人都会知道，这里再简单说下：</p><p>在 class 组件中，我们指的是 render 方法：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Foo <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在函数式组件中，我们指的是函数组件本身：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Foo <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="什么时候会执行「render」？"><a href="#什么时候会执行「render」？" class="headerlink" title="什么时候会执行「render」？"></a>什么时候会执行「render」？</h3><p>render 函数会在两种场景下被调用：</p><h4 id="状态更新时"><a href="#状态更新时" class="headerlink" title="状态更新时"></a>状态更新时</h4><h5 id="a-继承自-React-Component-的-class-组件更新状态时"><a href="#a-继承自-React-Component-的-class-组件更新状态时" class="headerlink" title="a. 继承自 React.Component 的 class 组件更新状态时"></a>a. 继承自 React.Component 的 class 组件更新状态时</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class Foo extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  state = &#123; count: 0 &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  increment = () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const &#123; count &#125; = this.state;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    const newCount = count <span class="tag">&lt; <span class="attr">10</span> ? <span class="attr">count</span> + <span class="attr">1</span> <span class="attr">:</span> <span class="attr">count</span>;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    this.setState(&#123; count: newCount &#125;);</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    const &#123; count &#125; = this.state;</span></span><br><span class="line"><span class="xml">    console.log("Foo render");</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    return (</span></span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt; &#123;count&#125; &lt;/h1&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.increment&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure><p>可以看到，代码中的逻辑是我们点击就会更新 count，到 10 以后，就会维持在 10。增加一个 console.log，这样我们就可以知道 render 是否被调用了。从执行结果可以知道，即使 count 到了 10 以上，render 仍然会被调用。</p><p>总结： <strong><font color="#ff0000">继承了 React.Component 的 class 组件，即使状态没变化，只要调用了setState 依然会触发 render。</font></strong></p><h5 id="b-函数式组件更新状态时"><a href="#b-函数式组件更新状态时" class="headerlink" title="b. 函数式组件更新状态时"></a>b. 函数式组件更新状态时</h5><p>我们用函数实现相同的组件，当然因为要有状态，我们用上了 useState hook：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Foo() &#123;</span></span><br><span class="line"><span class="xml">  const [count, setCount] = useState(0);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  function increment() &#123;</span></span><br><span class="line"><span class="xml">    const newCount = count <span class="tag">&lt; <span class="attr">10</span> ? <span class="attr">count</span> + <span class="attr">1</span> <span class="attr">:</span> <span class="attr">count</span>;</span></span></span><br><span class="line"><span class="xml">    setCount(newCount);</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  console.log("Foo render");</span></span><br><span class="line"><span class="xml">  </span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt; &#123;count&#125; &lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;increment&#125;&gt;Increment&lt;/button&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure><p></p><p>我们可以注意到，当状态值不再改变之后，render 的调用就停止了。</p><p>总结： <strong><font color="#ff0000">对函数式组件来说，状态值改变时才会触发 render 函数的调用。</font></strong></p><h4 id="父容器重新渲染时"><a href="#父容器重新渲染时" class="headerlink" title="父容器重新渲染时"></a>父容器重新渲染时</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123; <span class="attr">name</span>: <span class="string">"App"</span> &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">        &lt;Foo /&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.setState(&#123; <span class="attr">name</span>: <span class="string">"App"</span> &#125;)&#125;&gt;</span><br><span class="line">          Change name</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Foo render"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt; Foo &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure><p>只要点击了 App 组件内的 Change name 按钮，就会重新 render。而且可以注意到，不管 Foo 具体实现是什么，Foo 都会被重新渲染。</p><p>总结： <strong><font color="#ff0000">无论组件是继承自 React.Component 的 class 组件还是函数式组件，一旦父容器重新 render，组件的 render 都会再次被调用。</font></strong></p><h3 id="在「render」过程中会发生什么？"><a href="#在「render」过程中会发生什么？" class="headerlink" title="在「render」过程中会发生什么？"></a>在「render」过程中会发生什么？</h3><p>只要 render 函数被调用，就会有两个步骤按顺序执行。这两个步骤非常重要，理解了它们才好知道如何去优化 React App。</p><h4 id="Diffing-【对比】"><a href="#Diffing-【对比】" class="headerlink" title="Diffing 【对比】"></a>Diffing 【对比】</h4><p>在此步骤中，React 将新调用的 render 函数返回的树与旧版本的VDOM树进行比较，这一步是 React 决定如何更新 DOM 的必要步骤。虽然 React 使用高度优化的算法执行此步骤，但仍然有一定的性能开销。</p><h4 id="Reconciliation-【更新】"><a href="#Reconciliation-【更新】" class="headerlink" title="Reconciliation 【更新】"></a>Reconciliation 【更新】</h4><p>基于 diffing 的结果，React 更新 DOM 树。这一步因为需要卸载和挂载 DOM 节点同样存在许多性能开销。</p><h2 id="开始我们的-Tips"><a href="#开始我们的-Tips" class="headerlink" title="开始我们的 Tips"></a>开始我们的 Tips</h2><h3 id="谨慎分配-state-以避免不必要的-render-调用"><a href="#谨慎分配-state-以避免不必要的-render-调用" class="headerlink" title="谨慎分配 state 以避免不必要的 render 调用"></a>谨慎分配 state 以避免不必要的 render 调用</h3><p>我们以下面为例，其中 App 会渲染两个组件：</p><ul><li><code>CounterLabel</code>，接收 count 值和一个 inc 父组件 App 中状态 count 的方法。</li><li><code>List</code>，接收 item 的列表。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ITEMS = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [items, setItems] = useState(ITEMS);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;CounterLabel count=&#123;count&#125; increment=&#123;() =&gt; setCount(count + <span class="number">1</span>)&#125; /&gt;</span><br><span class="line">      &lt;List items=&#123;items&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function CounterLabel(&#123; count, increment &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;&#123;count&#125; &lt;/</span>h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;increment&#125;&gt; Increment &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">List</span>(<span class="params">&#123; items &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"List render"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;items.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;li key=&#123;index&#125;&gt;&#123;item&#125; &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/u</span>l&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure></li></ul><p>执行上面代码可知，只要父组件 App 中的状态被更新，<code>CounterLabel</code> 和 <code>List</code> 就都会更新。</p><p>当然，<code>CounterLabel</code> 重新渲染是正常的，因为 count 发生了变化，自然要重新渲染；但是对于 <code>List</code> 而言，就完全是不必要的更新了，因为它的渲染与 count 无关。</p><p> <strong><font color="#ff0000">尽管 React 并不会在 reconciliation 阶段真的更新 DOM，毕竟完全没变化，但是仍然会执行 diffing 阶段来对前后的树进行对比，这仍然存在性能开销。</font></strong></p><p>还记得 render 执行过程中的 diffing 和 reconciliation 阶段吗？前面讲过的东西在这里碰到了。</p><p>因此，为了避免不必要的 diffing 开销，我们应当考虑将特定的状态值放到更低的层级或组件中（与 React 中所说的「提升」概念刚好相反）。在这个例子中，我们可以通过将 count 放到 <code>CounterLabel</code> 组件中管理来解决这个问题。</p><h3 id="合并状态更新"><a href="#合并状态更新" class="headerlink" title="合并状态更新"></a>合并状态更新</h3><p>因为每次状态更新都会触发新的 render 调用，那么更少的状态更新也就可以更少的调用 render 了。</p><p>我们知道，React class 组件有 <code>componentDidUpdate(prevProps, prevState)</code> 的钩子，可以用来检测 props 或 state 有没有发生变化。尽管有时有必要在 props 发生变化时再触发 state 更新，但我们总可以避免在一次 state 变化后再进行一次 state 更新这种操作：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRange</span>(<span class="params">limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> range = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">    range.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    numbers: getRange(<span class="number">7</span>),</span><br><span class="line">    limit: <span class="number">7</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleLimitChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> limit = e.target.value;</span><br><span class="line">    <span class="keyword">const</span> limitChanged = limit !== <span class="keyword">this</span>.state.limit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (limitChanged) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; limit &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">const</span> limitChanged = prevState.limit !== <span class="keyword">this</span>.state.limit;</span><br><span class="line">    <span class="keyword">if</span> (limitChanged) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">numbers</span>: getRange(<span class="keyword">this</span>.state.limit) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleLimitChange&#125;</span><br><span class="line">          placeholder=<span class="string">"limit"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.limit&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.numbers.map(<span class="function">(<span class="params">number, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;p key=&#123;idx&#125;&gt;&#123;number&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure><p></p><p>这里渲染了一个范围数字序列，即范围为 0 到 limit。只要用户改变了 limit 值，我们就会在 componentDidUpdate 中进行检测，并设定新的数字列表。</p><p>毫无疑问，上面的代码是可以满足需求的，但是，我们仍然可以进行优化。</p><p>上面的代码中，每次 limit 发生改变，我们都会触发两次状态更新：第一次是为了修改 limit，第二次是为了修改展示的数字列表。这样一来，每次 limit 的变化会带来两次 render 开销：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始状态</span></span><br><span class="line">&#123; <span class="attr">limit</span>: <span class="number">7</span>, <span class="attr">numbers</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="comment">// 更新 limit -&gt; 4</span></span><br><span class="line">render <span class="number">1</span>: &#123; <span class="attr">limit</span>: <span class="number">4</span>, <span class="attr">numbers</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] &#125; </span><br><span class="line">render <span class="number">2</span>: &#123; <span class="attr">limit</span>: <span class="number">4</span>, <span class="attr">numbers</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>我们的代码逻辑带来了下面的问题：</p><ul><li>我们触发了比实际需要更多的状态更新；</li><li>我们出现了「不连续」的渲染结果，即数字列表与 limit 不匹配。</li></ul><p>为了改进，我们应避免在不同的状态更新中改变数字列表。事实上，我们可以在一次状态更新中搞定：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRange</span>(<span class="params">limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> range = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">    range.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> range;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    numbers: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">    limit: <span class="number">7</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleLimitChange = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> limit = e.target.value;</span><br><span class="line">    <span class="keyword">const</span> limitChanged = limit !== <span class="keyword">this</span>.state.limit;</span><br><span class="line">    <span class="keyword">if</span> (limitChanged) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; limit, <span class="attr">numbers</span>: getRange(limit) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          onChange=&#123;<span class="keyword">this</span>.handleLimitChange&#125;</span><br><span class="line">          placeholder=<span class="string">"limit"</span></span><br><span class="line">          value=&#123;<span class="keyword">this</span>.state.limit&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.numbers.map(<span class="function">(<span class="params">number, idx</span>) =&gt;</span> (</span><br><span class="line">          &lt;p key=&#123;idx&#125;&gt;&#123;number&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        ))&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure><p></p><h3 id="使用-PureComponent-和-React-memo-以避免不必要的-render-调用"><a href="#使用-PureComponent-和-React-memo-以避免不必要的-render-调用" class="headerlink" title="使用 PureComponent 和 React.memo 以避免不必要的 render 调用"></a>使用 PureComponent 和 React.memo 以避免不必要的 render 调用</h3><p>我们在之前的例子中看到将特定状态值放到更低的层级来避免不必要渲染的方法，不过这并不总是有用。</p><p>我们来看下下面的例子：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isFooVisible, setFooVisibility] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &#123;isFooVisible ? (</span><br><span class="line">        &lt;Foo hideFoo=&#123;() =&gt; setFooVisibility(<span class="literal">false</span>)&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setFooVisibility(<span class="literal">true</span>)&#125;&gt;Show Foo &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Bar name="Bar" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Foo(&#123; hideFoo &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Foo&lt;/</span>h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;hideFoo&#125;&gt;Hide Foo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">&#123; name &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootElement = <span class="built_in">document</span>.getElementById(<span class="string">"root"</span>);</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, rootElement);</span></span><br></pre></td></tr></table></figure><p></p><p>可以看到，只要父组件 App 的状态值 isFooVisible 发生变化，Foo 和 Bar 就都会被重新渲染。</p><p>这里因为为了决定 Foo 是否要被渲染出来，我们需要将 isFooVisible 放在 App中维护，因此也就不能将状态拆出放到更低的层级。</p><p>不过，在 isFooVisible 发生变化时重新渲染 Bar 仍然是不必要的，因为 Bar 并不依赖 isFooVisible。我们只希望 Bar 在传入属性 name 变化时重新渲染。</p><p>那我们该怎么搞呢？两种方法。</p><p>其一，对 Bar 做记忆化（memoize）：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Bar = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">&#123;name&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>这就能保证 Bar 只在 name 发生变化时才重新渲染。</p><p>此外，另一个方法就是让 Bar 继承 <strong><font color="#ff0000">React.PureComponent</font></strong> 而非 React.Component：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line"> render() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>是不是很熟悉？我们经常提到使用 React.PureComponent 能带来一定的性能提升，避免不必要的 render。</p><p>总结： <strong><font color="#ff0000">避免组件不必要的渲染的方法有：React.memo 包裹的函数式组件，继承自 React.PureComponent 的 class 组件 。</font></strong></p><h4 id="为什么不让每个组件都继承-PureComponent-或者用-memo-包呢？"><a href="#为什么不让每个组件都继承-PureComponent-或者用-memo-包呢？" class="headerlink" title="为什么不让每个组件都继承 PureComponent 或者用 memo 包呢？"></a>为什么不让每个组件都继承 PureComponent 或者用 memo 包呢？</h4><p>如果这条建议可以让我们避免不必要的重新渲染，那我们为什么不把每个 class 组件变成 PureComponent、把每个函数式组件用 React.memo 包起来？为什么有了更好的方法还要保留 React.Component 呢？为什么函数式组件不默认记忆化呢？</p><p>毫无疑问，这些方法并不总是万灵药。</p><h5 id="嵌套对象的问题"><a href="#嵌套对象的问题" class="headerlink" title="嵌套对象的问题"></a>嵌套对象的问题</h5><p>我们先来考虑下 PureComponent 和 React.memo 的组件到底做了什么？</p><p>每次更新的时候（包括状态更新或上层组件重新渲染），它们就会在新 props、state 和旧 props、state 之间对 key 和 value 进行浅比较。浅比较是个严格相等的检查，如果检测到差异，render 就会执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型的比较</span></span><br><span class="line">shallowCompare(&#123; <span class="attr">name</span>: <span class="string">'bar'</span>&#125;, &#123; <span class="attr">name</span>: <span class="string">'bar'</span>&#125;); <span class="comment">// output: true</span></span><br><span class="line">shallowCompare(&#123; <span class="attr">name</span>: <span class="string">'bar'</span>&#125;, &#123; <span class="attr">name</span>: <span class="string">'bar1'</span>&#125;); <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure><p>尽管基本类型（如字符串、数字、布尔）的比较可以工作的很好，但对象这类复杂的情况可能就会带来意想不到的行为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shallowCompare(&#123; <span class="attr">name</span>: &#123;<span class="attr">first</span>: <span class="string">'John'</span>, <span class="attr">last</span>: <span class="string">'Schilling'</span>&#125;&#125;,</span><br><span class="line">			   &#123; <span class="attr">name</span>: &#123;<span class="attr">first</span>: <span class="string">'John'</span>, <span class="attr">last</span>: <span class="string">'Schilling'</span>&#125;&#125;); <span class="comment">// output: false</span></span><br></pre></td></tr></table></figure><p>上述两个 name 对应的对象的引用是不同的。</p><p>我们重新看下之前的例子，然后修改我们传入 Bar 的 props：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Bar = React.memo(<span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">&#123; name: &#123; first, last &#125; &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Bar render"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;h1&gt;</span><br><span class="line">      &#123;first&#125; &#123;last&#125;</span><br><span class="line">    &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Foo(&#123; hideFoo &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h1&gt;Foo&lt;/</span>h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;hideFoo&#125;&gt;Hide Foo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isFooVisible, setFooVisibility] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &#123;isFooVisible ? (</span><br><span class="line">        &lt;Foo hideFoo=&#123;() =&gt; setFooVisibility(<span class="literal">false</span>)&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setFooVisibility(<span class="literal">true</span>)&#125;&gt;Show Foo&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">      &lt;Bar name=&#123;&#123; first: "John", last: "Schilling" &#125;&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br></pre></td></tr></table></figure><p></p><p>尽管 Bar 做了记忆化且 props 值并没有发生变动，每次父组件重新渲染时它仍然会重新渲染。这是因为尽管每次比较的两个对象拥有相同的值，引用并不同。</p><h5 id="函数-props-的问题"><a href="#函数-props-的问题" class="headerlink" title="函数 props 的问题"></a>函数 props 的问题</h5><p>我们也可以把函数作为 props 向组件传递，当然，在 JavaScript 中函数也会传递引用，因此浅比较也是基于其传递的引用。</p><p><strong>因此，如果我们传递的是箭头函数（匿名函数），组件仍然会在父组件重新渲染时重新渲染</strong>。</p><h3 id="更好的-props-写法"><a href="#更好的-props-写法" class="headerlink" title="更好的 props 写法"></a>更好的 props 写法</h3><p>前面的问题的一种解决方法是改写我们的 props。</p><p>我们不传递对象作为 props，而是<strong>将对象拆分成基本类型</strong>：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Bar</span> <span class="attr">firstName</span>=<span class="string">"John"</span> <span class="attr">lastName</span>=<span class="string">"Schilling"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>而对于传递箭头函数的场景，我们可以代以只唯一声明过一次的函数，从而总可以拿到相同的引用，如下所示：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doSomethingMethod = <span class="keyword">this</span>.doSomethingMethod.bind(<span class="keyword">this</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">  doSomethingMethod () &#123; <span class="comment">// do something&#125;</span></span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Bar</span> <span class="attr">onSomething</span>=<span class="string">&#123;this.doSomethingMethod&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="控制更新"><a href="#控制更新" class="headerlink" title="控制更新"></a>控制更新</h3><p>还是那句话，任何方法总有其适用范围。</p><p>第三条建议虽然处理了不必要的更新问题，但我们也不总能使用它。</p><p>而第四条，在某些情况下我们并不能拆分对象，如果我们传递了某种嵌套确实复杂的数据结构，那我们也很难将其拆分开来。</p><p>不仅如此，我们也不总能传递只声明了一次的函数。比如在我们的例子中，如果 App 是个函数式组件，恐怕就不能做到这一点了（在 class 组件中，我们可以用 bind 或者类内箭头函数来保证 this 的指向及唯一声明，而在函数式组件中则可能会有些问题）。</p><p>幸运的是， <strong><font color="#ff0000">无论是 class 组件还是函数式组件，我们都有办法控制浅比较的逻辑 。</font></strong></p><p><table><tr><td bgcolor="#FF00FF"> 在 class 组件中，我们可以使用生命周期钩子 <code>shouldComponentUpdate(prevProps, prevState)</code> 来返回一个布尔值，当返回值为 true 时才会触发 render。常用Immutable.js库的is()比较。</td></tr></table> <strong><a href="https://juejin.im/post/5c62ae34e51d450aab0a373f#heading-17" target="_blank" rel="noopener">Immutable.js了解一下？</a></strong></p><p>而如果我们使用 React.memo，我们可以传递一个比较函数作为第二个参数。</p><blockquote><p><strong>注意！</strong>React.memo 的第二参数（比较函数）和 <code>shouldComponentUpdate</code> 的逻辑是相反的，只有当返回值为 false 的时候才会触发 render。<a href="https://link.juejin.im?target=https%3A%2F%2Freactjs.org%2Fdocs%2Freact-api.html%23reactmemo" target="_blank" rel="noopener">参考文档</a>。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Bar = React.memo(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params">&#123; name: &#123; first, last &#125; &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"update"</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        &#123;first&#125; &#123;last&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  (prevProps, newProps) =&gt;</span></span><br><span class="line"><span class="regexp">    prevProps.name.first === newProps.name.first &amp;&amp;</span></span><br><span class="line"><span class="regexp">    prevProps.name.last === newProps.name.last</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure><p>尽管这条建议是可行的，但我们仍要注意<strong>比较函数的性能开销</strong>。如果 props 对象过深，反而会消耗不少的性能。</p><hr><h2 id="PureComponent-Vs-Component"><a href="#PureComponent-Vs-Component" class="headerlink" title="PureComponent Vs Component"></a>PureComponent Vs Component</h2><p>它们几乎完全相同，但是PureComponent通过prop和state的浅比较来实现shouldComponentUpdate，某些情况下可以用PureComponent提升性能</p><ol><li>所谓<code>浅比较</code>(shallowEqual)，即react源码中的一个函数，然后根据下面的方法进行是不是<code>PureComponent</code>的判断，帮我们做了本来应该我们在<code>shouldComponentUpdate</code>中做的事情<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>._compositeType === CompositeTypes.PureClass) &#123;</span><br><span class="line">  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>而本来我们做的事情如下，这里判断了<code>state</code>有没有发生变化（prop同理），从而决定要不要重新渲染，这里的函数在一个继承了<code>Component</code>的组件中，而这里<code>this.state.person</code>是一个对象，你会发现，在这个对象的引用没有发生变化的时候是不会重新<code>render</code>的（即下面提到的第三点），所以我们可以用<code>shouldComponentUpdate</code>进行优化，这个方法如果返回<code>false</code>，表示不需要重新进行渲染，返回<code>true</code>则重新渲染，默认返回<code>true</code><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">   <span class="keyword">return</span> (nextState.person !== <span class="keyword">this</span>.state.person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ol start="2"><li><p>上面提到的某些情况下可以使用<code>PureComponent</code>来提升性能，那具体是哪些情况可以，哪些情况不可以呢，实践出真知</p></li><li><p>如下显示的是一个<code>IndexPage</code>组件，设置了一个<code>state</code>是<code>isShow</code>，通过一个按钮点击可以改变它的值，</p></li></ol><p>结果是：初始化的时候输出的是<code>constructor</code>，<code>render</code>，而第一次点击按钮，会输出一次render，即重新渲染了一次，界面也会从显示<code>false</code>变成显示<code>true</code>，</p><p>但是当这个组件是继承自<code>PureComponent</code>的时候，再点击的时，不会再输出<code>render</code>，即不会再重新渲染了，而当这个组件是继承自<code>Component</code>时，还是会输出<code>render</code>，还是会重新渲染，这时候就是<code>PureComponent</code>内部做了优化的体现</p><ol start="4"><li><p>同理也适用于<code>string</code>，<code>number</code>等基本数据类型，因为基本数据类型，值改变了就算改变了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      isShow: <span class="literal">false</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  changeState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isShow: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.changeState&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.state.isShow.toString()&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>当这个<code>this.state.arr</code>是一个数组时，且这个组件是继承自<code>PureComponent</code>时，初始化依旧是输出<code>constructor</code>和<code>render</code>，但是当点击按钮时，界面上没有变化，也没有输出<code>render</code>，证明没有渲染，但是我们可以从下面的注释中看到，每点击一次按钮，我们想要修改的<code>arr</code>的值已经改变，而这个值将去修改<code>this.state.arr</code>,但是因为在<code>PureComponent</code>中<code>浅比较</code>这个数组的引用没有变化所以没有渲染，<code>this.state.arr</code>也没有更新，因为在<code>this.setState()</code>以后，值是在<code>render</code>的时候更新的，这里涉及到<code>this.setState()</code>的知识</p></li><li><p>但是当这个组件是继承自<code>Component</code>的时候，初始化依旧是输出<code>constructor</code>和<code>render</code>，但是当点击按钮时，界面上出现了变化，即我们打印处理的<code>arr</code>的值输出，而且每点击一次按钮都会输出一次<code>render</code>，证明已经重新渲染，<code>this.state.arr</code>的值已经更新，所以我们能在界面上看到这个变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      arr:[<span class="string">'1'</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  changeState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; arr &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    arr.push(<span class="string">'2'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">    <span class="comment">// ["1", "2"]</span></span><br><span class="line">    <span class="comment">// ["1", "2", "2"]</span></span><br><span class="line">    <span class="comment">// ["1", "2", "2", "2"] </span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      arr</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.changeState&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.arr.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return item;</span></span><br><span class="line"><span class="regexp">          &#125;)&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><p>7.下面的例子用<code>扩展运算符</code>产生新数组，使<code>this.state.arr</code>的引用发生了变化，所以初始化的时候输出<code>constructor</code>和<code>render</code>后，每次点击按钮都会输出<code>render</code>，界面也会变化，不管该组件是继承自<code>Component</code>还是<code>PureComponent</code>的<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; PureComponent &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      arr:[<span class="string">'1'</span>]</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  changeState = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; arr &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      arr: [...arr, <span class="string">'2'</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'render'</span>);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.changeState&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this.state.arr.map((item) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            return item;</span></span><br><span class="line"><span class="regexp">          &#125;)&#125;</span></span><br><span class="line"><span class="regexp">          &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>8.上面的情况同样适用于<code>对象</code>的情况</p><h3 id="PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件"><a href="#PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件" class="headerlink" title="PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件"></a>PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件</h3><p>1.我们让<code>IndexPage</code>组件里面包含一个子组件<code>Example</code>来展示<code>PureComponent</code>是如何影响子组件的</p><p>2.父组件继承<code>PureComponent</code>，子组件继承<code>Component</code>时：下面的结果初始化时输出为<code>constructor</code>，<code>IndexPage render</code>，<code>example render</code>，但是当我们点击按钮时，界面没有变化，因为这个<code>this.state.person</code>对象的引用没有改变，只是改变了它里面的属性值所以尽管子组件是继承<code>Component</code>的也没有办法渲染，因为父组件是<code>PureComponent</code>，父组件根本没有渲染，所以子组件也不会渲染</p><p>3.父组件继承<code>PureComponent</code>，子组件继承<code>PureComponent</code>时：因为渲染在父组件的时候就没有进行，相当于被拦截了，所以子组件是<code>PureComponent</code>还是<code>Component</code>根本不会影响结果，界面依旧没有变化</p><p>4.父组件继承<code>Component</code>，子组件继承<code>PureComponent</code>时：结果和我们预期的一样，即初始化是会输出<code>constructor</code>，<code>IndexPage render</code>，<code>example render</code>，但是点击的时候只会出现<code>IndexPage render</code>，因为父组件是<code>Component</code>，所以父组件会渲染，但是</p><p>当父组件把值传给子组件的时候，因为子组件是<code>PureComponent</code>，所以它会对<code>prop</code>进行浅比较，发现这个<code>person</code>对象的引用没有发生变化，所以不会重新渲染，而界面显示是由子组件显示的，所以界面也不会变化</p><p>5.父组件继承<code>Component</code>，子组件继承<code>Component</code>时：初始化是会输出<code>constructor</code>，<code>IndexPage render</code>，<code>example render</code>，当我们第一次点击按钮以后，界面发生变化，后面就不再改变，因为我们一直把它设置为sxt2，但是每点击一次都会输出<code>IndexPage render</code>，<code>example render</code>，因为每次不管父组件还是子组件都会渲染</p><p>6.所以正如下面第四条说的，如果<code>state</code>和<code>prop</code>一直变化的话，还是建议使用<code>Component</code>，并且<code>PureComponent</code>的最好作为展示组件</p><pre><code class="js"><span class="comment">//父组件</span>
<span class="keyword">import</span> React, { PureComponent, Component } <span class="keyword">from</span> <span class="string">'react'</span>;
<span class="keyword">import</span> Example <span class="keyword">from</span> <span class="string">"../components/Example"</span>;

<span class="class"><span class="keyword">class</span> <span class="title">IndexPage</span> <span class="keyword">extends</span> <span class="title">PureComponent</span></span>{
  <span class="keyword">constructor</span>() {
    <span class="keyword">super</span>();
    <span class="keyword">this</span>.state = {
      person: {
        name: <span class="string">'sxt'</span>
      }
    };
    <span class="built_in">console</span>.log(<span class="string">'constructor'</span>);
  }
  changeState = <span class="function"><span class="params">()</span> =&gt;</span> {
    <span class="keyword">let</span> { person } = <span class="keyword">this</span>.state;
    person.name = <span class="string">'sxt2'</span>;
    <span class="keyword">this</span>.setState({
      person
    })
  };
  render() {
    <span class="built_in">console</span>.log(<span class="string">'IndexPage render'</span>);
    <span class="keyword">const</span> { person } = <span class="keyword">this</span>.state;
    <span class="keyword">return</span> (
      &lt;div&gt;
        &lt;button onClick={<span class="keyword">this</span>.changeState}&gt;点击&lt;<span class="regexp">/button&gt;</span>
<span class="regexp">        &lt;Example person={person} /</span>&gt;
      &lt;<span class="regexp">/div&gt;</span>
<span class="regexp">    );</span>
<span class="regexp">  }</span>
<span class="regexp">}</span>
<span class="regexp">/</span><span class="regexp">/子组件</span>
<span class="regexp">import React, { Component } from 'react';</span>
<span class="regexp"></span>
<span class="regexp">class Example extends Component {</span>
<span class="regexp"></span>
<span class="regexp">  render() {</span>
<span class="regexp">    console.log('example render');</span>
<span class="regexp">    const { person } = this.props;</span>
<span class="regexp">    return(</span>
<span class="regexp">      &lt;div&gt;</span>
<span class="regexp">        {person.name}</span>
<span class="regexp">      &lt;/</span>div&gt;
    );
  }
}
</code></pre><h3 id="三-若是数组和对象等引用类型，则要引用不同，才会渲染"><a href="#三-若是数组和对象等引用类型，则要引用不同，才会渲染" class="headerlink" title="三.若是数组和对象等引用类型，则要引用不同，才会渲染"></a>三.若是数组和对象等引用类型，则要引用不同，才会渲染</h3><h3 id="四-如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间"><a href="#四-如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间" class="headerlink" title="四.如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间"></a>四.如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间</h3><h3 id="五-若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较"><a href="#五-若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较" class="headerlink" title="五.若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较"></a>五.若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较</h3><p>1.继承自<code>Component</code>的组件，若是<code>shouldComponentUpdate</code>返回<code>false</code>，就不会渲染了，继承自<code>PureComponent</code>的组件不用我们手动去判断<code>prop</code>和<code>state</code>，所以在<code>PureComponent</code>中使用<code>shouldComponentUpdate</code>会有如下警告:</p><p><strong>IndexPage has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.</strong></p><p>也是比较好理解的，就是不要在<code>PureComponent</code>中使用<code>shouldComponentUpdate</code>，因为根本没有必要.</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/02/06/一道赋值面试题引发的思考3【并发数控制】/" rel="next" title="一道赋值面试题引发的思考3【并发数控制】"><i class="fa fa-chevron-left"></i> 一道赋值面试题引发的思考3【并发数控制】</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/2019/02/18/用keep-alive优化页面性能/" rel="prev" title="用keep-alive优化页面性能">用keep-alive优化页面性能<i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/tx.jpg" alt="李斌"><p class="site-author-name" itemprop="name">李斌</p><p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">157</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">1</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/libin1991" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin"><i class="fa fa-fw fa-spinner"></i> juejin</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#解读-render-函数"><span class="nav-number">1.</span> <span class="nav-text">解读 render 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#当我们在说「render」时，我们在说什么？"><span class="nav-number">1.1.</span> <span class="nav-text">当我们在说「render」时，我们在说什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候会执行「render」？"><span class="nav-number">1.2.</span> <span class="nav-text">什么时候会执行「render」？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#状态更新时"><span class="nav-number">1.2.1.</span> <span class="nav-text">状态更新时</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-继承自-React-Component-的-class-组件更新状态时"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">a. 继承自 React.Component 的 class 组件更新状态时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-函数式组件更新状态时"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">b. 函数式组件更新状态时</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#父容器重新渲染时"><span class="nav-number">1.2.2.</span> <span class="nav-text">父容器重新渲染时</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在「render」过程中会发生什么？"><span class="nav-number">1.3.</span> <span class="nav-text">在「render」过程中会发生什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Diffing-【对比】"><span class="nav-number">1.3.1.</span> <span class="nav-text">Diffing 【对比】</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Reconciliation-【更新】"><span class="nav-number">1.3.2.</span> <span class="nav-text">Reconciliation 【更新】</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#开始我们的-Tips"><span class="nav-number">2.</span> <span class="nav-text">开始我们的 Tips</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#谨慎分配-state-以避免不必要的-render-调用"><span class="nav-number">2.1.</span> <span class="nav-text">谨慎分配 state 以避免不必要的 render 调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并状态更新"><span class="nav-number">2.2.</span> <span class="nav-text">合并状态更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-PureComponent-和-React-memo-以避免不必要的-render-调用"><span class="nav-number">2.3.</span> <span class="nav-text">使用 PureComponent 和 React.memo 以避免不必要的 render 调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么不让每个组件都继承-PureComponent-或者用-memo-包呢？"><span class="nav-number">2.3.1.</span> <span class="nav-text">为什么不让每个组件都继承 PureComponent 或者用 memo 包呢？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#嵌套对象的问题"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">嵌套对象的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#函数-props-的问题"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">函数 props 的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更好的-props-写法"><span class="nav-number">2.4.</span> <span class="nav-text">更好的 props 写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制更新"><span class="nav-number">2.5.</span> <span class="nav-text">控制更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PureComponent-Vs-Component"><span class="nav-number">3.</span> <span class="nav-text">PureComponent Vs Component</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件"><span class="nav-number">3.1.</span> <span class="nav-text">PureComponent不仅会影响本身，而且会影响子组件，所以PureComponent最佳情况是展示组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三-若是数组和对象等引用类型，则要引用不同，才会渲染"><span class="nav-number">3.2.</span> <span class="nav-text">三.若是数组和对象等引用类型，则要引用不同，才会渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四-如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间"><span class="nav-number">3.3.</span> <span class="nav-text">四.如果prop和state每次都会变，那么PureComponent的效率还不如Component，因为你知道的，进行浅比较也是需要时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五-若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较"><span class="nav-number">3.4.</span> <span class="nav-text">五.若有shouldComponentUpdate，则执行它，若没有这个方法会判断是不是PureComponent，若是，进行浅比较</span></a></li></ol></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">李斌</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script type="text/javascript" src="/js/src/clicklove.js"></script><script type="text/javascript" src="/js/src/clipboard.min.js"></script><script type="text/javascript" src="/js/src/clipboard-use.js"></script></body></html>
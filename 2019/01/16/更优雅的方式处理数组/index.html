<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="使用Set处理数组去重和元素剔除问题Set是es6新增的一种数据结构，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。它提供了4个语义化的API：  add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。">
<meta property="og:type" content="article">
<meta property="og:title" content="更优雅的方式处理数组">
<meta property="og:url" content="http://yoursite.com/2019/01/16/更优雅的方式处理数组/index.html">
<meta property="og:site_name" content="舞动乾坤">
<meta property="og:description" content="使用Set处理数组去重和元素剔除问题Set是es6新增的一种数据结构，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。它提供了4个语义化的API：  add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-22T13:56:19.371Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="更优雅的方式处理数组">
<meta name="twitter:description" content="使用Set处理数组去重和元素剔除问题Set是es6新增的一种数据结构，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。它提供了4个语义化的API：  add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/16/更优雅的方式处理数组/">





  <title>更优雅的方式处理数组 | 舞动乾坤</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
    	<div class="eevee"><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
    	<div id="sky">
				<div id="background" class="container">
			<!-- svg file -->
			<svg id="svgout" height="100%" width="100%" viewbox="0 0 550 400">
				<defs>
					<g id="bottomShadow">
						<path fill="#000000" stroke="none" d="
		M 270.5 225.95
		L 127.35 316.65 266.8 400 409.6 309.25 270.5 225.95 Z"/>
					</g>
					<g id="Layer52_0_FILL">
						<path class="topGrass" fill="#B9D668" stroke="none" d="
	M 397.85 229.3
	L 397.85 225.6 269.85 152 135.75 228.6 135.75 233.65 262.1 306.55 397.85 229.3 Z"/>
					</g>
					<g id="Layer51_0_FILL">
						<path class="leftSideGrass" fill="#6E9E4F" stroke="none" d="
	M 135.1 229.95
	L 135.1 256.85 262.1 328.4 262.1 301.85 135.1 229.95 Z"/>
					</g>
					<g id="Layer50_0_FILL">
						<path class="rightGrassTop" fill="#8CB154" stroke="none" d="
	M 397.85 225.95
	L 395.8 225.95 261.75 301.55 261.75 328.4 397.85 251.15 397.85 225.95 Z"/>
					</g>
					<g id="Layer48_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.45 282.4
	L 135.75 298.15 262.1 372.1 261.75 355.65 135.45 282.4 Z"/>
					</g>
					<g id="Layer47_0_FILL">
						<path class="middleLeftCrust" fill="#C77E61" stroke="none" d="
	M 135.1 270.3
	L 135.1 283.05 275.9 364.35 271.85 348.9 135.1 270.3 Z"/>
					</g>
					<g id="Layer46_0_FILL">
						<path class="crustLeftTop" fill="#955541" stroke="none" d="
	M 135.1 255.15
	L 135.1 270.3 262.1 343.55 262.1 328.05 135.1 255.15 Z"/>
					</g>
					<g id="Layer45_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 294.5
	L 397.5 277 261.75 355.3 261.75 372.75 397.5 294.5 Z"/>
					</g>
					<g id="Layer44_0_FILL">
						<path class="middleRightCrust" fill="#C89451" stroke="none" d="
	M 397.5 269.95
	L 397.15 266.6 262.1 343.2 262.1 355.95 397.5 279.7 397.5 269.95 Z"/>
					</g>
					<g id="Layer43_0_FILL">
						<path class="topRightCrust" fill="#A47237" stroke="none" d="
	M 397.5 266.6
	L 397.5 250.45 261.75 328.4 261.75 343.85 397.5 266.6 Z"/>
					</g>
					<g id="Layer41_0_FILL">
						<path class="greyRoad" fill="#B2B2B1" stroke="none" d="
	M 295.05 283.05
	Q 299.05 280.35 308.45 275.3 317.85 269.95 323.6 266.9
	L 268.8 233.65 338.05 191.35 309.15 174.55 177.75 254.5
	Q 191.55 262.2 198.25 266.25 204.65 269.95 209.7 271.95
	L 241.6 250.45 295.05 283.05 Z"/>
					</g>
					<g id="Layer40_0_FILL">
						<path fill="#FFFFFF" stroke="none" d="
	M 199.95 256.85
	Q 194.55 261.2 191.9 262.2
	L 194.9 263.9 200.95 259.2 199.95 256.85
	M 225.8 243.75
	L 224.8 241.75 211.05 250.8 212.05 252.8 225.8 243.75
	M 308.15 275.65
	L 296.7 266.6 295.35 268.6 306.8 277.7 308.15 275.65
	M 275.9 253.5
	L 274.55 255.5 285.95 264.55 287.3 262.55 275.9 253.5
	M 251.7 227.3
	L 250.7 225.25 236.9 234.35 237.9 236.35 251.7 227.3
	M 257.05 240.7
	L 254.05 240.7 268.8 249.8 269.5 247.75 257.05 240.7
	M 277.2 207.8
	L 263.45 216.85 264.45 218.9 278.25 209.8 277.2 207.8
	M 305.1 192.65
	L 304.1 190.65 290.3 199.75 291.35 201.75 305.1 192.65 Z"/>
					</g>
					<g id="Layer38_0_FILL">
						<path class="frontFascia" fill="#ECB27B" stroke="none" d="
	M 359.25 187.95
	L 346.4 174.95 333.85 202.9 359.25 187.95 Z"/>
					</g>
					<g id="Layer37_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 334 201.05
	L 334.35 232 359.2 217.55 359.25 187.95 334 201.05 Z"/>
					</g>
					<g id="Layer36_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 334.35 232.3
	L 334.35 205.1 305.1 191.35 305.1 216.85 334.35 232.3 Z"/>
					</g>
					<g id="Layer35_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 329.7 167.9
	L 331.05 167.9 344.55 176.7 347.85 176.7 363 192.25 363.15 189.55 350.65 176.7 350.55 176.7 334.25 167.5 334.25 159.1 329.7 159.1 329.7 164.9 322.65 160.95 322.3 162.15 329.7 167 329.7 167.9 Z"/>
					</g>
					<g id="Layer34_0_FILL">
						<path class="leftRoof" fill="#F2563B" stroke="none" d="
	M 334.05 207.05
	L 350.65 176.7 322.1 160.45 302.1 192.05 334.05 207.05 Z"/>
					</g>
					<g id="Layer30_0_FILL">
						<path id="windowFour" class="windows" stroke="none" fill="#975A42" d="
	M 341.35 203.3
	Q 340.9 203.45 340.5 203.8 340.1 204.2 339.85 204.75 339.7 205 339.7 205.3 339.6 205.75 339.7 206.1 339.7 206.15 339.7 206.2 339.8 206.5 340 206.8 340.55 207.4 341.45 207.4 342.35 207.4 343 206.8 343.4 206.5 343.65 206.1 343.85 205.75 343.95 205.3 344.05 204.4 343.55 203.8 343.3 203.45 343 203.3 342.65 203.15 342.2 203.15 341.8 203.15 341.35 203.3
	M 355.85 198.45
	Q 355.8 198.2 355.6 198 355.1 197.4 354.2 197.4 353.35 197.4 352.6 198 351.85 198.65 351.7 199.55 351.7 199.7 351.7 199.85 351.6 200.5 352 201.05 352.55 201.65 353.45 201.65 354.3 201.65 355.05 201.05 355.45 200.7 355.7 200.25 355.8 200.05 355.9 199.85 355.95 199.7 355.95 199.55 356.05 198.95 355.85 198.45 Z"/>
						<path class="door" fill="#B65041" stroke="none" d="
	M 351.95 211.2
	L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2
	M 351.2 211.2
	L 351.35 211.2 351.35 211.1 351.2 211.2 Z"/>
					</g>
					<g>
						<path id="Layer30_0_FILL" fill="#000000" fill-opacity="1" stroke="none" d="
	M 183.7 215.3
	L 183.7 215.6
	Q 187.25 231.75 212.25 234.35
	L 183.7 215.3 Z"/>
					</g>
					<g id="Layer29_0_FILL">
						<path fill="#000000" fill-opacity="0.4" stroke="none" d="
	M 305.1 216.85
	L 305.15 217.2
	Q 309.45 233.2 334.35 232.3
	L 305.1 216.85 Z"/>
					</g>
					<g id="Layer27_0_FILL">
						<path class="vegetation" fill="#78A950" stroke="none" d="
	M 177.45 231.65
	Q 175.75 235.35 181.8 239.35 185.5 235.7 185.15 231.3 182.8 230.65 181.45 234 179.45 231.3 177.45 231.65
	M 236.9 266.6
	Q 235.2 270.3 241.25 274.3 244.95 270.6 244.65 266.25 242.3 265.6 240.95 268.95 238.9 266.25 236.9 266.6
	M 254.7 277
	Q 253.05 280.7 259.1 284.75 262.75 281.05 262.45 276.65 260.1 276 258.75 279.35 256.7 276.65 254.7 277
	M 315.5 245.75
	Q 313.5 243.05 311.5 243.4 309.8 247.1 315.85 251.15 319.55 247.45 319.2 243.05 316.85 242.4 315.5 245.75
	M 295.35 232.65
	Q 293.7 236.35 299.75 240.4 303.45 236.7 303.1 232.3 300.75 231.65 299.4 235 297.4 232.3 295.35 232.65
	M 277.2 171.85
	Q 275.55 175.55 281.6 179.55 285.3 175.85 284.95 171.5 282.6 170.85 281.25 174.2 279.25 171.5 277.2 171.85 Z"/>
					</g>
					<g id="Layer26_0_FILL">
						<path class="treeWood" fill="#AE663D" stroke="none" d="
	M 175.1 177.55
	L 172.05 177.55 172.05 191.1 159.3 172.85
	Q 154.6 171.5 172.05 195.7
	L 172.05 212.5 175.1 212.5 175.1 177.55
	M 252.7 151.35
	L 249 151.35 249 176.9 252.7 176.9 252.7 151.35 Z"/>
					</g>
					<g id="Layer25_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 192.55 179.55
	Q 200.95 173.5 200.95 165.1 200.95 156.4 192.55 150 184.15 144.3 172.05 144.3 160.3 144.3 151.9 150 143.15 156.4 143.15 165.1 143.15 173.5 151.9 179.55 160.3 185.95 172.05 185.95 184.15 185.95 192.55 179.55
	M 236.25 106.65
	Q 230.2 116.05 230.2 129.15 230.2 142.25 236.25 151.35 242.3 160.75 250.7 160.75 258.75 160.75 264.8 151.35 270.85 142.25 270.85 129.15 270.85 116.05 264.8 106.65 258.75 97.6 250.7 97.6 242.3 97.6 236.25 106.65 Z"/>
					</g>
					<g id="Layer24_0_FILL">
						<path class="vegetation" fill="#77A951" stroke="none" d="
	M 158.3 221.9
	Q 160.65 221.9 161.95 220.2 163 219.55 163.3 218.55 164.65 218.9 166.35 218.9 170.05 218.9 172.4 216.2 175.1 213.85 175.1 210.15 175.1 206.45 172.4 203.75 170.05 201.4 166.35 201.4 162.65 201.4 159.95 203.75 157.6 206.45 157.6 210.15 157.6 210.8 157.6 211.15 155.95 211.5 154.6 212.5 152.9 214.15 152.9 216.55 152.9 218.9 154.6 220.2 156.25 221.9 158.3 221.9
	M 338.35 240.05
	Q 341.05 237.7 341.05 234 341.05 230.3 338.35 227.6 336 225.25 332.3 225.25 328.65 225.25 325.95 227.6 323.6 230.3 323.6 234 323.6 237.7 325.95 240.05 328.65 242.75 332.3 242.75 336 242.75 338.35 240.05 Z"/>
					</g>
					<g id="Layer22_0_FILL">
						<path class="rightRoof" fill="#D05041" stroke="none" d="
	M 220 173.85
	L 236.8 186.7 264.35 171.15 244.5 159.55 220 173.85 Z"/>
					</g>
					<g id="Layer21_0_FILL">
						<path class="leftWall" fill="#C57F42" stroke="none" d="
	M 212.25 191.35
	L 183.35 172.3 183.7 215.3 212.25 234.35 212.25 191.35 Z"/>
					</g>
					<g id="Layer20_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 192.1 149.85
	L 236.45 174.8 243.1 171.4
	Q 220.05 150.55 196.3 139.95
	L 192.1 149.85 Z"/>
					</g>
					<g id="Layer19_0_FILL">
						<path class="frontFascia" fill="#EBB17B" stroke="none" d="
	M 226.85 160.95
	L 212 190.6 229.75 192.6 239.75 172.85 226.85 160.95 Z"/>
					</g>
					<g id="Layer18_0_FILL">
						<path class="frontWall" fill="#EFA258" stroke="none" d="
	M 240.15 172.65
	L 211.9 191.6 212.25 233.65 264.35 201.7 264.35 170.8 240.8 184.45 240.15 172.65 Z"/>
					</g>
					<g id="Layer17_0_FILL">
						<path class="rightRoof" fill="#EF4427" stroke="none" d="
	M 210.9 142.2
	L 205.9 142.2 205.9 152.65 210.9 152.65 210.9 142.2 Z"/>
					</g>
					<g>
						<path id="Layer16_0_FILL" class="leftRoof" fill="#F2563B" stroke="none" d="
	M 210.25 195.5
	L 227.4 160.95 195.45 141.35 177.65 175.85 210.25 195.5 Z"/>
					</g>
					<g>
						<path id="sun" fill="#E3BD0E" stroke="none" d="
	M 257.05 15.95
	Q 251.7 15.95 248 19.65 244.3 23.35 244.3 28.7 244.3 34.1 248 37.8 251.7 41.5 257.05 41.5 262.45 41.5 266.15 37.8 269.85 34.1 269.85 28.7 269.85 23.35 266.15 19.65 262.45 15.95 257.05 15.95 Z"/>
					</g>
					<g id="Layer8_0_FILL">
						<path fill="#975A42" stroke="none" d="
	M 238.45 189.65
	Q 238.295703125 189.362109375 238.05 189.1 237.35 188.3 236.2 188.3 235.05 188.3 234.15 189.1 233.3 189.9 233.2 191.05 233.1 192.2 233.8 193 234.55 193.8 235.7 193.8 236.85 193.8 237.7 193 238.1970703125 192.558203125 238.45 192 238.6552734375 191.56484375 238.7 191.05 238.7671875 190.276953125 238.45 189.65
	M 220.55 197.55
	Q 220 197.55 219.5 197.75 218.95 197.95 218.5 198.35 217.933203125 198.8833984375 217.7 199.55 217.5833984375 199.916796875 217.55 200.3 217.4923828125 200.96171875 217.7 201.5 217.852734375 201.9103515625 218.15 202.25 218.95 203.05 220.1 203.05 221.25 203.05 222.05 202.25 222.95 201.45 223.05 200.3 223.15 199.15 222.4 198.35 222.05 197.95 221.65 197.75 221.15 197.55 220.55 197.55 Z"/>
					</g>
					<g id="Layer7_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 233.55 206.75
	L 225.9 211.95 226.25 225.5 233.95 220.35 233.55 206.75 Z"/>
					</g>
					<g>
						<path id="windowOne" class="windows" fill="#975A42" stroke="none" d="
	M 188.65 198.4
	L 188.8 204.1 198.65 210.45 198.55 204.75 188.65 198.4
	M 208.45 216.8
	L 208.35 211.1 198.55 204.75 198.65 210.45 208.45 216.8
	M 188.8 204.1
	L 188.95 209.8 198.8 216.15 198.65 210.45 188.8 204.1
	M 208.6 222.5
	L 208.45 216.8 198.65 210.45 198.8 216.15 208.6 222.5 Z"/>
					</g>
					<g>
						<path id="windowThree" class="windows" fill="#975A42" stroke="none" d="
	M 311.7 214.1
	L 318.55 217.55 318.45 211.9 311.6 208.45 311.7 214.1
	M 325.4 221
	L 325.25 215.35 318.45 211.9 318.55 217.55 325.4 221
	M 318.4 206.2
	L 311.5 202.75 311.6 208.45 318.45 211.9 318.4 206.2
	M 325.25 215.35
	L 325.2 209.7 318.4 206.2 318.45 211.9 325.25 215.35 Z"/>
					</g>
					<g id="Layer2_0_FILL">
						<path class="door" fill="#B65041" stroke="none" d="
	M 259.7 183.25
	L 244.6 191.9 244.6 213.8 259.7 204.55 259.7 183.25 Z"/>
					</g>
					<path id="windowTwo" fill="#975A42" class="windows" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" d="
	M 223.05 200.3
	Q 222.95 201.45 222.05 202.25 221.25 203.05 220.1 203.05 218.95 203.05 218.15 202.25 217.852734375 201.9103515625 217.7 201.5 217.4923828125 200.96171875 217.55 200.3 217.5833984375 199.916796875 217.7 199.575 217.933203125 198.8833984375 218.5 198.35 218.95 197.95 219.5 197.75 220 197.55 220.55 197.55 221.15 197.55 221.65 197.75 222.05 197.95 222.4 198.35 223.15 199.15 223.05 200.3 Z
	M 238.7 191.05
	Q 238.6552734375 191.56484375 238.45 192 238.1970703125 192.558203125 237.7 193 236.85 193.8 235.7 193.8 234.55 193.8 233.8 193 233.1 192.2 233.2 191.05 233.3 189.9 234.15 189.1 235.05 188.3 236.2 188.3 237.35 188.3 238.05 189.1 238.295703125 189.362109375 238.45 189.65 238.7671875 190.276953125 238.7 191.05 Z"/>
					<path fill="#F2563B" stroke="none" d=" M 351.95 211.2 L 351.8 211.2 346.05 215.1 346.05 225.2 351.95 221.6 351.95 211.2 Z"/>
					<path id="Layer6_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 198.55 204.75
	L 208.35 211.1 208.45 216.8 208.6 222.5 198.8 216.15 188.95 209.8 188.8 204.1 188.65 198.4 198.55 204.75 198.65 210.45 208.45 216.8
	M 198.8 216.15
	L 198.65 210.45 188.8 204.1"/>
					<path id="Layer5_0_1_STROKES" class="windowRims" stroke="#AE663D" stroke-width="1" stroke-linejoin="round" stroke-linecap="round" fill="none" d="
	M 325.25 215.35
	L 325.4 221 318.55 217.55 311.7 214.1 311.6 208.45 311.5 202.75 318.4 206.2 325.2 209.7 325.25 215.35 318.45 211.9 318.55 217.55
	M 318.4 206.2
	L 318.45 211.9 311.6 208.45"/>
				</defs>
				<g id="shadow">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use xlink:href="#bottomShadow"/>
					</g>
				</g>
				<g transform="matrix( 1, 0, 0, 1, 0,0) ">
					<use xlink:href="#sun"/>
				</g>
				<g id="earth">
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer52_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer51_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer50_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer48_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer47_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer46_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer45_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer44_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer43_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer41_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer40_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer38_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer37_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer36_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer35_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer34_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowFour"/>
						<use class="element" xlink:href="#Layer32_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer30_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer27_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer26_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer25_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer24_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer22_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer21_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer20_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer19_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer18_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer17_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer16_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer8_0_FILL"/>
						<use class="element" xlink:href="#windowTwo"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer7_0_FILL"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowOne"/>
						<use class="element" xlink:href="#Layer6_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#windowThree"/>
						<use class="element" xlink:href="#Layer5_0_1_STROKES"/>
					</g>
					<g transform="matrix( 1, 0, 0, 1, 0,0) ">
						<use class="element" xlink:href="#Layer2_0_FILL"/>
					</g>
				</g>
			</svg>
			<! -- End of SVG file -->
			<! -- Moon/Sun Toggle -->
			<div id="toggleButton" class="day-toggle">
				<div class="sun-icon"></div>
				<label class="switch">
            <input id="toggleCheckbox" type="checkbox">
            <div class="slider"></div>
        </label>
				<div class="cloud-icon"></div>
			</div>
			<! -- Moon/Sun Toggle -->
			<! -- End of Container -->
		</div>
			</div>
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">舞动乾坤</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">星光不问赶路人 岁月不负有心人</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/16/更优雅的方式处理数组/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="李斌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="舞动乾坤">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">更优雅的方式处理数组</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-16T23:23:17+08:00">
                2019-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="使用Set处理数组去重和元素剔除问题"><a href="#使用Set处理数组去重和元素剔除问题" class="headerlink" title="使用Set处理数组去重和元素剔除问题"></a>使用<code>Set</code>处理数组去重和元素剔除问题</h3><p><code>Set</code>是es6新增的一种<strong>数据结构</strong>，它和数组非常相似，但是成员的值都是唯一的，没有重复的值。它提供了4个语义化的API：</p>
<ol>
<li><code>add(value)</code>：添加某个值，返回Set结构本身。</li>
<li><code>delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>has(value)</code>：返回一个布尔值，表示该值是否为Set的成员。</li>
<li><code>clear()</code>：清除所有成员，没有返回值。</li>
</ol>
<blockquote>
<p>参考自@阮一峰 老师的<a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fset-map" target="_blank" rel="noopener">《ECMAScript 6 入门》</a></p>
</blockquote>
<p>那么我们可以用<code>Set</code>来干嘛呢？</p>
<p>第一个用法，数组去重。对于一个一维数组，我们可以先把它转化成<code>Set</code>，再配合<code>...</code>解构运算符重新转化为数组，达到去重的目的。请看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 1, 2, 2, 3, 4, 5, 5]</span><br><span class="line"></span><br><span class="line">const newArr = [...new Set(arr)]</span><br><span class="line"></span><br><span class="line">console.log(newArr)</span><br><span class="line"></span><br><span class="line">// [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p>
<p>值得注意的是，这个方法不能对元素为“对象”的数组奏效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const arr = [&#123; name: &apos;Alice&apos;, age: 12 &#125;, &#123; name: &apos;Alice&apos;, age: 12 &#125;, &#123; name: &apos;Bob&apos;, age: 13 &#125;]</span><br><span class="line"></span><br><span class="line">const newArr = [...new Set(arr)]</span><br><span class="line"></span><br><span class="line">console.log(newArr)</span><br><span class="line"></span><br><span class="line">// [&#123; name: &apos;Alice&apos;, age: 12 &#125;, &#123; name: &apos;Alice&apos;, age: 12 &#125;, &#123; name: &apos;Bob&apos;, age: 13 &#125;]</span><br></pre></td></tr></table></figure></p>
<p>这是因为<code>Set</code>判断元素是否重复的办法类似于<code>===</code>运算符，两个对象总是不相等的。</p>
<p>除了去重，<code>Set</code>提供的<code>delete()</code>方法也是非常实用。在以往的做法中，如果要删除数组中指定的元素，我们需要先获取该元素所在下标，然后通过<code>splice()</code>方法去删除对应下标的元素，在理解上容易引起混乱：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 我想删除数组当中值为2的元素const arr = [1, 2, 3]</span><br><span class="line">const index = arr.indexOf(2)</span><br><span class="line">if (index !== -1) &#123;</span><br><span class="line">    arr.splice(index, 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(arr)</span><br><span class="line"></span><br><span class="line">// [1, 3]</span><br></pre></td></tr></table></figure></p>
<p>使用<code>Set</code>就清晰多了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1, 2, 3]</span><br><span class="line">const set = newSet(arr)</span><br><span class="line">set.delete(2)</span><br><span class="line">arr = [...set]</span><br><span class="line"></span><br><span class="line">console.log(arr)</span><br><span class="line"></span><br><span class="line">// [1, 3]</span><br></pre></td></tr></table></figure></p>
<h3 id="使用map-方法和对象解构语法提取字段"><a href="#使用map-方法和对象解构语法提取字段" class="headerlink" title="使用map()方法和对象解构语法提取字段"></a>使用<code>map()</code>方法和对象解构语法提取字段</h3><p>请求后台接口返回的数据中，很可能会遇到下面这种数据格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">studentInfo = [</span><br><span class="line">  &#123; name: &apos;Alice&apos;, age: 18, no: 2 &#125;,</span><br><span class="line">  &#123; name: &apos;Bob&apos;, age: 16, no: 5 &#125;,</span><br><span class="line">  &#123; name: &apos;Candy&apos;, age: 17, no: 3 &#125;,</span><br><span class="line">  &#123; name: &apos;Den&apos;, age: 18, no: 4 &#125;,</span><br><span class="line">  &#123; name: &apos;Eve&apos;, age: 16, no: 1 &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>当我们要获取姓名列表、年龄列表和编号列表的时候，我们可以通过<code>map()</code>再配合对象的解构语法方便快捷地进行处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const nameList = studentInfo.map((&#123; name &#125;) =&gt; name)</span><br><span class="line">const ageList = studentInfo.map((&#123; age &#125;) =&gt; age)</span><br><span class="line">const noList = studentInfo.map((&#123; no &#125;) =&gt; no)</span><br><span class="line"></span><br><span class="line">// nameList: [ &apos;Alice&apos;, &apos;Bob&apos;, &apos;Candy&apos;, &apos;Den&apos;, &apos;Eve&apos; ]// ageList: [ 18, 16, 17, 18, 16 ]// noList: [ 2, 5, 3, 4, 1 ]</span><br></pre></td></tr></table></figure></p>
<h3 id="使用filter-方法和对象解构语法过滤数组"><a href="#使用filter-方法和对象解构语法过滤数组" class="headerlink" title="使用filter()方法和对象解构语法过滤数组"></a>使用<code>filter()</code>方法和对象解构语法过滤数组</h3><p>接上上面的例子，如果我想获取一个“年龄小于等于17岁”的新列表，应该怎么做呢？类似<code>map()</code>方法，我们可以用<code>filter()</code>方法进行过滤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const newStudentInfo = studentInfo.filter((&#123; age &#125;) =&gt; &#123;</span><br><span class="line">  return age &lt;= 17</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">newStudentInfo: [</span><br><span class="line">  &#123; name: &apos;Bob&apos;, age: 16, no: 5 &#125;,</span><br><span class="line">  &#123; name: &apos;Candy&apos;, age: 17, no: 3 &#125;,</span><br><span class="line">  &#123; name: &apos;Eve&apos;, age: 16, no: 1 &#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<h3 id="借助includes-方法求两个数组的差集"><a href="#借助includes-方法求两个数组的差集" class="headerlink" title="借助includes()方法求两个数组的差集"></a>借助<code>includes()</code>方法求两个数组的差集</h3><p>假设我们有以下两个数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, &#123;s:3&#125;, &#123;s:4&#125;, &#123;s:5&#125;]</span><br><span class="line">var b = [&#123;s:2&#125;, &#123;s:3&#125;, &#123;s:4&#125;, &apos;a&apos;]</span><br></pre></td></tr></table></figure></p>
<p>我们应该如何找到它们的差集呢？传统的方法可能需要把它们以Object形式hash化，但其实我们可以通过<code>.includes()</code>方法更加优雅方便地找出差集，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, &#123;s:3&#125;, &#123;s:4&#125;, &#123;s:5&#125;].map(item =&gt;JSON.stringify(item))</span><br><span class="line">var b = [&#123;s:2&#125;, &#123;s:3&#125;, &#123;s:4&#125;, &apos;a&apos;].map(item =&gt;JSON.stringify(item))</span><br><span class="line"></span><br><span class="line">var diff = a.concat(b)</span><br><span class="line">            .filter(v =&gt; !a.includes(v) || !b.includes(v))</span><br><span class="line">            .map(item =&gt;JSON.parse(item))</span><br><span class="line">            </span><br><span class="line">// diff: [1, 2, &#123;s:5&#125;, &#123;s:2&#125;, &quot;a&quot;]</span><br></pre></td></tr></table></figure></p>
<p>至于为什么要<code>JSON.stringify()</code>，是因为要对比两个“对象元素”是否相等，是无法直接以“对象”形式比较的（永远返回不相等）。</p>
<hr>
<h3 id="Array-includes-与条件判断"><a href="#Array-includes-与条件判断" class="headerlink" title="Array.includes 与条件判断"></a>Array.includes 与条件判断</h3><p>一般我们判断或用 ||<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// condition</span><br><span class="line">function test(fruit) &#123;</span><br><span class="line">  if (fruit == &quot;apple&quot; || fruit == &quot;strawberry&quot;) &#123;</span><br><span class="line">    console.log(&quot;red&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们有更多水果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function test(fruit) &#123;</span><br><span class="line">  const redFruits = [&quot;apple&quot;, &quot;strawberry&quot;, &quot;cherry&quot;, &quot;cranberries&quot;];</span><br><span class="line"></span><br><span class="line">  if (redFruits.includes(fruit)) &#123;</span><br><span class="line">    console.log(&quot;red&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Set-与去重"><a href="#Set-与去重" class="headerlink" title="Set 与去重"></a>Set 与去重</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。</p>
<p>数组去重<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const arr = [3, 5, 2, 2, 5, 5];</span><br><span class="line">const unique = [...new Set(arr)];</span><br><span class="line">// [3,5,2]</span><br></pre></td></tr></table></figure></p>
<p>Array.from 方法可以将 Set 结构转为数组。我们可以专门编写使用一个去重的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function unique(array) &#123;</span><br><span class="line">  return Array.from(new Set(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unique([1, 1, 2, 3]); // [1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p><strong>字符去重</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str = [...new Set(&quot;ababbc&quot;)].join(&quot;&quot;);</span><br><span class="line">console.log(str);</span><br><span class="line">// &apos;abc&apos;</span><br></pre></td></tr></table></figure></p>
<p>另外 Set 是如此强大，因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a = new Set([1, 2, 3]);</span><br><span class="line">let b = new Set([4, 3, 2]);</span><br><span class="line"></span><br><span class="line">// 并集</span><br><span class="line">let union = new Set([...a, ...b]);</span><br><span class="line">// Set &#123;1, 2, 3, 4&#125;</span><br><span class="line"></span><br><span class="line">// 交集</span><br><span class="line">let intersect = new Set([...a].filter(x =&gt; b.has(x)));</span><br><span class="line">// set &#123;2, 3&#125;</span><br><span class="line"></span><br><span class="line">// 差集</span><br><span class="line">let difference = new Set([...a].filter(x =&gt; !b.has(x)));</span><br><span class="line">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Map-与字典类型数据"><a href="#Map-与字典类型数据" class="headerlink" title="Map 与字典类型数据"></a>Map 与字典类型数据</h3><p>一般而已，JavaScript 实现字典数据是基于 Object 对象。但是 JavaScript 的对象的键只能是字符串。对于编程来说有很多不便。 ES6 提供了 Map 数据结构。它类似于 Object 对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值，字符串、数值、布尔值、数组、对象等等都可以当作键。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const resultMap = new Map()</span><br><span class="line">  .set(-1, &#123;text:&apos;小于&apos;,color:&apos;yellow&apos;)</span><br><span class="line">  .set(0, &#123;text:&apos;等于&apos;,color:&apos;black&apos;)</span><br><span class="line">  .set(1, &#123;text:&apos;大于&apos;,color:&apos;green&apos;)</span><br><span class="line">  .set(null,&#123;text:&apos;没有物品&apos;,color:&apos;red&apos;&#125;)</span><br><span class="line"></span><br><span class="line">let state = resultMap.get(null)</span><br><span class="line">// &#123;text:&apos;没有物品&apos;,color:&apos;red&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>Map 的遍历顺序就是插入顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([[&quot;F&quot;, &quot;no&quot;], [&quot;T&quot;, &quot;yes&quot;]]);</span><br><span class="line"></span><br><span class="line">for (let key of map.keys) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;F&quot;</span><br><span class="line">// &quot;T&quot;</span><br><span class="line"></span><br><span class="line">for (let value of map.value()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">// &quot;no&quot;</span><br><span class="line">// &quot;yes&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="函数式的方式处理数据"><a href="#函数式的方式处理数据" class="headerlink" title="函数式的方式处理数据"></a>函数式的方式处理数据</h3><p>按照我的理解，函数式编程主张函数必须接受至少一个参数并返回一个值。所以所有的关于数据的操作，都可以用函数式的方式处理。</p>
<p>假设我们有这样的需求，需要先把数组 foo 中的对象结构更改，然后从中挑选出一些符合条件的对象，并且把这些对象放进新数组 result 里。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">let foo = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;Stark&quot;,</span><br><span class="line">    age: 21</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;Jarvis&quot;,</span><br><span class="line">    age: 20</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;Pepper&quot;,</span><br><span class="line">    age: 16</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">//我们希望得到结构稍微不同，age大于16的对象：</span><br><span class="line">let result = [</span><br><span class="line">  &#123;</span><br><span class="line">    person: &#123;</span><br><span class="line">      name: &quot;Stark&quot;,</span><br><span class="line">      age: 21</span><br><span class="line">    &#125;,</span><br><span class="line">    friends: []</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    person: &#123;</span><br><span class="line">      name: &quot;Jarvis&quot;,</span><br><span class="line">      age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    friends: []</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>从直觉上我们很容易写出这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let result = [];</span><br><span class="line"></span><br><span class="line">//有时甚至是普通的for循环</span><br><span class="line">foo.forEach(function(person)&#123;</span><br><span class="line">    if(person.age &gt; 16)&#123;</span><br><span class="line">        let newItem = &#123;</span><br><span class="line">            person: person,</span><br><span class="line">            friends: [];</span><br><span class="line">        &#125;;</span><br><span class="line">        result.push(newItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>使用函数式的写法，可以优雅得多<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let result = foo</span><br><span class="line">  .filter(person =&gt; person.age &gt; 16)</span><br><span class="line">  .map(person =&gt; (&#123;</span><br><span class="line">    person: person,</span><br><span class="line">    friends: []</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure></p>
<p>数组求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let foo = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">//不优雅</span><br><span class="line">function sum(arr) &#123;</span><br><span class="line">  let x = 0;</span><br><span class="line">  for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    x += arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">sum(foo); // =&gt; 15</span><br><span class="line"></span><br><span class="line">//优雅</span><br><span class="line">foo.reduce((a, b) =&gt; a + b); // =&gt; 15</span><br></pre></td></tr></table></figure></p>
<h3 id="compose-与函数组合"><a href="#compose-与函数组合" class="headerlink" title="compose 与函数组合"></a>compose 与函数组合</h3><p>以下代码称为组合 compose<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const compose = function(f, g) &#123;</span><br><span class="line">  return function(x) &#123;</span><br><span class="line">    return f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于函数式编程大行其道，所以现在将会在 JavaScript 代码看到大量的箭头()=&gt;()=&gt;()=&gt;的代码。</p>
<p>ES6 版本 compose<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const compose = (f, g) =&gt; x =&gt; f(g(x));</span><br></pre></td></tr></table></figure></p>
<p>在 compose 的定义中， g 将先于 f 执行，因此就创建了一个从右到左的数据 流。这样做的可读性远远高于嵌套一大堆的函数调用.</p>
<p>我们选择一些函数，让它们结合，生成一个崭新的函数。</p>
<p>reverse 反转列表， head 取列表中的第一个元素；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const head = arr =&gt; arr[0];</span><br><span class="line">const reverse = arr =&gt; [].concat(arr).reverse();</span><br><span class="line"></span><br><span class="line">const last = compose(head, reverse);</span><br><span class="line">last([&quot;jumpkick&quot;, &quot;roundhouse&quot;, &quot;uppercut&quot;]);</span><br><span class="line">// &quot;uppercut&quot;</span><br></pre></td></tr></table></figure></p>
<p>但是我们这个这个compose不够完善，只能处理两个函数参数。redux源码有个很完备的compose函数，我们借鉴一下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function compose(...funcs)&#123;</span><br><span class="line">  if (funcs.length === 0)&#123;</span><br><span class="line">      return arg =&gt; arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (funcs.length === 1 )&#123;</span><br><span class="line">      return funcs[0]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return funcs.reduce((a,b)=&gt;(...args) =&gt; a(b(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了这个函数，我们可以随意组合无数个函数。现在我们增加需求，组合出一个lastAndUpper函数，内容是先reverse 反转列表， head 取列表中的第一个元素, 最后toUpperCase大写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const head = arr =&gt; arr[0];</span><br><span class="line">const reverse = arr =&gt; [].concat(arr).reverse();</span><br><span class="line">const toUpperCase = str =&gt; str.toUpperCase();</span><br><span class="line"></span><br><span class="line">const last = compose(head, reverse);</span><br><span class="line"></span><br><span class="line">const lastAndUpper = compose(toUpperCase, head, reverse,);</span><br><span class="line"></span><br><span class="line">console.log(last([&quot;jumpkick&quot;, &quot;roundhouse&quot;, &quot;uppercut&quot;]));</span><br><span class="line">// &quot;uppercut&quot;</span><br><span class="line">console.log(lastAndUpper([&quot;jumpkick&quot;, &quot;roundhouse&quot;, &quot;uppercut&quot;]))</span><br><span class="line">// &quot;UPPERCUT&quot;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>过去的一年， <code>JavaScript</code> 在持续变化着，其使用范围也越来越广。接下来，我将针对 <code>JavaScript</code> 的使用，列出 9 条 建议，以帮助你写出更加整洁高效的代码，成为更好的开发者。</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p><code>JavaScript</code> 极速发展的今天，回调地狱所产生的问题已不复存在。实际开发过程中我们应当尽量避免使用回调函数，除非为了遵守代码库规则或是维护性能。而解决回调地狱的一个常用方法为 <code>Promise</code>，但在代码量较多时使用会适得其反。于是提出了 <code>async / await</code>，使代码结构更加清晰明了，便于阅读和维护。一般而言，可以 <code>await</code> 任何 <code>Promise</code> 以防止正使用的库的返回值为 <code>Promise</code> ，也就是说 <code>async/await</code> 是 <code>Promise</code> 的语法糖，而且使用方法也十分简单：在函数前加 <code>async</code>。下面是一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function getData() &#123;</span><br><span class="line">    const result = await axios.get(&apos;https://dube.io/service/ping&apos;)</span><br><span class="line">    const data = result.data</span><br><span class="line">    console.log(&apos;data&apos;, data)</span><br><span class="line">    return data</span><br><span class="line">&#125;</span><br><span class="line">getData()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>await 只能使用在 async 函数中，不能用于全局作用域。</p>
</blockquote>
<blockquote>
<p><code>async/await</code> 是 ES2017 中引入的，使用时请进行转换。</p>
</blockquote>
<h3 id="异步控制流"><a href="#异步控制流" class="headerlink" title="异步控制流"></a>异步控制流</h3><p>当我们进行异步调用并获得返回值时，通常期望直接获取多个数据集，并且分别操作每个数据集。因此有了以下方式：</p>
<h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><p>假设页面上要展示 Pokemon 数据，可以通过 <code>axios</code> 获取它们的详细信息，我们所期望的是在得到返回值时立即更新页面中的所有数据，而不是等所有调用完成后才进行更新。</p>
<p>我们可以使用 <code>for...of</code> 解决上述问题。 首先循环遍历数组，并在每个循环内执行异步代码，当所有调用都成功时跳出循环。需要注意的是，这种方法虽然会对性能产生一些影响，但也不乏是一个很好的方法。</p>
<p>以下是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import axios from&apos;axios&apos;</span><br><span class="line">let myData = [&#123; id: 0 &#125;, &#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125;]</span><br><span class="line"></span><br><span class="line">async function fetchData(dataSet) &#123;</span><br><span class="line">    for (entry of dataSet) &#123;</span><br><span class="line">        const result = await axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`)</span><br><span class="line">        const newData = result.data</span><br><span class="line">        updateData(newData)</span><br><span class="line">        console.log(myData)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function updateData(newData) &#123;</span><br><span class="line">    myData = myData.map(el =&gt; &#123;</span><br><span class="line">        if (el.id === newData.id) return newData</span><br><span class="line">        return el</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fetchData(myData)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以将这些例子复制粘贴到编辑器中调试运行。</p>
</blockquote>
<blockquote>
<p>译者注：除了循环本身带来的性能问题之外，在使用 <code>async/await</code> 处理异步请求时也会对性能造成影响：如果使用过多 <code>await</code> 语句，而且候这些语句并不需要依赖于之前的语句，则会产生 <code>async/await</code> 地狱，影响性能。</p>
</blockquote>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><p>如果想要并行获取所有的 Pokemon，我们可以使用 <code>Promise.all</code> 方法来 <code>await</code> 所有 <code>Promise</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import axios from&apos;axios&apos;</span><br><span class="line">let myData = [&#123; id: 0 &#125;, &#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125;]</span><br><span class="line">async function fetchData(dataSet) &#123;</span><br><span class="line">    const pokemonPromises = dataSet.map(entry =&gt; &#123;</span><br><span class="line">        return axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`)</span><br><span class="line">    &#125;)</span><br><span class="line">    const results = awaitPromise.all(pokemonPromises)</span><br><span class="line">    results.forEach(result =&gt; &#123;</span><br><span class="line">        updateData(result.data)</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(myData)</span><br><span class="line">&#125;</span><br><span class="line">function updateData(newData) &#123;</span><br><span class="line">    myData = myData.map(el =&gt; &#123;</span><br><span class="line">        if (el.id === newData.id) return newData</span><br><span class="line">        return el</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fetchData(myData)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>for...of</code> 和 <code>Promise.all</code> 都是 <code>ES6+</code> 引入的，使用时请进行转换。</p>
</blockquote>
<h3 id="解构赋值-amp-默认值"><a href="#解构赋值-amp-默认值" class="headerlink" title="解构赋值 &amp; 默认值"></a>解构赋值 &amp; 默认值</h3><p>回到上个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const result = axios.get(`https://ironhack-pokeapi.herokuapp.com/pokemon/$&#123;entry.id&#125;`)</span><br><span class="line">const data = result.data</span><br></pre></td></tr></table></figure></p>
<p>现在有一种更简单的方法来实现它：通过解构赋值的方式从对象或数组中获取一个或多个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; data &#125; = await axios.get(...)</span><br></pre></td></tr></table></figure></p>
<p>也可对变量重命名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; data: newData &#125; = await axios.get(...)</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是在解构赋值时指定默认值，这样做可以确保代码不会出现 <code>undefined</code>，也避免手动检查变量的麻烦。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const &#123; id = 5 &#125; = &#123;&#125;</span><br><span class="line">console.log(id) // 5</span><br></pre></td></tr></table></figure></p>
<p>这些方法也可以用于函数参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function calculate(&#123; operands = [1, 2], type = &apos;addition&apos; &#125; = &#123;&#125;) &#123;</span><br><span class="line">    return operands.reduce((acc, val) =&gt; &#123;</span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case&apos;addition&apos;:</span><br><span class="line">                return acc + val</span><br><span class="line">            case&apos;subtraction&apos;:</span><br><span class="line">                return acc - val</span><br><span class="line">            case&apos;multiplication&apos;:</span><br><span class="line">                return acc * val</span><br><span class="line">            case&apos;division&apos;:</span><br><span class="line">                return acc / val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [&apos;addition&apos;, &apos;subtraction&apos;].includes(type) ? 0 : 1)</span><br><span class="line">&#125;</span><br><span class="line">console.log(calculate()) // 3 </span><br><span class="line">console.log(calculate(&#123; type: &apos;division&apos; &#125;)) // 0.5 </span><br><span class="line">console.log(calculate(&#123; operands: [2, 3, 4], type: &apos;multiplication&apos; &#125;)) // 24</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>ES6</code> 引入了解构赋值和默认值，使用时请进行转换。</p>
</blockquote>
<h3 id="真值和虚值"><a href="#真值和虚值" class="headerlink" title="真值和虚值"></a>真值和虚值</h3><p>当我们使用默认值时，通常要对现有值进行一系列判断，这种方法使代码变得异常繁琐，而现在我们可以真值（<code>Truthy</code>）和虚值（<code>Falsy</code>）的方式来改进它，不仅可以节省代码量，还使人更加信服。</p>
<p>以下是之前的做法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (myBool === true) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br><span class="line">// OR</span><br><span class="line">if (myString.length &gt; 0) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br><span class="line">// OR</span><br><span class="line">if (isNaN(myNumber)) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (myBool) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br><span class="line">// OR</span><br><span class="line">if (myString) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br><span class="line">// OR</span><br><span class="line">if (!myNumber) &#123;</span><br><span class="line">    console.log(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下为 <code>Falsy</code> 和 <code>Truthy</code> 的概念：</p>
<p><strong>False</strong></p>
<ul>
<li>长度为0的字符串</li>
<li>数字 <code>0</code></li>
<li><code>false</code></li>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>NaN</code></li>
</ul>
<p><strong>True</strong></p>
<ul>
<li>空数组</li>
<li>空对象</li>
<li>其他</li>
</ul>
<p>使用真值和虚值时没有确切的比较方式，这类似于我们进行比较时常使用双等号 <code>==</code> 而不是三等号 <code>===</code>。一般而言，这两者的判定方式相同，但在某些情况下也会遇到一些错误，对我来说主要为数字 <code>0</code>。</p>
<h3 id="逻辑运算符和三元运算符"><a href="#逻辑运算符和三元运算符" class="headerlink" title="逻辑运算符和三元运算符"></a>逻辑运算符和三元运算符</h3><p>逻辑运算符和三元运算符主要用于精简代码，有助于保持代码整洁度，但当他们形成运算链时会显得杂乱。</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符：和（<code>&amp;&amp;</code>）、或（<code>||</code>），一般用于比较两个表达式，返回值为： <code>true</code>、<code>false</code> 或着它的匹配值。如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(true &amp;&amp; true) // true</span><br><span class="line">console.log(false &amp;&amp; true) // false</span><br><span class="line">console.log(true &amp;&amp; false) // false</span><br><span class="line">console.log(false &amp;&amp; false) // false</span><br><span class="line">console.log(true || true) // true</span><br><span class="line">console.log(true || false) // true</span><br><span class="line">console.log(false || true) // true</span><br><span class="line">console.log(false || false) // false</span><br></pre></td></tr></table></figure></p>
<p>我们可以将逻辑运算符与真值和虚值的相关知识结合起来。</p>
<p>如果有表达式 <code>A</code> 和 <code>B</code>，针对两种逻辑运算符，有以下规则：</p>
<ul>
<li><code>A &amp;&amp; B</code> ： 当 <code>A</code> 为 <code>false</code> 时则直接返回 <code>A</code> 的值 ；否则返回 <code>B</code> 的值。</li>
<li><code>A || B</code> ： 当 <code>A</code> 为 <code>true</code> 时则直接返回 <code>A</code> 的值 ；否则返回 <code>B</code> 的值。</li>
</ul>
<blockquote>
<p>译者注：上述规则为逻辑运算中的短路现象。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(0 &amp;&amp; &#123; a: 1 &#125;) // 0</span><br><span class="line">console.log(false &amp;&amp; &apos;a&apos;) // false</span><br><span class="line">console.log(&apos;2&apos; &amp;&amp; 5) // 5</span><br><span class="line">console.log([] || false) // []</span><br><span class="line">console.log(NaN || null) // null</span><br><span class="line">console.log(true || &apos;a&apos;) // true</span><br></pre></td></tr></table></figure>
<h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>三元运算符与逻辑运算符非常相似，但有由三个部分组成：</p>
<ol>
<li>条件表达式：其结果为真值或是虚值</li>
<li>返回值 1：条件表达式为真值时，返回该值</li>
<li>返回值 2：条件表达式为虚值时，返回该值</li>
</ol>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const lang = &apos;German&apos;</span><br><span class="line">console.log(lang === &apos;German&apos; ? &apos;Hallo&apos; : &apos;Hello&apos;) // Hallo</span><br><span class="line">console.log(lang ? &apos;Ja&apos; : &apos;Yes&apos;) // Ja</span><br><span class="line">console.log(lang === &apos;French&apos; ? &apos;Bon soir&apos; : &apos;Good evening&apos;) // Good eveing</span><br></pre></td></tr></table></figure></p>
<h3 id="自判断链接"><a href="#自判断链接" class="headerlink" title="自判断链接"></a>自判断链接</h3><p>当访问某个嵌套对象的属性时，由于不能确定目标对象或者属性性是否存在，而需要进行一系列判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let data</span><br><span class="line">if (myObj &amp;&amp; myObj.firstProp &amp;&amp; myObj.firstProp.secondProp &amp;&amp; myObj.firstProp.secondProp.actualData)</span><br><span class="line">    data = myObj.firstProp.secondProp.actualData</span><br></pre></td></tr></table></figure></p>
<p>显而易见，代码变得非常臃肿难看。而自判断链接（<code>optional chaining</code>）的提出，正好可以满足对嵌套属性的校验需求，并使代码更加清晰整洁。如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const data = myObj?.firstProp?.secondProp?.actualData</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function safeGet(o, path)&#123;</span><br><span class="line">   </span><br><span class="line">   return path.split(&apos;.&apos;).reduce((o=&#123;&#125;,b)=&#123;   //用到参数默认值</span><br><span class="line">     </span><br><span class="line">      return o[b]  </span><br><span class="line">   &#125;,o)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>译者注：自判断链接： 检查一个对象上面是否存在某属性。</p>
<p>出现原因：调用某 <code>Object</code>属性链中的某个属性时，如果该属性不存在，会导致 <code>Cannot read property xxx of undefined</code> 错误。于是自判断链接 <code>?.</code> 出现。</p>
<p>使用方式：<code>obj?.a?.b?.c</code>。依次对代码中的属性进行判断，如果为 <code>null</code> 或者 <code>undefined</code> 时，结束调用，返回 <code>undefined</code> 。</p>
</blockquote>
<blockquote>
<p>目前，自判断链接还未纳入官方规范中，只处于第一阶段的实验特性。您需要在 <code>babelrc</code> 中添加 <code>@ babel / plugin-proposal-optional-chaining</code> 后方可使用它。</p>
</blockquote>
<h3 id="类属性-amp-绑定"><a href="#类属性-amp-绑定" class="headerlink" title="类属性 &amp; 绑定"></a>类属性 &amp; 绑定</h3><p><code>JavaScript</code> 中经常会用到绑定（<code>bind</code>）。<code>ES6</code> 规范中箭头函数的引入，使 <code>JavaScript</code> 开发人员有了一种将函数自动绑定到执行上下文中的常用方法，同时这种方法非常重要。</p>
<p>由于 <code>JavaScript</code> 中的类方法有特定的调用方式，因此当我们首次声明一个类时不能使用箭头函数，因此需要在其他位置进行函数绑定，比如在构造函数中（以 <code>React.js</code> 为例）。工作当中我总是先定义类方法再对其进行绑定，这种方法非常繁琐且容易出错。但如果使用 <code>class</code> 语法，我们可以通过箭头函数自动绑定它。以下是绑定 <code>_increaseCount</code> 的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">classCounterextendsReact.Component&#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123; count: 0 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;&lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;&lt;buttononClick=&#123;this._increaseCount&#125;&gt;Increase Count&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    _increaseCount = () =&gt; &#123;</span><br><span class="line">        this.setState(&#123; count: this.state.count + 1 &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>目前，类属性还未纳入官方规范中，只处于第三阶段的实验特性。您需要在 <code>babelrc</code> 中添加 <code>@ babel / plugin-proposal-class-properties</code> 后方可使用。</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/13/一道赋值面试题引发的思考2/" rel="next" title="一道赋值面试题引发的思考2">
                <i class="fa fa-chevron-left"></i> 一道赋值面试题引发的思考2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/25/async-await优雅的错误处理方法/" rel="prev" title="async/await优雅的错误处理方法">
                async/await优雅的错误处理方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/tx.jpg" alt="李斌">
            
              <p class="site-author-name" itemprop="name">李斌</p>
              <p class="site-description motion-element" itemprop="description">想要飞得高，那就把地平线忘掉</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">148</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">106</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/libin1991" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/57e737f6c4c971005f6bcd8d" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-spinner"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Set处理数组去重和元素剔除问题"><span class="nav-number">1.</span> <span class="nav-text">使用Set处理数组去重和元素剔除问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用map-方法和对象解构语法提取字段"><span class="nav-number">2.</span> <span class="nav-text">使用map()方法和对象解构语法提取字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用filter-方法和对象解构语法过滤数组"><span class="nav-number">3.</span> <span class="nav-text">使用filter()方法和对象解构语法过滤数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#借助includes-方法求两个数组的差集"><span class="nav-number">4.</span> <span class="nav-text">借助includes()方法求两个数组的差集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Array-includes-与条件判断"><span class="nav-number">5.</span> <span class="nav-text">Array.includes 与条件判断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-与去重"><span class="nav-number">6.</span> <span class="nav-text">Set 与去重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-与字典类型数据"><span class="nav-number">7.</span> <span class="nav-text">Map 与字典类型数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式的方式处理数据"><span class="nav-number">8.</span> <span class="nav-text">函数式的方式处理数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#compose-与函数组合"><span class="nav-number">9.</span> <span class="nav-text">compose 与函数组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#async-await"><span class="nav-number">10.</span> <span class="nav-text">async/await</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步控制流"><span class="nav-number">11.</span> <span class="nav-text">异步控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for…of"><span class="nav-number">11.1.</span> <span class="nav-text">for…of</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Promise-all"><span class="nav-number">11.2.</span> <span class="nav-text">Promise.all</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解构赋值-amp-默认值"><span class="nav-number">12.</span> <span class="nav-text">解构赋值 &amp; 默认值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#真值和虚值"><span class="nav-number">13.</span> <span class="nav-text">真值和虚值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑运算符和三元运算符"><span class="nav-number">14.</span> <span class="nav-text">逻辑运算符和三元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑运算符"><span class="nav-number">15.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三元运算符"><span class="nav-number">16.</span> <span class="nav-text">三元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自判断链接"><span class="nav-number">17.</span> <span class="nav-text">自判断链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类属性-amp-绑定"><span class="nav-number">18.</span> <span class="nav-text">类属性 &amp; 绑定</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李斌</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/clicklove.js"></script>


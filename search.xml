<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剖析node的Common.JS]]></title>
    <url>%2F2018%2F10%2F27%2F%E5%89%96%E6%9E%90node%E7%9A%84Common-JS%2F</url>
    <content type="text"><![CDATA[Javascript最开始是怎样实现模块化呢？我们知道javascript最开始是面向过程的思维编程，随着代码越来越庞大、复杂，在这种实际遇到的问题中，大佬们逐渐把面向对象、模块化的思想用在javascript当中。 一开始，我们是把不同功能写在不同函数当中// 比如getCssAttr函数来获取Css属性，当我们需要获取Css属性的时候可以直接调用该方法 function getCssAttr(obj, attr) { if (obj.currentStyle) { return obj.currentStyle[attr]; } else { return window.getComputedStyle(obj, null)[attr]; } } // 比如toJSON函数能够把url的query转为JSON对象 function toJSON(str) { var obj = {}, allArr = [], splitArr = []; str = str.indexOf(&apos;?&apos;) &gt;= 0 ? str.substr(1) : str; allArr = str.split(&apos;&amp;&apos;); for (var i = 0; i &lt; allArr.length; i++) { splitArr = allArr[i].split(&apos;=&apos;); obj[splitArr[0]] = splitArr[1]; } return obj; } 这样getCssAttr函数和toJSON组成了模块，当需要使用的时候，直接调用即可，但是随着项目代码量越来越庞大和复杂，而且这种方式会对全局变量造成了污染。 为了解决上面的问题，会想到把这些方法、变量放到对象中let utils = new Object({ getCssAttr:function(){...}, toJSON:function(){...} }) 当需要调用相应函数时，我们通过对象调用即可，utils.getCssAttr()、utils.toJSON()，但是这样会存在一个问题，就是可以直接通过外部修改内部方法属性。 utils.getCssAttr = null 那么我们有办法让内部方法属性不被修改吗？答案是可以的，我们可以通过闭包的方式，使私有成员不暴露在外部。 let utils = (function(){ let getCssAttr = function(){...} let toJSON = function(){...} return { getCssAttr, toJSON } })() 这样的话，外部就无法改变内部的私有成员了。 CMD和AMD规范试想一下，如果一个项目，所有轮子都自己造，在现在追求敏捷开发的环境下，我们有必要所有轮子都自己造吗？一些常用通用的功能，是否可以提取出来，供大家使用，提高开发效率？ 正所谓，无规矩不成方圆，每个程序猿的代码风格肯定是有差异的，你写你的，我写我的，这样就很难流通了，但是如果大家都遵循一个规范编写代码，形成一个个模块，就显得非常重要了。 在这样的背景下，形成了两种规范，一种是以sea.js为代表的CMD规范，另外一种是以require.js为代表的AMD规范。 CMD规范（Common Module Definition 通用模块定义） AMD规范（Asynchronous Module Definition 异步模块定义） 在node.js中是遵循commonJS规范的，在对模块的导入是同步的，为什么这样说？因为在服务器中，模块都是存在本地的，即使要导入模块，也只是耗费了从硬盘读取模块的时间，而且可控。 但是在浏览器中，模块是需要通过网络请求获取的，如果是同步获取的话，那么网络请求的时间没办法保证，会造成浏览器假死的，但是异步的话，是不会阻塞主线程，所以不管是CMD还是AMD，都是属于异步的，CMD和AMD都是属于异步加载模块，当所需要依赖的模块加载完毕后，才通过一个回调函数，写我们所需要的业务逻辑。 CMD和AMD的异同 CMD是延迟执行，依赖就近，而AMD是提前执行，依赖前置（require2.0开始可以改成延迟执行），怎么理解呢？看看下面代码1234567891011121314// CMDdefine(function(require,exports,module)&#123; var a = require(&apos;./a&apos;) a.run() var b = require(&apos;./b&apos;) b.eat()&#125;)// AMDdefine([&apos;./a&apos;,&apos;./b&apos;],function(a,b)&#123; a.run() b.eat()&#125;) CMD,AMD执行对比 — CMD AMD 执行回调函数的时机 快 慢 执行回调函数内的业务 慢 快 node.js遵循的commonJs规范首先，我们来剖析一下commonJs的源码我们分别创建两个文件useModule.js、module.js，并且打上断点。12345678910111213// useModule.jslet utils = require(&apos;./module&apos;)utils = require(&apos;./module&apos;)utils.sayhello()// module.jslet utils = &#123; sayhello:function()&#123; console.log(&apos;hello swr&apos;) &#125;&#125;module.exports = utils 然后开始执行，我们首先会进入commonJs的源码了 在最上面可以看出是一个闭包的形式 123(function(exports,require,module,__filename,__dirname))&#123; //...&#125; ，这里可以看出__dirname和__filename并非是global上的属性，而是每个模块对应的路径。 而且我们在模块当中this并不是指向global的，而是指向module.exports，至于为什么会这样呢？下面会讲到。 在红框中，我们可以看到require函数，exports.requireDepth可以暂时不用管，是一个引用深度的变量，接下来我们往下看，return mod.require(path)，这里的mod就是每一个文件、模块，而里面都有一个require方法，接下来我们看看mod.require函数内部是怎么写的。进来后，我们会看到2个assert断言，用来判断path参数是否传递了，path是否字符串类型等等。 return Module._load(path,this,false)，path为我们传入的模块路径，this则是这个模块，false则不是主要模块，主要模块的意思是，如果a.js加载了b.js，那么a.js是主要模块，而b.js则是非主要模块。 接下来我们看看Module._load这个静态方法123456789101112131415161718192021222324252627282930313233Module._load = function(request, parent, isMain) &#123; // 计算绝对路径 var filename = Module._resolveFilename(request, parent); // 第一步：如果有缓存，取出缓存 var cachedModule = Module._cache[filename]; if (cachedModule) &#123; return cachedModule.exports; &#125; // 第二步：是否为内置模块 if (NativeModule.exists(filename)) &#123; return NativeModule.require(filename); &#125; // 第三步：生成模块实例，存入缓存 var module = new Module(filename, parent); Module._cache[filename] = module; // 第四步：加载模块 try &#123; module.load(filename); hadException = false; &#125; finally &#123; if (hadException) &#123; delete Module._cache[filename]; &#125; &#125; // 第五步：输出模块的exports属性 return module.exports;&#125;; var filename = Module._resolveFilename(request, parent, isMain)，这里的目的是解析出一个绝对路径，我们可以进去看看Module._resolveFilename函数是怎么写的123456789101112131415161718192021Module._resolveFilename = function(request, parent) &#123; // 第一步：如果是内置模块，不含路径返回 if (NativeModule.exists(request)) &#123; return request; &#125; // 第二步：确定所有可能的路径 var resolvedModule = Module._resolveLookupPaths(request, parent); var id = resolvedModule[0]; var paths = resolvedModule[1]; // 第三步：确定哪一个路径为真 var filename = Module._findPath(request, paths); if (!filename) &#123; var err = new Error(&quot;Cannot find module &apos;&quot; + request + &quot;&apos;&quot;); err.code = &apos;MODULE_NOT_FOUND&apos;; throw err; &#125; return filename;&#125;; 上面代码中，在 Module.resolveFilrename 方法内部，又调用了两个方法 Module.reqolveLookPaths()和 Module._findPath(),前者用来列出可能的路径，后者用来确认哪一个路径为真。有了可能的路径以后，下面就是 Module._findPath()的源码，用来确定到底哪一个是正确路径。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Module._findPath = function(request, paths) &#123; // 列出所有可能的后缀名：.js，.json, .node var exts = Object.keys(Module._extensions); // 如果是绝对路径，就不再搜索 if (request.charAt(0) === &apos;/&apos;) &#123; paths = [&apos;&apos;]; &#125; // 是否有后缀的目录斜杠 var trailingSlash = (request.slice(-1) === &apos;/&apos;); // 第一步：如果当前路径已在缓存中，就直接返回缓存 var cacheKey = JSON.stringify(&#123;request: request, paths: paths&#125;); if (Module._pathCache[cacheKey]) &#123; return Module._pathCache[cacheKey]; &#125; // 第二步：依次遍历所有路径 for (var i = 0, PL = paths.length; i &lt; PL; i++) &#123; var basePath = path.resolve(paths[i], request); var filename; if (!trailingSlash) &#123; // 第三步：是否存在该模块文件 filename = tryFile(basePath); if (!filename &amp;&amp; !trailingSlash) &#123; // 第四步：该模块文件加上后缀名，是否存在 filename = tryExtensions(basePath, exts); &#125; &#125; // 第五步：目录中是否存在 package.json if (!filename) &#123; filename = tryPackage(basePath, exts); &#125; if (!filename) &#123; // 第六步：是否存在目录名 + index + 后缀名 filename = tryExtensions(path.resolve(basePath, &apos;index&apos;), exts); &#125; // 第七步：将找到的文件路径存入返回缓存，然后返回 if (filename) &#123; Module._pathCache[cacheKey] = filename; return filename; &#125; &#125; // 第八步：没有找到文件，返回false return false;&#125;; 有时在项目代码中，需要调用模块的绝对路径，那么除了 module.filename ，Node 还提供一个 require.resolve 方法，供外部调用，用于从模块名取到绝对路径。1234567require.resolve = function(request) &#123; return Module._resolveFilename(request, self);&#125;;// 用法require.resolve(&apos;a.js&apos;)// 返回 /Users/danlan/workspace/node-stu/ree/a.js Module._resolveFilename函数也没什么好说的，就是判断各种情况，然后解析出一个绝对路径出来，我们跳出这个函数，回到Module._load中.然后我们看到var cachedModule = Module._cache[filename]，这是我们加载模块的缓存机制，就是说我们加载过一次模块后，会缓存到Module._cache这个对象中，并且是以filename作为键名，因为路径是唯一的，所以以路径作为唯一标识，如果已经缓存过，则会直接返回这个缓存过的模块。 NativeModule.nonInternalExists(filename)判断是否原生模块，是的话则直接返回模块。 经过上面两个判断，基本可以判定这个模块没被加载过，那么接下来看到var module = new Module(filename, parent)，创建了一个模块，我们看看Module这个构造函数有什么内容123456module.id 模块的识别符，通常是带有绝对路径的模块文件名。module.filename 模块的文件名，带有绝对路径。module.loaded 返回一个布尔值，表示模块是否已经完成加载。module.parent 返回一个对象，表示调用该模块的模块。module.children 返回一个数组，表示该模块要用到的其他模块。module.exports 表示模块对外输出的值。 下面是一个示例文件，最后一行输出module变量。 1234// example.jsvar jquery = require(&apos;jquery&apos;);exports.$ = jquery;console.log(module); 执行这个文件，命令行会输出如下信息。 12345678910111213141516171819&#123; id: &apos;.&apos;, exports: &#123; &apos;$&apos;: [Function] &#125;, parent: null, filename: &apos;/path/to/example.js&apos;, loaded: false, children: [ &#123; id: &apos;/path/to/node_modules/jquery/dist/jquery.js&apos;, exports: [Function], parent: [Circular], filename: &apos;/path/to/node_modules/jquery/dist/jquery.js&apos;, loaded: true, children: [], paths: [Object] &#125; ], paths: [ &apos;/home/user/deleted/node_modules&apos;, &apos;/home/user/node_modules&apos;, &apos;/home/node_modules&apos;, &apos;/node_modules&apos; ]&#125; 这里的id，实际上就是filename唯一路径，另外一个很重要的是this.exports，也就是将来用于暴露模块的。我们接着往下看，在创建一个实例后，接下来把这个实例存在缓存当中，Module._cache[filename] = module然后执行tryModuleLoad(module, filename)，这个函数非常重要，是用来加载模块的，我们看看是怎么写的 这里有个module.load，我们再往里面看看是怎么写的123456Module.prototype.load = function (filename) &#123; var extension = path.extname(filename) || &apos;js&apos; if(!Module._extensions[extensions]) extension = &apos;.js&apos; Module._extensions[extension](this, filename) this.loaded = true&#125; 兜兜转转，终于来到最核心的地方了this.paths = Module._nodeModulePaths(path.dirname(filename))，我们知道，我们安装npm包时，node会由里到外一层层找node_modules文件夹，而这一步，则是路径一层层丢进数组里，我们可以看看this.paths的数组 CommonJS 模块查找规范 新建一个b.js 1var a = require(&apos;./a.js&apos;) 运行一下： 123456789101112131415161718192021222324252627282930313233module.id: /Users/danlan/workspace/node-stu/ree/a.jsmodule.exports: &#123;&#125;module.parent: Module &#123; id: &apos;.&apos;, exports: &#123;&#125;, parent: null, filename: &apos;/Users/danlan/workspace/node-stu/ree/b.js&apos;, loaded: false, children: [ Module &#123; id: &apos;/Users/danlan/workspace/node-stu/ree/a.js&apos;, exports: &#123;&#125;, parent: [Circular], filename: &apos;/Users/danlan/workspace/node-stu/ree/a.js&apos;, loaded: false, children: [], paths: [Array] &#125; ], paths: [ &apos;/Users/danlan/workspace/node-stu/ree/node_modules&apos;, &apos;/Users/danlan/workspace/node-stu/node_modules&apos;, &apos;/Users/danlan/workspace/node_modules&apos;, &apos;/Users/danlan/node_modules&apos;, &apos;/Users/node_modules&apos;, &apos;/node_modules&apos; ] &#125;module.filename: /Users/danlan/workspace/node-stu/ree/a.jsmodule.loaded: falsemodule.children: []module.paths: [ &apos;/Users/danlan/workspace/node-stu/ree/node_modules&apos;, &apos;/Users/danlan/workspace/node-stu/node_modules&apos;, &apos;/Users/danlan/workspace/node_modules&apos;, &apos;/Users/danlan/node_modules&apos;, &apos;/Users/node_modules&apos;, &apos;/node_modules&apos; ] 举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。 12345/usr/local/lib/node/bar.js/home/user/projects/node_modules/bar.js/home/user/node_modules/bar.js/home/node_modules/bar.js/node_modules/bar.js 这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。 如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。 如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。 如果想得到require命令加载的确切文件名，使用require.resolve()方法。 目录的加载规则 在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。 12345// package.json&#123; &quot;name&quot; : &quot;some-library&quot;, &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125; 继续往下看，var extension = path.extname(filename) || &#39;.js&#39;是获取后缀名，如果没有后缀名的话，暂时默认添加一个.js后缀名。继续往下看，if (!Module._extensions[extension]) extension = &#39;.js&#39;是判断Module._extensions这个对象，是否有这个属性，如果没有的话，则让这个后缀名为.js继续往下看，Module._extensions[extension](this, filename)，根据后缀名，执行对应的函数，那么我们看一下Module._extensions对象有哪几个函数 从这里我们可以看到，Module._extensions中有3个函数，分别是.js、.json、.node函数，意思是根据不同的后缀名，执行不同的函数，来解析不同的内容，我们可以留意到读取文件都是用fs.readFileSync同步读取，因为这些文件都是保存在服务器硬盘中，读取这些文件耗费时间非常短，所以采用了同步而不是异步其中.json最为简单，读取出文件后，再通过JSON.parse把字符串转化为JSON对象，然后把结果赋值给module.exports接下来看看.js，也是一样先读取出文件内容，然后通过module._compile这个函数来解析.js的内容，我们看一下module._compile函数怎么写的 var wrapper = Module.wrap(content)这里对.js文件的内容进行了一层处理，我们可以看看Module.wrap怎么写的 在这里可以看出，NativeModule.wrapper数组中有两个数组成员，是不是看起来似曾相识？没错，这就是闭包的形式，而Module.wrap中，是直接把js文件的内容，和这个闭包拼接成一段字符串，对，就是在这里，把一个个模块，套一层闭包！实际上拼接出来的是 // 字符串 &quot;(function(exports,require,module,__filename,__dirname){ let utils = { sayhello:function(){ console.log(&apos;hello swr&apos;) } } })&quot; 我们跳出来，回到Module.prototype._compile看看，接下来看到var compiledWrapper = vm.runInThisContext(wrapper,{...})，12//虚拟机，帮我们创建一个黑箱执行代码，防止变量污染const vm = require(&quot;vm&quot;); 在nodejs中是通过vm这个虚拟机，执行字符串，而且这样的好处是使内部完全是封闭的，不会被外在变量污染，而在前端的字符串模板则是通过new Function()来执行字符串，达到不被外在变量污染 继续往下看，result = compiledWrapper.call(this.exports, this.exports, require, this,filename, dirname)，其中compiledWrapper就是我们通过vm虚拟机执行的字符串后返回的闭包，而且通过call来把这个模块中的this指向更改为当前模块，而不是全局的global，这里就是为什么我们在模块当中打印this时，指向的是当前的module.exports而不是global，然后后面依次把相应的参数传递过去 最终一层层跳出后Module._load中，最后是return module.exports，也就是说我们通过require导入的模块，取的是module.exports 通过剖析commonJs源码，我们收获了什么？ 懂得了模块加载的整个流程 第一步：解析出一个绝对路径,如果是核心模块，比如fs，就直接返回模块 第二步：如文件没添加后缀，则添加.js、.json、.node作为后缀，然后通过fs.existsSync来判断文件是否存在 .js 解析为JavaScript 文本文件 .json解析JSON对象 .node解析为二进制插件模块 第三步：到缓存中找该模块是否被加载过(如果是带有路径的如/,./等等，则拼接出一个绝对路径，然后先读取缓存require.cache再读取文件。如果没有加后缀，则自动加后缀然后一一识别。) 第四步：new一个模块实例 第五步：把模块存到缓存当中(首次加载后的模块会缓存在require.cache之中，所以多次加载require，得到的对象是同一个。) 第六步：根据后缀名，加载这个模块 在执行模块代码的时候，会将模块包装成如下模式，以便于作用域在模块范围之内。123 (function(exports, require, module, __filename, __dirname) &#123; // 模块的代码实际上在这里&#125;); 知道如何实现由里到外一层层查找node_modules 知道针对.js和.json是怎么解析的 .js是通过拼接字符串，形成一个闭包形式的字符串 .json则是通过JSON.parse转为JSON对象 知道如何执行字符串，并且不受外部变量污染 nodejs中通过vm虚拟机来执行字符串 123 let vm=require(&quot;vm&quot;) let a=&apos;console.log(&quot;a&quot;)&apos;vm.runInThisContext(a) 前端则是通过new Function()来执行字符串 12var f = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x+y&apos;); f( 3, 4 ) 知道为什么模块中的this指向的是this.exports而不是global 通过call把指针指向了this.exports 接下来，我们手写一个简陋版的commonJs源码commonJs其实在加载模块的时候，做了以下几个步骤 第一步：解析出一个绝对路径 第二步：如文件没添加后缀，则添加.js、.json、.node作为后缀，然后通过fs.existsSync来判断文件是否存在 第三步：到缓存中找该模块是否被加载过 第四步：new一个模块实例 第五步：把模块存到缓存当中 第六步：根据后缀名，加载这个模块 那么我们根据这几个步骤，来手写一下源码~ // module.js let utils = { sayhello: function () { console.log(&apos;hello swr&apos;) } } console.log(&apos;执行了&apos;) module.exports = utils 首先写出解析一个绝对路径以及如文件没添加后缀，则添加.js、.json作为后缀，然后通过fs.existsSync来判断文件是否存在（ .. 每个步骤我都会标识1、2、3… // useModule.js // 1.引入核心模块 let fs = require(&apos;fs&apos;) let path = require(&apos;path&apos;) // 3.声明一个Module构造函数 function Module(id) { this.id = id this.exports = {} // 将来暴露模块的内容 } // 8.支持的后缀名类型 Module._extensions = { &quot;.js&quot;:function(){}, &quot;.json&quot;:function(){} } // 5.解析出绝对路径，_resolveFilename是Module的静态方法 Module._resolveFilename = function (relativePath) { // 6.返回一个路径 let p = path.resolve(__dirname,relativePath) // 7.该路径是否存在文件，如果存在则直接返回 // 这种情况主要考虑用户自行添加了后缀名 // 如&apos;./module.js&apos;let exists = fs.existsSync(p) if(exists) return p // 9.如果relativePath传入的如&apos;./module&apos;，没有添加后缀 // 那么我们给它添加后缀，并且判断添加后缀后是否存在该文件 let keys = Object.keys(Module._extensions) let r = falsefor(let val of keys){ // 这里用for循环，是当找到文件后可以直接break跳出循环 let realPath = p + val // 拼接后缀 let exists = fs.existsSync(realPath) if(exists){ r = realPath break } } if(!r){ // 如果找不到文件，则抛出错误 throw new Error(&apos;file not exists&apos;) } return r } // 2.为了不与require冲突，这个函数命名为req // 传入一个参数p 路径 function req(p) { // 10.因为Module._resolveFilename存在找不到文件 // 找不到文件时会抛出错误，所以我们这里捕获错误 try { // 4.通过Module._resolveFilename解析出一个绝对路径 let filename = Module._resolveFilename(p) } catch (e) { console.log(e) } } // 导入模块，并且导入两次，主要是校验是否加载过一次后 // 在有缓存的情况下，会不会直接返回缓存的模块 // 为此特意在module.js中添加了console.log(&quot;执行了&quot;) // 来看打印了几次 let utils = req(&apos;./module&apos;) utils = req(&apos;./module&apos;) utils.sayhello() 然后到缓存中找该模块是否被加载过，如果没有加载过则new一个模块实例，把模块存到缓存当中，最后根据后缀名，加载这个模块（ .. 每个步骤我都会标识1、2、3… // useModule.js // 1.引入核心模块 let fs = require(&apos;fs&apos;) let path = require(&apos;path&apos;) // 3.声明一个Module构造函数 function Module(id) { this.id = id this.exports = {} // 将来暴露模块的内容 } // * 21.因为处理js文件时，需要包裹一个闭包，我们写一个数组 Module.wrapper = [ &quot;(function(exports,require,module){&quot;, &quot;\n})&quot; ] // * 22.通过Module.wrap包裹成闭包的字符串形式 Module.wrap = function(script){ return Module.wrapper[0] + script + Module.wrapper[1] } // 8.支持的后缀名类型 Module._extensions = { &quot;.js&quot;:function(module){ // * 20.其次看看js是如何处理的 let str = fs.readFileSync(module.id,&apos;utf8&apos;) // * 23.通过Module.wrap函数把内容包裹成闭包 let fnStr = Module.wrap(str) // * 24.引入vm虚拟机来执行字符串 let vm = require(&apos;vm&apos;) let fn = vm.runInThisContext(fnStr) // 让产生的fn执行，并且把this指向更改为当前的module.exports fn.call(this.exports,this.exports,req,module) }, &quot;.json&quot;:function(module){ // * 18.首先看看json是如何处理的 let str = fs.readFileSync(module.id,&apos;utf8&apos;) // * 19.通过JSON.parse处理，并且赋值给module.exports let json = JSON.parse(str) module.exports = json } } // * 15.加载 Module.prototype._load = function(filename){ // * 16.获取后缀名 let extension = path.extname(filename) // * 17.根据不同后缀名 执行不同的方法 Module._extensions[extension](this) } // 5.解析出绝对路径，_resolveFilename是Module的静态方法 Module._resolveFilename = function (relativePath) { // 6.返回一个路径 let p = path.resolve(__dirname,relativePath) // 7.该路径是否存在文件，如果存在则直接返回 // 这种情况主要考虑用户自行添加了后缀名 // 如&apos;./module.js&apos;let exists = fs.existsSync(p) if(exists) return p // 9.如果relativePath传入的如&apos;./module&apos;，没有添加后缀 // 那么我们给它添加后缀，并且判断添加后缀后是否存在该文件 let keys = Object.keys(Module._extensions) let r = falsefor(let val of keys){ // 这里用for循环，是当找到文件后可以直接break跳出循环 let realPath = p + val // 拼接后缀 let exists = fs.existsSync(realPath) if(exists){ r = realPath break } } if(!r){ // 如果找不到文件，则抛出错误 throw new Error(&apos;file not exists&apos;) } return r } // * 11.缓存对象 Module._cache = {} // 2.为了不与require冲突，这个函数命名为req // 传入一个参数p 路径 function req(p) { // 10.因为Module._resolveFilename存在找不到文件 // 找不到文件时会抛出错误，所以我们这里捕获错误 try { // 4.通过Module._resolveFilename解析出一个绝对路径 let filename = Module._resolveFilename(p) // * 12.判断是否有缓存，如果有缓存的话，则直接返回缓存 if(Module._cache[filename]){ // * 因为实例的exports才是最终暴露出的内容 return Module._cache[filename].exports } // * 13.new一个Module实例 let module = new Module(filename) // * 14.加载这个模块 module._load(filename) // * 25.把module存到缓存 Module._cache[filename] = module // * 26.返回module.exprots return module.exports } catch (e) { console.log(e) } } // 导入模块，并且导入两次，主要是校验是否加载过一次后 // 在有缓存的情况下，会不会直接返回缓存的模块 // 为此特意在module.js中添加了console.log(&quot;执行了&quot;) // 来看打印了几次 let utils = req(&apos;./module&apos;) utils = req(&apos;./module&apos;) utils.sayhello() 这样我们就完成了一个简陋版的commonJs，而且我们多次导入这个模块，只会打印出一次执行了，说明了只要缓存中有的，就直接返回，而不是重新加载这个模块这里建议大家一个步骤一个步骤去理解，尝试敲一下代码，这样感悟会更加深 那么为什么exports = xxx 却失效了呢？// 从上面源码我们可以看出，实际上 // exports = module.exports = {} // 但是当我们exports = {name:&quot;CommonJS&quot;}时， // require出来却获取不到这个对象，这是因为我们在上面源码中， // req函数（即require）内部return出的是module.exports，而不是exports， // 当我们exports = { name:&quot;CommonJS&quot; }时，实际上这个exports指向了一个新的对象， // 而不是module.exports // 那么我们的exports是不是多余的呢？肯定不是多余的，我们可以这样写 exports.name = &quot;CommonJS&quot; // 这样写没有改变exports的指向，而是在exports指向的module.exports对象上新增了属性 // 那么什么时候用exports，什么时候用module.exports呢？ // 如果导出的东西是一个，那么可以用module.exports，如果导出多个属性可以用exports， // 一般情况下是用module.exports // 还有一种方式，就是把属性挂载到global上供全局访问，不过不推荐。 CommonJS模块总结CommonJS模块只能运行再支持此规范的环境之中，nodejs是基于CommonJS规范开发的，因此可以很完美地运行CommonJS模块，然后nodejs不支持ES6的模块规范，所以nodejs的服务器开发大家一般使用CommonJS规范来写。CommonJS模块导入用require，导出用module.exports。导出的对象需注意，如果是静态值，而且非常量，后期可能会有所改动的，请使用函数动态获取，否则无法获取修改值。导入的参数，是可以随意改动的，所以大家使用时要小心。]]></content>
      <tags>
        <tag>Common.JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解 HTTPS]]></title>
    <url>%2F2018%2F10%2F26%2F%E7%90%86%E8%A7%A3-HTTPS%2F</url>
    <content type="text"><![CDATA[HTTP2http2 的前身是由 google 领导开发的 SPDY，后来 google 把整个成果交给 IETF，IETF 把 SPDY 标准化之后变成 http2。google 也很大方的废弃掉 SPDY，转向支持 http2。http2 是完全兼容 http/1.x 的，在此基础上添加了 4 个主要新特性：12345二进制分帧头部压缩服务端推送多路复用优化手段 http2 简介 存在即合理http是非常常见的应用层协议，是超文本传输协议的简称，其传输的内容都是明文的。 在这个混乱的世界，明文传输信息想想就可怕，网络“小混混”的手段远比我们这些凡人高明得多，他们有一万种方式劫持，篡改我们的数据。对于一个网站或者服务，如果你给你的用户两个选择： 通讯数据明文传输，速度快； 通讯数据加密传输，但是速度可能会稍微慢一点.我想，只要脑袋没有长歪的用户都宁愿牺牲一点速度去换取数据传输的安全。 这样，https的存在就具备了合理性，https中的s表示SSL或者TLS，就是在原http的基础上加上一层用于数据加密、解密、身份认证的安全层。 HTTP协议的缺点 通信使用明文； 不验证通信方的身份； 无法验证报文的完整性； 通信使用明文: 通信使用明文意味着安全性大大降低，当通信过程被窃听后，无需花费额外的投入就可看到传输的数据。例如使用抓包工具，无需任何配置就可查看任何使用HTTP协议的通信数据；不验证通信方身份 :不验证通信方的身份，将导致通信过程被窃听后，可能会遭遇伪装，例如使用抓包工具抓取数据后，就可按照数据包的格式构造HTTP请求；无法验证报文的完整性:不验证报文的完整性，数据在传输过程中就可能被篡改，本来想看喜洋洋呢，结果数据在传输过程中被换成了光头强。 为解决了HTTP的以上问题，HTTPS协议就诞生了：12345Https = Http + 加密 + 认证 + 完整性验证 ||Https = Http + SSL ||HTTPS=数据加密+网站认证+完整性验证+HTTP HTTP 与 HTTPS 的区别 HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密 HTTP 的端口号是 80，HTTPS 是 443 HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费 HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。 HTTPS主要缺点： 网络耗时（比HTTP多了交互次数）。 加解密耗时。 比HTTP慢几百毫秒以上，页面加载时间增加了50%，增加10%到20%的耗电 HTTPS工作流程：1.客户端向服务器发送请求，并告诉服务器支持的算法列表；2.服务器选择一种算法，并将自己的证书返回给客户端，证书包含服务器域名和公钥等信息；3.客户端得到证书后进行验证，验证通过的话就生成一个随机值，并用证书中的公钥进行加密4.传递加密信息，目的就是让服务器得到这个随机值，以后客户端与服务器的通信就可以通过这个随机值来进行加密解密；5.服务器用自己的私钥解密客户端传过来的随机值，然后把内容进行对称加密，即将信息和私钥通过加密算法混在一起，这样除非知道私钥，不然无法获取到内容，而客户端与服务器都知道这个私钥，所以只要加密算法够强大，私钥够复杂，数据就很安全了；6.将加密后的信息发给客户端，客户端还原信息7.客户端用之前生成的私钥解密服务器发过来的信息，便获取到了解密后的内容； 那么加密的信息通道又加密了哪些信息呢？ 签发证书的 CA 中心会发布一种权威性的电子文档——数字证书，它可以通过加密技术（对称加密与非对称加密）对我们在网上传输的信息进行加密，比如我在 Pornhub 上输入：12账号：cbssfaw密码：123djaosid 可是这个数据被黑客拦截盗窃了，那么加密后，黑客得到的数据可能就是这样的：12账号：çµø…≤¥ƒ∂ø†®∂˙∆¬密码：∆ø¥§®†ƒ©®†©˚¬ 想要理解 HTTPS 加密。需要理解几个概念： 对称加密算法 非对称加密算法 CA(Certificate Authority) 数字证书 摘要算法 常用的加密方式分为两种： 对称加密： 加密和解密使用的是相同的密钥。 非对称加密： 加密和解密使用的不是相同的密钥，而是一对密钥对，分别称为公钥和私钥。 HTTPS 用了哪种加密方法？ 在 HTTPS 中，对称加密和非对称加密都用到了。非对称加密可以在不安全的信道上传递秘密内容，但是由于通常使用的非对称加密方法相较于对称加密算法慢很多，因此在 HTTPS 中仅使用非对称加密算法交换对称密钥，交换密钥之后的通信内容均使用对称加密算法加密和解密，这样既可以保证密钥的安全也可以保证内容的加解密速度，这对于移动端设备来说至关重要。 现在的问题是，如何在实现 HTTP 协议的情况下，对传输的信息进行加密解密？最开始使用到的是最简单的对称加密算法。 对称加密算法对称加密算法非常简单，只要加密方和解密方都拥有同一密钥（可为128，192，256 bit 大小的密钥，密钥越长，加密解密时间越长，解密难度也越高），即可完成加密解密过程，且假设无法强制对加密过的明文进行解密。 问题：对于需要传递加密信息的双方而言，对称加密算法用于加密解密没有什么问题，但是密钥的传输就成了另外一个问题。因为密钥也需要传输才能使双方通信，密钥明文传输出去，被人轻易截取，就能利用密钥破解加密的密文。 所以引出了下面的非对称加密算法来传输密钥。 公开密钥加密(Public-Key Cryptography)的非对称加密算法对于使用最广泛的非对称加密算法——RSA，RSA 算法基于一个简单的数论理论：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。 RSA 算法得出了下面的规则：通讯两方 A, B 分别都有各自的一套公钥和私钥。同一套公钥私钥当中，公钥的加密需要私钥才能解密，私钥的加密需要公钥才能解密。 假设 A 把自己的公钥公开出去，B 得到了 A 的公钥，然后 B 用 A 的公钥加密了明文，传给 A，A 用私钥解密，即可获得明文。所以，过程中公开的信息任何第三方得到都不可以破解 A 和 B 要传递的信息。有了这个算法之后，对称加密算法所用到的密钥传输安全性就没问题了。但是因为加密解密过程时间比较长，非对称加密算法不适合应用于数据量大的信息传递，只适用于密钥的传递。（这个问题解释了对于数字签名的摘要算法的必要性） 问题：虽然 RSA 算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是中间人攻击。在用非对称加密算法传递密钥的过程中，因为公钥都是公开的，并没有任何东西可以认证这个公钥是 A 的还是 B 的。现在出现了中间人 M，M 采取某种手段在 A 和 B 的通讯过程成为中间人。在 B 想要得到 A 的公钥的时候，M 向 B 谎称自己的这个公钥是 A 的公钥，B 拿到用 M 的公钥加密信息后，传出 M 手中，然后 M 拿加密过的信息，然后用自己的私钥把这个信息解密，得到明文。既然已经知道了明文，还是用 A 的公钥加密这个信息，继续给 A，这样 A 还是以为这个信息是安全的，继续用私钥解开。而在这个过程中，M 既获得了信息，又没有让 A，B 双方知道。至于这个 M 是怎么欺骗 A，B 的，又是另外一个安全的问题。总之，假如 M 只要让 B 相信这个公钥是 A 的，就可以作中间人攻击。 假如上面的 A 是服务器，B 是用户，那么中间人就很容易获取和修改 A，B 需要传输的信息。所以为了让 M 不再得逞，出现一个具有公信力的第三方——CA。 CA(Certificate Authority) 第三方认证机构简单来说，CA 要做的就是，让 B 相信拿到的 A 的公钥真正属于 A，而不是其他中间人 M 伪造。 而在 CA 在做这件事的过程中如何才能让 B 认证这个公钥是 A 的呢？ 这里需要另外一个概念：数字证书。 普通证书产生的过程就是：将个人提交的信息进行第三方具有权威性部门的认证，然后第三方权威部门确认个人信息合法无误后在自己的系统中登记，再把认证证书盖章签名给到个人手上，然后个人就可以用证书从事各类证明活动。现实世界中的做法是在个人提交的信息上盖章，例如4，6级的证书认证。假设你的成绩申请无误而合法，教育局就会将你的成绩记录，然后给你一张盖过章的证书。 数字证书同理。不过，与现实不一样，在互联网上完成一个完整的验证过程，需要兼顾到很多过程中的纰漏。 例如： 问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？现实中就是向政府部门认证哪些是登记过的可信任的部门，像4，6级证书颁发的部门——全国大学英语四六级考试委员会，是全国的教育局的下级和内部部门，是认证过的。而在互联网中，就需要顶级的最具有公信力的 CA，这个 CA 颁发的证书是最受信任的，这个就是根证书。为了不让所有鸡蛋都放在一个篮子里，其他的 CA 机构可以向上一级的 CA 机构申请成为中间 CA，获取自己的中间证书，最终个人像 A 向某一个中间 CA 申请的证书就是最终的终端普通数字证书。这个过程的签发关系就是证书链。当 B 得到 A 的数字证书之后，会在证书的信息中找到 A 申请的 CA，而这个 CA 则会根据自己中间证书找到的自己申请的 CA，就这样沿着证书链找证书，假如某个中间证书或者根证书在本机中安装有，则认证的时候会将 A 的证书设置为可被信任的。 如何识别可信任机构的这个问题就解决了。 问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？现实中可以在这个已经被认证的第三方机构系统中查询，像4，6级，可以到教育局的网上公开系统中查询。而在互联网中，则需要一个类似的查询验证过程——数字签名。为了对这个证书的验证，确保这个签名是来自可信任的 CA，而不是其他不可信的 CA。CA 在给 A 的数字证书中有一个数字签名。该签名是 CA 用自己的私钥对 A 的个人信息进行非对称加密得到的加密信息。当 B 得到 A 提供的数字证书，会拿到其中的数字签名和 A 的个人信息，然后用 CA 的公钥对这个数字签名进行非对称解密，得出的信息假如和 A 的数字证书中 A 的个人信息一样的话，就相信这个数字证书确实是 CA 认证过的。 如何认证这个签名是不是伪造的这个问题也解决了。但是这个问题又引出了另外一个问题：数字证书中 A 的个人信息数据比较大，而非对成加密算法的加密解密速度非常慢，使得认证过程中对个人信息的非对称加密解密非常耗占时间。所以需要用到另外一种算法来加快这个验证过程，这个算法就是摘要算法。（一直很疑惑为什么需要到摘要算法，总算找到了一个原因） 摘要算法可以将任意大小的原文消息加密并摘要成固定长度的简短密文。对于不同的原文消息，用同一种摘要算法，都可以得到不同但是固定长度的密文，而相同的原文消息，用同一种摘要算法，则可以得到相同固定长度的密文。这就解决了数字签名过程中，对数据大的个人信息文件的非对称加密解密的时间慢的问题。CA 用 A 个人信息进行摘要算法的处理，然后继续用私钥加密，作为数字证书的数字签名给到 A。B 拿到 A 提供的数字签名和 A 的个人信息，然后用 CA 的公钥解密 A 的数字签名，得到 A 个人信息的摘要。再用同一种摘要算法对 A 的个人信息进行处理，得到 A 个人信息的摘要，再与解密得到的 A 个人信息摘要对比，就可以确认改数字签名和个人信息是匹配的。 到这一步，中间人攻击已经很难可以发生了，假设 M 想要在 A 和 B 之间充当中间人，有三种手段： 需要从 A 服务器中直接获取域名数字证书； 得到 A 的域名管理，向 CA 申请证书 自己签发证书，然后要求 B 安装自己的证书。 对于第一第二个问题的防范，在服务器端，只要要保护好私钥和服务器和域名的安全，就不会出现大问题。 对于第三个问题，在客户端，有一个很好的例子：12306。12306 的证书就是中铁局自己搞的认证机构颁发的。当你浏览 12306 的时候，虽然请求是带 HTTPS，但是浏览器检查的时候发现这个中铁局的认证机构没有在证书链当中，会提示“可能会被攻击”，当然 12306 会要求你直接安装他们的证书。这就要求你自己的明察秋毫了，你是选择相信 ZF 的证书，然后可能以后 ZF 的某些网站可能会在中铁局的认证机构认证证书，然后假装是 HTTPS，并且可能会伪装窃取你的个人信息。所以在客户端，安装证书需要谨慎，不要随意安装不信任的证书。]]></content>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解密webpack tree-starking]]></title>
    <url>%2F2018%2F10%2F25%2F%E8%A7%A3%E5%AF%86webpack-tree-starking%2F</url>
    <content type="text"><![CDATA[Tree-Shaking 简介最近看了一篇 你的Tree-Shaking并没什么卵用 吓得我赶紧好好研究Tree-Shaking。 tree-sharking 是 Webpack 2 后续版本的优化功能，顾名思义，就是将多余的代码给 “摇晃” 掉，在开发中我们经常使用一些第三方库，而这些第三方库只使用了这个库的一部门功能或代码，未使用的代码也要被打包进来，这样出口文件会非常大，tree-sharking 帮我们解决了这个问题，它可以将各个模块中没有使用的方法过滤掉，只对有效代码进行打包。 Tree-Shaking在前端界由rollup首先提出并实现，后续webpack在2.x版本也借助于UglifyJS实现了。自那以后，在各类讨论优化打包的文章中，都能看到Tree-Shaking的身影。 Tree-Shaking的原理这里我不多冗余阐述，直接贴百度外卖前端的一篇文章： Tree-Shaking性能优化实践 - 原理篇 。 AST 语法树分析 AST 抽象语法树简介 AST（Abstract Syntax Tree）是源代码的抽象语法结构树状表现形式，Webpack、ESLint、JSX、TypeScript 的编译和模块化规则之间的转化都是通过 AST 来实现对代码的检查、分析以及编译等操作。 JavaScript 语法的 AST 语法树 JavaScript 中想要使用 AST 进行开发，要知道抽象成语法树之后的结构是什么，里面的字段名称都代表什么含义以及遍历的规则，我们可以通过在线转换网站http://esprima.org/demo/parse.html将 JS 代码装换成 AST 语法树。 通过在线编译工具，可以将 function fn(a, b) {}编译为下面的结构。123456789101112131415161718192021222324252627282930&#123; &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;FunctionDeclaration&quot;, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;fn&quot; &#125;, &quot;params&quot;: [ &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;a&quot; &#125;, &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;b&quot; &#125; ], &quot;body&quot;: &#123; &quot;type&quot;: &quot;BlockStatement&quot;, &quot;body&quot;: [] &#125;, &quot;generator&quot;: false, &quot;expression&quot;: false, &quot;async&quot;: false &#125; ], &quot;sourceType&quot;: &quot;script&quot;&#125; 将 JavaScript 语法编译成抽象语法树后，需要对它进行遍历、修该并重新编译，遍历树结构的过程为 “先序深度优先”。 esprima、estraverse 和 escodegenesprima、estraverse 和 escodegen 模块是操作 AST 的三个重要模块，也是实现 babel 的核心依赖，下面是分别介绍三个模块的作用。 1、esprima 将 JS 转换成 ASTesprima 模块的用法如下： 文件：esprima-test.js const esprima = require(&quot;esprima&quot;); let code = &quot;function fn() {}&quot;; // 生成语法树 let tree = esprima.parseScript(code); console.log(tree); // Script { // type: &apos;Program&apos;, // body: // [ FunctionDeclaration { // type: &apos;FunctionDeclaration&apos;, // id: [Identifier], // params: [], // body: [BlockStatement], // generator: false, // expression: false, // async: false } ], // sourceType: &apos;script&apos; } 通过上面的案例可以看出，通过 esprima 模块的 parseScript 方法将 JS 代码块转换成语法树，代码块需要转换成字符串，也可以通过 parseModule 方法转换一个模块。 2、estraverse 遍历和修改 AST查看遍历过程： 文件：estraverse-test.js const esprima = require(&quot;esprima&quot;); const estraverse = require(&quot;estraverse&quot;); let code = &quot;function fn() {}&quot;; // 遍历语法树 estraverse.traverse(esprima.parseScript(code), { enter(node) { console.log(&quot;enter&quot;, node.type); }, leave() { console.log(&quot;leave&quot;, node.type); } }); // enter Program // enter FunctionDeclaration // enter Identifier // leave Identifier // enter BlockStatement // leave BlockStatement // leave FunctionDeclaration // leave Program 上面代码通过 estraverse 模块的 traverse 方法将 esprima 模块转换的 AST 进行了遍历，并打印了所有的 type 属性并打印，每含有一个 type 属性的对象被叫做一个节点，修改是获取对应的类型并修改该节点中的属性即可。 其实深度遍历 AST 就是在遍历每一层的 type 属性，所以遍历会分为两个阶段，进入阶段和离开阶段，在 estraverse 的 traverse 方法中分别用参数指定的 entry 和 leave 两个函数监听，但是我们一般只使用 entry。 3、escodegen 将 AST 转换成 JS下面的案例是一个段 JS 代码块被转换成 AST，并将遍历、修改后的 AST 重新转换成 JS 的全过程。 文件：escodegen-test.js const esprima = require(&quot;esprima&quot;); const estraverse = require(&quot;estraverse&quot;); const escodegen = require(&quot;escodegen&quot;); let code = &quot;function fn() {}&quot;; // 生成语法树 let tree = esprima.parseScript(code); // 遍历语法树 estraverse.traverse(tree, { enter(node) { // 修改函数名 if (node.type === &quot;FunctionDeclaration&quot;) { node.id.name = &quot;ast&quot;; } } }); // 编译语法树 let result = escodegen.generate(tree); console.log(result); // function ast() { // } 在遍历 AST 的过程中 params 值为数组，没有 type 属性。 实现 Babel 语法转换插件实现语法转换插件需要借助 babel-core 和 babel-types 两个模块，其实这两个模块就是依赖 esprima、estraverse 和 escodegen 的。 使用这两个模块需要安装，命令如下： 1npm install babel-core babel-types 1、plugin-transform-arrow-functionsplugin-transform-arrow-functions 是 Babel 家族成员之一，用于将箭头函数转换 ES5 语法的函数表达式。 文件：plugin-transform-arrow-functions.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const babel = require(&quot;babel-core&quot;);const types = require(&quot;babel-types&quot;);// 箭头函数代码块let sumCode = `const sum = (a, b) =&gt; &#123; return a + b;&#125;`;let minusCode = `const minus = (a, b) =&gt; a - b;`;// 转化 ES5 插件let ArrowPlugin = &#123;// 访问者（访问者模式） visitor: &#123;// path 是树的路径 ArrowFunctionExpression(path) &#123;// 获取树节点let node = path.node;// 获取参数和函数体let params = node.params;let body = node.body;// 判断函数体是否是代码块，不是代码块则添加 return 和 &#123;&#125;if (!types.isBlockStatement(body)) &#123;let returnStatement = types.returnStatement(body); body = types.blockStatement([returnStatement]); &#125;// 生成一个函数表达式树结构let func = types.functionExpression(null, params, body, false, false);// 用新的树结构替换掉旧的树结构 types.replaceWith(func); &#125; &#125;&#125;;// 生成转换后的代码块let sumResult = babel.transform(sumCode, &#123; plugins: [ArrowPlugin]&#125;);let minusResult = babel.transform(minusCode, &#123; plugins: [ArrowPlugin]&#125;);console.log(sumResult.code);console.log(minusResult.code);// let sum = function (a, b) &#123;// return a + b;// &#125;;// let minus = function (a, b) &#123;// return a - b;// &#125;; 我们主要使用 babel-core 的 transform 方法将 AST 转化成代码块，第一个参数为转换前的代码块（字符串），第二个参数为配置项，其中 plugins 值为数组，存储修改 babal-core 转换的 AST 的插件（对象），使用 transform 方法将旧的 AST 处理成新的代码块后，返回值为一个对象，对象的 code 属性为转换后的代码块（字符串）。 内部修改通过 babel-types 模块提供的方法实现，API 可以到 https://github.com/babel/babel/tree/6.x/packages/babel-types 中查看。 ArrowPlugin 就是传入 transform 方法的插件，必须含有 visitor 属性（固定），值同为对象，用于存储修改语法树的方法，方法名要严格按照 API，对应的方法会修改 AST 对应的节点。 在 types.functionExpression 方法中参数分别代表，函数名（匿名函数为 null）、函数参数（必填）、函数体（必填）、是否为 generator 函数（默认 false）、是否为 async 函数（默认 false），返回值为修改后的 AST，types.replaceWith 方法用于替换 AST，参数为新的 AST。 2、plugin-transform-classesplugin-transform-classes 也是 Babel 家族中的成员之一，用于将 ES6 的 class 类转换成 ES5 的构造函数。 文件：plugin-transform-classes.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const babel = require(&quot;babel-core&quot;);const types = require(&quot;babel-types&quot;);// 类let code = `class Person &#123; constructor(name) &#123; this.name = name; &#125; getName () &#123; return this.name; &#125;&#125;`;// 将类转化 ES5 构造函数插件let ClassPlugin = &#123; visitor: &#123; ClassDeclaration(path) &#123;let node = path.node;let classList = node.body.body;// 将取到的类名转换成标识符 &#123; type: &apos;Identifier&apos;, name: &apos;Person&apos; &#125;let className = types.identifier(node.id.name);let body = types.blockStatement([]);let func = types.functionDeclaration(className, [], body, false, false); path.replaceWith(func);// 用于存储多个原型方法let es5Func = [];// 获取 class 中的代码体 classList.forEach((item, index) =&gt; &#123;// 函数的代码体let body = classList[index].body;// 获取参数let params = item.params.length ? item.params.map(val =&gt; val.name) : [];// 转化参数为标识符 params = types.identifier(params);// 判断是否是 constructor，如果构造函数那就生成新的函数替换if (item.kind === &quot;constructor&quot;) &#123;// 生成一个构造函数树结构 func = types.functionDeclaration(className, [params], body, false, false); &#125; else &#123;// 其他情况是原型方法let proto = types.memberExpression(className, types.identifier(&quot;prototype&quot;));// 左侧层层定义标识符 Person.prototype.getNamelet left = types.memberExpression(proto, types.identifier(item.key.name));// 右侧定义匿名函数let right = types.functionExpression(null, [params], body, false, false);// 将左侧和右侧进行合并并存入数组 es5Func.push(types.assignmentExpression(&quot;=&quot;, left, right)); &#125; &#125;);// 如果没有原型方法，直接替换if (es5Func.length === 0) &#123; path.replaceWith(func); &#125; else &#123; es5Func.push(func);// 替换 n 个节点 path.replaceWithMultiple(es5Func); &#125; &#125; &#125;&#125;;// 生成转换后的代码块result = babel.transform(code, &#123; plugins: [ClassPlugin]&#125;);console.log(result.code);// Person.prototype.getName = function () &#123;// return this.name;// &#125;// function Person(name) &#123;// this.name = name;// &#125; 上面这个插件的实现要比 plugin-transform-arrow-functions 复杂一些，归根结底还是将要互相转换的 ES6 和 ES5 语法树做对比，找到他们的不同，并使用 babel-types 提供的 API 对语法树对应的节点属性进行修改并替换语法树，值得注意的是 path.replaceWithMultiple 与 path.replaceWith 不同，参数为一个数组，数组支持多个语法树结构，可根据具体修改语法树的场景选择使用，也可根据不同情况使用不同的替换方法。 通过本节我们了解了什么是 AST 抽象语法树、抽象语法树在 JavaScript 中的体现以及在 NodeJS 中用于生成、遍历和修改 AST 抽象语法树的核心依赖，并通过使用 babel-core 和 babel-types 两个模块简易模拟了 ES6 新特性转换为 ES5 语法的过程，希望可以为后面自己实现一些编译插件提供了思路。 假设我们现在使用了 ElementUI 库的两个组件，通常会使用解构赋值来引入。 优化前 import { Button, Alert } from&quot;element-ui&quot;; 这样引用资源， Webpack 在打包的时候会找到 element-ui 并把里面所有的代码全部打包到出口文件，我们只使用了两个组件，全部打包不是我们所希望的，tree-sharking 是通过在 Webpack 中配置 babel-plugin-import 插件来实现的，它可以将解构的代码转换成下面的形式。 优化后 import Button from&quot;element-ui/lib/button&quot;; import Alert from&quot;element-ui/lib/Alert&quot;; 转化后会去 node_modules 中的 element-ui 模块找到 Button 和 Alert 两个组件对应的文件，并打包到出口文件中。 通过上面的转换可以看出，其实 tree-sharking 的实现原理是通过改变 AST 语法树的结构来实现的，如果不了解抽象语法树可以参考 AST 抽象语法树， 优化前的 AST 语法树 1234567891011121314151617181920212223242526272829303132333435363738&#123; &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ImportDeclaration&quot;, &quot;specifiers&quot;: [ &#123; &quot;type&quot;: &quot;ImportSpecifier&quot;, &quot;local&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Button&quot; &#125;, &quot;imported&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Button&quot; &#125; &#125;, &#123; &quot;type&quot;: &quot;ImportSpecifier&quot;, &quot;local&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Alert&quot; &#125;, &quot;imported&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Alert&quot; &#125; &#125; ], &quot;source&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;element-ui&quot;, &quot;raw&quot;: &quot;\&quot;element-ui\&quot;&quot; &#125; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 优化后的 AST 语法树 12345678910111213141516171819202122232425262728293031323334353637383940 &#123; &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;ImportDeclaration&quot;, &quot;specifiers&quot;: [ &#123; &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;, &quot;local&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Button&quot; &#125; &#125; ], &quot;source&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;element-ui/lib/button&quot;, &quot;raw&quot;: &quot;\&quot;element-ui/lib/button\&quot;&quot; &#125; &#125;, &#123; &quot;type&quot;: &quot;ImportDeclaration&quot;, &quot;specifiers&quot;: [ &#123; &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;, &quot;local&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;Alert&quot; &#125; &#125; ], &quot;source&quot;: &#123; &quot;type&quot;: &quot;Literal&quot;, &quot;value&quot;: &quot;element-ui/lib/Alert&quot;, &quot;raw&quot;: &quot;\&quot;element-ui/lib/Alert\&quot;&quot; &#125; &#125; ], &quot;sourceType&quot;: &quot;module&quot;&#125; 从上面的语法树对比，可以看出在优化前 body 里面只有一个对象，使用的组件信息存在 specifiers 里，source 指向了 element-ui，而在优化后，将两个组件分别拆成了两个对象存在 body 中，每个对象的的 specifiers 只存储一个组件，并在 source 里面指向了当前组件对应的路径。 模拟 tree-starking既然我们已经清楚要修改语法树的位置，下面就使用 AST 来模拟 tree-sharking 功能，对语法树的操作是依赖于 babel-core 和 babel-types 两个核心模块的，下面先安装依赖。1npm install babel-core babel-types 文件：babel-plugin-my-import.js 1234567891011121314151617181920212223242526272829303132333435363738const babel = require(&quot;babel-core&quot;);const types = require(&quot;babel-types&quot;);let code = `import &#123; Button, Alert &#125; from &quot;element-ui&quot;`;let importPlugin = &#123; visitor: &#123; ImportDeclaration(path) &#123; let node = path.node; let source = node.source.value; let specifiers = node.specifiers; // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出 if (!types.isImportDefaultSpecifier(specifiers[0])) &#123; // 如果不是默认导出，则需要转换 specifiers = specifiers.map(specifier =&gt; &#123; // 数组内容：当前默认导出的标识、从哪里导入 return types.importDeclaration( [types.importDefaultSpecifier(specifier.local)], types.stringLiteral(`$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;`) ); &#125;); // 替换树结构 path.replaceWithMultiple(specifiers); &#125; &#125; &#125;&#125;;let result = babel.transform(code, &#123; plugins: [importPlugin]&#125;);console.log(result.code);// import Button from &quot;element-ui/lib/button&quot;;// import Alert from &quot;element-ui/lib/alert&quot;; 通过上面的代码可以发现我们使用 babel-core 和 babel-types 两个模块的核心方法对语法书进行了遍历、修改和替换，更详细的 API 可以查看 https://github.com/babel/babel/tree/6.x/packages/babel-types。 结合 Webpack 使用插件前面只是验证了 tree-sharking 中 JS 语法的转换过程，接下来将上面的代码转换成插件配合 Webpack 使用，来彻底感受 tree-sharking 的工作过程。 文件：~node_modules/babel-plugin-my-import.js 1234567891011121314151617181920212223242526272829const babel = require(&quot;babel-core&quot;);const types = require(&quot;babel-types&quot;);let importPlugin = &#123; visitor: &#123; ImportDeclaration(path) &#123; let node = path.node; let source = node.source.value; let specifiers = node.specifiers; // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出 if (!types.isImportDefaultSpecifier(specifiers[0])) &#123; // 如果不是默认导出，则需要转换 specifiers = specifiers.map(specifier =&gt; &#123; // 数组内容：当前默认导出的标识、从哪里导入 return types.importDeclaration( [types.importDefaultSpecifier(specifier.local)], types.stringLiteral(`$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;`) ); &#125;); // 替换树解构 path.replaceWithMultiple(specifiers); &#125; &#125; &#125;&#125;;module.exports = importPlugin; 上面删掉了多余的测试代码，将模块中的 importPlugin 插件导出，并把 babel-plugin-my-import.js 移入了 node_modules 当中。 接下来安装需要的依赖：12npm install webpack webpack-cli babel-loader babel-presets-envnpm install vue element-ui --save 安装完依赖，写一个要编译的文件，使用 Webpack 进行打包，查看使用插件前和使用插件后出口文件的大小。文件：import.js12import Vue from&quot;vue&quot;;import &#123; Button, Alert &#125; from&quot;element-ui&quot;; 下面来写一个简单的 Webpack 配置文件。 文件：webpcak.config.js 1234567891011121314151617181920212223242526 module.exports = &#123; mode: &quot;development&quot;, entry: &quot;import.js&quot;, output: &#123; filename: &quot;bundle.js&quot;, path: __dirname &#125;, module: &#123; rules: [&#123; test: /\.js$/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; presets: [ &quot;env&quot;, ], plugins: [ // 插件：不使用插件打包注释掉该行即可 [&quot;my-import&quot;, &#123; libararyName: &quot;element-ui&quot; &#125;] ] &#125; &#125;, exclude: /node_modules/ &#125;] &#125;&#125;; 为了防止 babel 相关的依赖升级 7.0 后出现一些问题导致 Webpack 无法启动，再此贴出 package.json 文件，按照对应版本下载依赖保证上面 Webpack 配置生效。 文件：package.json 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;ast-lesson&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;tree-starking&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.3&quot;, &quot;babel-loader&quot;: &quot;^7.1.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;babel-types&quot;: &quot;^6.26.0&quot;, &quot;escodegen&quot;: &quot;^1.10.0&quot;, &quot;esprima&quot;: &quot;^4.0.0&quot;, &quot;estraverse&quot;: &quot;^4.2.0&quot;, &quot;webpack&quot;: &quot;^4.16.0&quot;, &quot;webpack-cli&quot;: &quot;^3.0.8&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.17&quot;, &quot;element-ui&quot;: &quot;^2.4.6&quot; &#125;&#125; 对比使用插件前后的出口文件接下来分别在使用插件和不使用插件时执行打包命令，查看出口文件 bondle.js 的大小。1npx webpack 使用 babel-plugin-my-import 前： 使用 babel-plugin-my-import 后： 通过对比，可以看到使用 tree-sharking 即我们自己实现的 babel-plugin-my-import 插件后，打包的出口文件大大减小，其原因是将引入第三方库没有使用的代码全都过滤掉了，只打包了有效代码。 总结上面对 Webpack 的 tree-sharking 进行了分析，并模拟 babel-plugin-import 简易的实现了一版 tree-sharking 的优化插件，这个过程中相信大家已经了解了 tree-sharking 的原理以及实现类似插件的思路，并已经具备了开发类似插件的基本条件，最后还有一点需要补充，tree-sharking 优化的方式是根据 ES6 语法 import “静态” 引入的特性实现的，如果要说 tree-sharking 很强大，还不如说 ES6 模块化规范 “静态” 引入的特性强大，正由于是基于 “静态” 引入，所以目前 tree-sharking 只支持遍历一层 import 关键字。]]></content>
      <tags>
        <tag>Tree-Shaking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async 并发执行和继发执行]]></title>
    <url>%2F2018%2F10%2F24%2Fasync-%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BB%A7%E5%8F%91%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[面试题继发执行 : 1s后执行10，等1s后输出20，再等1s后输出30 123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; function Pro(val) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; resolve(val) &#125;, 1000) &#125;) &#125; async function log(arrs) &#123; for(const item of arrs) &#123; var response = await Pro(item); console.log(response); &#125; &#125; log([10, 20, 30]) &lt;/script&gt; 问题：给定一个 URL 数组，如何实现接口的继发和并发？ async 继发实现：继发一123456async function loadData() &#123; var res1 = await fetch(url1); var res2 = await fetch(url2); var res3 = await fetch(url3); return&quot;whew all done&quot;;&#125; 继发二123456async function loadData(urls) &#123; for (const url of urls) &#123; const response = await fetch(url); console.log(await response.text()); &#125;&#125; async 并发实现：并发一1234async function loadData() &#123; var res = awaitPromise.all([fetch(url1), fetch(url2), fetch(url3)]); return&quot;whew all done&quot;;&#125; 并发二123456789101112async function loadData(urls) &#123; // 并发读取 url const textPromises = urls.map(async url =&gt; &#123; const response = await fetch(url); return response.text(); &#125;); // 按次序输出 for (const textPromise of textPromises) &#123; console.log(await textPromise); &#125;&#125;]]></content>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript 原生常用API大全]]></title>
    <url>%2F2018%2F10%2F23%2Fjavascript-%E5%8E%9F%E7%94%9F%E5%B8%B8%E7%94%A8API%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[原生JS API123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390一、节点1.1 节点属性Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点//parentNode接口Node.children //返回指定节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目。1.2 操作Node.appendChild(node) //向节点添加最后一个子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove() //用于删除当前节点Node.before() //Node.after()Node.replaceWith()1.3 Document节点1.3.1 Document节点的属性document.doctype //document.documentElement //返回当前文档的根节点document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素。//节点集合属性document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表//文档信息属性document.documentURI //表示当前文档的网址document.URL //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie1.3.2 Document节点的方法（1）读写方法document.open() //用于新建并打开一个文档document.close() //不安比open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符。（2）查找节点document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）document.getElementById(id) //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。（3）生成节点document.createElement(tagName) //用来生成HTML元素节点。document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回它。document.createDocumentFragment() //生成一个DocumentFragment对象（4）事件方法document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件（5）其他document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。1.4 Element节点1.4.1 Element节点的属性（1）特性属性Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有的data-*属性。（2）尺寸属性Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border,padding)Element.offsetWidth //返回元素的水平宽度(包含border,padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式（3）节点相关属性Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。1.4.2 Element节点的方法（1）位置方法getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft &#125;（2）属性方法Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性（3）查找方法Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName()（4）事件方法Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement;// 事件代理 ul.addEventListener(&apos;click&apos;, function(event) &#123; if (event.target.tagName.toLowerCase() === &apos;li&apos;) &#123; console.log(event.target.innerHTML) &#125; &#125;);（5）其他Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入 Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上二、CSS操作（1）类名操作//ie8以下Element.className //获取元素节点的类名Element.className += &apos; &apos; + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,&apos;gi&apos;).test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class（2）style操作element.setAttribute(&apos;style&apos;,&apos;&apos;)element.style.backgroundColor = &apos;red&apos;element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,&apos;:after&apos;)[attrName]三、对象3.1 Object对象（1）生成实例对象var o = new Object()（2）属性Object.prototype //返回原型对象（3）方法Object.keys(o) //遍历对象的可枚举属性Object.getOwnPropertyName(o) //遍历对象不可枚举的属性对象实例的方法valueOf()：返回当前对象对应的值。 toString()：返回当前对象对应的字符串形式。 toLocaleString()：返回当前对象对应的本地字符串形式。 hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：判断某个属性是否可枚举。3.2 Array对象（1）生成实例对象var a = new Array()（2）属性a.length //长度（3）Array.isArray()Array.isArray(a) //用来判断一个值是否为数组（4）Array实例的方法[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;a.valueof() //返回数组本身a.toString() //返回数组的字符串形式a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift() //用于删除数组的第一个元素，并返回该元素。unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse() //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。3.3 Number对象（1）生成对象var n = new Number()（2）Number对象的属性Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。（4）Number对象实例的方法toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision() //用于将一个数转为指定位数的有效数字。3.4 String 对象（1）生成实例对象var s = new String()（2）String对象的属性s.length //返回字符串的长度（3）方法s.chatAt(index) //返回指定位置的字符 //&quot;123456&quot;[0] == &quot;1&quot;s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2) //用于连接两个字符串s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。3.5 Math对象（1）属性Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。（2）数学方法Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。（3）三角函数方法Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值）3.6 JSON对象（1）方法JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse() //用于将JSON字符串转化成对象。3.7 console对象（1）方法console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn() //输出信息时，在最前面加一个黄色三角，表示警告；console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table() //可以将复合类型的数据转为表格显示。console.count() //用于计数，输出它被调用了多少次。console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml() //用于以目录树的形式，显示DOM节点。console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd() //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace() //显示当前执行的代码在堆栈中的调用路径。console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。正则表达式：只允许输入汉字：onkeyup=&quot;value=value.replace(/[^\u4E00-\u9FA5]/g,&apos;&apos;)&quot; 只允许输入数字：onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot;[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot; setTimeout(fn, 0) 的作用 setTimeout（0）单线程和异步队列setTimeout和setInterval是JS内置的两个定时器，使用很简单，但这两个方法背后的原理却不简单。我们知道，JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，主线程会形成一个全局执行环境，执行环境采用栈的方式将待执行任务按顺序依次来执行。但在浏览器中有一些任务是非常耗时的，比如http请求、定时器、事件回调等，为了保证其他任务的执行效率不被影响，JS在执行环境中维护了一个异步队列(也叫工作线程)，并将这些任务放入队列中进行等待，这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，才会去检查异步队列中的任务是否需要开始执行。这就是为什么setTimeout(fn,0) 始终要等到最后执行的原因。关于单线程和异步队列问题请参考：setTimeout（0） 深拷贝123456789101112function deepCopy(p, c) &#123; var c = c || &#123;&#125;; for (var i in p) &#123; if (typeof p[i] === &apos;object&apos;) &#123; c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;; deepCopy(p[i], c[i]); &#125; else &#123; c[i] = p[i]; &#125; &#125; return c;&#125; POST和GET的区别，HTTP状态码12345678910POST和GET的区别GET在浏览器回退时是无害的，而POST会再次提交请求GET产生的URL地址可以被收藏，而POST不可以GET请求会被浏览器主动缓存，而POST不会，除非手动设置GET请求只能进行URL编码，而POST支持多种编码方式GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留GET请求在URL中传送的参数是有长度限制的，而POST没有长度限制对参数的数据类型，GET只能请求ASCII字符，而POST没有限制GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传敏感信息GET参数通过URL传递，POST放在Request body中 12345678910111213HTTP状态码1XX：指示信息-表示请求已接受，继续处理2XX：成功-表示请求已被成功接收200 OK ：客户端请求成功206 Partial Content：客户发送一个带有Range头的GET请求，服务器完成了它 播放视频和音频3XX：重定向-要完成请求必须进行更进一步的操作301 Move Permanently：所请求的页面已经转移至新的URL302 Found：所请求的页面已经临时转移到新的URL304 Not Modified：客户端有缓冲的文档并发出一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用4XX：客户端错误-请求有语法错误或请求无法实现400 Bad Request：客户端请求有语法错误，不能被服务器所理解401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden：对被请求页面的访问被禁止404 Not Found：请求资源不存在5XX：服务错误-服务器未能实现合法的请求500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用503 Server Unavailable：请求未完成，服务器临时过载或当机，一段事件后恢复正常 301和302 301与302：二者都是进行重定向，前者为永久重定向，后者为临时重定向。301，302对用户来说没有区别，他们看到效果只是一个跳转，浏览器中旧的URL变成了新的URL。实际工作中，当我们的前一个域名被永久性停止使用，并且不希望用户还能访问以前的域名时，我们会用到301。 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。他们的不同在于:301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了）， 搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问）， 这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 301重定向和302重定向的区别: 302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。 而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。 1234567891011301适合永久重定向 301比较常用的场景是使用域名跳转。 比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com， 发送请求之后，就会返回301状态码， 然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。 注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。 或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。302用来做临时跳转 比如未登陆的用户访问用户中心重定向到登录页面。 访问404页面会重新定向到首页。 123456789101112131415161718301—永久移动。被请求的资源已被永久移动位置； 【永久重定向】302—请求的资源现在临时从不同的 URI 响应请求； 【临时重定向】305—使用代理。被请求的资源必须通过指定的代理才能被访问； 307—临时跳转。被请求的资源在临时从不同的URL响应请求； 400—错误请求； 402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付； 403—禁止访问。服务器已经理解请求，但是拒绝执行它； 404—找不到对象。请求失败，资源不存在； 406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体； 408—请求超时； 409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成； 410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址； 413—响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。 417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足； 418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现； 420—方法失效。 422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应； 500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理； JS返回所有子节点对象childNodes12345678910var mylist = document.getElementById(&apos;myid&apos;);for(var i=0,i&lt;mylist.childNodes.length;i++)&#123;console.log(mylist.childNodes[i]);&#125;firstChild返回第一个子节点lastChild返回最后一个子节点parentNode返回父节点对象nextSibling返回下一个兄弟节点对象previousSibling返回前一个兄弟节点对象nodeName返回节点的HTML标记名称 insertBefore()插入节点（父节点内容的最前面）注意：insertBefore()有两个参数，第一个是插入的节点，第二个是插入的位置 例子：123var list = document.getElementById(&apos;myList&apos;);list.insertBefore(newItem,list.childNodes[1]);//插入新节点newItem到list的第二个子节点 Element.matches 精确匹配12345678document.getElementById(&apos;list&apos;).addEventListener(&apos;click&apos;, function (e) &#123; // 兼容性处理 var event = e || window.event; var target = event.target || event.srcElement; if (target.matches(&apos;li.class-1&apos;)) &#123; console.log(&apos;the content is: &apos;, target.innerHTML); &#125;&#125;); 移动端touch事件(区分webkit 和 winphone) 当用户手指放在移动设备在屏幕上滑动会触发的touch事件,以下支持webkit12345678910touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动touchend——当手指离开屏幕时触发touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用TouchEventtouches：屏幕上所有手指的信息targetTouches：手指在目标区域的手指信息changedTouches：最近一次触发该事件的手指信息touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息参数信息(changedTouches[0])clientX、clientY在显示区的坐标target：当前元素 全局错误监控监听window上的error事件，过滤事件代理的error。 手动触发一个dom事件，需要3步，如果你对document.createEvent,�不是很熟悉，可以点击查看。创建一个事件对象 document.createEvent(event)初始化事件对象 event.initEvent(type, bubbles, true)分发事件 dom.dispatchEvent(event) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Object.preventExtensions(obj) 让一个对象变的不可扩展，也就是永远不能再添加新的属性。Object.isExtensible(obj) 判断一个对象是否是可扩展的Object.seal(obj)让一个对象密封(只能读写 不能新增)Object.isSealed(obj)判断一个对象是否密封Object.isFrozen(arr) 让一个对象被冻结(只能读)Object.isFrozen(obj)：判断一个对象是否被冻结Object.keys(obj) 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组Object.getOwnPropertyNames(obj)：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组Object.is(value1, value2)：判断两个值是否是同一个值,Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。Object.create(proto [, propertiesObject ]) 是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个参数是对象的属性描述符，这个参数是可选的。Object.assign 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。【浅复制】//var copy = Object.assign(&#123;&#125;, obj);Object.defineProperty() 定义单个对象属性或方法(可以设置读写可枚举)Object.defineProperties() 定义多个对象属性或方法(可以设置读写可枚举)Object.assign() //浅拷贝，类似&#123;...obj1,...obj2&#125; 都是浅拷贝Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125;//如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。var target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;var source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;停止jq中的ajax请求用abort()函数 var currentAjax = null; functionstartAjax()&#123; //方法就是将XHR对象指向currentAjax，再调用currentAjax的.abort()来中止请求 currentAjax = $.ajax(&#123; type:&apos;POST&apos;, beforeSend:function()&#123;&#125;, url:&apos;test.php&apos;, data:&apos;username=xxx&apos;, dataType:&apos;JSON&apos;, error:function()&#123;alert(&apos;error&apos;)&#125;, success:function(data)&#123;alert(data)&#125; &#125;); &#125; functionstopAjax()&#123; //如若上一次AJAX请求未完成，则中止请求 if(currentAjax) &#123;currentAjax.abort();&#125; &#125; JSONP 超时： 设置超时标志位flag=false，当超时后将flag=true; 异步加载JS文件并执行回调函数： function loadJS(src, callback)&#123; var script = document.createElement(&apos;script&apos;); var head = document.getElementsByTagName(&apos;head&apos;)[0]; var loaded; script.src = src; if(typeof callback === &apos;function&apos;)&#123; script.onload = script.onreadystatechange = function()&#123; if(!loaded &amp;&amp; (!script.readyState || /loaded|complete/.test(script.readyState)))&#123; script.onload = script.onreadystatechange = null; loaded = true; callback(); &#125; &#125; &#125; head.appendChild(script);&#125; 获取元素的绝对位置1234567891011121314151617181920function getPosition(node) &#123; var width = node.offsetWidth; //元素宽度 var height = node.offsetHeight; //元素高度 var left = node.offsetLeft; //获取元素相对于其根元素的left值var left var top = node.offsetTop; //获取元素相对于其根元素的top值var top current = node.offsetParent; // 取得元素的offsetParent // 一直循环直到根元素 while(current != null) &#123; left += current.offsetLeft; top += current.offsetTop; current = current.offsetParent; &#125; return &#123; &quot;width&quot;: width, &quot;height&quot;: height, &quot;left&quot;: left, &quot;top&quot;: top &#125;;&#125; 动画结束时事件123456789101112131415161718192021o.addEventListener(&quot;webkitAnimationEnd&quot;, function() &#123; console.log(&quot;动画结束&quot;);&#125;)-webkit-animation动画有三个事件：开始事件: webkitAnimationStart结束事件: webkitAnimationEnd重复运动事件: webkitAnimationIteration// 动画开始时事件o.addEventListener(&quot;webkitAnimationStart&quot;, function() &#123; console.log(&quot;动画开始&quot;);&#125;)// 动画重复运动时事件o.addEventListener(&quot;webkitAnimationIteration&quot;, function() &#123; console.log(&quot;动画重复运动&quot;);&#125;)// 动画结束时事件o.addEventListener(&quot;webkitAnimationEnd&quot;, function() &#123; console.log(&quot;动画结束&quot;);&#125;) 解决键盘弹出遮挡：123456789101112131415// 解决键盘弹出后挡表单的问题 window.addEventListener(&apos;resize&apos;, function() &#123; if( document.activeElement.tagName === &apos;INPUT&apos; || document.activeElement.tagName === &apos;TEXTAREA&apos; ) &#123; window.setTimeout(function() &#123; if(&apos;scrollIntoView&apos; in document.activeElement) &#123; document.activeElement.scrollIntoView(); &#125; else &#123; document.activeElement.scrollIntoViewIfNeeded(); &#125; &#125;, 0); &#125; &#125;); 单个for循环实现排序：1234567891011121314var a = [12, 13, 65, 54, 86, 21, 37, 1, 95, 4];var l=a.length; for(var i = 0; i &lt; l; i++) &#123; if(a[i] &gt; a[i + 1]) &#123; var tem = a[i]; a[i] = a[i + 1]; a[i + 1] = tem; &#125; if(i == l - 1) &#123; i = -1; l--; &#125; &#125; console.log(a); Object.assign实现:1234567891011121314151617181920212223242526272829303132333435363738if (!Object.assign) &#123; // 定义assign方法 Object.defineProperty(Object, &apos;assign&apos;, &#123; enumerable: false, configurable: true, writable: true, value: function(target) &#123; // assign方法的第一个参数 &apos;use strict&apos;; // 第一个参数为空，则抛错 if (target === undefined || target === null) &#123; throw new TypeError(&apos;Cannot convert first argument to object&apos;); &#125; var to = Object(target); // 遍历剩余所有参数 for (var i = 1; i &lt; arguments.length; i++) &#123; var nextSource = arguments[i]; // 参数为空，则跳过，继续下一个 if (nextSource === undefined || nextSource === null) &#123; continue; &#125; nextSource = Object(nextSource); // 获取改参数的所有key值，并遍历 var keysArray = Object.keys(nextSource); for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) &#123; var nextKey = keysArray[nextIndex]; var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey); // 如果不为空且可枚举，则直接浅拷贝赋值 if (desc !== undefined &amp;&amp; desc.enumerable) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; return to; &#125; &#125;);&#125; JavaScript中巧用位运算12345678910111213141516日常前端开发中我们很少用到位运算，容易让人遗忘，让我们一起回顾下一下js中的位运算。位运算详细说明查看JavaScript|MDN下面主要回顾一下一些常用的位运算的巧用。将十进制转化为二进制var number = 3;var result = number.toString(2);var result2 = 14..toString(2); // &quot;1110&quot;我们使用位运算来代替Math.floor()来向下取整var data = 2.2352524535;var result = data | 0; // 2var re2 = ~~data; // 2 将颜色从RGA转换为Hex格式1234567var color = &#123;r: 186, g: 218, b: 85&#125;;// RGB to HEXvar rgb2hex = function(r, g, b) &#123; return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).substr(1);&#125;rgb2hex(color.r, color.g, color.b);//&quot;#bada55&quot; 常用函数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/*========================常用函数========================*//*时间格式化*/Date.prototype.Format = function (fmt) &#123; var o = &#123; &quot;M+&quot;: this.getMonth() + 1, /*月份*/ &quot;d+&quot;: this.getDate(), /*日*/ &quot;h+&quot;: this.getHours(), /*小时*/ &quot;m+&quot;: this.getMinutes(), /*分*/ &quot;s+&quot;: this.getSeconds(), /*秒*/ &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), /*季度*/ &quot;S&quot;: this.getMilliseconds() /*毫秒*/ &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt;&#125;;/*IE浏览器不支持date(time),所以用此方法转换*/function NewDate(fmt) &#123; /*首先将日期分隔 ，获取到日期部分 和 时间部分*/ var day = fmt.split(&apos; &apos;); /*获取日期部分的年月日*/ var days = day[0].split(&apos;-&apos;); /*获取时间部分的 时分秒*/ var mi = day[day.length - 1].split(&apos;:&apos;); /*获取当前date类型日期*/ var date = new Date(); /*给date赋值 年月日*/ date.setUTCFullYear(days[0], days[1] - 1, days[2]); /*给date赋值 时分秒 首先转换utc时区 ：+8*/ date.setUTCHours(mi[0] - 8, mi[1], mi[2]); return date;&#125;/*为空判断*/function isEmpty(s) &#123; switch (typeof(s)) &#123; case &apos;string&apos;: return !s.length; break; case &apos;array&apos;: case &apos;object&apos;: for (var i in s) return false; return true; break; case &apos;undefined&apos;: return true; break; default: return !s; break; &#125;&#125;/*数字判断*/function isNumber(s) &#123; return typeof(s) == &apos;number&apos; ? true : false;&#125;/*整数判断*/function isInt(s) &#123; var re = /^-?\d*$/; return re.test(s);&#125;/*正整数判断*/function isUInt(s) &#123; var re = /^\d*$/; return re.test(s) &amp;&amp; s &gt;= 0;&#125;/*小数判断*/function isDecimal(s, bit) &#123; if (!arguments[1]) bit = -1; if (bit == -1) &#123; var re = /^-?\d*.?\d*$/; return re.test(s); &#125; else &#123; var re = new RegExp(&apos;^-?\\d*.?\\d&#123;0,&apos; + bit + &apos;&#125;$&apos;); return re.test(s); &#125;&#125;/*正小数判断*/function isUDecimal(s, bit) &#123; if (!arguments[1]) bit = -1; if (bit == -1) &#123; var re = /^\d*.?\d*$/; return re.test(s) &amp;&amp; s &gt;= 0; &#125; else &#123; var re = new RegExp(&apos;^\\d*.?\\d&#123;0,&apos; + bit + &apos;&#125;$&apos;); return re.test(s) &amp;&amp; s &gt;= 0; &#125;&#125;/*字符串判断*/function isString(s) &#123; return typeof(s) == &apos;string&apos;;&#125;/*========================/常用函数========================*/js onkeyup replace 自动替换检测浮点数 只能是整数或者小数 多余的就replace 掉 的表单验证function checkFloatNum(obj)&#123; //先把非数字的都替换掉，除了数字和. obj.value = obj.value.replace(/[^\d.]/g,&quot;&quot;); //必须保证第一个为数字而不是. obj.value = obj.value.replace(/^\./g,&quot;&quot;); //保证只有出现一个.而没有多个. obj.value = obj.value.replace(/\.&#123;2,&#125;/g,&quot;.&quot;); //保证.只出现一次，而不能出现两次以上 obj.value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;);&#125; performance1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950;(function() &#123; handleAddListener(&apos;load&apos;, getTiming) function handleAddListener(type, fn) &#123; if(window.addEventListener) &#123; window.addEventListener(type, fn) &#125; else &#123; window.attachEvent(&apos;on&apos; + type, fn) &#125; &#125; function getTiming() &#123; try &#123; var time = performance.timing; var timingObj = &#123;&#125;; var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000; if(loadTime &lt; 0) &#123; setTimeout(function() &#123; getTiming(); &#125;, 200); return; &#125; timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000; timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000; timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000; timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000; timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000; timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000; timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000; timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000; timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000; timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]); for(item in timingObj) &#123; console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;); &#125; console.log(performance.timing); &#125; catch(e) &#123; console.log(timingObj) console.log(performance.timing); &#125; &#125;&#125;)(); Cookie1234567891011121314151617181920212223242526export default class Cookie &#123; //写cookies static setCookie = (name, value) =&gt; &#123; var Days = 30; var exp = new Date(); exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000); document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString(); &#125; //读取cookies static getCookie = (name) =&gt; &#123; var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;); if(arr = document.cookie.match(reg)) return unescape(arr[2]); else return null; &#125; //删除cookies static delCookie = (name) =&gt; &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval = getCookie(name); if(cval != null) document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString(); &#125;&#125; jsonp123456789101112131415161718192021222324252627282930313233 function jsonp(objects)&#123; objects = objects || &#123;&#125;; if(!objects.url || !objects.callback)&#123; throw new Error(&apos;参数不合法&apos;); &#125; //创建script标签并插入 var callbackName = (&apos;jsonp_&apos; + Math.random()).replace(&quot;.&quot;, &quot;&quot;);//随机生成callbackName var script = document.createElement(&apos;script&apos;); var body = document.getElementsByTagName(&apos;body&apos;)[0]; body.appendChild(script); window[callbackName] = function (json) &#123; body.removeChild(script); clearTimeout(script.timer); window[callbackName] = null; objects.callback &amp;&amp; objects.callback(json); &#125;; //发出请求 script.src = objects.url + callbackName; //响应时间 if(objects.time)&#123; script.timer = setTimeout(function () &#123; window[callbackName] = null; body.removeChild(script); objects.fail &amp;&amp; objects.fail(&apos;超时&apos;); &#125;, objects.time); &#125; &#125;&#125; js判断DOM是否包含另一个DOM1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .first&#123; width: 200px; height: 200px; background: red; &#125; .first-child&#123; width: 100px; height: 100px; background: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;first&quot;&gt; &lt;div class=&quot;first-child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;second&quot;&gt; &lt;div class=&quot;second-child&quot;&gt; &lt;div class=&quot;second-child-child&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var first = document.querySelector(&apos;.first&apos;); var firstchild = document.querySelector(&apos;.first-child&apos;); var second = document.querySelector(&apos;.second&apos;); var secondchild = document.querySelector(&apos;.second-child&apos;); var secondchildchild = document.querySelector(&apos;.second-child-child&apos;); function isChildOf(child, parent) &#123; var parentNode; if(child &amp;&amp; parent) &#123; parentNode = child.parentNode; while(parentNode) &#123; if(parent === parentNode) &#123; return true; &#125; parentNode = parentNode.parentNode; &#125; &#125; return false; &#125; console.log(isChildOf(firstchild, first)); console.log(isChildOf(secondchild, second)); console.log(isChildOf(secondchildchild, secondchild)); console.log(isChildOf(secondchildchild, second)); console.log(isChildOf(secondchildchild, first)); console.log(document.documentElement.contains(document.body)); console.log(second.contains(secondchildchild)); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 回到顶部带动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/* 滚动条动画： * 移动端:document.body.scrollTop PC端：document.documentElement.scrollTop //使用:gotoTop(400,callBack) gotoTop(durations, callback = undefined) &#123; const doc = document.documentElement const scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0) for (var i = 60; i &gt;= 0; i--) &#123; setTimeout((i =&gt; &#123; return () =&gt; &#123; doc.scrollTop = scrollTop * i / 60 if (i === 0 &amp;&amp; typeof callback === &apos;function&apos;) &#123; callback() &#125; &#125; &#125;)(i), durations * (1 - i / 60)) &#125; &#125; * */var requestAnimFrame = (function() &#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback) &#123; window.setTimeout(callback, 1000 / 60); &#125;;&#125;)();var cancelAnimationFrame = (function() &#123; return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || function(id) &#123; window.clearTimeout(id) &#125;&#125;)()// Tween中的方法接受4个参数t,b,c,d 。t为初始时间 b、c、d三个参数（即初始值，变化量，持续时间）。返回值为当前位置// t =&gt; time(初始记步次数) b =&gt; begin(初始位置) c =&gt; change(变化量) d =&gt; duration(持续次数)var tween = &#123; linear: function(t, b, c, d) &#123; return c * t / d + b; &#125;, easeIn: function(t, b, c, d) &#123; return c * (t /= d) * t + b; &#125;, strongEaseIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t * t * t + b; &#125;, strongEaseOut: function(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t * t * t + 1) + b; &#125;, sineaseIn: function(t, b, c, d) &#123; return c * (t /= d) * t * t + b; &#125;, sineaseOut: function(t, b, c, d) &#123; return c * ((t = t / d - 1) * t * t + 1) + b; &#125;, easeInOutQuad: function(t, b, c, d) &#123; t /= d / 2; if(t &lt; 1) return c / 2 * t * t + b; t--; return -c / 2 * (t * (t - 2) - 1) + b; &#125;&#125;;var myReq; export var animatedScrollTo = function(element, to, duration, callback, Bzr = &apos;linear&apos;) &#123; var start = element.scrollTop, change = to - start, animationStart = +new Date(); var animating = true; var lastpos = null; var animateScroll = function() &#123; if(!animating) &#123; return; &#125; myReq=requestAnimFrame(animateScroll); var now = +new Date(); var val = Math.floor(tween[Bzr](now - animationStart, start, change, duration)); if(lastpos) &#123; if(lastpos === element.scrollTop) &#123; lastpos = val; element.scrollTop = val; &#125; else &#123; animating = false; &#125; &#125; else &#123; lastpos = val; element.scrollTop = val; &#125; if(now &gt; animationStart + duration) &#123; element.scrollTop = to; animating = false; cancelAnimationFrame(myReq); //清除定时器动画 callback&amp;&amp;callback(); &#125; &#125;; myReq=requestAnimFrame(animateScroll);&#125;; 使用js唤起Native下的App123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188/** * 浏览器的相关信息 */var Browser = /** @class */ (function() &#123; function Browser() &#123;&#125; /** * 获取浏览器数据 */ Browser.getBrowser = function() &#123; var UA = navigator.userAgent || &apos;&apos; var isAndroid = (function() &#123; return UA.match(/Android/i) ? true : false &#125;)() var isQQ = (function() &#123; return /(iPad|iPhone|iPod).*? (IPad)?QQ\/([\d\.]+)/.test(UA) || /\bV1_AND_SQI?_([\d\.]+)(.*? QQ\/([\d\.]+))?/.test(UA) &#125;)() var isIOS = (function() &#123; return UA.match(/iPhone|iPad|iPod/i) ? true : false &#125;)() var isSafari = (function() &#123; return /iPhone|iPad|iPod\/([\w.]+).*(safari).*/i.test(UA) &#125;)() var isWx = (function() &#123; return UA.match(/micromessenger/i) ? true : false &#125;)() var isWb = (function() &#123; return UA.match(/weibo/i) ? true : false &#125;)() var isAndroidChrome = (function() &#123; return(UA.match(/Chrome\/([\d.]+)/) || UA.match(/CriOS\/([\d.]+)/)) &amp;&amp; isAndroid &amp;&amp; !isQQ &#125;)() var isQZ = (function() &#123; return UA.indexOf(&apos;Qzone/&apos;) !== -1 &#125;)() var browser = &#123; isAndroid: isAndroid, isIOS: isIOS, isSafari: isSafari, isQQ: isQQ, isWb: isWb, isWx: isWx, isQZ: isQZ, isAndroidChrome: isAndroidChrome &#125; return browser &#125; return Browser&#125;)()/** * AppLink:H5唤起APP的所有方法 */var AppLink = /** @class */ (function() &#123; /** * 类的contructor方法 * @param config IAppLink类型的config文件 */ function AppLink(config) &#123; /** * UA */ this.UA = &#123;&#125; /** * 传入的config数据，以接口约束 */ this.config = &#123;&#125; this.UA = navigator.userAgent || &apos;&apos; this.config = config &#125; /** * 跳转函数 * @param url 链接 */ AppLink.prototype.go = function(url) &#123; window.location.href = url &#125; /** * 检查是否唤起 * @param cb 回调函数 */ AppLink.prototype.checkOpen = function(cb) &#123; var inter = null var statue = false var count = 0 inter = window.setInterval(function() &#123; count++ statue = document.hidden || document.webkitHidden if(statue || count &gt; 40) &#123; cb(statue) clearInterval(inter) &#125; &#125;, 50) &#125; /** * 外部调用的入口函数 */ AppLink.prototype.open = function() &#123; var _this = this var browser = Browser.getBrowser() var config = this.config // 微信直接跳 应用宝 if(browser.isWx) &#123; this.go(this.config.yyb) &#125; else if(browser.isQQ) &#123; if(browser.isIOS) &#123; // 没有下载 this.checkOpen(function(isSuccess) &#123; if(!isSuccess) &#123; _this.go(_this.config.appstore) &#125; &#125;) &#125; // iOS跳到AppStore if(browser.isAndroid) &#123; // 使用scheme唤起 this.tryCallApp(this.config.schema) // 唤起失败 跳到应用宝 this.checkOpen(function(isSuccess) &#123; if(!isSuccess) &#123; _this.go(_this.config.yyb) &#125; &#125;) &#125; &#125; else if(browser.isWb) &#123; // 使用scheme唤起 this.tryCallApp(this.config.schema) // 微博：唤起失败，也不跳转，会有引导功能 &#125; else if(browser.isSafari) &#123; var version = this.getIOSVersion() // iOS10以下不支持直接跳转到AppStore，跳到应用宝 if(version &lt; 10) &#123; this.go(this.config.yyb) &#125; else &#123; this.go(this.config.appstore) &#125; &#125; else &#123; // 其他情况，直接跳应用宝 this.go(this.config.yyb) &#125; &#125; /** * 下载按钮的url地址 */ AppLink.prototype.getDownloadUrl = function() &#123; var browser = Browser.getBrowser() var config = this.config var url = &apos;&apos; if(browser.isQQ) &#123; if(browser.isIOS) &#123; url = this.config.appstore &#125; else &#123; url = this.config.yyb &#125; &#125; else if(browser.isSafari) &#123; var version = this.getIOSVersion() if(version &lt; 10) &#123; url = this.config.yyb &#125; else &#123; url = this.config.appstore &#125; &#125; else if(browser.isWb) &#123; url = &apos;&apos; &#125; else &#123; url = this.config.yyb &#125; return url &#125; /** * 尝试唤起APP * @param scheme 唤起的scheme */ AppLink.prototype.tryCallApp = function(scheme) &#123; var aLink = document.createElement(&apos;a&apos;), body = document.body aLink.href = scheme body.appendChild(aLink) aLink.click() &#125; /** * 判断iOS版本 */ AppLink.prototype.getIOSVersion = function() &#123; var ver = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/) var version = parseInt(ver[1], 10) return version &#125; return AppLink&#125;)() 获取CSS样式1234567function getStyle(obj, attr) &#123; if(obj.currentStyle) &#123; return obj.currentStyle[attr]; //IE678 &#125; else &#123; return window.getComputedStyle(obj, null)[attr]; &#125;&#125; Colors123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function rgbToRgba(rgbValue) &#123; const rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue); return rgb ? `rgba($&#123;rgb[1]&#125;,1)` : rgbValue;&#125;function hexToRgba(hexValue) &#123; const rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i; const hex = hexValue.replace(rgx, (m, r, g, b) =&gt; r + r + g + g + b + b); const rgb = /^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i.exec(hex); const r = parseInt(rgb[1], 16); const g = parseInt(rgb[2], 16); const b = parseInt(rgb[3], 16); return `rgba($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;,1)`;&#125;function hslToRgba(hslValue) &#123; const hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue); const h = parseInt(hsl[1]) / 360; const s = parseInt(hsl[2]) / 100; const l = parseInt(hsl[3]) / 100; const a = hsl[4] || 1; function hue2rgb(p, q, t) &#123; if(t &lt; 0) t += 1; if(t &gt; 1) t -= 1; if(t &lt; 1 / 6) return p + (q - p) * 6 * t; if(t &lt; 1 / 2) return q; if(t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6; return p; &#125; let r, g, b; if(s == 0) &#123; r = g = b = l; &#125; else &#123; const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s; const p = 2 * l - q; r = hue2rgb(p, q, h + 1 / 3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1 / 3); &#125; return `rgba($&#123;r * 255&#125;,$&#123;g * 255&#125;,$&#123;b * 255&#125;,$&#123;a&#125;)`;&#125;function colorToRgb(val) &#123; if(is.rgb(val)) return rgbToRgba(val); if(is.hex(val)) return hexToRgba(val); if(is.hsl(val)) return hslToRgba(val);&#125; 750rem12345678910111213141516(function(doc, win) &#123; var docEl = doc.documentElement, resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;, recalc = function() &#123; var clientWidth = docEl.clientWidth; if(!clientWidth) return; if(clientWidth &gt;= 750) &#123; docEl.style.fontSize = &apos;100px&apos;; &#125; else &#123; docEl.style.fontSize = 100 * (clientWidth / 750) + &apos;px&apos;; &#125; &#125;; if(!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);&#125;)(document, window); 表单验证12345678910111213141516171819202122static checkType = (str, type) =&gt; &#123; switch(type) &#123; case &apos;email&apos;: return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str); case &apos;phone&apos;: return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str); case &apos;tel&apos;: return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str); case &apos;number&apos;: return /^[0-9]$/.test(str); case &apos;english&apos;: return /^[a-zA-Z]+$/.test(str); case &apos;chinese&apos;: return /^[\u4E00-\u9FA5]+$/.test(str); case &apos;lower&apos;: return /^[a-z]+$/.test(str); case &apos;upper&apos;: return /^[A-Z]+$/.test(str); default: return true; &#125;&#125; navigator帮助类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120class navigatorUtil &#123; /** * 头部信息 * @type &#123;[type]&#125; */ static userAgent = navigator.userAgent; /** * 是否为ipad */ static isIPad = () =&gt; &#123; return(navigatorUtil.userAgent.indexOf(&quot;iPad&quot;) &gt; -1); &#125; /** * 是否为iphone * @param &#123;[type]&#125; userAgent [description] * @return &#123;Boolean&#125; [description] */ static isIPhone = () =&gt; &#123; return(navigatorUtil.userAgent.indexOf(&quot;iPhone&quot;) &gt; -1); &#125; /** * 是否为ios系统 * @param &#123;[type]&#125; userAgent [description] * @return &#123;Boolean&#125; [description] */ static isIOS = () =&gt; &#123; return navigatorUtil.isIPad(navigatorUtil.userAgent) || navigatorUtil.isIPhone( navigatorUtil.userAgent); &#125; /** * 是否为Android系统 * @param &#123;[type]&#125; userAgent [description] * @return &#123;Boolean&#125; [description] */ static isAndroid = () =&gt; &#123; return(navigatorUtil.userAgent.indexOf(&quot;Android&quot;) &gt; -1) || (navigatorUtil.userAgent.indexOf(&quot;Linux&quot;) &gt; -1); &#125; /** * 判断是否为微信 */ static isWeixin = () =&gt; &#123; return(navigatorUtil.userAgent.indexOf(&quot;MicroMessenger&quot;) &gt; -1); &#125; /** * * @desc 获取浏览器类型和版本 * @return &#123;String&#125; */ static getExplore = () =&gt; &#123; var sys = &#123;&#125;, ua = navigator.userAgent.toLowerCase(), s; (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]: (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] : (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] : (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] : (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] : (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] : (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0; // 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie) if(sys.edge) return(&apos;EDGE: &apos; + sys.edge) if(sys.firefox) return(&apos;Firefox: &apos; + sys.firefox) if(sys.chrome) return(&apos;Chrome: &apos; + sys.chrome) if(sys.opera) return(&apos;Opera: &apos; + sys.opera) if(sys.safari) return(&apos;Safari: &apos; + sys.safari) return &apos;Unkonwn&apos; &#125; /** * * @desc 获取操作系统类型 * @return &#123;String&#125; */ static getOS = () =&gt; &#123; var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;; var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;; var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;; if(/mac/i.test(appVersion)) return &apos;MacOSX&apos; if(/win/i.test(appVersion)) return &apos;windows&apos; if(/linux/i.test(appVersion)) return &apos;linux&apos; if(/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos; if(/android/i.test(userAgent)) return &apos;android&apos; if(/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos; &#125; //进入全屏模式, 判断各种浏览器，找到正确的方法 static launchFullScreen = (element) =&gt; &#123; if(element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if(element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if(element.webkitRequestFullscreen) &#123; element.webkitRequestFullscreen(); &#125; else if(element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125; return true; &#125; //退出全屏模式 static exitFullScreen = () =&gt; &#123; if(document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if(document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if(document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125; return false; &#125;&#125; promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224function Promise(task) &#123; let self = this; //缓存this self.status = &apos;pending&apos;; //默认状态为pending self.value = undefined; //存放着此promise的结果 self.onResolvedCallbacks = []; //存放着所有成功的回调函数 self.onRejectedCallbacks = []; //存放着所有的失败的回调函数 // 调用resolve方法可以把promise状态变成成功态 function resolve(value) &#123; if(value instanceof Promise) &#123; return value.then(resolve, reject) &#125; setTimeout(function() &#123; // 异步执行所有的回调函数 // 如果当前状态是初始态（pending），则转成成功态 // 此处这个写判断的原因是因为resolved和rejected两个状态只能由pending转化而来，两者不能相互转化 if(self.status == &apos;pending&apos;) &#123; self.value = value; self.status = &apos;resolved&apos;; self.onResolvedCallbacks.forEach(item =&gt; item(self.value)); &#125; &#125;); &#125; // 调用reject方法可以把当前的promise状态变成失败态 function reject(value) &#123; setTimeout(function() &#123; if(self.status == &apos;pending&apos;) &#123; self.value = value; self.status = &apos;rejected&apos;; self.onRejectedCallbacks.forEach(item =&gt; item(value)); &#125; &#125;); &#125; // 立即执行传入的任务 try &#123; task(resolve, reject); &#125; catch(e) &#123; reject(e); &#125;&#125;/** * resolvePromise函数的目的是与原生Promise相兼容，可以互相调用 */function resolvePromise(promise2, x, resolve, reject) &#123; // 将返回的promise不停的调用执行，直到失败或者返回一个普通的数据类型 if(promise2 === x) &#123; return reject(new TypeError(&apos;循环引用&apos;)); &#125; let then, called; if(x != null &amp;&amp; ((typeof x == &apos;object&apos; || isFunction(x)))) &#123; // promise try &#123; then = x.then; if(isFunction(then)) &#123; then.call(x, function(value) &#123; if(called) return; called = true; resolvePromise(promise2, value, resolve, reject); &#125;, function(reason) &#123; if(called) return; called = true; reject(reason); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch(e) &#123; if(called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;/** * onFulfilled成功的回调，onReject失败的回调 */Promise.prototype.then = function(onFulfilled, onRejected) &#123; let self = this; // 当调用时没有写函数给它一个默认函数值 onFulfilled = isFunction(onFulfilled) ? onFulfilled : function(value) &#123; return value &#125;; onRejected = isFunction(onRejected) ? onRejected : function(value) &#123; throw value &#125;; let promise2; if(self.status == &apos;resolved&apos;) &#123; promise2 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if(self.status == &apos;rejected&apos;) &#123; promise2 = new Promise(function(resolve, reject) &#123; setTimeout(function() &#123; try &#123; let x = onRejected(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if(self.status == &apos;pending&apos;) &#123; promise2 = new Promise(function(resolve, reject) &#123; self.onResolvedCallbacks.push(function(value) &#123; try &#123; let x = onFulfilled(value); resolvePromise(promise2, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push(function(value) &#123; try &#123; let x = onRejected(value); resolvePromise(promise2, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; return promise2;&#125;/** * catch实际上是then的一个简写,成功回调传空值即可 */Promise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected);&#125;/** * Promise.reject(error)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。 */Promise.resolve = function(value) &#123; return new Promise(function(resolve, reject) &#123; if(typeof value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; isFunction(value.then)) &#123; value.then(); &#125; else &#123; resolve(value); &#125; &#125;)&#125;;Promise.reject = function(reason) &#123; return new Promise(function(resolve, reject) &#123; reject(reason); &#125;)&#125;;/** * all方法，可以传入多个promise，全部执行完后会将结果以数组的方式返回，如果有一个失败就返回失败 */Promise.all = function(promises) &#123; return new Promise(function(resolve, reject) &#123; let result = []; // all方法最终返回的结果 let count = 0; // 完成的数量 for(let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(function(data) &#123; result[i] = data; if(++count == promises.length) &#123; resolve(result); &#125; &#125;, function(err) &#123; reject(err); &#125;); &#125; &#125;);&#125;/** * race方法，可以传入多个promise，返回的是第一个执行完的resolve的结果，如果有一个失败就返回失败 */Promise.race = function(promises) &#123; return new Promise(function(resolve, reject) &#123; for(let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(function(data) &#123; resolve(data); &#125;, function(err) &#123; reject(err); &#125;); &#125; &#125;);&#125;Promise.deferred = Promise.defer = function() &#123; var defer = &#123;&#125;; defer.promise = new Promise(function(resolve, reject) &#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer;&#125;/** * 一些会多次使用的复用功能函数 */function isFunction(obj) &#123; return typeof obj === &quot;function&quot;;&#125;/** * 最后可以通过以下命令安装一个promises测试插件，用插件来测试自己实现的promise符不符合规范 * npm(cnpm) i -g promises-aplus-tests * promises-aplus-tests Promise.js */module.exports = Promise; ES6 promise123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230class es6Promise &#123; constructor(task) &#123; let self = this; //缓存this self.status = &apos;pending&apos;; //默认状态为pending self.value = undefined; //存放着此promise的结果 self.onResolvedCallbacks = []; //存放着所有成功的回调函数 self.onRejectedCallbacks = []; //存放着所有的失败的回调函数 // 调用resolve方法可以把promise状态变成成功态 function resolve(value) &#123; if(value instanceof Promise) &#123; return value.then(resolve, reject) &#125; setTimeout(() =&gt; &#123; // 异步执行所有的回调函数 // 如果当前状态是初始态（pending），则转成成功态 // 此处这个写判断的原因是因为resolved和rejected两个状态只能由pending转化而来，两者不能相互转化 if(self.status == &apos;pending&apos;) &#123; self.value = value; self.status = &apos;resolved&apos;; self.onResolvedCallbacks.forEach(item =&gt; item(self.value)); &#125; &#125;); &#125; // 调用reject方法可以把当前的promise状态变成失败态 function reject(value) &#123; setTimeout(() =&gt; &#123; if(self.status == &apos;pending&apos;) &#123; self.value = value; self.status = &apos;rejected&apos;; self.onRejectedCallbacks.forEach(item =&gt; item(value)); &#125; &#125;); &#125; // 立即执行传入的任务 try &#123; task(resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125; /** * onFulfilled成功的回调，onReject失败的回调 * 原型链方法 */ then(onFulfilled, onRejected) &#123; let self = this; // 当调用时没有写函数给它一个默认函数值 onFulfilled = isFunction(onFulfilled) ? onFulfilled : value =&gt; value; onRejected = isFunction(onRejected) ? onRejected : value =&gt; &#123; throw value &#125;; let promise2; if(self.status == &apos;resolved&apos;) &#123; promise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if(self.status == &apos;rejected&apos;) &#123; promise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(self.value); resolvePromise(promise2, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; if(self.status == &apos;pending&apos;) &#123; promise2 = new Promise((resolve, reject) =&gt; &#123; self.onResolvedCallbacks.push(value =&gt; &#123; try &#123; let x = onFulfilled(value); resolvePromise(promise2, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); self.onRejectedCallbacks.push(value =&gt; &#123; try &#123; let x = onRejected(value); resolvePromise(promise2, x, resolve, reject); &#125; catch(e) &#123; reject(e); &#125; &#125;); &#125;); &#125; return promise2; &#125; /** * catch实际上是then的一个简写,成功回调传空值即可 * 原型链方法 */ catch(onRejected) &#123; return this.then(null, onRejected); &#125; /** * Promise.reject(err)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。 * 静态方法为类自己的方法，不在原型链上 */ static resolve(value) &#123; return new Promise((resolve, reject) =&gt; &#123; if(typeof value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; isFunction(value.then)) &#123; value.then(); &#125; else &#123; resolve(value); &#125; &#125;) &#125; static reject(err) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(err); &#125;) &#125; /** * all方法，可以传入多个promise，全部执行完后会将结果以数组的方式返回，如果有一个失败就返回失败 * 静态方法为类自己的方法，不在原型链上 */ static all(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = []; // all方法最终返回的结果 let count = 0; // 完成的数量 for(let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(data =&gt; &#123; result[i] = data; if(++count == promises.length) &#123; resolve(result); &#125; &#125;, err =&gt; &#123; reject(err); &#125;); &#125; &#125;); &#125; /** * race方法，可以传入多个promise，返回的是第一个执行完的resolve的结果，如果有一个失败就返回失败 * 静态方法为类自己的方法，不在原型链上 */ static race(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; for(let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(data =&gt; &#123; resolve(data); &#125;, err =&gt; &#123; reject(err); &#125;); &#125; &#125;); &#125;&#125;/** * resolvePromise函数的目的是与原生Promise相兼容，可以互相调用 */function resolvePromise(promise2, x, resolve, reject) &#123; // 将返回的promise不停的调用执行，直到失败或者返回一个普通的数据类型 if(promise2 === x) &#123; return reject(new TypeError(&apos;循环引用&apos;)); &#125; let then; let called; if(x != null &amp;&amp; ((typeof x == &apos;object&apos; || isFunction(x)))) &#123; // promise try &#123; then = x.then; if(isFunction(then)) &#123; then.call(x, value =&gt; &#123; if(called) return; called = true; resolvePromise(promise2, value, resolve, reject); &#125;, reason =&gt; &#123; if(called) return; called = true; reject(reason); &#125;); &#125; else &#123; resolve(x); &#125; &#125; catch(e) &#123; if(called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;Promise.deferred = Promise.defer = () =&gt; &#123; const defer = &#123;&#125;; defer.promise = new Promise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer;&#125;/** * 一些会多次使用的复用功能函数 */function isFunction(obj) &#123; return typeof obj === &quot;function&quot;;&#125;/** * 最后可以通过以下命令安装一个promises测试插件，用插件来测试自己实现的promise符不符合规范 * npm(cnpm) i -g promises-aplus-tests * promises-aplus-tests es6Promise.js */module.exports = es6Promise; 使用promise手动封装ajax函数 跨浏览器实现Ajax兼容 1234567891011var createXMLHttpRequest = function () &#123; if ( window.XMLHttpRequest ) &#123; return new XMLHttpRequest(); &#125; else if ( window.ActiveXObject ) &#123; return new ActiveXObject(&apos;Microsoft.XMLHttp&apos;); &#125; else &#123; return; &#125;&#125; Ajax的xhr对象有如下常用API 1234567891011121314onloadstart 开始send触发onprogress 从服务器上下载数据每50ms触发一次,判断进度onload 得到响应onerror 服务器异常open xhr.open(&apos;GET&apos;, url, true) 请求方式,请求url, true(默认)异步请求 onloadend 请求结束，无论成功失败onreadystatechange xhr.readyState改变使触发onabort 调用xhr.abort时触发ontimeout 超时触发setRequestHeader 设置RequestHeader，eg：xhr.setRequestHeader(&apos;Accept&apos;,&apos;application/json&apos;); xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);xhr.getAllResponseHeaders() 返回全部头信息,stringgetResponseHeader 获取Response头信息，eg：xhr.getResponseHeader(&apos;date&apos;); xhr.getResponseHeader(&apos;content-type&apos;); readyState上面都是静态函数。而readyState表示了请求的状态: value=0,open()方法还未被调用 value=1,open()调用,send()方法还未被调用 value=2,send()方法已经被调用，响应头和响应状态已经返回 value=3,响应体下载中，responseText中已经获取了部分数据 value=4,请求完成，整个请求过程已经完毕。 GET123456789101112131415161718function getJSON (url) &#123; return new Promise( (resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open(&apos;GET&apos;, url, true) xhr.onreadystatechange = function () &#123; //if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304)) if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; resolve(this.responseText, this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send() &#125;)&#125; POST12345678910111213141516171819function postJSON(url, data) &#123; return new Promise( (resolve, reject) =&gt; &#123; var xhr = new XMLHttpRequest() xhr.open(&quot;POST&quot;, url, true) xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); xhr.onreadystatechange = function () &#123; //if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304)) if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; resolve(JSON.parse(this.responseText), this) &#125; else &#123; var resJson = &#123; code: this.status, response: this.response &#125; reject(resJson, this) &#125; &#125; &#125; xhr.send(JSON.stringify(data)) &#125;)&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// ajax函数的默认参数var ajaxOptions = &#123; url: &apos;#&apos;, method: &apos;GET&apos;, async: true, timeout: 0, data: null, dataType: &apos;text&apos;, headers: &#123;&#125;, onprogress: function () &#123; &#125;, onuploadprogress: function () &#123; &#125;, xhr: null&#125;/** * ajax函数，返回一个promise对象 * @param &#123;Object&#125; optionsOverride 参数设置，支持的参数如下 * url: url地址，默认&quot;#&quot; * method: 请求方法，仅支持GET,POST,默认GET * async: 是否异步，默认true * timeout: 请求时限，超时将在promise中调用reject函数 * data: 发送的数据，该函数不支持处理数据，将会直接发送 * dataType: 接受的数据的类型，默认为text * headers: 一个对象，包含请求头信息 * onprogress: 处理onprogress的函数 * ouploadprogress: 处理.upload.onprogress的函数 * xhr: 允许在函数外部创建xhr对象传入，但必须不能是使用过的 * @return &#123;Promise&#125; * 该函数注册xhr.onloadend回调函数，判断xhr.status是否属于 [200,300)&amp;&amp;304 ， * 如果属于则promise引发resolve状态，允许拿到xhr对象 * 如果不属于，或已经引发了ontimeout,onabort,则引发reject状态，允许拿到xhr对象 * * 关于reject * 返回一个对象，包含 * errorType:错误类型， * abort_error: xhr对象调用abort函数 * timeout_error: 请求超时 * onerror: xhr对象触发了onerror事件 * send_error: 发送请求出现错误 * status_error: 响应状态不属于 [200,300)&amp;&amp;304 */function ajax(optionsOverride) &#123; // 将传入的参数与默认设置合并 var options = &#123;&#125;; for (var k in ajaxOptions) &#123; options[k] = optionsOverride[k] || ajaxOptions[k]; &#125; options.async = options.async === false ? false : true; var xhr = options.xhr = options.xhr || new XMLHttpRequest(); return new Promise(function (resolve, reject) &#123; xhr.open(options.method, options.url, options.async); xhr.timeout = options.timeout; //设置请求头 for (var k in options.headers) &#123; xhr.setRuquestHeader(k, options.headers[k]); &#125; // 注册xhr对象事件 xhr.onprogress = options.onprogress; xhr.upload.onprogress = options.onuploadprogress; xhr.responseType = options.dataType; xhr.onabort = function () &#123; reject(new Error(&#123; errorType: &apos;abort_error&apos;, xhr: xhr &#125;)); &#125; xhr.ontimeout = function () &#123; reject(&#123; errorType: &apos;timeout_error&apos;, xhr: xhr &#125;); &#125; xhr.onerror = function () &#123; reject(&#123; errorType: &apos;onerror&apos;, xhr: xhr &#125;) &#125; xhr.onloadend = function () &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) resolve(xhr); else&#123; reject(&#123; errorType: &apos;status_error&apos;, xhr: xhr &#125;) &#125; &#125; try &#123; xhr.send(options.data); &#125; catch (e) &#123; reject(&#123; errorType: &apos;send_error&apos;, error: e &#125;); &#125; &#125;)&#125; 二分查找 非递归算法 12345678910111213141516171819function binary_search(arr,key)&#123; var low=0, high=arr.length-1; while(low&lt;=high)&#123; var mid=parseInt((high+low)/2); if(key==arr[mid])&#123; return mid; &#125;else if(key&gt;arr[mid])&#123; low=mid+1; &#125;else if(key&lt;arr[mid])&#123; high=mid-1; &#125;else&#123; return -1; &#125; &#125;&#125;;var arr=[1,2,3,4,5,6,7,8,9,10,11,23,44,86];var result=binary_search(arr,10);alert(result); // 9 返回目标元素的索引值 递归算法 123456789101112131415161718function binary_search(arr,low,high,key)&#123; if(low&gt;high)&#123; return -1; &#125; var mid=parseInt((high+low)/2); if(arr[mid]==key)&#123; return mid; &#125;else if(arr[mid]&gt;key)&#123; high=mid-1; return binary_search(arr,low,high,key); &#125;else if(arr[mid]&lt;key)&#123; low=mid+1; return binary_search(arr,low,high,key); &#125;&#125;;var arr=[1,2,3,4,5,6,7,8,9,10,11,23,44,86];var result=binary_search(arr,0,13,10);alert(result); // 9 返回目标元素的索引值 排序 冒泡排序 123456789101112function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = i+1; j &lt; len -1; j++) &#123; arr[i] &gt; arr[j] ? [arr[i],arr[j]]= [arr[j],arr[i]]:null; &#125; &#125; return arr;&#125; bubbleSort([1,2,4,7,2,8,0,9,11,32,17]) [0, 1, 2, 2, 4, 7, 8, 9, 11, 32, 17] 123456789101112131415function bubble_sort(arr)&#123; for(var i=0;i&lt;arr.length-1;i++)&#123; for(var j=0;j&lt;arr.length-i-1;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; var swap=arr[j]; arr[j]=arr[j+1]; arr[j+1]=swap; &#125; &#125; &#125;&#125;var arr=[3,1,5,7,2,4,9,6,10,8];bubble_sort(arr);console.log(arr); 快速排序 12345678910111213141516171819202122function quick_sort(arr)&#123; if(arr.length&lt;=1)&#123; return arr; &#125; var pivotIndex=Math.floor(arr.length/2); var pivot=arr.splice(pivotIndex,1)[0]; var left=[]; var right=[]; for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i]&lt;pivot)&#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quick_sort(left).concat([pivot],quick_sort(right));&#125;var arr=[5,6,2,1,3,8,7,1,2,3,4,7];console.log(quick_sort(arr)); 12345678910111213141516function qSort(arr) &#123; if (arr.length==0) &#123; return []; &#125; var left = []; var right = []; var pivot = arr[0]; for (var i =1; i &lt;arr.length; i++) &#123; // 注意这里的起始值，因为有一个作为flag了 if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return qSort(left).concat(pivot, qSort(right)); &#125; 当我们 new 一个类的时候 都发生了什么1234567891011121314151617181920212223/** * new2 new关键字的代码实现演示 * @param &#123;function&#125; func 被new的类 (构造函数) */function new2(func) &#123; // 创建了一个实例对象 o，并且这个对象__proto__指向func这个类的原型对象 let o = Object.create(func.prototype); // (在构造函数中this指向当前实例)让这个类作为普通函数值行 并且里面this为实例对象 let k = func.call(o); // 最后再将实例对象返回 如果你在类中显示指定返回值k， // 注意如果返回的是引用类型则将默认返回的实例对象o替代掉 return typeof k === &apos;object&apos; ? k : o;&#125;// 实验functionM() &#123; // 即将被new的类 this.name = &apos;liwenli&apos;;&#125;let m = new2(M); // 等价于 new M 这里只是模拟console.log(m instanceof M); // instanceof 检测实例console.log(m instanceof Object);console.log(m.__proto__.constructor === M); Object.create 兼容实现123456789101112131415let obj1 = &#123;id: 1&#125;; Object._create = (o) =&gt; &#123; let Fn = function() &#123;&#125;; // 临时的构造函数 Fn.prototype = o; return new Fn; &#125; let obj2 = Object._create(obj1); console.log(obj2.__proto__ === obj1); // true console.log(obj2.id); // 1 // 原生的Object.create let obj3 = Object.create(obj1); console.log(obj3.__proto__ === obj1); // true console.log(obj3.id); // 1 curry 将多参数函数转换为接收单一参数的函数12345678910111213141516let fn = function(a, b, c) &#123; // 多参数函数 return a + b + c; &#125; function curry(fn) &#123; let args = []; // 收集参数 let len = fn.length; returnfunctionfe() &#123; args = args.concat([].slice.call(arguments, 0)); if (args.length === len) &#123; return fn.apply(null, args); &#125; return fe; &#125; &#125; console.log(curry(fn)(1)(2)(3)); // 6 函数节流 throttle 策略的电梯。保证如果电梯第一个人进来后，50毫秒后准时运送一次，不等待。如果没有人，则待机。 12345678910let throttle = (fn, delay = 50) =&gt; &#123; // 节流 控制执行间隔时间 防止频繁触发 scroll resize mousemove let stattime = 0; returnfunction (...args) &#123; let curTime = new Date(); if (curTime - stattime &gt;= delay) &#123; fn.apply(this, args); stattime = curTime; &#125; &#125; &#125; 防抖动 debounce 策略的电梯。如果电梯里有人进来，等待50毫秒。如果又人进来，50毫秒等待重新计时，直到50毫秒超时，开始运送。 12345678let debounce = (fn, time = 50) =&gt; &#123; // 防抖动 控制空闲时间 用户输入频繁 let timer; returnfunction (...args) &#123; let that = this; clearTimeout(timer); timer = setTimeout(fn.bind(that, ...args), time); &#125; &#125; Function的bind实现123456789101112131415Function.prototype._bind = function(context) &#123; let func = this; let params = [].slice.call(arguments, 1); returnfunction() &#123; params = params.concat([].slice.call(arguments, 0)); func.apply(context, params); &#125;&#125;let obj = &#123;id: 24&#125;function fn1(a) &#123; console.log(this, arguments);&#125;let foo = fn1._bind(obj, obj.id); 函数组合串联compose（koa reduce中间件）1234567891011// 组合串联let fn1 = (a) =&gt; a + 1;let fn2 = (b) =&gt; b + 2;let fn3 = (c) =&gt; c + 3;let funs = [fn1, fn2, fn3];let compose = (func) =&gt; &#123; return arg =&gt; func.reduceRight((composed, fn) =&gt; fn(composed), arg);&#125;console.log(compose(funs)(100)); // 相当于fn1(fn2(fn3(100))) co函数1234567891011121314151617181920212223242526272829function* fn(a) &#123; a = yield a; let b = yield 2; let c = yield 3; return a + b + c;&#125;function co(fn, ...args) &#123; let g = fn(...args); return new Promise((resolve, reject) =&gt; &#123; function next(lastValue) &#123; let &#123; value, done &#125; = g.next(lastValue); if (done) &#123; resolve(value); &#125; else &#123; if (value instanceof Promise) &#123; value.then(next, (val) =&gt; reject(val)); &#125; else &#123; next(value) &#125; &#125; &#125; next(); &#125;);&#125;co(fn, 100).then(value =&gt; &#123; console.log(value); // 105&#125;); 如何主动中止Promise调用链12345678910111213141516171819const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 异步操作 resolve(&apos;start&apos;) &#125;, 1000);&#125;);p1.then((result) =&gt; &#123; console.log(&apos;a&apos;, result); return Promise.reject(&apos;中断后续调用&apos;); // 此时rejected的状态将直接跳到catch里，剩下的调用不会再继续&#125;).then(result =&gt; &#123; console.log(&apos;b&apos;, result);&#125;).then(result =&gt; &#123; console.log(&apos;c&apos;, result);&#125;).catch(err =&gt; &#123; console.log(err);&#125;);// a start// 中断后续调用 window.requestAnimationFrame兼容性处理12345678window._requestAnimationFrame = (function()&#123; return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(callback)&#123; window.setTimeout(callback, 1000 / 60); &#125;;&#125;)(); 字符串是否符合回文规则12345678910111213141516171819let str = &apos;My age is 0, 0 si ega ym.&apos;;方法一function palindrome(params) &#123; params = params.replace(/[\W\s_]/ig, &apos;&apos;); return params.toLowerCase() === params.split(&apos;&apos;).reverse().join(&apos;&apos;).toLowerCase();&#125;console.log(palindrome(str));方法二function palindrome(params) &#123; params = params.replace(/[\W\s_]/ig, &apos;&apos;).toLowerCase(); for (var i = 0, j = params.length-1; i&lt;j; i++, j--) &#123; if (params[i] !== params[j]) &#123; returnfalse; &#125; &#125; returntrue;&#125; 解构:将 destructuringArray([1, [2, 3], 4], “[a, [b], c]”) =&gt; {a: 1, b: 2, c: 4}123456789101112131415161718192021222324// 将 destructuringArray([1, [2, 3], 4], &quot;[a, [b], c]&quot;) =&gt; &#123;a: 1, b: 2, c: 4&#125;const targetArray = [1, [2, 3], 4];const formater = &quot;[a, [b], c]&quot;;const destructuringArray = (values, keys) =&gt; &#123; try &#123; const obj = &#123;&#125;; if (typeof keys === &apos;string&apos;) &#123; keys = JSON.parse(keys.replace(/\w+/g, &apos;&quot;$&amp;&quot;&apos;)); &#125; const iterate = (values, keys) =&gt; keys.forEach((key, i) =&gt; &#123; if(Array.isArray(key)) iterate(values[i], key) else obj[key] = values[i] &#125;) iterate(values, keys) return obj; &#125; catch (e) &#123; console.error(e.message); &#125;&#125; 数组展平12345678将[[1, 2], 3, [[[4], 5]]] 展平为 [1, 2, 3, 4, 5]let arr = [[1, 2], 3, [[[4], 5]]]; // 数组展平function flatten(arr) &#123; return [].concat( ...arr.map(x =&gt; Array.isArray(x) ? flatten(x) : x) )&#125; 找出数组中重复出现过的元素123456789101112131415161718192021222324// 例如：[1，2，4，4，3，3，1，5，3]// 输出：[1，3，4]let arr = [1, 2, 4, 4, 3, 3, 1, 5, 3];// 方法一function repeat1(arr)&#123; var result = [], map = &#123;&#125;; arr.map(function(num)&#123; if(map[num] === 1) result.push(num); // 等于1说明之前出现过一次 这次重复出现了 map[num] = (map[num] || 0) + 1; // 微妙之处 开始第一次出现无值 记为 0 + 1 = 1 下一次从1开始累加 &#125;); return result;&#125;console.log(repeat1(arr));// 方法二function repeat(arr) &#123; let result = arr.filter((x, i, self) =&gt; &#123; return self.indexOf(x) === i &amp;&amp; self.lastIndexOf(x) !== i &#125;); // return result;&#125;console.log(repeat(arr)); 将数组中按照数字重复出现的次数进行排序123456789101112131415161718192021222324252627282930// 如果次数相同 则按照值排序 比如 2, 2, 2和 1, 1, 1 应排序为 [1, 1, 1, 2, 2, 2]// 比如 [1,2,1,2,1,3,4,5,4,5,5,2,2] =&gt; [3, 4, 4, 1, 1, 1, 5, 5, 5, 2, 2, 2, 2]let arr = [9, 7, 7, 1, 2, 1, 2, 1, 3, 4, 5, 4, 5, 5, 2, 2];function sortArray(arr) &#123; let obj = &#123;&#125;; let newArr = []; for(let i = 0; i &lt; arr.length; i++) &#123; let cur = arr[i]; if(obj[cur])&#123; obj[cur].push(cur); continue; &#125; obj[cur] = [cur]; &#125; for(let k in obj) &#123; if(obj.hasOwnProperty(k)) &#123; newArr.push(obj[k]) &#125; &#125; newArr.sort((a, b) =&gt; &#123; if(a.length === b.length)&#123; return a[0] - b[0]; &#125; return a.length - b.length; &#125;); newArr = newArr.reduce((prev, cur) =&gt; prev.concat(cur)); return newArr; &#125; console.log(sortArray(arr)); // [ 3, 9, 4, 4, 7, 7, 1, 1, 1, 5, 5, 5, 2, 2, 2, 2 ] 移动端关闭虚拟键盘1document.activeElement.blur(); 解决setInterval在浏览器切换中的问题1234567document.onvisibilitychange=function()&#123; if(document.visibilityState==&quot;visible&quot;)&#123; timer=setInterval(slidemove, 1000); &#125;else&#123; clearInterval(timer); &#125;&#125; Promise 透传123Promise.resolve(1).then(2).then((a)=&gt;console.log(a)) 1Promise &#123;&lt;resolved&gt;: undefined&#125; 不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标123456es6版：Array.from(Array(100).keys()) 或者[...Array(100).keys()]Array(100).fill(0).map((t,i)=&gt;i) 箭头函数1234567891011121314151617181920（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 异步加载的区别 defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行 async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关async和defer html 触底的条件是：12document.documentElement.scrollHeight ===document.documentElement.clientHeight + document.documentElement.scrollTop 雅虎十四条优化1234567891011121314151617181. 尽可能的减少 HTTP 的请求数 content2. 使用 CDN（Content Delivery Network） server3. 添加 Expires 头(或者 Cache-control ) server4. Gzip 组件 server5. 将 CSS 样式放在页面的上方 css6. 将脚本移动到底部（包括内联的） javascript7. 避免使用 CSS 中的 Expressions css8. 将 JavaScript 和 CSS 独立成外部文件 javascript css9. 减少 DNS 查询 content10. 压缩 JavaScript 和 CSS (包括内联的) javascript css11. 避免重定向 server12. 移除重复的脚本 javascript13. 配置实体标签（ETags） css14. 使 AJAX 缓存15. DNS预读取 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://data.dadaabc.com/&quot;&gt;16. 多域名分发静态资源 同域下浏览器能并发的请求有限，为了增加并发，尤其是一些静态资源上，可以使用多个域名。17. 最小化重排和重绘18. 函数防抖和函数节流 微任务有两种 nextTick和then 那么这两个谁快呢？12345678Promise.resolve(&apos;123&apos;).then(res=&gt;&#123; console.log(res); &#125;) process.nextTick(() =&gt; console.log(&apos;nextTick&apos;)) //顺序 nextTick 123 //很明显 nextTick快 setTimeout第三个参数123setTimeout(function(...list)&#123; console.log(list); // [1, 2, 3, 4, 5] &#125;,100,1,2,3,4,5) Object和Function之间最让人琢磨不透的123456789101112Object instanceof Object // trueObject instanceof Function // trueFunction instanceof Function // trueFunction instanceof Object // trueconst o = &#123;&#125;o instanceof Object //trueo instanceof Function // falsefunction F () &#123;&#125;F instanceof Object //trueF instanceof Function //true 文件上传进度提示使用Javascript的XMLHttpRequest的progress事件12345678910111213141516171819202122232425使用Javascript的XMLHttpRequest的progress事件，实现示例代码为：var formData = new FormData(); formData.append(&quot;file&quot;, document.getElementById(&apos;file&apos;).files[0]); formData.append(&quot;token&quot;, token_value); // 其他参数按这样子加入var xhr = new XMLHttpRequest();xhr.open(&apos;POST&apos;, &apos;/uploadurl&apos;);// 上传完成后的回调函数xhr.onload = function () &#123; if (xhr.status === 200) &#123; console.log(&apos;上传成功&apos;); &#125; else &#123; console.log(&apos;上传出错&apos;); &#125;&#125;;// 获取上传进度xhr.upload.onprogress = function (event) &#123; if (event.lengthComputable) &#123; var percent = Math.floor(event.loaded / event.total * 100) ; // 设置进度显示 $(&quot;#J_upload_progress&quot;).progress(&apos;set progress&apos;, percent); &#125;&#125;;xhr.send(formData); 面试题1234567891011121314151617&lt;script type=&quot;text/javascript&quot;&gt; function A(obj) &#123; obj.s = &quot;哈&quot; obj = &#123; //obj 重新赋值，并且是一个对象，此时obj指向a的指针指向这个赋值对象 &quot;name&quot;: 2, &quot;city&quot;: &quot;亚洲&quot; &#125; return obj &#125; var a = &#123; &quot;name&quot;: 1, &quot;city&quot;: &quot;中国&quot; &#125; var b = A(a); console.log(b); //&#123;name: 2, city: &quot;亚洲&quot;&#125; console.log(a); //&#123;name: 1, city: &quot;中国&quot;, s: &quot;哈&quot;&#125; &lt;/script&gt; LESS和SASS 语言 实现 特性 赋值 缩进 Sass Ruby 变量$开头 $var: value 不需要 Less JavaSript 变量@开头 @var: value 不需要 Stylus NodeJs 不能使用@开头 var:10 都可以 创造纯净的对象1234567你可以创造100%纯净的对象，它不会从Object类继承任何方法（例如：构造函数、toString() 等）。const pureObject =Object.create(null);console.log(pureObject);//=&gt; &#123;&#125;console.log(pureObject.constructor);//=&gt; undefinedconsole.log(pureObject.toString);//=&gt; undefinedconsole.log(pureObject.hasOwnProperty);//=&gt; undefined 将一个任意长的数字变成逗号分割的格式1234567891011121314例子：// 保留三位小数parseToMoney(1234.56); // return &apos;1,234.56&apos;parseToMoney(123456789); // return &apos;123,456,789&apos;parseToMoney(1087654.321); // return &apos;1,087,654.321&apos;答：functionparseToMoney(num) &#123; num = parseFloat(num.toFixed(3)); let [integer, decimal] = String.prototype.split.call(num, &apos;.&apos;); integer = integer.replace(/\d(?=(\d&#123;3&#125;)+$)/g, &apos;$&amp;,&apos;); return integer + &apos;.&apos; + (decimal ? decimal : &apos;&apos;);&#125; 检测对象中属性的存在 使用in关键字。 该方法可以判断对象的自有属性和继承来的属性是否存在。1234var o=&#123;x:1&#125;;&quot;x&quot; in o; //true，自有属性存在&quot;y&quot; in o; //false&quot;toString&quot; in o; //true，是一个继承属性 使用对象的hasOwnProperty()方法。 该方法只能判断自有属性是否存在，对于继承属性会返回false。1234var o=&#123;x:1&#125;;o.hasOwnProperty(&quot;x&quot;); //true，自有属性中有xo.hasOwnProperty(&quot;y&quot;); //false，自有属性中不存在yo.hasOwnProperty(&quot;toString&quot;); //false，这是一个继承属性，但不是自有属性 n!1234567functionfactorial(number)&#123; if(number==1) &#123; return number; &#125; else&#123; return number*factorial(number-1); &#125; &#125; 斐波那契数列:1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, … 求第n个数是多少123456functionfibonacci(number) &#123; if (number &lt;=2) &#123; return1; &#125; returnfibonacci(number-1) +fibonacci(number -2) &#125; JavaScript进阶提高必读继承JavaScript常用七种继承方案JS 面试原生常用api 方法大全JS代码手写题PM2来部署nodejs服务器永久开启 JavaScript设计模式URL 解析JavaScript专题数据结构]]></content>
  </entry>
  <entry>
    <title><![CDATA[js获取深层次属性,一道很经典的面试题]]></title>
    <url>%2F2018%2F10%2F23%2Fjs%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%B1%9E%E6%80%A7-%E4%B8%80%E9%81%93%E5%BE%88%E7%BB%8F%E5%85%B8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：123var data = &#123; a: &#123; b: &#123; c: &apos;ScriptOJ&apos; &#125; &#125; &#125;data.a.b.c // =&gt; scriptojdata.a.b.c.d // =&gt; 报错，代码停止执行console.log(&apos;ScriptOJ&apos;) // =&gt; 不会被执行 请你完成一个 safeGet 函数，可以安全的获取无限多层次的数据，一旦数据不存在不会报错，会返回 undefined，例如：1234var data = &#123; a: &#123; b: &#123; c: &apos;ScriptOJ&apos; &#125; &#125; &#125;safeGet(data, &apos;a.b.c&apos;) // =&gt; scriptojsafeGet(data, &apos;a.b.c.d&apos;) // =&gt; 返回 undefinedsafeGet(data, &apos;a.b.c.d.e.f.g&apos;) // =&gt; 返回 undefined 答案：1234567const safeGet = (o, path) =&gt; &#123; try &#123; return path.split(&apos;.&apos;).reduce((o, k) =&gt; o[k], o) &#125; catch (e) &#123; return void 666 &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Web 安全攻防总结]]></title>
    <url>%2F2018%2F10%2F23%2FWeb-%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Web 安全的对于 Web 从业人员来说是一个非常重要的课题，所以在这里总结一下 Web 相关的安全攻防知识，希望以后不要再踩雷，也希望对看到这篇文章的同学有所帮助。今天这边文章主要的内容就是分析几种常见的攻击的类型以及防御的方法。 也许你对所有的安全问题都有一定的认识，但最主要的还是在编码设计的过程中时刻绷紧安全那根弦，需要反复推敲每个实现细节，安全无小事。 本文代码 Demo 都是基于 Node.js 讲解，其他服务端语言同样可以参考。 XSS首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。 XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。 非持久型 XSS非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。举一个例子，比如你的 Web 页面中包含有以下代码： &lt;select&gt; &lt;script&gt; document.write(&apos;&apos; + &apos;&lt;optionvalue=1&gt;&apos; + location.href.substring(location.href.indexOf(&apos;default=&apos;) + 8) + &apos;&lt;/option&gt;&apos; ); document.write(&apos;&lt;optionvalue=2&gt;English&lt;/option&gt;&apos;); &lt;/script&gt; &lt;/select&gt; 攻击者可以直接通过 URL (类似： https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt; 注入可执行的脚本代码。 非持久型 XSS 漏洞攻击有以下几点特征： 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。 攻击者需要诱骗点击 反馈率低，所以较难发现和响应修复 盗取用户敏感保密信息 为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情： Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.creteElement() 等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 &lt;，&gt;，空格 等，转义成 &amp;lt;，&amp;gt;，&amp;nbsp; 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。 持久型 XSS持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。攻击成功需要同时满足以下几个条件： POST 请求提交表单后端没做转义直接入库。 后端从数据库中取出数据没做转义直接输出给前端。 前端拿到后端数据没做转义直接渲染成 DOM。 持久型 XSS 有以下几个特点： 持久性，植入在数据库中 危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。 盗取用户敏感私密信息 为了防止持久型 XSS 漏洞，需要前后端共同努力： 后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。 后端在输出给前端数据统一进行转义处理。 前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。 基于字符集的 XSS其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。 以基于 utf-7 的 XSS 为例 utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。 这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。 &lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt; 可以被解释为： +ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4- 可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。 所以我们有什么办法避免这种 XSS 呢？ 记住指定 &lt;meta charset=&quot;utf-8&quot;&gt; XML 中不仅要指定字符集为 utf-8，而且标签要闭合 牛文推荐：http://drops.wooyun.org/papers/1327 （这个讲的很详细） 基于 Flash 的跨站 XSS基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。 避免方法： 严格管理 cookie 的读写权限 对 Flash 能接受用户输入的参数进行过滤 escape 转义处理 未经验证的跳转 XSS有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。 这时候需要通过以下方式来防止这类漏洞： 对待跳转的 URL 参数做白名单或者某种规则过滤 后端注意对敏感信息的保护, 比如 cookie 使用来源验证。 CSRFCSRF（Cross-Site Request Forgery），中文名称：跨站请求伪造攻击 那么 CSRF 到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。攻击者只要借助少许的社会工程学的诡计，例如通过 QQ 等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使 Web 应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。 所以遇到 CSRF 攻击时，将对终端用户的数据和操作指令构成严重的威胁。当受攻击的终端用户具有管理员帐户的时候，CSRF 攻击将危及整个 Web 应用程序。 CSRF 原理下图大概描述了 CSRF 攻击的原理，可以理解为有一个小偷在你配钥匙的地方得到了你家的钥匙，然后拿着要是去你家想偷什么偷什么。完成 CSRF 攻击必须要有三个条件： 用户已经登录了站点 A，并在本地记录了 cookie 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。 站点 A 没有做任何 CSRF 防御 你也许会问：「如果我不满足以上三个条件中的任意一个，就不会受到 CSRF 的攻击」。其实可以这么说的，但你不能保证以下情况不会发生： 你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站，特别现在浏览器都是支持多 tab 的。 你不能保证你关闭浏览器了后，你本地的 cookie 立刻过期，你上次的会话已经结束。 上图中所谓的攻击网站 B，可能是一个存在其他漏洞的可信任的经常被人访问的网站。 预防 CSRFCSRF 的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的 CSRF 防御也都在服务端进行。服务端的预防 CSRF 攻击的方式方法有多种，但思路上都是差不多的，主要从以下两个方面入手： 正确使用 GET，POST 请求和 cookie 在非 GET 请求中增加 token 一般而言，普通的 Web 应用都是以 GET、POST 请求为主，还有一种请求是 cookie 方式。我们一般都是按照如下规则设计应用的请求： GET 请求常用在查看，列举，展示等不需要改变资源属性的时候（数据库 query 查询的时候） POST 请求常用在 From 表单提交，改变一个资源的属性或者做其他一些事情的时候（数据库有 insert、update、delete 的时候） 当正确的使用了 GET 和 POST 请求之后，剩下的就是在非 GET 方式的请求中增加随机数，这个大概有三种方式来进行： 为每个用户生成一个唯一的 cookie token，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的 cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。 每个 POST 请求使用验证码，这个方案算是比较完美的，但是需要用户多次输入验证码，用户体验比较差，所以不适合在业务中大量运用。 渲染表单的时候，为每一个表单包含一个 csrfToken，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。 CSRF 的防御可以根据应用场景的不同自行选择。CSRF 的防御工作确实会在正常业务逻辑的基础上带来很多额外的开发量，但是这种工作量是值得的，毕竟用户隐私以及财产安全是产品最基础的根本。 SQL 注入SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。 而造成 SQL 注入的原因是因为程序没有有效的转义过滤用户的输入，使攻击者成功的向服务器提交恶意的 SQL 查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。 很多 Web 开发者没有意识到 SQL 查询是可以被篡改的，从而把 SQL 查询当作可信任的命令。殊不知，SQL 查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过 SQL 查询去运行主机系统级的命令。 SQL 注入原理下面将通过一些真实的例子来详细讲解 SQL 注入的方式的原理。 考虑以下简单的管理员登录表单： &lt;formaction=&quot;/login&quot;method=&quot;POST&quot;&gt; &lt;p&gt;Username: &lt;inputtype=&quot;text&quot;name=&quot;username&quot; /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;inputtype=&quot;password&quot;name=&quot;password&quot; /&gt;&lt;/p&gt; &lt;p&gt;&lt;inputtype=&quot;submit&quot;value=&quot;登陆&quot; /&gt;&lt;/p&gt; &lt;/form&gt; 后端的 SQL 语句可能是如下这样的： let querySQL = ` SELECT * FROM user WHERE username=&apos;${username}&apos; AND psw=&apos;${password}&apos; `; // 接下来就是执行 sql 语句... 目的就是来验证用户名和密码是不是正确，按理说乍一看上面的 SQL 语句也没什么毛病，确实是能够达到我们的目的，可是你只是站在用户会老老实实按照你的设计来输入的角度来看问题，如果有一个恶意攻击者输入的用户名是 zoumiaojiang&#39; OR 1 = 1 --，密码随意输入，就可以直接登入系统了。WFT! 冷静下来思考一下，我们之前预想的真实 SQL 语句是: SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;AND psw=&apos;mypassword&apos; 可以恶意攻击者的奇怪用户名将你的 SQL 语句变成了如下形式： SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1--&apos; AND psw=&apos;xxxx&apos; 在 SQL 中，-- 是注释后面的内容的意思，所以查询语句就变成了： SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1 这条 SQL 语句的查询条件永远为真，所以意思就是恶意攻击者不用我的密码，就可以登录进我的账号，然后可以在里面为所欲为，然而这还只是最简单的注入，牛逼的 SQL 注入高手甚至可以通过 SQL 查询去运行主机系统级的命令，将你主机里的内容一览无余，这里我也没有这个能力讲解的太深入，毕竟不是专业研究这类攻击的，但是通过以上的例子，已经了解了 SQL 注入的原理，我们基本已经能找到防御 SQL 注入的方案了。 如何预防 SQL 注入防止 SQL 注入主要是不能允许用户输入的内容影响正常的 SQL 语句的逻辑，当用户的输入的信息将要用来拼接 SQL 语句的话，我们应该永远选择不相信，任何内容都必须进行转义过滤，当然做到这个还是不够的，下面列出防御 SQL 注入的几点注意事项： 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。 对进入数据库的特殊字符（&#39;，&quot;，\，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。 mysql.query(`SELECT * FROM user WHERE username = ? AND psw = ?`, [username, psw]); 在应用发布之前建议使用专业的 SQL 注入检测工具进行检测，以及时修补被发现的 SQL 注入漏洞。网上有很多这方面的开源工具，例如 sqlmap、SQLninja 等。 避免网站打印出 SQL 错误信息，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。 不要过于细化返回的错误信息，如果目的是方便调试，就去使用后端日志，不要在接口上过多的暴露出错信息，毕竟真正的用户不关心太多的技术细节，只要话术合理就行。 碰到要操作的数据库的代码，一定要慎重，小心使得万年船，多找几个人多来几次 code review，将问题都暴露出来，而且要善于利用工具，操作数据库相关的代码属于机密，没事不要去各种论坛晒自家站点的 SQL 语句，万一被人盯上了呢？ 命令行注入命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令，听起来好像匪夷所思，这往往是 Web 开发者最容易忽视但是却是最危险的一个漏洞之一，看一个实例： 假如现在需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去产出一个结果返回给用户，接口的部分实现如下： // 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repo const exec = require(&apos;mz/child_process&apos;).exec; let params = {/* 用户输入的参数 */}; exec(`git clone ${params.repo} /some/path`); 这段代码确实能够满足业务需求，正常的用户也确实能从指定的 git repo 上下载到想要的代码，可是和 SQL 注入一样，这段代码在恶意攻击者眼中，简直就是香饽饽。 如果 params.repo 传入的是 https://github.com/zoumiaojiang/zoumiaojiang.github.io.git 当然没问题了。 可是如果 params.repo 传入的是 https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp; 恰好你的服务是用 root 权限起的就惨了。 具体恶意攻击者能用命令行注入干什么也像 SQL 注入一样，手法是千变万化的，比如「反弹 shell 注入」等，但原理都是一样的，我们绝对有能力防止命令行注入发生。防止命令行注入需要做到以下几件事情： 后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。 在调用系统命令前对所有传入参数进行命令行参数转义过滤。 不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 shell-escape npm 包。 还是前面的例子，我们可以做到如下： const exec = require(&apos;mz/child_process&apos;).exec; // 借助 shell-escape npm 包解决参数转义过滤问题 const shellescape = require(&apos;shell-escape&apos;); let params = {/* 用户输入的参数 */}; // 先过滤一下参数，让参数符合预期 if (!/正确的表达式/.test(params.repo)) { return; } let cmd = shellescape([ &apos;git&apos;, &apos;clone&apos;, params.repo, &apos;/some/path&apos; ]); // cmd 的值: git clone &apos;https://github.com/xx/xx.git &amp;&amp; rm -rf / &amp;&amp;&apos; /some/path // 这样就不会被注入成功了。 exec(cmd); 无论是在何种后端语言环境中，凡是涉及到代码调用系统 shell 命令的时候都一定要谨慎。 DDoS 攻击DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用，这个攻击应该不能算是安全问题，这应该算是一个另类的存在，因为这种攻击根本就是耍流氓的存在，「伤敌一千，自损八百」的行为。出于保护 Web App 不受攻击的攻防角度，还是介绍一下 DDoS 攻击吧，毕竟也是挺常见的。 DDoS 攻击可以理解为：「你开了一家店，隔壁家点看不惯，就雇了一大堆黑社会人员进你店里干坐着，也不消费，其他客人也进不来，导致你营业惨淡」。为啥说 DDoS 是个「伤敌一千，自损八百」的行为呢？毕竟隔壁店还是花了不少钱雇黑社会但是啥也没得到不是？DDoS 攻击的目的基本上就以下几个： 深仇大恨，就是要干死你 敲诈你，不给钱就干你 忽悠你，不买我防火墙服务就会有“人”继续干你 也许你的站点遭受过 DDoS 攻击，具体什么原因怎么解读见仁见智。DDos 攻击从层次上可分为网络层攻击与应用层攻击，从攻击手法上可分为快型流量攻击与慢型流量攻击，但其原理都是造成资源过载，导致服务不可用。 网络层 DDoS网络层 DDos 攻击包括 SYN Flood、ACK Flood、UDP Flood、ICMP Flood 等。 SYN Flood 攻击 SYN flood 攻击主要利用了 TCP 三次握手过程中的 Bug，我们都知道 TCP 三次握手过程是要建立连接的双方发送 SYN，SYN + ACK，ACK 数据包，而当攻击方随意构造源 IP 去发送 SYN 包时，服务器返回的 SYN + ACK 就不能得到应答（因为 IP 是随意构造的），此时服务器就会尝试重新发送，并且会有至少 30s 的等待时间，导致资源饱和服务不可用，此攻击属于慢型 DDoS 攻击。 ACK Flood 攻击 ACK Flood 攻击是在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。 UDP Flood 攻击 UDP flood 攻击是由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。 ICMP Flood 攻击 ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。 网络层 DDoS 防御网络层的 DDoS 攻击究其本质其实是无法防御的，我们能做得就是不断优化服务本身部署的网络架构，以及提升网络带宽。当然，还是做好以下几件事也是有助于缓解网络层 DDoS 攻击的冲击： 网络架构上做好优化，采用负载均衡分流。 确保服务器的系统文件是最新的版本，并及时更新系统补丁。 添加抗 DDos 设备，进行流量清洗。 限制同时打开的 SYN 半连接数目，缩短 SYN 半连接的 Timeout 时间。 限制单 IP 请求频率。 防火墙等防护设置禁止 ICMP 包等。 严格限制对外开放的服务器的向外访问。 运行端口映射程序或端口扫描程序，要认真检查特权端口和非特权端口。 关闭不必要的服务。 认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更,那这台机器就可能遭到了攻击。 限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。 加钱堆机器。。 报警。。 应用层 DDoS应用层 DDoS 攻击不是发生在网络层，是发生在 TCP 建立握手成功之后，应用程序处理请求的时候，现在很多常见的 DDoS 攻击都是应用层攻击。应用层攻击千变万化，目的就是在网络应用层耗尽你的带宽，下面列出集中典型的攻击类型。 CC 攻击 当时绿盟为了防御 DDoS 攻击研发了一款叫做 Collapasar 的产品，能够有效的防御 SYN Flood 攻击。黑客为了挑衅，研发了一款 Challenge Collapasar 攻击工具（简称 CC）。 CC 攻击的原理，就是针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。因此在发送 CC 攻击前，我们需要寻找加载比较慢，消耗资源比较多的网页，比如需要查询数据库的页面、读写硬盘文件的等。通过 CC 攻击，使用爬虫对某些加载需要消耗大量资源的页面发起 HTTP 请求。 DNS Flood DNS Flood 攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名，被攻击的DNS 服务器在接收到域名解析请求的时候首先会在服务器上查找是否有对应的缓存，如果查找不到并且该域名无法直接由服务器解析的时候，DNS 服务器会向其上层 DNS 服务器递归查询域名信息。域名解析的过程给服务器带来了很大的负载，每秒钟域名解析请求超过一定的数量就会造成 DNS 服务器解析域名超时。 根据微软的统计数据，一台 DNS 服务器所能承受的动态域名查询的上限是每秒钟 9000 个请求。而我们知道，在一台 P3 的 PC 机上可以轻易地构造出每秒钟几万个域名解析请求，足以使一台硬件配置极高的 DNS 服务器瘫痪，由此可见 DNS 服务器的脆弱性。 HTTP 慢速连接攻击 针对 HTTP 协议，先建立起 HTTP 连接，设置一个较大的 Conetnt-Length，每次只发送很少的字节，让服务器一直以为 HTTP 头部没有传输完成，这样连接一多就很快会出现连接耗尽。 应用层 DDoS 防御 判断 User-Agent 字段（不可靠，因为可以随意构造） 针对 IP + cookie，限制访问频率（由于 cookie 可以更改，IP 可以使用代理，或者肉鸡，也不可靠) 关闭服务器最大连接数等，合理配置中间件，缓解 DDoS 攻击。 请求中添加验证码，比如请求中有数据库操作的时候。 编写代码时，尽量实现优化，并合理使用缓存技术，减少数据库的读取操作。 加钱堆机器。。 报警。。 应用层的防御有时比网络层的更难，因为导致应用层被 DDoS 攻击的因素非常多，有时往往是因为程序员的失误，导致某个页面加载需要消耗大量资源，有时是因为中间件配置不当等等。而应用层 DDoS 防御的核心就是区分人与机器（爬虫），因为大量的请求不可能是人为的，肯定是机器构造的。因此如果能有效的区分人与爬虫行为，则可以很好地防御此攻击。 其他 DDoS 攻击发起 DDoS 也是需要大量的带宽资源的，但是互联网就像森林，林子大了什么鸟都有，DDoS 攻击者也能找到其他的方式发起廉价并且极具杀伤力的 DDoS 攻击。 利用 XSS 举个例子，如果 12306 页面有一个 XSS 持久型漏洞被恶意攻击者发现，只需在春节抢票期间在这个漏洞中执行脚本使得往某一个小站点随便发点什么请求，然后随着用户访问的增多，感染用户增多，被攻击的站点自然就会迅速瘫痪了。这种 DDoS 简直就是无本万利，不用惊讶，现在大站有 XSS 漏洞的不要太多。 来自 P2P 网络攻击 大家都知道，互联网上的 P2P 用户和流量都是一个极为庞大的数字。如果他们都去一个指定的地方下载数据，成千上万的真实 IP 地址连接过来，没有哪个设备能够支撑住。拿 BT 下载来说，伪造一些热门视频的种子，发布到搜索引擎，就足以骗到许多用户和流量了，但是这只是基础攻击。 高级的 P2P 攻击，是直接欺骗资源管理服务器。如迅雷客户端会把自己发现的资源上传到资源管理服务器，然后推送给其它需要下载相同资源的用户，这样，一个链接就发布出去。通过协议逆向，攻击者伪造出大批量的热门资源信息通过资源管理中心分发出去，瞬间就可以传遍整个 P2P 网络。更为恐怖的是，这种攻击是无法停止的，即使是攻击者自身也无法停止，攻击一直持续到 P2P 官方发现问题更新服务器且下载用户重启下载软件为止。 最后总结下，DDoS 不可能防的住，就好比你的店只能容纳 50 人，黑社会有 100 人，你就换一家大店，能容纳 500 人，然后黑社会又找来了 1000 人，这种堆人头的做法就是 DDoS 本质上的攻防之道，「道高一尺，魔高一丈，魔高一尺，道高一丈」，讲真，必要的时候就答应勒索你的人的条件吧，实在不行就报警吧。 流量劫持流量劫持应该算是黑产行业的一大经济支柱了吧？简直是让人恶心到吐，不吐槽了，还是继续谈干货吧，流量劫持基本分两种：DNS 劫持 和 HTTP 劫持，目的都是一样的，就是当用户访问 zoumiaojiang.com 的时候，给你展示的并不是或者不完全是 zoumiaojiang.com 提供的 “内容”。 DNS 劫持DNS 劫持，也叫做域名劫持，可以这么理解，「你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了」，DNS 的作用是把网络地址域名对应到真实的计算机能够识别的 IP 地址，以便计算机能够进一步通信，传递网址和内容等。如果当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。这类劫持，要不就是网络运营商搞的鬼，一般小的网络运营商与黑产勾结会劫持 DNS，要不就是电脑中毒，被恶意篡改了路由器的 DNS 配置，基本上做为开发者或站长却是很难察觉的，除非有用户反馈，现在升级版的 DNS 劫持还可以对特定用户、特定区域等使用了用户画像进行筛选用户劫持的办法，另外这类广告显示更加随机更小，一般站长除非用户投诉否则很难觉察到，就算觉察到了取证举报更难。无论如何，如果接到有 DNS 劫持的反馈，一定要做好以下几件事： 取证很重要，时间、地点、IP、拨号账户、截屏、URL 地址等一定要有。 可以跟劫持区域的电信运营商进行投诉反馈。 如果投诉反馈无效，直接去工信部投诉，一般来说会加白你的域名。 HTTP 劫持HTTP 劫持您可以这么理解，「你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告」，HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面，轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私。能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。 HTTPS 协议就是一种基于 SSL 协议的安全加密网络应用层协议，可以很好的防止 HTTP 劫持。这里有篇 文章 讲的不错。HTTPS 在这就不深讲了，后面有机会我会单独好好讲讲 HTTPS。如果不想站点被 HTTP 劫持，赶紧将你的站点全站改造成 HTTPS 吧。 服务器漏洞服务器除了以上提到的那些大名鼎鼎的漏洞和臭名昭著的攻击以外，其实还有很多其他的漏洞，往往也很容易被忽视，在这个小节也稍微介绍几种。 越权操作漏洞如果你的系统是有登录控制的，那就要格外小心了，因为很有可能你的系统越权操作漏洞，越权操作漏洞可以简单的总结为 「A 用户能看到或者操作 B 用户的隐私内容」，如果你的系统中还有权限控制就更加需要小心了。所以每一个请求都需要做 userid 的判断 以下是一段有漏洞的后端示意代码： // ctx 为请求的 context 上下文 let msgId = ctx.params.msgId; mysql.query( &apos;SELECT * FROM msg_table WHERE msg_id = ?&apos;, [msgId] ); 以上代码是任何人都可以查询到任何用户的消息，只要有 msg_id 就可以，这就是比较典型的越权漏洞，需要如下这么改进一下： // ctx 为请求的 context 上下文 let msgId = ctx.params.msgId; let userId = ctx.session.userId; // 从会话中取出当前登陆的 userId mysql.query( &apos;SELECT * FROM msg_table WHERE msg_id = ? AND user_id = ?&apos;, [msgId, userId] ); 嗯，大概就是这个意思，如果有更严格的权限控制，那在每个请求中凡是涉及到数据库的操作都需要先进行严格的验证，并且在设计数据库表的时候需要考虑进 userId 的账号关联以及权限关联。 目录遍历漏洞目录遍历漏洞指通过在 URL 或参数中构造 ../，./ 和类似的跨父目录字符串的 ASCII 编码、unicode 编码等，完成目录跳转，读取操作系统各个目录下的敏感文件，也可以称作「任意文件读取漏洞」。 目录遍历漏洞原理：程序没有充分过滤用户输入的 ../ 之类的目录跳转符，导致用户可以通过提交目录跳转来遍历服务器上的任意文件。使用多个.. 符号，不断向上跳转，最终停留在根 /，通过绝对路径去读取任意文件。 目录遍历漏洞几个示例和测试，一般构造 URL 然后使用浏览器直接访问，或者使用 Web 漏洞扫描工具检测，当然也可以自写程序测试。 http://somehost.com/../../../../../../../../../etc/passwd http://somehost.com/some/path?file=../../Windows/system.ini # 借助 %00 空字符截断是一个比较经典的攻击手法 http://somehost.com/some/path?file=../../Windows/system.ini%00.js # 使用了 IIS 的脚本目录来移动目录并执行指令 http://somehost.com/scripts/..%5c../Windows/System32/cmd.exe?/c+dir+c:\ 防御 方法就是需要对 URL 或者参数进行 ../，./ 等字符的转义过滤。 物理路径泄漏物理路径泄露属于低风险等级缺陷，它的危害一般被描述为「攻击者可以利用此漏洞得到信息，来对系统进一步地攻击」，通常都是系统报错 500 的错误信息直接返回到页面可见导致的漏洞。得到物理路径有些时候它能给攻击者带来一些有用的信息，比如说：可以大致了解系统的文件目录结构；可以看出系统所使用的第三方软件；也说不定会得到一个合法的用户名（因为很多人把自己的用户名作为网站的目录名）。 防止这种泄漏的方法就是做好后端程序的出错处理，定制特殊的 500 报错页面。 源码暴露漏洞和物理路径泄露类似，就是攻击者可以通过请求直接获取到你站点的后端源代码，然后就可以对系统进一步研究攻击。那么导致源代码暴露的原因是什么呢？基本上就是发生在服务器配置上了，服务器可以设置哪些路径的文件才可以被直接访问的，这里给一个 koa 服务起的例子，正常的 koa 服务器可以通过 koa-static 中间件去指定静态资源的目录，好让静态资源可以通过路径的路由访问。比如你的系统源代码目录是这样的： |- project |- src |- static |- ... |- server.js 你想要将 static 的文件夹配成静态资源目录，你应该会在 server.js 做如下配置： const Koa = require(&apos;koa&apos;); const serve = require(&apos;koa-static&apos;); const app = new Koa(); app.use(serve(__dirname + &apos;/project/static&apos;)); 但是如果配错了静态资源的目录，可能就出大事了，比如： // ... app.use(serve(__dirname + &apos;/project&apos;)); 这样所有的源代码都可以通过路由访问到了，所有的服务器都提供了静态资源机制，所以在通过服务器配置静态资源目录和路径的时候，一定要注意检验，不然很可能产生漏洞。 最后，希望 Web 开发者们能够管理好自己的代码隐私，注意代码安全问题，比如不要将产品的含有敏感信息的代码放到第三方外部站点或者暴露给外部用户，尤其是前端代码，私钥类似的保密性的东西不要直接输出在代码里或者页面中。也许还有很多值得注意的点，但是归根结底还是绷住安全那根弦，对待每一行代码都要多多推敲。]]></content>
      <tags>
        <tag>xss</tag>
        <tag>CSRF</tag>
        <tag>SQL注入</tag>
        <tag>DDoS 攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 父子组件通信的十种方式]]></title>
    <url>%2F2018%2F10%2F22%2FVue-js-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8D%81%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[面试官：Vue 中父子组件通信有哪些方式？ vue组件通信全揭秘(共7章) 几种通信方式无外乎以下几种： Prop（常用） $emit (组件封装用的较多) .sync语法糖 （较少） $attrs 和 $listeners (组件封装用的较多) provide 和 inject （高阶组件/组件库用的较多） 其他方式通信 Prop英式发音：[prɒp]。这个在我们日常开发当中用到的非常多。简单来说，我们可以通过 Prop 向子组件传递数据。用一个形象的比喻来说，父子组件之间的数据传递相当于自上而下的下水管子，只能从上往下流，不能逆流。这也正是 Vue 的设计理念之单向数据流。而 Prop 正是管道与管道之间的一个衔接口，这样水（数据）才能往下流。说这么多，看代码：1234567891011121314151617181920212223&lt;divid=&quot;app&quot;&gt; &lt;child:content=&quot;message&quot;&gt;&lt;/child&gt;&lt;/div&gt;let Child = Vue.extend(&#123; template: &apos;&lt;h2&gt;&#123;&#123; content &#125;&#125;&lt;/h2&gt;&apos;, props: &#123; content: &#123; type: String, default: () =&gt; &#123; return&apos;from child&apos; &#125; &#125; &#125;&#125;)new Vue(&#123; el: &apos;#app&apos;, data: &#123; message: &apos;from parent&apos; &#125;, components: &#123; Child &#125;&#125;) 1from parent $emit英式发音：[iˈmɪt]。官方说法是触发当前实例上的事件。附加参数都会传给监听器回调。按照我的理解不知道能不能给大家说明白，先简单看下代码吧： &lt;divid=&quot;app&quot;&gt; &lt;my-button @greet=&quot;sayHi&quot;&gt;&lt;/my-button&gt; &lt;/div&gt; let MyButton = Vue.extend({ template: &apos;&lt;button @click=&quot;triggerClick&quot;&gt;click&lt;/button&gt;&apos;, data () { return { greeting: &apos;vue.js!&apos; } }, methods: { triggerClick () { this.$emit(&apos;greet&apos;, this.greeting) } } }) new Vue({ el: &apos;#app&apos;, components: { MyButton }, methods: { sayHi (val) { alert(&apos;Hi, &apos; + val) // &apos;Hi, vue.js!&apos; } } }) 大致逻辑是酱婶儿的：当我在页面上点击按钮时，触发了组件 MyButton 上的监听事件 greet，并且把参数传给了回调函数 sayHi 。说白了，当我们从子组件 Emit（派发） 一个事件之前，其内部都提前在事件队列中 On（监听）了这个事件及其监听回调。其实相当于下面这种写法： vm.$on(&apos;greet&apos;, functionsayHi (val) { console.log(&apos;Hi, &apos; + val) }) vm.$emit(&apos;greet&apos;, &apos;vue.js&apos;) // =&gt; &quot;Hi, vue.js&quot; .sync 修饰符这个家伙在 vue@1.x 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值。因为它违反了单向数据流的设计理念，所以在 vue@2.0 的时候被干掉了。但是在 vue@2.3.0+ 以上版本又重新引入了这个 .sync 修饰符。但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。说白了就是让我们手动进行更新父组件中的值了，从而使数据改动来源更加的明显。下面引入自官方的一段话： 在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。 既然作为一个语法糖，肯定是某种写法的简写形式，哪种写法呢，看代码：1234&lt;text-document v-bind:title=&quot;doc.title&quot; v-on:update:title=&quot;doc.title = $event&quot;&gt;&lt;/text-document&gt; 于是我们可以用 .sync 语法糖简写成如下形式： &lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt; 废话这么多，如何做到“双向绑定” 呢？让我们进段广告，广告之后更加精彩！…好的，欢迎回来。假如我们想实现这样一个效果：改变子组件文本框中的值同时改变父组件中的值。怎么做？列位不妨先想想。先看段代码： &lt;divid=&quot;app&quot;&gt; &lt;login:name.sync=&quot;userName&quot;&gt;&lt;/login&gt; {{ userName }} &lt;/div&gt; let Login = Vue.extend({ template: ` &lt;div class=&quot;input-group&quot;&gt; &lt;label&gt;姓名:&lt;/label&gt; &lt;input v-model=&quot;text&quot;&gt; &lt;/div&gt; `, props: [&apos;name&apos;], data () { return { text: &apos;&apos; } }, watch: { text (newVal) { this.$emit(&apos;update:name&apos;, newVal) } } }) new Vue({ el: &apos;#app&apos;, data: { userName: &apos;&apos; }, components: { Login } }) 下面划重点，代码里有这一句话： this.$emit(&apos;update:name&apos;, newVal) 官方语法是：update:myPropName 其中 myPropName 表示要更新的 prop 值。当然如果你不用 .sync 语法糖使用上面的 .$emit 也能达到同样的效果。仅此而已！ $attrs 和 $listeners 官网对 $attrs 的解释如下： 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。 官网对 $listeners 的解释如下： 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=&quot;$listeners&quot; 传入内部组件——在创建更高层次的组件时非常有用。 我觉得 $attrs 和 $listeners 属性像两个收纳箱，一个负责收纳属性，一个负责收纳事件，都是以对象的形式来保存数据。看下面的代码解释： &lt;divid=&quot;app&quot;&gt; &lt;child:foo=&quot;foo&quot;:bar=&quot;bar&quot; @one.native=&quot;triggerOne&quot; @two=&quot;triggerTwo&quot;&gt; &lt;/child&gt; &lt;/div&gt; 从 Html 中可以看到，这里有俩属性和俩方法，区别是属性一个是 prop 声明，事件一个是 .native 修饰器。 let Child = Vue.extend({ template: &apos;&lt;h2&gt;{{ foo }}&lt;/h2&gt;&apos;, props: [&apos;foo&apos;], created () { console.log(this.$attrs, this.$listeners) // -&gt; {bar: &quot;parent bar&quot;} // -&gt; {two: fn} // 这里我们访问父组件中的 `triggerTwo` 方法 this.$listeners.two() // -&gt; &apos;two&apos; } }) new Vue({ el: &apos;#app&apos;, data: { foo: &apos;parent foo&apos;, bar: &apos;parent bar&apos; }, components: { Child }, methods: { triggerOne () { alert(&apos;one&apos;) }, triggerTwo () { alert(&apos;two&apos;) } } }) 可以看到，我们可以通过 $attrs 和 $listeners 进行数据传递，在需要的地方进行调用和处理，还是很方便的。当然，我们还可以通过 v-on=&quot;$listeners&quot; 一级级的往下传递，子子孙孙无穷尽也！ 一个插曲！ 当我们在组件上赋予了一个非Prop 声明时，编译之后的代码会把这些个属性都当成原始属性对待，添加到 html 原生标签上，看上面的代码编译之后的样子： &lt;h2 bar=&quot;parent bar&quot;&gt;parent foo&lt;/h2&gt; 这样会很难看，同时也爆了某些东西。如何去掉？这正是 inheritAttrs 属性的用武之地！给组件加上这个属性就行了，一般是配合 $attrs 使用。看代码： // 源码 let Child = Vue.extend({ ... inheritAttrs: false, // 默认是 true ... }) 再次编译： &lt;h2&gt;parent foo&lt;/h2&gt; provide / inject他俩是对CP, 感觉挺神秘的。来看下官方对 provide / inject 的描述： provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。并且这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 看完描述有点懵懵懂懂！一句话总结就是：小时候你老爸什么东西都先帮你存着等你长大该娶媳妇儿了你要房子给你买要车给你买只要他有的尽量都会满足你。下面是这句话的代码解释： &lt;divid=&quot;app&quot;&gt; &lt;son&gt;&lt;/son&gt; &lt;/div&gt; let Son = Vue.extend({ template: &apos;&lt;h2&gt;son&lt;/h2&gt;&apos;, inject: { house: { default: &apos;没房&apos; }, car: { default: &apos;没车&apos; }, money: { // 长大工作了虽然有点钱// 仅供生活费，需要向父母要default: &apos;￥4500&apos; } }, created () { console.log(this.house, this.car, this.money) // -&gt; &apos;房子&apos;, &apos;车子&apos;, &apos;￥10000&apos; } }) new Vue({ el: &apos;#app&apos;, provide: { house: &apos;房子&apos;, car: &apos;车子&apos;, money: &apos;￥10000&apos; }, components: { Son } }) 其他方式通信除了以上五种方式外，其实还有： EventBus 思路就是声明一个全局Vue实例变量 EventBus , 把所有的通信数据，事件监听都存储到这个变量上。这样就达到在组件间数据共享了，有点类似于 Vuex。但这种方式只适用于极小的项目，复杂项目还是推荐 Vuex。下面是实现 EventBus 的简单代码： &lt;divid=&quot;app&quot;&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; // 全局变量 let EventBus = new Vue() // 子组件 let Child = Vue.extend({ template: &apos;&lt;h2&gt;child&lt;/h2&gt;&apos;, created () { console.log(EventBus.message) // -&gt; &apos;hello&apos; EventBus.$emit(&apos;received&apos;, &apos;from child&apos;) } }) new Vue({ el: &apos;#app&apos;, components: { Child }, created () { // 变量保存 EventBus.message = &apos;hello&apos;// 事件监听 EventBus.$on(&apos;received&apos;, function (val) { console.log(&apos;received: &apos;+ val) // -&gt; &apos;received: from child&apos; }) } }) Vuex 官方推荐的，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 $parent 父实例，如果当前实例有的话。通过访问父实例也能进行数据之间的交互，但极小情况下会直接修改父组件中的数据。 $root 当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。通过访问根组件也能进行数据之间的交互，但极小情况下会直接修改父组件中的数据。 broadcast / dispatch 他俩是 vue@1.0 中的方法，分别是事件广播 和 事件派发。虽然 vue@2.0 里面删掉了，但可以模拟这两个方法。可以借鉴 Element 实现。有时候还是非常有用的，比如我们在开发树形组件的时候等等。]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试之Vue.$nextTick原理]]></title>
    <url>%2F2018%2F10%2F21%2F%E9%9D%A2%E8%AF%95%E4%B9%8BVue-nextTick%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[面试官:Vue的nextTick是怎么监听DOM树更新完毕的？nextTick是全局vue的一个函数，在vue系统中，用于处理dom更新的操作。vue里面有一个watcher，用于观察数据的变化，然后更新dom，vue里面并不是每次数据改变都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom更新操作。 通常情况下，我们不需要关心这个问题，而如果想在DOM状态更新后做点什么，则需要用到nextTick。在vue生命周期的created()钩子函数进行的DOM操作要放在Vue.nextTick()的回调函数中，因为created()钩子函数执行的时候DOM并未进行任何渲染，而此时进行DOM操作是徒劳的，所以此处一定要将DOM操作的JS代码放进Vue.nextTick()的回调函数中。而与之对应的mounted钩子函数，该钩子函数执行时所有的DOM挂载和渲染都已完成，此时该钩子函数进行任何DOM操作都不会有个问题。 Vue.nextTick(callback)，当数据发生变化，更新后执行回调。 Vue.$nextTick(callback)，当dom发生变化，更新后执行的回调。 废话少说，来看一个例子1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;span id=&apos;name&apos; ref=&apos;name&apos;&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt; &lt;button @click=&apos;change&apos;&gt;change name&lt;/button&gt; &lt;div id=&apos;content&apos;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &apos;#app&apos;, data() &#123; return &#123; name: &apos;SHERlocked93&apos; &#125; &#125;, methods: &#123; change() &#123; const $name = this.$refs.name this.$nextTick(() =&gt; console.log(&apos;setter前：&apos; + $name.innerHTML)) this.name = &apos; name改喽 &apos; console.log(&apos;同步方式：&apos; + this.$refs.name.innerHTML) setTimeout(() =&gt; this.console(&quot;setTimeout方式：&quot; + this.$refs.name.innerHTML)) this.$nextTick(() =&gt; console.log(&apos;setter后：&apos; + $name.innerHTML)) this.$nextTick().then(() =&gt; console.log(&apos;Promise方式：&apos; + $name.innerHTML)) &#125; &#125; &#125;)&lt;/script&gt; 执行以下看看结果：123456同步方式：SHERlocked93 setter前：SHERlocked93 setter后：name改喽 Promise方式：name改喽 setTimeout方式：name改喽 再看一段代码: 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;div ref=&quot;text&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;text&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; text: &apos;start&apos; &#125;; &#125;, methods () &#123; handleClick () &#123; this.text = &apos;end&apos;; console.log(this.$refs.text.innerText);//打印“start” &#125; &#125;&#125; 打印的结果是start，为什么明明已经将text设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“start”呢？ 源码解读带着这个疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。 watcher123456789101112131415/* 调度者接口，当依赖发生改变的时候进行回调。 */ update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; /*同步则执行run直接渲染视图*/ this.run() &#125; else &#123; /*异步推送到观察者队列中，由调度者调用。*/ queueWatcher(this) &#125; &#125; 我们发现Vue.js默认是使用异步执行DOM更新。当异步执行update的时候，会调用queueWatcher函数。 12345678910111213141516171819202122232425262728293031323334353637/** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it&apos;s * pushed when the queue is being flushed. **/ /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/export function queueWatcher (watcher: Watcher) &#123; /*获取watcher的id*/ const id = watcher.id /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/ if (has[id] == null) &#123; has[id] = true if (!flushing) &#123; /*如果没有flush掉，直接push到队列中即可*/ queue.push(watcher) &#125; else &#123; // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // queue the flush // 刷新队列 if (!waiting) &#123; waiting = true if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !config.async) &#123; flushSchedulerQueue() return &#125; nextTick(flushSchedulerQueue) &#125; &#125;&#125; 查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。 flushSchedulerQueue1vue/src/core/observer/scheduler.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/** * Flush both queues and run the watchers. */ /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/function flushSchedulerQueue () &#123; flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component&apos;s user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component&apos;s watcher run, // its watchers can be skipped. /* 刷新前给queue排序，这样做可以保证： 1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。 2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建 3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。 */ queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存， 因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/ for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id /*将has的标记删除*/ has[id] = null /*执行watcher*/ watcher.run() // in dev build, check and stop circular updates. /* 在测试环境中，检测watch是否在死循环中 比如这样一种情况 watch: &#123; test () &#123; this.test++; &#125; &#125; 持续执行了一百次watch代表可能存在死循环 */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( &apos;You may have an infinite update loop &apos; + ( watcher.user ? `in watcher with expression &quot;$&#123;watcher.expression&#125;&quot;` : `in a component render function.` ), watcher.vm ) break &#125; &#125; &#125; // keep copies of post queues before resetting state /*得到队列的拷贝*/ const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() /*重置调度者的状态*/ resetSchedulerState() // call component updated and activated hooks /*使子组件状态都改编成active同时调用activated钩子*/ callActivatedHooks(activatedQueue) /*调用updated钩子*/ callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) &#123; devtools.emit(&apos;flush&apos;) &#125;&#125; flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图 nextTickvue.js提供了一个nextTick函数，其实也就是上面调用的nextTick。 nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion。 网上很多文章讨论的nextTick实现是2.4版本以下的实现，2.5以上版本对于nextTick的内部实现进行了大量的修改，看一下源码： 首先是从Vue 2.5+开始，抽出来了一个单独的文件next-tick.js来执行它。1vue/src/core/util/next-tick.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163 /* 延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function 这个函数的作用是在task或者microtask中推入一个timerFunc， 在当前调用栈执行完以后以此执行直到执行到timerFunc 目的是延迟到当前调用栈执行完以后执行*//*存放异步执行的回调*/const callbacks = []/*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/let pending = false/*下一个tick时的回调*/function flushCallbacks () &#123;/*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/ pending = false //复制callback const copies = callbacks.slice(0) //清除callbacks callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; //触发callback的回调函数 copies[i]() &#125;&#125;// Here we have async deferring wrappers using both microtasks and (macro) tasks.// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where// microtasks have too high a priority and fire in between supposedly// sequential events (e.g. #4521, #6690) or even between bubbling of the same// event (#6566). However, using (macro) tasks everywhere also has subtle problems// when state is changed right before repaint (e.g. #6813, out-in transitions).// Here we use microtask by default, but expose a way to force (macro) task when// needed (e.g. in event handlers attached by v-on)./**其大概的意思就是：在Vue2.4之前的版本中，nextTick几乎都是基于microTask实现的，但是由于microTask的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，就会导致一些诡异的问题；但是如果全部都改成macroTask，对一些有重绘和动画的场景也会有性能的影响。所以最终nextTick采取的策略是默认走microTask，对于一些DOM的交互事件，如v-on绑定的事件回调处理函数的处理，会强制走macroTask。**/let microTimerFunclet macroTimerFunclet useMacroTask = false// Determine (macro) task defer implementation.// Technically setImmediate should be the ideal choice, but it&apos;s only available// in IE. The only polyfill that consistently queues the callback after all DOM// events triggered in the same loop is by using MessageChannel./* istanbul ignore if *//**而对于macroTask的执行，Vue优先检测是否支持原生setImmediate（高版本IE和Edge支持），不支持的话再去检测是否支持原生MessageChannel，如果还不支持的话为setTimeout(fn, 0)。**/if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else if (typeof MessageChannel !== &apos;undefined&apos; &amp;&amp; ( // MessageChannel与原先的MutationObserver异曲同工/**在Vue 2.4版本以前使用的MutationObserver来模拟异步任务。而Vue 2.5版本以后，由于兼容性弃用了MutationObserver。Vue 2.5+版本使用了MessageChannel来模拟macroTask。除了IE以外，messageChannel的兼容性还是比较可观的。**/ isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === &apos;[object MessageChannelConstructor]&apos;)) &#123; /** 可见，新建一个MessageChannel对象，该对象通过port1来检测信息，port2发送信息。 通过port2的主动postMessage来触发port1的onmessage事件， 进而把回调函数flushCallbacks作为macroTask参与事件循环。 **/ const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; &#123; port.postMessage(1) &#125;&#125; else &#123; /* istanbul ignore next */ //上面两种都不支持，用setTimeout macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125;// Determine microtask defer implementation./* istanbul ignore next, $flow-disable-line */if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123;/*使用Promise*/ const p = Promise.resolve() microTimerFunc = () =&gt; &#123; p.then(flushCallbacks) // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&apos;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. //iOS的webview下，需要强制刷新队列，执行上面的回调函数 if (isIOS) setTimeout(noop) &#125;&#125; else &#123; // fallback to macro microTimerFunc = macroTimerFunc&#125;/** * Wrap a function so that if any code inside triggers state change, * the changes are queued using a (macro) task instead of a microtask. */ /** 在Vue执行绑定的DOM事件时，默认会给回调的handler函数调用withMacroTask方法做一层包装， 它保证整个回调函数的执行过程中，遇到数据状态的改变，这些改变而导致的视图更新（DOM更新） 的任务都会被推到macroTask而不是microtask。 **/export function withMacroTask (fn: Function): Function &#123; return fn._withTask || (fn._withTask = function () &#123; useMacroTask = true const res = fn.apply(null, arguments) useMacroTask = false return res &#125;)&#125; /* 推送到队列中下一个tick时执行 cb 回调函数 ctx 上下文 */export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve /*cb存到callbacks中*/ callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &apos;nextTick&apos;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true if (useMacroTask) &#123; macroTimerFunc() &#125; else &#123; microTimerFunc() &#125; &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; MessageChannel VS setTimeout为什么要优先MessageChannel创建macroTask而不是setTimeout？ HTML5中规定setTimeout的最小时间延迟是4ms，也就是说理想环境下异步回调最快也是4ms才能触发。 Vue使用这么多函数来模拟异步任务，其目的只有一个，就是让回调异步且尽早调用。而MessageChannel的延迟明显是小于setTimeout的。 说了这么多，到底什么是macrotasks，什么是microtasks呢？ 两者的具体实现macrotasks： setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染 microtasks: Promise， process.nextTick， Object.observe， MutationObserver 1.在 macrotask 队列中执行最早的那个 task ，然后移出 2.再执行 microtask 队列中所有可用的任务，然后移出 3.下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步) 那我们上面提到的任务队列到底是什么呢？跟macrotasks和microtasks有什么联系呢？ • 一个事件循环有一个或者多个任务队列； • 每个事件循环都有一个microtask队列； • macrotask队列就是我们常说的任务队列，microtask队列不是任务队列； • 一个任务可以被放入到macrotask队列，也可以放入microtask队列； • 当一个任务被放入microtask或者macrotask队列后，准备工作就已经结束，这时候可以开始执行任务了。 可见，setTimeout和Promises不是同一类的任务，处理方式应该会有区别，具体的处理方式有什么不同呢？ 通俗的解释一下，microtasks的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务。 例如响应事件、或者异步操作，以避免付出额外的一个task的费用。 microtask会在两种情况下执行： 任务队列(macrotask = task queue)回调后执行，前提条件是当前没有其他执行中的代码。每个task末尾执行。另外在处理microtask期间，如果有新添加的microtasks，也会被添加到队列的末尾并执行。 也就是说执行顺序是： 开始 -&gt; 取task queue第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取task queue下一个任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复 Promise一旦状态置为完成态，便为其回调(.then内的函数)安排一个microtask。 接下来我们看回我们上面的代码： 12345678910111213setTimeout(function()&#123; console.log(1)&#125;,0);new Promise(function(resolve)&#123; console.log(2) for( var i=100000 ; i&gt;0 ; i-- )&#123; i==1 &amp;&amp; resolve() &#125; console.log(3)&#125;).then(function()&#123; console.log(4)&#125;);console.log(5); 按照上面的规则重新分析一遍： 当运行到setTimeout时，会把setTimeout的回调函数console.log(1)放到任务队列里去，然后继续向下执行。 接下来会遇到一个Promise。首先执行打印console.log(2)，然后执行for循环，即时for循环要累加到10万，也是在执行栈里面，等待for循环执行完毕以后，将Promise的状态从fulfilled切换到resolve，随后把要执行的回调函数，也就是then里面的console.log(4)推到microtask里面去。接下来马上执行马上console.log(3)。 然后出Promise，还剩一个同步的console.log(5)，直接打印。这样第一轮下来，已经依次打印了2，3，5。 现在第一轮任务队列已经执行完毕，没有正在执行的代码。符合上面讲的microtask执行条件，因此会将microtask中的任务优先执行，因此执行console.log(4) 最后还剩macrotask里的setTimeout放入的函数console.log(1)最后执行。 如此分析输出顺序是： 1234523541 我们再来看一个： 当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候： 1.先执行 macrotasks：I/O -》 UI渲染 2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe 3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次： setTimeout ，setInterval –》setImmediate 综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 12345678910111213141516171819setImmediate(function()&#123; console.log(1);&#125;,0);setTimeout(function()&#123; console.log(2);&#125;,0);new Promise(function(resolve)&#123; console.log(3); resolve(); console.log(4);&#125;).then(function()&#123; console.log(5);&#125;);console.log(6);process.nextTick(function()&#123; console.log(7);&#125;);console.log(8);结果是：3 4 6 8 7 5 2 1 使用了nextTick异步更新视图有什么好处呢？接下来我们看一下一个Demo： 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;export default &#123; data () &#123; return &#123; test: 0 &#125;; &#125;, created () &#123; for(let i = 0; i &lt; 1000; i++) &#123; this.test++; &#125; &#125;&#125; 现在有这样的一种情况，created的时候test的值会被++循环执行1000次。每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。]]></content>
      <tags>
        <tag>vue</tag>
        <tag>nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router浅析原理]]></title>
    <url>%2F2018%2F10%2F15%2Fvue-router%E6%B5%85%E6%9E%90%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[近期被问到一个问题，在你们项目中使用的是Vue的SPA（单页面）还是Vue的多页面设计？ 这篇文章主要围绕Vue的SPA单页面设计展开。关于如何展开Vue多页面设计请点击查看。 vue-router是什么？首先我们需要知道vue-router是什么，它是干什么的？ 这里指的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。换句话说，vue-router就是WebApp的链接路径管理系统。 vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。 那与传统的页面跳转有什么区别呢？ 1.vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。 2.传统的页面应用，是用一些超链接来实现页面切换和跳转的。 在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。 至于为啥不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，必须使用vue-router来进行管理。 vue-router实现原理SPA(single page application):单一页面应用程序，有且只有一个完整的页面；当它在加载页面的时候，不会加载整个页面的内容，而只更新某个指定的容器中内容。 单页面应用(SPA)的核心之一是: 1.更新视图而不重新请求页面; 2.vue-router在实现单页面前端路由时，提供了三种方式：Hash模式、History模式、abstract模式，根据mode参数来决定采用哪一种方式。 路由模式vue-router 提供了三种运行模式： ● hash: 使用 URL hash 值来作路由。默认模式。 ● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。 ● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。 Hash模式vue-router 默认模式是 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会去重新加载。 hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分（/#/..），浏览器只会加载相应位置的内容，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据。 History模式HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面； 由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 //main.js文件中 const router = new VueRouter({ mode: &apos;history&apos;, routes: [...] }) 当使用 history 模式时，URL 就像正常的 url，例如 yoursite.com/user/id，比较好…不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 export const routes = [ {path: &quot;/&quot;, name: &quot;homeLink&quot;, component:Home} {path: &quot;/register&quot;, name: &quot;registerLink&quot;, component: Register}, {path: &quot;/login&quot;, name: &quot;loginLink&quot;, component: Login}, {path: &quot;*&quot;, redirect: &quot;/&quot;}] 此处就设置如果URL输入错误或者是URL 匹配不到任何静态资源，就自动跳到到Home页面。 abstract模式abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。 根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式） vue-router使用方式1:下载 npm i vue-router -S 2:在main.js中引入 import VueRouter from ‘vue-router’; 3:安装插件 Vue.use(VueRouter); 4:创建路由对象并配置路由规则 let router = new VueRouter({routes:[{path:’/home’,component:Home}]}); 5:将其路由对象传递给Vue的实例，options中加入 router:router 6:在app.vue中留坑 &lt;router-view&gt;&lt;/router-view&gt; 具体实现请看如下代码： //main.js文件中引入 import Vue from &apos;vue&apos;; import VueRouter from &apos;vue-router&apos;; //主体 import App from &apos;./components/app.vue&apos;; import index from &apos;./components/index.vue&apos; //安装插件 Vue.use(VueRouter); //挂载属性 //创建路由对象并配置路由规则 let router = new VueRouter({ routes: [ //一个个对象 { path: &apos;/index&apos;, component: index } ] }); //new Vue 启动 new Vue({ el: &apos;#app&apos;, //让vue知道我们的路由规则 router: router, //可以简写router render: c =&gt; c(App), }) 最后记得在在app.vue中“留坑” //app.vue中 &lt;template&gt; &lt;div&gt; &lt;!-- 留坑，非常重要 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { data(){ return {} } } &lt;/script&gt; vue-router源码分析我们先来看看vue的实现路径。在入口文件中需要实例化一个 VueRouter 的实例对象 ，然后将其传入 Vue 实例的 options 中。 export default class VueRouter { static install: () =&gt; void; static version: string; app: any; apps: Array&lt;any&gt;; ready: boolean; readyCbs: Array&lt;Function&gt;; options: RouterOptions; mode: string; history: HashHistory | HTML5History | AbstractHistory; matcher: Matcher; fallback: boolean; beforeHooks: Array&lt;?NavigationGuard&gt;; resolveHooks: Array&lt;?NavigationGuard&gt;; afterHooks: Array&lt;?AfterNavigationHook&gt;; constructor (options: RouterOptions = {}) { this.app = null this.apps = [] this.options = options this.beforeHooks = [] this.resolveHooks = [] this.afterHooks = [] // 创建 matcher 匹配函数 this.matcher = createMatcher(options.routes || [], this) // 根据 mode 实例化具体的 History，默认为&apos;hash&apos;模式 let mode = options.mode || &apos;hash&apos; // 通过 supportsPushState 判断浏览器是否支持&apos;history&apos;模式 // 如果设置的是&apos;history&apos;但是如果浏览器不支持的话，&apos;history&apos;模式会退回到&apos;hash&apos;模式 // fallback 是当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true。 this.fallback = mode === &apos;history&apos; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== falseif (this.fallback) { mode = &apos;hash&apos; } // 不在浏览器内部的话，就会变成&apos;abstract&apos;模式 if (!inBrowser) { mode = &apos;abstract&apos; } this.mode = mode // 根据不同模式选择实例化对应的 History 类 switch (mode) { case&apos;history&apos;: this.history = new HTML5History(this, options.base) breakcase&apos;hash&apos;: this.history = new HashHistory(this, options.base, this.fallback) breakcase&apos;abstract&apos;: this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== &apos;production&apos;) { assert(false, `invalid mode: ${mode}`) } } } match ( raw: RawLocation, current?: Route, redirectedFrom?: Location ): Route { return this.matcher.match(raw, current, redirectedFrom) } get currentRoute (): ?Route { return this.history &amp;&amp; this.history.current } init (app: any /* Vue component instance */) { process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; assert( install.installed, `not installed. Make sure to call \`Vue.use(VueRouter)\` ` + `before creating root instance.` ) this.apps.push(app) // main app already initialized. if (this.app) { return } this.app = app const history = this.history // 根据history的类别执行相应的初始化操作和监听 if (history instanceof HTML5History) { history.transitionTo(history.getCurrentLocation()) } elseif (history instanceof HashHistory) { const setupHashListener = () =&gt; { history.setupListeners() } history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ) } history.listen(route =&gt; { this.apps.forEach((app) =&gt; { app._route = route }) }) } // 路由跳转之前 beforeEach (fn: Function): Function { return registerHook(this.beforeHooks, fn) } // 路由导航被确认之间前 beforeResolve (fn: Function): Function { return registerHook(this.resolveHooks, fn) } // 路由跳转之后 afterEach (fn: Function): Function { return registerHook(this.afterHooks, fn) } // 第一次路由跳转完成时被调用的回调函数 onReady (cb: Function, errorCb?: Function) { this.history.onReady(cb, errorCb) } // 路由报错 onError (errorCb: Function) { this.history.onError(errorCb) } // 路由添加，这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。 push (location: RawLocation, onComplete?: Function, onAbort?: Function) { this.history.push(location, onComplete, onAbort) } // 这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。 replace (location: RawLocation, onComplete?: Function, onAbort?: Function) { this.history.replace(location, onComplete, onAbort) } // 相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面 go (n: number) { this.history.go(n) } // 后退到上一个页面 back () { this.go(-1) } // 前进到下一个页面 forward () { this.go(1) } getMatchedComponents (to?: RawLocation | Route): Array&lt;any&gt; { const route: any = to ? to.matched ? to : this.resolve(to).route : this.currentRoute if (!route) { return [] } return [].concat.apply([], route.matched.map(m =&gt; { return Object.keys(m.components).map(key =&gt; { return m.components[key] }) })) } resolve ( to: RawLocation, current?: Route, append?: boolean ): { location: Location, route: Route, href: string, // for backwards compat normalizedTo: Location, resolved: Route } { const location = normalizeLocation( to, current || this.history.current, append, this ) const route = this.match(location, current) const fullPath = route.redirectedFrom || route.fullPath const base = this.history.base const href = createHref(base, fullPath, this.mode) return { location, route, href, // for backwards compat normalizedTo: location, resolved: route } } addRoutes (routes: Array&lt;RouteConfig&gt;) { this.matcher.addRoutes(routes) if (this.history.current !== START) { this.history.transitionTo(this.history.getCurrentLocation()) } } } HashHistory• hash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。 • 可以为hash的改变添加监听事件： window.addEventListener(&quot;hashchange&quot;,funcRef,false) • 每一次改变hash(window.location.hash)，都会在浏览器访问历史中增加一个记录。 export class HashHistory extends History { constructor (router: Router, base: ?string, fallback: boolean) { super(router, base) // check history fallback deeplinking // 如果是从history模式降级来的，需要做降级检查 if (fallback &amp;&amp; checkFallback(this.base)) { // 如果降级且做了降级处理，则返回 return } ensureSlash() } ....... function checkFallback (base) { const location = getLocation(base) // 得到除去base的真正的 location 值 if (!/^\/#/.test(location)) { // 如果此时地址不是以 /# 开头的 // 需要做一次降级处理，降为 hash 模式下应有的 /# 开头 window.location.replace( cleanPath(base + &apos;/#&apos; + location) ) returntrue } } function ensureSlash (): boolean { // 得到 hash 值 const path = getHash() if (path.charAt(0) === &apos;/&apos;) { // 如果是以 / 开头的，直接返回即可 returntrue } // 不是的话，需要手动保证一次 替换 hash 值 replaceHash(&apos;/&apos; + path) returnfalse } exportfunction getHash (): string { // We can&apos;t use window.location.hash here because it&apos;s not // consistent across browsers - Firefox will pre-decode it! // 因为兼容性的问题，这里没有直接使用 window.location.hash // 因为 Firefox decode hash 值 const href = window.location.href const index = href.indexOf(&apos;#&apos;) return index === -1 ? &apos;&apos; : decodeURI(href.slice(index + 1)) } // 得到hash之前的url地址 function getUrl (path) { const href = window.location.href const i = href.indexOf(&apos;#&apos;) const base = i &gt;= 0 ? href.slice(0, i) : href return `${base}#${path}` } // 添加一个hashfunction pushHash (path) { if (supportsPushState) { pushState(getUrl(path)) } else { window.location.hash = path } } // 替代hashfunction replaceHash (path) { if (supportsPushState) { replaceState(getUrl(path)) } else { window.location.replace(getUrl(path)) } } hash的改变会自动添加到浏览器的访问历史记录中。 那么视图的更新是怎么实现的呢，看下 transitionTo()方法： transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) { const route = this.router.match(location, this.current) //找到匹配路由 this.confirmTransition(route, () =&gt; { //确认是否转化 this.updateRoute(route) //更新route onComplete &amp;&amp; onComplete(route) this.ensureURL() // fire ready cbs once if (!this.ready) { this.ready = true this.readyCbs.forEach(cb =&gt; { cb(route) }) } }, err =&gt; { if (onAbort) { onAbort(err) } if (err &amp;&amp; !this.ready) { this.ready = true this.readyErrorCbs.forEach(cb =&gt; { cb(err) }) } }) } //更新路由 updateRoute (route: Route) { const prev = this.current // 跳转前路由 this.current = route // 装备跳转路由 this.cb &amp;&amp; this.cb(route) // 回调函数，这一步很重要，这个回调函数在index文件中注册，会更新被劫持的数据 _router this.router.afterHooks.forEach(hook =&gt; { hook &amp;&amp; hook(route, prev) }) } } pushStateexportfunction pushState (url?: string, replace?: boolean) { saveScrollPosition() // try...catch the pushState call to get around Safari // DOM Exception 18 where it limits to 100 pushState calls // 加了 try...catch 是因为 Safari 有调用 pushState 100 次限制 // 一旦达到就会抛出 DOM Exception 18 错误 const history = window.history try { if (replace) { // replace 的话 key 还是当前的 key 没必要生成新的 history.replaceState({ key: _key }, &apos;&apos;, url) } else { // 重新生成 key _key = genKey() // 带入新的 key 值 history.pushState({ key: _key }, &apos;&apos;, url) } } catch (e) { // 达到限制了 则重新指定新的地址 window.location[replace ? &apos;replace&apos; : &apos;assign&apos;](url) } } replaceState// 直接调用 pushState 传入 replace 为 trueexportfunction replaceState (url?: string) { pushState(url, true) } pushState和replaceState两种方法的共同特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。 supportsPushStateexport const supportsPushState = inBrowser &amp;&amp; (function () { const ua = window.navigator.userAgent if ( (ua.indexOf(&apos;Android 2.&apos;) !== -1 || ua.indexOf(&apos;Android 4.0&apos;) !== -1) &amp;&amp; ua.indexOf(&apos;Mobile Safari&apos;) !== -1 &amp;&amp; ua.indexOf(&apos;Chrome&apos;) === -1 &amp;&amp; ua.indexOf(&apos;Windows Phone&apos;) === -1 ) { returnfalse } return window.history &amp;&amp; &apos;pushState&apos;in window.history })() 其实所谓响应式属性，即当_route值改变时，会自动调用Vue实例的render()方法，更新视图。$router.push()–&gt;HashHistory.push()–&gt;History.transitionTo()–&gt;History.updateRoute()–&gt;{app._route=route}–&gt;vm.render() 监听地址栏在浏览器中，用户可以直接在浏览器地址栏中输入改变路由，因此还需要监听浏览器地址栏中路由的变化 ，并具有与通过代码调用相同的响应行为，在HashHistory中这一功能通过setupListeners监听hashchange实现： setupListeners () { window.addEventListener(&apos;hashchange&apos;, () =&gt; { if (!ensureSlash()) { return } this.transitionTo(getHash(), route =&gt; { replaceHash(route.fullPath) }) }) } HTML5HistoryHistory interface是浏览器历史记录栈提供的接口，通过back(),forward(),go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。 export class HTML5History extends History { constructor (router: Router, base: ?string) { super(router, base) const expectScroll = router.options.scrollBehavior //指回滚方式 const supportsScroll = supportsPushState &amp;&amp; expectScroll if (supportsScroll) { setupScroll() } const initLocation = getLocation(this.base) //监控popstate事件 window.addEventListener(&apos;popstate&apos;, e =&gt; { const current = this.current // Avoiding first `popstate` event dispatched in some browsers but first // history route not updated since async guard at the same time. // 避免在某些浏览器中首次发出“popstate”事件 // 由于同一时间异步监听，history路由没有同时更新。 const location = getLocation(this.base) if (this.current === START &amp;&amp; location === initLocation) { return } this.transitionTo(location, route =&gt; { if (supportsScroll) { handleScroll(router, route, current, true) } }) }) } hash模式仅改变hash部分的内容，而hash部分是不会包含在http请求中的(hash带#)： oursite.com/#/user/id //如请求，只会发送http://oursite.com/ 所以hash模式下遇到根据url请求页面不会有问题 而history模式则将url修改的就和正常请求后端的url一样(history不带#) oursite.com/user/id 如果这种向后端发送请求的话，后端没有配置对应/user/id的get路由处理,会返回404错误。 官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。 两种模式比较一般的需求场景中，hash模式与history模式是差不多的，根据MDN的介绍，调用history.pushState()相比于直接修改hash主要有以下优势： • pushState设置的新url可以是与当前url同源的任意url,而hash只可修改#后面的部分，故只可设置与当前同文档的url • pushState设置的新url可以与当前url一模一样，这样也会把记录添加到栈中，而hash设置的新值必须与原来不一样才会触发记录添加到栈中 • pushState通过stateObject可以添加任意类型的数据记录中，而hash只可添加短字符串pushState可额外设置title属性供后续使用 AbstractHistory‘abstract’模式，不涉及和浏览器地址的相关记录，流程跟’HashHistory’是一样的，其原理是通过数组模拟浏览器历史记录栈的功能 //abstract.js实现，这里通过栈的数据结构来模拟路由路径 export class AbstractHistory extends History { index: number; stack: Array&lt;Route&gt;; constructor (router: Router, base: ?string) { super(router, base) this.stack = [] this.index = -1 } // 对于 go 的模拟 go (n: number) { // 新的历史记录位置 const targetIndex = this.index + n // 小于或大于超出则返回 if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) { return } // 取得新的 route 对象 // 因为是和浏览器无关的 这里得到的一定是已经访问过的 const route = this.stack[targetIndex] // 所以这里直接调用 confirmTransition 了 // 而不是调用 transitionTo 还要走一遍 match 逻辑 this.confirmTransition(route, () =&gt; { this.index = targetIndex this.updateRoute(route) }) } //确认是否转化路由 confirmTransition (route: Route, onComplete: Function, onAbort?: Function) { const current = this.current const abort = err =&gt; { if (isError(err)) { if (this.errorCbs.length) { this.errorCbs.forEach(cb =&gt; { cb(err) }) } else { warn(false, &apos;uncaught error during route navigation:&apos;) console.error(err) } } onAbort &amp;&amp; onAbort(err) } //判断如果前后是同一个路由，不进行操作 if ( isSameRoute(route, current) &amp;&amp; route.matched.length === current.matched.length ) { this.ensureURL() return abort() } //下面是各类钩子函数的处理 //********************* }) }]]></content>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[compose-串联中间件实现(洋葱模型)]]></title>
    <url>%2F2018%2F10%2F11%2Fcompose-%E4%B8%B2%E8%81%94%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言Koa 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 Express 支持了异步，所以编码时经常使用 async/await，提高了可读性，使代码变得更优雅，上一篇文章 NodeJS 进阶 —— Koa 源码分析，也对 “洋葱模型” 和实现它的 compose 进行分析，由于个人觉得 compose 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 compose。 洋葱模型案例如果你已经使用 Koa 对 “洋葱模型” 这个词一定不陌生，它就是 Koa 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。 const Koa = require(&quot;koa&quot;); const app = new Koa(); app.use(asycn (ctx, next) =&gt; { console.log(1); await next(); console.log(2); }); app.use(asycn (ctx, next) =&gt; { console.log(3); await next(); console.log(4); }); app.use(asycn (ctx, next) =&gt; { console.log(5); await next(); console.log(6); }); app.listen(3000); // 1 // 3 // 5 // 6 // 4 // 2 上面的写法我们按照官方推荐，使用了 async/await，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 next，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 Koa 源码中，这一功能是靠一个 compose 方法实现的，我们本文四种实现 compose 的方式中实现同步和异步，并附带对应的案例来验证。 准备工作在真正创建 compose 方法之前应该先做些准备工作，比如创建一个 app 对象来顶替 Koa 创建出的实例对象，并添加 use 方法和管理中间件的数组 middlewares。 文件：app.js // 模拟 Koa 创建的实例 const app = { middlewares: [] }; // 创建 use 方法 app.use = function(fn) { app.middlewares.push(fn); }; // app.compose..... module.exports = app; 上面的模块中导出了 app 对象，并创建了存储中间件函数的 middlewares 和添加中间件的 use 方法，因为无论用哪种方式实现 compose 这些都是需要的，只是 compose 逻辑的不同，所以后面的代码块中会只写 compose 方法。 Koa 中 compose 的实现方式首先介绍的是 Koa 源码中的实现方式，在 Koa 源码中其实是通过 koa-compose 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 compose 的原理，所以 ctx 参数就被去掉了，因为我们不会使用它，重点是 next 参数。 1、同步的实现文件：app.js app.compose = function() { // 递归函数 function dispatch(index) { // 如果所有中间件都执行完跳出 if (index === app.middlewares.length) return; // 取出第 index 个中间件并执行 const route = app.middlewares[index]; return route(() =&gt; dispatch(index + 1)); } // 取出第一个中间件函数执行 dispatch(0); }; 上面是同步的实现，通过递归函数 dispatch 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 dispatch，传入的参数 +1，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 1 3 5 6 4 2 的情况执行，测试例子如下（同步上、异步下）。 文件：sync-test.js const app = require(&quot;./app&quot;); app.use(next =&gt; { console.log(1); next(); console.log(2); }); app.use(next =&gt; { console.log(3); next(); console.log(4); }); app.use(next =&gt; { console.log(5); next(); console.log(6); }); app.compose(); // 1 // 3 // 5 // 6 // 4 // 2 文件：async-test.js const app = require(&quot;./app&quot;); // 异步函数 functionfn() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(); console.log(&quot;hello&quot;); }, 3000); }); } app.use(async next =&gt; { console.log(1); await next(); console.log(2); }); app.use(async next =&gt; { console.log(3); await fn(); // 调用异步函数 await next(); console.log(4); }); app.use(async next =&gt; { console.log(5); await next(); console.log(6); }); app.compose(); 我们发现如果案例中按照 Koa 的推荐写法，即使用 async 函数，都会通过，但是在给 use 传参时可能会传入普通函数或 async 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 Koa 中 compose 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。 注意：后面 compose 的其他实现方式中，都是使用 sync-test.js 和 async-test.js 验证，所以后面就不再重复了。 2、升级为支持异步文件：app.js app.compose = function() { // 递归函数 function dispatch(index) { // 如果所有中间件都执行完跳出，并返回一个 Promise if (index === app.middlewares.length) return Promise.resolve(); // 取出第 index 个中间件并执行 const route = app.middlewares[index]; // 执行后返回成功态的 Promise return Promise.resolve(route(() =&gt; dispatch(index + 1))); } // 取出第一个中间件函数执行 dispatch(0); }; 我们知道 async 函数中 await 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 async-test.js进行测试，发现结果为 1 3 hello(3s后) 5 6 4 2。 Redux 旧版本 compose 的实现方式1、同步的实现文件：app.js app.compose = function() { return app.middlewares.reduceRight((a, b) =&gt; () =&gt; b(a), () =&gt; {})(); }; 上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 middlewares 中存储的三个中间件函数分别为 fn1、fn2 和 fn3，由于使用的是 reduceRight 方法，所以是逆序归并，第一次 a 代表初始值（空函数），b 代表 fn3，而执行 fn3 返回了一个函数，这个函数再作为下一次归并的 a，而 fn2 作为 b，依次类推，过程如下。 // 第 1 次 reduceRight 的返回值，下一次将作为 a () =&gt; fn3(() =&gt; {}); // 第 2 次 reduceRight 的返回值，下一次将作为 a () =&gt; fn2(() =&gt; fn3(() =&gt; {})); // 第 3 次 reduceRight 的返回值，下一次将作为 a () =&gt; fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {}))); 由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 fn1，如果调用 next 则会执行 fn2，如果同样调用 next 则会执行 fn3，fn3 已经是最后一个中间件函数了，再次调 next 会执行我们最初传入的空函数，这也是为什么要将 reduceRight 的初始值设置成一个空函数，就是防止最后一个中间件调用 next 而报错。 经过测试上面的代码不会出现顺序错乱的情况，但是在 compose 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 use 的中间件函数既可以是普通函数，又可以是 async 函数，这就要我们的 compose 完全支持异步。 2、升级为支持异步文件：app.js app.compose = function() { return Promise.resolve( app.middlewares.reduceRight( (a, b) =&gt; () =&gt; Promise.resolve(b(a)), () =&gt; Promise.resolve(); )() ); }; 参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 next 后又调用了 then），都处理成了 Promise，保证了 reduceRight 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 async 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 compose 就可以调用 then 方法执行后续逻辑。 Redux 新版本 compose 的实现方式1、同步的实现文件：app.js app.compose = function() { return app.middlewares.reduce((a, b) =&gt; arg =&gt; a(() =&gt; b(arg)))(() =&gt; {}); }; Redux 新版本中将 compose 的逻辑做了些改动，将原本的 reduceRight 换成 reduce，也就是说将逆序归并改为了正序，我们不一定和 Redux 源码完全相同，是根据相同的思路来实现串行中间件的需求。 个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 fn1、fn2 和 fn3，由于 reduce 并没有传入初始值，所以此时 a 为 fn1，b 为 fn2。 // 第 1 次 reduce 的返回值，下一次将作为 a arg =&gt; fn1(() =&gt; fn2(arg)); // 第 2 次 reduce 的返回值，下一次将作为 a arg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg)); // 等价于... arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg))); // 执行最后返回的函数连接中间件，返回值等价于... fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {}))); 所以在调用 reduce 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 fn3，也就是第三个中间件，这样保证了在最后一个中间件调用 next 时不会报错。 2、升级为支持异步下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。 文件：app.js app.compose = function() { return Promise.resolve( app.middlewares.reduce((a, b) =&gt; arg =&gt; Promise.resolve(a(() =&gt; b(arg))) )(() =&gt; Promise.resolve()) ); }; 实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 compose 也返回 Promise。 使用 async 函数实现这个版本是我在之前在学习 Koa 源码时偶然在一位大佬的一篇分析 Koa 原理的文章中看到的（翻了半天实在没找到链接），在这里也拿出来和大家分享一下，由于是利用 async 函数实现的，所以默认就是支持异步的，因为 async 函数会返回一个 Promise。 文件：app.js app.compose = function() { // 自执行 async 函数返回 Promise return (async function () { // 定义默认的 next，最后一个中间件内执行的 next let next = async () =&gt; Promise.resolve(); // middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next // 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题 function createNext(middleware, oldNext) { return async () =&gt; { await middleware(oldNext); } } // 反向遍历中间件数组，先把 next 传给最后一个中间件函数 // 将新的中间件函数存入 next 变量 // 调用下一个中间件函数，将新生成的 next 传入 for (let i = app.middlewares.length - 1; i &gt;= 0; i--) { next = createNext(app.middlewares[i], next); } await next(); })(); }; 上面代码中的 next 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 next，而数组 middlewares 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 createNext作用是返回一个新的可以执行数组中最后一个中间件的 async 函数，并传入了初始的 next，这个返回的 async 函数作为新的 next，再取到倒数第二个中间件，调用 createNext，又返回了一个 async 函数，函数内依然是倒数第二个中间件的执行，传入的 next 就是上次新生成的 next，这样依次类推到第一个中间件。 因此执行第一个中间件返回的 next 则会执行传入的上一个生成的 next 函数，就会执行第二个中间件，就会执行第二个中间件中的 next，就这样直到执行完最初定义的的 next，通过案例的验证，执行结果与洋葱模型完全相同。 至于异步的问题，每次执行的 next 都是 async 函数，执行后返回的都是 Promise，而最外层的自执行 async 函数返回的也是 Promise，也就是说 compose 最后返回的是 Promise，因此完全支持异步。 这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。 总结或许你看完这几种方式会觉得，还是 Koa 对于 compose 的实现方式最容易理解，你也可能和我一样在感慨 Redux 的两种实现方式和 async 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想，写出 compose 这种优雅又高逼格的代码，路漫漫其修远兮，愿你在技术的路上 “一去不复返”。]]></content>
  </entry>
  <entry>
    <title><![CDATA[koa-bodyparser中间件模拟]]></title>
    <url>%2F2018%2F10%2F10%2Fkoa-bodyparser%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[前言Koa 2.x 版本是当下最流行的 NodeJS 框架，Koa 2.0 的源码特别精简，不像 Express 封装的功能那么多，所以大部分的功能都是由 Koa 开发团队（同 Express 是一家出品）和社区贡献者针对 Koa 对 NodeJS 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 Koa 的 use 方法使用在对应的位置，这样就可以通过在内部操作 ctx 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 Koa 中间件供自己和别人使用。 Koa 的洋葱模型介绍我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 API 的使用方式及洋葱模型分析中间件是如何工作的。 // 洋葱模型特点// 引入 Koa const Koa = require(&quot;koa&quot;); // 创建服务 const app = new Koa(); app.use(async (ctx, next) =&gt; { console.log(1); await next(); console.log(2); }); app.use(async (ctx, next) =&gt; { console.log(3); await next(); console.log(4); }); app.use(async (ctx, next) =&gt; { console.log(5); await next(); console.log(6); }); // 监听服务 app.listen(3000); // 1 // 3 // 5 // 6 // 4 // 2 我们知道 Koa 的 use 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 next 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 Koa 中都是建议使用 async/await 的，引入的中间件都是在 use 方法中调用，由此我们可以分析出每一个 Koa 的中间件都是返回一个 async 函数的。 koa-bodyparser 中间件模拟想要分析 koa-bodyparser 的原理首先需要知道用法和作用，koa-bodyparser 中间件是将我们的 post 请求和表单提交的查询字符串转换成对象，并挂在 ctx.request.body 上，方便我们在其他中间件或接口处取值，使用前需提前安装。 npm install koa koa-bodyparser koa-bodyparser 具体用法如下： // koa-bodyparser 的用法 const Koa = require(&quot;koa&quot;); const bodyParser = require(&quot;koa-bodyparser&quot;); const app = new Koa(); // 使用中间件 app.use(bodyParser()); app.use(async (ctx, next) =&gt; { if (ctx.path === &quot;/&quot; &amp;&amp; ctx.method === &quot;POST&quot;) { // 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据 console.log(ctx.request.body); } }); app.listen(3000); 根据用法我们可以看出 koa-bodyparser 中间件引入的其实是一个函数，我们把它放在了 use 中执行，根据 Koa 的特点，我们推断出 koa-bodyparser 的函数执行后应该给我们返回了一个 async 函数，下面是我们模拟实现的代码。 // 文件：my-koa-bodyparser.js const querystring = require(&quot;querystring&quot;); module.exports = functionbodyParser() { returnasync (ctx, next) =&gt; { await new Promise((resolve, reject) =&gt; { // 存储数据的数组 let dataArr = []; // 接收数据 ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data)); // 整合数据并使用 Promise 成功 ctx.req.on(&quot;end&quot;, () =&gt; { // 获取请求数据的类型 json 或表单 let contentType = ctx.get(&quot;Content-Type&quot;); // 获取数据 Buffer 格式 let data = Buffer.concat(dataArr).toString(); if (contentType === &quot;application/x-www-form-urlencoded&quot;) { // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body ctx.request.body = querystring.parse(data); } elseif (contentType === &quot;applaction/json&quot;) { // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body ctx.request.body = JSON.parse(data); } // 执行成功的回调 resolve(); }); }); // 继续向下执行 await next(); }; }; 在上面代码中由几点是需要我们注意的，即 next 的调用以及为什么通过流接收数据、处理数据和将数据挂在 ctx.request.body 要在 Promise 中进行。 首先是 next 的调用，我们知道 Koa 的 next 执行，其实就是在执行下一个中间件的函数，即下一个 use 中的 async 函数，为了保证后面的异步代码执行完毕后再继续执行当前的代码，所以我们需要使用 await 进行等待，其次就是数据从接收到挂在 ctx.request.body 都在 Promise 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 ctx.request.body 上，可以保证我们在下一个 use 的 async 函数中可以在 ctx.request.body 上拿到数据，所以我们使用 await 等待一个 Promise 成功后再执行 next。]]></content>
      <tags>
        <tag>koa</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于IntersectionObserver的图片懒加载实现]]></title>
    <url>%2F2018%2F10%2F10%2F%E5%9F%BA%E4%BA%8EIntersectionObserver%E7%9A%84%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;图片懒加载&lt;/title&gt; &lt;link href=&quot;./css/style.css&quot; rel=&quot;stylesheet&quot;/&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;view&quot;&gt; &lt;img data-src=&quot;http://img.pconline.com.cn/images/upload/upc/tx/wallpaper/1301/05/c0/17135331_1357355776882.jpg&quot; class=&quot;lazy-image&quot;/&gt; &lt;img data-src=&quot;http://f.hiphotos.baidu.com/zhidao/pic/item/eac4b74543a982267a3d54978a82b9014b90eb86.jpg&quot; class=&quot;lazy-image&quot;/&gt; &lt;img data-src=&quot;http://pic1.win4000.com/wallpaper/2/58b61f7dc6c1d.jpg&quot; class=&quot;lazy-image&quot;/&gt; &lt;img data-src=&quot;http://file03.16sucai.com/2017/1100/16sucai_p20161106032_0c2.JPG&quot; class=&quot;lazy-image&quot;/&gt; &lt;img data-src=&quot;http://imgsrc.baidu.com/image/c0%3Dpixel_huitu%2C0%2C0%2C294%2C40/sign=5a7938d38acb39dbd5cd6f16b96e6c48/aec379310a55b3196c79de4c48a98226cffc1702.jpg&quot; class=&quot;lazy-image&quot;/&gt; &lt;img data-src=&quot;http://c.hiphotos.baidu.com/zhidao/pic/item/8d5494eef01f3a2987a8062f9f25bc315d607ceb.jpg&quot; class=&quot;lazy-image&quot;/&gt; &lt;/div&gt;&lt;/body&gt;&lt;link href=&quot;./css/style.css&quot; rel=&quot;stylesheet&quot;/&gt;&lt;script src=&quot;js/lazy-image.js&quot;&gt;&lt;/script&gt;&lt;script&gt; console.log(document.documentElement.clientHeight) new LazyImage(&apos;.lazy-image&apos;)&lt;/script&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class LazyImage &#123; constructor(selector) &#123; // 懒记载图片列表，将伪数组转为数组，以便可以使用数组的api this.lazyImages = Array.prototype.slice.call(document.querySelectorAll(selector)) this.init() &#125; inViewShow() &#123; // 不支持IntersectionObserver api的情况下判断图片是否出现在可视区域内 let len = this.lazyImages.length for(let i = 0; i &lt; len; i++) &#123; let lazyImage = this.lazyImages[i] const rect = lazyImage.getBoundingClientRect() // 出现在视野的时候加载图片 if(rect.top &lt; document.documentElement.clientHeight) &#123; lazyImage.src = lazyImage.dataset.src // 移除掉已经显示的 this.lazyImages.splice(i, 1) len-- i-- if(this.lazyImages.length === 0) &#123; // 如果全部都加载完 则去掉滚动事件监听 document.removeEventListener(&apos;scroll&apos;, this._throttleFn) &#125; &#125; &#125; &#125; throttle(fn, delay = 15, mustRun = 30) &#123; let t_start = null let timer = null let context = this return function() &#123; let t_current = +(new Date()) let args = Array.prototype.slice.call(arguments) clearTimeout(timer) if(!t_start) &#123; t_start = t_current &#125; if(t_current - t_start &gt; mustRun) &#123; fn.apply(context, args) t_start = t_current &#125; else &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, delay) &#125; &#125; &#125; init() &#123; // 通过IntersectionObserver api判断图片是否出现在可视区域内，不需要监听Scroll来判断 if (&quot;IntersectionObserver&quot; in window) &#123; let lazyImageObserver = new IntersectionObserver((entries, observer) =&gt; &#123; entries.forEach((entry, index) =&gt; &#123; // 如果元素可见 if (entry.isIntersecting) &#123; let lazyImage = entry.target lazyImage.src = lazyImage.dataset.src lazyImageObserver.unobserve(lazyImage) // this.lazyImages.splice(index, 1) &#125; &#125;) &#125;) this.lazyImages.forEach(function(lazyImage) &#123; lazyImageObserver.observe(lazyImage); &#125;) &#125; else &#123; this.inViewShow() this._throttleFn = this.throttle(this.inViewShow) document.addEventListener(&apos;scroll&apos;, this._throttleFn) &#125; &#125; &#125; 1234567891011121314151617181920212223html,body &#123; height: 100%; width: 100%; margin: 0;&#125;#view &#123; color: red; width: 200px; height: 300px&#125;.lazy-image &#123; background: url(&apos;../img/loading.gif&apos;) no-repeat center;&#125;img&#123; margin-top: 100px; background-size: cover; background-position: center; width: 490px; height: 242px;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[(a ==1 && a== 2 && a==3) 有可能是 true 吗？]]></title>
    <url>%2F2018%2F10%2F10%2Fa-1-a-2-a-3-%E6%9C%89%E5%8F%AF%E8%83%BD%E6%98%AF-true-%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一个有趣的问题：在 JavaScript 中， (a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 是否有可能为 true ？ 这是一道我被某科技公司问到的面试题。发生在两周之前，我仍然在努力寻找答案。 我知道我们从来不会在日常工作中写出这样的代码，但我对问题的答案仍然十分很好奇。 解法一：利用松散相等运算符 == 的工作原理，你可以简单地创建一个带有自定义toString( 或者 valueOf)函数的对象，在每一次使用它时候改变它所的返回值，使其满足所有三个条件。 const a = { i: 1, toString: function () { return a.i++; } } if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) { console.log(&apos;Hello World!&apos;); } // Hello World! 之所以会得到如此结果，是由于表达式中使用了松散相等的运算符 ==。使用松散相等时，如果其中一个操作数与另一个类型不同，则 JS 引擎将尝试将一个操作转换为另一个类型。在左边对象、右边的数字的情况下，它会尝试将对象转换为一个数，首先通过调用 valueOf 如果是可调用的。否则，它会调用toString方法。我使用toString仅仅是因为它是我的第一反应，valueOf 会更合理。如果我不从toString返回一个字符串（而是返回数字），JS 引擎会尝试将字符串转换为一个数字，虽然有一个稍长的路径，但它仍然会给我们同样的结果。 解法二：我不可否认——其他答案无疑是正确的，但你真的不能过错下面的代码： var aﾠ = 1; var a = 2; var ﾠa = 3; if(aﾠ==1 &amp;&amp; a== 2 &amp;&amp;ﾠa==3) { console.log(&quot;Why hello there!&quot;) } 请注意if 语句中的奇怪间距。它是半宽度韩文=,=。这是一个 Unicode 空格字符，但是 ECMAScript 不将其解释为一个空格 —— 这意味着它是一个有效的标识符。因此有三个完全不同的变量，一个是a后加半宽度韩文，一个是a， 一个是a前加半宽度韩文。。。 用下划线 _ 替代半宽度韩文，增加可读性，相同的代码看起来像这样： var a_ = 1; var a = 2; var _a = 3; if(a_==1 &amp;&amp; a== 2 &amp;&amp;_a==3) { console.log(&quot;Why hello there!&quot;) } 解法三：这是完全可能的！ var val = 0; Object.defineProperty(window, &apos;a&apos;, { get: function() { return ++val; } }); if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) { console.log(&apos;yay&apos;); } 使用一个get，让 a 的返回值为三个不同的值。然而这并不意味着我们应该在真正的代码中使用。。。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Babel 将 Generator 编译成了什么]]></title>
    <url>%2F2018%2F10%2F05%2FBabel-%E5%B0%86-Generator-%E7%BC%96%E8%AF%91%E6%88%90%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[前言本文就是简单介绍下 Generator 语法编译后的代码。 Generatorfunction* helloWorldGenerator() { yield&apos;hello&apos;; yield&apos;world&apos;; return&apos;ending&apos;; } 我们打印下执行的结果： var hw = helloWorldGenerator(); console.log(hw.next()); // {value: &quot;hello&quot;, done: false}console.log(hw.next()); // {value: &quot;world&quot;, done: false}console.log(hw.next()); // {value: &quot;ending&quot;, done: true}console.log(hw.next()); // {value: undefined, done: true} Babel具体的执行过程就不说了，我们直接在 Babel 官网的 Try it out 粘贴上述代码，然后查看代码被编译成了什么样子： /** * 我们就称呼这个版本为简单编译版本吧 */var _marked = /*#__PURE__*/ regeneratorRuntime.mark(helloWorldGenerator); functionhelloWorldGenerator() { return regeneratorRuntime.wrap( functionhelloWorldGenerator$(_context) { while (1) { switch ((_context.prev = _context.next)) { case0: _context.next = 2; return&quot;hello&quot;; case2: _context.next = 4; return&quot;world&quot;; case4: return _context.abrupt(&quot;return&quot;, &quot;ending&quot;); case5: case&quot;end&quot;: return _context.stop(); } } }, _marked, this ); } 猛一看，好像编译后的代码还蛮少的，但是细细一看，编译后的代码肯定是不能用的呀，regeneratorRuntime 是个什么鬼？哪里有声明呀？mark 和 wrap 方法又都做了什么？ 难道就不能编译一个完整可用的代码吗？ regenerator如果你想看到完整可用的代码，你可以使用 regenerator，这是 facebook 下的一个工具，用于编译 ES6 的 generator 函数。 我们先安装一下 regenerator： npm install -g regenerator 然后新建一个 generator.js 文件，里面的代码就是文章最一开始的代码，我们执行命令： regenerator --include-runtime generator.js &gt; generator-es5.js 我们就可以在 generator-es5.js 文件看到编译后的完整可用的代码。 而这一编译就编译了 700 多行…… 编译后的代码可以查看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757/** * Copyright (c) 2014-present, Facebook, Inc. * * This source code is licensed under the MIT license found in the * LICENSE file in the root directory of this source tree. */!(function(global) &#123; &quot;use strict&quot;; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; // More compressible than void 0. var $Symbol = typeof Symbol === &quot;function&quot; ? Symbol : &#123;&#125;; var iteratorSymbol = $Symbol.iterator || &quot;@@iterator&quot;; var asyncIteratorSymbol = $Symbol.asyncIterator || &quot;@@asyncIterator&quot;; var toStringTagSymbol = $Symbol.toStringTag || &quot;@@toStringTag&quot;; var inModule = typeof module === &quot;object&quot;; var runtime = global.regeneratorRuntime; if (runtime) &#123; if (inModule) &#123; // If regeneratorRuntime is defined globally and we&apos;re in a module, // make the exports object identical to regeneratorRuntime. module.exports = runtime; &#125; // Don&apos;t bother evaluating the rest of this file if the runtime was // already defined globally. return; &#125; // Define the runtime globally (as expected by generated code) as either // module.exports (if we&apos;re in a module) or a new, empty object. runtime = global.regeneratorRuntime = inModule ? module.exports : &#123;&#125;; function wrap(innerFn, outerFn, self, tryLocsList) &#123; // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator. var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next, // .throw, and .return methods. generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; &#125; runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion // record like context.tryEntries[i].completion. This interface could // have been (and was previously) designed to take a closure to be // invoked without arguments, but in all the cases we care about we // already have an existing method we want to call, so there&apos;s no need // to create a new function object. We can even get away with assuming // the method takes exactly one argument, since that happens to be true // in every case, so we don&apos;t have to touch the arguments object. The // only additional allocation required is the completion record, which // has a stable shape and so hopefully should be cheap to allocate. function tryCatch(fn, obj, arg) &#123; try &#123; return &#123; type: &quot;normal&quot;, arg: fn.call(obj, arg) &#125;; &#125; catch (err) &#123; return &#123; type: &quot;throw&quot;, arg: err &#125;; &#125; &#125; var GenStateSuspendedStart = &quot;suspendedStart&quot;; var GenStateSuspendedYield = &quot;suspendedYield&quot;; var GenStateExecuting = &quot;executing&quot;; var GenStateCompleted = &quot;completed&quot;; // Returning this object from the innerFn has the same effect as // breaking out of the dispatch switch statement. var ContinueSentinel = &#123;&#125;; // Dummy constructor functions that we use as the .constructor and // .constructor.prototype properties for functions that return Generator // objects. For full spec compliance, you may wish to configure your // minifier not to mangle the names of these two functions. function Generator() &#123;&#125; function GeneratorFunction() &#123;&#125; function GeneratorFunctionPrototype() &#123;&#125; // This is a polyfill for %IteratorPrototype% for environments that // don&apos;t natively support it. var IteratorPrototype = &#123;&#125;; IteratorPrototype[iteratorSymbol] = function () &#123; return this; &#125;; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto &amp;&amp; getProto(getProto(values([]))); if (NativeIteratorPrototype &amp;&amp; NativeIteratorPrototype !== Op &amp;&amp; hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) &#123; // This environment has a native %IteratorPrototype%; use it instead // of the polyfill. IteratorPrototype = NativeIteratorPrototype; &#125; var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = &quot;GeneratorFunction&quot;; // Helper for defining the .next, .throw, and .return methods of the // Iterator interface in terms of a single ._invoke method. function defineIteratorMethods(prototype) &#123; [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123; prototype[method] = function(arg) &#123; return this._invoke(method, arg); &#125;; &#125;); &#125; runtime.isGeneratorFunction = function(genFun) &#123; var ctor = typeof genFun === &quot;function&quot; &amp;&amp; genFun.constructor; return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can // do is to check its .name property. (ctor.displayName || ctor.name) === &quot;GeneratorFunction&quot; : false; &#125;; runtime.mark = function(genFun) &#123; if (Object.setPrototypeOf) &#123; Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); &#125; else &#123; genFun.__proto__ = GeneratorFunctionPrototype; if (!(toStringTagSymbol in genFun)) &#123; genFun[toStringTagSymbol] = &quot;GeneratorFunction&quot;; &#125; &#125; genFun.prototype = Object.create(Gp); return genFun; &#125;; // Within the body of any async function, `await x` is transformed to // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test // `hasOwn.call(value, &quot;__await&quot;)` to determine if the yielded value is // meant to be awaited. runtime.awrap = function(arg) &#123; return &#123; __await: arg &#125;; &#125;; function AsyncIterator(generator) &#123; function invoke(method, arg, resolve, reject) &#123; var record = tryCatch(generator[method], generator, arg); if (record.type === &quot;throw&quot;) &#123; reject(record.arg); &#125; else &#123; var result = record.arg; var value = result.value; if (value &amp;&amp; typeof value === &quot;object&quot; &amp;&amp; hasOwn.call(value, &quot;__await&quot;)) &#123; return Promise.resolve(value.__await).then(function(value) &#123; invoke(&quot;next&quot;, value, resolve, reject); &#125;, function(err) &#123; invoke(&quot;throw&quot;, err, resolve, reject); &#125;); &#125; return Promise.resolve(value).then(function(unwrapped) &#123; // When a yielded Promise is resolved, its final value becomes // the .value of the Promise&lt;&#123;value,done&#125;&gt; result for the // current iteration. result.value = unwrapped; resolve(result); &#125;, function(error) &#123; // If a rejected Promise was yielded, throw the rejection back // into the async generator function so it can be handled there. return invoke(&quot;throw&quot;, error, resolve, reject); &#125;); &#125; &#125; var previousPromise; function enqueue(method, arg) &#123; function callInvokeWithMethodAndArg() &#123; return new Promise(function(resolve, reject) &#123; invoke(method, arg, resolve, reject); &#125;); &#125; return previousPromise = // If enqueue has been called before, then we want to wait until // all previous Promises have been resolved before calling invoke, // so that results are always delivered in the correct order. If // enqueue has not been called before, then it is important to // call invoke immediately, without waiting on a callback to fire, // so that the async generator function has the opportunity to do // any necessary setup in a predictable way. This predictability // is why the Promise constructor synchronously invokes its // executor callback, and why async functions synchronously // execute code before the first await. Since we implement simple // async functions in terms of async generators, it is especially // important to get this right, even though it requires care. previousPromise ? previousPromise.then( callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later // invocations of the iterator. callInvokeWithMethodAndArg ) : callInvokeWithMethodAndArg(); &#125; // Define the unified helper method that is used to implement .next, // .throw, and .return (see defineIteratorMethods). this._invoke = enqueue; &#125; defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () &#123; return this; &#125;; runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of // AsyncIterator objects; they just return a Promise for the value of // the final result produced by the iterator. runtime.async = function(innerFn, outerFn, self, tryLocsList) &#123; var iter = new AsyncIterator( wrap(innerFn, outerFn, self, tryLocsList) ); return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator. : iter.next().then(function(result) &#123; return result.done ? result.value : iter.next(); &#125;); &#125;; function makeInvokeMethod(innerFn, self, context) &#123; var state = GenStateSuspendedStart; return function invoke(method, arg) &#123; if (state === GenStateExecuting) &#123; throw new Error(&quot;Generator is already running&quot;); &#125; if (state === GenStateCompleted) &#123; if (method === &quot;throw&quot;) &#123; throw arg; &#125; // Be forgiving, per 25.3.3.3.3 of the spec: // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume return doneResult(); &#125; context.method = method; context.arg = arg; while (true) &#123; var delegate = context.delegate; if (delegate) &#123; var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) &#123; if (delegateResult === ContinueSentinel) continue; return delegateResult; &#125; &#125; if (context.method === &quot;next&quot;) &#123; // Setting context._sent for legacy support of Babel&apos;s // function.sent implementation. context.sent = context._sent = context.arg; &#125; else if (context.method === &quot;throw&quot;) &#123; if (state === GenStateSuspendedStart) &#123; state = GenStateCompleted; throw context.arg; &#125; context.dispatchException(context.arg); &#125; else if (context.method === &quot;return&quot;) &#123; context.abrupt(&quot;return&quot;, context.arg); &#125; state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === &quot;normal&quot;) &#123; // If an exception is thrown from innerFn, we leave state === // GenStateExecuting and loop back for another invocation. state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) &#123; continue; &#125; return &#123; value: record.arg, done: context.done &#125;; &#125; else if (record.type === &quot;throw&quot;) &#123; state = GenStateCompleted; // Dispatch the exception by looping back around to the // context.dispatchException(context.arg) call above. context.method = &quot;throw&quot;; context.arg = record.arg; &#125; &#125; &#125;; &#125; // Call delegate.iterator[context.method](context.arg) and handle the // result, either by returning a &#123; value, done &#125; result from the // delegate iterator, or by modifying context.method and context.arg, // setting context.delegate to null, and returning the ContinueSentinel. function maybeInvokeDelegate(delegate, context) &#123; var method = delegate.iterator[context.method]; if (method === undefined) &#123; // A .throw or .return when the delegate iterator has no .throw // method always terminates the yield* loop. context.delegate = null; if (context.method === &quot;throw&quot;) &#123; if (delegate.iterator.return) &#123; // If the delegate iterator has a return method, give it a // chance to clean up. context.method = &quot;return&quot;; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === &quot;throw&quot;) &#123; // If maybeInvokeDelegate(context) changed context.method from // &quot;return&quot; to &quot;throw&quot;, let that override the TypeError below. return ContinueSentinel; &#125; &#125; context.method = &quot;throw&quot;; context.arg = new TypeError( &quot;The iterator does not provide a &apos;throw&apos; method&quot;); &#125; return ContinueSentinel; &#125; var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === &quot;throw&quot;) &#123; context.method = &quot;throw&quot;; context.arg = record.arg; context.delegate = null; return ContinueSentinel; &#125; var info = record.arg; if (! info) &#123; context.method = &quot;throw&quot;; context.arg = new TypeError(&quot;iterator result is not an object&quot;); context.delegate = null; return ContinueSentinel; &#125; if (info.done) &#123; // Assign the result of the finished delegate to the temporary // variable specified by delegate.resultName (see delegateYield). context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield). context.next = delegate.nextLoc; // If context.method was &quot;throw&quot; but the delegate handled the // exception, let the outer generator proceed normally. If // context.method was &quot;next&quot;, forget context.arg since it has been // &quot;consumed&quot; by the delegate iterator. If context.method was // &quot;return&quot;, allow the original .return call to continue in the // outer generator. if (context.method !== &quot;return&quot;) &#123; context.method = &quot;next&quot;; context.arg = undefined; &#125; &#125; else &#123; // Re-yield the result returned by the delegate method. return info; &#125; // The delegate iterator is finished, so forget it and continue with // the outer generator. context.delegate = null; return ContinueSentinel; &#125; // Define Generator.prototype.&#123;next,throw,return&#125; in terms of the // unified ._invoke helper method. defineIteratorMethods(Gp); Gp[toStringTagSymbol] = &quot;Generator&quot;; // A Generator should always return itself as the iterator object when the // @@iterator function is called on it. Some browsers&apos; implementations of the // iterator prototype chain incorrectly implement this, causing the Generator // object to not be returned from this call. This ensures that doesn&apos;t happen. // See https://github.com/facebook/regenerator/issues/274 for more details. Gp[iteratorSymbol] = function() &#123; return this; &#125;; Gp.toString = function() &#123; return &quot;[object Generator]&quot;; &#125;; function pushTryEntry(locs) &#123; var entry = &#123; tryLoc: locs[0] &#125;; if (1 in locs) &#123; entry.catchLoc = locs[1]; &#125; if (2 in locs) &#123; entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; &#125; this.tryEntries.push(entry); &#125; function resetTryEntry(entry) &#123; var record = entry.completion || &#123;&#125;; record.type = &quot;normal&quot;; delete record.arg; entry.completion = record; &#125; function Context(tryLocsList) &#123; // The root entry object (effectively a try statement without a catch // or a finally block) gives us a place to store values thrown from // locations where there is no enclosing try statement. this.tryEntries = [&#123; tryLoc: &quot;root&quot; &#125;]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); &#125; runtime.keys = function(object) &#123; var keys = []; for (var key in object) &#123; keys.push(key); &#125; keys.reverse(); // Rather than returning an object with a next method, we keep // things simple and return the next function itself. return function next() &#123; while (keys.length) &#123; var key = keys.pop(); if (key in object) &#123; next.value = key; next.done = false; return next; &#125; &#125; // To avoid creating an additional object, we just hang the .value // and .done properties off the next function object itself. This // also ensures that the minifier will not anonymize the function. next.done = true; return next; &#125;; &#125;; function values(iterable) &#123; if (iterable) &#123; var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) &#123; return iteratorMethod.call(iterable); &#125; if (typeof iterable.next === &quot;function&quot;) &#123; return iterable; &#125; if (!isNaN(iterable.length)) &#123; var i = -1, next = function next() &#123; while (++i &lt; iterable.length) &#123; if (hasOwn.call(iterable, i)) &#123; next.value = iterable[i]; next.done = false; return next; &#125; &#125; next.value = undefined; next.done = true; return next; &#125;; return next.next = next; &#125; &#125; // Return an iterator with no values. return &#123; next: doneResult &#125;; &#125; runtime.values = values; function doneResult() &#123; return &#123; value: undefined, done: true &#125;; &#125; Context.prototype = &#123; constructor: Context, reset: function(skipTempReset) &#123; this.prev = 0; this.next = 0; // Resetting context._sent for legacy support of Babel&apos;s // function.sent implementation. this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = &quot;next&quot;; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) &#123; for (var name in this) &#123; // Not sure about the optimal order of these conditions: if (name.charAt(0) === &quot;t&quot; &amp;&amp; hasOwn.call(this, name) &amp;&amp; !isNaN(+name.slice(1))) &#123; this[name] = undefined; &#125; &#125; &#125; &#125;, stop: function() &#123; this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === &quot;throw&quot;) &#123; throw rootRecord.arg; &#125; return this.rval; &#125;, dispatchException: function(exception) &#123; if (this.done) &#123; throw exception; &#125; var context = this; function handle(loc, caught) &#123; record.type = &quot;throw&quot;; record.arg = exception; context.next = loc; if (caught) &#123; // If the dispatched exception was caught by a catch block, // then let that catch block handle the exception normally. context.method = &quot;next&quot;; context.arg = undefined; &#125; return !! caught; &#125; for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123; var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === &quot;root&quot;) &#123; // Exception thrown outside of any try block that could handle // it, so set the completion value of the entire function to // throw the exception. return handle(&quot;end&quot;); &#125; if (entry.tryLoc &lt;= this.prev) &#123; var hasCatch = hasOwn.call(entry, &quot;catchLoc&quot;); var hasFinally = hasOwn.call(entry, &quot;finallyLoc&quot;); if (hasCatch &amp;&amp; hasFinally) &#123; if (this.prev &lt; entry.catchLoc) &#123; return handle(entry.catchLoc, true); &#125; else if (this.prev &lt; entry.finallyLoc) &#123; return handle(entry.finallyLoc); &#125; &#125; else if (hasCatch) &#123; if (this.prev &lt; entry.catchLoc) &#123; return handle(entry.catchLoc, true); &#125; &#125; else if (hasFinally) &#123; if (this.prev &lt; entry.finallyLoc) &#123; return handle(entry.finallyLoc); &#125; &#125; else &#123; throw new Error(&quot;try statement without catch or finally&quot;); &#125; &#125; &#125; &#125;, abrupt: function(type, arg) &#123; for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123; var entry = this.tryEntries[i]; if (entry.tryLoc &lt;= this.prev &amp;&amp; hasOwn.call(entry, &quot;finallyLoc&quot;) &amp;&amp; this.prev &lt; entry.finallyLoc) &#123; var finallyEntry = entry; break; &#125; &#125; if (finallyEntry &amp;&amp; (type === &quot;break&quot; || type === &quot;continue&quot;) &amp;&amp; finallyEntry.tryLoc &lt;= arg &amp;&amp; arg &lt;= finallyEntry.finallyLoc) &#123; // Ignore the finally entry if control is not jumping to a // location outside the try/catch block. finallyEntry = null; &#125; var record = finallyEntry ? finallyEntry.completion : &#123;&#125;; record.type = type; record.arg = arg; if (finallyEntry) &#123; this.method = &quot;next&quot;; this.next = finallyEntry.finallyLoc; return ContinueSentinel; &#125; return this.complete(record); &#125;, complete: function(record, afterLoc) &#123; if (record.type === &quot;throw&quot;) &#123; throw record.arg; &#125; if (record.type === &quot;break&quot; || record.type === &quot;continue&quot;) &#123; this.next = record.arg; &#125; else if (record.type === &quot;return&quot;) &#123; this.rval = this.arg = record.arg; this.method = &quot;return&quot;; this.next = &quot;end&quot;; &#125; else if (record.type === &quot;normal&quot; &amp;&amp; afterLoc) &#123; this.next = afterLoc; &#125; return ContinueSentinel; &#125;, finish: function(finallyLoc) &#123; for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123; var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) &#123; this.complete(entry.completion, entry.afterLoc); resetTryEntry(entry); return ContinueSentinel; &#125; &#125; &#125;, &quot;catch&quot;: function(tryLoc) &#123; for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123; var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) &#123; var record = entry.completion; if (record.type === &quot;throw&quot;) &#123; var thrown = record.arg; resetTryEntry(entry); &#125; return thrown; &#125; &#125; // The context.catch method must only be called with a location // argument that corresponds to a known catch block. throw new Error(&quot;illegal catch attempt&quot;); &#125;, delegateYield: function(iterable, resultName, nextLoc) &#123; this.delegate = &#123; iterator: values(iterable), resultName: resultName, nextLoc: nextLoc &#125;; if (this.method === &quot;next&quot;) &#123; // Deliberately forget the last sent value so that we don&apos;t // accidentally pass it on to the delegate. this.arg = undefined; &#125; return ContinueSentinel; &#125; &#125;;&#125;)( // In sloppy mode, unbound `this` refers to the global object, fallback to // Function constructor if we&apos;re in global strict mode. That is sadly a form // of indirect eval which violates Content Security Policy. (function() &#123; return this || (typeof self === &quot;object&quot; &amp;&amp; self); &#125;)() || Function(&quot;return this&quot;)());var _marked =/*#__PURE__*/regeneratorRuntime.mark(helloWorldGenerator);function helloWorldGenerator() &#123; return regeneratorRuntime.wrap(function helloWorldGenerator$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return &apos;hello&apos;; case 2: _context.next = 4; return &apos;world&apos;; case 4: return _context.abrupt(&quot;return&quot;, &apos;ending&apos;); case 5: case &quot;end&quot;: return _context.stop(); &#125; &#125; &#125;, _marked, this);&#125;var hw = helloWorldGenerator();console.log(hw.next()); // &#123;value: &quot;hello&quot;, done: false&#125;console.log(hw.next()); // &#123;value: &quot;world&quot;, done: false&#125;console.log(hw.next()); // &#123;value: &quot;ending&quot;, done: true&#125;console.log(hw.next()); // &#123;value: undefined, done: true&#125; 总之编译后的代码还蛮复杂，我们可以从中抽离出大致的逻辑，至少让简单编译的那段代码能够跑起来。 mark 函数简单编译后的代码第一段是这样的： var _marked = /*#__PURE__*/ regeneratorRuntime.mark(helloWorldGenerator); 我们查看完整编译版本中 mark 函数的源码： runtime.mark = function(genFun) { genFun.__proto__ = GeneratorFunctionPrototype; genFun.prototype = Object.create(Gp); return genFun; }; 这其中又涉及了 GeneratorFunctionPrototype 和 Gp 变量，我们也查看下对应的代码： functionGenerator() {} functionGeneratorFunction() {} functionGeneratorFunctionPrototype() {} ... var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = &quot;GeneratorFunction&quot;; 这段代码构建了一堆看起来很复杂的关系链，其实这是参照着 ES6 规范构建的关系链:图中 +@@toStringTag:s = &#39;Generator&#39; 的就是 Gp，+@@toStringTag:s = &#39;GeneratorFunction&#39; 的就是 GeneratorFunctionPrototype。 构建关系链的目的在于判断关系的时候能够跟原生的保持一致，就比如： function* f() {} var g = f(); console.log(g.__proto__ === f.prototype); // trueconsole.log(g.__proto__.__proto__ === f.__proto__.prototype); // true 为了简化起见，我们可以把 Gp 先设置为一个空对象，不过正如你在上图中看到的，next()、 throw()、return() 函数都是挂载在 Gp 对象上，实际上，在完整的编译代码中，确实有为 Gp 添加这三个函数的方法： // 117 行functiondefineIteratorMethods(prototype) { [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) { prototype[method] = function(arg) { returnthis._invoke(method, arg); }; }); } // 406 行 defineIteratorMethods(Gp); 为了简单起见，我们将整个 mark 函数简化为： runtime.mark = function(genFun) { var generator = Object.create({ next: function(arg) { returnthis._invoke(&apos;next&apos;, arg) } }); genFun.prototype = generator; return genFun; }; wrap 函数除了设置关系链之外，mark 函数的返回值 genFun 还作为了 wrap 函数的第二个参数传入： functionhelloWorldGenerator() { return regeneratorRuntime.wrap( functionhelloWorldGenerator$(_context) { ... }, _marked, this ); } 我们再看下 wrap 函数： functionwrap(innerFn, outerFn, self) { var generator = Object.create(outerFn.prototype); var context = new Context([]); generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } 所以当执行 var hw = helloWorldGenerator(); 的时候，其实执行的是 wrap 函数，wrap 函数返回了 generator，generator 是一个对象，原型是 outerFn.prototype, outerFn.prototype 其实就是 genFun.prototype， genFun.prototype 是一个空对象，原型上有 next() 方法。 所以当你执行 hw.next() 的时候，执行的其实是 hw 原型的原型上的 next 函数，next 函数执行的又是 hw 的 _invoke 函数： generator._invoke = makeInvokeMethod(innerFn, self, context); innerFn 就是 wrap 包裹的那个函数，其实就是 helloWordGenerato$ 函数，呐，就是这个函数： functionhelloWorldGenerator$(_context) { while (1) { switch ((_context.prev = _context.next)) { case0: _context.next = 2; return&quot;hello&quot;; case2: _context.next = 4; return&quot;world&quot;; case4: return _context.abrupt(&quot;return&quot;, &quot;ending&quot;); case5: case&quot;end&quot;: return _context.stop(); } } } 而 context 你可以直接理解为这样一个全局对象： var ContinueSentinel = {}; var context = { done: false, method: &quot;next&quot;, next: 0, prev: 0, abrupt: function(type, arg) { var record = {}; record.type = type; record.arg = arg; returnthis.complete(record); }, complete: function(record, afterLoc) { if (record.type === &quot;return&quot;) { this.rval = this.arg = record.arg; this.method = &quot;return&quot;; this.next = &quot;end&quot;; } return ContinueSentinel; }, stop: function() { this.done = true; returnthis.rval; } }; 每次 hw.next 的时候，就会修改 next 和 prev 属性的值，当在 generator 函数中 return 的时候会执行 abrupt，abrupt 中又会执行 complete，执行完 complete，因为 this.next = end 的缘故，再执行就会执行 stop 函数。 我们来看下 makeInvokeMethod 函数： var ContinueSentinel = {}; functionmakeInvokeMethod(innerFn, self, context) { var state = &apos;start&apos;; returnfunctioninvoke(method, arg) { if (state === &apos;completed&apos;) { return { value: undefined, done: true }; } context.method = method; context.arg = arg; while (true) { state = &apos;executing&apos;; var record = { type: &apos;normal&apos;, arg: innerFn.call(self, context) }; if (record.type === &quot;normal&quot;) { state = context.done ? &apos;completed&apos; : &apos;yield&apos;; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } } }; } 基本的执行过程就不分析了，我们重点看第三次执行 hw.next() 的时候: 第三次执行 hw.next() 的时候，其实执行了 this._invoke(&quot;next&quot;, undefined); 我们在 invoke 函数中构建了一个 record 对象： var record = { type: &quot;normal&quot;, arg: innerFn.call(self, context) }; 而在 innerFn.call(self, context) 中，因为 _context.next 为 4 的缘故，其实执行了: _context.abrupt(&quot;return&quot;, &apos;ending&apos;); 而在 abrupt 中，我们又构建了一个 record 对象： var record = {}; record.type = &apos;return&apos;; record.arg = &apos;ending&apos;; 然后执行了 this.complete(record)， 在 complete 中，因为 record.type === &quot;return&quot; this.rval = &apos;ending&apos;; this.method = &quot;return&quot;; this.next = &quot;end&quot;; 然后返回了全局对象 ContinueSentinel，其实就是一个全局空对象。 然后在 invoke 函数中，因为 record.arg === ContinueSentinel 的缘故，没有执行后面的 return 语句，就直接进入下一个循环。 于是又执行了一遍 innerFn.call(self, context)，此时 _context.next 为 end, 执行了 _context.stop(), 在 stop 函数中： this.done = true; returnthis.rval; // this.rval 其实就是 `ending` 所以最终返回的值为: { value: &apos;ending&apos;, done: true }; 之后，我们再执行 hw.next() 的时候，因为 state 已经是 ‘completed’ 的缘故，直接就返回 { value: undefined, done: true} 不完整但可用的源码当然这个过程，看文字理解起来可能有些难度，不完整但可用的代码如下，你可以断点调试查看具体的过程： (function() { var ContinueSentinel = {}; var mark = function(genFun) { var generator = Object.create({ next: function(arg) { returnthis._invoke(&quot;next&quot;, arg); } }); genFun.prototype = generator; return genFun; }; functionwrap(innerFn, outerFn, self) { var generator = Object.create(outerFn.prototype); var context = { done: false, method: &quot;next&quot;, next: 0, prev: 0, abrupt: function(type, arg) { var record = {}; record.type = type; record.arg = arg; returnthis.complete(record); }, complete: function(record, afterLoc) { if (record.type === &quot;return&quot;) { this.rval = this.arg = record.arg; this.method = &quot;return&quot;; this.next = &quot;end&quot;; } return ContinueSentinel; }, stop: function() { this.done = true; returnthis.rval; } }; generator._invoke = makeInvokeMethod(innerFn, context); return generator; } functionmakeInvokeMethod(innerFn, context) { var state = &quot;start&quot;; returnfunctioninvoke(method, arg) { if (state === &quot;completed&quot;) { return { value: undefined, done: true }; } context.method = method; context.arg = arg; while (true) { state = &quot;executing&quot;; var record = { type: &quot;normal&quot;, arg: innerFn.call(self, context) }; if (record.type === &quot;normal&quot;) { state = context.done ? &quot;completed&quot; : &quot;yield&quot;; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } } }; } window.regeneratorRuntime = {}; regeneratorRuntime.wrap = wrap; regeneratorRuntime.mark = mark; })(); var _marked = regeneratorRuntime.mark(helloWorldGenerator); functionhelloWorldGenerator() { return regeneratorRuntime.wrap( functionhelloWorldGenerator$(_context) { while (1) { switch ((_context.prev = _context.next)) { case0: _context.next = 2; return&quot;hello&quot;; case2: _context.next = 4; return&quot;world&quot;; case4: return _context.abrupt(&quot;return&quot;, &quot;ending&quot;); case5: case&quot;end&quot;: return _context.stop(); } } }, _marked, this ); } var hw = helloWorldGenerator(); console.log(hw.next()); console.log(hw.next()); console.log(hw.next()); console.log(hw.next());]]></content>
      <tags>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单理解async、await语法实现原理]]></title>
    <url>%2F2018%2F10%2F04%2F%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3async%E3%80%81await%E8%AF%AD%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[现在最新的前端框架生态都开始用上了Generator和yield，有的甚至已经开始使用最新的async、await语法了，这两样都是基于Generator自动执行的原理。 阮一峰 async-函数的实现原理async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。12345678910async function fn(args) &#123; // ...&#125;// 等同于function fn(args) &#123; return spawn(function* () &#123; // ... &#125;);&#125; 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。 下面给出spawn函数的实现，基本就是前文自动执行器的翻版。12345678910111213141516171819202122function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(undefined); &#125;); &#125;);&#125; DEMO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function timeout(ms) &#123; return &#123; text: &apos;done&apos; &#125; &#125; function* start() &#123; const res = yield timeout(1000); return res; &#125;; function fn(args) &#123; return spawn(start); &#125; function spawn(genF) &#123; return new Promise(function(resolve, reject) &#123; const gen = genF(); function step(nextF) &#123; let next; try &#123; next = nextF(); &#125; catch(e) &#123; return reject(e); &#125; if(next.done) &#123; return resolve(next.value); &#125; Promise.resolve(next.value).then(function(v) &#123; step(function() &#123; return gen.next(v); &#125;); &#125;, function(e) &#123; step(function() &#123; return gen.throw(e); &#125;); &#125;); &#125; step(function() &#123; return gen.next(); &#125;); &#125;); &#125; fn().then((data)=&gt;&#123; console.log(data) &#125;) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 看下babel转换后的1234async function fns(args) &#123; const res = await fetch(&apos;google.com&apos;); return res.text(); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&apos;use strict&apos;; var fns = function() &#123; var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(args) &#123; var res; return regeneratorRuntime.wrap(function _callee$(_context) &#123; while(1) &#123; switch(_context.prev = _context.next) &#123; case 0: _context.next = 2; return fetch(&apos;google.com&apos;); case 2: res = _context.sent; return _context.abrupt(&apos;return&apos;, res.text()); case 4: case&apos;end&apos;: return _context.stop(); &#125; &#125; &#125;, _callee, this); &#125;)); returnfunction fns(_x) &#123; return _ref.apply(this, arguments); &#125;; &#125;(); function _asyncToGenerator(fn) &#123; //Generator函数自动执行 returnfunction() &#123; var gen = fn.apply(this, arguments); return new Promise(function(resolve, reject) &#123; function step(key, arg) &#123; try &#123; var info = gen[key](arg); var value = info.value; &#125; catch(error) &#123; reject(error); return; &#125; if(info.done) &#123; resolve(value); &#125; else &#123; return Promise.resolve(value).then(function(value) &#123; step(&quot;next&quot;, value); &#125;, function(err) &#123; step(&quot;throw&quot;, err); &#125;); &#125; &#125; return step(&quot;next&quot;); &#125;); &#125;; &#125; 一、thunk函数thunk函数指的是能将执行结果传入回调函数，并将该回调函数返回的函数。是不是有点抽象，举个例子:12345var readFile = function (fileName) &#123; returnfunction (callback) &#123; return fs.readFile(fileName, callback) &#125;&#125; 下面我们来看下thunk函数怎样执行123readFile(&apos;./package.json&apos;)((err, str) =&gt; &#123; console.log(str.toString())&#125;) 问: thunk的执行比普通函数要麻烦不少，那么它有什么优势呢？ thunk函数的优势在于它能将异步操作返回结果的获取权交给thunk函数的返回值，而不是将异步操作结果传入thunk函数本身的作用域内，这点很重要，因为它能结合Generator语法让Generator函数自动执行 二、Generatores6的Generator函数，具体语法这里就不介绍了， 我们来编写一个基于thunk函数的Generator：123456let gen = function* () &#123; let r1 = yield readFile(&apos;./package.json&apos;) console.log(r1.toString()) let r2 = yield readFile(&apos;./index.js&apos;) console.log(r2.toString())&#125; 我们来手动执行一下这个Generator:1234567891011121314let g = gen()let r1 = g.next()r1.value(function (err, data) &#123; if (err) &#123; throw err &#125; let r2 = g.next(data) r2.value(function (err, data) &#123; if (err) &#123; throw err &#125; g.next(data) &#125;)&#125;) 可以注意到，在我们手动执行基于thunk函数的Generator时，有很多代码是可以复用的，没错，所谓的Generator自动执行就是把这些可复用的部分封装成函数，然后让它们递归执行，直到执行完所有的yield。 三、Generator自动执行器下面就是Generator自动执行的核心代码1234567891011function run(fn) &#123; let gen = fn() function next(err, data) &#123; let result = gen.next(data) if (result.done) &#123; return &#125; result.value(next) &#125; next()&#125; 可以看到无非就是把可复用的部分封装成next函数，然后让其递归执行，直到执行完所有的yield 其调用代码为:1run(gen) 这样就将原本繁杂的异步操作封装的十分简单了 基于Promise的Generator的自动执行上面的例子是基于thunk函数的，而即将出现的es7的async、await语法是基于Promise的 这里再上一个基于Promise的Generator的自动执行123456789101112131415161718192021222324252627282930313233343536//包装返回Promise对象的函数functionreadFile(fileName) &#123; return new Promise((resolve, reject) =&gt; &#123; fs.readFile(fileName, (error, data) =&gt; &#123; if (error) &#123; reject(error) &#125; else &#123; resolve(data) &#125; &#125;) &#125;)&#125; // 编写Generatorlet gen = function* () &#123; let r1 = yield readFile(&apos;./package.json&apos;) console.log(r1.toString()) let r2 = yield readFile(&apos;./index.js&apos;) console.log(r2.toString())&#125;// 编写Generator执行器function run(gen) &#123; let g = gen() function next(data) &#123; let result = g.next(data) if (result.done) &#123; return result.value &#125; result.value.then((data) =&gt; next(data)) &#125; next()&#125;//用Generator执行器自动执行run(gen) 这个和基于thunk函数的大同小异，只是把函数返回值的获取权以Promise的方式交出 参考 简单理解Generator自执行及async、await语法原理]]></content>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6之 Generator 的惰性执行]]></title>
    <url>%2F2018%2F10%2F04%2FES6%E4%B9%8B-Generator-%E7%9A%84%E6%83%B0%E6%80%A7%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[单个异步任务var fetch = require(&apos;node-fetch&apos;); function* gen(){ var url = &apos;https://api.github.com/users/github&apos;; var result = yield fetch(url); console.log(result.bio); } 为了获得最终的执行结果，你需要这样做： var g = gen(); var result = g.next(); result.value.then(function(data){ return data.json(); }).then(function(data){ g.next(data); }); 首先执行 Generator 函数，获取遍历器对象。 然后使用 next 方法，执行异步任务的第一阶段，即 fetch(url)。 注意，由于 fetch(url) 会返回一个 Promise 对象，所以 result 的值为： { value: Promise { &lt;pending&gt; }, done: false } 最后我们为这个 Promise 对象添加一个 then 方法，先将其返回的数据格式化(data.json())，再调用 g.next，将获得的数据传进去，由此可以执行异步任务的第二阶段，代码执行完毕。 多个异步任务上节我们只调用了一个接口，那如果我们调用了多个接口，使用了多个 yield，我们岂不是要在 then 函数中不断的嵌套下去…… 所以我们来看看执行多个异步任务的情况： var fetch = require(&apos;node-fetch&apos;); function* gen() { var r1 = yield fetch(&apos;https://api.github.com/users/github&apos;); var r2 = yield fetch(&apos;https://api.github.com/users/github/followers&apos;); var r3 = yield fetch(&apos;https://api.github.com/users/github/repos&apos;); console.log([r1.bio, r2[0].login, r3[0].full_name].join(&apos;\n&apos;)); } 为了获得最终的执行结果，你可能要写成： var g = gen(); var result1 = g.next(); result1.value.then(function(data){ return data.json(); }) .then(function(data){ return g.next(data).value; }) .then(function(data){ return data.json(); }) .then(function(data){ return g.next(data).value }) .then(function(data){ return data.json(); }) .then(function(data){ g.next(data) }); 但我知道你肯定不想写成这样…… 其实，利用递归，我们可以这样写： functionrun(gen) { var g = gen(); functionnext(data) { var result = g.next(data); if (result.done) return; result.value.then(function(data) { return data.json(); }).then(function(data) { next(data); }); } next(); } run(gen); 其中的关键就是 yield 的时候返回一个 Promise 对象，给这个 Promise 对象添加 then 方法，当异步操作成功时执行 then 中的 onFullfilled 函数，onFullfilled 函数中又去执行 g.next，从而让 Generator 继续执行，然后再返回一个 Promise，再在成功时执行 g.next，然后再返回…… 启动器函数在 run 这个启动器函数中，我们在 then 函数中将数据格式化 data.json()，但在更广泛的情况下，比如 yield 直接跟一个 Promise，而非一个 fetch 函数返回的 Promise，因为没有 json 方法，代码就会报错。所以为了更具备通用性，连同这个例子和启动器，我们修改为： var fetch = require(&apos;node-fetch&apos;); function* gen() { var r1 = yield fetch(&apos;https://api.github.com/users/github&apos;); var json1 = yield r1.json(); var r2 = yield fetch(&apos;https://api.github.com/users/github/followers&apos;); var json2 = yield r2.json(); var r3 = yield fetch(&apos;https://api.github.com/users/github/repos&apos;); var json3 = yield r3.json(); console.log([json1.bio, json2[0].login, json3[0].full_name].join(&apos;\n&apos;)); } functionrun(gen) { var g = gen(); functionnext(data) { var result = g.next(data); if (result.done) return; result.value.then(function(data) { next(data); }); } next(); } run(gen); 只要 yield 后跟着一个 Promise 对象，我们就可以利用这个 run 函数将 Generator 函数自动执行。 回调函数yield 后一定要跟着一个 Promise 对象才能保证 Generator 的自动执行吗？如果只是一个回调函数呢？我们来看个例子： 首先我们来模拟一个普通的异步请求： functionfetchData(url, cb) { setTimeout(function(){ cb({status: 200, data: url}) }, 1000) } 我们将这种函数改造成： functionfetchData(url) { returnfunction(cb){ setTimeout(function(){ cb({status: 200, data: url}) }, 1000) } } 对于这样的 Generator 函数： function* gen() { var r1 = yield fetchData(&apos;https://api.github.com/users/github&apos;); var r2 = yield fetchData(&apos;https://api.github.com/users/github/followers&apos;); console.log([r1.data, r2.data].join(&apos;\n&apos;)); } 如果要获得最终的结果： var g = gen(); var r1 = g.next(); r1.value(function(data) { var r2 = g.next(data); r2.value(function(data) { g.next(data); }); }); 如果写成这样的话，我们会面临跟第一节同样的问题，那就是当使用多个 yield 时，代码会循环嵌套起来…… 同样利用递归，所以我们可以将其改造为： functionrun(gen) { var g = gen(); functionnext(data) { var result = g.next(data); if (result.done) return; result.value(next); } next(); } run(gen); run由此可以看到 Generator 函数的自动执行需要一种机制，即当异步操作有了结果，能够自动交回执行权。 而两种方法可以做到这一点。 （1）回调函数。将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权。 （2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。 在两种方法中，我们各写了一个 run 启动器函数，那我们能不能将这两种方式结合在一些，写一个通用的 run 函数呢？我们尝试一下： // 第一版functionrun(gen) { var gen = gen(); functionnext(data) { var result = gen.next(data); if (result.done) return; if (isPromise(result.value)) { result.value.then(function(data) { next(data); }); } else { result.value(next) } } next() } functionisPromise(obj) { return&apos;function&apos; == typeof obj.then; } module.exports = run; 其实实现的很简单，判断 result.value 是否是 Promise，是就添加 then 函数，不是就直接执行。 return Promise我们已经写了一个不错的启动器函数，支持 yield 后跟回调函数或者 Promise 对象。 现在有一个问题需要思考，就是我们如何获得 Generator 函数的返回值呢？又如果 Generator 函数中出现了错误，就比如 fetch 了一个不存在的接口，这个错误该如何捕获呢？ 这很容易让人想到 Promise，如果这个启动器函数返回一个 Promise，我们就可以给这个 Promise 对象添加 then 函数，当所有的异步操作执行成功后，我们执行 onFullfilled 函数，如果有任何失败，就执行 onRejected 函数。 我们写一版： // 第二版functionrun(gen) { var gen = gen(); returnnewPromise(function(resolve, reject) { functionnext(data) { try { var result = gen.next(data); } catch (e) { return reject(e); } if (result.done) { return resolve(result.value) }; var value = toPromise(result.value); value.then(function(data) { next(data); }, function(e) { reject(e) }); } next() }) } functionisPromise(obj) { return&apos;function&apos; == typeof obj.then; } functiontoPromise(obj) { if (isPromise(obj)) return obj; if (&apos;function&apos; == typeof obj) return thunkToPromise(obj); return obj; } functionthunkToPromise(fn) { returnnewPromise(function(resolve, reject) { fn(function(err, res) { if (err) return reject(err); resolve(res); }); }); } module.exports = run; 与第一版有很大的不同： 首先，我们返回了一个 Promise，当 result.done 为 true 的时候，我们将该值 resolve(result.value)，如果执行的过程中出现错误，被 catch 住，我们会将原因 reject(e)。 其次，我们会使用 thunkToPromise 将回调函数包装成一个 Promise，然后统一的添加 then 函数。在这里值得注意的是，在 thunkToPromise 函数中，我们遵循了 error first 的原则，这意味着当我们处理回调函数的情况时： // 模拟数据请求functionfetchData(url) { returnfunction(cb) { setTimeout(function() { cb(null, { status: 200, data: url }) }, 1000) } } 在成功时，第一个参数应该返回 null，表示没有错误原因。 优化我们在第二版的基础上将代码写的更加简洁优雅一点，最终的代码如下： // 第三版functionrun(gen) { returnnewPromise(function(resolve, reject) { if (typeof gen == &apos;function&apos;) gen = gen(); // 如果 gen 不是一个迭代器if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen) onFulfilled(); functiononFulfilled(res) { var ret; try { ret = gen.next(res); } catch (e) { return reject(e); } next(ret); } functiononRejected(err) { var ret; try { ret = gen.throw(err); } catch (e) { return reject(e); } next(ret); } functionnext(ret) { if (ret.done) return resolve(ret.value); var value = toPromise(ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected(newTypeError(&apos;You may only yield a function, promise &apos; + &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;)); } }) } functionisPromise(obj) { return&apos;function&apos; == typeof obj.then; } functiontoPromise(obj) { if (isPromise(obj)) return obj; if (&apos;function&apos; == typeof obj) return thunkToPromise(obj); return obj; } functionthunkToPromise(fn) { returnnewPromise(function(resolve, reject) { fn(function(err, res) { if (err) return reject(err); resolve(res); }); }); } module.exports = run; co如果我们再将这个启动器函数写的完善一些，我们就相当于写了一个 co，实际上，上面的代码确实是来自于 co…… 而 co 是什么？ co 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。 如果直接使用 co 模块，这两种不同的例子可以简写为： // yield 后是一个 Promisevar fetch = require(&apos;node-fetch&apos;); var co = require(&apos;co&apos;); function* gen() { var r1 = yield fetch(&apos;https://api.github.com/users/github&apos;); var json1 = yield r1.json(); var r2 = yield fetch(&apos;https://api.github.com/users/github/followers&apos;); var json2 = yield r2.json(); var r3 = yield fetch(&apos;https://api.github.com/users/github/repos&apos;); var json3 = yield r3.json(); console.log([json1.bio, json2[0].login, json3[0].full_name].join(&apos;\n&apos;)); } co(gen); // yield 后是一个回调函数var co = require(&apos;co&apos;); functionfetchData(url) { returnfunction(cb) { setTimeout(function() { cb(null, { status: 200, data: url }) }, 1000) } } function* gen() { var r1 = yield fetchData(&apos;https://api.github.com/users/github&apos;); var r2 = yield fetchData(&apos;https://api.github.com/users/github/followers&apos;); console.log([r1.data, r2.data].join(&apos;\n&apos;)); } co(gen); 是不是特别的好用？ ES6 系列ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。 如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue超简洁双日历组件]]></title>
    <url>%2F2018%2F10%2F04%2Fvue%E8%B6%85%E7%AE%80%E6%B4%81%E5%8F%8C%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[看了那么多的日历组件，没有一个满意的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div&gt; &lt;!--&lt;div class=&quot;hide&quot;&gt; &lt;mcalendar :child=&quot;date0&quot;&gt;&lt;/mcalendar&gt; &lt;mcalendar :child=&quot;date1&quot;&gt;&lt;/mcalendar&gt; &lt;/div&gt;--&gt; &lt;div&gt; &lt;mdatapick :child=&apos;mdatapickdata&apos; @cllback=&quot;callback&quot;&gt;&lt;/mdatapick&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &apos;@/assets/css/reset.less&apos; import mcalendar from &apos;./mdata&apos; import mdatapick from &apos;./mdatapick&apos; export default &#123; data() &#123; return &#123; // date0: &#123; // now: &quot;2018-09-05&quot;, // end: &quot;2018-09-28&quot;, // callback: function(d) &#123; // console.log(d); // &#125; // &#125;, // date1: &#123; // now: &quot;2018-11-25&quot;, // start: &quot;2018-11-05&quot;, // callback: function(d) &#123; // console.log(d); // &#125; // &#125;, mdatapickdata: &#123; start: &quot;2018-09-29&quot;, end: &quot;2018-10-18&quot; &#125; &#125; &#125;, methods: &#123; callback(startDate, endDate) &#123; this.mdatapickdata.start=startDate; this.mdatapickdata.end=endDate; &#125; &#125;, components: &#123; mcalendar, mdatapick &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409&lt;template&gt; &lt;div class=&quot;m_calender&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;date_input&quot; readonly=&quot;readonly&quot; v-model=&quot;dataMsg&quot; @click=&quot;toggleShow&quot;&gt; &lt;div class=&quot;datamain&quot; v-if=&quot;open&quot;&gt; &lt;div class=&quot;datacon&quot;&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;date_main&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;time&quot;&gt;开始日期&lt;/div&gt; &lt;div class=&quot;timenum&quot;&gt;&#123;&#123;start&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;date_top&quot;&gt; &lt;em class=&quot;prev_month hoverhands&quot; @click=&quot;prev(&apos;start&apos;)&quot;&gt;&lt;/em&gt; &lt;p&gt; &lt;span class=&quot;top_month&quot;&gt;&#123;&#123;getMonthText(startMonth)&#125;&#125;&lt;/span&gt; &lt;span class=&quot;top_year&quot;&gt;&#123;&#123;startYear&#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;em v-if=&quot;startNext&quot; class=&quot;next_month hoverhands&quot; @click=&quot;next(&apos;start&apos;)&quot;&gt;&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;date_week&quot;&gt; &lt;em&gt;周日&lt;/em&gt; &lt;em&gt;周一&lt;/em&gt; &lt;em&gt;周二&lt;/em&gt; &lt;em&gt;周三&lt;/em&gt; &lt;em&gt;周四&lt;/em&gt; &lt;em&gt;周五&lt;/em&gt; &lt;em&gt;周六&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;date_day&quot;&gt; &lt;em v-for=&quot;s in startlist&quot; :class=&quot;s.className&quot; @click=&quot;clickDate(s,&apos;start&apos;)&quot;&gt;&#123;&#123; s.num &#125;&#125;&lt;/em&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;date_main&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;div class=&quot;time&quot;&gt;结束日期&lt;/div&gt; &lt;div class=&quot;timenum&quot;&gt;&#123;&#123;end&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;date_top&quot;&gt; &lt;em v-if=&quot;endPrev&quot; class=&quot;prev_month hoverhands&quot; @click=&quot;prev(&apos;end&apos;)&quot;&gt;&lt;/em&gt; &lt;p&gt; &lt;span class=&quot;top_month&quot;&gt;&#123;&#123;getMonthText(endMonth)&#125;&#125;&lt;/span&gt; &lt;span class=&quot;top_year&quot;&gt;&#123;&#123;endYear&#125;&#125;&lt;/span&gt; &lt;/p&gt; &lt;em class=&quot;next_month hoverhands&quot; @click=&quot;next(&apos;end&apos;)&quot;&gt;&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;date_week&quot;&gt; &lt;em&gt;周日&lt;/em&gt; &lt;em&gt;周一&lt;/em&gt; &lt;em&gt;周二&lt;/em&gt; &lt;em&gt;周三&lt;/em&gt; &lt;em&gt;周四&lt;/em&gt; &lt;em&gt;周五&lt;/em&gt; &lt;em&gt;周六&lt;/em&gt; &lt;/div&gt; &lt;div class=&quot;date_day&quot;&gt; &lt;em v-for=&quot;s in endlist&quot; :class=&quot;s.className&quot; @click=&quot;clickDate(s,&apos;end&apos;)&quot;&gt;&#123;&#123; s.num &#125;&#125;&lt;/em&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;databtn&quot;&gt; &lt;div class=&quot;btn hoverhands&quot; @click=&quot;toggleShow&quot;&gt;取消&lt;/div&gt; &lt;div class=&quot;btn active hoverhands&quot; @click=&quot;Determine&quot;&gt;确定&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: [&quot;child&quot;], data: function() &#123; return &#123; open: false, start: this.child.start, startYear: &apos;&apos;, startMonth: &apos;&apos;, startFirstWeek: &apos;&apos;, startDaySum: &apos;&apos;, startlist: [], startNext:true, end: this.child.end, endYear: &apos;&apos;, endMonth: &apos;&apos;, endFirstWeek: &apos;&apos;, endDaySum: &apos;&apos;, endlist: [], endPrev:true &#125; &#125;, computed: &#123; activeStartData() &#123; return new Date(this.start).getTime(); &#125;, activeEndData() &#123; return new Date(this.end).getTime(); &#125;, dataMsg() &#123; if(this.child) &#123; return `$&#123;this.child.start&#125; ~ $&#123;this.child.end&#125;` &#125; &#125;, check(tag) &#123; var startTime = new Date(`$&#123;this.startYear&#125;-$&#123;this.checkVal(this.startMonth)&#125;-01`).getTime(); var endTime = new Date(`$&#123;this.endYear&#125;-$&#123;this.checkVal(this.endMonth)&#125;-01`).getTime(); if(endTime &lt;= startTime) &#123; return false; &#125; return true; &#125; &#125;, mounted() &#123; var startDate = new Date(this.start); this.startYear = startDate.getFullYear(); this.startMonth = startDate.getMonth() + 1; var endDate = new Date(this.end); this.endYear = endDate.getFullYear(); this.endMonth = endDate.getMonth() + 1; this.init(); &#125;, methods: &#123; toggleShow() &#123; this.open = !this.open; &#125;, init() &#123; this.startFirstWeek = new Date(`$&#123;this.startYear&#125;-$&#123;this.checkVal(this.startMonth)&#125;-01`).getDay(); this.startDaySum = this.getMonthDaySum(`$&#123;this.startYear&#125;-$&#123;this.checkVal(this.startMonth)&#125;-01`); this.startlist = this.initDate(this.startFirstWeek, this.startDaySum, this.startYear, this.startMonth, this.activeStartData); this.endFirstWeek = new Date(`$&#123;this.endYear&#125;-$&#123;this.checkVal(this.endMonth)&#125;-01`).getDay(); this.endDaySum = this.getMonthDaySum(`$&#123;this.endYear&#125;-$&#123;this.checkVal(this.endMonth)&#125;-1`); this.endlist = this.initDate(this.endFirstWeek, this.endDaySum, this.endYear, this.endMonth, this.activeEndData) &#125;, prev(tag) &#123; if(tag == &apos;end&apos;) &#123; if(!this.check) &#123; return false; &#125; &#125; this[tag + &apos;Month&apos;]--; if(!this[tag + &apos;Month&apos;]) &#123; this[tag + &apos;Month&apos;] = 12; this[tag + &apos;Year&apos;]--; &#125; this.$nextTick(() =&gt; &#123; this.init(); &#125;) &#125;, next(tag) &#123; if(tag == &apos;start&apos;) &#123; if(!this.check) &#123; return false; &#125; &#125; this[tag + &apos;Month&apos;]++; if(this[tag + &apos;Month&apos;] &gt; 12) &#123; this[tag + &apos;Month&apos;] = 1; this[tag + &apos;Year&apos;]++; &#125; this.$nextTick(() =&gt; &#123; this.init(); &#125;) &#125;, getMonthDaySum(val) &#123; //获取当前月有多少天 var curDate = new Date(val); var curMonth = curDate.getMonth(); curDate.setMonth(curMonth + 1); curDate.setDate(0); return curDate.getDate(); &#125;, initDate(FirstWeek, DaySum, Year, Month, activeData) &#123; var list = []; for(var i = 1; i &lt;= FirstWeek; i++) &#123; var Dates = new Date(`$&#123;Year&#125;-$&#123;this.checkVal(Month)&#125;-01`); Dates.setDate(i - FirstWeek); list.push(&#123; &quot;className&quot;: &quot;disabled&quot;, &quot;num&quot;: Dates.getDate(), &quot;date&quot;: `$&#123;Year&#125;-$&#123;this.checkVal(Month-1)&#125;-$&#123;Dates.getDate()&#125;` &#125;) &#125; for(var i = 1; i &lt;= DaySum; i++) &#123; var isActive = new Date(`$&#123;Year&#125;-$&#123;this.checkVal(Month)&#125;-$&#123;this.checkVal(i)&#125;`).getTime() == activeData; list.push(&#123; &quot;className&quot;: isActive ? &apos;on&apos; : &apos;&apos;, &quot;num&quot;: i, &quot;date&quot;: `$&#123;Year&#125;-$&#123;this.checkVal(Month)&#125;-$&#123;this.checkVal(i)&#125;` &#125;) &#125; var nextData = new Date(`$&#123;Year&#125;-$&#123;this.checkVal(Month)&#125;-$&#123;DaySum&#125;`).getDay(); for(var i = 1; i &lt;= 6 - nextData; i++) &#123; list.push(&#123; &quot;className&quot;: &quot;disabled&quot;, &quot;num&quot;: i, &quot;date&quot;: `$&#123;Year&#125;-$&#123;this.checkVal(Month+1)&#125;-$&#123;this.checkVal(i)&#125;` &#125;) &#125; return list; &#125;, checkVal(num) &#123; num = +num; return +num &lt; 10 ? &quot;0&quot; + num : &apos;&apos; + num; &#125;, clickDate(val, tag) &#123; if(val.className !== &apos;disabled&apos;) &#123; this[tag] = val.date; this.$nextTick(() =&gt; &#123; this.init(); &#125;) &#125; &#125;, Determine() &#123; this.toggleShow(); this.$emit(&quot;cllback&quot;, this.start, this.end) &#125;, getMonthText(m) &#123; return [&apos;&apos;, &apos;一月&apos;, &apos;二月&apos;, &apos;三月&apos;, &apos;四月&apos;, &apos;五月&apos;, &apos;六月&apos;, &apos;七月&apos;, &apos;八月&apos;, &apos;九月&apos;, &apos;十月&apos;, &apos;十一月&apos;, &apos;十二月&apos;][m] &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt; .m_calender &#123; position: relative; display: block; margin: 0 auto; .date_input &#123; margin: 0 auto; width: 200px; border: 1px solid red; text-align: center; height: 20px; line-height: 20px; cursor: pointer; display: block; color: #484848; font-size: 12px; &#125; .datamain &#123; border: 1px solid #E6E6E6; position: absolute; left: 50%; top: 30px; transform: translateX(-50%); &amp;::before &#123; content: &apos;&apos;; position: absolute; left: 50%; transform: translateX(-50%); top: -18px; width: 0; height: 0; border-top: 9px solid rgba(0, 0, 0, 0); border-right: 9px solid rgba(0, 0, 0, 0); border-bottom: 9px solid #E6E6E6; border-left: 9px solid rgba(0, 0, 0, 0); &#125; &amp;::after &#123; content: &apos;&apos;; position: absolute; left: 50%; transform: translateX(-50%); top: -15px; width: 0; height: 0; border-top: 8px solid rgba(0, 0, 0, 0); border-right: 8px solid rgba(0, 0, 0, 0); border-bottom: 8px solid white; border-left: 8px solid rgba(0, 0, 0, 0); &#125; .datacon &#123; display: flex; .con &#123; margin: 5px 10px; .date_main &#123; width: 232px; background: #FFFFFF; z-index: 20; .title &#123; padding: 8px 4px; display: flex; justify-content: space-between; align-items: center; font-size: 14px; .time &#123; color: #939393; &#125; .timenum &#123; color: #333333; &#125; &#125; .date_top &#123; height: 28px; line-height: 28px; padding: 0 6px; display: flex; justify-content: space-around; align-items: center; em &#123; width: 14px; font-style: normal; margin: 9px 4px; &amp;.prev_month &#123; width: 0px; height: 0px; border-top: 7px solid rgba(0, 0, 0, 0); border-bottom: 7px solid rgba(0, 0, 0, 0); border-right: 7px solid #A1A1A1; border-left: 7px solid rgba(0, 0, 0, 0); &#125; &amp;.next_month &#123; width: 0px; height: 0px; border-top: 7px solid rgba(0, 0, 0, 0); border-bottom: 7px solid rgba(0, 0, 0, 0); border-left: 7px solid #A1A1A1; border-right: 7px solid rgba(0, 0, 0, 0); &#125; &#125; p &#123; width: 100px; flex: 1; font-size: 12px; font-weight: 700; text-align: center; span &#123; width: 40px; display: inline-block; text-align: center; &#125; &#125; &#125; .date_week &#123; height: 24px; em &#123; box-sizing: border-box; font-style: normal; width: 33px; height: 24px; line-height: 24px; display: block; float: left; color: #484848; font-size: 12px; text-align: center; &#125; &#125; .date_day &#123; overflow: hidden; border: 1px solid #E6E6E6; em &#123; font-style: normal; width: 32px; height: 20px; line-height: 20px; display: block; float: left; color: #484848; font-size: 12px; text-align: center; border-right: 1px solid #E6E6E6; cursor: pointer; &amp;:nth-child(7n) &#123; border-right: 0px solid #E6E6E6; &#125; &amp;.on &#123; color: #FFFFFF; background-color: #E76E00; &#125; &amp;.disabled &#123; color: #CCCCCC; background-color: #FFFFFF; cursor: default; &#125; &#125; &#125; &#125; &#125; &#125; .databtn &#123; text-align: right; display: flex; justify-content: flex-end; align-items: center; padding: 5px 0px 11px; .btn &#123; display: flex; justify-content: center; align-items: center; box-sizing: border-box; width: 56px; height: 24px; border: 1px solid red; font-size: 12px; border: 1px solid #E6E6E6; border-radius: 2px; &amp;.active &#123; color: wheat; margin: 0px 8px; background: #EE6E25; &#125; &#125; &#125; &#125; &#125;&lt;/style&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript核武库]]></title>
    <url>%2F2018%2F10%2F04%2FJavaScript%E6%A0%B8%E6%AD%A6%E5%BA%93%2F</url>
    <content type="text"><![CDATA[以下是个人总结，也有一些是copy大神的，现在放到一起，方便以后查阅（有不对的地方，还望大家能够提出，我会尽快加以改正）。 !!强制转boolean根据真值，假值 判断，返回true，false假值： 0 “” null undefined false NaN 例如： var nu=null; var nul=&quot;&quot;; var str=&quot;abcd&quot;; console.log(!!nu) // false; console.log(!!nul) // false; console.log(!!str) // true; +obj 强制转Number 将对象强制转number,如果是纯数字的“88”字符串，可转为number var a=&quot;88&quot;; console.log(+a) =&gt;88 //但是如果是混合类型的字符串，则会转为NaN var b=&quot;1606e&quot;; console.log(+b) =&gt; NaN ~~ 强制取整~~ 12.34 12 ~~ 12.88 12 不可靠的undefined 可靠的void 0在JavaScript中，假设我们想判断一个是否是 undefined，那么我们通常会这样写： if(a === undefined){ dosomething } //但是在javascript中，undefined是不可靠的 例如：当undefined在函数内，并且是在局部变量是可以赋上值 function foo2(){ var undefined=1; console.log(undefined) } foo2(); =&gt;1; 但是当在函数内定义一个全局变量，并不能给赋上值 var undefined; function foo2(){ undefined=1; console.log(undefined) } foo2() // undefined void 0或者 void (0)： 最常见的用法是通过void 0 运算来获得 undefined，表达式为 0 时的运算开销最小：那在以后需要判断值为undefined的时候，可以直接用void 0或者void (0) 字符串也是有length属性的！我们知道所有的array都是有length,属性，就算事空数组，length 是0，那么字符串有没有呢？接下来我们来验证一下： var str=&quot;sdfsd5565s6dfsd65sd6+d5fd5&quot;; console.log(str.length) // 26 结果是有的，所以我们在判断类型时，不能单纯拿有没有length属性来判断是不是数组了，我们可以用下面的方法： var obj=[1,2] ; console.log(toString.call(obj) === &apos;[object Array]&apos;); 生成一个随机数组(创建数组，sort排序)在项目中有时候我们需要一个随机打乱的数组，那么下面我们来实现以下：先来创建一个数组： var arr=[]; for(var i=0;i&lt;10;i++){ arr.push(i) } console.log(arr) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 接下来我们来打乱它： arr.sort(()=&gt;{ return Math.random() - 0.5 }) // [1, 0, 2, 3, 4, 6, 8, 5, 7, 9] 第二种打乱方法： arr.sort((a,b)=&gt;{ return a&gt;Math.random()*10; }) // [1, 2, 0, 6, 4, 3, 8, 9, 7, 5] 我们以前的正常排序是这样的： arr.sort(function(a,b){ return b-a }); 解析：先说正常的排序：a,b表示数组中的任意两个元素，若return &gt; 0 b前a后；reutrn &lt; 0 a前b后；a=b时存在浏览器兼容 ，a-b输出从小到大排序，b-a输出从大到小排序。然后再说我们打乱的方法：创建数组不用说，接下来就是用js的sort方法 来实现，Math.random()实现一个随机0-1之间的小数 然后再减去0.5，这时就会根据return比较后得到的值排，所以说就会生成不是正常从大到小或者从小到大的排序。 第二个打乱的方法同样是遵循sort的方法，将a,b传进去 然后和随机数做比较，关于比较的方法不太清楚。 去除前后、前、后 所有空格 这是专门为去除空格写的一套方法，适用于各种情况，所有空格,前后空格，前空格，后空格。 var strr=” 1 ad dertasdf sdfASDFDF DFG SDFG “// type 1-所有空格 2-前后空格 3-前空格 4-后空格 function trim(str,type){ switch (type){ case 1:return str.replace(/\s+/g,&quot;&quot;); case 2:return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;); case 3:return str.replace(/(^\s*)/g, &quot;&quot;); case 4:return str.replace(/(\s*$)/g, &quot;&quot;); default:return str; } } console.log( trim(strr,1)) // &quot;1addertasdfsdfASDFDFDFGSDFG&quot; 解析： 这个方法用的是正则的匹配格式,后面我会把正则单独拿出来总结一个系列，敬请期待！！！ \s ： 空格符，Tab,换页符，换行符 \S ： 非\s的所有内容 /g : 全局匹配 ^ : 匹配在行首 $ : 匹配在行尾 + ： 重复次数&gt;0 * ： 重复次数&gt;=0 | : 或者 replace(a,b)： 方法用于在字符创中用一些字符替换另一些字符, 会传入两个值，将逗号前面的值a替换成逗号后面的值b 字母大小写切换（正则匹配，replace）这个方法主要是给一些需要大小写转换提供的方法，主要有首字母大写，首字母小写，大小写转换，全部转大写和全部转小写。 type： 1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写 原始字符串： var str=&quot;sdfwwerasfddffddeerAasdgFegqer&quot;; function changeCase(str,type) { //这个函数是第三个大小写转换的方法 function ToggleCase(str) { var itemText = &quot;&quot; str.split(&quot;&quot;).forEach( function (item) { // 判断循环字符串中每个字符是否以a-z之间开头的并且重复大于0次 if (/^([a-z]+)/.test(item)) { // 如果是小写，转换成大写 itemText += item.toUpperCase(); } // 判断循环字符串中每个字符是否以A-Z之间开头的并且重复大于0次 else if (/^([A-Z]+)/.test(item)) { // 如果是大写，转换成小写 itemText += item.toLowerCase(); } else{ // 如果都不符合，返回其本身 itemText += item; } }); return itemText; } //下面主要根据传入的type值来匹配各个场景 switch (type) { //当匹配 case 1: return str.replace(/^(\w)(\w+)/, function (v, v1, v2) { //v=验证本身 v1=s ; v2=dfwwerasfddffddeerAasdgFegqer return v1.toUpperCase() + v2.toLowerCase(); }); case 2: return str.replace(/^(\w)(\w+)/, function (v, v1, v2) { //v=验证本身 v1=s ; v2=dfwwerasfddffddeerAasdgFegqer return v1.toLowerCase() + v2.toUpperCase(); }); case 3: return ToggleCase(str); case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; } } console.log(changeCase(str,1)) =&gt;SdfwwerasfddffddeerAasdgFegqer 解析： split：用于把一个字符串分割成字符串数组 \w: 数字0-9或字母a-z及A-Z,或下划线 \W: 非\w，除以上的特殊符号等 toUpperCase：转大写 toLowerCase：转小写 replace第二个参数可以是函数，函数的参数中，第一个是本身，第二个是正则匹配内容，第三个匹配剩下的内容 下面我们就通过小实验来验证一下：网上有说replace是可以有4个参数的，但是我并没有验证到第四个代表的意义，前三个已经验证，第一个参数为验证本身，第二个正则匹配结果，第三为第二个匹配完剩下的值。 循环n次传入的字符串str为传入随意字符串，count为循环的次数var str=&quot;abc&quot;; var number=555; function repeatStr(str, count) { //声明一个空字符串，用来保存生成后的新字符串 var text = &apos;&apos;; //循环传入的count值，即循环的次数 for (var i = 0; i &lt; count; i++) { //循环一次就把字符串+到我们事先准备好的空字符串上 text += str; } return text; } console.log(repeatStr(str, 3)) // &quot;abcabcabc&quot; console.log(repeatStr(number, 3)) // &quot;555555555&quot; 解析：根据count循环的次数，在循环体内复制，return 返回+=后的值 查找字符串的A内容替换成B内容let str=&quot;abacdasdfsd&quot; function replaceAll(str,AFindText,ARepText){ raRegExp = new RegExp(AFindText,&quot;g&quot;); return str.replace(raRegExp,ARepText); } console.log(replaceAll(str,&quot;a&quot;,&quot;x&quot;)) // xbxcdxsdfsd str：需要编辑的字符串本身 AFindText:需要替换的内容 ARepText:被替换成的内容 解析：创建正则，匹配内容，替换 检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证function checkType (str, type) { switch (type) { case &apos;email&apos;: return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str); case &apos;phone&apos;: return /^1[3|4|5|7|8][0-9]{9}$/.test(str); case &apos;tel&apos;: return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str); case &apos;number&apos;: return /^[0-9]$/.test(str); case &apos;english&apos;: return /^[a-zA-Z]+$/.test(str); case &apos;chinese&apos;: return /^[\u4E00-\u9FA5]+$/.test(str); case &apos;lower&apos;: return /^[a-z]+$/.test(str); case &apos;upper&apos;: return /^[A-Z]+$/.test(str); default : return true; } } console.log(checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;)) //false 解析： checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;)&apos;需要验证的字符串&apos;，&apos;匹配的格式&apos; email：验证邮箱 phone：验证手机号 tel：验证座机号 number：验证数字 english：验证英文字母 chinese：验证中文字 lower：验证小写 upper：验证大写 JS返回浏览器历史第一页： JS返回浏览器历史第一页 我在浏览器控制台敲了 window.history 其实我想看看还有哪些API，他输出了以下信息，我看到length 这个属性让我眼前一亮，其他2个我不关心。 { length: 2, scrollRestoration: &quot;auto&quot;, state: null } 我尝试用length 去回退， 不成功！ window.history.go(-2); 我再尝试用length去减1, 成功了， 我猜应该是跟新标签页有关吧。 那我不管了，我已经有答案了 window.history.go(-1); 最后代码 var historyLen = window.history; window.history.go(-(historyLen - 1)); 测试了3个浏览器， 都是第一次打开浏览器测试 Chrome 会直接返回到新标签页 Safari 我这里测试是返回到百度，可能是我的设置问题 Firefox 直接关闭浏览器 作为战斗在业务一线的前端，要想少加班，就要想办法提高工作效率。这里提一个小点，我们在业务开发过程中，经常会重复用到日期格式化、url参数转对象、浏览器类型判断、节流函数等一类函数，这些工具类函数，基本上在每个项目都会用到，为避免不同项目多次复制粘贴的麻烦，我们可以统一封装，发布到npm，以提高开发效率。 这里，笔者已经封装并发布了自己的武器库 outils，如果你对本项目感兴趣，欢迎 star 本项目。当然你也可以在本项目的基础上封装自己的武器库。 常用函数汇总 这里先分类整理下，之前项目中多次用到的工具函数。1.Array1.1 arrayEqual/** * * @desc 判断两个数组是否相等 * @param {Array} arr1 * @param {Array} arr2 * @return {Boolean} */ function arrayEqual(arr1, arr2) { if (arr1 === arr2) return true; if (arr1.length != arr2.length) return false; for (var i = 0; i &lt; arr1.length; ++i) { if (arr1[i] !== arr2[i]) return false; } return true; } 2.Class2.1 addClass/** * * @desc 为元素添加class * @param {HTMLElement} ele * @param {String} cls */ var hasClass = require(&apos;./hasClass&apos;); function addClass(ele, cls) { if (!hasClass(ele, cls)) { ele.className += &apos; &apos; + cls; } } 2.2 hasClass /** * * @desc 判断元素是否有某个class * @param {HTMLElement} ele * @param {String} cls * @return {Boolean} */ function hasClass(ele, cls) { return (new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;)).test(ele.className); } 2.3 removeClass /** * * @desc 为元素移除class * @param {HTMLElement} ele * @param {String} cls */ var hasClass = require(&apos;./hasClass&apos;); function removeClass(ele, cls) { if (hasClass(ele, cls)) { var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;); ele.className = ele.className.replace(reg, &apos; &apos;); } } 3.Cookie3.1 getCookie/** * * @desc 根据name读取cookie * @param {String} name * @return {String} */ function getCookie(name) { var arr = document.cookie.replace(/\s/g, &quot;&quot;).split(&apos;;&apos;); for (var i = 0; i &lt; arr.length; i++) { var tempArr = arr[i].split(&apos;=&apos;); if (tempArr[0] == name) { return decodeURIComponent(tempArr[1]); } } return &apos;&apos;; } 3.2 removeCookie var setCookie = require(&apos;./setCookie&apos;); /** * * @desc 根据name删除cookie * @param {String} name */ function removeCookie(name) { // 设置已过期，系统会立刻删除cookie setCookie(name, &apos;1&apos;, -1); } 3.3 setCookie /** * * @desc 设置Cookie * @param {String} name * @param {String} value * @param {Number} days */ function setCookie(name, value, days) { var date = new Date(); date.setDate(date.getDate() + days); document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + date; } 4.Device4.1 getExplore/** * * @desc 获取浏览器类型和版本 * @return {String} */ function getExplore() { var sys = {}, ua = navigator.userAgent.toLowerCase(), s; (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]: (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] : (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] : (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] : (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] : (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] : (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0; // 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie) if (sys.edge) return (&apos;EDGE: &apos; + sys.edge) if (sys.firefox) return (&apos;Firefox: &apos; + sys.firefox) if (sys.chrome) return (&apos;Chrome: &apos; + sys.chrome) if (sys.opera) return (&apos;Opera: &apos; + sys.opera) if (sys.safari) return (&apos;Safari: &apos; + sys.safari) return &apos;Unkonwn&apos; } 4.2 getOS /** * * @desc 获取操作系统类型 * @return {String} */ function getOS() { var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;; var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;; var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;; if (/mac/i.test(appVersion)) return &apos;MacOSX&apos; if (/win/i.test(appVersion)) return &apos;windows&apos; if (/linux/i.test(appVersion)) return &apos;linux&apos; if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos; if (/android/i.test(userAgent)) return &apos;android&apos; if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos; } 5.Dom5.1 getScrollTop/** * * @desc 获取滚动条距顶部的距离 */ function getScrollTop() { return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop; } 5.2 offset /** * * @desc 获取一个元素的距离文档(document)的位置，类似jQ中的offset() * @param {HTMLElement} ele * @returns { {left: number, top: number} } */ function offset(ele) { var pos = { left: 0, top: 0 }; while (ele) { pos.left += ele.offsetLeft; pos.top += ele.offsetTop; ele = ele.offsetParent; }; return pos; } 5.3 scrollTovar getScrollTop = require(&apos;./getScrollTop&apos;); var setScrollTop = require(&apos;./setScrollTop&apos;); var requestAnimFrame = (function () { return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) { window.setTimeout(callback, 1000 / 60); }; })(); /** * * @desc 在${duration}时间内，滚动条平滑滚动到${to}指定位置 * @param {Number} to * @param {Number} duration */ function scrollTo(to, duration) { if (duration &lt; 0) { setScrollTop(to); return } var diff = to - getScrollTop(); if (diff === 0) return var step = diff / duration * 10; requestAnimationFrame( function () { if (Math.abs(step) &gt; Math.abs(diff)) { setScrollTop(getScrollTop() + diff); return; } setScrollTop(getScrollTop() + step); if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) { return; } scrollTo(to, duration - 16); }); } 5.4 setScrollTop/** * * @desc 设置滚动条距顶部的距离 */ function setScrollTop(value) { window.scrollTo(0, value); return value; } 6.Keycode6.1 getKeyNamevar keyCodeMap = { 8: &apos;Backspace&apos;, 9: &apos;Tab&apos;, 13: &apos;Enter&apos;, 16: &apos;Shift&apos;, 17: &apos;Ctrl&apos;, 18: &apos;Alt&apos;, 19: &apos;Pause&apos;, 20: &apos;Caps Lock&apos;, 27: &apos;Escape&apos;, 32: &apos;Space&apos;, 33: &apos;Page Up&apos;, 34: &apos;Page Down&apos;, 35: &apos;End&apos;, 36: &apos;Home&apos;, 37: &apos;Left&apos;, 38: &apos;Up&apos;, 39: &apos;Right&apos;, 40: &apos;Down&apos;, 42: &apos;Print Screen&apos;, 45: &apos;Insert&apos;, 46: &apos;Delete&apos;, 48: &apos;0&apos;, 49: &apos;1&apos;, 50: &apos;2&apos;, 51: &apos;3&apos;, 52: &apos;4&apos;, 53: &apos;5&apos;, 54: &apos;6&apos;, 55: &apos;7&apos;, 56: &apos;8&apos;, 57: &apos;9&apos;, 65: &apos;A&apos;, 66: &apos;B&apos;, 67: &apos;C&apos;, 68: &apos;D&apos;, 69: &apos;E&apos;, 70: &apos;F&apos;, 71: &apos;G&apos;, 72: &apos;H&apos;, 73: &apos;I&apos;, 74: &apos;J&apos;, 75: &apos;K&apos;, 76: &apos;L&apos;, 77: &apos;M&apos;, 78: &apos;N&apos;, 79: &apos;O&apos;, 80: &apos;P&apos;, 81: &apos;Q&apos;, 82: &apos;R&apos;, 83: &apos;S&apos;, 84: &apos;T&apos;, 85: &apos;U&apos;, 86: &apos;V&apos;, 87: &apos;W&apos;, 88: &apos;X&apos;, 89: &apos;Y&apos;, 90: &apos;Z&apos;, 91: &apos;Windows&apos;, 93: &apos;Right Click&apos;, 96: &apos;Numpad 0&apos;, 97: &apos;Numpad 1&apos;, 98: &apos;Numpad 2&apos;, 99: &apos;Numpad 3&apos;, 100: &apos;Numpad 4&apos;, 101: &apos;Numpad 5&apos;, 102: &apos;Numpad 6&apos;, 103: &apos;Numpad 7&apos;, 104: &apos;Numpad 8&apos;, 105: &apos;Numpad 9&apos;, 106: &apos;Numpad *&apos;, 107: &apos;Numpad +&apos;, 109: &apos;Numpad -&apos;, 110: &apos;Numpad .&apos;, 111: &apos;Numpad /&apos;, 112: &apos;F1&apos;, 113: &apos;F2&apos;, 114: &apos;F3&apos;, 115: &apos;F4&apos;, 116: &apos;F5&apos;, 117: &apos;F6&apos;, 118: &apos;F7&apos;, 119: &apos;F8&apos;, 120: &apos;F9&apos;, 121: &apos;F10&apos;, 122: &apos;F11&apos;, 123: &apos;F12&apos;, 144: &apos;Num Lock&apos;, 145: &apos;Scroll Lock&apos;, 182: &apos;My Computer&apos;, 183: &apos;My Calculator&apos;, 186: &apos;;&apos;, 187: &apos;=&apos;, 188: &apos;,&apos;, 189: &apos;-&apos;, 190: &apos;.&apos;, 191: &apos;/&apos;, 192: &apos;`&apos;, 219: &apos;[&apos;, 220: &apos;\\&apos;, 221: &apos;]&apos;, 222: &apos;\&apos;&apos; }; /** * @desc 根据keycode获得键名 * @param {Number} keycode * @return {String} */ function getKeyName(keycode) { if (keyCodeMap[keycode]) { return keyCodeMap[keycode]; } else { console.log(&apos;Unknow Key(Key Code:&apos; + keycode + &apos;)&apos;); return &apos;&apos;; } }; 7.Object7.1 deepClone/** * @desc 深拷贝，支持常见类型 * @param {Any} values */ function deepClone(values) { var copy; // Handle the 3 simple types, and null or undefined if (null == values || &quot;object&quot; != typeof values) return values; // Handle Date if (values instanceof Date) { copy = new Date(); copy.setTime(values.getTime()); return copy; } // Handle Array if (values instanceof Array) { copy = []; for (var i = 0, len = values.length; i &lt; len; i++) { copy[i] = deepClone(values[i]); } return copy; } // Handle Object if (values instanceof Object) { copy = {}; for (var attr in values) { if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]); } return copy; } throw new Error(&quot;Unable to copy values! Its type isn&apos;t supported.&quot;); } 7.2 isEmptyObject/** * * @desc 判断`obj`是否为空 * @param {Object} obj * @return {Boolean} */ function isEmptyObject(obj) { if (!obj || typeof obj !== &apos;object&apos; || Array.isArray(obj)) return false return !Object.keys(obj).length } 8.Random8.1 randomColor/** * * @desc 随机生成颜色 * @return {String} */ function randomColor() { return &apos;#&apos; + (&apos;00000&apos; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6); } 8.2 randomNum/** * * @desc 生成指定范围随机数 * @param {Number} min * @param {Number} max * @return {Number} */ function randomNum(min, max) { return Math.floor(min + Math.random() * (max - min)); } 9.Regexp9.1 isEmail/** * * @desc 判断是否为邮箱地址 * @param {String} str * @return {Boolean} */ function isEmail(str) { return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str); } 9.2 isIdCard/** * * @desc 判断是否为身份证号 * @param {String|Number} str * @return {Boolean} */ function isIdCard(str) { return /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/.test(str) } 9.3 isPhoneNum/** * * @desc 判断是否为手机号 * @param {String|Number} str * @return {Boolean} */ function isPhoneNum(str) { return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/.test(str) } 9.4 isUrl/** * * @desc 判断是否为URL地址 * @param {String} str * @return {Boolean} */ function isUrl(str) { return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str); } 10.String10.1 digitUppercase/** * * @desc 现金额转大写 * @param {Number} n * @return {String} */ function digitUppercase(n) { var fraction = [&apos;角&apos;, &apos;分&apos;]; var digit = [ &apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;, &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos; ]; var unit = [ [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;], [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;] ]; var head = n &lt; 0 ? &apos;欠&apos; : &apos;&apos;; n = Math.abs(n); var s = &apos;&apos;; for (var i = 0; i &lt; fraction.length; i++) { s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;); } s = s || &apos;整&apos;; n = Math.floor(n); for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) { var p = &apos;&apos;; for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) { p = digit[n % 10] + unit[1][j] + p; n = Math.floor(n / 10); } s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s; } return head + s.replace(/(零.)*零元/, &apos;元&apos;) .replace(/(零.)+/g, &apos;零&apos;) .replace(/^整$/, &apos;零元整&apos;); }; 11.Support11.1 isSupportWebP/** * * @desc 判断浏览器是否支持webP格式图片 * @return {Boolean} */ function isSupportWebP() { return !![].map &amp;&amp; document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0; } 12.Time12.1 formatPassTime/** * @desc 格式化${startTime}距现在的已过时间 * @param {Date} startTime * @return {String} */ function formatPassTime(startTime) { var currentTime = Date.parse(new Date()), time = currentTime - startTime, day = parseInt(time / (1000 * 60 * 60 * 24)), hour = parseInt(time / (1000 * 60 * 60)), min = parseInt(time / (1000 * 60)), month = parseInt(day / 30), year = parseInt(month / 12); if (year) return year + &quot;年前&quot; if (month) return month + &quot;个月前&quot; if (day) return day + &quot;天前&quot; if (hour) return hour + &quot;小时前&quot; if (min) return min + &quot;分钟前&quot; else return &apos;刚刚&apos; } 12.2 formatRemainTime/** * * @desc 格式化现在距${endTime}的剩余时间 * @param {Date} endTime * @return {String} */ function formatRemainTime(endTime) { var startDate = new Date(); //开始时间 var endDate = new Date(endTime); //结束时间 var t = endDate.getTime() - startDate.getTime(); //时间差 var d = 0, h = 0, m = 0, s = 0; if (t &gt;= 0) { d = Math.floor(t / 1000 / 3600 / 24); h = Math.floor(t / 1000 / 60 / 60 % 24); m = Math.floor(t / 1000 / 60 % 60); s = Math.floor(t / 1000 % 60); } return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;; } 13.Url13.1 parseQueryString/** * * @desc url参数转对象 * @param {String} url default: window.location.href * @return {Object} */ function parseQueryString(url) { url = url == null ? window.location.href : url var search = url.substring(url.lastIndexOf(&apos;?&apos;) + 1) if (!search) { return {} } return JSON.parse(&apos;{&quot;&apos; + decodeURIComponent(search).replace(/&quot;/g, &apos;\\&quot;&apos;).replace(/&amp;/g, &apos;&quot;,&quot;&apos;).replace(/=/g, &apos;&quot;:&quot;&apos;) + &apos;&quot;}&apos;) } 13.2 stringfyQueryString/** * * @desc 对象序列化 * @param {Object} obj * @return {String} */ function stringfyQueryString(obj) { if (!obj) return &apos;&apos;; var pairs = []; for (var key in obj) { var value = obj[key]; if (value instanceof Array) { for (var i = 0; i &lt; value.length; ++i) { pairs.push(encodeURIComponent(key + &apos;[&apos; + i + &apos;]&apos;) + &apos;=&apos; + encodeURIComponent(value[i])); } continue; } pairs.push(encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(obj[key])); } return pairs.join(&apos;&amp;&apos;); } 14.Function14.1 throttle/** * @desc 函数节流。 * 适用于限制`resize`和`scroll`等函数的调用频率 * * @param {Number} delay 0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。 * @param {Boolean} noTrailing 可选，默认为false。 * 如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。 * 如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次. * （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位） * @param {Function} callback 延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的， * 执行去节流功能时，调用`callback`。 * @param {Boolean} debounceMode 如果`debounceMode`为true，`clear`在`delay`ms后执行。 * 如果debounceMode是false，`callback`在`delay` ms之后执行。 * * @return {Function} 新的节流函数 */ function throttle(delay, noTrailing, callback, debounceMode) { // After wrapper has stopped being called, this timeout ensures that // `callback` is executed at the proper times in `throttle` and `end` // debounce modes. var timeoutID; // Keep track of the last time `callback` was executed. var lastExec = 0; // `noTrailing` defaults to falsy. if (typeof noTrailing !== &apos;boolean&apos;) { debounceMode = callback; callback = noTrailing; noTrailing = undefined; } // The `wrapper` function encapsulates all of the throttling / debouncing // functionality and when executed will limit the rate at which `callback` // is executed. function wrapper() { var self = this; var elapsed = Number(new Date()) - lastExec; var args = arguments; // Execute `callback` and update the `lastExec` timestamp. function exec() { lastExec = Number(new Date()); callback.apply(self, args); } // If `debounceMode` is true (at begin) this is used to clear the flag // to allow future `callback` executions. function clear() { timeoutID = undefined; } if (debounceMode &amp;&amp; !timeoutID) { // Since `wrapper` is being called for the first time and // `debounceMode` is true (at begin), execute `callback`. exec(); } // Clear any existing timeout. if (timeoutID) { clearTimeout(timeoutID); } if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) { // In throttle mode, if `delay` time has been exceeded, execute // `callback`. exec(); } else if (noTrailing !== true) { // In trailing throttle mode, since `delay` time has not been // exceeded, schedule `callback` to execute `delay` ms after most // recent execution. // // If `debounceMode` is true (at begin), schedule `clear` to execute // after `delay` ms. // // If `debounceMode` is false (at end), schedule `callback` to // execute after `delay` ms. timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay); } } // Return the wrapper function. return wrapper; }; 14.2 debounce/** * @desc 函数防抖 * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次， * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。 * @example 适用场景：如在线编辑的自动存储防抖。 * @param {Number} delay 0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。 * @param {Boolean} atBegin 可选，默认为false。 * 如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。 如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行 * @param {Function} callback 延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的， * 执行去抖动功能时，，调用`callback`。 * * @return {Function} 新的防抖函数。 */ var throttle = require(&apos;./throttle&apos;); function debounce(delay, atBegin, callback) { return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false); }; 封装 除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用webpack统一打包成UMD 通用模块规范，支持webpack、RequireJS、SeaJS等模块加载器，亦或直接通过&lt;script&gt;标签引入。 但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持按需引入吧 1.目录结构说明 │ .babelrc │ .gitignore │ .travis.yml │ LICENSE │ package.json │ README.md │ setCookie.js // 拷贝到根路径的函数模块，方便按需加载 │ setScrollTop.js │ stringfyQueryString.js │ ... │ ... │ ├─min │ outils.min.js // 所有函数统一打包生成的全量压缩包 │ ├─script // 本项目开发脚本目录 │ build.js // 打包构建脚本 │ test.js // 测试脚本 │ webpack.conf.js // webpack打包配置文件 │ ├─src // 源码目录 │ │ index.js // webpack入口文件 │ │ │ ├─array │ │ │ ├─class │ │ │ ├─cookie │ │ │ ├─device │ │ │ ├─dom │ │ │ ├─keycode │ │ │ ├─object │ │ │ ├─random │ │ │ ├─regexp │ │ │ ├─string │ │ │ ├─support │ │ │ ├─time │ │ │ └─url │ └─test // 测试用例目录 │ array.test.js │ class.test.js │ cookie.test.js │ device.test.js │ dom.test.js │ index.html │ keycode.test.js │ object.test.js │ random.test.js │ regexp.test.js │ string.test.js │ support.test.js │ time.test.js │ url.test.js │ └─_lib // 测试所用到的第三方库 mocha.css mocha.js power-assert.js 2.构建脚本 这里主要说明一下项目中 build.js 的构建过程第一步，构建全量压缩包，先删除min目录中之前的outils.min.js，后通过webpack打包并保存新的压缩包至min目录中： ...... ...... // 删除旧的全量压缩包 rm(path.resolve(rootPath, &apos;min&apos;, `${pkg.name}.min.js`), err =&gt; { if (err) throw (err) webpack(config, function (err, stats) { if (err) throw (err) building.stop() process.stdout.write(stats.toString({ colors: true, modules: false, children: false, chunks: false, chunkModules: false }) + &apos;\n\n&apos;) resolve() console.log(chalk.cyan(&apos; Build complete.\n&apos;)) }) }) ...... ...... 第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝src下面一层目录的所有js文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接require(&#39;outils/&lt;方法名&gt;&#39;)即可，缩短引入的路径，也算是提高点效率。 // 替换模块文件 ...... ...... // 先删除根目录中之前的函数模块 rm(&apos;*.js&apos;, err =&gt; { if (err) throw (err) let folderList = fs.readdirSync(path.resolve(rootPath, &apos;src&apos;)) folderList.forEach((item, index) =&gt; { // 拷贝`src`下面一层目录的所有`js`文件至根目录 copy(`src/${item}/*.js`, rootPath, function (err, files) { if (err) throw err; if (index === folderList.length - 1) { console.log(chalk.cyan(&apos; Copy complete.\n&apos;)) copying.stop() } }) }) }) ...... ...... 3.书写测试用例 俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。 但是因为时间关系，本项目暂时通过项目中的 test.js ，启动了一个koa静态服务器，来加载mocha网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。但是后续将使用travis-ci配合Github来做持续化构建，自动发布到npm。改用karma，mocha，power-assert做单元测试，使用Coverage测试覆盖率。这一部分，后续更新。 这里给大家推荐一个好用的断言库 power-assert ，这个库记住assert(value, [message])一个API就基本无敌，从此再也不用担心记不住断言库的API。 本项目的所有测试用例都在test目录下，大家可以作一定参考。 更新：单元测试，已使用karma，mocha，power-assert，使用Coverage测试覆盖率，并集成 travis-ci 配合Github来做持续化构建，可以参考本项目的travis配置文件 .travis.yml 和karma的配置文件 karma.conf.js 。 发布 首先放到Github托管一下，当然你也可以直接fork本项目，然后再加入你自己的函数。以笔者项目，举个栗子: 1.添加自己的函数 在src目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。 /** * * @desc 判断是否NaN * @param {Any} value * @return {Boolean} */ function isNaN(value) { return value !== value; }; modules.export = isNaN 然后记得在src/index.js文件中暴露isNaN函数 2.单元测试 在test文件新建测试用例 describe(&apos;#isNaN()&apos;, function () { it(`outils.isNaN(NaN) should return true`, function () { assert(outils.isNaN(NaN)) }) it(`outils.isNaN(&apos;value&apos;) should return false`, function () { assert.notEqual(outils.isNaN(NaN)) }) }) 然后记得在test/index.html中引入之前创建的测试用例脚本。 3.测试并打包 执行npm run test，看所有的测试用例是否通过。如果没有问题，执行npm run build构建，之后提交到个人的 github 仓库即可。 4.发布到npm 在 www.npmjs.com 注册账号，修改本地package.json中的name、version、author等信息，最后npm publish就大功告成了。注意：向npm发包，要把镜像源切到 www.npmjs.com ，使用cnpm等第三方镜像源会报错。 使用 1.浏览器 直接下载min目录下的 outils.min.js ，通过&lt;script&gt;标签引入。 &lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var OS = outils.getOS() &lt;/script&gt; 注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到 github Release 页面下载对应版本号的代码。 2.Webpack、RequireJS、SeaJS等模块加载器 先使用npm安装outils。 $ npm install --save-dev outils // 完整引入 const outils = require(&apos;outils&apos;) const OS = outils.getOS() 推荐使用方法 // 按需引入require(&apos;outils/&lt;方法名&gt;&apos;) const getOS = require(&apos;outils/getOS&apos;) const OS = getOS() 当然，你的开发环境有babel编译ES6语法的话，也可以这样使用： import getOS from &apos;outils/getOS&apos; // 或 import { getOS } from &quot;outils&quot;; 总结 这里只是简单封装，发布到npm上，省去下次复制粘贴的功夫，或者直接Goole的时间。如果笔者的库中，没有你常用的函数，或者你有更好的建议，欢迎来本项目的 Github Issues 交流，如果觉得不错，欢迎 star 本项目。 当然，更好的建议是 fork 本项目，或者直接新建自己的项目，添加自己 想要的 、常用的 、记不住的 函数，甚至是可以抽象出来的功能，封装成自己顺手、熟悉的库。 这样才能打造出你自己的武器库，瞬间提高你的单兵作战（开发）能力。 libraries ：https://github.com/wuxianqiang/libraries目录 仿ECMAScript5中Object.create()函数 仿ECMAScript5中String.trim()函数 仿ECMAScript5中Array.reduce()函数 仿ECMAScript5中Object.keys()函数 仿ECMAScript5中Function.bind()函数 仿ECMAScript5中Array.map()函数 仿Math.max()方法实现 仿String.match()方法实现 仿HTML5的classList属性实现 仿Function.name属性实现 返回元素的第n层祖先元素 返回元素的第n个兄弟元素 返回元素的第n个子代元素 原生JS实现CSS动画之震动 原生JS实现CSS动画之隐藏 在数组中查找所有出现的元素方法 数据类型检测之特殊情况特殊处理 使用innerHTML实现outerHTML属性 插入节点 倒序排列子节点 查询窗口滚动条的位置 查询窗口的视口尺寸 表格的行排序 生成目录表 数组去重 冒泡排序 从URL解析参数 获取纯文本的元素内容 手写一个JSONP实现 查询纯文本形式的内容 查找元素的后代中节点中的所有Text节点 使用innerHTML实现insertAdjacentHTML 拖拽 在谷歌地图上显示地理位置信息 使用所有地理位置特性 优雅的图片翻转实现 使用canvas绘制多边形 使用canvas绘制雪花 在Web Worker中发起同步XMLHtttpRequest 仿ECMAScript5中Object.create()函数function inherit(obj) { if (obj === null) throw TypeError(); if (Object.create) return Object.create(obj); var t = typeof obj; if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) throw TypeError(); function Fn() {}; Fn.prototype = obj; return new Fn(); } 仿ECMAScript5中String.trim()函数String.prototype.mytrim = function () { String.prototype.trim || function () { if (!this) return this; //空字符串不做处理 return this.replace(/^\s+|\s+$/g, &quot;&quot;) //使用正则表达式经行空格替换 } } 仿ECMAScript5中Array.reduce()函数var reduce = Array.prototype.reduce ? function (ary, fn, initial) { if (arguments.length &gt; 2) { //如果reduce()方法存在的话 return ary.reduce(fn, initial); //如果传入了一个初始值 } else { return ary.reduce(fn); //否则初始值 } } : function (ary, fn, initial) { //以特定的初始值开始，否则第一个值取自ary var i = 0, len = ary.length, accumulator; if (arguments.length &gt; 2) { accumulator = initial; } else { //找到数组中第一个已经定义的索引 if (len == 0) throw TypeError(); while (i &lt; len) { if (i in ary) { accumulator = ary[i++]; break; } else { i++; } } if (i == len) throw TypeError(); } while (i &lt; len) { //对于数组中剩下的元素依次调用fn if (i in ary) { accumulator = fn.call(undefined, accumulator, ary[i], i, ary) } i++; } return accumulator; } ⬆ back to top 在数组中查找所有出现的元素方法function findAll(ary, ele) { var results = [], len = ary.length, pos = 0; while (pos &lt; len) { pos = ary.indexOf(ele, pos); if (pos === -1) break; results.push(pos); pos++; } return results; } ⬆ back to top 数据类型检测，特殊情况特殊处理function classOf(obj) { if (obj === null) return &quot;Null&quot;; if (obj === undefined) return &apos;Undefined&apos;; return Object.prototype.toString.call(obj).slice(8, -1); } ⬆ back to top 仿ECMAScript5中Object.keys()函数function keys(obj) { if (typeof obj !== &quot;object&quot;) { throw TypeError(); } var result = []; for (var prop in obj) { if (obj.hasOwnProperty(prop)) { result.push(prop); } } return result; } ⬆ back to top 仿Math.max方法（不定实参函数）function max() { var max = Number.NEGATIVE_INFINITY; for (var i = 0; i &lt; arguments.length; i++) { if (arguments[i] &gt; max) max = arguments[i]; } return max; } ⬆ back to top 仿ECMAScript5中Function.bind()函数if (!Function.prototype.bind) { Function.prototype.bind = function (obj) { var self = this, boundArgs = arguments; return function () { var args = [], i; for (i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]); for (i = 1; i &lt; arguments.length; i++) args.push(arguments[i]); return self.apply(obj, args); } } } ⬆ back to top 仿ECMAScript5中Array.map()函数var map = Array.prototype.map ? function (ary, fn) { return ary.map(fn); } : function (ary, fn) { var results = []; for (var i = 0, len = ary.length; i &lt; len; i++) { if (i in ary) { results[i] = fn.call(null, ary[i], i, ary); } } return results; } ⬆ back to top 数组去重Array.prototype.unique = function unique() { var obj = {}; for (var i = 0; i &lt; this.length; i++) { var current = this[i]; if (obj[current] === current) { current = this[this.length - 1]; this.length--; i--; continue; } obj[current] = current } obj = null; return this; } ⬆ back to top 冒泡排序Array.prototype.bubbleSort = function bubbleSort() { var temp = null; for (var i = 0; i &lt; this.length - 1; i++) { for (var k = 0; k &lt; this.length - 1 - i; k++) { if (this[k] &gt; this[k + 1]) { temp = this[k]; this[k] = this[k + 1]; this[k + 1] = temp; } } } return this; } ⬆ back to top 仿String.match()方法实现String.prototype.mymatch = function (reg) { var ary = []; var res = reg.exec(this); while (res) { ary.push(res[0]); res = reg.exec(this); } return ary; } ⬆ back to top 返回元素的第n层祖先元素/** *返回元素ele的第n层祖先元素，如果不存在此类祖先或祖先不是Element， *（例如Document或者DocumentFragment）则返回null *如果n为0，则返回e本身。如果n为1（或省略），则返回其父元素 *如果n为2，则返回其祖父元素，依次类推 */ function parent(ele, n) { if (n === nudefined) n = 1; while (n-- &amp;&amp; ele) { ele = ele.parentNode; } if (!ele || ele.nodeTope !== 1) return null; return ele; } ⬆ back to top 返回元素的第n个兄弟元素/** *返回元素ele的第n个兄弟元素 *如果n为正，返回后续的第n个兄弟元素 *如果n为负，返回前面的第n个兄弟元素 *如果n为零，返回ele本身 */ function sibling(ele, n) { while (ele &amp;&amp; n !== 0) { //如果ele未定义，即刻返回它 if (n &gt; 0) { //查找后续的兄弟元素 if (ele.nextElementSibling) { ele = ele.nextElementSibling; } else { for (ele = ele.nextSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/; } n--; } else { //查找前面的兄弟元素 if (ele.previousElementSibing) { ele = ele.previousElementSibling; } else { for (ele = ele.previousSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/; } n++; } } return ele; } ⬆ back to top 返回元素的第n个子代元素/** *返回元素ele的第n代子元素，如果不存在则为null *负值n代表从后往前计数。0表示第一个子元素，而-1代表最后一个，-2代表倒数第二个，依次类推 */ function child(ele, n) { if (ele.children) { //如果children数组存在 if (n &lt; 0) n += ele.children.length; //转换负的n为数组索引 if (n &lt; 0) return null; //如果它仍然为负，说明没有子元素 return ele.children[n]; //返回指定的子元素 } //如果e没有children数组，找到第一个子元素并向前数，或找到最后一个子元素并往回数 if (n &gt;= 0) { //n非负：从第一个子元素向前数 //找到元素e的第一个子元素 if (ele.firstElementChild) { ele = ele.firstElementChild; } else { for (ele = ele.firstChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/; } return sibling(ele, n); //返回第一个子元素的第n个兄弟元素 } else { //n为负：从最后一个子元素往回数 if (ele.lastElementChild) { ele = ele.lastElementChild; } else { for (ele = ele.lastChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/; } return sibling(ele, n + 1); //+1来转化最后1个子元素为最后1个兄弟元素 } } ⬆ back to top 表格的行排序//根据指定表格每行第n个单元格的值，对第一个＜tbody＞中的行进行排序 //如果存在comparator函数则使用它，否则按字母表顺序比较 function sortrows(table, n, comparator) { var tbody = table.tBodies[0]; //第一个＜tbody＞，可能是隐式创建的 var rows = tbody.getElementsByTagName(&quot;tr&quot;); //tbody中的所有行 rows = Array.prototype.slice.call(rows, 0); //真实数组中的快照 //基于第n个＜td＞元素的值对行排序 rows.sort(function (row1, row2) { var cell1 = row1.getElementsByTagName(&quot;td&quot;)[n]; //获得第n个单元格 var cell2 = row2.getElementsByTagName(&quot;td&quot;)[n]; //两行都是 var val1 = cell1.textContent || cell1.innerText; //获得文本内容 var val2 = cell2.textContent || cell2.innerText; //两单元格都是 if (comparator) return comparator(val1, val2); //进行比较 if (val1 &lt; val2) { return -1; } else if (val1 &gt; val2) { return 1; } else { return 0; } }); //在tbody中按它们的顺序把行添加到最后 //这将自动把它们从当前位置移走，故没必要预先删除它们 //如果＜tbody＞还包含了除了＜tr＞的任何其他元素，这些节点将会悬浮到顶部位置 for (var i = 0; i &lt; rows.length; i++) tbody.appendChild(rows[i]); } //查找表格的＜th＞元素（假设只有一行），让它们可单击， //以便单击列标题，按该列对行排序 function makeSortable(table) { var headers = table.getElementsByTagName(&quot;th&quot;); for (var i = 0; i &lt; headers.length; i++) { (function (n) { //嵌套函数来创建本地作用域 headers[i].onclick = function () { sortrows(table, n); }; }(i)); //将i的值赋给局部变量n } } ⬆ back to top 生成目录表/** * *这个模块注册一个可在页面加载完成后自动运行的匿名函数。当执行这个函数时会去文档中查找 *id为&quot;TOC&quot;的元素。如果这个元素不存在，就创建一个元素 * *生成的TOC目录应当具有自己的CSS样式。整个目录区域的样式className设置为&quot;TOCEntry&quot; *同样我们为不同层级的目录标题定义不同的样式。＜h1＞标签生成的标题 *className为&quot;TOCLevel1&quot;，＜h2＞标签生成的标题className为&quot;TOCLevel2&quot;，以此类推 *段编号的样式为&quot;TOCSectNum&quot; * *完整的CSS样式代码如下: * *#TOC{border:solid black 1px;margin:10px;padding:10px;} *.TOCEntry{font-family:sans-serif;} *.TOCEntry a{text-decoration:none;} *.TOCLevel1{font-size:16pt;font-weight:bold;} *.TOCLevel2{font-size:12pt;margin-left:.5in;} *.TOCSectNum:after{content:&quot;:&quot;;} * *这段代码的最后一行表示每个段编号之后都有一个冒号和空格符。要想隐藏段编号， *请使用这行代码： *.TOCSectNum{display:none} * **/ (function () { //匿名函数定义了一个局部作用域 //查找TOC容器元素 //如果不存在，则在文档开头处创建一个 var toc = document.getElementById(&quot;TOC&quot;); if (!toc) { toc = document.createElement(&quot;div&quot;); toc.id = &quot;TOC&quot;; document.body.insertBefore(toc, document.body.firstChild); } //查找所有的标题元素 var headings; if (document.querySelectorAll) //我们是否能用这个简单的方法？ headings = document.querySelectorAll(&quot;h1,h2,h3,h4,h5,h6&quot;); else //否则，查找方法稍微麻烦一些 headings = findHeadings(document.body, []); //递归遍历document的body，查找标题元素 function findHeadings(root, sects) { for (var c = root.firstChild; c != null; c = c.nextSibling) { if (c.nodeType !== 1) continue; if (c.tagName.length == 2 &amp;&amp; c.tagName.charAt(0) == &quot;H&quot;) sects.push(c); else findHeadings(c, sects); } return sects; } //初始化一个数组来保持跟踪章节号 var sectionNumbers = [0, 0, 0, 0, 0, 0]; //现在，循环已找到的标题元素 for (var h = 0; h &lt; headings.length; h++) { var heading = headings[h]; //跳过在TOC容器中的标题元素 if (heading.parentNode == toc) continue; //判定标题的级别 var level = parseInt(heading.tagName.charAt(1)); if (isNaN(level) || level &lt; 1 || level &gt; 6) continue; //对于该标题级别增加sectionNumbers对应的数字 //重置所有标题比它级别低的数字为零 sectionNumbers[level - 1]++; for (var i = level; i &lt; 6; i++) sectionNumbers[i] = 0; //现在，将所有标题级别的章节号组合产生一个章节号， 如2 .3 .1 var sectionNumber = sectionNumbers.slice(0, level).join(&quot;.&quot;) //为标题级别增加章节号 //把数字放在＜span＞中，使得其可以用样式修饰 var span = document.createElement(&quot;span&quot;); span.className = &quot;TOCSectNum&quot;; span.innerHTML = sectionNumber; heading.insertBefore(span, heading.firstChild); //用命名的锚点将标题包起来，以便为它增加链接 var anchor = document.createElement(&quot;a&quot;); anchor.name = &quot;TOC&quot; + sectionNumber; heading.parentNode.insertBefore(anchor, heading); anchor.appendChild(heading); //现在为该节创建一个链接 var link = document.createElement(&quot;a&quot;); link.href = &quot;#TOC&quot; + sectionNumber; //链接的目标地址 link.innerHTML = heading.innerHTML; //链接文本与实际标题一致 //将链接放在一个div中，div用基于级别名字的样式修饰 var entry = document.createElement(&quot;div&quot;); entry.className = &quot;TOCEntry TOCLevel&quot; + level; entry.appendChild(link); //该div添加到TOC容器中 toc.appendChild(entry); } }()); ⬆ back to top 从URL解析参数/* *这个函数用来解析来自URL的查询串中的name=value参数对 *它将name=value对存储在一个对象的属性中，并返回该对象 *这样来使用它 * *var args=urlArgs();//从URL中解析参数 *var q=args.q||&quot;&quot;;//如果参数定义了的话就使用参数；否则使用一个默认值 *var n=args.n?parseInt(args.n):10; */ function urlArgs() { var args = {}; //定义一个空对象 var query = location.search.substring(1); //查找到查询串，并去掉&apos;?&apos; var pairs = query.split(&quot;&amp;&quot;); //根据&quot;&amp;&quot;符号将查询字符串分隔开 for (var i = 0; i &lt; pairs.length; i++) { //对于每个片段 var pos = pairs[i].indexOf(&apos;=&apos;); //查找&quot;name=value&quot; if (pos == -1) continue; //如果没有找到的话，就跳过 var name = pairs[i].substring(0, pos); //提取name var value = pairs[i].substring(pos + 1); //提取value value = decodeURIComponent(value); //对value进行解码 args[name] = value; //存储为属性 } return args; //返回解析后的参数 } ⬆ back to top 获取纯文本的元素内容/** *一个参数，返回元素的textContent或innerText *两个参数，用value参数的值设置元素的textContent或innerText */ function textContent(element, value) { var content = element.textContent; //检测textContent是否有定义 if (value === undefined) { //没传递value，因此返回当前文本 if (content !== undefined) { return content; } else { return element.innerText; } } else { //传递了value，因此设置文本 if (content !== undefined) { element.textContent = value; } else { element.innerText = value; } } } ⬆ back to top 手写一个JSONP实现//根据指定的URL发送一个JSONP请求 //然后把解析得到的响应数据传递给回调函数 //在URL中添加一个名为jsonp的查询参数，用于指定该请求的回调函数的名称 function getJSONP(url, callback) { //为本次请求创建一个唯一的回调函数名称 var cbnum = &quot;cb&quot; + getJSONP.counter++; //每次自增计数器 var cbname = &quot;getJSONP.&quot; + cbnum; //作为JSONP函数的属性 //将回调函数名称以表单编码的形式添加到URL的查询部分中 //使用jsonp作为参数名，一些支持JSONP的服务 //可能使用其他的参数名，比如callback if (url.indexOf(&quot;?&quot;) === -1) //URL没有查询部分 url += &quot;?jsonp=&quot; + cbname; //作为查询部分添加参数 else //否则 url += &quot;＆jsonp=&quot; + cbname; //作为新的参数添加它 //创建script元素用于发送请求 var script = document.createElement(&quot;script&quot;); //定义将被脚本执行的回调函数 getJSONP[cbnum] = function (response) { try { callback(response); //处理响应数据 } finally { //即使回调函数或响应抛出错误 delete getJSONP[cbnum]; //删除该函数 script.parentNode.removeChild(script); //移除script元素 } }; //立即触发HTTP请求 script.src = url; //设置脚本的URL document.body.appendChild(script); //把它添加到文档中 } getJSONP.counter = 0; //用于创建唯一回调函数名称的计数器 ⬆ back to top 插入节点//将child节点插入到parent中，使其成为第n个子节点 function insertAt(parent, child, n) { if (n &lt; 0 || n &gt; parent.childNodes.length) { throw new Error(&quot;invalid index&quot;); } else if (n == parent.childNodes.length) { parent.appendChild(child); } else { parent.insertBefore(child, parent.childNodes[n]); } } ⬆ back to top 使用innerHTML实现outerHTML属性//为那些不支持它的浏览器实现outerHTML属性 //假设浏览器确实支持innerHTML，并有个可扩展的Element.prototype， //并且可以定义getter和setter (function () { //如果outerHTML存在，则直接返回 if (document.createElement(&quot;div&quot;).outerHTML) return; //返回this所引用元素的外部HTML function outerHTMLGetter() { var container = document.createElement(&quot;div&quot;); //虚拟元素 container.appendChild(this.cloneNode(true)); //复制到该虚拟节点 return container.innerHTML; //返回虚拟节点的innerHTML } //用指定的值设置元素的外部HTML function outerHTMLSetter(value) { //创建一个虚拟元素，设置其内容为指定的值 var container = document.createElement(&quot;div&quot;); container.innerHTML = value; //将虚拟元素中的节点全部移动到文档中 while (container.firstChild) //循环，直到container没有子节点为止 this.parentNode.insertBefore(container.firstChild, this); //删除所被取代的节点 this.parentNode.removeChild(this); } //现在使用这两个函数作为所有Element对象的outerHTML属性的getter和setter //如果它存在则使用ES5的Object.defineProperty()方法， //否则，退而求其次，使用__defineGetter__()和__defineSetter__() if (Object.defineProperty) { Object.defineProperty(Element.prototype, &quot;outerHTML&quot;, { get: outerHTMLGetter, set: outerHTMLSetter, enumerable: false, configurable: true }); } else { Element.prototype.__defineGetter__(&quot;outerHTML&quot;, outerHTMLGetter); Element.prototype.__defineSetter__(&quot;outerHTML&quot;, outerHTMLSetter); } }()); ⬆ back to top 倒序排列子节点//倒序排列节点n的子节点 function reverse(n) { //创建一个DocumentFragment作为临时容器 var f = document.createDocumentFragment(); //从后至前循环子节点，将每一个子节点移动到文档片段中 //n的最后一个节点变成f的第一个节点，反之亦然 //注意，给f添加一个节点，该节点自动地会从n中删除 while (n.lastChild) f.appendChild(n.lastChild); //最后，把f的所有子节点一次性全部移回n中 n.appendChild(f); } ⬆ back to top 查询窗口滚动条的位置//以一个对象的x和y属性的方式返回滚动条的偏移量 function getScrollOffsets(w) { //使用指定的窗口，如果不带参数则使用当前窗口 w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用 if (w.pageXOffset != null) return { x: w.pageXOffset, y: w.pageYOffset }; //对标准模式下的IE（或任何浏览器） var d = w.document; if (document.compatMode == &quot;CSS1Compat&quot;) return { x: d.documentElement.scrollLeft, y: d.documentElement.scrollTop }; //对怪异模式下的浏览器 return { x: d.body.scrollLeft, y: d.body.scrollTop }; } ⬆ back to top 查询窗口的视口尺寸//作为一个对象的w和h属性返回视口的尺寸 function getViewportSize(w) { //使用指定的窗口，如果不带参数则使用当前窗口 w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用 if (w.innerWidth != null) return { w: w.innerWidth, h: w.innerHeight }; //对标准模式下的IE（或任何浏览器） var d = w.document; if (document.compatMode == &quot;CSS1Compat&quot;) return { w: d.documentElement.clientWidth, h: d.documentElement.clientHeight }; //对怪异模式下的浏览器 return { w: d.body.clientWidth, h: d.body.clientWidth }; } ⬆ back to top 返回函数的名字Function.prototype.getName = function () { return this.name || this.toString().match(/function\s*(\w*)\s*\(/)[1]; } ⬆ back to top 原生JS实现CSS动画1//将e转化为相对定位的元素，使之左右&quot;震动&quot; //第一个参数可以是元素对象或者元素的id //如果第二个参数是函数，以e为参数，它将在动画结束时调用 //第三个参数指定e震动的距离，默认是5像素 //第四个参数指定震动多久，默认是500毫秒 function shake(e, oncomplete, distance, time) { //句柄参数 if (typeof e === &quot;string&quot;) e = document.getElementById(e); if (!time) time = 500; if (!distance) distance = 5; var originalStyle = e.style.cssText; //保存e的原始style e.style.position = &quot;relative&quot;; //使e相对定位 var start = (new Date()).getTime(); //注意，动画的开始时间 animate(); //动画开始 //函数检查消耗的时间，并更新e的位置 //如果动画完成，它将e还原为原始状态 //否则，它更新e的位置，安排它自身重新运行 function animate() { var now = (new Date()).getTime(); //得到当前时间 var elapsed = now - start; //从开始以来消耗了多长时间？ var fraction = elapsed / time; //是总时间的几分之几？ if (fraction &lt; 1) { //如果动画未完成 //作为动画完成比例的函数，计算e的x位置 //使用正弦函数将完成比例乘以4pi //所以，它来回往复两次 var x = distance * Math.sin(fraction * 4 * Math.PI); e.style.left = x + &quot;px&quot;; //在25毫秒后或在总时间的最后尝试再次运行函数 //目的是为了产生每秒40帧的动画 setTimeout(animate, Math.min(25, time - elapsed)); } else { //否则，动画完成 e.style.cssText = originalStyle //恢复原始样式 if (oncomplete) oncomplete(e); //调用完成后的回调函数 } } } ⬆ back to top 原生JS实现CSS动画2function fadeOut(e, oncomplete, time) { if (typeof e === &quot;string&quot;) e = document.getElementById(e); if (!time) time = 500; //使用Math.sqrt作为一个简单的“缓动函数”来创建动画 //精巧的非线性：一开始淡出得比较快，然后缓慢了一些 var ease = Math.sqrt; var start = (new Date()).getTime(); //注意：动画开始的时间 animate(); //动画开始 function animate() { var elapsed = (new Date()).getTime() - start; //消耗的时间 var fraction = elapsed / time; //总时间的几分之几？ if (fraction &lt; 1) { //如果动画未完成 var opacity = 1 - ease(fraction); //计算元素的不透明度 e.style.opacity = String(opacity); //设置在e上 setTimeout(animate, //调度下一帧 Math.min(25, time - elapsed)); } else { //否则，动画完成 e.style.opacity = &quot;0&quot;; //使e完全透明 if (oncomplete) oncomplete(e); //调用完成后的回调函数 } } } ⬆ back to top 仿HTML5的classList属性/* *如果e有classList属性则返回它。否则，返回一个为e模拟DOMTokenList API的对象 *返回的对象有contains()、add()、remove()、toggle()和toString()等方法 *来检测和修改元素e的类集合。如果classList属性是原生支持的， *返回的类数组对象有length和数组索引属性。模拟DOMTokenList不是类数组对象， *但是它有一个toArray()方法来返回一个含元素类名的纯数组快照 */ function classList(e) { if (e.classList) return e.classList; //如果e.classList存在，则返回它 else return new CSSClassList(e); //否则，就伪造一个 } //CSSClassList是一个模拟DOMTokenList的JavaScript类 function CSSClassList(e) { this.e = e; } //如果e.className包含类名c则返回true否则返回false CSSClassList.prototype.contains = function (c) { //检查c是否是合法的类名 if (c.length === 0 || c.indexOf(&quot; &quot;) != -1) throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //首先是常规检查 var classes = this.e.className; if (!classes) return false; //e不含类名 if (classes === c) return true; //e有一个完全匹配的类名 //否则，把c自身看做一个单词，利用正则表达式搜索c //\b在正则表达式里代表单词的边界 return classes.search(&quot;\\b&quot; + c + &quot;\\b&quot;) != -1; }; //如果c不存在，将c添加到e.className中 CSSClassList.prototype.add = function (c) { if (this.contains(c)) return; //如果存在，什么都不做 var classes = this.e.className; if (classes &amp;&amp; classes[classes.length - 1] != &quot;&quot;) c = &quot;&quot; + c; //如果需要加一个空格 this.e.className += c; //将c添加到className中 }; //将在e.className中出现的所有c都删除 CSSClassList.prototype.remove = function (c) { //检查c是否是合法的类名 if (c.length === 0 || c.indexOf(&quot; &quot;) != -1) throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //将所有作为单词的c和多余的尾随空格全部删除 var pattern = new RegExp(&quot;\\b&quot; + c + &quot;\\b\\s*&quot;, &quot;g&quot;); this.e.className = this.e.className.replace(pattern, &quot;&quot;); }; //如果c不存在，将c添加到e.className中，并返回true //否则，将在e.className中出现的所有c都删除，并返回false CSSClassList.prototype.toggle = function (c) { if (this.contains(c)) { //如果e.className包含c this.remove(c); //删除它 return false; } else { //否则 this.add(c); //添加它 return true; } }; //返回e.className本身 CSSClassList.prototype.toString = function () { return this.e.className; }; //返回在e.className中的类名 CSSClassList.prototype.toArray = function () { return this.e.className.match(/\b\w+\b/g) || []; }; ⬆ back to top 查询纯文本形式的内容/** *一个参数，返回元素的textContent或innerText *两个参数，用value参数的值设置元素的textContent或innerText */ function textContent(element, value) { var content = element.textContent; //检测textContent是否有定义 if (value === undefined) { //没传递value，因此返回当前文本 if (content !== undefined) return content; else return element.innerText; } else { //传递了value，因此设置文本 if (content !== undefined) element.textContent = value; else element.innerText = value; } } textContent属性在除了IE的所有当前的浏览器中都支持。在IE中，可以用Element的innerText属性来代替。 ⬆ back to top 查找元素的后代中节点中的所有Text节点//返回元素e的纯文本内容，递归进入其子元素 //该方法的效果类似于textContent属性 function textContent(e) { var child, type, s = &quot;&quot;; //s保存所有子节点的文本 for (child = e.firstChild; child != null; child = child.nextSibling) { type = child.nodeType; if (type === 3 || type === 4) //Text和CDATASection节点 s += child.nodeValue; else if (type === 1) //递归Element节点 s += textContent(child); } return s; } ⬆ back to top 使用innerHTML实现insertAdjacentHTML()//本模块为不支持它的浏览器定义了Element.insertAdjacentHTML //还定义了一些可移植的HTML插入函数，它们的名字比insertAdjacentHTML更符合逻辑： //Insert.before()、Insert.after()、Insert.atStart()和Insert.atEnd() var Insert = (function () { //如果元素有原生的insertAdjacentHTML， //在4个函数名更明了的HTML插入函数中使用它 if (document.createElement(&quot;div&quot;).insertAdjacentHTML) { return { before: function (e, h) { e.insertAdjacentHTML(&quot;beforebegin&quot;, h); }, after: function (e, h) { e.insertAdjacentHTML(&quot;afterend&quot;, h); }, atStart: function (e, h) { e.insertAdjacentHTML(&quot;afterbegin&quot;, h); }, atEnd: function (e, h) { e.insertAdjacentHTML(&quot;beforeend&quot;, h); } }; } //否则，无原生的insertAdjacentHTML //实现同样的4个插入函数，并使用它们来定义insertAdjacentHTML //首先，定义一个工具函数，传入HTML字符串，返回一个DocumentFragment， //它包含了解析后的HTML的表示 function fragment(html) { var elt = document.createElement(&quot;div&quot;); //创建空元素 var frag = document.createDocumentFragment(); //创建空文档片段 elt.innerHTML = html; //设置元素内容 while (elt.firstChild) //移动所有的节点 frag.appendChild(elt.firstChild); //从elt到frag return frag; //然后返回frag } var Insert = { before: function (elt, html) { elt.parentNode.insertBefore(fragment(html), elt); }, after: function (elt, html) { elt.parentNode.insertBefore(fragment(html), elt.nextSibling); }, atStart: function (elt, html) { elt.insertBefore(fragment(html), elt.firstChild); }, atEnd: function (elt, html) { elt.appendChild(fragment(html)); } }; //基于以上函数实现insertAdjacentHTML Element.prototype.insertAdjacentHTML = function (pos, html) { switch (pos.toLowerCase()) { case &quot;beforebegin&quot;: return Insert.before(this, html); case &quot;afterend&quot;: return Insert.after(this, html); case &quot;afterbegin&quot;: return Insert.atStart(this, html); case &quot;beforeend&quot;: return Insert.atEnd(this, html); } }; return Insert; //最后返回4个插入函数 }()); ⬆ back to top 拖拽/** *Drag.js：拖动绝对定位的HTML元素 * *这个模块定义了一个drag()函数，它用于mousedown事件处理程序的调用 *随后的mousemove事件将移动指定元素，mouseup事件将终止拖动 *这些实现能同标准和IE两种事件模型一起工作 * *参数： * *elementToDrag：接收mousedown事件的元素或某些包含元素 *它必须是定位的元素,元素的样式必须是行内样式 *它的style.left和style.top值将随着用户的拖动而改变 * *event：mousedown事件对象 **/ function drag(elementToDrag, event) { //初始鼠标位置，转换为文档坐标 var startX = event.clientX; var startY = event.clientY; //在文档坐标下，待拖动元素的初始位置 //因为elementToDrag是绝对定位的， //所以我们可以假设它的offsetParent就是文档的body元素 var origX = parseFloat(elementToDrag.style.left); var origY = parseFloat(elementToDrag.style.top); //计算mousedown事件和元素左上角之间的距离 //我们将它另存为鼠标移动的距离 if (document.addEventListener) { //标准事件模型 //在document对象上注册捕获事件处理程序 document.addEventListener(&quot;mousemove&quot;, moveHandler, true); document.addEventListener(&quot;mouseup&quot;, upHandler, true); } else if (document.attachEvent) { //用于IE5～8的IE事件模型 //在IE事件模型中， //捕获事件是通过调用元素上的setCapture()捕获它们 elementToDrag.setCapture(); elementToDrag.attachEvent(&quot;onmousemove&quot;, moveHandler); elementToDrag.attachEvent(&quot;onmouseup&quot;, upHandler); //作为mouseup事件看待鼠标捕获的丢失 elementToDrag.attachEvent(&quot;onlosecapture&quot;, upHandler); } //我们处理了这个事件，不让任何其他元素看到它 if (event.stopPropagation) event.stopPropagation(); //标准模型 else event.cancelBubble = true; //IE //现在阻止任何默认操作 if (event.preventDefault) event.preventDefault(); //标准模型 else event.returnValue = false; //IE /** * 当元素正在被拖动时， 这就是捕获mousemove事件的处理程序 *它用于移动这个元素 **/ function moveHandler(e) { if (!e) e = window.event; //IE事件模型 //移动这个元素到当前鼠标位置， //通过滚动条的位置和初始单击的偏移量来调整 var targetLeft = e.clientX - startX + origX; var targetTop = e.clientY - startY + origY; var minLeft = 0; var minTop = 0; var maxLeft = (document.documentElement.clientWidth || document.body.clientWidth) - elementToDrag.offsetWidth; var maxTop = (document.documentElement.clientHeight || document.body.clientHeight) - elementToDrag.offsetHeight; targetLeft = targetLeft &gt; maxLeft ? maxLeft : (targetLeft &lt; minLeft ? minLeft : targetLeft); targetTop = targetTop &gt; maxTop ? maxTop : (targetTop &lt; minTop ? minTop : targetTop); elementToDrag.style.left = targetLeft + &quot;px&quot;; elementToDrag.style.top = targetTop + &quot;px&quot;; if (e.stopPropagation) e.stopPropagation(); //标准 else e.cancelBubble = true; //IE } /** *这是捕获在拖动结束时发生的最终mouseup事件的处理程序 **/ function upHandler(e) { if (!e) e = window.event; //IE事件模型 //注销捕获事件处理程序 if (document.removeEventListener) { //DOM事件模型 document.removeEventListener(&quot;mouseup&quot;, upHandler, true); document.removeEventListener(&quot;mousemove&quot;, moveHandler, true); } else if (document.detachEvent) { //IE 5+事件模型 elementToDrag.detachEvent(&quot;onlosecapture&quot;, upHandler); elementToDrag.detachEvent(&quot;onmouseup&quot;, upHandler); elementToDrag.detachEvent(&quot;onmousemove&quot;, moveHandler); elementToDrag.releaseCapture(); } //并且不让事件进一步传播 if (e.stopPropagation) e.stopPropagation(); //标准模型 else e.cancelBubble = true; //IE } } ⬆ back to top 在谷歌地图上显示地理位置信息//获取当前位置然后通过Google地图显示 //如果当前浏览器不支持地理位置API，则抛出一个错误 function getmap() { //检查是否支持地理位置API if (!navigator.geolocation) throw &quot;Geolocation not supported&quot;; //开始请求地理位置信息， navigator.geolocation.getCurrentPosition(setMapURL); function setMapURL(pos) { //从参数对象（pos）中获取位置信息 var latitude = pos.coords.latitude; //经度 var longitude = pos.coords.longitude; //纬度 var accuracy = pos.coords.accuracy; //米 var scale = 10; //比例 //构造一个URL，用于跳转到Google地图 var url = &quot;https://www.google.com/maps/@&quot; + latitude + &quot;,&quot; + longitude + &quot;,&quot; + scale + &quot;z&quot;; //设置一个大致的缩放级别 location = url; } } ⬆ back to top 使用所有地理位置特性//异步的获取我的位置，并在指定的元素中展示出来 function whereami(elt) { //将此对象作为第三个参数传递给getCurrentPosition()方法 var options = { //设置为true，表示如果可以的话 //获取高精度的位置信息（例如，通过GPS获取） //但是，要注意的是，这会影响电池寿命 enableHighAccuracy: false, //可以近似：这是默认值 //如果获取缓存过的位置信息就足够的话，可以设置此属性 //默认值为0,表示强制检查新的位置信息 maximumAge: 300000, //5分钟左后 //愿意等待多长时间来获取位置信息？ //默认值为无限长 [2] ，getCurrentPosition()方法永不超时 timeout: 15000 //不要超过15秒 }; if (navigator.geolocation) //如果支持的话，就获取位置信息 navigator.geolocation.getCurrentPosition(success, error, options); else elt.innerHTMl = &quot;Geolocation not supported in this browser&quot;; //当获取位置信息失败的时候，会调用此函数 function error(e) { //error对象包含一些数字编码和文本消息，如下所示： //1:用户不允许分享他/她的位置信息 //2:浏览器无法确定位置 //3:发生超时 elt.innerHTML = &quot;Geolocation error&quot; + e.code + &quot;:&quot; + e.message; } //当获取位置信息成功的时候，会调用此函数 function success(pos) { //总是可以获取如下这些字段 //但是要注意的是时间戳信息在outer对象中，而不在inner、coords对象中 var msg = &quot;时间是&quot; + new Date(pos.timestamp).toLocaleString() + &quot;地理位置是&quot; + pos.coords.accuracy + &quot;米范围内经度是&quot; + pos.coords.latitude + &quot;纬度是&quot; + pos.coords.longitude + &quot;.&quot;; //如果设备还返回了海拔信息，则将其添加进去 if (pos.coords.altitude) { msg += &quot;海拔是&quot; + pos.coords.altitude + &quot;±&quot; + pos.coords.altitudeAccuracy + &quot;千米.&quot;; } //如果设备还返回了速度和航向信息，也将它们添加进去 if (pos.coords.speed) { msg += &quot;速度是&quot; + pos.coords.speed + &quot;m/s方向是&quot; + pos.coords.heading + &quot;.&quot;; } elt.innerHTML = msg; //显示所有的位置信息 } } ⬆ back to top 优雅的图片翻转实现/** *优雅的图片翻转实现方式 * *要创建图片翻转效果，将此模块引入到HTML文件中 *然后在任意＜img＞元素上使用data-rollover属性来指定翻转图片的URL即可 *如下所示: * *&lt;img src=&quot;normal_image.png &quot;data-rollover=&quot;rollover_image.png&quot;&gt; * */ function changeImage() { //所有处理逻辑都在一个匿名函数中:不定义任何符号 //遍历所有的图片，查找data-rollover属性 for (var i = 0; i &lt; document.images.length; i++) { var img = document.images[i]; var rollover = img.getAttribute(&quot;data-rollover&quot;); if (!rollover) continue; //跳过没有data-rollover属性的图片 //确保将翻转的图片缓存起来 (new Image()).src = rollover; //定义一个属性来标识默认的图片URL img.setAttribute(&quot;data-rollout&quot;, img.src); //注册事件处理函数来创建翻转效果 img.onmouseover = function () { this.src = this.getAttribute(&quot;data-rollover&quot;); }; img.onmouseout = function () { this.src = this.getAttribute(&quot;data-rollout&quot;); }; } } ⬆ back to top 使用canvas绘制多边形//定义一个以(x,y)为中心，半径为r的规则n边形,c可以通过调用画布getContext()方法得到 //每个顶点都是均匀分布在圆周上 //将第一个顶点放置在最上面，或者指定一定角度 //除非最后一个参数是true，否则顺时针旋转 function polygon(c, n, x, y, r, angle, counterclockwise) { angle = angle || 0; counterclockwise = counterclockwise || false; c.moveTo(x + r * Math.sin(angle), //从第一个顶点开始一条新的子路径 y - r * Math.cos(angle)); //使用三角法计算位置 var delta = 2 * Math.PI / n; //两个顶点之间的夹角 for (var i = 1; i &lt; n; i++) { //循环剩余的每个顶点 angle += counterclockwise ? -delta : delta; //调整角度 c.lineTo(x + r * Math.sin(angle), //以下个顶点为端点添加线段 y - r * Math.cos(angle)); } c.closePath(); //将最后一个顶点和起点连接起来 } ⬆ back to top 使用canvas绘制雪花var deg = Math.PI / 180; //用于角度制到弧度制的转换 //在画布的上下文c中，以左下角的点(x,y)和边长len，绘制一个n级别的科赫雪花分形 function snowflake(c, n, x, y, len) { c.save(); //保存当前变换 c.translate(x, y); //变换原点为起始点 c.moveTo(0, 0); //从新的原点开始一条新的子路径 leg(n); //绘制雪花的第一条边 c.rotate(-120 * deg); //现在沿着逆时针方向旋转120 o leg(n); //绘制第二条边 c.rotate(-120 * deg); //再次旋转 leg(n); //画最后一条边 c.closePath(); //闭合子路径 c.restore(); //恢复初始的变换 //绘制n级别的科赫雪花的一条边 //此函数在画完一条边的时候就离开当前点， //然后通过坐标系变换将当前点又转换成(0,0,) //这意味着画完一条边之后可以很简单地调用rotate()进行旋转 function leg(n) { c.save(); //保存当前坐标系变换 if (n == 0) { //不需要递归的情况下: c.lineTo(len, 0); //就绘制一条水平线段 } else { //递归情况下：绘制4条子边，类似这个样子： - \/ - c.scale(1 / 3, 1 / 3); //子边长度为原边长的1/3 leg(n - 1); //递归第一条子边 c.rotate(60 * deg); //顺时针旋转60 o leg(n - 1); //第二条子边 c.rotate(-120 * deg); //逆时针旋转120 o leg(n - 1); //第三条子边 c.rotate(60 * deg); //通过旋转回到初始状态 leg(n - 1); //最后一条边 } c.restore(); //恢复坐标系变换 c.translate(len, 0); //但是通过转换使得边的结束点为(0,0) } } ⬆ back to top 在Web Worker中发起同步XMLHtttpRequest//此文件会通过一个新的Worker()来载入，因此，它是运行在独立的线程中的， //可以放心地使用同步XMLHttpRequest API //消息是URL数组的形式。以字符串形式同步获取每个URL指定的内容， //并将这些字符串数组传递回去。 onmessage = function (e) { var urls = e.data; //输入：要获取的URL var contents = []; //输出：URL指定的内容 for (var i = 0; i &lt; urls.length; i++) { var url = urls[i]; //每个URL var xhr = new XMLHttpRequest(); //开始一个HTTP请求 xhr.open(&quot;GET&quot;, url, false); //false则表示进行同步请求 xhr.send(); //阻塞住，一直到响应完成 if (xhr.status !== 200) //如果请求失败则抛出错误 throw Error(xhr.status + &quot; &quot; + xhr.statusText + &quot;: &quot; + url); contents.push(xhr.responseText); //否则，存储通过URL获取得到的内容 } //最后，将这些URL内容以数组的形式传递回主线程 postMessage(contents); } 善于利用JS中的小技巧，不仅可以使代码更加简洁，而且逼格更高。 使用!!模拟Boolean()函数原理：逻辑非操作一个数据对象时，会先将数据对象转换为布尔值，然后取反，两个!!重复取反，就实现了转换为布尔值的效果。 使用一元加(+)模拟Number()函数原理：对非数值类型的数据使用一元加(+)，会起到与Number()函数相同的效果。 null转换为0 undefined转换为NaN false转换为0，true转换为1 对于字符串： 空字串转换为0 含有数字或者浮点数或者十六进制格式的数据(11, 0.3, 0xfe等)，转换为相应的数值 含有其他格式字符，无法转换为数值的字符串，转换为NaN 对于对象，先调用valueOf()方法，在转换，若结果为NaN，那么再调用toString()方法，之后再转换 使用逻辑与(&amp;&amp;)进行短路操作if(connected){ login(); } 以上代码可以简写为: connected &amp;&amp; login(); 也可用这种方法来检查对象中是否拥有某个属性 user &amp;&amp; user.name 原理：逻辑与(&amp;&amp;)会首先对第一个操作数进行求值，只有求值结果为true时才会对第二个操作数求值。connected &amp;&amp; login()中，若判断connected不为true,则不再进行下一步操作。所谓的短路操作即第一个操作数可以决定结果，则不再对第二个操作数进行求值。 使用逻辑或(||)设置默认值逻辑或(||)也属于短路操作，即当第一个操作数可以决定结果时，不再对第二个操作数进行求值。利用这个特点，我们可以给赋值语句设置默认值。只有当第一个操作数为null或者undefined时，才会把第二个操作数赋值给目标。 function User(name, age){ this.name = name || &quot;Liming&quot;; } 上述代码中，如果函数中没有传入name参数，name的值为undefined，那么就会给this.name赋值为”Liming”。ES6中可以为函数设置默认值，所以这种方法可能要成为过去式，但是其他地方还是很有用的。ES6 写法 简洁了许多 let User = (name=&quot;Liming&quot;, age) =&gt; { } 获取数组最后n个元素可以使用以下代码获取数组中最后n个元素 var array = [1, 2, 3, 4, 5, 6]; console.log(array.slice(-1)); //[6] console.log(array.slice(-2)); //[5, 6] 原理:Array.prototype.slice(begin,end)可以用来裁剪数组，第二个参数的默认值是数组的长度值。若值传入一个参数，则会返回从指定索引开始到数组结尾的所有值。而slice()方法还可以接收负值，当传入负值时，会自动加上数组的长度值使其转换为正值，于是便得到了最后的n个值。 合并大数组常用的合并数组的方式是使用Array.concat()函数。该函数会创建一个新数组，将两个数组连接起来存储到新数组中，这会大量消耗内存。可以使用Array.push.apply(arr1, arr2)，它不会创建新数组，而是将第二个数组合并到第一个数组中，以减少内存的消耗。 var a = [1,2]; var b = [3,4]; console.log(a.push.apply(a, b)); // [1,2,3,4] //或者 Array.prototype.push.apply(a, b); // a变成了[1,2,3,4] console.log(a); //[1,2,3,4] 原理: Array.push()是在数组的末尾增加元素，但是如果使用a.push(b)会把整个数组b当作一个元素添加到数组a中。而apply()方法，则允许将某个方法的参数以数组的形式传入，所以起到了将数组b中的元素追加到数组a中的效果。 NodeList转换为数组使用document.querySelectorAll(‘div’)返回的是NodeList对象，虽然它很像数组，但是并不能使用诸如sort()，filter()等方法。你可以将其转换为真正的数组。 var eles = document.querySelectorAll(&apos;p&apos;); //NodeList var arrayElements = [].slice.call(eles); //转化为数组 // 或者 var arrayElements = Array.prototype.slice.call(eles); // 或者 var arrayElements = Array.from(eles); 原理: [].slice.call(eles):首先创建了一个空数组[]，然后调用他的slice()方法，但是在slice()方法的执行中，把this对象指向了eles,所以会对eles进行裁减，由于对slice()方法没有传入参数，所以相当于slice(0,eles.length),会按照元长度返回一个数组。 Array.prototype.slice.call(eles): 原理与上面相似，只不过这次没有创建空数组，而是直接使用了原型中的方法]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈 instanceof 和 typeof 的实现原理]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%B5%85%E8%B0%88-instanceof-%E5%92%8C-typeof-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[typeof 实现原理typeof 一般被用于判断一个变量的类型，我们可以利用 typeof 来判断number, string, object, boolean, function, undefined,symbol 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，typeof能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，typeof 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如👉 let s =newString(&apos;abc&apos;); typeof s ===&apos;object&apos;// true s instanceofString// true 要想判断一个数据具体是哪一种 object 的时候，我们需要利用 instanceof 这个操作符来判断，这个我们后面会说到。 来谈谈关于 typeof 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？ 其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉1234567000：对象010：浮点数100：字符串110：布尔 1：整数 but, 对于 undefined 和 null 来说，这两个值的信息存储是有点特殊的。 null：所有机器码均为0 undefined：用 −2^30 整数来表示 所以，typeof 在判断 null 的时候就出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。 然而用 instanceof 来判断的话👉 nullinstanceofnull// TypeError: Right-hand side of &apos;instanceof&apos; is not an object null 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。 因此在用 typeof 来判断变量类型的时候，我们需要注意，最好是用 typeof 来判断基本数据类型（包括symbol），避免对 null 的判断。 还有一个不错的判断类型的方法，就是Object.prototype.toString，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断 Object.prototype.toString.call(1)// &quot;[object Number]&quot; Object.prototype.toString.call(&apos;hi&apos;)// &quot;[object String]&quot; Object.prototype.toString.call({a:&apos;hi&apos;})// &quot;[object Object]&quot; Object.prototype.toString.call([1,&apos;a&apos;])// &quot;[object Array]&quot; Object.prototype.toString.call(true)// &quot;[object Boolean]&quot; Object.prototype.toString.call(()=&gt;{})// &quot;[object Function]&quot; Object.prototype.toString.call(null)// &quot;[object Null]&quot; Object.prototype.toString.call(undefined)// &quot;[object Undefined]&quot; Object.prototype.toString.call(Symbol(1))// &quot;[object Symbol]&quot; instanceof 操作符的实现原理之前我们提到了 instanceof 来判断对象的具体类型，其实 instanceof 主要的作用就是判断一个实例是否属于某种类型 let person =function(){ } let nicole =new person() nicole instanceof person // true 当然，instanceof 也可以判断一个实例是否是其父类型或者祖先类型的实例。 let person =function(){ } let programmer =function(){ } programmer.prototype =new person() let nicole =new programmer() nicole instanceof person // true nicole instanceof programmer // true 这是 instanceof 的用法，但是 instanceof 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下 function new_instance_of(leftVaule, rightVaule){ let rightProto = rightVaule.prototype;// 取右表达式的 prototype 值 leftVaule = leftVaule.__proto__;// 取左表达式的__proto__值 while(true){ if(leftVaule ===null){ returnfalse; } if(leftVaule === rightProto){ returntrue; } leftVaule = leftVaule.__proto__ } } 其实 instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。因此，instanceof 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 prototype，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。看几个很有趣的例子 functionFoo(){ } Object instanceof Object// true Function instanceof Function// true Function instanceof Object// true Foo instanceof Foo// false Foo instanceof Object// true Foo instanceof Function// true 要想全部理解 instanceof 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。 关于原型继承的原理，我简单用一张图来表示 我们知道每个 JavaScript 对象均有一个隐式的 __proto__ 原型属性，而显式的原型属性是 prototype，只有 Object.prototype.__proto__ 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 instanceof 使用的例子。 Object instanceof Object 由图可知，Object 的 prototype 属性是 Object.prototype, 而由于 Object 本身是一个函数，由 Function 所创建，所以 Object.__proto__ 的值是 Function.prototype，而 Function.prototype 的 __proto__ 属性是 Object.prototype，所以我们可以判断出，Object instanceof Object 的结果是 true 。用代码简单的表示一下 leftValue =Object.__proto__ =Function.prototype; rightValue =Object.prototype; // 第一次判断 leftValue != rightValue leftValue =Function.prototype.__proto__ =Object.prototype // 第二次判断 leftValue === rightValue // 返回 true Function instanceof Function 和 Function instanceof Object 的运行过程与 Object instanceof Object 类似，故不再详说。 Foo instanceof Foo Foo 函数的 prototype 属性是 Foo.prototype，而 Foo 的 __proto__ 属性是 Function.prototype，由图可知，Foo 的原型链上并没有 Foo.prototype ，因此 Foo instanceof Foo 也就返回 false 。 我们用代码简单的表示一下 leftValue =Foo, rightValue =Foo leftValue =Foo.__proto =Function.prototype rightValue =Foo.prototype // 第一次判断 leftValue != rightValue leftValue =Function.prototype.__proto__ =Object.prototype // 第二次判断 leftValue != rightValue leftValue =Object.prototype =null // 第三次判断 leftValue ===null // 返回 false Foo instanceof Object leftValue =Foo, rightValue =Object leftValue =Foo.__proto__ =Function.prototype rightValue =Object.prototype // 第一次判断 leftValue != rightValue leftValue =Function.prototype.__proto__ =Object.prototype // 第二次判断 leftValue === rightValue // 返回 true Foo instanceof Function leftValue =Foo, rightValue =Function leftValue =Foo.__proto__ =Function.prototype rightValue =Function.prototype // 第一次判断 leftValue === rightValue // 返回 true 总结简单来说，我们使用 typeof 来判断基本数据类型是 ok 的，不过需要注意当用 typeof 来判断 null 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 instanceof，但是 instanceof 也可能判断不准确，比如一个数组，他可以被 instanceof 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 Object.prototype.toString.call 方法。]]></content>
      <tags>
        <tag>typeof</tag>
        <tag>instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你可能会忽略的vue-router技巧]]></title>
    <url>%2F2018%2F10%2F03%2F%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BF%BD%E7%95%A5%E7%9A%84vue-router%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[说到Vue权限控制，你可能会第一个想到123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Created by superman on 17/2/16. * http配置 */import axios from &apos;axios&apos;import store from &apos;./store/store&apos;import * as types from &apos;./store/types&apos;import router from &apos;./router&apos;// axios 配置axios.defaults.timeout = 5000;axios.defaults.baseURL = &apos;https://api.github.com&apos;;// http request 拦截器axios.interceptors.request.use( config =&gt; &#123; if (store.state.token) &#123; config.headers.Authorization = `token $&#123;store.state.token&#125;`; &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;);// http response 拦截器axios.interceptors.response.use( response =&gt; &#123; return response; &#125;, error =&gt; &#123; if (error.response) &#123; switch (error.response.status) &#123; case 401: // 401 清除token信息并跳转到登录页面 store.commit(types.LOGOUT); router.replace(&#123; path: &apos;login&apos;, query: &#123;redirect: router.currentRoute.fullPath&#125; &#125;) &#125; &#125; // console.log(JSON.stringify(error));//console : Error: Request failed with status code 402 return Promise.reject(error.response.data) &#125;);export default axios; VueRouter12345678910111213141516const router = new VueRouter(&#123; routes&#125;)router.beforeEach((to, from, next) =&gt; &#123; if (to.path == &apos;/login&apos;) &#123; //清除token ... &#125; let token = get(&apos;token&apos;); //获取token if (!token &amp;&amp; to.path != &apos;/login&apos;) &#123; next(&#123; path: &apos;/login&apos; &#125;) &#125; else &#123; next() &#125;&#125;) 但上面的只能对登录拦截,跳转拦截，不能控制user权限，最好的方式是动态注入路由addRoutes1234import router from &apos;./router&apos;router.addRoutes(routes)或者this.$router.addRoutes(routers)]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue手势库]]></title>
    <url>%2F2018%2F10%2F03%2FVue%E6%89%8B%E5%8A%BF%E5%BA%93%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111function vueTouch(el, binding, type) &#123; var _this = this; this.obj = el; this.binding = binding; this.touchType = type; this.vueTouches = &#123; x: 0, y: 0 &#125;; this.vueMoves = true; this.vueLeave = true; this.longTouch = true; this.vueCallBack = typeof(binding.value) == &quot;object&quot; ? binding.value.fn : binding.value; this.obj.addEventListener(&quot;touchstart&quot;, function(e) &#123; _this.start(e); &#125;, false); this.obj.addEventListener(&quot;touchmove&quot;, function(e) &#123; _this.move(e); &#125;, false); this.obj.addEventListener(&quot;touchend&quot;, function(e) &#123; _this.end(e); &#125;, false);&#125;;vueTouch.prototype = &#123; start(e) &#123; this.vueMoves = true; this.vueLeave = true; this.longTouch = true; this.vueTouches = &#123; x: e.changedTouches[0].pageX, y: e.changedTouches[0].pageY &#125;; this.time = setTimeout(function() &#123; if(this.vueLeave &amp;&amp; this.vueMoves) &#123; this.touchType == &quot;longtap&quot; &amp;&amp; this.vueCallBack(this.binding.value, e); this.longTouch = false; &#125;; &#125;.bind(this), 1000); &#125;, end(e) &#123; var disX = e.changedTouches[0].pageX - this.vueTouches.x; var disY = e.changedTouches[0].pageY - this.vueTouches.y; clearTimeout(this.time); if(Math.abs(disX) &gt; 10 || Math.abs(disY) &gt; 100) &#123; this.touchType == &quot;swipe&quot; &amp;&amp; this.vueCallBack(this.binding.value, e); if(Math.abs(disX) &gt; Math.abs(disY)) &#123; if(disX &gt; 10) &#123; this.touchType == &quot;swiperight&quot; &amp;&amp; this.vueCallBack(this.binding.value, e); &#125;; if(disX &lt; -10) &#123; this.touchType == &quot;swipeleft&quot; &amp;&amp; this.vueCallBack(this.binding.value, e); &#125;; &#125; else &#123; if(disY &gt; 10) &#123; this.touchType == &quot;swipedown&quot; &amp;&amp; this.vueCallBack(this.binding.value, e); &#125;; if(disY &lt; -10) &#123; this.touchType == &quot;swipeup&quot; &amp;&amp; this.vueCallBack(this.binding.value, e); &#125;; &#125;; &#125; else &#123; if(this.longTouch &amp;&amp; this.vueMoves) &#123; this.touchType == &quot;tap&quot; &amp;&amp; this.vueCallBack(this.binding.value, e); this.vueLeave = false &#125;; &#125;; &#125;, move(e) &#123; this.vueMoves = false; &#125;&#125;;Vue.directive(&quot;tap&quot;, &#123; bind: function(el, binding) &#123; new vueTouch(el, binding, &quot;tap&quot;); &#125;&#125;);Vue.directive(&quot;swipe&quot;, &#123; bind: function(el, binding) &#123; new vueTouch(el, binding, &quot;swipe&quot;); &#125;&#125;);Vue.directive(&quot;swipeleft&quot;, &#123; bind: function(el, binding) &#123; new vueTouch(el, binding, &quot;swipeleft&quot;); &#125;&#125;);Vue.directive(&quot;swiperight&quot;, &#123; bind: function(el, binding) &#123; new vueTouch(el, binding, &quot;swiperight&quot;); &#125;&#125;);Vue.directive(&quot;swipedown&quot;, &#123; bind: function(el, binding) &#123; new vueTouch(el, binding, &quot;swipedown&quot;); &#125;&#125;);Vue.directive(&quot;swipeup&quot;, &#123; bind: function(el, binding) &#123; new vueTouch(el, binding, &quot;swipeup&quot;); &#125;&#125;);Vue.directive(&quot;longtap&quot;, &#123; bind: function(el, binding) &#123; new vueTouch(el, binding, &quot;longtap&quot;); &#125;&#125;); 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html id=&quot;html&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .box &#123; width: 250px; height: 250px; background-color: red; color: #FFFFFF; text-align: center; line-height: 250px; font-size: 30px; position: absolute; margin: auto; left: 0; right: 0; top: 0; bottom: 0; &#125; &lt;/style&gt; &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue-touch.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot; class=&quot;box&quot; v-tap=&quot;&#123;fn:vuetap,name:&apos;点击&apos;&#125;&quot; v-longtap=&quot;&#123;fn:vuetap,name:&apos;长按&apos;&#125;&quot; v-swipeleft=&quot;&#123;fn:vuetap,name:&apos;左滑&apos;&#125;&quot; v-swiperight=&quot;&#123;fn:vuetap,name:&apos;右滑&apos;&#125;&quot; v-swipeup=&quot;&#123;fn:vuetap,name:&apos;上滑&apos;&#125;&quot; v-swipedown=&quot;&#123;fn:vuetap,name:&apos;下滑&apos;&#125;&quot;&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;!-- vuetouch为函数名，如没有参数，可直接写函数名,比如：v-tap=&quot;vuetap&quot; 如果有参数以对象形式传，fn 为函数名--&gt; &lt;script&gt; kim = new Vue(&#123; el: &quot;#app&quot;, data: &#123; name: &quot;开始&quot; &#125;, methods: &#123; vuetap: function(s, e) &#123; console.log(e) this.name = s.name; &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[async/await 小技巧]]></title>
    <url>%2F2018%2F10%2F03%2Fasync-await-%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[async/await 小技巧sleep 函数以前只接使用 setTimeout 和回调函数实现一个 sleep 会有很多的副作用，用起来很不方便。 所以让 setTimeout 搭配使用 async/await constsleep=delay=&gt; { returnnewPromise(resolve=&gt; { setTimeout(resolve, delay) }) } constfn=async_=&gt; { console.log(&apos;starting....&apos;) awaitsleep(1000) console.log(&apos;after sleeping for 1 second&apos;) } 搭配 map() 函数在 map 中引入异步处理: constarr= [1,2,3,4,5] constasyncFn=data=&gt; { // 异步处理函数 } constresults=arr.map(asyncnum=&gt; { awaitasyncFn(num) return++num }) console.log(results) 代码执行后的结果 [Promise, Promise, Promise, Promise, Promise] 而且 map 函数并不会等异步函数 asyncFn 执行完毕后再返回结果 既然 async 执行后会返回一个 Promise 对象，所以可以通过 Promise.all 的状态来判断异步函数的状态: constarr= [1,2,3,4,5] constasyncFn=data=&gt; { // 异步处理函数 } constp=arr.map(asyncnum=&gt; { awaitasyncFn(num) return++num }) Promise.all(p).then(results=&gt; { console.log(results) }) 这样就能正常返回结果 [2, 3, 4, 5, 6] 使用 await 代替 then() 函数上面的例子最后使用了 Promise.all 还是回到了使用回调函数的方式 这个也很好解决，只需要在外层再加一个 async 函数 constmain=async_=&gt; { constresults=awaitPromise.all(arr.map(num=&gt; { awaitasyncFn() return++num })) console.log(results) } main() 搭配 reduce() 函数通过引入 async/await 可以把 reduce 扩展成一个按顺序执行异步函数的工具 reduce 用起来很简单: constarr= [1,2,3,4,5] constresult=arr.reduce((prev, next) =&gt; { return prev+next }, 0) console.log(result) 像 map 函数一样引入 async/await : constarr= [1,2,3,4,5] constmain=async_=&gt; { constresult=awaitarr.reduce(async (prev, next) =&gt; { consttmp=await prev return tmp + next }, Promise.resolve(0)) console.log(result) } main() 而且还可以在 reduce 内部加入异步函数: constarr= [1,2,3,4,5] constmain=async_=&gt; { constresult=awaitarr.reduce(async (prev, next) =&gt; { consttmp=await prev // 异步处理 暂停1sawaitsleep(1000) console.log(tmp + next) return tmp + next }, Promise.resolve(0)) } main() 上述代码会每隔一秒依次打出 1 3 6 10 15 参考自 http://2ality.com/2016/10/async-function-tips.html]]></content>
      <tags>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Event Loop 必知必会（六道题）]]></title>
    <url>%2F2018%2F10%2F03%2FEvent-Loop-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%88%E5%85%AD%E9%81%93%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一直想写一篇关于 Event Loop 的文章，前不久发现 CNode 上有位同学写了一篇原理分析的文章很详细，这里我就不献丑了。本文就拿出六道题来补充一下，放出一张我认为非常直观的图。绿色小块是 macrotask（宏任务），macrotask 中间的粉红箭头是 microtask（微任务）。 题目一setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)}) 运行结果： setImmediate setTimeout 或者： setTimeout setImmediate 为什么结果不确定呢？ 解释：setTimeout/setInterval 的第二个参数取值范围是：[1, 2^31 - 1]，如果超过这个范围则会初始化为 1，即 setTimeout(fn, 0) === setTimeout(fn, 1)。我们知道 setTimeout 的回调函数在 timer 阶段执行，setImmediate 的回调函数在 check 阶段执行，event loop 的开始会先检查 timer 阶段，但是在开始之前到 timer 阶段会消耗一定时间，所以就会出现两种情况： timer 前的准备时间超过 1ms，满足 loop-&gt;time &gt;= 1，则执行 timer 阶段（setTimeout）的回调函数 timer 前的准备时间小于 1ms，则先执行 check 阶段（setImmediate）的回调函数，下一次 event loop 执行 timer 阶段（setTimeout）的回调函数 再看个例子： setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})conststart=Date.now()while(Date.now()-start&lt;10); 运行结果一定是： setTimeout setImmediate 题目二constfs=require(&apos;fs&apos;)fs.readFile(__filename,()=&gt;{setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})}) 运行结果： setImmediate setTimeout 解释：fs.readFile 的回调函数执行完后： 注册 setTimeout 的回调函数到 timer 阶段 注册 setImmediate 的回调函数到 check 阶段 event loop 从 pool 阶段出来继续往下一个阶段执行，恰好是 check 阶段，所以 setImmediate 的回调函数先执行 本次 event loop 结束后，进入下一次 event loop，执行 setTimeout 的回调函数 所以，在 I/O Callbacks 中注册的 setTimeout 和 setImmediate，永远都是 setImmediate 先执行。 题目三setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)process.nextTick(functiontick(){process.nextTick(tick)}) 运行结果：setInterval 永远不会打印出来。 解释：process.nextTick 会无限循环，将 event loop 阻塞在 microtask 阶段，导致 event loop 上其他 macrotask 阶段的回调函数没有机会执行。 解决方法通常是用 setImmediate 替代 process.nextTick，如下： setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)setImmediate(functionimmediate(){setImmediate(immediate)}) 运行结果：每 100ms 打印一次 setInterval。 解释：process.nextTick 内执行 process.nextTick 仍然将 tick 函数注册到当前 microtask 的尾部，所以导致 microtask 永远执行不完； setImmediate 内执行 setImmediate 会将 immediate 函数注册到下一次 event loop 的 check 阶段，而不是当前正在执行的 check 阶段，所以给了 event loop 上其他 macrotask 执行的机会。 再看个例子： setImmediate(()=&gt;{console.log(&apos;setImmediate1&apos;)setImmediate(()=&gt;{console.log(&apos;setImmediate2&apos;)})process.nextTick(()=&gt;{console.log(&apos;nextTick&apos;)})})setImmediate(()=&gt;{console.log(&apos;setImmediate3&apos;)}) 运行结果： setImmediate1 setImmediate3 nextTick setImmediate2 注意：并不是说 setImmediate 可以完全替代 process.nextTick，process.nextTick 在特定场景下还是无法被替代的，比如我们就想将一些操作放到最近的 microtask 里执行。 题目四constpromise=Promise.resolve().then(()=&gt;{returnpromise})promise.catch(console.error) 运行结果： TypeError: Chaining cycle detected for promise #&lt;Promise&gt; at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) at Function.Module.runMain (module.js:667:11) at startup (bootstrap_node.js:187:16) at bootstrap_node.js:607:3 解释：promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码会导致死循环，类似前面提到的： process.nextTick(functiontick(){process.nextTick(tick)}) 再看个例子： constpromise=Promise.resolve() promise.then(()=&gt;{ console.log(&apos;promise&apos;)}) process.nextTick(()=&gt;{ console.log(&apos;nextTick&apos;) }) 运行结果： nextTick promise 解释：promise.then 虽然和 process.nextTick 一样，都将回调函数注册到 microtask，但优先级不一样。process.nextTick 的 microtask queue 总是优先于 promise 的 microtask queue 执行。 题目五setTimeout(()=&gt;{ console.log(1) },0) newPromise((resolve,reject)=&gt;{ console.log(2) for(leti=0;i&lt;10000;i++){ i===9999&amp;&amp;resolve() } console.log(3) }).then(()=&gt;{ console.log(4) }) console.log(5) 运行结果： 解释：Promise 构造函数是同步执行的，所以先打印 2、3，然后打印 5，接下来 event loop 进入执行 microtask 阶段，执行 promise.then 的回调函数打印出 4，然后执行下一个 macrotask，恰好是 timer 阶段的 setTimeout 的回调函数，打印出 1。 题目六setImmediate(()=&gt;{ console.log(1) setTimeout(()=&gt;{ console.log(2) },100) setImmediate(()=&gt;{ console.log(3) }) process.nextTick( ()=&gt;{console.log(4)}) }) process.nextTick(()=&gt;{ console.log(5) setTimeout(()=&gt;{ console.log(6)},100) setImmediate(()=&gt;{ console.log(7)}) process.nextTick( ()=&gt;{console.log(8)}) })console.log(9) 运行结果： process.nextTick、setTimeout 和 setImmediate 的组合，请读者自己推理吧。 参考链接 https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c https://cnodejs.org/topic/57d68794cb6f605d360105bf]]></content>
      <tags>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的 Promise 对象黑科技]]></title>
    <url>%2F2018%2F10%2F03%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-Promise-%E5%AF%B9%E8%B1%A1%E9%BB%91%E7%A7%91%E6%8A%80%2F</url>
    <content type="text"><![CDATA[Promise 必知必会（十道题）一、resolve 后的执行情况无论是 resolve, reject，都会将函数剩余的代码执行完 const promise = new Promise((resolve, reject) =&gt; { console.log(&apos;mark 1&apos;); resolve(&apos;hello world&apos;); // reject(&apos;hello world&apos;); console.log(&apos;mark 2&apos;); }); promise.then(result =&gt; { console.log(result); }).catch(err =&gt; { console.log(err); }); 相当于： const promise = new Promise((resolve, reject) =&gt; { console.log(&apos;mark 1&apos;); console.log(&apos;mark 2&apos;); resolve(&apos;hello world&apos;); // reject(&apos;hello world&apos;); }); promise.then(result =&gt; { console.log(result); }).catch(err =&gt; { console.log(err); }); 如果你不想在 resolve 或 reject 后执行剩下的代码段，可以在 resolve 后将其返回 const promise = new Promise((resolve, reject) =&gt; { console.log(&apos;mark 1&apos;); return resolve(&apos;hello world&apos;); // reject(&apos;hello world&apos;); console.log(&apos;mark 2&apos;); // never be here }); promise.then(result =&gt; { console.log(result); }).catch(err =&gt; { console.log(err); }); 二、串行执行和并行执行： 串行执行：有一堆 Promise 对象，它们的执行顺序是固定的，前一个 promise 执行完后，后一个 promise 才开始执行，比如数据库查询，它们往往有前后的因果关系。 并行执行：有一堆 Promise 对象，它们的执行顺序是不固定的，没有前后因果关系，可以并发地去执行。 并行执行很好解决，在 Promise中有 all 这个函数支持, Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。当多个 Promise 实例执行完后才去执行最后新的 Promise 实例。 const datum = []; for(let i = 0; i &lt; 10; i++) { datum.push(i); } Promise.all(datum.map(i =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(i * 200 + &quot; ms 后执行结束&quot;); resolve(&quot;第 &quot; + (i + 1) + &quot; 个 Promise 执行结束&quot;); }, i * 200); }) })).then((data) =&gt; { console.log(data); }); 如果不使用 Promise.all 这个方法的话，你也可以使用像 ES7 的 async/await const asyncFun = async () =&gt; { const datum = [] for(let i = 0; i &lt; 10; i++) { datum.push(new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(i * 200 + &apos;ms 后执行结束&apos;) resolve(&apos;第 &apos; + (i + 1) + &apos; 个 Promise 执行结束&apos;) }, i * 200) })) } const result = [] for(let promise of datum) { result.push(await promise) } console.log(result) } asyncFun() 串行执行：这里提供两种方式 const datum = []; for(let i = 0; i &lt; 10; i++) { datum.push(i); } let serial = Promise.resolve(); for(let i of datum) { serial = serial.then(data =&gt; { console.log(data); return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(i * 200 + &quot; ms 后执行结束&quot;); resolve(&quot;第 &quot; + (i + 1) + &quot; 个 Promise 执行结束&quot;); }, i * 200); }) }); } 另外可以使用 reduce 来串行： const datum = []; for(let i = 0; i &lt; 10; i++) { datum.push(i); } datum.reduce((prev, cur) =&gt; { return prev.then(data =&gt; { console.log(data); return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(cur * 200 + &quot; ms 后执行结束&quot;); resolve(&quot;第 &quot; + (cur + 1) + &quot; 个 Promise 执行结束&quot;); }, cur * 200); }) }) }, Promise.resolve(true)); 三、值穿透问题：let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&apos;Hello World!&apos;); }, 1000) }); promise.then(&apos;呵呵哒&apos;).then((data) =&gt; { console.log(data); // Hello World }) 这是一种值穿透的情况，一般有下面两种情况：promise 已经是 FULFILLED/REJECTED 时，通过 return this 实现的值穿透： let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&apos;Hello World!&apos;); }, 1000) }); promise.then(() =&gt; { promise.then().then(null).then(&apos;呵呵哒&apos;).then((res) =&gt; { console.log(res) }) promise.catch().catch(null).then(&apos;呵呵哒&apos;).then((res) =&gt; { console.log(res) }) }) promise 是 PENDING 时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态和值。如： let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&apos;Hello World!&apos;); }, 1000) }); let a = promise.then(&apos;呵呵哒&apos;); a.then(res =&gt; { console.log(res); }); let b = promise.catch(&apos;呵呵哒&apos;); b.then(res =&gt; { console.log(res); }) 总而言之，当你给 then() 传递一个非函数（比如一个 promise ）值的时候，它实际上会解释为 then(null) ，这会导致之前的 promise 的结果丢失。例如: Promise.resolve(&apos;First Value&apos;).then(Promise.resolve(&apos;Second Value&apos;)).then(null).then((value) =&gt; { console.log(value) // First Value }) 四、不要在异步回调函数中使用 throw Error不仅 reject，抛出的异常也会被作为拒绝状态被 Promise 捕获 let promise = new Promise((resolve, reject) =&gt; { reject(&apos;This is an error&apos;); }); promise.then(result =&gt; { console.log(result); }).catch(error =&gt; { console.log(&apos;handle error: &apos;, error); //handle error: Error: This is an error }) 但是，永远不要在回调队列中抛出异常，因为回调队列脱离了运行上下文环境，异常无法被当前作用域捕获。 let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { throw Error(&apos;This is an error&apos;); }); }); promise.then(result =&gt; { console.log(result); }).catch(error =&gt; { console.log(&apos;handle error: &apos;, error); // Error: This is an error }); 简单说来，回调队列指的是 JS 事件循环中的 macrotask 队列，比如 setTimeout setInterval 会插入到 macrotask 中。如果要在回调函数中捕获异常，请使用 reject，永远不要使用 Error。上述的代码应改成： let promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&apos;This is an error&apos;); }); }); promise.then(result =&gt; { console.log(result); }).catch(error =&gt; { console.log(&apos;handle error: &apos;, error); // Error: This is an error }); 五、then 的第二个参数跟 catch 的区别 【面试常问】我们都知道 then 的第二参数跟 catch 用法很像，都是用来进行错误处理的，比如下面这段代码： let promise1 = new Promise((resolve, reject) =&gt; { reject(&apos;this is an error&apos;); }); promise1.then(data =&gt; { console.log(data); }, err =&gt; { console.log(&apos;handle err:&apos;, err); // handle err: this is an error }); let promise2 = new Promise((resolve, reject) =&gt; { reject(&apos;this is an error&apos;); }); promise2.then(data =&gt; { console.log(data); }).catch(err =&gt; { console.log(&apos;handle err:&apos;, err); // handle err: this is an error }); 当时这两者还是区别的，区别于 then 的第二参数无法处理第一参数函数中的错误。 let promise1 = Promise.resolve(); promise1.then(() =&gt; { throw Error(&apos;this is a error&apos;); //UnhandledPromiseRejectionWarning: Unhandled promise rejection }, err =&gt; { console.log(err); }) let promise2 = Promise.resolve(); promise2.then(() =&gt; { throw Error(&apos;this is a error&apos;); }).catch(err =&gt; { console.log(&apos;handle err:&apos;, err); //handle err: Error: this is a error }) 当你使用then( resolveHandler, rejectHandler)格式，如果 resolveHandler 自己抛出一个错误 rejectHandler 并不能捕获。第一个 Promise 对象无法处理同级 then 中的函数抛出的异常，所以在一般情况下，最后直接使用 catch 来进行异常捕获比较保险。 六、处理最后 catch 函数中的异常一般我们用 catch 来捕捉前面抛出的异常，但是如果试想一下如果最后一个 catch 函数也抛出了异常，应该怎么处理呢? let promise = new Promise((resolve, reject) =&gt; { reject(&apos;Hello World&apos;) }); promise.catch((err) =&gt; { throw(&apos;Unexpected Error&apos;); // Uncaught (in promise) Unexpected Error }) 面对这样的错误，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）这里提供两种思路： 拓展 Promise.prototype 的方法，添加一个 done 函数，将错误抛向全局。 window.onerror = (err) =&gt; { console.log(err); } Promise.prototype.done = function (onFulfilled, onRejected) { this.then(onFulfilled, onRejected) .catch(function (reason) { // 抛出一个全局错误 setTimeout(() =&gt; { throw reason }, 0); }); }; let promise = new Promise((resolve, reject) =&gt; { reject(&apos;Hello World&apos;) }); promise.catch((err) =&gt; { throw(&apos;Unexpected Error&apos;); // Uncaught Unexpected Error }).done() 在全局添加 unhandledrejection 事件捕获 Promise 异常。 window.addEventListener(&quot;unhandledrejection&quot;, (e) =&gt;{ console.log(e.reason) }) let promise = new Promise((resolve, reject) =&gt; { reject(&apos;Hello World&apos;) }); promise.catch((err) =&gt; { throw(&apos;Unexpected Error&apos;); // Unexpected Error }) 七、未捕获的错误可以被恢复let promise = new Promise((resolve, reject) =&gt; [ reject(&apos;Hello world&apos;) ]).then(() =&gt; { console.log(&apos;resolve&apos;) }) setTimeout(() =&gt; { promise.catch((e) =&gt; { console.log(e) }).then(() =&gt; { console.log(&apos;catch resolve&apos;) }) }, 1000) 八、resolved 状态的 Promise 不会立即执行let i = 0; Promise.resolve(&apos;resolved promise&apos;).then(() =&gt; { i += 2 }) console.log(i) // 0 即使是 resolve 的 Promise 调用 then 方法也是异步执行。 九、结合 async/await 编写同步代码 async/await 函数可以帮助我们彻底摆脱回调地狱的烦恼，用一种同步的方式来编写异步函数。 await 后面可以接数值，如果是异步请求的话可以接 Thunk 函数和 Promise 对象。 const timeout = (ms) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(ms + &apos; passed&apos;) }, ms) }) } const asyncFunc = async () =&gt; { const value1 = await timeout(2000) console.log(value1) const value2 = await timeout(2000) console.log(value2) } asyncFunc() console.log(&apos;now&apos;) 十、调用 then 方法返回新的 Promise 对象let promise1 = new Promise((resolve) =&gt; { resolve(&apos;Hello world&apos;) }) let promise2 = promise1.then() console.log(promise1 === promise2) // false console.log(promise1 instanceof Promise) // true console.log(promise2 instanceof Promise) // true 每次调用 then 方法后都会返回一个新的 Promise 对象，并不是返回原本的 Promise 对象。]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我也来实现一把MVVM]]></title>
    <url>%2F2018%2F10%2F03%2F%E6%88%91%E4%B9%9F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%8A%8AMVVM%2F</url>
    <content type="text"><![CDATA[大家都知道，vue是个MVVM框架，能够实现view和model的双向绑定，不像backbone那样，model改变需要手动去通知view更新，而vue实现的原理就是通过Object.defineProperty实现数据挟持，定义setter，然后数据改变的时候通知视图更新。 下面是网上vue的实现原理图： 实现效果 1、MVVM入口文件，在这里对vue当中的$el、methods、$data进行初始化，调用observer遍历$data的数据并进行挟持，调用compile遍历$el下的所有节点，解析指令和取值操作。遍历$data的数据，通过Object.defineProperty的getter和setter实现对$data的代理。 2、Observer遍历data，通过Object.defineProperty设置getter和setter，在setter知道数据发生了改变，然后通知Wacher去更新view。 3、Compile遍历$el下的所有节点，解析指令和取值操作等，为每个节点绑定更新函数（为什么在compile这里绑定呢？因为这里刚好是遍历的节点☺），绑定事件和method的关系，同时也添加订阅者，当接受到视图更新的订阅消息后，调用更新函数，实现视图更新。同时在添加订阅者的时候，初始化渲染视图。 4、WatcherWatcher作为订阅者，充当Observer和Compile的中间桥梁，包含update方法，update方法调用Compile中绑定的事件更新函数，实现对视图的初始化和更新操作。 MVVM的实现MVVM完成初始化操作，并且调用observer和compile。对$data进行代理，如此便可以通过this.attribute来代理this.$data.attribute。因为一个属性可能对应多个指令，所以需要一个_binding属性来存放属性对应的所有订阅者，这样属性一改变，就可以取出所有的订阅者去更新视图。 function MVVM(options) { // 初始化 this.$data = options.data; this.$methods = options.methods; this.$el = options.el; // 保存data的每个属性对应的所有watcher this._binding = {}; // 调用observer和compile this._observer(options.data); this._compile(); // this.xxx 代理this.$data.xxx this.proxyAttribute(); } Observer的实现Observer遍历$data，通过Object.defineProperty的setter的挟持数据改变，监听到数据改变后取出所有该属性对应的订阅者，然后通知更新函数更新视图。 注意：这里有循环，且闭包（getter和setter）里面需要依赖循环项（value和key），所以用立即执行函数解决循环项获取不对的问题。 MVVM.prototype._observer = function(data) { var self = this; for(var key in this.$data) { if (this.$data.hasOwnProperty(key)) { // 初始化属性对应的订阅者容器（数组） this._binding[key] = { _directives: [], _texts: [] }; if(typeof this.$data[key] === &quot;object&quot;) { return this._observer(this.$data[key]); } var val = data[key]; // 立即执行函数获取正确的循环项 (function(value, key) { Object.defineProperty(self.$data, key, { enumerable: true, configurable: true, get: function() { return value; }, set(newval) { if(newval === value) { return; } value = newval; // 监听到数据改变后取出所有该属性对应的订阅者，通知view更新-属性 if(self._binding[key]._directives) { self._binding[key]._directives.forEach(function(watcher) { watcher.update(); }, self); } // 监听到数据改变后取出所有该属性对应的订阅者，通知view更新-文本 if(self._binding[key]._texts) { self._binding[key]._texts.forEach(function(watcher) { watcher.update(); }, self); } } }); })(val, key); } } } Compile的实现Compile遍历所有的节点，解析指令，为每个节点绑定更新函数，且添加订阅者，当订阅者通知view更新的时候，调用更新函数，实现对视图的更新。 这里同样需要使用立即执行函数来解决闭包依赖的循环项问题。 还有一点需要解决的是，如果节点的innerText依赖多个属性的话，如何做到只替换改变属性对应的文本问题。 比如：已经被编译解析成“欢迎： 鸣人”，如果message改变为“你好”，怎么让使得“欢迎：鸣人”改为“你好：鸣人”。 MVVM.prototype._compile = function() { var dom = document.querySelector(this.$el); var children = dom.children; var self = this; var i = 0, j = 0; // 更新函数，但observer中model的数据改变的时候，通过Watcher的update调用更新函数，从而更新dom var updater = null; for(; i &lt; children.length; i++) { var node = children[i]; (function(node) { // 解析{{}}里面的内容 // 保存指令原始内容，不然数据更新时无法完成替换 var text = node.innerText; var matches = text.match(/{{([^{}]+)}}/g); if(matches &amp;&amp; matches.length &gt; 0) { // 保存和node绑定的所有属性 node.bindingAttributes = []; for(j = 0; j &lt; matches.length; j++) { // data某个属性 var attr = matches[j].match(/{{([^{}]+)}}/)[1]; // 将和该node绑定的data属性保存起来 node.bindingAttributes.push(attr); (function(attr) { updater = function() { // 改变的属性值对应的文本进行替换 var innerText = text.replace(new RegExp(&quot;{{" + attr + "}}&quot;, &quot;g&quot;), self.$data[attr]); // 如果该node绑定多个属性 eg:&lt;div&gt;{{title}}{{description}}&lt;/div&gt; for(var k = 0; k &lt; node.bindingAttributes.length; k++) { if(node.bindingAttributes[k] !== attr) { // 恢复原来没改变的属性对应的文本 innerText = innerText.replace(&quot;{{" + node.bindingAttributes[k] + "}}&quot;, self.$data[node.bindingAttributes[k]]); } } node.innerText = innerText; } self._binding[attr]._texts.push(new Watcher(self, attr, updater)); })(attr); } } // 解析vue指令 var attributes = node.getAttributeNames(); for(j = 0; j &lt; attributes.length; j++) { // vue指令 var attribute = attributes[j]; // DOM attribute var domAttr = null; // 绑定的data属性 var vmDataAttr = node.getAttribute(attribute); if(/v-bind:([^=]+)/.test(attribute)) { // 解析v-bind domAttr = RegExp.$1; // 更新函数 updater = function(val) { node[domAttr] = val; } // data属性绑定多个watcher self._binding[vmDataAttr]._directives.push( new Watcher(self, vmDataAttr, updater) ) } elseif(attribute === &quot;v-model&quot; &amp;&amp; (node.tagName = &apos;INPUT&apos; || node.tagName == &apos;TEXTAREA&apos;)) { // 解析v-model // 更新函数 updater = function(val) { node.value = val; } // data属性绑定多个watcher self._binding[vmDataAttr]._directives.push( new Watcher(self, vmDataAttr, updater) ) // 监听input/textarea的数据变化，同步到model去，实现双向绑定 node.addEventListener(&quot;input&quot;, function(evt) { var $el = evt.currentTarget; self.$data[vmDataAttr] = $el.value; }); } elseif(/v-on:([^=]+)/.test(attribute)) { // 解析v-on var event = RegExp.$1; var method = vmDataAttr; node.addEventListener(event, function(evt) { self.$methods[method] &amp;&amp; self.$methods[method].call(self, evt); }); } } })(node); } } Watcher的实现Watcher充当订阅者的角色，架起了Observer和Compile的桥梁，Observer监听到数据变化后，通知Wathcer更新视图(调用Wathcer的update方法)，Watcher再告诉Compile去调用更新函数，实现dom的更新。同时页面的初始化渲染也交给了Watcher（当然也可以放到Compile进行）。 function Watcher(vm, attr, cb) { this.vm = vm; // viewmodel this.attr = attr; // data的属性，一个watcher订阅一个data属性 this.cb = cb; // 更新函数，在compile那边定义 // 初始化渲染视图 this.update(); } Watcher.prototype.update = function() { // 通知comile中的更新函数更新dom this.cb(this.vm.$data[this.attr]); } 全部代码git地址：github.com/VikiLee/MVV… 鸣谢：juejin.im/post/5acc17… 使用例子&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;view&quot;&gt; &lt;div v-bind:id=&quot;id&quot;&gt; {{message}}:{{name}} &lt;/div&gt; &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt; &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script src=&quot;js/MVVM.js&quot;type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script&gt; var vue = new MVVM({ el: &quot;#view&quot;, data: { message: &quot;欢迎光临&quot;, name: &quot;鸣人&quot;, id: &quot;id&quot; }, methods: { handleClick: function() { alert(this.message + &quot;:&quot; + this.name + &quot;, 点击确定路飞会出来&quot;); this.name = &apos;路飞&apos;; } } }) setTimeout(function() { vue.message = &quot;你好&quot;; }, 1000); &lt;/script&gt; &lt;/html&gt;]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise 必知必会]]></title>
    <url>%2F2018%2F10%2F02%2FPromise-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[你不知道的 Promise 对象黑科技Promise 想必大家都十分熟悉，想想就那么几个 api，可是你真的了解 Promise 吗？本文根据 Promise 的一些知识点总结了十道题，看看你能做对几道。 以下 promise 均指代 Promise 实例，环境是 Node.js。 题目一const promise = new Promise((resolve, reject) =&gt; { console.log(1) resolve() console.log(2) }) promise.then(() =&gt; { console.log(3) }) console.log(4) 运行结果： 1 2 4 3 解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。 题目二const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(&apos;success&apos;) }, 1000) }) console.log(promise) promise .then(() =&gt; { console.log(promise) throw new Error(&apos;error!!!&apos;) }) .catch(err =&gt; { console.log(promise) }) 运行结果： Promise { &lt;pending&gt; } Promise { &apos;success&apos; } Promise { &apos;success&apos; } 解释：promise 有 3 种状态：pending、fulfilled 和 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。 题目三const promise = new Promise((resolve, reject) =&gt; { resolve(&apos;success1&apos;) reject(&apos;error&apos;) resolve(&apos;success2&apos;) }) promise .then((res) =&gt; { console.log(&apos;then: &apos;, res) }) .catch((err) =&gt; { console.log(&apos;catch: &apos;, err) }) 运行结果： then: success1 解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。 题目四Promise.resolve(1) .then((res) =&gt; { console.log(res) return 2 }) .catch((err) =&gt; { return 3 }) .then((res) =&gt; { console.log(res) }) 运行结果： 1 2 解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。 题目五const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&apos;once&apos;) resolve(&apos;success&apos;) }, 1000) }) const start = Date.now() promise.then((res) =&gt; { console.log(res, Date.now() - start) }) promise.then((res) =&gt; { console.log(res, Date.now() - start) }) 运行结果： once success 1005 success 1007 解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。 题目六Promise.resolve() .then(() =&gt; { return new Error(&apos;error!!!&apos;) }) .then((res) =&gt; { console.log(&apos;then: &apos;, res) }) .catch((err) =&gt; { console.log(&apos;catch: &apos;, err) }) 运行结果： then: Error: error!!! at Promise.resolve.then (...) at ... 解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种： return Promise.reject(new Error(‘error!!!’)) throw new Error(‘error!!!’) 因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。 题目七const promise = Promise.resolve() .then(() =&gt; { return promise }) promise.catch(console.error) 运行结果： TypeError: Chaining cycle detected for promise #&lt;Promise&gt; at &lt;anonymous&gt; at process._tickCallback (internal/process/next_tick.js:188:7) at Function.Module.runMain (module.js:667:11) at startup (bootstrap_node.js:187:16) at bootstrap_node.js:607:3 解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于： process.nextTick(function tick () { console.log(&apos;tick&apos;) process.nextTick(tick) }) 题目八Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 运行结果： 1 解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。 题目九Promise.resolve() .then(function success (res) { throw new Error(&apos;error&apos;) }, function fail1 (e) { console.error(&apos;fail1: &apos;, e) }) .catch(function fail2 (e) { console.error(&apos;fail2: &apos;, e) }) 运行结果： fail2: Error: error at success (...) at ... 解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以： Promise.resolve() .then(function success1 (res) { throw new Error(&apos;error&apos;) }, function fail1 (e) { console.error(&apos;fail1: &apos;, e) }) .then(function success2 (res) { }, function fail2 (e) { console.error(&apos;fail2: &apos;, e) }) 题目十process.nextTick(() =&gt; { console.log(&apos;nextTick&apos;) }) Promise.resolve() .then(() =&gt; { console.log(&apos;then&apos;) }) setImmediate(() =&gt; { console.log(&apos;setImmediate&apos;) }) console.log(&apos;end&apos;) 运行结果： end nextTick then setImmediate 解释：process.nextTick 和 promise.then 都属于 microtasks，而 setImmediate 属于 macrotasks，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotasks）之间都会执行 microtasks，事件循环的开始会先执行一次 microtasks。]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS正则表达式Regex]]></title>
    <url>%2F2018%2F10%2F01%2FJS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegex%2F</url>
    <content type="text"><![CDATA[名余曰正则兮，字余曰灵均。 Regular Expressions翻译成中文叫正则表达式。也不知道是谁翻译过来的，听起来就很严肃。似乎翻译成通用表达式更能传达其精髓，如果你不怕梦见屈原的话。 为什么叫通用表达式？因为它有一套和编程语言无关的文本匹配规则。很多语言都实现了正则表达式的文本匹配引擎，只不过在功能集合上略有不同。 我们要记住的是三点： 其一，正则表达式是用来提取文本的。 其二，正则表达式的表达能力强大到令人发指。 其三，正则表达式的语法对初学者不友好。 另外，本专题只涉及JavaScript语言的正则表达式，其他语言的规则可能略有不同。 我还为各位读者准备了一副宣传语，应该能让你心动(点赞)吧？ 学一门前端工具，几年就过时了。学正则表达式，受用一辈子。 普通字符什么叫普通字符？ 当我们写a的时候，我们指的就是a；当我们写爱的时候，我们指的就是爱。 &apos;hello 😀 regex&apos;.match(/😀/); // [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined]复制代码 这就是普通字符，它在正则中的含义就是检索它本身。除了正则规定的部分字符外，其余的都是普通字符，包括各种人类语言，包括emoji，只要能够表达为字符串。 开始与结束^字符的英文是caret，翻译成中文是脱字符。不要问我，又不是我翻译的。它在正则中属于元字符，通常代表的意义是文本的开始。说通常是因为当它在字符组中[^abc]另有含义。 什么叫文本的开始？就是如果它是正则主体的第一个符号，那紧跟着它的字符必须是被匹配文本的第一个字符。 &apos;regex&apos;.match(/^r/); // [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码 问题来了，如果^不是正则的第一个符号呢？ &apos;regex&apos;.match(/a^r/); // null复制代码 所以呀，关于它有三点需要注意： 作为匹配文本开始元字符的时候必须是正则主体的第一个符号，否则正则无效。 它匹配的是一个位置，而不是具体的文本。 它在其他规则中有另外的含义。 $字符与^正好相反。它代表文本的结束，并且没有其他含义(其实是有的，但不是在正则主体内)。同样，它必须是正则主体的最后一个符号。 &apos;regex&apos;.match(/x$/); // [&quot;x&quot;, index: 4, input: &quot;regex&quot;, groups: undefined]复制代码 ^与$特殊的地方在于它匹配的是一个位置。位置不像字符，它看不见，所以更不容易理解。 转义我们现在已经知道$匹配文本的结束位置，它是元字符。但是如果我想匹配$本身呢？匹配一个美元符号的需求再常见不过了吧。所以我们得将它贬为庶民。 \反斜杠就是干这个的。 &apos;price: $3.6&apos;.match(/\$[0-9]+\.[0-9]+$/); // [&quot;$3.6&quot;, index: 7, input: &quot;price: $3.6&quot;, groups: undefined]复制代码 上面的例子有点超纲了，超纲的部分先不管。 你可以认为\也是一个元字符，它跟在另一个元字符后面，就能还原它本来的含义。 如果有两个\呢？那就是转义自身了。如果有三个\呢？我们得分成两段去理解。以此类推。 普通字符前面跟了一个\是什么效果？首先它们是一个整体，然后普通字符转义后还是普通字符。 带反斜杠的元字符一般来说，普通字符前面带反斜杠还是普通字符，但是有一些普通字符，带反斜杠后反而变成了元字符。 要怪只能怪计算机领域的常用符号太少了。元字符含义\b匹配一个单词边界(boundary)\B匹配一个非单词边界\d匹配一个数字字符(digit)\D匹配一个非数字字符\s匹配一个空白字符(space)\S匹配一个非空白字符\w匹配一个字母或者一个数字或者一个下划线(word)\W匹配一个字母、数字和下划线之外的字符你这么聪明，肯定一眼就看出来，大写代表反义。对，就是这么好记。 \b元字符\b匹配的也是一个位置，而不是一个字符。单词和空格之间的位置，就是所谓单词边界。 &apos;hello regex&apos;.match(/\bregex$/); // [&quot;regex&quot;, index: 6, input: &quot;hello regex&quot;, groups: undefined]&apos;hello regex&apos;.match(/\Bregex$/); // null复制代码 所谓单词边界，对中文等其他语言是无效的。 &apos;jiangshuying gaoyuanyuan huosiyan&apos;.match(/\bgaoyuanyuan\b/); // [&quot;gaoyuanyuan&quot;, index: 13, input: &quot;jiangshuying gaoyuanyuan huosiyan&quot;, groups: undefined]&apos;江疏影 高圆圆 霍思燕&apos;.match(/\b高圆圆\b/); // null复制代码 所以\b翻译一下就是^\w|\w$|\W\w|\w\W。 \d元字符\d匹配一个数字，注意，这里的数字不是指JavaScript中的数字类型，因为文本全是字符串。它指的是代表数字的字符。 &apos;123&apos;.match(/\d/); // [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined]复制代码 \s元字符\s匹配一个空白字符。 这里需要解释一下什么是空白字符。 空白字符不是空格，它是空格的超集。很多人说它是\f\n\r\t\v的总和，其中\f是换页符，\n是换行符，\r是回车符，\t是水平制表符，\v是垂直制表符。是这样么？ &apos;a b&apos;.match(/\w\s\w/); // [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]&apos;a b&apos;.match(/\w\f\w/); // null&apos;a b&apos;.match(/\w\n\w/); // null&apos;a b&apos;.match(/\w\r\w/); // null&apos;a b&apos;.match(/\w\t\w/); // null&apos;a b&apos;.match(/\w\v\w/); // null&apos;a b&apos;.match(/\w \w/); // [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]复制代码 这样说的人，明显是没有做过实验。其实正确的写法是空格\f\n\r\t\v的总和，集合里面包含一个空格，可千万别忽略了。诶，难道空格在正则中的写法就是空一格么，是的，就是这样随意。 这个集合中很多都是不可打印字符，估计只有\n是我们的老朋友。所以，如果不需要区分空格和换行的话，那就大胆的用\s吧。 \w元字符\w匹配一个字母或者一个数字或者一个下划线。为什么要将它们放一起？想一想JavaScript中的变量规则，包括很多应用的用户名都只能是这三样，所以把它们放一起挺方便的。 不过要注意，字母指的是26个英文字母，其他的不行。 &apos;正则&apos;.match(/\w/); // null复制代码 负阴抱阳如果我们将大写和小写的带反斜杠的元字符组合在一起，就能匹配任何字符。是的，不针对任何人。 &apos;@regex&apos;.match(/[\s\S]/); // [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码 方括号的含义我们先按下不表。 道生一.在正则中的含义仙风道骨，它匹配换行符之外的任意单个字符。 如果文本不存在换行符，那么.和[\b\B]和[\d\D]和[\s\S]和[\w\W]是等价的。 如果文本存在换行符，那么(.|\n)和[\b\B]和[\d\D]和[\s\S]和[\w\W]是等价的。 &apos;@regex&apos;.match(/./); // [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码 量词前面我们一直在强调，一个元字符只匹配一个字符。即便强大如.它也只能匹配一个。 那匹配gooooogle的正则是不是得写成/gooooogle/呢？ 正则冷笑，并向你发射一个蔑视。 如果匹配的模式有重复，我们可以声明它重复的次数。量词含义?重复零次或者一次+重复一次或者多次，也就是至少一次*重复零次或者多次，也就是任意次数{n}重复n次{n,}重复n次或者更多次{n,m}重复n次到m次之间的次数，包含n次和m次有三点需要注意： ?在诸如匹配http协议的时候非常有用，就像这样：/http(s)?/。它在正则中除了是量词还有别的含义，后面会提到。 我们习惯用/.*/来匹配若干对我们没有价值的文本，它的含义是若干除换行符之外的字符。比如我们需要文本两头的格式化信息，中间是什么无所谓，它就派上用场了。不过它的性能可不好。 {n,m}之间不能有空格，空格在正则中是有含义的。 关于量词最令人困惑的是：它重复什么？ 它重复紧贴在它前面的某个集合。第一点，必须是紧贴在它前面；第二点，重复一个集合。最常见的集合就是一个字符，当然正则中有一些元字符能够将若干字符变成一个集合，后面会讲到。 &apos;gooooogle&apos;.match(/go{2,5}gle/); // [&quot;gooooogle&quot;, index: 0, input: &quot;gooooogle&quot;, groups: undefined]复制代码 如果一个量词紧贴在另一个量词后面会怎样？ &apos;gooooogle&apos;.match(/go{2,5}+gle/); // Uncaught SyntaxError: Invalid regular expression: /go{2,5}+gle/: Nothing to repeat复制代码 贪婪模式与非贪婪模式前面提到量词不能紧跟在另一个量词后面，马上要👋👋打脸了。 &apos;https&apos;.match(/http(s)?/); // [&quot;https&quot;, &quot;s&quot;, index: 0, input: &quot;https&quot;, groups: undefined]&apos;https&apos;.match(/http(s)??/); // [&quot;http&quot;, undefined, index: 0, input: &quot;https&quot;, groups: undefined]复制代码 然而，我的脸是这么好打的？ 紧跟在?后面的?它不是一个量词，而是一个模式切换符，从贪婪模式切换到非贪婪模式。 贪婪模式在正则中是默认的模式，就是在既定规则之下匹配尽可能多的文本。因为正则中有量词，它的重复次数可能是一个区间，这就有了取舍。 紧跟在量词之后加上?就可以开启非贪婪模式。怎么省事怎么来。 这里的要点是，?必须紧跟着量词，否则的话它自己就变成量词了。 字符组正则中的普通字符只能匹配它自己。如果我要匹配一个普通字符，但是我不确定它是什么，怎么办？ &apos;grey or gray&apos;.match(/gr[ae]y/); // [&quot;grey&quot;, index: 0, input: &quot;grey or gray&quot;, groups: undefined]复制代码 方括号在正则中表示一个区间，我们称它为字符组。 首先，字符组中的字符集合只是所有的可选项，最终它只能匹配一个字符。 然后，字符组是一个独立的世界，元字符不需要转义。 &apos;$&apos;.match(/[$&amp;@]/); // [&quot;$&quot;, index: 0, input: &quot;$&quot;, groups: undefined]复制代码 最后，有两个字符在字符组中有特殊含义。 ^在字符组中表示取反，不再是文本开始的位置了。 &apos;regex&apos;.match(/[^abc]/); // [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码 如果我就要^呢？前面已经讲过了，转义。 -本来是一个普通字符，在字符组中摇身一变成为连字符。 &apos;13&apos;.match(/[1-9]3/); // [&quot;13&quot;, index: 0, input: &quot;13&quot;, groups: undefined]复制代码 连字符的意思是匹配范围在它的左边字符和右边字符之间。 如果我这样呢？ &apos;abc-3&apos;.match(/[0-z]/); // [&quot;a&quot;, index: 0, input: &quot;abc-3&quot;, groups: undefined]复制代码 &apos;xyz-3&apos;.match(/[0-c]/); // [&quot;3&quot;, index: 4, input: &quot;xyz-3&quot;, groups: undefined]复制代码 &apos;xyz-3&apos;.match(/[0-$]/); // Uncaught SyntaxError: Invalid regular expression: /[0-$]/: Range out of order in character class复制代码 发现什么了没有？只有两种字符是可以用连字符的：英文字母和数字。而且英文字母可以和数字连起来，英文字母的顺序在后面。这和扑克牌1 2 3 4 5 6 7 8 9 10 J Q K是一个道理。 捕获组与非捕获组我们已经知道量词是怎么回事了，我们也知道量词只能重复紧贴在它前面的字符。 如果我要重复的是一串字符呢？ &apos;i love you very very very much&apos;.match(/i love you very +much/); // null&apos;i love you very very very much&apos;.match(/i love you v+e+r+y+ +much/); // null复制代码 这样肯定是不行的。是时候请圆括号出山了。 &apos;i love you very very very much&apos;.match(/i love you (very )+much/); // [&quot;i love you very very very much&quot;, &quot;very &quot;, index: 0, input: &quot;i love you very very very much&quot;, groups: undefined]复制代码 圆括号的意思是将它其中的字符集合打包成一个整体，然后量词就可以操作这个整体了。这和方括号的效果是完全不一样的。 而且默认的，圆括号的匹配结果是可以捕获的。 正则内捕获现在我们有一个需求，匹配&lt;div&gt;标签。 &apos;&lt;div&gt;hello regex&lt;/div&gt;&apos;.match(/&lt;div&gt;.*&lt;\/div&gt;/); // [&quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, index: 0, input: &quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, groups: undefined]复制代码 这很简单。但如果我要匹配的是任意标签，包括自定义的标签呢？ &apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;([a-zA-Z]+)&gt;.*&lt;\/\1&gt;/); // [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: undefined]复制代码 这时候就要用到正则的捕获特性。正则内捕获使用\数字的形式，分别对应前面的圆括号捕获的内容。这种捕获的引用也叫反向引用。 我们来看一个更复杂的情况： &apos;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&apos;.match(/&lt;((A|a)pp)&gt;(hello regex)+&lt;\/\1&gt;&lt;p&gt;\2&lt;\/p&gt;&lt;p&gt;\3&lt;\/p&gt;/); // [&quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, &quot;App&quot;, &quot;A&quot;, &quot;hello regex&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, groups: undefined]复制代码 如果有嵌套的圆括号，那么捕获的引用是先递归的，然后才是下一个顶级捕获。 正则外捕获&apos;@abc&apos;.match(/@(abc)/); // [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]RegExp.$1; // &quot;abc&quot;复制代码 没错，RegExp就是构造正则的构造函数。如果有捕获组，它的实例属性$数字会显示对应的引用。 如果有多个正则呢？ &apos;@abc&apos;.match(/@(abc)/); // [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@xyz&apos;.match(/@(xyz)/); // [&quot;@xyz&quot;, &quot;xyz&quot;, index: 0, input: &quot;@xyz&quot;, groups: undefined]RegExp.$1; // &quot;xyz&quot;复制代码 RegExp构造函数的引用只显示最后一个正则的捕获。 另外还有一个字符串实例方法也支持正则捕获的引用，它就是replace方法。 &apos;hello **regex**&apos;.replace(/\*{2}(.*)\*{2}/, &apos;&lt;strong&gt;$1&lt;/strong&gt;&apos;); // &quot;hello &lt;strong&gt;regex&lt;/strong&gt;&quot;复制代码 实际上它才是最常用的引用捕获的方式。 捕获命名 这是ES2018的新特性。 使用\数字引用捕获必须保证捕获组的顺序不变。现在开发者可以给捕获组命名了，有了名字以后，引用起来更加确定。 &apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;(?&lt;tag&gt;[a-zA-Z]+)&gt;.*&lt;\/\k&lt;tag&gt;&gt;/); // [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: {tag: &quot;App&quot;}]复制代码 在捕获组内部最前面加上?&lt;key&gt;，它就被命名了。使用\k&lt;key&gt;语法就可以引用已经命名的捕获组。 是不是很简单？ 通常情况下，开发者只是想在正则中将某些字符当成一个整体看待。捕获组很棒，但是它做了额外的事情，肯定需要额外的内存占用和计算资源。于是正则又有了非捕获组的概念。 &apos;@abc&apos;.match(/@(abc)/); // [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@abc&apos;.match(/@(?:abc)/); // [&quot;@abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]复制代码 只要在圆括号内最前面加上?:标识，就是告诉正则引擎：我只要这个整体，不需要它的引用，你就别费劲了。从上面的例子也可以看出来，match方法返回的结果有些许不一样。 个人观点：我觉得正则的捕获设计应该反过来，默认不捕获，加上?:标识后才捕获。因为大多数时候开发者是不需要捕获的，但是它又懒得加?:标识，会有些许性能浪费。 分支有时候开发者需要在正则中使用或者。 &apos;高圆圆&apos;.match(/陈乔恩|高圆圆/); // [&quot;高圆圆&quot;, index: 0, input: &quot;高圆圆&quot;, groups: undefined]复制代码 |就代表或者。字符组其实也是一个多选结构，但是它们俩有本质区别。字符组最终只能匹配一个字符，而分支匹配的是左边所有的字符或者右边所有的字符。 我们来看一个例子： &apos;我喜欢高圆圆&apos;.match(/我喜欢陈乔恩|高圆圆/); // [&quot;高圆圆&quot;, index: 3, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码 因为|是将左右两边一切两半，然后匹配左边或者右边。所以上面的正则显然达不到我们想要的效果。这个时候就需要一个东西来缩小分支的范围。诶，你可能已经想到了： &apos;我喜欢高圆圆&apos;.match(/我喜欢(?:陈乔恩|高圆圆)/); // [&quot;我喜欢高圆圆&quot;, index: 0, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码 没错，就是圆括号。 零宽断言正则中有一些元字符，它不匹配字符，而是匹配一个位置。比如之前提到的^和$。^的意思是说这个位置应该是文本开始的位置。 正则还有一些比较高级的匹配位置的语法，它匹配的是：在这个位置之前或之后应该有什么内容。 零宽(zero-width)是什么意思？指的就是它匹配一个位置，本身没有宽度。 断言(assertion)是什么意思？指的是一种判断，断言之前或之后应该有什么或应该没有什么。 零宽肯定先行断言所谓的肯定就是判断有什么，而不是判断没有什么。 而先行指的是向前看(lookahead)，断言的这个位置是为前面的规则服务的。 语法很简单：圆括号内最左边加上?=标识。 &apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)/); // [&quot;Java&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码 上面匹配的是四个字母，这四个字母要满足以下条件：紧跟着的应该是Script字符串，而且Script字符串应该是单词的结尾部分。 所以，零宽肯定先行断言的意思是：现在有一段正则语法，用这段语法去匹配给定的文本。但是，满足条件的文本不仅要匹配这段语法，紧跟着它的必须是一个位置，这个位置又必须满足一段正则语法。 说的再直白点，我要匹配一段文本，但是这段文本后面必须紧跟着另一段特定的文本。零宽肯定先行断言就是一个界碑，我要满足前面和后面所有的条件，但是我只要前面的文本。 我们来看另一种情况： &apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)\w+/); // [&quot;JavaScript&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码 上面的例子更加直观，零宽肯定先行断言已经匹配过Script一次了，后面的\w+却还是能匹配Script成功，足以说明它的零宽特性。它为紧贴在它前面的规则服务，并且不影响后面的匹配规则。 零宽肯定后行断言先行是向前看，那后行就是向后看(lookbehind)咯。 语法是圆括号内最左边加上?&lt;=标识。 &apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍\S+/); // [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码 一个正则可以有多个断言： &apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍.+?(?=\s|$)/); // [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码 零宽否定先行断言肯定是判断有什么，否定就是判断没有什么咯。 语法是圆括号内最左边加上?!标识。 &apos;TypeScript Perl JavaScript&apos;.match(/\b\w{4}(?!Script\b)/); // [&quot;Perl&quot;, index: 11, input: &quot;TypeScript Perl JavaScript&quot;, groups: undefined]复制代码 零宽否定后行断言语法是圆括号最左边加上?&lt;!标识。 &apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;!演员)霍\S+/); // [&quot;霍去病&quot;, index: 8, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码 修饰符正则表达式除了主体语法，还有若干可选的模式修饰符。 写法就是将修饰符安插在正则主体的尾巴上。比如这样：/abc/gi。 g修饰符g是global的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。g修饰符会开启全局匹配模式，找到所有匹配的结果。 &apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/); // [&quot;高圆圆&quot;, index: 2, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/g); // [&quot;高圆圆&quot;, &quot;霍思燕&quot;]复制代码 i修饰符i是ignoreCase的缩写。默认情况下，/z/是无法匹配Z的，所以我们有时候不得不这样写：/[a-zA-Z]/。i修饰符可以全局忽略大小写。 很多时候我们不在乎文本是大写、小写还是大小写混写，这个修饰符还是很有用的。 &apos;javascript is great&apos;.match(/JavaScript/); // null&apos;javascript is great&apos;.match(/JavaScript/i); // [&quot;javascript&quot;, index: 0, input: &quot;javascript is great&quot;, groups: undefined]复制代码 m修饰符m是multiline的缩写。这个修饰符有特定起作用的场景：它要和^和$搭配起来使用。默认情况下，^和$匹配的是文本的开始和结束，加上m修饰符，它们的含义就变成了行的开始和结束。 ` abc xyz `.match(/xyz/); // [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]` abc xyz `.match(/^xyz$/); // null` abc xyz `.match(/^xyz$/m); // [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码 y修饰符 这是ES2015的新特性。 y是sticky的缩写。y修饰符有和g修饰符重合的功能，它们都是全局匹配。所以重点在sticky上，怎么理解这个粘连呢？ g修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是y修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。 &apos;a bag with a tag has a mag&apos;.match(/\wag/g); // [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]&apos;a bag with a tag has a mag&apos;.match(/\wag/y); // null&apos;bagtagmag&apos;.match(/\wag/y); // [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]&apos;bagtagmag&apos;.match(/\wag/gy); // [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]复制代码 有人肯定发现了猫腻：你不是说y修饰符是全局匹配么？看上面的例子，单独一个y修饰符用match方法怎么并不是全局匹配呢？ 诶，这里说来就话长了。 长话短说呢，就涉及到y修饰符的本质是什么。它的本质有二： 全局匹配(先别着急打我)。 从文本的lastIndex位置开始新的匹配。lastIndex是什么？它是正则表达式的一个属性，如果是全局匹配，它用来标注下一次匹配的起始点。这才是粘连的本质所在。 不知道你们发现什么了没有：lastIndex是正则表达式的一个属性。而上面例子中的match方法是作用在字符串上的，都没有lastIndex属性，休怪人家工作不上心。 const reg = /\wag/y; reg.exec(&apos;bagtagmag&apos;); // [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined] reg.exec(&apos;bagtagmag&apos;); // [&quot;tag&quot;, index: 3, input: &quot;bagtagmag&quot;, groups: undefined] reg.exec(&apos;bagtagmag&apos;); // [&quot;mag&quot;, index: 6, input: &quot;bagtagmag&quot;, groups: undefined]复制代码 咱们换成正则方法exec，多次执行，正则的lastIndex在变，匹配的结果也在变。全局匹配无疑了吧。 s修饰符 这是ES2018的新特性。 s不是dotAll的缩写。s修饰符要和.搭配使用，默认情况下，.匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。 s修饰符的作用就是让.可以匹配任意单个字符。 s是singleline的缩写。 ` abc xyz `.match(/c.x/); // null` abc xyz `.match(/c.x/s); // [&quot;c↵x&quot;, index: 3, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码 u修饰符 这是ES2015的新特性。 u是unicode的缩写。有一些Unicode字符超过一个字节，正则就无法正确的识别它们。u修饰符就是用来处理这些不常见的情况的。 &apos;𠮷&apos;.match(/^.$/); // null&apos;𠮷&apos;.match(/^.$/u); // [&quot;𠮷&quot;, index: 0, input: &quot;𠮷&quot;, groups: undefined]复制代码 𠮷念jí，与吉同义。 笔者对Unicode认识尚浅，这里不过多展开。]]></content>
      <tags>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现call和apply]]></title>
    <url>%2F2018%2F10%2F01%2F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E5%92%8Capply%2F</url>
    <content type="text"><![CDATA[概述JS 函数 call 和 apply 用来手动改变 this 的指向，call 和 apply 唯一的区别就在于函数参数的传递方式不同，call 是以逗号的形式，apply 是以数组的形式： let person1 = { name: &quot;person1&quot;, say: function(age, sex) { console.log(this.name + &apos; age: &apos; + age + &apos; sex: &apos; + sex); } } let person2 = { name: &quot;person&quot; } person1.say.call(person2, 20, &quot;男&quot;); person1.say.apply(person2, [20, &quot;男&quot;]); 本文就尝试用其他方式来模拟实现 call 和 apply。 首先观察 call 和 apply 有什么特点？ 被函数调用（函数也是对象），相当于 call 和 apply 是函数的属性 如果没有传入需要 this 指向对象，那么 this 指向全局对象 函数执行了 最后都改变了 this 的指向 一、初步实现基于 call 函数是调用函数的属性的特点，call 的 this 指向调用函数，我们可以尝试把调用函数的作为传入的新对象的一个属性，执行后，再删除这个属性就好了。 Function.prototype.newCall = function (context) { context.fn = this; // this 指的是 say 函数 context.fn(); delete context.fn; } var person = { name: &quot;jayChou&quot; }; var say = function() { console.log(this.name); } say.newCall(person); // jayChou 是不是就初步模拟实现了 call 函数呢，由于 call 还涉及到传参的问题，所以我们进入到下一环节。 二、eval 方式在给对象临时一个函数，并执行时，传入的参数是除了 context 其余的参数。那么我们可以截取 arguments 参数数组的第一个后，将剩余的参数传入临时数组。 在前面我有讲过函数 arguments 类数组对象的特点，arguments 是不支持数组的大多数方法, 但是支持for 循环来遍历数组。 Function.prototype.newCall = function (context) { context.fn = this; let args = []; for(let i=1; i&lt; arguments.length; i++) { args.push(&apos;arguments[&apos; + i + &apos;]&apos;); } // args =&gt; [arguments[1], arguments[2], arguments[3], ...] context.fn(args.join(&apos;,&apos;)); // ？？？delete context.fn; } var person = { name: &quot;jayChou&quot; }; var say = function(age, sex) { console.log(`name: ${this.name},age: ${age}, sex: ${sex}`); } say.newCall(person); 上面传递参数的方式最后肯定是失败的，我们可以尝试 eval 的方式，将参数添加子函数的作用域中。 eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码 Function.prototype.newCall = function (context) { context.fn = this; let args = []; for(var i=1; i&lt; arguments.length; i++) { args.push(&apos;arguments[&apos; + i + &apos;]&apos;); } // args =&gt; [arguments[1], arguments[2], arguments[3], ...]eval(&apos;context.fn(&apos; + args + &apos;)&apos;); delete context.fn; } var person = { name: &quot;jayChou&quot; }; functionsay(age, sex) { console.log(`name: ${this.name},age: ${age}, sex: ${sex}`); } say.newCall(person, 18, &apos;男&apos;); // name: jayChou,age: 18, sex: 男 成功啦！ 实现了函数参数的传递，那么函数返回值怎么处理呢。而且，如果传入的对象是 null，又该如何处理？所以还需要再做一些工作： Function.prototype.newCall = function (context) { if (typeof context === &apos;object&apos;) { context = context || window } else { context = Object.create(null); } context.fn = this; let args = []; for(var i=1; i&lt; arguments.length; i++) { args.push(&apos;arguments[&apos; + i + &apos;]&apos;); } // args =&gt; [arguments[1], arguments[2], arguments[3], ...]var result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;); // 处理返回值delete context.fn; return result; // 返回返回值 } var person = { name: &quot;jayChou&quot; }; functionsay(age, sex) { console.log(`name: ${this.name},age: ${age}, sex: ${sex}`); return age + sex; } var check = say.newCall(person, 18, &apos;男&apos;); console.log(check); // 18男 判断传入对象的类型，如果为 null 就指向 window 对象。利用 eval 来执行字符串代码，并返回字符串代码执行的结果，就完成了模拟 call。大功告成！ 三、ES 6 实现前面我们用的 eval 方式可以用 ES6 的解决还存在的一些问题，有没有注意到，这段代码是有问题的。 context.fn = this; 假如对象在被 call 调用前，已经有 fn 属性怎么办？ ES6 中提供了一种新的基本数据类型，Symbol，表示独一无二的值，另外，Symbol 作为属性的时候，不能使用点运算符。所以再加上 ES 的 rest 剩余参数替代 arguments 遍历的工作就有： Function.prototype.newCall = function (context,...params) { if (typeof context === &apos;object&apos;) { context = context || window } else { context = Object.create(null); } let fn = Symbol(); context[fn] = thisvar result = context[fn](...params); delete context.fn; return result; } var person = { name: &quot;jayChou&quot; }; functionsay(age, sex) { console.log(`name: ${this.name},age: ${age}, sex: ${sex}`); return age + sex; } var check = say.newCall(person, 18, &apos;男&apos;); console.log(check); // 18男 四、applyapply 和 call 的实现原理，基本类似，区别在于 apply 的参数是以数组的形式传入。 Function.prototype.newApply = function (context, arr) { if (typeof context === &apos;object&apos;) { context = context || window } else { context = Object.create(null); } context.fn = this; var result; if (!arr) { // 判断函数参数是否为空 result = context.fn(); } else { var args = []; for (var i = 0; i &lt; arr.length; i++) { args.push(&apos;arr[&apos; + i + &apos;]&apos;); } result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;); } delete context.fn; return result; } es6 实现 Function.prototype.newApply = function(context, parameter) { if (typeof context === &apos;object&apos;) { context = context || window } else { context = Object.create(null) } let fn = Symbol() context[fn] = this; var result = context[fn](...parameter); delete context[fn]; return result; }]]></content>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2 常用配置及命令]]></title>
    <url>%2F2018%2F09%2F30%2Fpm2-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[如果直接通过node app来启动，如果报错了可能直接停在整个运行，supervisor感觉只是拿来用作开发环境的。再网上找到pm2.目前似乎最常见的线上部署nodejs项目的有forever,pm2这两种。使用场合: supervisor是开发环境用。 forever管理多个站点，每个站点访问量不大，不需要监控。 nodemon 是开发环境使用，修改自动重启。 pm2 网站访问量比较大,需要完整的监控界面。 PM2 是 node 进程管理工具，可以利用它来简化很多 node 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。本文就 PM2 进行入门性的介绍，基本涵盖了 PM2 的常用的功能和配置。 安装1npm install -g pm2 如果你的node项目配置文件和以上代码不一样，，，莫急，pm2 也是有办法可以启动的（个人觉得这是一个万能的启动的方法）：12pm2 start npm -- run XXXpm2 start npm --watch --name XXX -- run start 用她替代：npm run dev，就可以写成：pm2 start npm -- run dev，项目启动： 常用命令12345678910111213141516171819202122232425262728293031323334353637383940pm2 start [server.js]# 启动服务pm2 list# 查看当前所跑服务的详情pm2 show [name]# 查看更加详细的信息这个命令可查看pm2配置 包括日志文件存放的位置等pm2 stop [id/name]# 关闭某个服务pm2 delete [id/name]# 删除某个服务pm2 stop all# 关闭所有服务pm2 logs# 查看实时日志pm2 restart [name]# 重新启动服务$ pm2 logs 显示所有进程日志$ pm2 stop all 停止所有进程$ pm2 restart all 重启所有进程$ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程)$ pm2 stop 0 停止指定的进程$ pm2 restart 0 重启指定的进程$ pm2 startup 产生 init 脚本 保持进程活着$ pm2 web 运行健壮的 computer API endpoint (http://localhost:9615)$ pm2 delete 0 杀死指定的进程$ pm2 delete all 杀死全部进程 运行进程的不同方式：$ pm2 start app.js -i max 根据有效CPU数目启动最大进程数目$ pm2 start app.js -i 3 启动3个进程$ pm2 start app.js -x 用fork模式启动 app.js 而不是使用 cluster$ pm2 start app.js -x -- -a 23 用fork模式启动 app.js 并且传递参数 (-a 23)$ pm2 start app.js --name serverone 启动一个进程并把它命名为 serverone$ pm2 stop serverone 停止 serverone 进程$ pm2 start app.json 启动进程, 在 app.json里设置选项$ pm2 start app.js -i max -- -a 23 在--之后给 app.js 传递参数$ pm2 start app.js -i max -e err.log -o out.log 启动 并 生成一个配置文件 启动参数说明： --watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i --instances：启用多少个实例，可用于负载均衡。如果 -i 0 或者 -i max，则根据当前机器核数确定实例数目。 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如 --ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot; -n --name：应用的名称。查看应用信息的时候可以用到。 -o --output &lt;path&gt;：标准输出日志文件的路径。 -e --error &lt;path&gt;：错误输出日志文件的路径。 监听pm2 start ./bin/www --watch #注意，这里用了--watch参数，意味着当你的应用代码发生变化时，pm2会帮你自动重启服务 配置及部署部署的配置文件示例12345678910111213141516171819202122232425262728293031&#123; // 数组中放的是需要发布的项目一些变量的定义 &quot;apps&quot;: [&#123; &quot;name&quot;: &quot;xxx&quot;, //项目名称 &quot;script&quot;: &quot;server.js&quot;, //用来启动的脚本 // &quot;instances&quot;:2, // 启动项目所需要的环境变量 &quot;env&quot;: &#123; &quot;COMMON_VARIABLE&quot;: &quot;true&quot;, //设置为true 可以在启动的时传入外部的变量进去 &#125;, &quot;env_production&quot;: &#123; &quot;NODE_ENV&quot;: &quot;production&quot; &#125; &#125;], // 部署 &quot;deploy&quot;: &#123; &quot;production&quot;: &#123; &quot;user&quot;: &quot;root&quot;, &quot;host&quot;: &quot;0.0.0.0&quot;, //可以是数组 部署到多台主机 &quot;ref&quot;: &quot;origin/master&quot;, //选择拿哪个个分支的代码 &quot;repo&quot;: &quot;git@github.com:ihoey/hitalk.git&quot;, //仓库地址 &quot;path&quot;: &quot;/root/www/hitalk/production&quot;, //要发布到服务器上哪个目录下面 &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, //避免key验证导致代码更新到远程仓库失败 &quot;post-deploy&quot;: &quot;source ~/.nvm/nvm.sh &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;, //发布之后执行的动作 执行开启或更新pm2运行的服务 &quot;pre-deploy-local&quot;: &quot;echo &apos;Deploy Done!&apos;&quot;, //本地发布之前的动作 &quot;env&quot;: &#123; //指定部署到远程的仓库的环境 是production生产环境 &quot;NODE_ENV&quot;: &quot;production&quot; &#125; &#125; &#125;&#125; 说明: 123456789101112131415161718apps:json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用name:应用程序名称cwd:应用程序所在的目录script:应用程序的脚本路径log_date_format:error_file:自定义应用程序的错误日志文件out_file:自定义应用程序日志文件pid_file:自定义应用程序的pid文件instances:min_uptime:最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量max_restarts:设置应用程序异常退出重启的次数，默认15次（从0开始计数）cron_restart:定时启动，解决重启能解决的问题watch:是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。merge_logs:exec_interpreter:应用程序的脚本类型，这里使用的shell，默认是nodejsexec_mode:应用程序启动模式，这里设置的是cluster_mode（集群），默认是forkautorestart:启用/禁用应用程序崩溃或退出时自动重启vizion:启用/禁用vizion特性(版本控制) 初始化配置第一次部署 pm2 deploy ecosystem.json production setup 部署pm2 deploy ecosystem.json production 好了，先记录这么多~]]></content>
      <tags>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅说 XSS 和 CSRF]]></title>
    <url>%2F2018%2F09%2F29%2F%E6%B5%85%E8%AF%B4-XSS-%E5%92%8C-CSRF%2F</url>
    <content type="text"><![CDATA[在 Web 安全领域中，XSS 和 CSRF 是最常见的攻击方式。本文将会简单介绍 XSS 和 CSRF 的攻防问题。 声明：本文的示例仅用于演示相关的攻击原理 XSSXSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。 XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。 攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。 XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。 反射型反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。 看一个示例。我先准备一个如下的静态页： 恶意链接的地址指向了 localhost:8001/?q=111&amp;p=222。然后，我再启一个简单的 Node 服务处理恶意链接的请求： consthttp=require(&apos;http&apos;); functionhandleReequest(req, res) { res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;}); res.write(&apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;); res.end(); } constserver=newhttp.Server(); server.listen(8001, &apos;127.0.0.1&apos;); server.on(&apos;request&apos;, handleReequest); 当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本： 这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 举一个示例。 先准备一个输入页面： &lt;input type=&quot;text&quot; id=&quot;input&quot;&gt; &lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt; &lt;script&gt; const input = document.getElementById(&apos;input&apos;); const btn = document.getElementById(&apos;btn&apos;); let val; input.addEventListener(&apos;change&apos;, (e) =&gt; { val = e.target.value; }, false); btn.addEventListener(&apos;click&apos;, (e) =&gt; { fetch(&apos;http://localhost:8001/save&apos;, { method: &apos;POST&apos;, body: val }); }, false); &lt;/script&gt; 启动一个 Node 服务监听 save 请求。为了简化，用一个变量来保存用户的输入： consthttp=require(&apos;http&apos;); let userInput =&apos;&apos;; functionhandleReequest(req, res) { constmethod=req.method; res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;); res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type&apos;) if (method ===&apos;POST&apos;&amp;&amp;req.url===&apos;/save&apos;) { let body =&apos;&apos;; req.on(&apos;data&apos;, chunk=&gt; { body += chunk; }); req.on(&apos;end&apos;, () =&gt; { if (body) { userInput = body; } res.end(); }); } else { res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;}); res.write(userInput); res.end(); } } constserver=newhttp.Server(); server.listen(8001, &apos;127.0.0.1&apos;); server.on(&apos;request&apos;, handleReequest); 当用户点击提交按钮将输入信息提交到服务端时，服务端通过 userInput 变量保存了输入内容。当用户通过 http://localhost:8001/${id} 访问时，服务端会返回与 id 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行： 基于DOM基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。 看如下代码： &lt;h2&gt;XSS: &lt;/h2&gt; &lt;inputtype=&quot;text&quot;id=&quot;input&quot;&gt; &lt;buttonid=&quot;btn&quot;&gt;Submit&lt;/button&gt; &lt;divid=&quot;div&quot;&gt;&lt;/div&gt; &lt;script&gt;constinput=document.getElementById(&apos;input&apos;);constbtn=document.getElementById(&apos;btn&apos;);constdiv=document.getElementById(&apos;div&apos;);let val;input.addEventListener(&apos;change&apos;, (e) =&gt; { val =e.target.value; }, false);btn.addEventListener(&apos;click&apos;, () =&gt; {div.innerHTML=`&lt;ahref=${val}&gt;testLink&lt;/a&gt;` }, false);&lt;/script&gt; 点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容： &apos;&apos; onclick=alert(/xss/) 用户提交之后，页面代码就变成了： &lt;ahrefonlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt; 此时，用户点击生成的链接，就会执行对应的脚本： XSS 攻击的防范现在主流的浏览器内置了防范 XSS 的措施，例如 CSP。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。 HttpOnly 防止劫取 CookieHttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。 上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。 输入检查不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。 在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 &lt;，&gt; 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。 而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 &lt;，&gt;，script，防止 XSS 攻击： // vuejs 中的 decodingMap // 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉 const decodingMap = { &apos;&amp;lt;&apos;: &apos;&lt;&apos;, &apos;&amp;gt;&apos;: &apos;&gt;&apos;, &apos;&amp;quot;&apos;: &apos;&quot;&apos;, &apos;&amp;amp;&apos;: &apos;&amp;&apos;, &apos;&amp;#10;&apos;: &apos;\n&apos; } 输出检查用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。 CSRFCSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。 通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。 在举例子之前，先说说浏览器的 Cookie 策略。 浏览器的 Cookie 策略Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面： 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 个性化设置（如用户自定义设置、主题等） 而浏览器所持有的 Cookie 分为两种： Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。 Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。 res.setHeader(‘Set-Cookie’, [‘mycookie=222’, ‘test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;’]); 上述代码创建了两个 Cookie：mycookie 和 test，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 Expires 属性值会不一样： Firefox： Chrome: 此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。 通过 Cookie 进行 CSRF 攻击假设有一个 bbs 站点：http://www.c.com，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子： http://www.c.com:8002/content/delete/:id 如发起 http://www.c.com:8002/content/delete/87343 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie： res.setHeader(&apos;Set-Cookie&apos;, [&apos;user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&apos;]); user 对应的值是用户 ID。然后构造一个页面 A： &lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt; &lt;img src=&quot;http://www.c.com:8002/content/delete/87343&quot;&gt; 页面 A 使用了一个 img 标签，其地址指向了删除用户帖子的链接： 可以看到，当登录用户访问攻击者的网站时，会向 www.c.com 发起一个删除用户帖子的请求。此时若用户在切换到 www.c.com 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。 由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。 但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。 CSRF 攻击的防范当前，对 CSRF 攻击的防范措施主要有如下几种方式。 验证码验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。 从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。 但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。 Referer Check根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。 比如，如果用户要删除自己的帖子，那么先要登录 www.c.com，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 www.a.com 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 www.c.com 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。 针对上文的例子，可以在服务端增加如下代码： if (req.headers.referer!==&apos;http://www.c.com:8002/&apos;) { res.write(&apos;csrf 攻击&apos;); return; } Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。 添加 token 验证CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 总结本文主要介绍了 XSS 和 CSRF 的攻击原理和防御措施。当然，在 Web 安全领域，除了这两种常见的攻击方式，也存在这 SQL 注入等其它攻击方式，这不在本文的讨论范围之内，如果你对其感兴趣，可以阅读SQL注入技术专题的专栏详细了解相关信息。最后，总结一下 XSS 攻击和 CSRF 攻击的常见防御措施： 防御 XSS 攻击 HttpOnly 防止劫取 Cookie 用户的输入检查 服务端的输出检查 防御 CSRF 攻击 验证码 Referer Check Token 验证 &lt;完&gt; 参考资料 Cross-site scripting CSRF 攻击的应对之道 《白帽子讲 Web 安全》]]></content>
      <tags>
        <tag>xss</tag>
        <tag>csrf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6事件总线 EventBus]]></title>
    <url>%2F2018%2F09%2F21%2FES6%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF-EventBus%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class EventBus &#123; constructor() &#123; this.events = &#123;&#125;; &#125; on(type, callback, scope, ...args) &#123; if (typeof this.events[type] == &quot;undefined&quot;) &#123; this.events[type] = []; &#125; this.events[type].push(&#123;scope: scope, callback: callback, args: args&#125;); &#125; off(type, callback, scope) &#123; if (typeof this.events[type] == &quot;undefined&quot;) &#123; return; &#125; let numOfCallbacks = this.events[type].length; let newArray = []; for (let i = 0; i &lt; numOfCallbacks; i++) &#123; let event = this.events[type][i]; if (event.scope == scope &amp;&amp; event.callback == callback) &#123; &#125; else &#123; newArray.push(event); &#125; &#125; this.events[type] = newArray; &#125; has(type, callback, scope) &#123; if (typeof this.events[type] == &quot;undefined&quot;) &#123; return false; &#125; let numOfCallbacks = this.events[type].length; if (callback === undefined &amp;&amp; scope === undefined) &#123; return numOfCallbacks &gt; 0; &#125; for (let i = 0; i &lt; numOfCallbacks; i++) &#123; let event = this.events[type][i]; if ((scope ? event.scope == scope : true) &amp;&amp; event.callback == callback) &#123; return true; &#125; &#125; return false; &#125; emit(type, target, ...args) &#123; if (typeof this.events[type] == &quot;undefined&quot;) &#123; return; &#125; let bag = &#123; type: type, target: target &#125;; args = [bag].concat(args); let events = this.events[type].slice(); let numOfCallbacks = events.length; for (let i = 0; i &lt; numOfCallbacks; i++) &#123; let event = events[i]; if (event &amp;&amp; event.callback) &#123; let concatArgs = args.concat(event.args); event.callback.apply(event.scope, concatArgs); &#125; &#125; &#125; debug() &#123; let str = &quot;&quot;; for (let type in this.events) &#123; let numOfCallbacks = this.events[type].length; for (let i = 0; i &lt; numOfCallbacks; i++) &#123; let event = this.events[type][i]; let className = &quot;Anonymous&quot;; if (event.scope) &#123; if (event.scope.constructor.name) &#123; className = event.scope.constructor.name; &#125; &#125; str += `$&#123;className&#125; listening for &quot;$&#123;type&#125;&quot;\n`; &#125; &#125; return str; &#125;&#125;;export default new EventBus(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;EventBus Examples&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;module&quot;&gt; import EventBus from &apos;/src/eventbus.js&apos;; // Simple example &#123; function myHandler(event) &#123; console.log(&quot;myHandler / type: &quot; + event.type); &#125; EventBus.on(&quot;my_event&quot;, myHandler); EventBus.emit(&quot;my_event&quot;); &#125; // Keeping the scope &#123; class TestClass1 &#123; constructor() &#123; this.className = &quot;TestClass1&quot;; EventBus.on(&quot;callback_event&quot;, this.callback, this); &#125; callback(event) &#123; console.log(this.className + &quot; / type: &quot; + event.type + &quot; / dispatcher: &quot; + event.target.className); &#125; &#125; class TestClass2 &#123; constructor() &#123; this.className = &quot;TestClass2&quot;; &#125; dispatch() &#123; EventBus.emit(&quot;callback_event&quot;, this); &#125; &#125; let t1 = new TestClass1(); let t2 = new TestClass2(); t2.dispatch(); &#125; // Passing additional parameters &#123; class TestClass1 &#123; constructor() &#123; this.className = &quot;TestClass1&quot;; EventBus.on(&quot;custom_event&quot;, this.doSomething, this); &#125; doSomething(event, param1, param2) &#123; console.log(this.className + &quot;.doSomething&quot;); console.log(&quot;type=&quot; + event.type); console.log(&quot;params=&quot; + param1 + param2); console.log(&quot;coming from=&quot; + event.target.className); &#125; &#125; class TestClass2 &#123; constructor() &#123; this.className = &quot;TestClass2&quot;; &#125; ready() &#123; EventBus.emit(&quot;custom_event&quot;, this, &quot;javascript events&quot;, &quot; are really useful&quot;); &#125; &#125; let t1 = new TestClass1(); let t2 = new TestClass2(); t2.ready(); &#125; // Debugging console.log(EventBus.debug()); // Removing a registered handler &#123; var handler = function() &#123; console.log(&apos;example callback&apos;); &#125;; EventBus.on(&apos;EXAMPLE_EVENT&apos;, handler); EventBus.emit(&apos;EXAMPLE_EVENT&apos;); EventBus.off(&apos;EXAMPLE_EVENT&apos;, handler); // Not emitted because event was removed EventBus.emit(&apos;EXAMPLE_EVENT&apos;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端代码异常监控实战]]></title>
    <url>%2F2018%2F09%2F16%2F%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[把前端监控做到极致 - 掘金线上压缩代码-定位错误 - 掘金生产环境没有source-map文件，上报的错误都不好定位，这里实现一个简单的错误定位脚本 1、获取压缩代码错误信息（行数、列数、错误信息，错误文件） 这里通过控制台看错误信息window.addEventListener(&apos;error&apos;, function (e) { console.debug(&apos;lineno: &apos;, e.lineno, &apos; colno: &apos;, e.colno) console.debug(&apos;errorMessage:&apos;, e.message) console.debug(&apos;errorFile:&apos;, e.filename) }, true) 我们写一段错误的代码（single.vue的片段） method: { test (option) { const data = option.test const dataTest = option.data.test return data + dataTest } }, created () { // 设置异步错误的原因是，同步的错误会被vue捕获 setTimeout(() =&gt; { this.test({ testOption: 1 }) }, 300) } 在浏览器中运行，报错结果如下 得到错误信息： 错误行数：1 错误列数：59236 错误信息：cannot read property ‘test’ of undefined 错误文件：0.0a77f.js 2、定位错误的node脚本123456789101112131415161718192021222324252627282930313233343536## 安装依赖source-map npm install source-map node脚本如下（map/index.js） // 读取文件var fs = require(&apos;fs&apos;)// souceMap处理文件var SourceMapConsumer = require(&apos;source-map&apos;).SourceMapConsumer// 启动构建进程（已构建则不需要）var exec = require(&apos;child_process&apos;).execvar lineno = process.argv[2] || 0 // 第一个参数为行数var columnno = process.argv[3] || 0 // 第二个参数为列数var fileName = process.argv[4] || &apos;&apos; // 第三个参数为错误文件（错误文件名就好）// 构建有map的线上代码// node build onlineMap为构建命令exec(&apos;node build onlineMap&apos;, function () &#123; // 读取错误文件的map文件 var consumer = new SourceMapConsumer(fs.readFileSync(&apos;./dist/&apos; + fileName + &apos;.map&apos;, &apos;utf8&apos;)) // 输出map的错误信息 console.log(consumer.originalPositionFor(&#123; line: +lineno, // +是为了转化为数字 column: +columnno &#125;))&#125;)` 运行node脚本 node map 1 59236 0.0a77f.js 效果如下： 结合控制台输出的信息，就可以定位到错误代码了 我们再来看一下，给代码开启source-map，看错误信息是否一致 错误代码的位置定位是准确的，证明可行。 3、后续扩展思路 目前实现的是比较简单的脚本，所以存在一些问题： 需要当前构建内容和线上是一致的 操作比较繁琐 优化思路如下： 后续优化慢慢补充~ 前言之前在对公司的前端代码脚本错误进行排查，试图降低 JS Error 的错误量，结合自己之前的经验对这方面内容进行了实践并总结，下面就此谈谈我对前端代码异常监控的一些见解。 本文大致围绕下面几点展开讨论： JS 处理异常的方式 上报方式 异常监控上报常见问题 JS 异常处理对于 Javascript 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。 当前代码块将作为一个任务压入任务队列中，JS 线程会不断地从任务队列中提取任务执行。 当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务的执行。 JS 线程会继续从任务队列中提取下一个任务继续执行。 error console.log('永远不会执行'); console.log('我继续执行') 在对脚本错误进行上报之前，我们需要对异常进行处理，程序需要先感知到脚本错误的发生，然后再谈异常上报。 脚本错误一般分为两种：语法错误，运行时错误。 下面就谈谈几种异常监控的处理方式： try-catch 异常处理try-catch 在我们的代码中经常见到，通过给代码块进行 try-catch 进行包装后，当代码块发生出错时 catch 将能捕捉到错误的信息，页面也将可以继续执行。 但是 try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误和异步错误就显得无能为力，捕捉不到。 示例：运行时错误try { error // 未定义变量 } catch(e) { console.log(&apos;我知道错误了&apos;); console.log(e); } 然而对于语法错误和异步错误就捕捉不到了。 示例：语法错误try { var error = &apos;error&apos;； // 大写分号 } catch(e) { console.log(&apos;我感知不到错误&apos;); console.log(e); } 一般语法错误在编辑器就会体现出来，常表现的错误信息为： Uncaught SyntaxError: Invalid or unexpected token xxx 这样。但是这种错误会直接抛出异常，常使程序崩溃，一般在编码时候容易观察得到。 示例：异步错误try { setTimeout(() =&gt; { error // 异步错误 }) } catch(e) { console.log(&apos;我感知不到错误&apos;); console.log(e); } 除非你在 setTimeout 函数中再套上一层 try-catch，否则就无法感知到其错误，但这样代码写起来比较啰嗦。 window.onerror 异常处理window.onerror 捕获异常能力比 try-catch 稍微强点，无论是异步还是非异步错误，onerror 都能捕获到运行时错误。 示例：运行时同步错误 /** * @param {String} msg 错误信息 * @param {String} url 出错文件 * @param {Number} row 行号 * @param {Number} col 列号 * @param {Object} error 错误详细信息 */ window.onerror = function (msg, url, row, col, error) { console.log(&apos;我知道错误了&apos;); console.log({ msg, url, row, col, error }) return true; }; error; 示例：异步错误 window.onerror = function (msg, url, row, col, error) { console.log(&apos;我知道异步错误了&apos;); console.log({ msg, url, row, col, error }) return true; }; setTimeout(() =&gt; { error; }); 然而 window.onerror 对于语法错误还是无能为力，所以我们在写代码的时候要尽可能避免语法错误的，不过一般这样的错误会使得整个页面崩溃，还是比较容易能够察觉到的。 在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。 需要注意的是，window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。 关于 window.onerror 还有两点需要值得注意 对于 onerror 这种全局捕获，最好写在所有 JS 脚本的前面，因为你无法保证你写的代码是否出错，如果写在后面，一旦发生错误的话是不会被 onerror 捕获到的。 另外 onerror 是无法捕获到网络异常的错误。 当我们遇到 &lt;img src=&quot;./404.png&quot;&gt; 报 404 网络请求异常的时候，onerror 是无法帮助我们捕获到异常的。 &lt;script&gt; window.onerror = function (msg, url, row, col, error) { console.log(&apos;我知道异步错误了&apos;); console.log({ msg, url, row, col, error }) return true; }; &lt;/script&gt; &lt;img src=&quot;./404.png&quot;&gt; 由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。 &lt;script&gt; window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; { console.log(&apos;我知道 404 错误了&apos;); console.log( msg, url, row, col, error ); return true; }, true); &lt;/script&gt; &lt;img src=&quot;./404.png&quot; alt=&quot;&quot;&gt; 这点知识还是需要知道，要不然用户访问网站，图片 CDN 无法服务，图片加载不出来而开发人员没有察觉就尴尬了。 Promise 错误通过 Promise 可以帮助我们解决异步回调地狱的问题，但是一旦 Promise 实例抛出异常而你没有用 catch 去捕获的话，onerror 或 try-catch 也无能为力，无法捕捉到错误。 window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; { console.log(&apos;我感知不到 promise 错误&apos;); console.log( msg, url, row, col, error ); }, true); Promise.reject(&apos;promise error&apos;); new Promise((resolve, reject) =&gt; { reject(&apos;promise error&apos;); }); new Promise((resolve) =&gt; { resolve(); }).then(() =&gt; { throw &apos;promise error&apos; }); 虽然在写 Promise 实例的时候养成最后写上 catch 函数是个好习惯，但是代码写多了就容易糊涂，忘记写 catch。 所以如果你的应用用到很多的 Promise 实例的话，特别是你在一些基于 promise 的异步库比如 axios 等一定要小心，因为你不知道什么时候这些异步请求会抛出异常而你并没有处理它，所以你最好添加一个 Promise 全局异常捕获事件 unhandledrejection。 window.addEventListener(&quot;unhandledrejection&quot;, function(e){ e.preventDefault() console.log(&apos;我知道 promise 的错误了&apos;); console.log(e.reason); return true; }); Promise.reject(&apos;promise error&apos;); new Promise((resolve, reject) =&gt; { reject(&apos;promise error&apos;); }); new Promise((resolve) =&gt; { resolve(); }).then(() =&gt; { throw &apos;promise error&apos; }); 当然，如果你的应用没有做 Promise 全局异常处理的话，那很可能就像某乎首页这样： 异常上报方式监控拿到报错信息之后，接下来就需要将捕捉到的错误信息发送到信息收集平台上，常用的发送形式主要有两种: 通过 Ajax 发送数据 动态创建 img 标签的形式 实例 - 动态创建 img 标签进行上报 function report(error) { var reportUrl = &apos;http://xxxx/report&apos;; new Image().src = reportUrl + &apos;error=&apos; + error; } 监控上报常见问题下述例子我全部放在我的 github 上，读者可以自行查阅，后面不再赘述。 git clone https://github.com/happylindz/blog.git cd blog/code/jserror/ npm install Script error 脚本错误是什么因为我们在线上的版本，经常做静态资源 CDN 化，这就会导致我们常访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。 可通过 npm run nocors 查看效果。 Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。 这样做的目的是避免数据泄露到不安全的域中，举个简单的例子， &lt;script src=&quot;xxxx.com/login.html&quot;&gt;&lt;/script&gt; 上面我们并没有引入一个 js 文件，而是一个 html，这个 html 是银行的登录页面，如果你已经登录了，那 login 页面就会自动跳转到 Welcome xxx...，如果未登录则跳转到 Please Login...，那么报错也会是 Welcome xxx... is not defined，Please Login... is not defined，通过这些信息可以判断一个用户是否登录他的帐号，给入侵者提供了十分便利的判断渠道，这是相当不安全的。 介绍完背景后，那么我们应该去解决这个问题？ 首先可以想到的方案肯定是同源化策略，将 JS 文件内联到 html 或者放到同域下，虽然能简单有效地解决 script error 问题，但是这样无法利用好文件缓存和 CDN 的优势，不推荐使用。正确的方法应该是从根本上解决 script error 的错误。 跨源资源共享机制( CORS )首先为页面上的 script 标签添加 crossOrigin 属性 // http://localhost:8080/index.html &lt;script&gt; window.onerror = function (msg, url, row, col, error) { console.log(&apos;我知道错误了，也知道错误信息&apos;); console.log({ msg, url, row, col, error }) return true; }; &lt;/script&gt; &lt;script src=&quot;http://localhost:8081/test.js&quot; crossorigin&gt;&lt;/script&gt; // http://localhost:8081/test.js setTimeout(() =&gt; { console.log(error); }); 当你修改完前端代码后，你还需要额外给后端在响应头里加上 Access-Control-Allow-Origin: localhost:8080，这里我以 Koa 为例。 const Koa = require(&apos;koa&apos;); const path = require(&apos;path&apos;); const cors = require(&apos;koa-cors&apos;); const app = new Koa(); app.use(cors()); app.use(require(&apos;koa-static&apos;)(path.resolve(__dirname, &apos;./public&apos;))); app.listen(8081, () =&gt; { console.log(&apos;koa app listening at 8081&apos;) }); 读者可通过 npm run cors 详细的跨域知识我就不展开了，有兴趣可以看看我之前写的文章：跨域，你需要知道的全在这里 你以为这样就完了吗？并没有，下面就说一些 Script error 你不常遇见的点： 我们都知道 JSONP 是用来跨域获取数据的，并且兼容性良好，在一些应用中仍然会使用到，所以你的项目中可能会用这样的代码： // http://localhost:8080/index.html window.onerror = function (msg, url, row, col, error) { console.log(&apos;我知道错误了，但不知道错误信息&apos;); console.log({ msg, url, row, col, error }) return true; }; function jsonpCallback(data) { console.log(data); } const url = &apos;http://localhost:8081/data?callback=jsonpCallback&apos;; const script = document.createElement(&apos;script&apos;); script.src = url; document.body.appendChild(script); 因为返回的信息会当做脚本文件来执行，一旦返回的脚本内容出错了，也是无法捕捉到错误的信息。 解决办法也不难，跟之前一样，在添加动态添加脚本的时候加上 crossOrigin，并且在后端配上相应的 CORS 字段即可. const script = document.createElement(&apos;script&apos;); script.crossOrigin = &apos;anonymous&apos;; script.src = url; document.body.appendChild(script); 读者可以通过 npm run jsonp 查看效果 知道原理之后你可能会觉得没什么，不就是给每个动态生成的脚本添加 crossOrigin 字段嘛，但是在实际工程中，你可能是面向很多库来编程，比如使用 jQuery，Seajs 或者 webpack 来异步加载脚本，许多库封装了异步加载脚本的能力，以 jQeury 为例你可能是这样来触发异步脚本。 $.ajax({ url: &apos;http://localhost:8081/data&apos;, dataType: &apos;jsonp&apos;, success: (data) =&gt; { console.log(data); } }) 假如这些库中没有提供 crossOrigin 的能力的话(jQuery jsonp 可能有，假装你不知道)，那你只能去修改人家写的源代码了，所以我这里提供一个思路，就是去劫持 document.createElement，从根源上去为每个动态生成的脚本添加 crossOrigin 字段。 document.createElement = (function() { const fn = document.createElement.bind(document); return function(type) { const result = fn(type); if(type === &apos;script&apos;) { result.crossOrigin = &apos;anonymous&apos;; } return result; } })(); window.onerror = function (msg, url, row, col, error) { console.log(&apos;我知道错误了，也知道错误信息&apos;); console.log({ msg, url, row, col, error }) return true; }; $.ajax({ url: &apos;http://localhost:8081/data&apos;, dataType: &apos;jsonp&apos;, success: (data) =&gt; { console.log(data); } }) 效果也是一样的，读者可以通过 npm run jsonpjq 来查看效果： 这样重写 createElement 理论上没什么问题，但是入侵了原本的代码，不保证一定不会出错，在工程上还是需要多尝试下看看再使用，可能存在兼容性上问题，如果你觉得会出现什么问题的话也欢迎留言讨论下。 关于 Script error 的问题就写到这里，如果你理解了上面的内容，基本上绝大部分的 Script error 都能迎刃而解。 window.onerror 能否捕获 iframe 的错误当你的页面有使用 iframe 的时候，你需要对你引入的 iframe 做异常监控的处理，否则一旦你引入的 iframe 页面出现了问题，你的主站显示不出来，而你却浑然不知。 首先需要强调，父窗口直接使用 window.onerror 是无法直接捕获，如果你想要捕获 iframe 的异常的话，有分好几种情况。 如果你的 iframe 页面和你的主站是同域名的话，直接给 iframe 添加 onerror 事件即可。 &lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; &lt;script&gt; window.frames[0].onerror = function (msg, url, row, col, error) { console.log(&apos;我知道 iframe 的错误了，也知道错误信息&apos;); console.log({ msg, url, row, col, error }) return true; }; &lt;/script&gt; 读者可以通过 npm run iframe 查看效果： 如果你嵌入的 iframe 页面和你的主站不是同个域名的，但是 iframe 内容不属于第三方，是你可以控制的，那么可以通过与 iframe 通信的方式将异常信息抛给主站接收。与 iframe 通信的方式有很多，常用的如：postMessage，hash 或者 name 字段跨域等等，这里就不展开了，感兴趣的话可以看：跨域，你需要知道的全在这里 如果是非同域且网站不受自己控制的话，除了通过控制台看到详细的错误信息外，没办法捕获，这是出于安全性的考虑，你引入了一个百度首页，人家页面报出的错误凭啥让你去监控呢，这会引出很多安全性的问题。 压缩代码如何定位到脚本异常位置线上的代码几乎都经过了压缩处理，几十个文件打包成了一个并丑化代码，当我们收到 a is not defined 的时候，我们根本不知道这个变量 a 究竟是什么含义，此时报错的错误日志显然是无效的。 第一想到的办法是利用 sourcemap 定位到错误代码的具体位置，详细内容可以参考：Sourcemap 定位脚本错误 另外也可以通过在打包的时候，在每个合并的文件之间添加几行空格，并相应加上一些注释，这样在定位问题的时候很容易可以知道是哪个文件报的错误，然后再通过一些关键词的搜索，可以快速地定位到问题的所在位置。 收集异常信息量太多，怎么办如果你的网站访问量很大，假如网页的 PV 有 1kw，那么一个必然的错误发送的信息就有 1kw 条，我们可以给网站设置一个采集率： Reporter.send = function(data) { // 只采集 30% if(Math.random() &lt; 0.3) { send(data) // 上报错误信息 } } 这个采集率可以通过具体实际的情况来设定，方法多样化，可以使用一个随机数，也可以具体根据用户的某些特征来进行判定。 上面差不多是我对前端代码监控的一些理解，说起来容易，但是一旦在工程化运用，难免需要考虑到兼容性等种种问题，读者可以通过自己的具体情况进行调整，前端代码异常监控对于我们的网站的稳定性起着至关重要的作用。如若文中所有不对的地方，还望指正。]]></content>
      <tags>
        <tag>错误监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS之call和apply,bind的模拟实现]]></title>
    <url>%2F2018%2F09%2F02%2FJS%E4%B9%8Bcall%E5%92%8Capply-bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[call一句话介绍 call： call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。 举个例子： var foo = { value: 1 }; function bar() { console.log(this.value); } bar.call(foo); // 1 注意两点： call 改变了 this 的指向，指向到 foo bar 函数执行了 模拟实现第一步那么我们该怎么模拟实现这两个效果呢？ 试想当调用 call 的时候，把 foo 对象改造成如下： var foo = { value: 1, bar: function() { console.log(this.value) } }; foo.bar(); // 1 这个时候 this 就指向了 foo，是不是很简单呢？ 但是这样却给 foo 对象本身添加了一个属性，这可不行呐！ 不过也不用担心，我们用 delete 再删除它不就好了~ 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 以上个例子为例，就是： // 第一步 foo.fn = bar // 第二步 foo.fn() // 第三步 delete foo.fn fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。 根据这个思路，我们可以尝试着去写第一版的 call2 函数： // 第一版 Function.prototype.call2 = function(context) { // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn; } // 测试一下 var foo = { value: 1 }; function bar() { console.log(this.value); } bar.call2(foo); // 1 正好可以打印 1 哎！是不是很开心！(～￣▽￣)～ 模拟实现第二步最一开始也讲了，call 函数还能给定参数执行函数。举个例子： var foo = { value: 1 }; function bar(name, age) { console.log(name) console.log(age) console.log(this.value); } bar.call(foo, &apos;kevin&apos;, 18); // kevin // 18 // 1 注意：传入的参数并不确定，这可咋办？ 不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。 比如这样： // 以上个例子为例，此时的arguments为： // arguments = { // 0: foo, // 1: &apos;kevin&apos;, // 2: 18, // length: 3 // } // 因为arguments是类数组对象，所以可以用for循环 var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push(&apos;arguments[&apos; + i + &apos;]&apos;); } // 执行后 args为 [foo, &apos;kevin&apos;, 18] 不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。 // 将数组里的元素作为多个参数放进函数的形参里 context.fn(args.join(&apos;,&apos;)) // (O_o)?? // 这个方法肯定是不行的啦！！！ 也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样： eval(&apos;context.fn(&apos; + args +&apos;)&apos;) 这里 args 会自动调用 Array.toString() 这个方法。 所以我们的第二版克服了两个大问题，代码如下： // 第二版 Function.prototype.call2 = function(context) { context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push(&apos;arguments[&apos; + i + &apos;]&apos;); } eval(&apos;context.fn(&apos; + args +&apos;)&apos;); delete context.fn; } // 测试一下 var foo = { value: 1 }; function bar(name, age) { console.log(name) console.log(age) console.log(this.value); } bar.call2(foo, &apos;kevin&apos;, 18); // kevin // 18 // 1 (๑•̀ㅂ•́) ✧ 模拟实现第三步模拟代码已经完成 80%，还有两个小点要注意： 1.this 参数可以传 null，当为 null 的时候，视为指向 window 举个例子： var value = 1; function bar() { console.log(this.value); } bar.call(null); // 1 虽然这个例子本身不使用 call，结果依然一样。 2.函数是可以有返回值的！ 举个例子： var obj = { value: 1 } function bar(name, age) { return { value: this.value, name: name, age: age } } console.log(bar.call(obj, &apos;kevin&apos;, 18)); // Object { // value: 1, // name: &apos;kevin&apos;, // age: 18 // } 不过都很好解决，让我们直接看第三版也就是最后一版的代码： // 第三版 Function.prototype.call2 = function (context) { var context = context || window; context.fn = this; var args = []; for(var i = 1, len = arguments.length; i &lt; len; i++) { args.push(&apos;arguments[&apos; + i + &apos;]&apos;); } var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;); delete context.fn return result; } // 测试一下 var value = 2; var obj = { value: 1 } function bar(name, age) { console.log(this.value); return { value: this.value, name: name, age: age } } bar.call(null); // 2 console.log(bar.call2(obj, &apos;kevin&apos;, 18)); // 1 // Object { // value: 1, // name: &apos;kevin&apos;, // age: 18 // } 到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ apply的模拟实现apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现： Function.prototype.apply = function (context, arr) { var context = Object(context) || window; context.fn = this; var result; if (!arr) { result = context.fn(); } else { var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) { args.push(&apos;arr[&apos; + i + &apos;]&apos;); } result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;) } delete context.fn return result; } 类数组转对象 在上面的例子中已经提到了一种类数组转数组的方法，再补充三个： var arrayLike = {0: &apos;name&apos;, 1: &apos;age&apos;, 2: &apos;sex&apos;, length: 3 } // 1. slice Array.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 2. splice Array.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 3. ES6 Array.from Array.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 4. apply Array.prototype.concat.apply([], arrayLike) 要说到类数组对象，Arguments 对象就是一个类数组对象。 在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。 传递参数 将参数从一个函数传递到另一个函数 // 使用 apply 将 foo 的参数传递给 bar function foo() { bar.apply(this, arguments); } function bar(a, b, c) { console.log(a, b, c); } foo(1, 2, 3) 强大的ES6 使用ES6的 ... 运算符，我们可以轻松转成数组。 function func(...arguments) { console.log(arguments); // [1, 2, 3] } func(1, 2, 3); bind一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 返回函数的模拟实现从第一个特点开始，我们举个例子： var foo = { value: 1 }; function bar() { console.log(this.value); } // 返回了一个函数 var bindFoo = bar.bind(foo); bindFoo(); // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看《JavaScript深入之call和apply的模拟实现》。我们来写第一版的代码： // 第一版 Function.prototype.bind2 = function (context) { var self = this; return function () { self.apply(context); } } 传参的模拟实现接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： var foo = { value: 1 }; function bar(name, age) { console.log(this.value); console.log(name); console.log(age); } var bindFoo = bar.bind(foo, &apos;daisy&apos;); bindFoo(&apos;18&apos;); // 1 // daisy // 18 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 这可咋办？不急，我们用 arguments 进行处理： // 第二版 Function.prototype.bind2 = function (context) { var self = this; // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1); return function () { // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); self.apply(context, args.concat(bindArgs)); } } 构造函数效果的模拟实现完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： var value = 2; var foo = { value: 1 }; function bar(name, age) { this.habit = &apos;shopping&apos;; console.log(this.value); console.log(name); console.log(age); } bar.prototype.friend = &apos;kevin&apos;; var bindFoo = bar.bind(foo, &apos;daisy&apos;); var obj = new bindFoo(&apos;18&apos;); // undefined // daisy // 18 console.log(obj.habit); console.log(obj.friend); // shopping // kevin 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 (哈哈，我这是为我的下一篇文章《JavaScript深入系列之new的模拟实现》打广告)。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： // 第三版 Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); } // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound; } 如果对原型链稍有困惑，可以查看《JavaScript深入之从原型到原型链》。 构造函数效果的优化实现但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： // 第四版 Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; } 到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ 三个小问题接下来处理些小问题: 1.apply 这段代码跟 MDN 上的稍有不同 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是： self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于 context 是否存在的判断，然而这个是错误的！ 举个例子： var value = 2; var foo = { value: 1, bar: bar.bind(null) }; function bar() { console.log(this.value); } foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ 2.调用 bind 的不是函数咋办？ 不行，我们要报错！ if (typeof this !== &quot;function&quot;) { throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } 3.我要在线上用 那别忘了做个兼容： Function.prototype.bind = Function.prototype.bind || function () { …… }; 当然最好是用 es5-shim 啦。 最终代码所以最最后的代码就是： Function.prototype.bind2 = function (context) { if (typeof this !== &quot;function&quot;) { throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;); } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; }]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的 this !]]></title>
    <url>%2F2018%2F08%2F31%2FJavaScript-%E4%B8%AD%E7%9A%84-this%2F</url>
    <content type="text"><![CDATA[在 js 中，this 这个上下文总是变化莫测，很多时候出现 bug 总是一头雾水，其实，只要分清楚不同的情况下如何执行就 ok 了。 全局执行首先，我们在全局环境中看看它的 this 是什么： first. 浏览器： console.log(this); // Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…} 可以看到打印出了 window 对象； second. node： console.log(this); // global 可以看到打印出了 global 对象； 总结：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。 函数中执行纯粹的函数调用这是最普通的函数使用方法了： function test() { console.log(this); }; test(); // Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…} 我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象； 严格模式 ‘use strict’; 如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为： &apos;use strict&apos;; function test() { console.log(this); }; test(); // undefined 当然，把它放在一个立即执行函数中会更好，避免了污染全局： (function (){ &quot;use strict&quot;; console.log(this); })(); // undefined 作为对象的方法调用当一个函数被当作一个对象的方法调用的时候： var obj = { name: &apos;qiutc&apos;, foo: function() { console.log(this.name); } } obj.foo(); // &apos;qiutc&apos; 这时候，this 指向当前的这个对象； 当然，我们还可以这么做： function test() { console.log(this.name); } var obj = { name: &apos;qiutc&apos;, foo: test } obj.foo(); // &apos;qiutc&apos; 同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 test ，它只是一个函数名，函数的引用，它指向这个函数，当 foo = test，foo 同样也指向了这个函数。 如果把对象的方法赋值给一个变量，然后直接调用这个变量呢： var obj = { name: &apos;qiutc&apos;, foo: function() { console.log(this); } } var test = obj.foo; test(); // Window 可以看到，这时候 this 执行了全局，当我们把 test = obj.foo ，test 直接指向了一个函数的引用，这时候，其实和 obj 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，this 指向全局对象。 一些坑 我们经常在回调函数里面会遇到一些坑： var obj = { name: &apos;qiutc&apos;, foo: function() { console.log(this); }, foo2: function() { console.log(this); //Object {name: &quot;qiutc&quot;...} setTimeout(this.foo, 1000); // window 对象 } } obj.foo2(); 执行这段代码我们会发现两次打印出来的 this 是不一样的： 关于setTimeout的this指向：https://www.talkingcoder.com/article/6356947525374513523 第一次是 foo2 中直接打印 this，这里指向 obj 这个对象，我们毋庸置疑； 但是在 setTimeout 中执行的 this.foo，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑；其实，setTimeout 也只是一个函数而已，函数必然有可能需要参数，我们把 this.foo 当作一个参数传给 setTimeout 这个函数，就像它需要一个 fun 参数，在传入参数的时候，其实做了个这样的操作 fun = this.foo，看到没有，这里我们直接把 fun 指向 this.foo 的引用；执行的时候其实是执行了 fun() 所以已经和 obj 无关了，它是被当作普通函数直接调用的，因此 this 指向全局对象。 这个问题是很多异步回调函数中普遍会碰到的； 解决 为了解决这个问题，我们可以利用 闭包 的特性来处理： var obj = { name: &apos;qiutc&apos;, foo: function() { console.log(this); }, foo2: function() { console.log(this); var _this = this; setTimeout(function() { console.log(this); // Window console.log(_this); // Object {name: &quot;qiutc&quot;} }, 1000); } } obj.foo2(); 可以看到直接用 this 仍然是 Window；因为 foo2 中的 this 是指向 obj，我们可以先用一个变量 _this 来储存，然后在回调函数中使用 _this，就可以指向当前的这个对象了； setTimeout 的另一个坑 之前啊说过，如果直接执行回调函数而没有绑定作用域，那么它的 this 是指向全局对象(window)，在严格模式下会指向 undefined，然而在 setTimeout 中的回调函数在严格模式下却表现出不同： &apos;use strict&apos;; function foo() { console.log(this); } setTimeout(foo, 1); // window 按理说我们加了严格模式，foo 调用也没有指定 this，应该是出来 undefined，但是这里仍然出现了全局对象，难道是严格模式失效了吗？ 并不，即使在严格模式下，setTimeout 方法在调用传入函数的时候，如果这个函数没有指定了的 this，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 foo.apply(window) 而非 foo()； 当然，如果我们在传入函数的时候已经指定 this，那么就不会被注入全局对象，比如： setTimeout(foo.bind(obj), 1);； http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code 作为一个构造函数使用在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 new 这个关键字： function Person(name) { this.name = name; console.log(this); } var p = new Person(&apos;qiutc&apos;); // Person {name: &quot;qiutc&quot;} 我们可以看到当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象； 当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局： function Person(name) { this.name = name; console.log(this); } var p = Person(&apos;qiutc&apos;); // Window 其区别在于，如何调用函数（new）。 箭头函数在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 this 的指向了，还记得在上文中（作为对象的方法调用-一些坑-解决）我们使用闭包来解决 this 的指向问题吗，如果用上了箭头函数就可以更完美的解决了： var obj = { name: &apos;qiutc&apos;, foo: function() { console.log(this); }, foo2: function() { console.log(this); setTimeout(() =&gt; { console.log(this); // Object {name: &quot;qiutc&quot;} }, 1000); } } obj.foo2(); 可以看到，在 setTimeout 执行的函数中，本应该打印出在 Window，但是在这里 this 却指向了 obj，原因就在于，给 setTimeout 传入的函数（参数）是一个箭头函数： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 根据例子我们理解一下这句话：在 obj.foo2() 执行的时候，当前的 this 指向 obj；在执行 setTimeout 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 this 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 this，也就是 obj.foo2 中的 this，即 obj；所以在执行箭头函数的时候，它的 this -&gt; obj.foo2 中的 this -&gt; obj； 简单来说， 箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。 call, apply, bind在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向： call fun.call(thisArg[, arg1[, arg2[, …]]]) 它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，后面的参数是执行函数需要传入的参数； apply fun.apply(thisArg[, [arg1, arg2, …]]) 它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）； bind var foo = fun.bind(thisArg[, arg1[, arg2[, …]]]); 它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数； 这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this），我们以 call 函数为例； 为一个普通函数指定 this var obj = { name: &apos;qiutc&apos; }; function foo() { console.log(this); } foo.call(obj); // Object {name: &quot;qiutc&quot;} 可以看到，在执行 foo.call(obj) 的时候，函数内的 this 指向了 obj 这个对象，成功； 为对象中的方法指定一个 this var obj = { name: &apos;qiutc&apos;, foo: function () { console.log(this); } } var obj2 = { name: &apos;tcqiu222222&apos; }; obj.foo.call(obj2); // Object {name: &quot;tcqiu222222&quot;} 可以看到，执行函数的时候这里的 this 指向了 obj2，成功； 为构造函数指定 this function Person(name) { this.name = name; console.log(this); } var obj = { name: &apos;qiutc2222222&apos; }; var p = new Person.call(obj, &apos;qiutc&apos;); // Uncaught TypeError: Person.call is not a constructor(…) 这里报了个错，原因是我们去 new 了 Person.call 函数，而非 Person ，这里的函数不是一个构造函数； 换成 bind 试试： function Person(name) { this.name = name; console.log(this); } var obj = { name: &apos;qiutc2222222&apos; }; var Person2 = Person.bind(obj); var p = new Person2(&apos;qiutc&apos;); // Person {name: &quot;qiutc&quot;} console.log(obj); // Object {name: &quot;qiutc2222222&quot;} 打印出来的是 Person 实例化出来的对象，而和 obj 没有关系，而 obj 也没有发生变化，说明，我们给 Person 指定 this 上下文并没有生效； 因此可以得出： 使用 bind 给一个构造函数指定 this，在 new 这个构造函数的时候，bind 函数所指定的 this 并不会生效； 当然 bind 不仅可以指定 this ，还能传入参数，我们来试试这个操作： function Person(name) { this.name = name; console.log(this); } var obj = { name: &apos;qiutc2222222&apos; }; var Person2 = Person.bind(obj, &apos;qiutc111111&apos;); var p = new Person2(&apos;qiutc&apos;); // Person {name: &quot;qiutc111111&quot;} 可以看到，虽然指定 this 不起作用，但是传入参数还是起作用了； 为箭头函数指定 this 我们来定义一个全局下的箭头函数，因此这个箭头函数中的 this 必然会指向全局对象，如果用 call 方法改变 this 呢： var afoo = (a) =&gt; { console.log(a); console.log(this); } afoo(1); // 1 // Window var obj = { name: &apos;qiutc&apos; }; afoo.call(obj, 2); // 2 // Window 可以看到，这里的 call 指向 this 的操作并没有成功，所以可以得出： 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this。 只要记住箭头函数大法好，不变的 this。 Function.prototype.call 格式:fx.call( thisArg [，arg1，arg2，… ] ); call的传参个数不限,第一个数表示调用函数(fx)函数体内this的指向.从第二个参数开始依次按序传入函数. var age = 40; var xiaoMing = { age:30 }; var xiaoLi = { age: 20 }; var getAge = function(){ console.log(this.age); }; getAge.call( xiaoMing ); //30 表示函数this指向xiaoMing getAge.call(xiaoLi); //20 表示函数this指向xiaoLi getAge.call(undefined);//40 getAge.call(undefined)==getAge.call(null) getAge.call(null);//40 getAge(); //40 如果我们传入fx.call()的第一个参数数为null,那么表示函数fx体内this指向宿主对象,在浏览器是Window对象,这也解释了getAge.call(undefined);//40。 在此基础我们可以理解为 getAge()相当于getAge.call(null/undefined),扩展到所有函数,fx()==fx.call(null) == fx.call(undefined) 值得注意的是严格模式下有点区别: this指向null var getAge = function(){ &apos;use strict&apos; console.log(this.age); }; getAge(null);//报错 age未定义 再来理解this的使用 this的常用场景: this位于一个对象的方法内,此时this指向该对象 var name = ‘window’; var Student = { name : &apos;kobe&apos;, getName: function () { console.log(this == Student); //true console.log(this.name); //kobe } } Student.getName(); var name = ‘window’; var Student = { name : &apos;kobe&apos;, getName: function () { var name=100; console.log(this == Student); //true console.log(this.name); //kobe } } Student.getName(); //getName取得是Student 的name this位于一个普通的函数内,表示this指向全局对象,(浏览器是window) var name = ‘window’; var getName = function () { var name = &apos;kobe&apos;; //迷惑性而已 return this.name; } console.log( getName() ); //window this使用在构造函数(构造器)里面,表示this指向的是那个返回的对象. var name = ‘window’; //构造器 var Student = function () { this.name = &apos;student&apos;; } var s1 = new Student(); console.log(s1.name); //student 注意: 如果构造器返回的也是一个Object的对象(其他类型this指向不变遵循之前那个规律),这时候this指的是返回的这个Objec. var name = &apos;window&apos;; //构造器 var Student = function () { this.name = &apos;student&apos;; return { name: &apos;boyStudent&apos; } } var s1 = new Student(); console.log(s1.name); //boyStudent this指向失效问题 var name = ‘window’; var Student = { name : &apos;kobe&apos;, getName: function () { console.log(this.name); } } Student.getName(); // kobe var s1 = Student.getName; s1(); //window 原因: 此时s1是一个函数 function () { console.log(this.name); } 对一个基本的函数,前面提过this在基本函数中指的是window. 在开发中我们经常使用的this缓存法 ,缓存当前作用域下this到另外一个环境域下使用 最后理解apply的用法 Function.prototype.apply 格式: fx.apply(thisArg [，argArray] ); // 参数数组，argArray apply与call的作用是一样的,只是传参方式不同, apply接受两个参数,第一个也是fx函数体内this的指向,用法与call第一个参数一致.第二个参数是数组或者类数组,apply就是把这个数组元素传入函数fx. var add = function (a ,b ,c) { console.log(a +b +c); } add.apply(null , [1,2,3]); // 6 再吃透这个题目就ok var a=10; var foo={ a:20, bar:function(){ var a=30; return this.a; } } foo.bar() //20 (foo.bar)() //20 (foo.bar=foo.bar)() //10 (foo.bar,foo.bar)() //10 上题注解： 时刻牢记：作用域链查找遵循”就近原则”；this谁调用就指向谁。var a=10; var foo={ a:20, bar:function(){ var a=30; //this 指向 foo ：console.log( this == foo) //true return this.a; } } foo.bar() //20 // foo.bar() // foo调用，this指向foo , 此时的 this 指的是foo，所以是20 (foo.bar)() //20 //第一步： (function(){ var a=30; return this.a; })() //作用域链向上查找,this 指向外一层的对象foo (foo.bar=foo.bar)() //10 foo.bar=foo.bar,【睁大眼睛，是单等号赋值】就是普通的复制,一个匿名函数赋值给一个全局变量,你可以把右边的foo.bar换成b, 即(b = foo.bar)(),博客里面【this指向失效问题】说过普通的函数里面的this指向window,自然this.a == 10 (foo.bar,foo.bar)() //逗号表达式 //10 //(foo.bar,foo.bar)是一个小括号表达式,小括号表达式会依次创建两个匿名函数,并返回最后一个的匿名函数值, (foo.bar,foo.bar) 得到的是这个函数 function(){ var a=30; console.log( this == foo); //如果不是很了解this的指向就加这个代码进行检测 return this.a; } ,这个是匿名函数,匿名函数的this指的是widnow,那么this.a = 10 this可谓是JavaScript中的开发神器，使用得当的话不仅有事半功倍的效果，而且代码的逼格也更高。但是既然是神器，如果你没有足够的功力的话，那么就不要使用它，否则就有可能自毁身亡。曾几何时，我偶然得到这个神器，之后，，，自残，，，自残，，，再自残...再自残了那么多次后，终于可以拥有强大功力持此神器行走江湖了。接下来，我就为大家来传授传说中神器的使用秘诀。 咳咳。。 入正题。 this是什么？this表示当前运行方法的主体。 注意：函数中的this指向和当前函数在哪定义的话或者在哪执行都没有任何的关系。为啥这样说，请仔细阅读下面的秘籍大全。 神器秘籍大全： 秘籍一：自制行函数里面的this永远都是window var inner = &quot;window&quot;; var obj = {inner : &quot;obj&quot;, fn : (function () {console.log(this.inner)})() } 上面浏览器在运行该程序时，会自动运行obj.fn里面的方法，因为obj.fn是一个自制行函数，当执行该函数时，程序会输出window。 额，为什么输出不是obj？ 因为人家规定自制行函数里面的this是window,所以其实this.inner就是window.inner，因此这个inner是定义在全局变量的，它的值是&quot;window&quot;。 秘籍二：元素绑定事件驱动方法运行，方法里的this表示当前绑定的元素 var oDiv = document.getElementsByTagName(&quot;div&quot;)[0]; oDiv.onclick=function(){ console.log(this); //当用鼠标点击该元素，则输出oDiv元素的集合 }; 这个好理解，元素绑定某个行为执行的方法，就相当于把这个方法也绑定在这个元素上，所以this也就指向元素本身。 秘籍三：方法执行，看方法名前面是否有&quot;.&quot;，有的话&quot;.&quot;前面是谁this就是谁，没有的话this就是window var obj={fn:fn}; function fn(){console.log(this)} fn.prototype.aa=function(){console.log(this)}; var f=new fn; fn(); //window.. obj.fn(); //Object.. fn.prototype.aa(); //fn.prototype f.aa(); //f 记住此秘籍！！！ 秘籍四：在构造函数模式中,函数体中的this是当前类的一个实例 function Fn(){ this.x = 100; console.log(this); // 实例 f } var f = new Fn; 构造函数生成的实例，故构造函数里的this当然是指向当前这个实例了。 秘籍五（大招）：call/apply来改变this的指向 var oDiv = document.getElementsByTagName(&quot;div&quot;)[0]; function fn() { console.log(this); } fn.call(oDiv); fn.call(oDiv); //执行这个语句后，fn里面的this指向oDiv元素，applay用法与call类似。 此大招一出来，上面四个秘籍都无效了。 五个典型的 JavaScript 面试题问题1: 范围（Scope）思考以下代码： 控制台（console）会打印出什么？ 答案 上述代码会打印出5。 这个问题的陷阱就是，在立即执行函数表达式（IIFE）中，有两个命名，但是其中变量是通过关键词var来声明的。这就意味着a是这个函数的局部变量。与此相反，b是在全局作用域下的。 这个问题另一个陷阱就是，在函数中他没有使用”严格模式” (‘use strict’;)。如果 严格模式 开启，那么代码就会报出未捕获引用错误（Uncaught ReferenceError）：b没有定义。记住，严格模式要求你在需要使用全局变量时，明确地引用该变量。因此，你需要像下面这么写： 问题2: 创建 “原生（native）” 方法在String对象上定义一个repeatify函数。这个函数接受一个整数参数，来明确字符串需要重复几次。这个函数要求字符串重复指定的次数。举个例子： 应该打印出hellohellohello. 答案 一种可能的实现如下所示： 这个问题测试了开发人员对于JavaScript中继承的掌握，以及prototype这个属性。这也验证了开发人员是否有能力扩展原生数据类型的功能（虽然不应该这么做）。 这个问题的另一个重点是验证你是否意识到并知道如何避免覆盖已经存在的函数。这可以通过在自定义函数之前判断该函数是否存在来做到。 当你需要为旧浏览器实现向后兼容的函数时，这一技巧十分有用。 问题3: 变量提升（Hoisting）执行以下代码会有什么结果？为什么？ 答案 这段代码的执行结果是 undefined 和 2。 这个结果的原因是，变量和函数都被提升了（hoisted）。因此，在a被打印的时候，它已经在函数作用域中存在（即它已经被声明了），但是它的值依然是 undefined。换言之，上述代码和以下代码是等价的。 问题4: this 在 JavaScript 中是如何工作的以下代码的结果是什么？请解释你的答案。 答案 上面的代码打印出 Aurelio De Rosa 和 John Doe。原因是在 JavaScript 中，一个函数的上下文环境，也就是this关键词所引用对象，是依赖于函数是如何被调用的，而不是依赖于函数如何被定义的。 在第一个 console.log() 调用中， getFullname() 是作为 obj.prop 的函数被调用的。因此，这里的上下文环境指向后者并且函数返回this对象的 fullname 属性。相反，当 getFullname() 被赋为test变量的值时，那个语境指向全局对象(window)。这是因为，test被隐式设置为全局对象的属性。因此，函数调用返回 window 的 fullname 属性值，在此段代码中，这个值是通过第一行赋值语句设置的。 问题5: call() 和 apply()修复上一个问题，让最后一个 console.log() 打印出 Aurelio De Rosa。 答案 要解决这个问题，可以通过为函数 call() 或者 apply() 强制函数调用的上下文环境。如果你不知道 call() 和 apply() 之间的区别，我推荐阅读文章“ function.call 和 function.apply 之间有和区别?”。在以下代码中，我会用 call()，但是在这里，用 apply() 也可以获得相同的结果： 常见面试：下面列举一些简单的实例 总结一下this的一些用法： 1.方法中的this会指向当前执行该方法的对象 如： var name = &quot;window&quot; var Tom = { name:&quot;Tom&quot;; show:function(){alert(this.name)} } Tom.show(); //Tom 2.方法中的this不会指向声明它的对象 如下 var Bob={ name:&quot;Bob&quot;, show:function(){alert(this.name);} }; var Tom={ name:&quot;Tom&quot;, show:Bob.show }; Tom.show() ; //Tom 因为尽管alert(this.name)是在Bob对象环境中声明的 但该方法是由Tom对象调用执行所以this总是会指向当前执行的对象，而不是声明的对象 3.将方法复制给变量时，执行时仍然会以Tom对象区调用该方法 var name=&quot;window&quot;; var Tom={ name:&quot;Tom&quot;. show:function(){alert(this.name)} }; var fun=Tom.show(); fun(); //Tom 可以看出赋值后再调用，并不影响调用其方法的对象 4.将对象赋值给变量后，再调用方法，执行的对象仍然是Tom var name=&quot;window&quot;; var Tom={ name:&quot;Tom&quot;, show:function(){alert(this.name)}, wait:function(){ var that=this; that.show(); } }; Tom.wait(); //Tom 这里that赋值了当前执行的对象，并让它继续调用show， 所以show方法中alert(this.name)自然而然的指向了Tom 可以把上面的 &quot;that赋值对象 然后调用方法&quot; 这个过程看做成执行对象 的延迟，就是让Tom加班的意思 5.另一种 指明调用方法的对象 的办法 如下： var name = &quot;window&quot;; var Bob= { name:&quot;Bob&quot;, show:function(){alert(this.name);} }; var Tom= {name: &quot;Tom&quot;}; Bob.show(); //Bob Bob.show.apply(); //window Bob.show.apply(Tom); //Tom 当然call()也差不多类似 6.下面来个特殊的例子 var name=&quot;window&quot;; var Tom={ name:&quot;Tom&quot;, show:function(){alert(this.name)}, wait:function(){ var fun=this.show; fun(); } }; Tom.wait(); //window 上面也是赋值方法后，再调用，可是执行的对象却改成了window对象 解释： 在函数体内把方法赋值给变量再调用会导致对象更改为Window对象 执行fun时，可以看做是一种方法调用的延迟行为，延迟调用方法会使得执行的对象 变为全局对象也就是window对象 下面我们来看看其他几种延迟方式，导致对象被更改为window的例子 7.匿名函数的延迟 var name=&quot;window&quot;; var Tom={ name:&quot;Tom&quot;, show:function(){alert(this.name)}, wait:function(){!function(call){call();}(this.show)} } Tom.wait(); //Window 8.setTimeout、setInterval函数延迟 这里只以setTimeout为例子 var name=&quot;window&quot;; var Tom={ name:&quot;Tom&quot;, show:function(){alert(this.name)}, wait:function(){setTimeout(this.show,1000)} } Tom.wait(); //window 9. 在延迟的环境下 尝试让Tom加班（对象也跟着延迟） var name=&quot;window&quot;; var Tom={ name:&quot;Tom&quot;, show:function(){alert(this.name)}, wait:function(){setTimeout(Tom.show,1000)} } Tom.wait(); //window 上面中this对象改成了Tom，尝试让Tom加班，但是结果仍然为Window对象 因为Tom.show放在第一个参数里，延迟的执行使得执行的对象变为window对象 而不再是Tom对象，如何让执行对象Tom在延迟当不被变更呢？下面给你答案 10.虽然延迟会导致方法的执行对象被更改为Window 但也有办法防止执行对象更改 如下 var name=&quot;window&quot; var Tom ={ name : &quot;Tom&quot;, show : function(){alert(this.name);}, wait: function(){ var that=this; setTimeout(function(){that.show()},1000)} } Tom.wait(); //Tom 如果不能理解上面的代码，你就当做Tom对象也跟着函数一起延迟就好了 而第9个例子没有成功延迟，是因为没有变量保存对象使得执行对象没有跟着延迟 11.eval函数的延迟 对于eval比较特殊 在eval环境下，执行的对象就是当前作用域的对象 如下 var name=&quot;window&quot;; var Bob={ name:&quot;Bob&quot;, showName: function(){ eval(&quot;alert(this.name)&quot;); } }; Bob.showName(); //Bob 12.eval函数的环境下，不会受到延迟而影响函数执行的对象 之所以eval特殊是因为eval不受延迟的影响 var name=&quot;window&quot;; var that; var Tom={ name:&quot;Tom&quot;, show:function(){alert(this.name)}, wait:function(){that=this;setTimeout(&quot;that.show()&quot;,1000)} } Tom.wait(); //Tom 也许你会觉得上面的代码没有eval函数的身影 其实setTimeout函数的第一个参数就是eval环境 他会指向当前执行作用域的执行对象，忽略延迟方法延迟调用 如果能把上面12个例子都理解了，那么this将成为你的一把有力的刀，挥舞在你代码中 当然如果不能理解，那么像闭包一样 尽量的少用！ 函数是JavaScript世界里的第一公民，换句话来说，就是我们如果可以精通JavaScript函数的使用，那么对JavaScript的运用可以更游刃有余了。熟悉JavaScript的人应该都知道，同样的函数，以不同的方式调用的话，受影响最大的应该是 this 。下面我们来说说JavaScript函数的各种调用模式。 一、普通函数的调用模式 所谓普通函数的调用模式，也是JavaScript函数的最简单的一种调用模式，直接就是函数名后接一个 () 实现调用，看下面代码： function func(){ console.log(this === window); //true } func(); 上面代码，我们用function关键字声明了一个 func 函数，并且在函数体内打印 this===window，然后我们直接调用函数func，我们可以看到控制台是直接打印出 true ，也就是说，函数的这种普通调用模式，函数体内的 this 是指向全局环境 window 的。不清楚这点的同学，可以能会遇到这样的一个bug： var color = &apos;gg&apos;; var obj = { color : &apos;red&apos;, show : function(){ function func1(){ console.log(this.color); //gg } func1(); } } obj.show(); 我们在全局环境下声明了一个变量 color 和一个对象 obj ，在对象 obj 里面我们还声明了一个 color 属性 为 ‘red’，一个 show 方法。而且在 show 方法里面呢，我们还声明了一个函数 func1 并且调用了 func1，func1 的作用是打印 this.color。最后我们运行代码 obj.show(); 调用obj里面的show方法。不清楚函数的普通调用模式的特点的同学可能会认为此时在控制台答应出来的会是 ‘red’ 。实际上此时在控制台答应出来的应该是 gg 。因为函数 func1 的调用模式是 普通函数调用模式（即使它是在 obj 的 show 方法里面调用的），所以此时函数体内的 this 是指向 全局环境window 的，所以就打印了全局环境下的变量 color 。 可能有些同学会问：如果我们希望 func1 函数打印出来的是 ‘red’ 呢，应该怎么改？其实很简单，因为 obj.color 才是 ‘red’ ，所以我们只需要把 指向 obj 的 this 引入到函数 func1 里面就行了： var color = &apos;gg&apos;; var obj = { color : &apos;red&apos;, show : function(){ var that = this; function func1(){ console.log(that.color); //red } func1(); } } obj.show(); var color = &apos;gg&apos;; var obj = { color : &apos;red&apos;, show : function(){ var func1=function(){ console.log(this.color); //red }.bind(this); func1(); } } obj.show(); 在上面的代码中，因为 show 里面的 this 指向 obj 的，所以我们在 show 里面声明一个变量 that = this;用来把指向 obj 的 this 引入到 func1 中，然后再把 func1 函数体内的 this.color 改为 that.color ,此时在控制台打印出来的就是我们想要的 ‘red’ 了。 可能现在又有同学会问：为什么 show 里面的 this 是指向 obj 的呢？这就是我们要说的JavaScript函数的第二种调用模式：方法调用模式 二、方法调用模式 方法调用模式，简单来说就是把一个 JavaScript函数作为一个对象的方法来调用，当一个函数被保存为一个对象的属性是，我们就把它称为方法，例如上文的 obj 对象里的 show ，当一个方法被调用时，函数体里面的 this 就会绑定到这个对象，例如上文的 show 里面的 this 。方法调用模式也很容易辨别：obj.show()，对象名 . 属性名 () ；代码的话可以参考上文的 obj 代码 ，博主就不多写了。记住：方法的调用是可以在函数体内通过 this 访问自己所属的那个对象的。 三、构造器调用模式 博主认为构造器调用模式是相对于其他模式来说较为复杂点的调用模式了。通过关键字 new 可以把一个函数作为构造器来调用。关键字 new 可以改变函数的返回值： function func2(name){ this.name = name; } name; //undefined //普通函数调用模式 var foo = func2(&apos;afei&apos;); foo; //undefined name; //afei //构造器调用模式 var bar = new func2(&apos;lizefei&apos;); bar.__proto__ === func2.prototype; //true bar; //{name:&apos;lizefei&apos;} bar.name; //&apos;lizefei&apos; 在上示代码中我们声明了一个函数 func2 ，分别用两种不同的调用模式去调用它。因为函数 func2 并没有显式返回值，所以作为普通函数去调用时，它什么也没有返回，所以 foo 的值是 undefined 。因为普通调用模式的 this 是指向 全局环境 window 的，所以 func2(‘afei’); 后，全局环境下就多了一个 name 变量且等于 ‘afei’。 func2 作为构造器调用时，我们可以看到，它返回的是一个对象，因为关键字 new 使得函数在调用是发生了如下的特殊变化： 创建了一个新对象，而且这个新对象是链接到 func2 的 prototype 属性的 把函数里的 this 指向了这个新对象 如果没有显式的返回值，新对象作为构造器func2的返回值进行返回（所以bar 是 {name:’lizefei’}） 这样子我们就可以看出构造器的作用：通过函数的调用来初始化新创建出来的对象。在JavaScript的面向对象编程里面，这个可是相当重要的。 因为在函数的声明上，在未来作为构造器调用的函数和普通函数的声明没什么区别，所以导致后来的开发者很容易因为调用模式的错误导致程序出问题。所以开发者们都默契地约定，用来做构造器调用的函数的函数名的第一个字符应该大写，例如：Person，People。这样子后来的开发者一看到函数名就知道要用构造器调用模式调用此函数了。 四、使用apply()和call()方法调用 这种调用的模式是为了更灵活控制函数运行的上下文环境而诞生的。简单的说就是为了灵活控制函数体内 this 的值。 apply 和 call这两个方法的第一个参数都是要传递被函数上下文的对象（简单点说就是要绑定给函数 this 的对象）。其他参数就有所不同了： apply方法的第二个参数是一个数组，数组里面的值将作为函数调用的参数； call方法，从第二个参数起（包括第二个参数），剩下的参数都是作为函数调用的参数； 让我们看看栗子： var obj = { name :&apos;afei&apos; } function say(ag1,ag2){ console.log(ag1+&apos;:&apos;+ag2+&quot; &quot;+ this.name); } say.apply(obj,[&apos;apply方法&apos;,&apos;hello&apos;]); //apply方法:hello afei say.call(obj,&apos;call方法&apos;,&apos;hi&apos;); //call方法:hi afei 正如栗子所示，我们把对象 obj 作为函数 say 的上下文来调用函数 say ，所以函数里的 this 是指向 对象 obj 的。在apply方法里，我们通过数组 [‘apply方法’,’hello’] 给 say 方法传递了两个参数（’apply方法’ 和 ‘hello’），所以打印出来是： apply方法:hello afei。 同理 call 也是一样，而且函数传递的方式通过上面的代码也一目了然我，博主就不多做解释了。 另外，博主还听说apply和call这两个方法除了传递参数的方式不一样，执行的速度还是apply 比 call 要快呢。不过博主就没有实验过。 五、总结 在JavaScript里面，函数只要的调用模式就是这几种了（在ES6里面还有一种很奇怪很特殊的函数调用模式，叫做’标签模板‘，在这里博主也不多说了，有空另更），只要掌握了这几种主要的调用模式，那么日后再也不用担心 this 的值变来变去了。 上文如果有漏的、有错误的地方，望各位小伙伴指出，小弟虚心向学。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue批量异步更新与nextTick原理]]></title>
    <url>%2F2018%2F08%2F20%2FVue%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%8EnextTick%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[异步更新 我们在依赖收集原理的响应式化方法 defineReactive 中的 setter 访问器中有派发更新 dep.notify() 方法。 这个方法会挨个通知在 dep 的 subs 中收集的订阅自己变动的watchers执行update。 一起来看看 update 方法的实现： // src/core/observer/watcher.js /* Subscriber接口，当依赖发生改变的时候进行回调 */ update() { if (this.computed) { // 一个computed watcher有两种模式：activated lazy(默认) // 只有当它被至少一个订阅者依赖时才置activated，这通常是另一个计算属性或组件的render function if (this.dep.subs.length === 0) { // 如果没人订阅这个计算属性的变化 // lazy时，我们希望它只在必要时执行计算，所以我们只是简单地将观察者标记为dirty // 当计算属性被访问时，实际的计算在this.evaluate()中执行 this.dirty = true } else { // activated模式下，我们希望主动执行计算，但只有当值确实发生变化时才通知我们的订阅者 this.getAndInvoke(() =&gt; { this.dep.notify() // 通知渲染watcher重新渲染，通知依赖自己的所有watcher执行update }) } } else if (this.sync) { // 同步 this.run() } else { queueWatcher(this) // 异步推送到调度者观察者队列中，下一个tick时调用 } } 如果不是 computed watcher 也非 sync 会把调用update的当前watcher推送到调度者队列中，下一个tick时调用，看看 queueWatcher ： // src/core/observer/scheduler.js /* 将一个观察者对象push进观察者队列，在队列中已经存在相同的id则 * 该watcher将被跳过，除非它是在队列正被flush时推送 */ export function queueWatcher (watcher: Watcher) { const id = watcher.id if (has[id] == null) { // 检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验 has[id] = true queue.push(watcher) // 如果没有正在flush，直接push到队列中 if (!waiting) { // 标记是否已传给nextTick waiting = true nextTick(flushSchedulerQueue) } } } /* 重置调度者状态 */ function resetSchedulerState () { queue.length = 0 has = {} waiting = false } 这里使用了一个 has 的哈希map用来检查是否当前watcher的id是否存在，若已存在则跳过。 不存在则就push到 queue 队列中并标记哈希表has，用于下次检验，防止重复添加。 这就是一个去重的过程，比每次查重都要去queue中找要文明，在渲染的时候就不会重复 patch 相同watcher的变化。 这样就算同步修改了一百次视图中用到的data，异步 patch 的时候也只会更新最后一次修改。 这里的 waiting 方法是用来标记 flushSchedulerQueue 是否已经传递给 nextTick 的标记位。 如果已经传递则只push到队列中不传递 flushSchedulerQueue 给 nextTick。 等到 resetSchedulerState 重置调度者状态的时候 waiting 会被置回 false 允许 flushSchedulerQueue 被传递给下一个tick的回调。 总之保证了 flushSchedulerQueue 回调在一个tick内只允许被传入一次。 来看看被传递给 nextTick 的回调 flushSchedulerQueue 做了什么： // src/core/observer/scheduler.js /* nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers */ function flushSchedulerQueue () { flushing = true let watcher, id queue.sort((a, b) =&gt; a.id - b.id) // 排序 for (index = 0; index &lt; queue.length; index++) { // 不要将length进行缓存 watcher = queue[index] if (watcher.before) { // 如果watcher有before则执行 watcher.before() } id = watcher.id has[id] = null // 将has的标记删除 watcher.run() // 执行watcher if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) { // 在dev环境下检查是否进入死循环 circular[id] = (circular[id] || 0) + 1 // 比如user watcher订阅自己的情况 if (circular[id] &gt; MAX_UPDATE_COUNT) { // 持续执行了一百次watch代表可能存在死循环 warn() // 进入死循环的警告 break } } } resetSchedulerState() // 重置调度者状态 callActivatedHooks() // 使子组件状态都置成active同时调用activated钩子 callUpdatedHooks() // 调用updated钩子 } 在 nextTick 方法中执行 flushSchedulerQueue 方法，这个方法挨个执行 queue 中的watcher的 run 方法。 我们看到在首先有个 queue.sort() 方法把队列中的watcher按id从小到大排了个序，这样做可以保证： 组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。 一个组件的user watchers(侦听器watcher)比render watcher先运行，因为user watchers往往比render watcher更早创建 如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过 在挨个执行队列中的for循环中，index &lt; queue.length 这里没有将length进行缓存。 因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue。 那么数据的修改从model层反映到view的过程：数据更改 -&gt; setter -&gt; Dep -&gt; Watcher -&gt; nextTick -&gt; patch -&gt; 更新视图 nextTick原理 2.1 宏任务/微任务 这里就来看看包含着每个watcher执行的方法被作为回调传入 nextTick 之后，nextTick 对这个方法做了什么。 不过首先要了解一下浏览器中的 EventLoop、macro task、micro task几个概念。 不了解可以参考一下 JS与Node.js中的事件循环 这篇文章，这里就用一张图来表明一下后两者在主线程中的执行关系： 解释一下，当主线程执行完同步任务后： 引擎首先从macrotask queue中取出第一个任务，执行完毕后，将microtask queue中的所有任务取出，按顺序全部执行； 然后再从macrotask queue中取下一个，执行完毕后，再次将microtask queue中的全部取出； 循环往复，直到两个queue中的任务都取完。 浏览器环境中常见的异步任务种类，按照优先级： macro task ： 同步代码、setImmediate、MessageChannel、setTimeout/setInterval micro task： Promise.then、MutationObserver 有的文章把 micro task 叫微任务，macro task 叫宏任务，因为这两个单词拼写太像了 -。- ，所以后面的注释多用中文表示~ 先来看看源码中对micro task与macro task 的实现： macroTimerFunc、microTimerFunc // src/core/util/next-tick.js const callbacks = [] // 存放异步执行的回调 let pending = false // 一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送 /* 挨个同步执行callbacks中回调 */ function flushCallbacks() { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) { copies[i]() } } let microTimerFunc // 微任务执行方法 let macroTimerFunc // 宏任务执行方法 let useMacroTask = false // 是否强制为宏任务，默认使用微任务 // 宏任务 if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) { macroTimerFunc = () =&gt; { setImmediate(flushCallbacks) } } else if (typeof MessageChannel !== &apos;undefined&apos; &amp;&amp; ( isNative(MessageChannel) || MessageChannel.toString() === &apos;[object MessageChannelConstructor]&apos; // PhantomJS )) { const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; { port.postMessage(1) } } else { macroTimerFunc = () =&gt; { setTimeout(flushCallbacks, 0) } } // 微任务 if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) { const p = Promise.resolve() microTimerFunc = () =&gt; { p.then(flushCallbacks) } } else { microTimerFunc = macroTimerFunc // fallback to macro } flushCallbacks 这个方法就是挨个同步的去执行callbacks中的回调函数们，callbacks中的回调函数是在调用 nextTick 的时候添加进去的； 那么怎么去使用 micro task 与 macro task 去执行 flushCallbacks 呢。 这里他们的实现 macroTimerFunc、microTimerFunc 使用浏览器中宏任务/微任务的API对flushCallbacks 方法进行了一层包装。 比如宏任务方法 macroTimerFunc=()=&gt;{ setImmediate(flushCallbacks) }，这样在触发宏任务执行的时候 macroTimerFunc() 就可以在浏览器中的下一个宏任务loop的时候消费这些保存在callbacks数组中的回调了，微任务同理。 同时也可以看出传给 nextTick 的异步回调函数是被压成了一个同步任务在一个tick执行完的，而不是开启多个异步任务。 注意这里有个比较难理解的地方，第一次调用 nextTick 的时候 pending 为false。 此时已经push到浏览器event loop中一个宏任务或微任务的task，如果在没有flush掉的情况下继续往callbacks里面添加。 那么在执行这个占位queue的时候会执行之后添加的回调，所以 macroTimerFunc、microTimerFunc 相当于task queue的占位。 以后 pending 为true则继续往占位queue里面添加，event loop轮到这个task queue的时候将一并执行。 执行 flushCallbacks 时 pending 置false，允许下一轮执行 nextTick 时往event loop占位。 可以看到上面 macroTimerFunc 与 microTimerFunc 进行了在不同浏览器兼容性下的平稳退化，或者说降级策略： 1、macroTimerFunc ： setImmediate -&gt; MessageChannel -&gt; setTimeout。 首先检测是否原生支持 setImmediate，这个方法只在 IE、Edge 浏览器中原生实现。 然后检测是否支持 MessageChannel，如果对 MessageChannel 不了解可以参考一下这篇文章。还不支持的话最后使用setTimeout； 为什么优先使用 setImmediate 与 MessageChannel 而不直接使用 setTimeout 呢。 是因为HTML5规定setTimeout执行的最小延时为4ms，而嵌套的timeout表现为10ms。 为了尽可能快的让回调执行，没有最小延时限制的前两者显然要优于 setTimeout。 2、microTimerFunc： Promise.then -&gt; macroTimerFunc 。 首先检查是否支持 Promise，如果支持的话通过 Promise.then 来调用 flushCallbacks 方法。 否则退化为 macroTimerFunc ； vue2.5之后 nextTick 中因为兼容性原因删除了微任务平稳退化的 MutationObserver 的方式。 2.2 nextTick实现 最后来看看我们平常用到的 nextTick 方法到底是如何实现的： // src/core/util/next-tick.js export function nextTick(cb?: Function, ctx?: Object) { let _resolve callbacks.push(() =&gt; { if (cb) { try { cb.call(ctx) } catch (e) { handleError(e, ctx, &apos;nextTick&apos;) } } else if (_resolve) { _resolve(ctx) } }) if (!pending) { pending = true if (useMacroTask) { macroTimerFunc() } else { microTimerFunc() } } if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) { return new Promise(resolve =&gt; { _resolve = resolve }) } } /* 强制使用macrotask的方法 */ export function withMacroTask(fn: Function): Function { return fn._withTask || (fn._withTask = function() { useMacroTask = true const res = fn.apply(null, arguments) useMacroTask = false return res }) } nextTick 在这里分为三个部分，我们一起来看一下； 1、首先 nextTick 把传入的 cb 回调函数用 try-catch 包裹后放在一个匿名函数中推入callbacks数组中。 这么做是因为防止单个 cb 如果执行错误不至于让整个JS线程挂掉。 每个 cb 都包裹是防止这些回调函数如果执行错误不会相互影响，比如前一个抛错了后一个仍然可以执行。 2、然后检查 pending 状态，这个跟之前介绍的 queueWatcher 中的 waiting 是一个意思。 它是一个标记位，一开始是 false 在进入 macroTimerFunc、microTimerFunc方法前被置为 true。 因此下次调用 nextTick 就不会进入 macroTimerFunc、microTimerFunc方法。 这两个方法中会在下一个 macro/micro tick 时候 flushCallbacks 异步的去执行callbacks队列中收集的任务，而 flushCallbacks 方法在执行一开始会把 pending 置 false。 因此下一次调用 nextTick 时候又能开启新一轮的 macroTimerFunc、microTimerFunc，这样就形成了vue中的 event loop。 3、最后检查是否传入了 cb。 因为 nextTick 还支持Promise化的调用：nextTick().then(() =&gt; {})。 所以如果没有传入 cb 就直接return了一个Promise实例，并且把resolve传递给_resolve。 这样后者执行的时候就跳到我们调用的时候传递进 then 的方法中。 Vue源码中 next-tick.js 文件还有一段重要的注释，这里就翻译一下： 在vue2.5之前的版本中，nextTick基本上基于 micro task 来实现的。 但是在某些情况下 micro task 具有太高的优先级，并且可能在连续顺序事件之间（例如＃4521，＃6690）或者甚至在同一事件的事件冒泡过程中之间触发（＃6566）。 但是如果全部都改成 macro task，对一些有重绘和动画的场景也会有性能影响，如 issue #6813。 vue2.5之后版本提供的解决办法是默认使用 micro task，但在需要时（例如在v-on附加的事件处理程序中）强制使用 macro task。 为什么默认优先使用 micro task 呢。 是利用其高优先级的特性，保证队列中的微任务在一次循环全部执行完毕。 强制 macro task 的方法是在绑定 DOM 事件的时候。 默认会给回调的 handler 函数调用 withMacroTask 方法做一层包装 handler = withMacroTask(handler)。 它保证整个回调函数执行过程中，遇到数据状态的改变，这些改变都会被推到 macro task 中。 以上实现在src/platforms/web/runtime/modules/events.js 的 add 方法中，可以自己看一看具体代码。 刚好在写这篇文章的时候思否上有人问了个问题 vue 2.4 和2.5 版本的@input事件不一样。 这个问题的原因也是因为2.5之前版本的DOM事件采用 micro task ，而之后采用 macro task。 解决的途径参考 &lt; Vue.js 升级踩坑小记&gt; 中介绍的几个办法。 这里就提供一个在mounted钩子中用 addEventListener 添加原生事件的方法来实现。 参见 CodePen （https://codepen.io/SHERlocked93/pen/WKGNKJ）。 一个例子 说这么多，不如来个例子，执行参见 CodePen &lt;div id=&quot;app&quot;&gt; &lt;span id=&apos;name&apos; ref=&apos;name&apos;&gt;{{ name }}&lt;/span&gt; &lt;button @click=&apos;change&apos;&gt;change name&lt;/button&gt; &lt;div id=&apos;content&apos;&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue({ el: &apos;#app&apos;, data() { return { name: &apos;SHERlocked93&apos; } }, methods: { change() { const $name = this.$refs.name this.$nextTick(() =&gt; console.log(&apos;setter前：&apos; + $name.innerHTML)) this.name = &apos; name改喽 &apos; console.log(&apos;同步方式：&apos; + this.$refs.name.innerHTML) setTimeout(() =&gt; this.console(&quot;setTimeout方式：&quot; + this.$refs.name.innerHTML)) this.$nextTick(() =&gt; console.log(&apos;setter后：&apos; + $name.innerHTML)) this.$nextTick().then(() =&gt; console.log(&apos;Promise方式：&apos; + $name.innerHTML)) } } }) &lt;/script&gt; 执行以下看看结果： 同步方式：SHERlocked93 setter前：SHERlocked93 setter后：name改喽 Promise方式：name改喽 setTimeout方式：name改喽 为什么是这样的结果呢，解释一下： 同步方式： 当把data中的name修改之后，此时会触发name的 setter 中的 dep.notify 通知依赖本data的render watcher去 update，update 会把 flushSchedulerQueue 函数传递给 nextTick，render watcher在 flushSchedulerQueue 函数运行时 watcher.run 再走 diff -&gt; patch 那一套重渲染 re-render 视图，这个过程中会重新依赖收集，这个过程是异步的；所以当我们直接修改了name之后打印，这时异步的改动还没有被 patch 到视图上，所以获取视图上的DOM元素还是原来的内容。 setter前： setter前为什么还打印原来的是原来内容呢，是因为 nextTick 在被调用的时候把回调挨个push进callbacks数组，之后执行的时候也是 for 循环出来挨个执行，所以是类似于队列这样一个概念，先入先出；在修改name之后，触发把render watcher填入 schedulerQueue 队列并把他的执行函数 flushSchedulerQueue 传递给 nextTick ，此时callbacks队列中已经有了 setter前函数 了，因为这个 cb 是在 setter前函数 之后被push进callbacks队列的，那么先入先出的执行callbacks中回调的时候先执行 setter前函数，这时并未执行render watcher的 watcher.run，所以打印DOM元素仍然是原来的内容。 setter后： setter后这时已经执行完 flushSchedulerQueue，这时render watcher已经把改动 patch 到视图上，所以此时获取DOM是改过之后的内容。 Promise方式： 相当于 Promise.then 的方式执行这个函数，此时DOM已经更改。 setTimeout方式： 最后执行macro task的任务，此时DOM已经更改。 注意，在执行 setter前函数 这个异步任务之前，同步的代码已经执行完毕。 异步的任务都还未执行，所有的 $nextTick 函数也执行完毕。 所有回调都被push进了callbacks队列中等待执行，所以在setter前函数执行的时候。 此时callbacks队列是这样的： [setter前函数， flushSchedulerQueue， setter后函数， Promise方式函数]。 它是一个micro task队列，执行完毕之后执行macro task setTimeout，所以打印出上面的结果。 另外，如果浏览器的宏任务队列里面有setImmediate、MessageChannel、setTimeout/setInterval 各种类型的任务。 那么会按照上面的顺序挨个按照添加进event loop中的顺序执行，所以如果浏览器支持MessageChannel。 nextTick执行的是macroTimerFunc。 那么如果 macrotask queue 中同时有 nextTick 添加的任务和用户自己添加的 setTimeout 类型的任务。 会优先执行 nextTick 中的任务，因为MessageChannel 的优先级比 setTimeout的高，setImmediate 同理。]]></content>
  </entry>
  <entry>
    <title><![CDATA[ES6之promise、generator+co、async+await手写promise]]></title>
    <url>%2F2018%2F08%2F20%2FES6%E4%B9%8Bpromise%E3%80%81generator-co%E3%80%81async-await%E6%89%8B%E5%86%99promise%2F</url>
    <content type="text"><![CDATA[一、前言传统的解决代码单线程执行的方案是回调函数和事件。这是个解决问题的方案，但是会造成回调地狱。 异步编程是优化代码逻辑提高代码易读性的关键。 目前通用的异步编程方法有三种： Promise generator+co async+await 这三种方法我都经常在用，但是对它们的原理却一知半解。于是想炒个冷饭从头到尾理一遍，梳理一下它们之间的关系。 二、Promise2.1 原理Promise对象是一个构造函数，用来生成Promise实例。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。Promise函数的两个参数分别是resolve和reject。它们是Promise中定义的两个函数，在运行自定义函数时返回。resolve函数将Promise对象的状态从 pending 变为resolved,reject将Promise对象的状态从 pending 变为rejectedPromise的原型链上定义了then方法，提供两个回调函数分别捕获resolve、reject返回的值。 2.2 静态方法方法描述Promise.resolve(promise);返回 promise（仅当 promise.constructor == Promise 时）Promise.resolve(thenable);从thenable 中生成一个新promise。thenable 是具有 then() 方法的类似于 promise 的对象。Promise.resolve(obj);在此情况下，生成一个promise 并在执行时返回 obj。Promise.reject(obj);生成一个promise 并在拒绝时返回 obj。为保持一致和调试之目的（例如堆叠追踪）， obj 应为 instanceof Error。Promise.all(array);生成一个promise，该 promise 在数组中各项执行时执行，在任意一项拒绝时拒绝。Promise.race(array);生成一个 Promise，该 Promise 在任意项执行时执行，或在任意项拒绝时拒绝，以最先发生的为准。sample 1123456789101112131415161718let p1 = new Promise((resolve,reject)=&gt;&#123; console.log(&apos;hello&apos;) setTimeout(function () &#123; reject(&apos;1212&apos;) &#125;,1000)&#125;)p1.then(data=&gt; &#123; console.log(&apos;success&apos;+data)&#125;,err=&gt;&#123; console.log(&apos;err&apos;+err)&#125;)p1.then(data=&gt; &#123; console.log(&apos;success&apos;+data)&#125;,err=&gt;&#123; console.log(&apos;err&apos;+err)&#125;) terminal:123helloerr1212err1212 sample 1 中新建了一个Promise实例，定时1S后使用reject方法，将Promise实例的状态从pending变成rejected，触发then的err捕捉回调函数。 在sample 1 中调用then方法，并不会马上执行回调。是等待实例中状态改变后才会执行。这一点和发布订阅模式很类似。 sample 21234567891011121314151617181920212223242526let fs = require(&apos;fs&apos;)let event = &#123; arr:[], result:[], on(fn)&#123; this.arr.push(fn) &#125;, emit(data)&#123; this.result.push(data) this.arr.forEach(fn=&gt;fn(this.result)) &#125;&#125;event.on(function (data) &#123; if(data.length === 2)&#123; console.log(data) &#125;&#125;)fs.readFile(&apos;1.txt&apos;,&apos;utf8&apos;,function (err,data) &#123; event.emit(data)&#125;)fs.readFile(&apos;2.txt&apos;,&apos;utf8&apos;,function (err,data) &#123; event.emit(data)&#125;) smaple2 中将结果data放入暂存数组中，在执行接听函数的时候返回。 2.3 简写Promise源码通过之前的例子和对发布订阅模式的理解，我们可以大概写出Promise实例的基本功能： code 1：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function Promise(executor) &#123; let self = this self.value = undefined self.reason = undefined self.status = &apos;pending&apos; self.onResovedCallbacks = [] self.onRejectedCallbacks = [] function resolve(data) &#123; if(self.status === &apos;pending&apos;)&#123; self.value = data self.status = &apos;resolved&apos; self.onResovedCallbacks.forEach(fn=&gt;fn()) &#125; &#125; function reject(reason) &#123; if(self.status === &apos;pending&apos;) &#123; self.reason = reason self.status = &apos;reject&apos; self.onRejectedCallbacks.forEach(fn=&gt;fn()) &#125; &#125; //如果函数执行时发生异常 try&#123; executor(resolve,reject) &#125;catch (e)&#123; reject(e) &#125;&#125;Promise.prototype.then = function (onFulfilled,onRejected) &#123; let self = this if(self.status === &apos;pending&apos;)&#123; self.onResovedCallbacks.push(()=&gt;&#123; onFulfilled(self.value) &#125;) self.onRejectedCallbacks.push(()=&gt;&#123; onRejected(self.reason) &#125;) &#125;elseif(self.status === &apos;resolved&apos;)&#123; onFulfilled(self.value) &#125;elseif(self.status === &apos;reject&apos;)&#123; onRejected(self.reason) &#125;&#125;module.exports = Promise 函数内部变量 status：储存Promise的状态 onResovedCallbacks：储存Promise pending状态下成功回调函数 onRejectedCallbacks：储存Promise pending状态下失败回调函数 resolve函数 reject函数 Promise.prototype.then 根据实例状态执行响应的回调 status == pending使用发布订阅模式储存回调函数。 2.4 Promise用法简述 如果一个promise执行完后,返回的还是一个Promise对象,会把这个promise的执行结果,传递给下一个then中。 1234567891011121314151617let fs = require(&apos;fs&apos;)functionread(filePath,encoding) &#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(filePath,encoding,(err,data)=&gt; &#123; if(err) reject(err) resolve(data) &#125;) &#125;)&#125;read(&apos;1.txt&apos;,&apos;utf8&apos;).then( f1=&gt;read(f1,&apos;utf8&apos;) // 1).then( data=&gt; console.log(&apos;resolved:&apos;,comments) err=&gt; console.log(&apos;rejected: &apos;,err)) 如果then中返回的不是promise，是一个普通值,会将这个普通值作为下一个then的返回结果。 12345678910 ...... read(&apos;1.txt&apos;,&apos;utf8&apos;).then( f1=&gt;read(f1,&apos;utf8&apos;)).then( return 123 //2).then( data=&gt; console.log(&apos;resolved:&apos;,comments) err=&gt; console.log(&apos;rejected: &apos;,err)) 如果当前then中失败了会走下一个then的失败。 123456789101112 ...... read(&apos;1.txt&apos;,&apos;utf8&apos;).then( f1=&gt;read(f1,&apos;utf8&apos;)).then( return 123).then( throw new Error(&apos;出错&apos;) //3).then( data=&gt; console.log(&apos;resolved:&apos;,comments) err=&gt; console.log(&apos;rejected: &apos;,err)) 如果返回的是undefined不管当前是失败还是成功，都会走下一次成功。 catch是错误没有处理的情况下会走。 then中可以不写。12345678910111213 ...... read(&apos;1.txt&apos;,&apos;utf8&apos;).then( f1=&gt;read(f1,&apos;utf8&apos;)).then( return 123).then( throw new Error(&apos;出错&apos;) ).then() //6 .then( data=&gt; console.log(&apos;resolved:&apos;,comments) err=&gt; console.log(&apos;rejected: &apos;,err)) 这些用法中最重要的是promise的then链式调用。可以大致猜到，旧Promise的then方法返回的是一个新的Promise对象。 参考Promises/A+规范，可以完善手写的Promise源码使其支持promise的静态方法和调用规则。 code 2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150function Promise(executor) &#123; let self = this self.value = undefined self.reason = undefined self.status = &apos;pending&apos; self.onResovedCallbacks = [] self.onRejectedCallbacks = [] function resolve(value) &#123; if (self.status === &apos;pending&apos;) &#123; self.value = value self.status = &apos;resolved&apos; self.onResovedCallbacks.forEach(fn=&gt;fn()) &#125; &#125; function reject(reason) &#123; if (self.status === &apos;pending&apos;) &#123; self.reason = reason self.status = &apos;rejected&apos; self.onRejectedCallbacks.forEach(fn=&gt;fn()) &#125; &#125; //如果函数执行时发生异常 try &#123; executor(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;function resolvePromise(promise2, x, resolve, reject) &#123; //If promise and x refer to the same object, reject promise with a TypeError as the reason. if (promise2 === x) &#123; return reject(new TypeError(&apos;chaining cycle&apos;)) &#125; let called //2.3.3.Otherwise, if x is an object or function, if (x !== null &amp;&amp; (typeof x == &apos;object&apos; || typeof x === &apos;function&apos;)) &#123; try &#123; letthen = x.then //2.3.3.3.If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where: //2.3.3.3.3.If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored. if (typeof then === &apos;function&apos;) &#123; then.call(x, y=&gt; &#123; if (called) return; called = true; //递归直到解析成普通值为止 //2.3.3.1.If/when resolvePromise is called with a value y, run [[Resolve]](promise, y). resolvePromise(promise2, y, resolve, reject) &#125;, err=&gt; &#123; if (called) return; called = true; reject(err) &#125;) &#125; else &#123; resolve(x) &#125; &#125; catch (e) &#123; if (called) return; called = true; //2.3.3.3.If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason. reject(e) &#125; &#125; else &#123; //If x is not an object or function, fulfill promise with x. resolve(x) &#125;&#125;//then调用的时候 都是异步调用 (原生的then的成功或者失败 是一个微任务)Promise.prototype.then = function (onFulfilled, onRejected) &#123; //成功和失败的函数 是可选参数 onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val=&gt;val; onRejected = typeof onRejected === &apos;function&apos; ? onRejected : (e)=&gt; &#123;throw e&#125;; let self = this let promise2; promise2 = new Promise((resolve, reject)=&gt; &#123; if (self.status === &apos;resolved&apos;) &#123; setTimeout(()=&gt; &#123; try &#123; let x = onFulfilled(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; elseif (self.status === &apos;rejected&apos;) &#123; setTimeout(()=&gt; &#123; try &#123; let x = onRejected(self.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125; elseif (self.status === &apos;pending&apos;) &#123; self.onResovedCallbacks.push(()=&gt; &#123; setTimeout(()=&gt; &#123; try &#123; let x = onFulfilled(self.value) resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; //当执行成功回调的时候,可能会出现异常,那就用这个异常作为promise2的错误结果 reject(e) &#125; &#125;, 0) &#125;) self.onRejectedCallbacks.push(()=&gt; &#123; setTimeout(()=&gt; &#123; try &#123; let x = onRejected(self.reason) resolvePromise(promise2, x, resolve, reject) &#125; catch (e) &#123; reject(e) &#125; &#125;, 0) &#125;) &#125; &#125;) return promise2&#125;//setTimeout (规范要求)Promise.reject = function (reason) &#123; return new Promise((resolve,reject)=&gt;&#123; reject(reason) &#125;)&#125;Promise.resolve = function (value) &#123; return new Promise((resolve,reject)=&gt;&#123; resolve(value) &#125;)&#125;Promise.prototype.catch = function (onReject) &#123; return this.then(null,onReject)&#125;Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125; dfd.promise = new Promise((resolve, reject)=&gt; &#123; dfd.resolve = resolve dfd.reject = reject &#125;) return dfd;&#125;module.exports = Promise 为了支持then的链式调用，Promise.then.prototype中返回一个新的Promise对象1return p2 = new Promise() 2.增加resolvePromise方法，处理旧Promise的回调函数的结果x，根据x的类型，分别调用新promise对象的resolve/reject方法。 是普通值用resolve方法返回 是函数或者对象就继续用resolvePromise方法迭代（解决回调函数是Promise对象） 出错就用reject方法返回 三、bluebird1: NodeJS 中的 fs.readFile 方法的基本使用方式123456789const fs = require(&apos;fs&apos;),path = require(&apos;path&apos;); fs.readFile(path.join(__dirname, &apos;1.txt&apos;), &apos;utf-8&apos;, (err, data) =&gt; &#123; if (err) &#123; console.error(err); &#125; else &#123; console.log(data); &#125;&#125;); 2：使用Promise封装123456789101112let fs = require(&apos;fs&apos;)functionread(filePath, encoding) &#123; return new Promise((resolve, reject)=&gt; &#123; fs.readFile(filePath, encoding, (err, data)=&gt; &#123; if (err) reject(err) resolve(data) &#125;) &#125;)&#125;read(&apos;1.txt&apos;, &apos;utf8&apos;).then( data=&gt; data) 把fs.readFile方法用Promise封装一下就能使用Promise api。但是每次手动封装比较麻烦，bluebird可以帮我们简化这个步骤。 3：在 NodeJS 环境中，通过 const bluebird = require(‘bluebird’) 就可以开始使用 Bluebird 提供的 Promise 对象。 Promise.promisify 将单个方法转换成Promise对象。12345const bluebird = require(&apos;bluebird&apos;) letread = bluebird.promisify(fs.readFile)read(&apos;1.txt&apos;, &apos;utf-8&apos;).then(data=&gt; &#123; console.log(&apos;data promisify&apos;, data)&#125;) 使用bluebird.promisify方法，就能将fs.readFile直接封装成一个promise对象，它的原理很简单，return new Promise是它的核心：12345678910function promisify(fn) &#123; return function () &#123; return new Promise((resolve, reject)=&gt; &#123; fn(...arguments, function (err, data) &#123; if (err) reject(err) resolve(data) &#125;) &#125;) &#125;&#125; 4.使用 Promise.promisifyAll 把一个对象的所有方法都自动转换成使用 Promise。12345678const bluebird = require(&apos;bluebird&apos;), fs = require(&apos;fs&apos;), path = require(&apos;path&apos;);Promise.promisifyAll(fs); fs.readFileAsync(path.join(__dirname, &apos;sample.txt&apos;), &apos;utf-8&apos;) .then(data =&gt; console.log(data)) .catch(err =&gt; console.error(err)); promisifyAll核心是遍历对象，生成些新创建方法的名称在已有方法的名称后加上”Async”后缀。1234567function promisifyAll(obj) &#123; Object.keys(obj).forEach(key=&gt;&#123; if(typeof obj[key] === &apos;function&apos;)&#123; obj[key+&apos;Async&apos;] = promisify(obj[key]) &#125; &#125;)&#125; 四、generator+co4.1 简介generator函数最大的特点是可以用yield暂停执行，为了区别普通函数在函数名前加*号。123456789function *say() &#123; let a = yield &quot;test1&quot;let b = yield &quot;test2&quot;&#125;let it = say();console.log(1, it.next()) //1 &#123; value: &apos;test1&apos;, done: false &#125;console.log(2, it.next()) //2 &#123; value: &apos;test2&apos;, done: false &#125;console.log(3, it.next()) //3 &#123; value: undefined, done: true &#125; 执行say()方法返回的是指针对象，不会返回函数执行结果。it 就是iterator 迭代器 需要调用指针对象的next()方法，让函数指针不断移动并返回一个对象。（{value:xxx,done:xxx}） value是yield后面的值，done表示函数是否执行完成。 我们可以用generator函数实现结果的产出，但是也需要它支持输入。 generator函数的运行顺序如下：使用it.next()执行函数，结果并不会返回给定义的变量a。next方法可以接受参数，这是向 Generator 函数体内输入数据。第二个next的时候传入参数，就能被变量a接收到。 terminal 返回：123451 &#123; value: &apos;test1&apos;, done: false &#125;aaa2 &#123; value: &apos;test2&apos;, done: false &#125;bbb3 &#123; value: undefined, done: true &#125; 4.2 使用 example：使用generator异步执行函数，使函数的返回作为下一个函数的入参执行。12345678910111213let bluebird = require(&apos;bluebird&apos;)let fs = require(&apos;fs&apos;)letread = bluebird.promisify(fs.readFile)function *r() &#123; let r1 = yield read(&apos;1.txt&apos;, &apos;utf-8&apos;) console.log(&apos;r1&apos;,r1); // r1 2.txt let r2 = yield read(r1, &apos;utf-8&apos;) console.log(&apos;r2&apos;,r2); // r2 3.txt let r3 = yield read(r2, &apos;utf-8&apos;) console.log(&apos;r3&apos;,r3); // r3 hello return r3&#125; 拿读取文件的例子：使用bluebird将fs.readFile变成promise对象，将读取到的文件内容作为入参传入下一个要执行的函数。 突然发现，要拿到结果会是个复杂的过程，但还是硬着头皮下下去：12345678910const it_r = r()it_r.next().value.then(d1=&gt;&#123; return it_r.next(d1).value&#125;).then(d2=&gt;&#123; return it_r.next(d2).value&#125;).then(d3=&gt;&#123; return it_r.next(d3).value&#125;).then(data=&gt;&#123; console.log(data) // hello&#125;) it.next().value 返回的是一个promise，使用then方法，拿到它成功回调的值，并传入下一个next。 这样能成功拿到我们要的值，但是太麻烦了。于是就有了generator+co的组合！ 安装：1$ npm install co 使用:123co(r()).then(data=&gt; &#123; console.log(data)&#125;) co会迭代执行it.next()方法，直到done的布尔值为true就返回generator函数的运行结果。 大致执行代码如下：123456789101112131415function co(it) &#123; return new Promise((resolve, reject)=&gt; &#123; function next(data) &#123; let &#123;value, done&#125; = it.next(data) if(done)&#123; resolve(value) &#125;else&#123; value.then(data=&gt; &#123; next(data) &#125;,reject) &#125; &#125; next() &#125;)&#125; 五、async+awaitasync 函数是Generator 函数的语法糖。 比Generator函数用起来简单 可以让代码像同步 可以try+catch 可以使用promise api12345678910111213141516async functionr() &#123; try&#123; let r1 = await read(&apos;1.txt&apos;,&apos;utf8&apos;) let r2 = await read(r1,&apos;utf8&apos;) let r3 = await read(r2,&apos;utf8&apos;) return r3 &#125;catch(e)&#123; console.log(&apos;e&apos;,e) &#125;&#125;r().then(data=&gt; &#123; console.log(data)&#125;,err=&gt;&#123; console.log(&apos;err&apos;,err)&#125;) async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。遇到await就会先返回，等待函数执行。]]></content>
      <tags>
        <tag>promise</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交叉观察器(intersectionObserver) Vue实战]]></title>
    <url>%2F2018%2F08%2F13%2F%E4%BA%A4%E5%8F%89%E8%A7%82%E5%AF%9F%E5%99%A8-intersectionObserver-Vue%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[参考文章：IntersectionObserver API 使用教程Intersection Observer【译】使用 Intersection Observer 实现图片延迟加载intersectionObserver解决什么问题？ intersectionObserver解决目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”， 比如在web网页开发中，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。 传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。 目前有一个新的 IntersectionObserver API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。 IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。 IntersectionObserverEntry 对象 IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。 { time: 3893.92, rootBounds: ClientRect { bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 }, boundingClientRect: ClientRect { // ... }, intersectionRect: ClientRect { // ... }, intersectionRatio: 0.54, target: element } 每个属性的含义如下。 time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target：被观察的目标元素，是一个 DOM 节点对象 rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null boundingClientRect：目标元素的矩形区域的信息 intersectionRect：目标元素与视口（或根元素）的交叉区域的信息 intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0 现在我们已经创建了一个 Intersection Observer 并且正在观察页面上的图片，我们现在来了解 intersection 事件，它将在元素进入视区时触发。 浏览器支持此时此刻，你也许想知道关于这项特性的浏览器支持情况。Intersection Observer 现在已被 Edge、Firefox、Chrome 和 Opera 支持，这是一个好消息。 然而，为了确保我们的代码不会在不支持它的浏览器中造成破坏，我们可以使用特性检测来确定我们应该如何来加载图片。让我们看看下面的代码。 // If we don&apos;t have support for intersection observer, load the images immediately if (!(&apos;IntersectionObserver&apos; in window)) { Array.from(images).forEach(image =&gt; preloadImage(image)); } else { // It is supported, load the images observer = new IntersectionObserver(onIntersection, config); images.forEach(image =&gt; { observer.observe(image); }); } view raw Vue: &lt;template&gt; &lt;img :src=&quot;lazysrc&quot; /&gt; &lt;/template&gt; &lt;script&gt; import Bus from &apos;../bus&apos;; import nonepng from &apos;../../assets/img/none.png&apos;; export default { name: &apos;lazyimg&apos;, data: function() { return { isShow: false, lazysrc: nonepng } }, mounted() { if(!this.needlazy) { this.lazysrc = this.src; } else { if(!(&apos;IntersectionObserver&apos; in window)) { //TODO } else { var io = new IntersectionObserver( entries =&gt; { entries.forEach(i =&gt; { if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发 i.target.setAttribute(&quot;src&quot;, this.src) } }); }, { threshold: [0, 0.25, 0.5, 0.75, 1], } ); io.observe(this.$el); } } }, props: { needlazy: { type: Boolean, default: false, }, src: { type: String, default: &apos;&apos;, }, } }; &lt;/script&gt; 通常都是通过判断intersectionRatio来做某些事，比如当intersectionRatio大于多少的时候做什么事，加载图片等！ 灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的intersectionRatio图中都已经注明。 DEMO： 延迟加载(Lazyload)三种实现方式 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; &lt;title&gt; &lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; * { padding: 0px; margin: 0px; outline: none; } body {} #main { margin: 0 auto; width: 600px; height: 300px; overflow: scroll; } #con { width: 1200px; height: 300px; } .cc { width: 300px; height: 300px; float: left; background-size: cover; } #a { background-color: red; } #b { background-color: black; } #c { background-color: blue; } #d { background-color: green; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;con&quot;&gt; &lt;div id=&quot;a&quot; class=&quot;cc&quot;&gt;&lt;/div&gt; &lt;div id=&quot;b&quot; class=&quot;cc&quot;&gt;&lt;/div&gt; &lt;div id=&quot;c&quot; class=&quot;cc&quot;&gt;&lt;/div&gt; &lt;div id=&quot;d&quot; class=&quot;cc&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var io = new IntersectionObserver( entries =&gt; { console.log(&apos;********************************&apos;); console.log(entries); console.log(&apos;********************************&apos;); entries.forEach(i =&gt; { console.log(&apos;================================&apos;); console.log(&apos;Time: &apos; + i.time); console.log(&apos;Target: &apos; + i.target.nodeName); console.log(&apos;IntersectionRatio: &apos; + i.intersectionRatio); console.log(&apos;rootBounds: &apos; + i.rootBounds); console.log(i.boundingClientRect); console.log(i.intersectionRect); console.log(&apos;================================&apos;); if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发 console.log(&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&apos;); i.target.style.backgroundImage = &quot;url(&quot; + &apos;http://pic35.photophoto.cn/20150528/0020032932102307_b.jpg&apos; + &quot;)&quot; } }); }, { /* Using default options. Details below */ threshold: [0, 0.25, 0.5, 0.75, 1], //会执行5次 } ); // Start observing an element io.observe(document.querySelector(&apos;#d&apos;)); io.observe(document.querySelector(&apos;#c&apos;)); &lt;/script&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Lazyload 3&lt;/title&gt; &lt;style&gt; img { display: block; margin-bottom: 50px; width: 800px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/1.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/2.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/3.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/4.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/5.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/6.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/7.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/8.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/9.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/10.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/11.png&quot;&gt; &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/12.png&quot;&gt; &lt;script&gt; function query(selector) { return Array.from(document.querySelectorAll(selector)); } var io = new IntersectionObserver(function(items) { items.forEach(function(item) { var target = item.target; if(target.getAttribute(&apos;src&apos;) == &apos;images/loading.gif&apos;) { target.src = target.getAttribute(&apos;data-src&apos;); } }) }); query(&apos;img&apos;).forEach(function(item) { io.observe(item); }); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; IntersectionObserver 传入一个回调函数，当其观察到元素集合出现时候，则会执行该函数。 io.observe 即要观察的元素，要一个个添加才可以。 io 管理的是一个数组，当元素出现或消失的时候，数组添加或删除该元素，并且执行该回调函数。 一、API它的用法非常简单。 var io = new IntersectionObserver(callback, option); 上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。 构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。 // 开始观察 io.observe(document.getElementById(&apos;example&apos;)); // 停止观察 io.unobserve(element); // 关闭观察器 io.disconnect(); 上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。 io.observe(elementA); io.observe(elementB); 二、callback 参数目标元素的可见性变化时，就会调用观察器的回调函数callback。 callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。 var io = new IntersectionObserver( entries =&gt; { console.log(entries); } ); 上面代码中，回调函数采用的是箭头函数的写法。callback函数的参数（entries）是一个数组，每个成员都是一个[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。 三、Option 对象IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。 [IntersectionObserver.root](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/root) 只读所监听对象的具体祖先元素([element](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Element))。如果未传入任何值或值为null，则默认使用viewport。 [IntersectionObserver.rootMargin](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/rootMargin) 只读计算交叉时添加到根(root)边界盒bounding box的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。此属性返回的值可能与调用构造函数时指定的值不同，因此可能需要更改该值，以匹配内部要求。所有的偏移量均可用像素(pixel)(px)或百分比(percentage)(%)来表达, 默认值为”0px 0px 0px 0px”。 [IntersectionObserver.thresholds](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/thresholds) 只读一个包含阈值的list, 升序排列, list中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会生成一个通知(Notification)。如果构造器未传入值, 则默认值为0. threshold 属性 threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。 new IntersectionObserver( entries =&gt; {/* ... */}, { threshold: [0, 0.25, 0.5, 0.75, 1] } ); 用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。 root 属性，rootMargin 属性 很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。 IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。 var opts = { root: document.querySelector(&apos;.container&apos;), rootMargin: &quot;500px 0px&quot; }; var observer = new IntersectionObserver( callback, opts ); 上面代码中，除了root属性，还有[rootMargin](https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/%23dom-intersectionobserverinit-rootmargin)属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。 //离视窗还有top=500px 或者 bottom=500 触发加载 rootMargin = `500px 0px` //离视窗还有top=-500px 或者 bottom=-500 触发加载 （惰性加载） rootMargin = `-500px 0px` 这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。 四、方法[IntersectionObserver.disconnect](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/disconnect)使IntersectionObserver对象停止监听工作。 [IntersectionObserver.observe](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/observe)使IntersectionObserver开始监听一个目标元素。 [IntersectionObserver.takeRecords](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/takeRecords)为所有监听目标返回一个[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry)对象数组并且停止监听这些目标。 [IntersectionObserver.unobserve](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/unobserve)使IntersectionObserver停止监听特定目标元素。 五、Vue（xunleif2e/vue-lazy-component）核心 VueLazyComponent.vue &lt;template&gt; &lt;transition-group :tag=&quot;tagName&quot; name=&quot;lazy-component&quot; style=&quot;position: relative;&quot; @before-enter=&quot;(el) =&gt; $emit(&apos;before-enter&apos;, el)&quot; @before-leave=&quot;(el) =&gt; $emit(&apos;before-leave&apos;, el)&quot; @after-enter=&quot;(el) =&gt; $emit(&apos;after-enter&apos;, el)&quot; @after-leave=&quot;(el) =&gt; $emit(&apos;after-leave&apos;, el)&quot; &gt; &lt;div v-if=&quot;isInit&quot; key=&quot;component&quot;&gt; &lt;slot :loading=&quot;loading&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div v-else-if=&quot;$slots.skeleton&quot; key=&quot;skeleton&quot;&gt; &lt;slot name=&quot;skeleton&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div v-else key=&quot;loading&quot;&gt; &lt;/div&gt; &lt;/transition-group&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;VueLazyComponent&apos;, props: { timeout: { type: Number }, tagName: { type: String, default: &apos;div&apos; }, viewport: { type: typeof window !== &apos;undefined&apos; ? window.HTMLElement : Object, default: () =&gt; null }, threshold: { type: String, default: &apos;0px&apos; }, direction: { type: String, default: &apos;vertical&apos; }, maxWaitingTime: { type: Number, default: 50 } }, data () { return { isInit: false, timer: null, io: null, loading: false } }, created () { // 如果指定timeout则无论可见与否都是在timeout之后初始化 if (this.timeout) { this.timer = setTimeout(() =&gt; { this.init() }, this.timeout) } }, mounted () { if (!this.timeout) { // 根据滚动方向来构造视口外边距，用于提前加载 let rootMargin switch (this.direction) { case &apos;vertical&apos;: rootMargin = `${this.threshold} 0px` break case &apos;horizontal&apos;: rootMargin = `0px ${this.threshold}` break } // 观察视口与组件容器的交叉情况 this.io = new window.IntersectionObserver(this.intersectionHandler, { rootMargin, root: this.viewport, threshold: [ 0, Number.MIN_VALUE, 0.01] }) this.io.observe(this.$el) } }, beforeDestroy () { // 在组件销毁前取消观察 if (this.io) { this.io.unobserve(this.$el) } }, methods: { // 交叉情况变化处理函数 intersectionHandler (entries) { if ( // 正在交叉 entries[0].isIntersecting || // 交叉率大于0 entries[0].intersectionRatio ) { this.init() this.io.unobserve(this.$el) } }, // 处理组件和骨架组件的切换 init () { // 此时说明骨架组件即将被切换 this.$emit(&apos;beforeInit&apos;) this.$emit(&apos;before-init&apos;) // 此时可以准备加载懒加载组件的资源 this.loading = true // 由于函数会在主线程中执行，加载懒加载组件非常耗时，容易卡顿 // 所以在requestAnimationFrame回调中延后执行 this.requestAnimationFrame(() =&gt; { this.isInit = true this.$emit(&apos;init&apos;) }) }, requestAnimationFrame (callback) { // 防止等待太久没有执行回调 // 设置最大等待时间 setTimeout(() =&gt; { if (this.isInit) return callback() }, this.maxWaitingTime) // 兼容不支持requestAnimationFrame 的浏览器 return (window.requestAnimationFrame || ((callback) =&gt; setTimeout(callback, 1000 / 60)))(callback) } } } &lt;/script&gt;]]></content>
      <tags>
        <tag>intersectionObserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raect 异步加载组件]]></title>
    <url>%2F2018%2F08%2F11%2FRaect-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[首先需要知道的是dynamic import通过返回Promise的方式实现异步加载功能。 import(&apos;./component.js&apos;) .then((m) =&gt; { // 处理异步加载到的模块m }) .catch((err) =&gt; { // 错误处理 }); 要注意的是import的参数不能使用变量，简单原则是至少要让Webpack知晓应该预先加载哪些内容。这里的参数除了使用常量之外，还可以使用模板字符串componentDir/${name}.js。 其实到这里基本完成代码切割了，接下来做得就是结合react-router实现按模块异步加载。这是跟业务代码相关的，因此每个人的做法都是不一样的。所以以下代码仅供参考。 异步加载 我参考react-router的例子写了个简单的异步加载组件AsyncLoader.js，内容： import React from &apos;react&apos;; export default class AsyncLoader extends React.Component { static propTypes = { path: React.PropTypes.string.isRequired, loading: React.PropTypes.element, }; static defaultProps = { path: &apos;&apos;, loading: &lt;p&gt;Loading...&lt;/p&gt;, error: &lt;p&gt;Error&lt;/p&gt; }; constructor(props) { super(props); this.state = { module: null }; } componentWillMount() { this.load(this.props); } componentWillReceiveProps(nextProps) { if (nextProps.path !== this.props.path || nextProps.error !== this.props.error || nextProps.loading !== this.props.loading) { this.load(nextProps); } } load(props) { this.setState({module: props.loading}); // TODO：异步代码的路径希望做成可以配置的方式 import(`./path/${props.path}`) .then((m) =&gt; { let Module = m.default ? m.default : m; console.log(&quot;module: &quot;, Module); this.setState({module: &lt;Module/&gt;}); }).catch(() =&gt; { this.setState({module: props.error}); }); } render() { return this.state.module; } } 使用方法 &lt;Route exact path=&apos;/book&apos; render={()=&gt;&lt;AsyncLoader path={&apos;./components/Book.js&apos;}/&gt;} /&gt; Webpack打包的时候会根据import的参数生成相应的js文件，默认使用id（webpack生成的，从0开始）命名这个文件。 const Search = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;search&quot; */ &quot;./containers/Search/SearchContainer&quot;)) const BookList = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;bookList&quot; */ &quot;./containers/BookList/BookListContainer&quot;)) import React from &apos;react&apos; export const asyncComponent = loadComponent =&gt; ( class AsyncComponent extends React.Component { state = { Component: null, } componentWillMount() { if (this.hasLoadedComponent()) { return; } loadComponent() .then(module =&gt; module.default) ////兼容 module.default ? module.default : module .then((Component) =&gt; { this.setState({ Component }); }) .catch((err) =&gt; { console.error(`Cannot load component in &lt;AsyncComponent /&gt;`); throw err; }); } hasLoadedComponent() { return this.state.Component !== null; } render() { const { Component } = this.state; return (Component) ? &lt;Component {...this.props} /&gt; : null; } } );]]></content>
      <tags>
        <tag>Raect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5的Websocket]]></title>
    <url>%2F2018%2F08%2F08%2FHTML5%E7%9A%84Websocket%2F</url>
    <content type="text"><![CDATA[先请来TA的邻居：*http：无状态、基于tcp请求/响应模式的应用层协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么）tcp：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) 传输层协议。（看啊，大阅兵，如此规整有秩序） 为什么要引入Websocket： RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。 long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。 从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。 这个时候，Websocket出现了。 Websocket是什么： RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。 对，划重点：双向通信 Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以主动向客户端推送消息。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。 其特点： （1）握手阶段采用 HTTP 协议，默认端口是80和443 （2）建立在TCP协议基础之上，和http协议同属于应用层 （4）可以发送文本，也可以发送二进制数据 （5）没有同源限制，客户端可以与任意服务器通信 （6）协议标识符是ws（如果加密，为wss），如ws://localhost:8023 简单来说，Websocket协议分为两部分：握手和数据传输。 Websocket API： 这里是指客户端 API。 WebSocket 构造函数 通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。 const ws =`newWebSocket(‘ws://localhost:8023’);` Websocket事件 WebSocket`是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。` open: 服务端响应WebSocket连接请求，就会触发open事件。onopen是响应的回调函数。 // 连接请求open事件处理： ws.onopen=e=&gt;{ console.log(&apos;Connection success&apos;); ws.send(`Hello ${e}`); }; 如果要指定多个回调函数，可以使用addEventListener方法。 ws.addEventListener(&apos;open&apos;, e =&gt; { ws.send(`Hello ${e}`); }); 当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。 Message: 收到服务器数据，会触发消息事件，onmessage是响应的回调函数。如下： // 接受文本消息的事件处理： ws.onmessage = e =&gt; { const data = e.data; if (typeof data === &quot;string&quot;) { console.log(&quot;Received string message &quot;,data); } else if (data instanceof Blob) { console.log(&quot;Received blob message &quot;, data); } }; 服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。 Error 发生错误会触发error事件, onerror是响应的回调函数, 会导致连接关闭。 //异常处理 ws.onerror = e =&gt; { console.log(&quot;WebSocket Error: &quot; , e); handleErrors(e); }; 当连接关闭时触发close事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再通信。 WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧） //关闭连接处理 ws.onclose = e =&gt; { const code = e.code; const reason = e.reason; console.log(&quot;Connection close&quot;, code, reason); }; WebSocket 方法： WebSocket 对象有两个方法：send 和 close send: 客户端和服务器建立连接后，可以调用send方法去发送消息。 //发送一个文本消息 ws.send(&quot;this is websocket&quot;); 在open事件的回调中调用send()方法传送数据： const ws = new WebSocket(&apos;ws://localhost:8023&apos;); ws.onopen = e =&gt; { console.log(&apos;Connection success&apos;); ws.send(`Hello ${e}`); }; 如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState. close close方法用来关闭连接。调用close方法后，将不能发送数据。close方法可以传入两个可选的参数，code 和reason, 以告诉服务端为什么终止连接。 ws.close(); //1000是状态码，代表正常结束。 ws.close(1000, &quot;Closing normally&quot;); WebSocket 属性 readyState： readyState值表示连接状态，是只读属性。它有以下四个值： WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开 除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。 function bindEventHandler(data) { if (ws.readyState === WebSocket.OPEN) { ws.send(data); } else { //do something } } bufferedAmount： 当客户端传输大量数据时，浏览器会缓存将要流出的数据，bufferedAmount属性可判断有多少字节的二进制数据没有发送出去，发送是否结束。 ws.onopen = function () { setInterval( function() { //缓存未满的时候发送 if (ws.bufferedAmount &lt; 1024 * 5) { ws.send(data); } }, 2000); }; protocol： protocol代表客户端使用的WebSocket协议。当握手协议未成功，这个属性是空。 接下来，我们说说握手阶段过程。* 当我们创建Websocket实例对象与服务器建立连接时， const ws = new WebSocket(&apos;ws://localhost:8023&apos;)； 首先客户端向服务器发起一个握手请求，其请求报文的内容如下： GET /game HTTP/1.1 Host: 10.242.17.102:8023 Cache-Control: no-cache Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== Sec-WebSocket-Protocol: game Sec-WebSocket-Version: 10 Origin: http://192.168.185.16 Accept-Encoding: gzip, deflate, sdch Accept-Language: zh-CN,zh;q=0.8 从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。 Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。 Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信 Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议 Sec-WebSocket-Version: 通知服务器所使用的协议版本 服务器响应： 当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ= 101 状态码，表示要转换协议啦 Upgrde: 通知客户端将要升级成Websocket协议 Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。 至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。]]></content>
      <tags>
        <tag>Websocket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux中间件]]></title>
    <url>%2F2018%2F08%2F03%2Fredux%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言提到中间件，你可能会想到Express和Koa等服务端框架，没想到也没关系，这句话是我装逼用的。 那么redux中的中间件到底干嘛用的？ 有这样一个问题？我们之前用的Redux都是在Action发出之后立即执行Reducer,计算出state,这是同步操作。如果想异步操作呢？即过一段时间再执行Reducer怎么办？这里就需要用到中间件middleware。 先放一张图看看： 一、中间件的概念redux是有流程的，那么，我们该把这个异步操作放在哪个环节比较合适呢？ Reducer?纯函数只承担计算State功能，不适合其它功能。 View?与State一一对应，可以看做是State的视觉层，也不适合承担其它功能。 Action？它是一个对象，即存储动作的载体，只能被操作。 其实，也只有dispatch能胜任此重任了。那么怎么在dispatch中添加其它操作呢？ let next = store.dispatch; store.dispatch = function(action){ console.log(&apos;老状态 &apos;,store.getState()); next(action); console.log(&apos;新状态 &apos;,store.getState()); } 复制代码 示例中可以看出，我们对store.dispatch重新进行了定义，在发送action的前后，做了打印。 这是中间件的大致雏形，真实的中间件要比这么复杂多了 二、中间件的用法我们在这里先看看中间件是怎么使用，下面我们一步步剖析每个细节。 import {applyMiddleware,createStore} from &apos;redux&apos;; import reduxLogger form &apos;redux-logger&apos;; const store = createStore(reducer,inital_state,applyMiddleware(thunk, promise,reduxLogger)); 复制代码 代码中有两点需要注意： 1、createStore方法可以整个应用的初始状态作为参数内部是这么处理的 let state = inital_state; 复制代码 2、中间件的参数次序有讲究。下面我会把这个问题讲明白。 三、applyMiddlewareMiddleware可以让你包装store的dispatch方法来达到你想要的目的。同时，middleWare还拥有“可组合”这一关键特性。多个middleWare可以被组合到一起使用，形成middleWare链，依次执行。其中每个middleware不需要关心链前后的的middleWare的任何信息。 function applyMiddleware(...middlewares){ returnfunction(createStore){ returnfunction(reducer){ //引入store let store = createStore(reducer); let dispatch = store.dispatch; let middlewareAPI = { getState:store.getState, // 对dispatch进行包装 dispatch:action=&gt;dispatch(action) } //每个中间件都是这种模型 ({ getState, dispatch }) =&gt; next =&gt; action chain = middlewares.map(middleware=&gt;middleware(middleAPI)); dispatch = compose(...chain)(store.dispatch); // dispatch被改装后，返回store return{...store,dispatch}; } } } 复制代码 上面代码中，所有中间件都被放进了一个数组chain,然后嵌套执行，最后执行store.dispatch。中间件内部middlewaAPI可以拿到getState和dispatch这两个方法。 ...middleware：遵循Redux middleware API的函数。每个middleware接受Store的dispatch和getState函数作为命名参数，并返回一个函数。该函数会被传入成为next的下一个middleWare 的dispatch方法，并返回一个接收action的新函数，这个函数可以直接调用next(action)，或者在其他需要的时刻调用，甚至根本不去调用它。 所以，接下来，我们就能看到middleware的函数签名是({ getState, dispatch }) =&gt; next =&gt; action 其实，它的本质就是包装sotre中的dispatch。 上面代码中，还用到了compose方法，我们来看看compose是怎么是实现的？ compose先看下面一个栗子： function add1(str){ return str+1; } function add2(str){ return str+2; } function add3(str){ return str+3; } let result = add3(add2(add1(&apos;好吃&apos;)));// 好吃123; 复制代码 这中写法调用起来，一层套一层，是不是看着很不爽，我们简化一下： function compose(...fns){ if(fns.length==1) return fns[0]; returnfunction(...args){ let last = fns.pop(); return fns.reduceRight((prev,next)=&gt;{ return next(prev); },last(...args)); } } let add = compose(add3,add2,add1);// let result = add(&apos;好吃&apos;);// 好吃123 // 上面的代码其实就是redux3.6.0版本中compose的实现方式 复制代码 看看这个代码是不是用起来，很干练一些。其实还可以简化 function compose(...fns){ if(fns.length==1) return fns[0]; return fns.reduce((a,b)=&gt;(...args)=&gt;a(b(...args)));//add3(add2(add1(&apos;好吃&apos;))) } let add = compose(add3,add2,add1);// let result = add(&apos;好吃&apos;);// 好吃123 // 这是redux3.6.0版本之后的compose实现方式，一直沿用至今。 复制代码 至于为什么applyMiddleWare的参数有顺序，这里给出了答案。 四、Applymiddleware的三个常用参数4.1、日志记录使用 Redux 的一个益处就是它让 state 的变化过程变的可预知和透明。每当一个 action 发起完成后，新的 state 就会被计算并保存下来。State 不能被自身修改，只能由特定的 action 引起变化。 试想一下，当我们的应用中每一个 action 被发起以及每次新的 state 被计算完成时都将它们记录下来，岂不是很好？当程序出现问题时，我们可以通过查阅日志找出是哪个 action 导致了 state 不正确。图片的效果是不是很期待啊！！！ 我们先来手动实现一版。 // 记录所有被发起的action和新的statelet next = store.dispatch; store.dispatch = function(action){ console.log(&apos;老状态 &apos;,store.getState()); next(action); console.log(&apos;新状态 &apos;,store.getState()); } 复制代码 还是上面的示例，我们来做个修改 let logger = function({ getState, dispatch }){ returnfunction(next){// 这里的next可以理解为store.dispath,本质上就是调用 middleware 链中下一个 middleware 的 dispatch。returnfunction(action){ console.log(&apos;老状态1 &apos;,getState()); next(action);//派发动作console.log(&apos;新状态1 &apos;,getState()); } } } // 高逼格写法let logger = ({ getState, dispatch }) =&gt; next =&gt; action =&gt; { console.log(&apos;老状态1 &apos;,getState()); next(action) console.log(&apos;新状态1 &apos;,getState()); } 复制代码 4.2、redux-thunk 中间件redux-thunk 是redux官方文档中用到的异步组件，实质就是一个redux中间件，一个封装表达式的函数，封装的目的就是延迟执行表达式。 redux-thunk是一个通用的解决方案，其核心思想是让action可以变成一个thunk，这样的话，同步情况：dispatch(action),异步情况：dispatch(thunk)。 下面是redux-thunk的实现： let thunk = ({dispatch,getState})=&gt;next=&gt;action=&gt;{ if(typeof action == &apos;function&apos;){ action(dispatch,getState); }else{ next(action);//这里可以理解为dispatch(action),本质上就是调用 middleware 链中下一个 middleware 的 dispatch。 } } 复制代码 使用redux-thunk const store = createStore( reducer, applyMiddleware(thunk) ); 复制代码 然后我们实现一个thunkActionCreator //过一秒加1 exportfunction thunkActionCreator(payload){ returnfunction(dispatch,getState){ setTimeout(function(){ dispatch({type:types.INCREMENT,payload:payload}); },1000); } }, 复制代码 最后，在组件中dispatch thunk this.dispatch(thunkActionCreator(payload)); 复制代码 4.3、redux-promiseredux-promise也是延迟执行的表达式，它是解决异步的另外一种方案。 redux-thunk和核心思想是把action变成thunk，而redux-promise的核心思想是让action返回一个promise对象。 这个中间件使得store.dispatch方法可以接收Promise对象作为参数。这时 ，action 有两种写法: 写法一、返回值是一个Promise对象。 functionpromiseIncrement(payload){ // return {type:types.INCREMENT,payload:payload} 以前是这种写法returnnewPromise(function(resolve,reject){ setTimeout(function(){ resolve({type:types.INCREMENT,payload:payload}); },1000); }); }, 复制代码 写法二，action 对象的payload属性是一个Promise对象，这需要从 functionpayloadIncrement(){ return { type:types.INCREMENT, payload: newPromise(function(resolve,reject){ setTimeout(function(){ if(Math.random()&gt;.5){ resolve(100); }else{ reject(-100); } },1000) }) } } 复制代码 下面我们来看看 redux-promise是怎么实现的，就会明白它内部是怎么操作的. let promise = ({dispatch,getState})=&gt;next=&gt;action=&gt;{ if(action.then &amp;&amp; typeof action.then == &apos;function&apos;){ action.then(dispatch); // 这里的dispatch就是一个函数，dispatch(action){state:reducer(state,action)}; }elseif(action.payload&amp;&amp; action.payload.then&amp;&amp; typeof action.payload.then == &apos;function&apos;){ action.payload.then(payload=&gt;dispatch({...action,payload}),payload=&gt;dispatch({...action,payload})); }else{ next(action); } } 复制代码 上面的代码可以看出，如果Action本身就是一个Promise，它resolve以后的值应该是一个Action对象，会被dispatch方法送出action.then(dispatch)；如果Action对象的 payload属性是一个Promise对象，那么无论resolve和reject,dispatch 方法都会发出Action。]]></content>
      <tags>
        <tag>Raedux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[强大的margin负边距]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%BC%BA%E5%A4%A7%E7%9A%84margin%E8%B4%9F%E8%BE%B9%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[css中的负边距(negative margin)是布局中的一个常用技巧，只要运用得合理常常会有意想不到的效果。很多特殊的css布局方法都依赖于负边距，所以掌握它的用法对于前端的同学来说，那是必须的。本文非常基础，老鸟可以略过。 左和右的负边距对元素宽度的影响 负边距不仅能影响元素在文档流中的位置，还能增加元素的宽度！ 这个作用能实现的前提是：该元素没有设定width属性（当然width:auto是可以的）。 比如下图的黑灰色部分是一个块状元素，它没有设定宽度。它被包裹在一个宽度为400px,且水平居中的父元素中。 现在给这个元素的设一个margin-right:-100px; 我们看到它的宽度的确变长100px;然后再给它设一个margin-left:-100px; 我们看到它变得更宽了。 负的margin会改变元素的宽度，这的确很让人费解，如果说负边距会改变元素在文档流中的位置还是很好理解的话，那改变宽度这种现象还真的蛮让人不可思议的。 那这货有什么用途呢？我就举一个例子吧。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;浮动两端对齐&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; ul, li { margin: 0; padding: 0; } h2 { clear: both; font-size: 1.2em; } .justify { width: 320px; /* 1行3个li，li之间距离10px = 100px*3 + 10px*2 */ overflow: hidden; margin: 10px; border: 1px solid #999999; } .justify ul { width: 330px; /* 可容纳下3列的宽度 */ margin-bottom: -10px; /* 隐藏掉最下面一行的margin-bottom */ overflow: hidden; zoom: 1; /* 触发IE的Layout */ } *+html .justify ul { margin-bottom: 0; /* 针对IE7中最后1行li的margin-bottom失效 */ } .justify li { display: inline; float: left; list-style: none; width: 100px; height: 100px; margin: 0 10px 10px 0; background: #EEEEEE; } .margin ul { width: auto; margin: 0 -10px -10px 0; } .col-2 { width: 210px; } .col-4 { width: 430px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;a href=&quot;http://www.ddcat.net/blog/?p=1199&quot; title=&quot;回到猫窝Blog&quot;&gt;回到猫窝Blog&lt;/a&gt; &lt;/div&gt; &lt;h1&gt;浮动两端对齐&lt;/h1&gt; &lt;h2&gt;ul定宽&lt;/h2&gt; &lt;div class=&quot;justify&quot;&gt; &lt;ul&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;中间&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;中间&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;中间&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h2&gt;ul使用负margin值&lt;/h2&gt; &lt;div class=&quot;justify margin&quot;&gt; &lt;ul&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;中间&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;中间&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;中间&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h2&gt;两列&lt;/h2&gt; &lt;div class=&quot;justify margin col-2&quot;&gt; &lt;ul&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;li&gt;靠左边&lt;/li&gt; &lt;li&gt;靠右边&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;h2&gt;四列&lt;/h2&gt; &lt;div class=&quot;justify margin col-4&quot;&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div&gt; &lt;a href=&quot;http://www.ddcat.net/blog/?p=1199&quot; title=&quot;回到猫窝Blog&quot;&gt;回到猫窝Blog&lt;/a&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 一个负的margin-right,相当于把ul的宽度增加了10px. 负边距对浮动元素的影响 负边距对浮动元素的影响与负边距对文档流中元素的影响其实是差不多的。文档流中元素的位置由文档流的走向决定，浮动的元素也可以看成有一个“浮动流”存在，不过浮动流既可以向左，也可以向右。 比如下图是三个向左浮动的元素，宽高都是100px： 现在把它们都设一个margin-right:-50px; 然后会变成这样子： 我们看到后面的元素叠到了前面的元素上。 再看下面的图： 我们把浏览器缩小了，然后因为宽度不够，元素3掉下来了。我们给元素3设一个margin-left:-80px;看看会怎么样 这时我们看到元素3上去了，而且还覆盖了元素2的一部分。继续元素3设为margin-left:-100px 这时元素3完全覆盖住了元素2,当元素3设为：margin-left:-200px时： 我们看到元素3继续向左移动并覆盖住了元素1。 现在想必大家都明白了负边距对浮动元素位置的影响了吧。所以那些说得很好听的什么圣杯布局、双飞翼布局啊什么的，都是利用这个原理实现的。就是某个元素虽然是写在了后面，但可以通过负边距让它在浏览器显示的时候是在前面的。这个以后可以再慢慢讲。 负边距对绝对定位元素的影响 绝对定位的元素定义的top、right、bottom、left等值是元素自身的边界到最近的已定位的祖先元素的距离，这个元素自身的边界指的就是margin定义的边界，所以，如果margin为正的时候，那它的边界是向外扩的，如果margin为负的时候，则它的边界是向里收的。利用这点，就有了经典的利用绝对定位来居中的方法： 看下效果： 但该方法的缺点是必须要知道要居中元素的高度和宽度。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么Redux 需要 reducers是纯函数？]]></title>
    <url>%2F2018%2F07%2F31%2F%E4%B8%BA%E4%BB%80%E4%B9%88Redux-%E9%9C%80%E8%A6%81-reducers%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[为什么Redux 需要 reducers是纯函数？ 这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个state和action作为参数，然后返回一个新的state，这个新的state不能是在原来state基础上的修改。所以经常可以看到以下的写法：123return Object.assign(...)//或者----------return &#123;...state,xx:xxx&#125; 其作用，都是为了返回一个全新的对象。 为什么reducers要求是纯函数(返回全新的对象，不影响原对象)? –某面试官 纯函数从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。举个例子，下面的add函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。1const add = (a,b) =&gt; &#123;a + b&#125;; 这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数为什么必须是纯函数?先告诉你结果吧，如果在reducer中，在原来的state上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！接下来看下Redux的源码：Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的state是全新的对象。那么为什么非要这么麻烦开发者呢？请看下面的例子：尝试比较a和b是否相同12345678910111213var a = &#123; name: &apos;jack&apos;, friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;], years: 12, ...//省略n项目&#125; var b = &#123; name: &apos;jack&apos;, friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;], years: 13, ...//省略n项目&#125; 思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？有！12//接上面的例子a === b //false 我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是redux的reducer如此设计的原因了]]></content>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 ES6 中 Promise 的面试题]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%85%B3%E4%BA%8E-ES6-%E4%B8%AD-Promise-%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[说明最近在复习 Promise 的知识，所以就做了一些题，这里挑出几道题，大家一起看看吧。 题目一const promise = newPromise((resolve, reject) =&gt; { console.log(1); resolve(); console.log(2); }) promise.then(() =&gt; { console.log(3); }) console.log(4); 解析首先 Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then() 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3。 答案1243 题目二const promise = newPromise((resolve, reject) =&gt; { resolve(&apos;success1&apos;); reject(&apos;error&apos;); resolve(&apos;success2&apos;); }); promise.then((res) =&gt; { console.log(&apos;then:&apos;, res); }).catch((err) =&gt; { console.log(&apos;catch:&apos;, err); }) 解析resolve 函数将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 而一旦状态改变，就不会再变。所以 代码中的reject(&#39;error&#39;); 不会有作用。 Promise 只能 resolve 一次，剩下的调用都会被忽略。所以 第二次的 resolve(&#39;success2&#39;); 也不会有作用。 答案then: success1 题目三Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 解析Promise.resolve 方法的参数如果是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为resolved，Promise.resolve 方法的参数，会同时传给回调函数。 then 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。 答案1 题目四红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promse实现）三个亮灯函数已经存在： functionred() { console.log(&apos;red&apos;); } functiongreen() { console.log(&apos;green&apos;); } functionyellow() { console.log(&apos;yellow&apos;); } 解析红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，意思就是3秒，执行一次 red 函数，2秒执行一次 green 函数，1秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以就利用递归来实现。 答案functionred() { console.log(&apos;red&apos;); } functiongreen() { console.log(&apos;green&apos;); } functionyellow() { console.log(&apos;yellow&apos;); } var light = function (timmer, cb) { returnnewPromise(function (resolve, reject) { setTimeout(function () { cb(); resolve(); }, timmer); }); }; var step = function () { Promise.resolve().then(function () { return light(3000, red); }).then(function () { return light(2000, green); }).then(function () { return light(1000, yellow); }).then(function () { step(); }); } step(); 这个答案，看上去已经很不错了，不过经小伙伴提醒，如果一直这么递归下去，会有栈溢出的问题，对于这个问题，其他小伙伴有什么优化建议的话，可以在评论区展示出来。 题目五实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。 const timeout = ms =&gt;newPromise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(); }, ms); }); const ajax1 = () =&gt; timeout(2000).then(() =&gt; { console.log(&apos;1&apos;); return1; }); const ajax2 = () =&gt; timeout(1000).then(() =&gt; { console.log(&apos;2&apos;); return2; }); const ajax3 = () =&gt; timeout(2000).then(() =&gt; { console.log(&apos;3&apos;); return3; }); const mergePromise = ajaxArray =&gt; { // 在这里实现你的代码 }; mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; { console.log(&apos;done&apos;); console.log(data); // data 为 [1, 2, 3] }); // 要求分别输出// 1// 2// 3// done// [1, 2, 3] 解析首先 ajax1 、ajax2、ajax3 都是函数，只是这些函数执行后会返回一个 Promise，按题目的要求我们只要顺序执行这三个函数就好了，然后把结果放到 data 中，但是这些函数里都是异步操作，想要按顺序执行，然后输出 1，2，3并没有那么简单，看个例子。 functionA() { setTimeout(function () { console.log(&apos;a&apos;); }, 3000); } functionB() { setTimeout(function () { console.log(&apos;b&apos;); }, 1000); } A(); B(); // b// a 例子中我们是按顺序执行的 A，B 但是输出的结果却是 b，a 对于这些异步函数来说，并不会按顺序执行完一个，再执行后一个。这道题就是考用 Promise 控制异步流程，我们要想办法，让这些函数，一个执行完之后，再执行下一个，看答案吧。 答案// 保存数组中的函数执行后的结果var data = []; // Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。var sequence = Promise.resolve(); ajaxArray.forEach(function (item) { // 第一次的 then 方法用来执行数组中的每个函数，// 第二次的 then 方法接受数组中的函数执行后返回的结果，// 并把结果添加到 data 中，然后把 data 返回。 sequence = sequence.then(item).then(function (res) { data.push(res); return data; }); }) // 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。return sequence; 题目六以下代码最后输出什么？ const first = () =&gt; (newPromise((resolve, reject) =&gt; { console.log(3); let p = newPromise((resolve, reject) =&gt; { console.log(7); setTimeout(() =&gt; { console.log(5); resolve(6); }, 0) resolve(1); }); resolve(2); p.then((arg) =&gt; { console.log(arg); }); })); first().then((arg) =&gt; { console.log(arg); }); console.log(4); 解析这道题就其实和 Promise 的关系不太大，主要是需要理解 JS执行机制，才能很好的解决这道题，对于 JS 执行机制不了解的朋友推荐看看这篇文章 这一次，彻底弄懂 JavaScript 执行机制 第一轮事件循环先执行宏任务，主script ，new Promise立即执行，输出【3】， 执行 p 这个new Promise 操作，输出【7】， 发现 setTimeout，将回调放入下一轮任务队列（Event Queue），p 的 then，姑且叫做 then1，放入微任务队列，发现 first 的 then，叫 then2，放入微任务队列。执行console.log(4)，输出【4】，宏任务执行结束。 再执行微任务，执行 then1，输出【1】， 执行 then2，输出【2】。 到此为止，第一轮事件循环结束。开始执行第二轮。 第二轮事件循环先执行宏任务里面的，也就是 setTimeout 的回调，输出【5】。resolve(6) 不会生效，因为 p 这个 Promise 的状态一旦改变就不会在改变了。 答案374125 题目七有 8 个图片资源的 url，已经存储在数组 urls 中（即urls = [&#39;http://example.com/1.jpg&#39;, ...., &#39;http://example.com/8.jpg&#39;]），而且已经有一个函数 function loadImg，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。 var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;]; functionloadImg(url) { returnnewPromise((resolve, reject) =&gt; { const img = new Image() img.onload = function () { console.log(&apos;一张图片加载完成&apos;); resolve(); } img.onerror = reject img.src = url }) }; 解析题目的意思是需要我们这么做，先并发请求 3 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 3 个，直到需要加载的图片都全部发起请求。 用 Promise 来实现就是，先并发请求3个图片资源，这样可以得到 3 个 Promise，组成一个数组，就叫promises 吧，然后不断的调用 Promise.race 来返回最快改变状态的 Promise，然后从数组（promises）中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 url 被取完，最后再使用 Promise.all 来处理一遍数组（promises）中没有改变状态的 Promise。 答案var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;]; functionloadImg(url) { returnnewPromise((resolve, reject) =&gt; { const img = new Image() img.onload = function () { console.log(&apos;一张图片加载完成&apos;); resolve(); } img.onerror = reject img.src = url }) }; functionlimitLoad(urls, handler, limit) { // 对数组做一个拷贝const sequence = [].concat(urls) let promises = []; //并发请求到最大数 promises = sequence.splice(0, limit).map((url, index) =&gt; { // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标return handler(url).then(() =&gt; { return index }); }); // 利用数组的 reduce 方法来以队列的形式执行return sequence.reduce((last, url, currentIndex) =&gt; { return last.then(() =&gt; { // 返回最快改变状态的 PromisereturnPromise.race(promises) }).catch(err =&gt; { // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误// 更重要的是防止中断整个链式调用console.error(err) }).then((res) =&gt; { // 用新的 Promise 替换掉最快改变状态的 Promise promises[res] = handler(sequence[currentIndex]).then(() =&gt; { return res }); }) }, Promise.resolve()).then(() =&gt; { returnPromise.all(promises) }) } limitLoad(urls, loadImg, 3) /* 因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用 limitLoad(urls, loadImg, 3).then(() =&gt; { console.log(&apos;所有图片加载完成&apos;); }).catch(err =&gt; { console.error(err); }) */]]></content>
      <tags>
        <tag>Promise</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS defer和async的区别]]></title>
    <url>%2F2018%2F07%2F26%2FCSS-defer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[先来试个一句话解释仨，当浏览器碰到 script 脚本的时候：1&lt;script src=&quot;&quot;&gt;&lt;/script&gt; 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。1&lt;script async src=&quot;&quot;&gt;&lt;/script&gt; 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。1&lt;script defer src=&quot;&quot;&gt;&lt;/script&gt; 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 然后从实用角度来说呢，首先把所有脚本都丢到 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。 接着，我们来看一张图咯： 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】此图告诉我们以下几个要点： defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析） 它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用 async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js几种文件路径及path模块]]></title>
    <url>%2F2018%2F07%2F15%2Fnodejs%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%8F%8Apath%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[前言最近在写一篇weex的webpack配置，刚刚踩坑了，weekpack中会用到path模块，而对于这个模块，我想抽离出来看一下，因为这个用到的还是比较多的,喜欢的朋友可以点个喜欢，或者去我的github点个star也行，谢谢支持，举起小手指点一点哦😯，写的不对的地方，评论拍砖，谢谢。 node中的路径分类node中的路径大致分5类，dirname,filename,process.cwd(),./,../,其中前三个都是绝对路径 我们先来看一个简单点的例子 假如，我有一个文件的目录结构如下： editor/ - dist/ - src/ - task.js 然后我们在task.js文件中写入一下代码 const path = require(&apos;path&apos;); console.log(__dirname); console.log(__filename); console.log(process.cwd()); console.log(path.resolve(&apos;./&apos;)); 在editor目录下运行node src/task.js，我们可以看到结果如下： /Users/laihuamin/Documents/richEditor/editor/src /Users/laihuamin/Documents/richEditor/editor/src/task.js /Users/laihuamin/Documents/richEditor/editor /Users/laihuamin/Documents/richEditor/editor 然后我们有可以在src目录下运行这个文件，node task.js,运行结果如下： /Users/laihuamin/Documents/richEditor/editor/src /Users/laihuamin/Documents/richEditor/editor/src/task.js /Users/laihuamin/Documents/richEditor/editor/src /Users/laihuamin/Documents/richEditor/editor/src 对比两个输出结果，我们可以归纳一下几点： 1.dirname:返回的是这个文件所在文件夹的位置2.filename:你运行命令代表的是文件所在的位置，不管你运行什么命令，都是指向文件3.process.cwd():你运行node命令所在文件夹的位置，比如你在src目录下运行，那么就是输出到src为止，下面的同理。 path讲完前面三个绝对路径，我倒是挺想来聊聊path这个模块的，这个node模块在很多地方都有应用，所以，对于我们来说，掌握他，对我们以后的发展更有利，不用每次看webpack的配置文件还要去查询一下这个api是干什么用的，很影响我们的效率 nodeJS/path 上面那个网站有详细的api，但是我们这里不用都掌握吧，我就讲几个我遇到过的，我觉得webpack等工程配置中会用到的 path.normalize这个方法就是把不规范的路径规范化，比如看下面的例子 const path = require(&apos;path&apos;); console.log(path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;)); 输出结果： /foo/bar/baz/asdf path.joinconst path = require(&apos;path&apos;); console.log(path.join(&apos;src&apos;, &apos;task.js&apos;)); const path = require(&apos;path&apos;); console.log(path.join(&apos;dist&apos;, &apos;task.js&apos;)); const path = require(&apos;path&apos;); console.log(path.join(&apos;&apos;)); 这么两个的输出结果是： src/task.js dist/task.js . 他的作用也就显而易见，他有一下几条规则：1.传入的参数是字符串的路径片段，可以是一个，也可以是多个 2.返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，Unix系统是”/“，Windows系统是”\“，那么你在两个系统下看到的返回结果就不一样。 3.如果返回的路径字符串长度为零，那么他会返回一个’.’，代表当前的文件夹。 4.如果传入的参数中有不是字符串的，那就直接会报错 path.parse我们先来看个例子，在src目录下的task.js写入 const path = require(&apos;path&apos;); console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor&apos;)); 然后运行node src/task.js之后,输出的结果如下： { root: &apos;/&apos;, dir: &apos;/Users/laihuamin/Documents/richEditor&apos;, base: &apos;editor&apos;, ext: &apos;&apos;, name: &apos;editor&apos; } 他返回的是一个对象，那么我们来把这么几个名词熟悉一下： 这个表格应该展示的很形象，但是我们还是来解释一下这些名词：1.root：代表根目录2.dir：代表文件所在的文件夹3.base：代表整一个文件4.name：代表文件名5.ext: 代表文件的后缀名 那我们根据下面的规则，来看一下下面这个例子，最好自己脑子做一遍 const path = require(&apos;path&apos;); console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;)); 输出的结果： { root: &apos;/&apos;, dir: &apos;/Users/laihuamin/Documents/richEditor/editor/src&apos;, base: &apos;task.js&apos;, ext: &apos;.js&apos;, name: &apos;task&apos; } 你做对了么？0.0 path.basename那有了前面这个铺垫，想必这个接口猜也能猜的到了。。。。我们看下面这个例子 const path = require(&apos;path&apos;); console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;)); 输出的结果是： task.js 我们还是简单介绍一下，接收两个参数，一个是path,还有一个是ext（可选参数）. const path = require(&apos;path&apos;) console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;, &apos;.js&apos;)); 输出结果: task path.dirname这个接口比basename还要简单，我就不多说了，看例子，看结果 const path = require(&apos;path&apos;); console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;)); 输出的结果: /Users/laihuamin/Documents/richEditor/editor/src 注意一下，接收的参数是字符串类型 path.extname这个就是展示文件的扩展名，我们得注意几种情况 const path = require(&apos;path&apos;); path.extname(&apos;index.html&apos;); path.extname(&apos;index.coffee.md&apos;); path.extname(&apos;index.&apos;); path.extname(&apos;index&apos;); path.extname(&apos;.index&apos;); 输出的结果是： .html .md . &apos;&apos; &apos;&apos; 自己注意一下这几个情况 path.resolve我们通过下面这几个例子先来熟悉一下： const path = require(&apos;path&apos;); console.log(path.resolve(&apos;/foo/bar&apos;, &apos;/bar/faa&apos;, &apos;..&apos;, &apos;a/../c&apos;)); 输出的结果是 /bar/c 他就相当于一堆cd操作，我们一步一步看 cd /foo/bar/ //这是第一步, 现在的位置是/foo/bar/ cd /bar/faa //这是第二步，这里和第一步有区别，他是从/进入的，也就时候根目录，现在的位置是/bar/faa cd .. //第三步，从faa退出来，现在的位置是 /bar cd a/../c //第四步，进入a，然后在推出，在进入c，最后位置是/bar/c 但是这个操作和cd还是有区别的，这个路径不一定要存在，而且最后的可以是文件 path.relative这个返回的是from到to的相对路径，什么意思呢，我们看下面的例子就知道了. const path = require(&apos;path&apos;); console.log(path.relative(&apos;src/bar/baz&apos;, &apos;src/aaa/bbb&apos;)); 输出的结果是： ../../aaa/bbb 总结这些比较实用的方法，分享给大家，自己还是老老实实去看weektool的webpack的配置文件了，喜欢的朋友可以点个喜欢，或者去我的github点个star也行，谢谢支持，举起小手指点一点哦😯。]]></content>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue安全权限控制axios拦截]]></title>
    <url>%2F2018%2F07%2F02%2FVue%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6axios%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[何为权限控制 //请求失败后的统一拦截，以及ajax的基本设置 import axios from &apos;axios&apos;; import qs from &apos;qs&apos;; function cleanRequest(req) { for (const i in req) { /* eslint guard-for-in: 0 */ if (req[i] !== 0 &amp;&amp; !req[i]) { delete req[i]; } } } axios.defaults.withCredentials = true; axios.defaults.xsrfCookieName = null; axios.defaults.headers.common[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos;; axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; //系统弹层 import Toast from &apos;mint-ui/lib/toast&apos;; import &apos;mint-ui/lib/toast/style.css&apos;; module.exports.install = function (Vue) { axios.defaults.baseURL=&quot;/&quot;; Vue.prototype.$http = axios; Vue.http = axios; axios.interceptors.request.use( function (request) { const params = request.params; if (params) { cleanRequest(params); } if (request.data) { cleanRequest(request.data); request.data=qs.stringify(Object.assign(request.data,Bus.movieConfig)) }else{ request.data=qs.stringify(Bus.movieConfig) } return request; }, function (error) { return Promise.reject(error); } ); // Add a response interceptor axios.interceptors.response.use( function (response) { return response; }, function (error) { Toast(&apos;系统繁忙，请稍后重试!&apos;); // Do something with response error return Promise.reject(error); } ); }; 权限控制大致分为两个维度: 垂直维度: 控制用户可以访问哪些url的权限 水平维度: 控制用户访问特定url，获取哪些数据的权限（e.g. 普通用户、管理员、超级管理员访问同一url，获取的数据是不同的） Web权限控制方案List 前后端不分离：以Java为例，后端通过jsp、freemark、thmeleaf等模板来渲染相应权限的数据，渲染完呈现在浏览器端 前后端分离：▫SPA单页面应用，路由由前端控制，前端通过js控制hash路由的权限▫SSR服务端渲染，Node中间层做代理路由，判断权限渲染特定的路由至浏览器端 SPA前端权限控制方案 SPA: 单页Web应用（single page web application）将所有web活动局限于一个html页面中，利用js通过hash或者浏览器history api来实现无刷新路由跳转，前后端通过ajax数据通信，避免了浏览器的刷新重新加载，为用户提供流程的操作体验。这意味着前端接管了路由层，需要通过调用前端自身的MVC模块，来渲染不同的页面。 Base on： Vue 前端MVVM框架 Vuex 状态管理机 Vue-router 路由 Axios HTTP请求库 1.登陆事件Login // 1.触发登陆事件 dispatch(&apos;login&apos;) // actions commit(types.LOGIN_SUCCESS, res.data.data) ... 2.获取Token，经Base64编码后存至sessionStorage // mutations const mutations = { [types.LOGIN_SUCCESS] (state, data) { state.authlock = false // 2.登陆成功回调拿到token,经Base64 编码后存入本地sessionStorage let token = Base64.encode(data + &apos;:HIKDATAE&apos;) sessionStorage.setItem(&apos;userToken&apos;, token) // 路由跳转至目标页面 router.push({name: &apos;xxx&apos;}) }, [types.LOGOUT_SUCCESS] (state) { state.authlock = true // 登出成功回调,移除本地token sessionStorage.removeItem(&apos;userToken&apos;) router.push({name: &apos;Login&apos;}) } } 3.所有HTTP Header Authorization 加上编码后的token(前后端可约定规则) // Axios 请求钩子（request） axios.interceptors.request.use(req =&gt; { let token = sessionStorage.getItem(&apos;user&apos;) if (token) { // 3.token 存在,则在之后所有请求的http请求头 Authorization 带上base64编码后的token,后台拿到token后进行验证权限 req.headers.Authorization = `Basic ${token}` } req.data = qs.stringify(req.data) return req }, error =&gt; { return Promise.reject(error) }) 浏览器http header 4.请求拦截：后台拿到token后对每个请求进行校验，若校验失败返回401，前端response钩子里统一catch error 跳转至登陆页面。 // Axios 请求钩子（response） axios.interceptors.response.use(res =&gt; { return res }, error =&gt; { if (error.response) { switch (error.response.status) { // 4.所有接口response校验钩子,若token检验失败,后台返回 401 error code, 清除token信息并跳转到登录页面 case 401: store.commit(types.LOGOUT) router.replace({ path: &apos;/login&apos; }) } } return Promise.reject(error) }) 5.路由跳转拦截：任意路由跳转时，在路由beforeEach钩子里校验本地是否存在token，若没有，则跳转至登陆页面 // 路由钩子(每个路由跳转前调起beforeEach钩子) router.beforeEach((to, from, next) =&gt; { if (to.path === &apos;/login&apos;) { sessionStorage.removeItem(&apos;userToken&apos;) } let user = sessionStorage.getItem(&apos;userToken&apos;) if (!user &amp;&amp; to.path !== &apos;/login&apos;) { // 若本地token不存在,则任意路由跳转的时候,重定向至login 登陆页面 next({ path: &apos;/login&apos; }) } else { next() } }) 6.登出Logout：清楚本地sessionStorage的token信息 // mutations const mutations = { ... [types.LOGOUT_SUCCESS] (state) { state.authlock = true // 登出成功回调,移除本地token sessionStorage.removeItem(&apos;userToken&apos;) router.push({name: &apos;Login&apos;}) } } 流程示意图如下:]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6实现自己的 Promise]]></title>
    <url>%2F2018%2F07%2F02%2FES6-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-Promise%2F</url>
    <content type="text"><![CDATA[一、JavaScript异步编程背景从去年ES2015发布至今，已经过去了一年多，ES2015发布的新的语言特性中最为流行的也就莫过于Promise了，Promise使得如今JavaScript异步编程如此轻松惬意，甚至慢慢遗忘了曾经那不堪回首的痛楚。其实从JavaScript诞生，JavaScript中的异步编程就已经出现，例如点击鼠标、敲击键盘这些事件的处理函数都是异步的，时间到了2009年，Node.js横空出世，在整个Node.js的实现中，将回调模式的异步编程机制发挥的淋漓尽致，Node的流行也是的越来越多的JavaScripter开始了异步编程，但是回调模式的副作用也慢慢展现在人们眼前，错误处理不够优雅以及嵌套回调带来的“回调地狱”。这些副作用使得人们从回调模式的温柔乡中慢慢清醒过来，开始寻找更为优雅的异步编程模式，路漫漫其修远兮、吾将上下而求索。时间到了2015年，Promise拯救那些苦苦探索的先驱。行使它历史使命的时代似乎已经到来。 每个事物的诞生有他的历史使命，更有其历史成因，促进其被那些探索的先驱们所发现。了解nodejs或者熟悉浏览器的人都知道，JavaScript引擎是基于事件循环或单线程这两个特性的。更为甚者在浏览器中，更新UI(也就是浏览器重绘、重拍页面布局)和执行JavaScript代码也在一个单线程中，可想而知，一个线程就相当于只有一条马路，如果一辆马车抛锚在路上了阻塞了马路，那么别的马车也就拥堵在了那儿，这个单线程容易被阻塞是一个道理，单线程也只能允许某一时间点只能够执行一段代码。同时，JavaScript没有想它的哥哥姐姐们那么财大气粗，像Java或者C++，一个线程不够，那么再加一个线程，这样就能够同时执行多段代码了，但是这样就会带来的隐患就是状态不容易维护，JavaScript选择了单线程非阻塞式的方式，也就是异步编程的方式，就像上面的马车抛锚在了路上，那么把马车推到路边的维修站，让其他马车先过去，等马车修好了再回到马路上继续行驶，这就是单线程非阻塞方式。正如Promise的工作方式一样，通过Promise去向服务器发起一个请求，毕竟请求有网络开销，不可能马上就返回请求结果的，这个时候Promise就处于pending状态，但是其并不会阻塞其他代码的执行，当请求返回时，修改Promise状态为fulfilled或者rejected（失败请求）。同时执行绑定到这两个状态上面的“处理函数”。这就是异步编程的模式，也就是Promise兢兢业业的工作方式，在下面一个部分将详细讨论Promise。 二、Promise基础怎么一句话解释Promise呢？Promise可以代指那些尚未完成的一些操作，但是其在未来的某个时间会返回某一特定的结果。 当创建一个Promise实例后，其代表一个未知的值，在将来的某个时间会返回一个成功的返回值，或者失败的返回值，我们可以为这些返回值添加处理函数，当值返回时，处理函数被调用。Promise总是处于下面三种状态之一： pending： Promise的初始状态，也就是未被fulfilled或者rejected的状态。 fulfilled： 意味着promise代指的操作已经成功完成。 rejected：意味着promise代指的操作由于某些原因失败。 一个处于pending状态的promise可能由于某个成功返回值而发展为fulfilled状态，也有可能因为某些错误而进入rejected状态，无论是进入fulfilled状态或者rejected状态，绑定到这两种状态上面的处理函数就会被执行。并且进入fulfilled或者rejected状态也就不能再返回pending状态了。 三、边学边写上面说了那么多，其实都是铺垫。接下来我们就开始实现自己的Promise对象。go go go！！！ 第一步：Promise构造函数Promise有三种状态，pending、fulfilled、rejected。 const PENDING = &apos;PENDING&apos; // Promise 的 初始状态 const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态 const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态 有了三种状态后，那么我们怎么创建一个Promise实例呢？ const promise = new Promise(executor) // 创建Promise的语法 通过上面生成promise语法我们知道，Promise实例是调用Promise构造函数通过new操作符生成的。这个构造函数我们可以先这样写： class Promise { constructor(executor) { this.status = PENDING // 创建一个promise时，首先进行状态初始化。pending this.result = undefined // result属性用来缓存promise的返回结果，可以是成功的返回结果，或失败的返回结果 } } 我们可以看到上面构造函数接受的参数executor。它是一个函数，并且接受其他两个函数（resolve和reject）作为参数，当resolve函数调用后，promise的状态转化为fulfilled，并且执行成功返回的处理函数（不用着急后面会说到怎么添加处理函数）。当reject函数调用后，promise状态转化为rejected，并且执行失败返回的处理函数。 现在我们的代码大概是这样的： class Promise { constructor(executor) { this.status = PENDING this.result = undefined executor(data =&gt; resolveProvider(this, data), err =&gt; rejectProvider(this, err)) } } function resolveProvider(promise, data) { if (promise.status !== PENDING) return false promise.status = FULFILLED } function rejectProvider(promise, data) { if (promise.status !== PENDING) return false promise.status = FULFILLED } Dont Repeat Yourselt！！！我们可以看到上面代码后面两个函数基本相同，其实我们可以把它整合成一个函数，在结合高阶函数的使用。 const statusProvider = (promise, status) =&gt; data =&gt; { if (promise.status !== PENDING) return false promise.status = status promise.result = data } class Promise { constructor(executor) { this.status = PENDING this.result = undefined executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED)) } } 现在我们的代码就看上去简洁多了。 第二步：为Promise添加处理函数其实通过 new Promise(executor)已经可以生成一个Promise实例了，甚至我们可以通过传递到executor中的resolve和reject方法来改变promise状态，但是！现在的promise依然没啥卵用！！！因为我们并没有给它添加成功和失败返回的处理函数。 首先我们需要给我们的promise增加两个属性，successListener和failureListener用来分别缓存成功处理函数和失败处理函数。 class Promise { constructor(executor) { this.status = PENDING this.successListener = [] this.failureListener = [] this.result = undefined executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED)) } } 怎么添加处理函数呢？ECMASCRIPT标准中说到，我们可以通过promise原型上面的then方法为promise添加成功处理函数和失败处理函数，可以通过catch方法为promise添加失败处理函数。 const statusProvider = (promise, status) =&gt; data =&gt; { if (promise.status !== PENDING) return false promise.status = status promise.result = data switch(status) { case FULFILLED: return promise.successListener.forEach(fn =&gt; fn(data)) case REJECTED: return promise.failurelistener.forEach(fn =&gt; fn(data)) } } class Promise { constructor(executor) { this.status = PENDING this.successListener = [] this.failurelistener = [] this.result = undefined executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED)) } /** * Promise原型上面的方法 */ then(...args) { switch (this.status) { case PENDING: { this.successListener.push(args[0]) this.failurelistener.push(args[1]) break } case FULFILLED: { args[0](this.result) break } case REJECTED: { args[1](this.result) } } } catch(arg) { return this.then(undefined, arg) } } 我们现在的Promise基本初具雏形了。甚至可以运用到一些简单的场景中了。举个例子。 /*创建一个延时resolve的pormise*/ new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; resolve(5), 2000)}).then(data =&gt; console.log(data)) // 5 /*创建一个及时resolve的promise*/ new Promise((resolve, reject) =&gt; resolve(5)).then(data =&gt; console.log(data)) // 5 /*链式调用then方法还不能够使用！*/ new Promise(resolve=&gt; resolve(5)).then(data =&gt; data).then(data =&gt; console.log(data)) // Uncaught TypeError: Cannot read property &apos;then&apos; of undefined 第三步：Promise的链式调用Promise需要实现链式调用，我们需要再次回顾下then方法的定义： then方法为pormise添加成功和失败的处理函数，同时then方法返回一个新的promise对象，这个新的promise对象resolve处理函数的返回值，或者当没有提供处理函数时直接resolve原始的值。 可以看出，promise能够链式调用归功于then方法返回一个全新的promise，并且resolve处理函数的返回值，当然，如果then方法的处理函数本身就返回一个promise，那么久不用我们自己手动生成一个promise了。了解了这些，就开始动手写代码了。 const isPromise = object =&gt; object &amp;&amp; object.then &amp;&amp; typeof object.then === &apos;function&apos; const noop = () =&gt; {} const statusProvider = (promise, status) =&gt; data =&gt; { // 同上面代码 } class Promise { constructor(executor) { // 同上面代码 } then(...args) { const child = new this.constructor(noop) const handler = fn =&gt; data =&gt; { if (typeof fn === &apos;function&apos;) { const result = fn(data) if (isPromise(result)) { Object.assign(child, result) } else { statusProvider(child, FULFILLED)(result) } } else if(!fn) { statusProvider(child, this.status)(data) } } switch (this.status) { case PENDING: { this.successListener.push(handler(args[0])) this.failurelistener.push(handler(args[1])) break } case FULFILLED: { handler(args[0])(this.result) break } case REJECTED: { handler(args[1])(this.result) break } } return child } catch(arg) { return this.then(undefined, arg) } } 首先我们写了一个isPromise方法，用于判断一个对象是否是promise。就是判断对象是否有一个then方法，免责声明为了实现上的简单，我们不区分thenable和promise的区别，但是我们应该是知道。所有的promise都是thenable的，而并不是所有的thenable对象都是promise。（thenable对象是指带有一个then方法的对象，该then方法其实就是一个executor。）isPromise的作用就是用于判断then方法返回值是否是一个promise，如果是promise，就直接返回该promise，如果不是，就新生成一个promise并返回该promise。 由于需要链式调用，我们对successListener和failureListener中处理函数进行了重写，并不是直接push进去then方法接受的参数函数了，因为then方法需要返回一个promise，所以当then方法里面的处理函数被执行的同时，我们也需要对then方法返回的这个promise进行处理，要么resolve，要么reject掉。当然，大部分情况都是需要resolve掉的，只有当then方法没有添加第二个参数函数，同时调用then方法的promise就是rejected的时候，才需要把then方法返回的pormise进行reject处理，也就是调用statusProvider(child, REJECTED)(data). toy Promise实现的完整代码： const PENDING = &apos;PENDING&apos; // Promise 的 初始状态 const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态 const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态 const isPromise = object =&gt; object &amp;&amp; object.then &amp;&amp; typeof object.then === &apos;function&apos; const noop = () =&gt; {} const statusProvider = (promise, status) =&gt; data =&gt; { if (promise.status !== PENDING) return false promise.status = status promise.result = data switch(status) { case FULFILLED: return promise.successListener.forEach(fn =&gt; fn(data)) case REJECTED: return promise.failurelistener.forEach(fn =&gt; fn(data)) } } class Promise { constructor(executor) { this.status = PENDING this.successListener = [] this.failurelistener = [] this.result = undefined executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED)) } /** * Promise原型上面的方法 */ then(...args) { const child = new this.constructor(noop) const handler = fn =&gt; data =&gt; { if (typeof fn === &apos;function&apos;) { const result = fn(data) if (isPromise(result)) { Object.assign(child, result) } else { statusProvider(child, FULFILLED)(result) } } else if(!fn) { statusProvider(child, this.status)(data) } } switch (this.status) { case PENDING: { this.successListener.push(handler(args[0])) this.failurelistener.push(handler(args[1])) break } case FULFILLED: { handler(args[0])(this.result) break } case REJECTED: { handler(args[1])(this.result) break } } return child } catch(arg) { return this.then(undefined, arg) } } 四、怎么让我们的toy Promise变强健 在ECMAScript标准中，Promise构造函数上面还提供了一些静态方法，比如Promise.resolve、Promise.reject、Promsie.all、Promise.race。当我们有了上面的基础实现后，为我们的toy Promise添加上面这些新的功能一定能让其更加实用。 在我们的基本实现中，我们并没有区分thenable对象，其实Promise.resolve和then方法都可以接受一个thenable对象，并把该thenable对象转化为一个promise对象，如果想让我们的toy Promise用于生产的话，这也是要考虑的。 为了让我们的toy Promise变得更强壮，我们需要拥有强健的错误处理机制，比如验证executor必须是一个函数、then方法的参数只能是函数或者undefined或null，又比如executor和then方法中抛出的错误并不能够被window.onerror监测到，而只能够通过错误处理函数来处理，这也是需要考虑的因素。 如果我们的Promise polyfill是考虑支持多平台，那么首要考虑的就是浏览器环境或Node.js环境，其实在这两个平台，原生Promise都是支持两个事件的。就拿浏览器端举例： unhandledrejection: 在一个事件循环中，如果我们没有对promise返回的错误进行处理，那么就会在window对象上面触发该事件。 rejectionhandled:如果在一个事件循环后，我们才去对promise返回的错误进行处理，那么就会在window对象上面监听到此事件。 关于这两个事件以及node.js平台上面类似的事件请参考Nicholas C. Zakas新书 Promise能够很棒的处理异步编程，要想学好它我认为最好的方法就是亲自动手去实现一个自己的Promise。 完整code： /** * 2016.09.19 */ const PENDING = &apos;PENDING&apos; // Promise 的初始状态 const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态 const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态 const isThenable = data =&gt; data &amp;&amp; data.then &amp;&amp; typeof data.then === &apos;function&apos; const isPromise = object =&gt; isThenable(object) &amp;&amp; (&apos;catch&apos; in object) &amp;&amp; typeof object.catch === &apos;function&apos; const noop = () =&gt; {} const range = n =&gt; n === 0 ? [] : [n, ...range(n - 1)] // resolve function const statusProvider = (promise, status) =&gt; data =&gt; { if (promise.status !== PENDING) return false promise.status = status promise.result = data promise.listeners[status].forEach(fn =&gt; fn(data)) } class APromise { constructor(executor) { if (typeof executor !== &apos;function&apos;) { throw new TypeError(`Promise resolver ${executor.toString()} is not a function`) } this.status = PENDING this.listeners = { FULFILLED: [], REJECTED: [] } this.result = undefined try { executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED)) } catch (e) { statusProvider(this, REJECTED)(e) } } // prototype method then(...args) { const child = new this.constructor(noop) const handler = fn =&gt; data =&gt; { if (typeof fn === &apos;function&apos;) { try { const result = fn(data) if (isThenable(result)) { isPromise(result) ? Object.assign(child, result) : Object.assign(child, new this.constructor(result.then)) } else { statusProvider(child, FULFILLED)(result) } } catch (e) { statusProvider(child, REJECTED)(e) } } else if (!fn) { statusProvider(child, this.status)(data) } } switch (this.status) { case PENDING: { this.listeners[FULFILLED].push(handler(args[0])) this.listeners[REJECTED].push(handler(args[1])) break } case FULFILLED: { handler(args[0])(this.result) break } case REJECTED: { handler(args[1])(this.result) break } } return child } catch(arg) { return this.then(undefined, arg) } } APromise.resolve = data =&gt; { if (isPromise(data)) return data return isThenable(data) ? new APromise(data.then) : new APromise((resolve, reject) =&gt; resolve(data)) } APromise.reject = err =&gt; new APromise((resolve, reject) =&gt; reject(err)) APromise.all = promises =&gt; { const length = promises.length const result = new APromise(noop) let count = 0 const values = range(length) promises.forEach((p, i) =&gt; { p.then(data =&gt; { values[i] = data count++ if (count === length) statusProvider(result, FULFILLED)(values) }, statusProvider(result, REJECTED)) }) return result } APromise.race = promises =&gt; { const result = new APromise(noop) promises.forEach((p, i) =&gt; { p.then(statusProvider(result, FULFILLED), statusProvider(result, REJECTED)) }) return result } export default APromise]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v-for 循环 index的传值问题]]></title>
    <url>%2F2018%2F06%2F24%2Fv-for-%E5%BE%AA%E7%8E%AF-index%E7%9A%84%E4%BC%A0%E5%80%BC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&lt;el-submenu :index=&quot;index&quot; v-for=&quot;(item,index) in menuList&quot;&gt; &lt;el-menu-item :index=&quot;index&quot; v-for=&quot;(subItem,subindex) in item.subMenuList&quot;&gt; {{index}}-{{subItem.subMenuName}}&lt;/el-menu-item&gt; &lt;/el-submenu&gt; 发现子组件获取到的index一直都是undefined。 修改办法： &lt;el-menu-item :index=&quot;&apos;&apos;+index&quot; v-for=&quot;(subItem,subindex) in item.subMenuList&quot;&gt; {{index}}-{{subItem.subMenuName}} &lt;/el-menu-item&gt; 将 :index 的制改为’’+index，一定是单引号’’ ，子组件获取的到的就变成字符串”0,””1”….. 将字符串”0”变成整数 +”0” 即可！]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端设置了overflow:hidden和border-radius，子元素超出部分不隐藏问题？]]></title>
    <url>%2F2018%2F06%2F21%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BA%86overflow-hidden%E5%92%8Cborder-radius%EF%BC%8C%E5%AD%90%E5%85%83%E7%B4%A0%E8%B6%85%E5%87%BA%E9%83%A8%E5%88%86%E4%B8%8D%E9%9A%90%E8%97%8F%E9%97%AE%E9%A2%98%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; href=&quot;css/SB.css&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; .main { width: 300px; height: 100px; border: 1px solid red; border-radius: 15px; overflow: hidden; /*transform:rotate(0deg); */ } .con { display: block; overflow: scroll; overflow-y: hidden; -webkit-overflow-scrolling: touch; white-space: nowrap; font-size: 0px; } .item { width: 100px; height: 100px; background: green; display: inline-block; position: relative; } .item:nth-child(2n) { background: red; } .item p{ width: 50px; height: 20px; color: white; text-align: center; position: absolute; left: 50%; transform: translateX(-50%); top: 0px; background: blue; font-size: 12px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;con&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;快点&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;快点&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;快点&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;快点&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p&gt;快点&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 复制代码 PC 移动端解决办法： .main { width: 300px; height: 100px; border: 1px solid red; border-radius: 15px; overflow: hidden; transform:rotate(0deg); /*transform: scale(1);也可以*/ } 复制代码]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的事件循环]]></title>
    <url>%2F2018%2F06%2F03%2FJavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[Node.js 事件循环一: 浅析 理解事件循环系列第一步 浅析和总览 多数的网站不需要大量计算，程序花费的时间主要集中在磁盘 I/O 和网络 I/O 上面 SSD读取很快，但和CPU处理指令的速度比起来也不在一个数量级上，而且网络上一个数据包来回的时间更慢： 一个数据包来回的延迟平均320ms(我网速慢，ping国内网站会更快)，这段时间内一个普通 cpu 执行几千万个周期应该没问题 因此异步IO就要发挥作用了，比如用多线程，如果用 Java 去读一个文件，这是一个阻塞的操作，在等待数据返回的过程中什么也干不了，因此就开一个新的线程来处理文件读取，读取操作结束后再去通知主线程。 这样虽然行得通，但是代码写起来比较麻烦。像 Node.js V8 这种无法开一个线程的怎么办？ 先看下面函数执行过程 栈 Stack当我们调用一个函数，它的地址、参数、局部变量都会压入到一个 stack 中 function fire() { const result = sumSqrt(3, 4) console.log(result); } function sumSqrt(x, y) { const s1 = square(x) const s2 = square(y) const sum = s1 + s2; return Math.sqrt(sum) } function square(x) { return x * x; } fire() 下面的图都是用 keynote 做的 keynote地址 函数 fire 首先被调用 fire 调用 sumSqrt 函数 参数为3和4 之后调用 square 参数为 x, x==3 当 square 执行结束返回时，从 stack 中弹出，并将返回值赋值给 s1s1加入到 sumSqrt 的 stack frame 中 以同样的方式调用下一个 square 函数 在下一行的表达式中计算出 s1+s2 并赋值给 sum 之后调用 Math.sqrt 参数为sum 现在就剩下 sumSqrt 函数返回计算结果了 返回值赋值给 result 在 console 中打印出 result 最终 fire 没有任何返回值 从stack中弹出 stack也清空了 当函数执行完毕后本地变量会从 stack 中弹出，这只有在使用 numbers string boolean 这种基本数据类型时才会发生。而对象、数组的值是存在于 heap(堆) 中的，stack 只存放了他们对应的指针。 当函数之行结束从 stack 中弹出来时，只有对象的指针被弹出，而真正的值依然存在 heap 中，然后由垃圾回收器自动的清理回收。 事件循环通过一个例子来了解函数的执行顺序 &apos;use strict&apos; const express = require(&apos;express&apos;) const superagent = require(&apos;superagent&apos;) const app = express() app.get(&apos;/&apos;, getArticle) function getArticle(req, res) { fetchArticle(req, res) print() } const aids = [4564824, 4506868, 4767667, 4856099, 7456996]; function fetchArticle(req, res) { const aid = aids[Math.floor(Math.random() * aids.length)] superagent.get(`http://news-at.zhihu.com/api/4/news/${aid}`) .end((err, res) =&gt; { if(err) { console.log(&apos;error ......&apos;); return res.status(500).send(&apos;an error ......&apos;) } const article = res.body res.send(article) console.log(&apos;Got an article&apos;) }) console.log(&apos;Now is fetching an article&apos;) } function print(){ console.log(&apos;Print something&apos;) } app.listen(&apos;5000&apos;) 请求 http://localhost:5000/ 后打印出 Now is fetching an article Print something Got an article 虽然 V8 是单线程的，但底层的 C++ API 却不是。这意味着当我们执行一些非阻塞的操作，Node会调用一些代码，与引擎里的js代码同时执行。一旦这个隐藏的线程收到了等待的返回值或者抛出一个异常，之前提供的回调函数就会执行。 上面的说的Node调用的一些代码其实就是 libuv，一个开源的跨平台的异步 I/O 。最初就是为 Node.js 开发的，现在很多项目都在用 任务队列javascript 是单线程事件驱动的语言，那我们可以给时间添加监听器，当事件触发时，监听器就能执行回调函数。 当我们去调用 setTimeout`http.getfs.readFile`, Node.js 会把这些定时器、http、IO操作发送给另一个线程以保证V8继续执行我们的代码。 然而我们只有一个主线程和一个 call-stack ，这样当一个读取文件的操作还在执行时，有一个网络请求request过来，那这时他的回调就需要等stack变空才能执行。 回调函数正在等待轮到自己执行所排的队就被称为任务队列(或者事件队列、消息队列)。每当主线程完成前一个任务，回调函数就会在一个无限循环圈里被调用，因此这个圈被称为事件循环。 我们前面那个获取文章的例子的执行顺序就会如下： express 给 request 事件注册了一个 handler，并且当请求到达路径 ‘/‘ 时来触发handler 调过各个函数并且在端口 5000 上启动监听 stack 为空，等待 request 事件触发 根据传入的请求，事件触发，express 调用之前提供的函数 getArticle getArticle 压入(push) stack fetchArticle 被调用 同时压入 stack Math.floor 和 Math.random 被调用压入 stack 然后再 弹出(pop), 从 aids 里面取出的一个值被赋值给变量 aid superagent.get 被执行，参数为 &#39;http://news-at.zhihu.com/api/4/news/${aid}&#39; ,并且回调函数注册给了 end 事件 到 http://news-at.zhihu.com/api/4/news/${aid} 的HTTP请求被发送到后台线程，然后函数继续往下执行 &#39;Now is fetching an article&#39; 打印在 console 中。 函数 fetchArticle 返回 print 函数被调用, &#39;Print something&#39; 打印在 console 中 函数 getArticle 返回，并从 stack 中弹出， stack 为空 等待 http://news-at.zhihu.com/api/4/news/${aid} 发送相应信息 响应信息到达，end 事件被触发 注册给 end 事件的匿名回调函数被执行，这个匿名函数和他闭包中的所有变量压入 stack，这意味着这个匿名函数可以访问并修改 express, superagent, app, aids, req, res, aid 的值以及之前所有已经定义的函数 函数 res.send() 伴随着 200 或 500 的状态码被执行，但同时又被放入到后台线程中，因此 响应流 不会阻塞我们函数的执行。匿名函数也被 pop 出 stack。 Microtasks Macrotasks任务队列不止一个，还有 microtasks 和 macrotasks microtasks: process.nextTick promise Object.observe macrotasks: setTimeout setInterval setImmediate I/O 这两个的详细区别下一篇再写，先看一段代码 console.log(&apos;start&apos;) const interval = setInterval(() =&gt; { console.log(&apos;setInterval&apos;) }, 0) setTimeout(() =&gt; { console.log(&apos;setTimeout 1&apos;) Promise.resolve() .then(() =&gt; { console.log(&apos;promise 3&apos;) }) .then(() =&gt; { console.log(&apos;promise 4&apos;) }) .then(() =&gt; { setTimeout(() =&gt; { console.log(&apos;setTimeout 2&apos;) Promise.resolve() .then(() =&gt; { console.log(&apos;promise 5&apos;) }) .then(() =&gt; { console.log(&apos;promise 6&apos;) }) .then(() =&gt; { clearInterval(interval) }) }, 0) }) }, 0) Promise.resolve() .then(() =&gt; { console.log(&apos;promise 1&apos;) }) .then(() =&gt; { console.log(&apos;promise 2&apos;) }) 理解了node的事件循环还是比较容易得出答案的： start promise 1 promise 2 setInterval setTimeout 1 promise 3 promise 4 setInterval setTimeout 2 promise 5 promise 6 根据 WHATVG 的说明，在一个事件循环的周期(cycle)中一个 (macro)task 应该从 macrotask 队列开始执行。当这个 macrotask 结束后，所有的 microtasks 将在同一个 cycle 中执行。在 microtasks 执行时还可以加入更多的 microtask，然后一个一个的执行，直到 microtask 队列清空。 规范理解起来有点晦涩，来看下上面的例子 Cycle 11)setInterval 被列为 task 2)setTimeout 1 被列为 task 3)Promise.resolve 1 中两个 then 被列为 microtask 4) stack 清空 microtasks 执行 任务队列： setInterval`setTimeout 1` Cycle 25) microtasks 队列清空 setInteval 的回调可以执行。另一个 setInterval 被列为 task , 位于 setTimeout 1后面 任务队列： setTimeout 1`setInterval` Cycle 36) microtask 队列清空，setTimeout 1 的回调可以执行，promise 3 和 promise 4 被列为 microtasks 7)promise 3 和 promise 4 执行。 setTimeout 2 被列为 task 任务队列 setInterval`setTimeout 2` Cycle 48) microtask 队列清空 setInteval 的回调可以执行。然后另一个 setInterval 被列为 task ，位于 setTimeout 2 后面 任务队列： setTimeout 2`setInterval` 9)setTimeout 2 的回调执行， promise 5 和 promise 6 被列为 microtasks 现在 promise 5 和 promise 6 的回调应该执行，并且 clear 掉 interval。 但有的时候不知道为什么 setInterval 还会在执行一遍，变成下面结果 ... setTimeout 2 setInterval promise 5 promise 6 但是把上面的代码放入 chrome console 中执行却没有问题。这一点还要再根据不同的 node版本 查一下。 关于 macrotask 和 microtask用例子简单理解了下 macrotask 和 microtask 这里再详细的总结下两者的区别和使用 简介一个事件循环(EventLoop)中会有一个正在执行的任务(Task)，而这个任务就是从 macrotask 队列中来的。在whatwg规范中有 queue 就是任务队列。当这个 macrotask 执行结束后所有可用的 microtask 将会在同一个事件循环中执行，当这些 microtask 执行结束后还能继续添加 microtask 一直到真个 microtask 队列执行结束。 怎么用基本来说，当我们想以同步的方式来处理异步任务时候就用 microtask（比如我们需要直接在某段代码后就去执行某个任务，就像Promise一样）。 其他情况就直接用 macrotask。 两者的具体实现 macrotasks: setTimeout setInterval setImmediate I/O UI渲染 microtasks: Promise process.nextTick Object.observe MutationObserver 从规范中理解whatwg规范：https://html.spec.whatwg.org/multipage/webappapis.html#task-queue 一个事件循环(event loop)会有一个或多个任务队列(task queue) task queue 就是 macrotask queue 每一个 event loop 都有一个 microtask queue task queue == macrotask queue != microtask queue 一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中 当一个 task 被放入队列 queue(macro或micro) 那这个 task 就可以被立即执行了 再来回顾下事件循环如何执行一个任务的流程 当执行栈(call stack)为空的时候，开始依次执行： 把最早的任务(task A)放入任务队列 如果 task A 为null (那任务队列就是空)，直接跳到第6步 将 currently running task 设置为 task A 执行 task A (也就是执行回调函数) 将 currently running task 设置为 null 并移出 task A 执行 microtask 队列 a: 在 microtask 中选出最早的任务 task X b: 如果 task X 为null (那 microtask 队列就是空)，直接跳到 g c: 将 currently running task 设置为 task X d: 执行 task X e: 将 currently running task 设置为 null 并移出 task X f: 在 microtask 中选出最早的任务 , 跳到 b g: 结束 microtask 队列 跳到第一步 上面就算是一个简单的 event-loop 执行模型 再简单点可以总结为： 在 macrotask 队列中执行最早的那个 task ，然后移出 执行 microtask 队列中所有可用的任务，然后移出 下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步) 其他 当一个task(在 macrotask 队列中)正处于执行状态，也可能会有新的事件被注册，那就会有新的 task 被创建。比如下面两个 promiseA.then() 的回调就是一个 task promiseA 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue promiseA 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中 setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况 microtask queue 中的 task 会在事件循环的当前回合中执行，因此 macrotask queue 中的 task 就只能等到事件循环的下一个回合中执行了 click ajax setTimeout 的回调是都是 task, 同时，包裹在一个 script 标签中的js代码也是一个 task 确切说是 macrotask。 两者的具体实现 macrotasks: setTimeout ，setInterval， setImmediate， I/O ，UI渲染，requestAnimationFrame microtasks: Promise， process.nextTick， Object.observe， MutationObserver 再简单点可以总结为： 在 macrotask 队列中执行最早的那个 task ，然后移出 再执行 microtask 队列中所有可用的任务，然后移出 下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步) 这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到： JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、 MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。实在不行，只能用 setTimeout 创建 task 了。为啥要用 microtask？根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。 首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调， MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。 setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行： setTimeout(function(){ console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;); },0); 它会将回调函数加入task中，等到执行。 setTimeout(function(){console.log(4)},0); new Promise(function(resolve){ console.log(1) for( var i=0 ; i&lt;10000 ; i++ ){ i==9999 &amp;&amp; resolve() } console.log(2) }).then(function(){ console.log(5) }); console.log(3); 结果是： 1,2,3,5,4 再看这个，两个自执行同时执行： &lt;script&gt; (function test() { setTimeout(function () { console.log(4) }, 0); new Promise(function executor (resolve) { console.log(1); for(var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(2); }).then(function() { console.log(5); }); console.log(3); })() (function test2() { setTimeout(function () { console.log(42) }, 0); new Promise(function executor (resolve) { console.log(12); for(var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(22); }).then(function() { console.log(52); }); console.log(32); })() &lt;/script&gt; 整个执行过程是一个 main thread 【主线程】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的setTimeout进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。 当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候： 1.先执行 macrotasks：I/O -》 UI渲染 2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe 3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次： setTimeout ，setInterval –》setImmediate 综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 setImmediate(function(){ console.log(1); },0); setTimeout(function(){ console.log(2); },0); new Promise(function(resolve){ console.log(3); resolve(); console.log(4); }).then(function(){ console.log(5); }); console.log(6); process.nextTick(function(){ console.log(7); }); console.log(8); 结果是：3 4 6 8 7 5 2 1]]></content>
      <tags>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从你在浏览器输入一个网址....]]></title>
    <url>%2F2018%2F06%2F01%2F%E4%BB%8E%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80...%2F</url>
    <content type="text"><![CDATA[从你在浏览器输入一个网址…我们在面试的时候或许经常会被问到： 从你在浏览器输入一个网址到网页内容完全被展示的这段时间内，都发生了什么事情？ 确实是个老生常谈的问题，但问题的答案并不是唯一的，或许在三五年前，这个问题还会有一个「相对」标准的答案。 浏览器在接收到这个请求时，会开启一个单独的线程来处理这个请求，首先要判断用户输入是否为合法或合理的 URL 地址，是否为 HTTP 协议请求，如果是那就进入下一步 浏览器的浏览器引擎将对此 URL 进行分析加载 通过 DNS 解析域名获取该网站地址对应的 IP 地址，查询完成后连同浏览器的 Cookie、 userAgent 等信息向网站目的 IP 发出 GET 请求。 接下来就是经典的「三次握手」，HTTP 协议会话，浏览器客户端向 Web 服务器发送报文，进行通讯和数据传输。 进入网站的后端服务，如 Tomcat、Apache 等，还有近几年流行的 Node.js 服务器，这些服务器上部署着应用代码，语言有很多，如 Java、 PHP、 C++、 C# 和 Javascript 等。 服务器根据 URL 执行相应的后端应用逻辑，整理数据组装成一个完整的 HTML 数据返回给浏览器，期间会使用到「服务器缓存」或「数据库」内的内容。 浏览器接收到返回信息后先判读此 HTML 文件是否存在本地缓存，如果不存在或不可用，则下载此 HTML 文件（200状态码），如果可用（未过期），则走浏览器缓存（304返回码）。「强缓存（200返回码）不在考虑范围」 浏览器的渲染引擎在拿到 HTML 文件后，便开始解析构建 DOM 数，并根据 HTML 中的标记请求下载指定的 MIME 类型文件（如 CSS、 JavaScript 脚本等），同时使用&amp;设置缓存等内容。 渲染引擎根据 CSS 样式规则将 DOM 树扩充为渲染树，然后进行重排、重绘。 如果含有 JS 文件将会执行，进行 Dom 操作、缓存读存、时间绑定等操作。最终页面将被展示在浏览器上。 此答案精简的概括了「后端为主的 MVC 模式」及早期 Web 应用的浏览器相应的全过程。那，前端技术发展到现在，「前后端分离」「中间件直出」和「MNV*模式」也已问世，再谈及此问题，答案会有不同。 就以「前后端分离」为例，在上方答案的第4步后，紧接着就不会直接进入后端服务器了。而会被 HTTP 和反向代理服务器，如 Ngnix，代替。 前置步骤1、2、3、4 Ngnix 在接收到 HTTP（80端口）或 HTTPS（443端口）后，根据 URL 做服务器分发，分发（rewrite）到后端服务器或静态资源服务器，首页请求基本是静态服务器，返回一个静态的 HTML 文件 步骤7、8、9 执行 JS 脚本，异步 ajax、 fetch 发起 POST、 GET 请求，重新进入 Ngnix 分发，此次分发到后端服务器，步骤5、6，然后返回一个 xml 或 json 格式的信息，一般含有 code（返回码）、result（依赖信息） 最后根据返回码执行不同的 js 逻辑，增删改页面元素，此时可能会发生重排或重汇。首页加载结束。 以上步骤可以发现，浏览器可能会触发重绘两次，极易发生「白屏」或「页面抖动」，为了解决这个问题「中间件直出」的模式应运而生。另外为了扩充大前端的阵营，吸纳 IOS 和 Android，Google又设计了「MNV*模式」，典型代表就是 ReactNative，但此模式已经脱离了浏览器的范畴，此处就不再做扩展。 以上讨论的渲染过程中使用到了较多的浏览器功能，如用户地址栏输入框、网络请求、浏览器文档解析、渲染引擎渲染网页、 JavaScript 引擎执行js脚本、客户端存储等。 接下来我们介绍下浏览器的基本结构组成。 浏览器的结构组成浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储） 如下图： 用户界面－包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了页面显示窗口之外的其他部分 浏览器引擎－可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心 渲染引擎－解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎 网络－用来完成网络调用或资源下载的模块 UI 后端－用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的效果也不同 JS解释器－用来解释执行JS脚本的模块，如 V8 引擎 数据存储－浏览器在硬盘中保存 cookie、localStorage等各种数据，可通过浏览器引擎提供的API进行调用 作为前端开发人员，我们需要重点理解渲染引擎的工作原理，灵活应用数据存储技术，在实际项目开发中会经常涉及到这两个部分，尤其是在做项目性能优化时，理解浏览器渲染引擎尤为重要。而其他部分则是由各种浏览器自行管理的，开发者能控制的地方较少。今天我们就围绕这两个重点其中的一个部分「浏览器渲染引擎」进行展开 浏览器渲染引擎浏览器渲染引擎是由各大浏览器厂商依照 W3C 标准自行实现的，也被称之为「浏览器内核」。 目前，市面上使用的主流浏览器内核有5类：Trident、Gecko、Presto、Webkit、Blink。 Trident：俗称 IE 内核，也被叫做 MSHTML 引擎，目前在使用的浏览器为 IE11-，以及各种国产多核浏览器中的IE兼容模式。另外Edge 浏览器不再使用 MSHTML 引擎，而是使用类全新的引擎 EdgeHTML。 Gecko：俗称 Firefox 内核，Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。 Presto：Opera 前内核，为啥说是前内核呢？因为 Opera12.17 以后便拥抱了 Google Chrome 的 Blink 内核，此内核就没了寄托 Webkit：Safari 内核也是 Chrome 内核原型，主要是 Safari 浏览器在使用的内核，也是特性上表现较好的浏览器内核。也被大量使用在移动端浏览器上。 Blink： 由Google和Opera Software开发的浏览器排版引擎，在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器 中使用。Blink 其实是 WebKit 的一个分支，添加了一些优化的新特性，例如跨进程的 iframe，将 DOM 移入 JavaScript 中来提高 JavaScript 对 DOM 的访问速度等，目前较多的移动端应用内嵌的浏览器内核也渐渐开始采用 Blink。 渲染引擎的工作流程浏览器渲染引擎重要的工作就是将 HTML 和 CSS 文档解析组合最终渲染到浏览器窗口上。如下图所示，渲染引擎在接受到 HTML 文件后主要进行了以下操作：解析 HTML 构建 DOM 树 -&gt; 构建渲染树 -&gt; 渲染树布局 -&gt; 渲染树绘制。 解析 HTML 构建 DOM 树时渲染引擎会将 HTML 文件的便签元素解析成多个 DOM 元素对象节点，并且将这些对象根据父子关系组成一个树结构。同时 CSS 文件被解析成 CSS规则表，然后将每条 CSS 规则按照「从右向左」的方式在 DOM 树上进行逆向匹配，生成一个具有样式规则描述的 DOM 渲染树。接下来就是将渲染树进行布局、绘制的过程。首先根据 DOM 渲染树上的样式规则，对 DOM 元素进行大小和位置的定位，关键属性如position;width;margin;padding;top;border;...，接下来在根据元素样式规则中的color;background;shadow;...规则进行 DOM 的绘制。 另外，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 再者，需要注意的是，在浏览器渲染完首屏页面后，如果对 DOM 进行操作会引起浏览器引擎对 DOM 渲染树的重新布局和重新绘制，我们叫做「重排」和「重绘」，由于重排和重绘是前后依赖的关系，所以重绘发生时未必会触发渲染引擎的重排，但是如果发生了重排就必然会触发重绘操作，这样带来的性能损害就是巨大的。因此我们在做性能优化的时候应该遵循「避免重排；减少重绘」的原则。 不同浏览器内核间的差异在不同的浏览器内核下， 浏览器页面渲染的流程略有不同 上面两幅图分别是 Webkit 和 Geoko 内核渲染 DOM 的工作流程，对比可以看出，两者流程的区别主要在于 CSS 样式表的解析时机，Webkit 内核下，HTML 和 CSS 文件的解析是同步的，而 Geoko 内核下，CSS 文件需要等到 HTML 文件解析成内容 Sink 后才进行解析。 另外两者的不同还有描述术语，除此之外两者的流程就基本相同了，其中最重要的三个部分就是 「HTML 的解析」「CSS 的解析」「渲染树的生成」。这三个部分的原理内容就比较深，涉及到「词法分析」「语法分析」「转换」「解释」等数据结构的内容，比较枯燥，一般我们了解到这里就够了，不过想深入了解的同学可以阅读此篇译文，浏览器的工作原理，里面详细的解释了以上三个部分的流程和关系。此处就不再多做赘述了。 关于 CSS 规则的匹配上面我们提到过， CSS 规则是按照「从右向左」的方式在 DOM 树上进行逆向匹配的，最终生成一个具有样式规则描述的 DOM 渲染树。 但是你知道为什么要「从右向左」做逆向匹配码？ 我们重新回到【webkit 内核工作流程】图 CSS 规则匹配是发生在webkit引擎的「Attachment」过程中，浏览器要为每个 DOM Tree 中的元素扩充 CSS 样式规则（匹配 Style Rules）。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。 我们来举一个最简单的栗子： &lt;template&gt; &lt;div&gt; &lt;div class=&quot;t&quot;&gt; &lt;span&gt;test&lt;/span&gt; &lt;p&gt;test&lt;/p&gt; &lt;div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; div{ color: #000; } div .t span{ color: red; } div .t p{color: blue; } &lt;/style&gt; 此处我们有一个 html 元素 和一个 style 元素，两者需要做遍历匹配 此处会有 4*3 个匹配项，如果做正向匹配，在遇到 &lt;span&gt; 标签匹配 div .t p{ color: red; }到匹配项时，显然时不通过到，计算机首先要找到&lt;span&gt; 标签到父标签和祖父标签，判断他们是否满足div .t的规则，然后在匹配&lt;span&gt;是否为p标签，此处匹配不成功，此处就产生了三次浪费。 如果时逆向匹配，那么第一次对比&lt;span&gt;是否为p标签便可排除此规则，效率更高。 如果将 HTML 结构变复杂，CSS 规则表变庞大，那么，「逆向匹配」的优势就远大于「正向匹配」了，因为匹配的情况远远低于不匹配的情况。同时如果在选择器结尾加上通配符「*」，那么「逆向匹配」的优势就大打折扣，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。 极限了想，如果我们的样式表不存在嵌套关系，如下： &lt;template&gt; &lt;div&gt; &lt;div&gt; &lt;span class=&quot;div_t_span&quot;&gt;test&lt;/span&gt; &lt;p class=&quot;div_t_p&quot;&gt;test&lt;/p&gt; &lt;div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; div{ color: #000; } .div_t_span{ color: red; } .div_t_p{color: blue; } &lt;/style 那么引擎的「Attachment」过程将得到极大的精简，效率也是可想而知的，这就是为什么「微信小程序」样式表不建议使用关系行写法的原因。 相关的性能优化由以上介绍，我们大致可以在案例中看到同浏览器渲染引擎相关的可行优化点。 大致为以下几种 减少 JS 加载对 Dom 渲染的影响：将 JS 文件放在 HTML 文档后加载，或者使用异步的方式加载 JS 代码 避免重排，减少重绘：在做css动画的时候减少使用 width、 margin、 padding等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替 减少使用关系型样式表的写法：直接使用唯一的类名即可最大限度的提升渲染效率 减少 DOM 的层级：减少无意义的dom 层级可以减少 渲染引擎 Attachment 过程中的匹配计算量]]></content>
      <tags>
        <tag>url</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6 Async Functions (异步函数)]]></title>
    <url>%2F2018%2F05%2F30%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%20%20Async%20Functions%2F</url>
    <content type="text"><![CDATA[概述async(异步) 函数变体以下是已经存在的异步函数变体。请注意无处不在的 async 关键字。 异步函数声明： async function foo() {} 异步函数表达式： const foo = async function () {}; 异步函数定义：let obj = { async foo() {} } 异步箭头函数： const foo = async () =&gt; {}; async(异步) 函数总是返回 Promisesasync(异步) 函数的 Promise 完成状态： async function asyncFunc() { return 123; } asyncFunc() .then(x =&gt; console.log(x)); // 123 async(异步) 函数的 Promise 拒绝状态： async function asyncFunc() { throw new Error(&apos;Problem!&apos;); } asyncFunc() .catch(err =&gt; console.log(err)); // Error: Problem! 通过 await 处理 async(异步) 计算的结果和错误await（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise 返回： 如果 Promise 是完成状态，await 的结果是完成态的值。 如果 Promise 是拒绝状态，await 会抛出拒绝值。 处理单个 async(异步) 返回值： async function asyncFunc() { const result = await otherAsyncFunc(); console.log(result); } // 等价于: function asyncFunc() { return otherAsyncFunc() .then(result =&gt; { console.log(result); }); } 按顺序处理多个 async(异步) 返回值： async function asyncFunc() { const result1 = await otherAsyncFunc1(); console.log(result1); const result2 = await otherAsyncFunc2(); console.log(result2); } // 等价于: function asyncFunc() { return otherAsyncFunc1() .then(result1 =&gt; { console.log(result1); return otherAsyncFunc2(); }) .then(result2 =&gt; { console.log(result2); }); } 并行处理多个 async(异步) 返回值： async function asyncFunc() { const [result1, result2] = await Promise.all([ otherAsyncFunc1(), otherAsyncFunc2(), ]); console.log(result1, result2); } // 等价于: function asyncFunc() { return Promise.all([ otherAsyncFunc1(), otherAsyncFunc2(), ]) .then([result1, result2] =&gt; { console.log(result1, result2); }); } 错误处理： async function asyncFunc() { try { await otherAsyncFunc(); } catch (err) { console.error(err); } } // 等价于: function asyncFunc() { return otherAsyncFunc() .catch(err =&gt; { console.error(err); }); } 理解 async(异步) 函数在我解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。 对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 客户端 fetch API ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下： function fetchJson(url) { return fetch(url) .then(request =&gt; request.text()) .then(text =&gt; { return JSON.parse(text); }) .catch(error =&gt; { console.log(`ERROR: ${error.stack}`); }); } fetchJson(&apos;http://example.com/some_file.json&apos;) .then(obj =&gt; console.log(obj)); 通过 generator 来编写异步代码co 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同： const fetchJson = co.wrap(function* (url) { try { let request = yield fetch(url); let text = yield request.text(); return JSON.parse(text); } catch (error) { console.log(`ERROR: ${error.stack}`); } }); 每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，yield 返回完成状态的值，如果处于拒绝状态，yield 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于 then() 所做的工作）。 通过 async(异步) 函数来编写异步代码async(异步) 函数用的特定语法基本上和 co 类似： async function fetchJson(url) { try { let request = await fetch(url); let text = await request.text(); return JSON.parse(text); } catch (error) { console.log(`ERROR: ${error.stack}`); } } 在内部，异步函数写法更类似于 generators 。 以同步开始，异步处理的 async(异步) 函数以下是 async(异步)函数是如何工作的： async(异步) 函数总是返回一个 Promise 对象 p 。Promise 对象在 async(异步) 函数开始执行时被创建。 函数体执行过程中，可以通过 return 或 throw 终止执行。或者通过 await 暂停执行，在这种情况下，通常会在以后继续执行。 返回 Promise 对象 p。 当执行 async(异步) 函数的函数体时，return x 中的 x 是 Promise 对象 p 的完成状态的结果，而 throw err 是 p 的拒绝状态的结果。执行结果是异步返回的。换句话说：then() 和 catch() 的回调总是在当前代码完成后执行。 以下是代码示例： async function asyncFunc() { console.log(&apos;asyncFunc()&apos;); // (A) return &apos;abc&apos;; } asyncFunc(). then(x =&gt; console.log(`Resolved: ${x}`)); // (B) console.log(&apos;main&apos;); // (C) // Output: // asyncFunc() // main // Resolved: abc 您可以认为是以下的执行顺序： 行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 return 来返回完成状态的结果。 行C：执行继续。 行B：Promise 完成状态通知是异步发生的。 返回不被包裹的 Promise 对象Promise 的 resolve 是一项标准操作。 return 就是使用它来 resolve async(异步) 函数的 Promise p 的。这意味着： 返回一个非 Promise 值，该值将被处理成 p 的完成状态值。 返回一个 Promise 对象，那么 p 此时相当于是该 Promise 的状态。 因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中： async function asyncFunc() { return Promise.resolve(123); } asyncFunc() .then(x =&gt; console.log(x)) // 123 有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 throw ）： async function asyncFunc() { return Promise.reject(new Error(&apos;Problem!&apos;)); } asyncFunc() .catch(err =&gt; console.error(err)); // Error: Problem! 这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 await 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理： async function asyncFunc() { return anotherAsyncFunc(); } 上面的代码示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹 anotherAsyncFunc() 的 Promise ，而是包裹 anotherAsyncFunc() 本身 ）： async function asyncFunc() { return await anotherAsyncFunc(); } 使用 await 小贴士不要忘记使用 await在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 await ： async function asyncFunc() { const value = otherAsyncFunc(); // missing `await`! ··· } 在这个例子中，方法执行返回的 Promise 对象赋值给了 value ，它通常不是你在 async(异步) 函数中想要的结果。 await 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如： async function foo() { await step1(); // (A) ··· } 行A中的 await 确保在执行 foo() 剩余部分之前， step1() 已经执行完成。 不需要使用 await 的情况有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例： async function asyncFunc() { const writer = openFile(&apos;someFile.txt&apos;); writer.write(&apos;hello&apos;); // don’t wait writer.write(&apos;world&apos;); // don’t wait await writer.close(); // wait for file to close } 在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。 asyncFunc() 函数最后一行的 await 确保该函数仅在文件写入关闭后才会执行。 由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 return 替换 await writer.close() ： async function asyncFunc() { const writer = openFile(&apos;someFile.txt&apos;); writer.write(&apos;hello&apos;); writer.write(&apos;world&apos;); return writer.close(); } 这两个版本各有利弊，await 版本可能稍微更容易理解。 await 是顺序执行的，Promise.all() 是并行的下面的代码调用了两个 async(异步) 函数， asyncFunc1() 和 asyncFunc1() 。 async function foo() { const result1 = await asyncFunc1(); const result2 = await asyncFunc2(); } 这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ： async function foo() { const [result1, result2] = await Promise.all([ asyncFunc1(), asyncFunc2(), ]); } 我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。 异步函数和回调async(异步) 函数的一个限制是 await(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 await(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 map() 和 forEach()。 Array.prototype.map()我们从数组方法 map() 开始讲解。在下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。 async function downloadContent(urls) { return urls.map(url =&gt; { // 错误的语法! const content = await httpGet(url); return content; }); } 这不起作用，因为在正常箭头函数中 await 语法上是非法的(愚人码头注： await(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？ async function downloadContent(urls) { return urls.map(async (url) =&gt; { // 注意这一行中的 async ; const content = await httpGet(url); return content; }); } 这段代码有两个问题： 现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。 一旦 map() 执行完成，回调执行的工作并不能同时完成，因为 await 只暂停了包裹它的箭头函数 和 httpGet() 异步执行达到完成状态。这意味着你不能使用 await，来等待 downloadContent() 执行结束。 我们可以通过 Promise.all() 来解决这两个问题，Promise.all() 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）： async function downloadContent(urls) { const promiseArray = urls.map(async (url) =&gt; { const content = await httpGet(url); return content; }); return await Promise.all(promiseArray); } map() 的回调并不对 httpGet() 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。 async function downloadContent(urls) { const promiseArray = urls.map( url =&gt; httpGet(url)); return await Promise.all(promiseArray); } 我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 await 来解开 Promise.all() 的结果，然后通过 return 再次包裹它。 假设 return 不包裹 Promises，我们可以直接返回 Promise.all() 的结果： async function downloadContent(urls) { const promiseArray = urls.map( url =&gt; httpGet(url)); return Promise.all(promiseArray); } Array.prototype.forEach()我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容： async function logContent(urls) { urls.forEach(url =&gt; { // Wrong syntax const content = await httpGet(url); console.log(content); }); } 同样的，这里的代码会产生一个语法错误，因为你不能在通常的箭头函数内部使用 await 。 我们换作异步箭头函数： async function logContent(urls) { urls.forEach(async url =&gt; { const content = await httpGet(url); console.log(content); }); // Not finished here } 这段代码起作用了，但是会出现一个警告：httpGet() 返回的 Promise 对象是异步完成的，这也意味着当 forEach() 返回的时候回调可能还没有结束，因此你无法等到 logContent() 只能结束。 如果你并不想要这个结果，你可以将 forEach() 转换为 for-of 循环。 async function logContent(urls) { for (const url of urls) { const content = await httpGet(url); console.log(content); } } 现在一切都在 for-of 循环完成后完成。但是，处理步骤依次发生：httpGet() 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 Promise.all()： async function logContent(urls) { await Promise.all(urls.map( async url =&gt; { const content = await httpGet(url); console.log(content); })); } map() 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 await(等待) 所有方法执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 Promise.all() ，但是该函数的结果是一个数组，其元素都是未完成状态的。 使用异步函数小贴士了解你的 Promisesasync(异步) 函数的基础就是 Promises 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。 举个例子，这里有个 “promisified” 版本的 XMLHttpRequest ： function httpGet(url, responseType=&quot;&quot;) { return new Promise( function (resolve, reject) { const request = new XMLHttpRequest(); request.onload = function () { if (this.status === 200) { // Success resolve(this.response); } else { // Something went wrong (404 etc.) reject(new Error(this.statusText)); } }; request.onerror = function () { reject(new Error( &apos;XMLHttpRequest Error: &apos;+this.statusText)); }; request.open(&apos;GET&apos;, url); xhr.responseType = responseType; request.send(); }); } XMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 return 或者 throw 来完成这样的操作。你不能从回调函数内部 return 一个函数的结果。throw也有类似的约束。 因此，异步函数的通用编码风格是： 直接使用 Promise 对象来构建异步原语。 用异步函数来使用这些原语。 扩展阅读：“Exploring ES6” 中的 “异步编程中的 Promises 对象” 章节 立即调用异步函数表达式有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 main() 并立即调用它： async function main() { console.log(await asyncFunction()); } main(); 或者您可以使用立即调用异步函数表达式： (async function () { console.log(await asyncFunction()); })(); 另一个选择是立即调用异步箭头函数： (async () =&gt; { console.log(await asyncFunction()); })(); 用异步函数进行单元测试以下代码使用 测试框架 mocha 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试： import assert from &apos;assert&apos;; // Bug: the following test always succeeds test(&apos;Testing async code&apos;, function () { asyncFunc1() // (A) .then(result1 =&gt; { assert.strictEqual(result1, &apos;a&apos;); // (B) return asyncFunc2(); }) .then(result2 =&gt; { assert.strictEqual(result2, &apos;b&apos;); // (C) }); }); 然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。 你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。 return asyncFunc1() // (A) 异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试： import assert from &apos;assert&apos;; test(&apos;Testing async code&apos;, async function () { const result1 = await asyncFunc1(); assert.strictEqual(result1, &apos;a&apos;); const result2 = await asyncFunc2(); assert.strictEqual(result2, &apos;b&apos;); }); 在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。 不要担心没有处理的拒绝拒态当前的 JavaScript 引擎可以在拒绝态未处理的情况下提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告： JavaScript 代码: async function foo() { throw new Error(&apos;Problem!&apos;); } foo();]]></content>
      <tags>
        <tag>js</tag>
        <tag>promise</tag>
        <tag>异步</tag>
        <tag>Async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域，你需要知道的全在这里]]></title>
    <url>%2F2018%2F05%2F21%2F%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%A8%E5%9C%A8%E8%BF%99%E9%87%8C%2F</url>
    <content type="text"><![CDATA[最近在面试的时候常被问到如何解决跨域的问题，看了网上的一些文章后，许多文章并没有介绍清楚，经常使读者(我)感到困惑，所以今天我整理一下常用的跨域技巧，写这篇关于跨域的文章目的在于： 介绍常见的跨域的解决方案以及其优缺点 模拟实际的跨域场景，在每种方案后给出一个简单的实例，能够让读者和我一起敲代码，直观地理解这些跨域技巧 如果觉得本文有帮助，可以点 star 鼓励下，本文所有代码都可以从 github 仓库下载，读者可以按照下述打开: git clone https://github.com/happylindz/blog.git cd blog/code/crossOrigin/ yarn 建议你 clone 下来，方便你阅读代码，跟我一起测试。 同源策略使用过 Ajax 的同学都知道其便利性，可以在不向服务端提交完整页面的情况下，实现局部刷新，在当今 SPA 应用普遍使用，但是浏览器处于对安全方面的考虑，不允许跨域调用其它页面的对象，这对于我们在注入 iframe 或是 ajax 应用上带来不少麻烦。 简单来说，只有当协议，域名，端口号相同的时候才算是同一个域名，否则，均认为需要做跨域处理。 跨域方法今天一共介绍七种常用的跨域技巧，关于跨域技巧大致可以分为 iframe 跨域和 API 跨域请求。 下面就先介绍三种 API 跨域的方法: 1. JSONP：只要说到跨域，就必须聊到 JSONP，JSONP 全称为：JSON with padding，可用于解决老版本浏览器的跨域数据访问问题。 由于 web 页面上调用 js 文件不受浏览器同源策略的影响，所以通过 script 标签可以进行跨域请求： 首先前端需要先设置好回调函数，并将其作为 url 的参数。 服务端接收到请求后，通过该参数获取到回调函数名，并将数据放在参数中将其返回 收到结果后因为是 script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的 jsonp 之所以能够跨域的关键在于页面调用 JS 脚本是不受同源策略的影响，相当于向后端发起一条 http 请求，跟后端约定好函数名，后端拿到函数名，动态计算出返回结果并返回给前端执行 JS 脚本，相当于是一种 “动态 JS 脚本” 接下来我们通过一个实例来尝试： 后端逻辑： // jsonp/server.js const url = require(&apos;url&apos;); require(&apos;http&apos;).createServer((req, res) =&gt; { const data = { x: 10 }; // 拿到回调函数名 const callback = url.parse(req.url, true).query.callback; console.log(callback); res.writeHead(200); res.end(`${callback}(${JSON.stringify(data)})`); }).listen(3000, &apos;127.0.0.1&apos;); console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;); 前端逻辑： // jsonp/index.html &lt;script&gt; function jsonpCallback(data) { alert(&apos;获得 X 数据:&apos; + data.x); } &lt;/script&gt; &lt;script src=&quot;http://127.0.0.1:3000?callback=jsonpCallback&quot;&gt;&lt;/script&gt; 然后在终端开启服务： 之所以能用脚本指令，是因为我在 package.json 里面设置好了脚本命令： { // 输入 yarn jsonp 等于 &quot;node ./jsonp/server.js &amp; http-server ./jsonp&quot; &quot;scripts&quot;: { &quot;jsonp&quot;: &quot;node ./jsonp/server.js &amp; http-server ./jsonp&quot;, &quot;cors&quot;: &quot;node ./cors/server.js &amp; http-server ./cors&quot;, &quot;proxy&quot;: &quot;node ./serverProxy/server.js&quot;, &quot;hash&quot;: &quot;http-server ./hash/client/ -p 8080 &amp; http-server ./hash/server/ -p 8081&quot;, &quot;name&quot;: &quot;http-server ./name/client/ -p 8080 &amp; http-server ./name/server/ -p 8081&quot;, &quot;postMessage&quot;: &quot;http-server ./postMessage/client/ -p 8080 &amp; http-server ./postMessage/server/ -p 8081&quot;, &quot;domain&quot;: &quot;http-server ./domain/client/ -p 8080 &amp; http-server ./domain/server/ -p 8081&quot; }, // ... } yarn jsonp // 因为端口 3000 和 8080 分别属于不同域名下 // 在 localhost:3000 查看效果，即可收到后台返回的数据 10 打开浏览器访问 localhost:8080 即可看到获取到的数据。 至此，通过 JSONP 跨域获取数据已经成功了，但是通过这种方式也存在着一定的优缺点： 优点： 它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制 兼容性很好，在古老的浏览器也能很好的运行 不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。 缺点： 它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题 无法捕获 Jsonp 请求时的连接异常，只能通过超时进行处理 CORS:CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。 CORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。 前端逻辑很简单，只要正常发起 ajax 请求即可: // cors/index.html &lt;script&gt; const xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;, &apos;http://127.0.0.1:3000&apos;, true); xhr.onreadystatechange = function() { if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) { alert(xhr.responseText); } } xhr.send(null); &lt;/script&gt; 这似乎跟一次正常的异步 ajax 请求没有什么区别，关键是在服务端收到请求后的处理： // cors/server.js require(&apos;http&apos;).createServer((req, res) =&gt; { res.writeHead(200, { &apos;Access-Control-Allow-Origin&apos;: &apos;http://localhost:8080&apos;, &apos;Content-Type&apos;: &apos;text/html;charset=utf-8&apos;, }); res.end(&apos;这是你要的数据：1111&apos;); }).listen(3000, &apos;127.0.0.1&apos;); console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;); 关键是在于设置相应头中的 Access-Control-Allow-Origin，该值要与请求头中 Origin 一致才能生效，否则将跨域失败。 然后我们执行命令：yarn cors 打开浏览器访问 localhost:3000 即可看到效果： 成功的关键在于 Access-Control-Allow-Origin 是否包含请求页面的域名，如果不包含的话，浏览器将认为这是一次失败的异步请求，将会调用 xhr.onerror 中的函数。 CORS 的优缺点： 使用简单方便，更为安全 支持 POST 请求方式 CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上 这里只是对 CORS 做一个简单的介绍，如果想更详细地了解其原理的话，可以看看下面这篇文章： 跨域资源共享 CORS 详解 - 阮一峰的网络日志 3. 服务端代理：服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。 假设有这样的一个场景，你的页面需要获取 CNode：Node.js专业中文社区 论坛上一些数据，如通过 https://cnodejs.org/api/v1/topics，当时因为不同域，所以你可以将请求后端，让其对该请求代为转发。 代码如下： // serverProxy/server.js const url = require(&apos;url&apos;); const http = require(&apos;http&apos;); const https = require(&apos;https&apos;); const server = http.createServer((req, res) =&gt; { const path = url.parse(req.url).path.slice(1); if(path === &apos;topics&apos;) { https.get(&apos;https://cnodejs.org/api/v1/topics&apos;, (resp) =&gt; { let data = &quot;&quot;; resp.on(&apos;data&apos;, chunk =&gt; { data += chunk; }); resp.on(&apos;end&apos;, () =&gt; { res.writeHead(200, { &apos;Content-Type&apos;: &apos;application/json; charset=utf-8&apos; }); res.end(data); }); }) } }).listen(3000, &apos;127.0.0.1&apos;); console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;); 通过代码你可以看出，当你访问 http://127.0.0.1:3000/topics 的时候，服务器收到请求，会代你发送请求 https://cnodejs.org/api/v1/topics 最后将获取到的数据发送给浏览器。 启动服务 yarn proxy 并访问 http://localhost:3000/topics 即可看到效果： 跨域请求成功。纯粹的获取跨域获取后端数据的请求的方式已经介绍完了，另外介绍四种通过 iframe 跨域与其它页面通信的方式。 location.hash：在 url 中，http://www.baidu.com#helloworld 的 “#helloworld” 就是 location.hash，改变 hash 值不会导致页面刷新，所以可以利用 hash 值来进行数据的传递，当然数据量是有限的。 假设 localhost:8080 下有文件 index.html 要和 localhost:8081 下的 data.html 传递消息，index.html 首先创建一个隐藏的 iframe，iframe 的 src 指向 localhost:8081/data.html，这时的 hash 值就可以做参数传递。 // hash/client/index.html 对应 localhost:8080/index.html &lt;script&gt; let ifr = document.createElement(&apos;iframe&apos;); ifr.style.display = &apos;none&apos;; ifr.src = &quot;http://localhost:8081/data.html#data&quot;; document.body.appendChild(ifr); function checkHash() { try { let data = location.hash ? location.hash.substring(1) : &apos;&apos;; console.log(&apos;获得到的数据是：&apos;, data); }catch(e) { } } window.addEventListener(&apos;hashchange&apos;, function(e) { console.log(&apos;获得的数据是：&apos;, location.hash.substring(1)); }); &lt;/script&gt; data.html 收到消息后通过 parent.location.hash 值来修改 index.html 的 hash 值，从而达到数据传递。 // hash/server/data.html 对应 localhost:8081/data.html &lt;script&gt; switch(location.hash) { case &quot;#data&quot;: callback(); break; } function callback() { const data = &quot;data.html 的数据&quot; try { parent.location.hash = data; }catch(e) { // ie, chrome 下的安全机制无法修改 parent.location.hash // 所以要利用一个中间的代理 iframe var ifrproxy = document.createElement(&apos;iframe&apos;); ifrproxy.style.display = &apos;none&apos;; ifrproxy.src = &apos;http://localhost:8080/proxy.html#&apos; + data; // 该文件在 client 域名的域下 document.body.appendChild(ifrproxy); } } &lt;/script&gt; 由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于 localhost:8080 域名下的一个代理 iframe 的 proxy.html 页面 // hash/client/proxy.html 对应 localhost:8080/proxy.html &lt;script&gt; parent.parent.location.hash = self.location.hash.substring(1); &lt;/script&gt; 之后启动服务 yarn hash，即可在 localhost:8080 下观察到： 当然这种方法存在着诸多的缺点： 数据直接暴露在了 url 中 数据容量和类型都有限等等 window.name:window.name（一般在 js 代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，这里要注意的是每个 iframe 都有包裹它的 window，而这个 window 是 top window 的子窗口，而它自然也有 window.name 的属性，window.name 属性的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。 举个简单的例子： 你在某个页面的控制台输入： window.name = &quot;Hello World&quot; window.location = &quot;http://www.baidu.com&quot; 页面跳转到了百度首页，但是 window.name 却被保存了下来，还是 Hello World，跨域解决方案似乎可以呼之欲出了： 前端逻辑： // name/client/index.html 对应 localhost:8080/index.html &lt;script&gt; let data = &apos;&apos;; const ifr = document.createElement(&apos;iframe&apos;); ifr.src = &quot;http://localhost:8081/data.html&quot;; ifr.style.display = &apos;none&apos;; document.body.appendChild(ifr); ifr.onload = function() { ifr.onload = function() { data = ifr.contentWindow.name; console.log(&apos;收到数据:&apos;, data); } ifr.src = &quot;http://localhost:8080/proxy.html&quot;; } &lt;/script&gt; 数据页面： // name/server/data.html 对应 localhost:8081/data.html &lt;script&gt; window.name = &quot;data.html 的数据!&quot;; &lt;/script&gt; localhost:8080index.html 在请求数据端 localhost:8081/data.html 时，我们可以在该页面新建一个 iframe，该 iframe 的 src 指向数据端地址(利用 iframe 标签的跨域能力)，数据端文件设置好 window.name 的值。 但是由于 index.html 页面与该页面 iframe 的 src 如果不同源的话，则无法操作 iframe 里的任何东西，所以就取不到 iframe 的 name 值，所以我们需要在 data.html 加载完后重新换个 src 去指向一个同源的 html 文件，或者设置成 ‘about:blank;’ 都行，这时候我只要在 index.html 相同目录下新建一个 proxy.html 的空页面即可。如果不重新指向 src 的话直接获取的 window.name 的话会报错： 之后运行 yarn name 即可看到效果： 6.postMessagepostMessage 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能，使用起来也特别简单。 前端逻辑： // postMessage/client/index.html 对应 localhost:8080/index.html &lt;iframe src=&quot;http://localhost:8081/data.html&quot; style=&apos;display: none;&apos;&gt;&lt;/iframe&gt; &lt;script&gt; window.onload = function() { let targetOrigin = &apos;http://localhost:8081&apos;; window.frames[0].postMessage(&apos;index.html 的 data!&apos;, targetOrigin); } window.addEventListener(&apos;message&apos;, function(e) { console.log(&apos;index.html 接收到的消息:&apos;, e.data); }); &lt;/script&gt; 创建一个 iframe，使用 iframe 的一个方法 postMessage 可以想 http://localhost:8081/data.html 发送消息，然后监听 message，可以获得其文档发来的消息。 数据端逻辑： // postMessage/server/data.html 对应 localhost:8081/data.html &lt;script&gt; window.addEventListener(&apos;message&apos;, function(e) { if(e.source != window.parent) { return; } let data = e.data; console.log(&apos;data.html 接收到的消息:&apos;, data); parent.postMessage(&apos;data.html 的 data!&apos;, e.origin); }); &lt;/script&gt; 启动服务：yarn postMessage 并打开浏览器访问： 对 postMessage 感兴趣的详细内容可以看看教程： PostMessage_百度百科Window.postMessage() 7.document.domain对于主域相同而子域不同的情况下，可以通过设置 document.domain 的办法来解决，具体做法是可以在 http://www.example.com/index.html 和 http://sub.example.com/data.html 两个文件分别加上 document.domain = &quot;example.com&quot; 然后通过 index.html 文件创建一个 iframe，去控制 iframe 的 window，从而进行交互，当然这种方法只能解决主域相同而二级域名不同的情况，如果你异想天开的把 script.example.com 的 domain 设为 qq.com 显然是没用的，那么如何测试呢？ 测试的方式稍微复杂点，需要安装 nginx 做域名映射，如果你电脑没有安装 nginx，请先去安装一下: nginx 前端逻辑： // domain/client/index.html 对应 sub1.example.com/index.html &lt;script&gt; document.domain = &apos;example.com&apos;; let ifr = document.createElement(&apos;iframe&apos;); ifr.src = &apos;http://sub2.example.com/data.html&apos;; ifr.style.display = &apos;none&apos;; document.body.append(ifr); ifr.onload = function() { let win = ifr.contentWindow; alert(win.data); } &lt;/script&gt; 数据端逻辑： // domain/server/data 对应 sub2.example.com/data.html &lt;script&gt; document.domain = &apos;example.com&apos;; window.data = &apos;data.html 的数据！&apos;; &lt;/script&gt; 打开操作系统下的 hosts 文件：mac 是位于 /etc/hosts 文件，并添加： 127.0.0.1 sub1.example.com 127.0.0.1 sub2.example.com 之后打开 nginx 的配置文件：/usr/local/etc/nginx/nginx.conf，并在 http 模块里添加，记得输入 nginx 启动 nginx 服务： /usr/local/etc/nginx/nginx.conf http { // ... server { listen 80; server_name sub1.example.com; location / { proxy_pass http://127.0.0.1:8080/; } } server { listen 80; server_name sub2.example.com; location / { proxy_pass http://127.0.0.1:8081/; } } // ... } 相当于是讲 sub1.example.com 和 sub2.example.com 这些域名地址指向本地 127.0.0.1:80，然后用 nginx 做反向代理分别映射到 8080 和 8081 端口。 这样访问 sub1(2).example.com 等于访问 127.0.0.1:8080(1) 启动服务 yarn domain 访问浏览器即可看到效果： 总结：前面七种跨域方式我已经全部讲完，其实讲道理，常用的也就是前三种方式，后面四种更多时候是一些小技巧，虽然在工作中不一定会用到，但是如果你在面试过程中能够提到这些跨域的技巧，无疑在面试官的心中是一个加分项。 上面阐述方法的时候可能有些讲的不明白，希望在阅读的过程中建议你跟着我敲代码，当你打开浏览器看到结果的时候，你也就能掌握到这种方法。]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(for..in)、Object.keys()和Object.getOwnPropertyNames(),for...of]]></title>
    <url>%2F2018%2F05%2F19%2Ffor-in-%E3%80%81Object-keys-%E5%92%8CObject-getOwnPropertyNames-for-of%2F</url>
    <content type="text"><![CDATA[Object.keys（obj），返回一个数组，数组里是该obj可被枚举的所有属性。请看示例： 示例一： function Pasta(grain, width, shape) { this.grain = grain; this.width = width; this.shape = shape; this.toString = function () { return (this.grain + &quot;, &quot; + this.width + &quot;, &quot; + this.shape); } } console.log(Object.keys(Pasta)); //console: [] var spaghetti = new Pasta(&quot;wheat&quot;, 0.2, &quot;circle&quot;); console.log(Object.keys(spaghetti)); //console: [&quot;grain&quot;, &quot;width&quot;, &quot;shape&quot;, &quot;toString&quot;] 示例二： var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; console.log(Object.keys(arr)); // console: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] var obj = { 0 : &quot;a&quot;, 1 : &quot;b&quot;, 2 : &quot;c&quot;}; console.log(Object.keys(obj)); // console: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;] var an_obj = { 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot;}; console.log(Object.keys(an_obj)); // console: [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;] var my_obj = Object.create({}, { getFoo : { value : function () { return this.foo } } }); my_obj.foo = 1; console.log(Object.keys(my_obj)); // console: [&quot;foo&quot;] js中几种遍历对象的方法，包括for in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。 for in 主要用于遍历对象的可枚举属性，包括自有属性、继承自原型的属性 var obj = {&quot;name&quot;:&quot;Poly&quot;, &quot;career&quot;:&quot;it&quot;} Object.defineProperty(obj, &quot;age&quot;, {value:&quot;forever 18&quot;, enumerable:false}); Object.prototype.protoPer1 = function(){console.log(&quot;proto&quot;);}; Object.prototype.protoPer2 = 2; console.log(&quot;For In : &quot;); for(var a in obj) console.log(a); Object.keys 返回一个数组，元素均为对象自有的可枚举属性 var obj = {&quot;name&quot;:&quot;Poly&quot;, &quot;career&quot;:&quot;it&quot;} Object.defineProperty(obj, &quot;age&quot;, {value:&quot;forever 18&quot;, enumerable:false}); Object.prototype.protoPer1 = function(){console.log(&quot;proto&quot;);}; Object.prototype.protoPer2 = 2; console.log(&quot;Object.keys:&quot;) console.log(Object.keys(obj)); Object.getOwnProperty 用于返回对象的自有属性，包括可枚举和不可枚举的 var obj = {&quot;name&quot;:&quot;Poly&quot;, &quot;career&quot;:&quot;it&quot;} Object.defineProperty(obj, &quot;age&quot;, {value:&quot;forever 18&quot;, enumerable:false}); Object.prototype.protoPer1 = function(){console.log(&quot;proto&quot;);}; Object.prototype.protoPer2 = 2; console.log(&quot;Object.getOwnPropertyNames: &quot;); console.log(Object.getOwnPropertyNames(obj)); for..of var obj = {&quot;name&quot;:&quot;Poly&quot;, &quot;career&quot;:&quot;it&quot;} Object.defineProperty(obj, &quot;age&quot;, {value:&quot;forever 18&quot;, enumerable:false}); Object.prototype.protoPer1 = function(){console.log(&quot;proto&quot;);}; Object.prototype.protoPer2 = 2; console.log(&quot;For of : &quot;); for(var a of Object.entries(obj)) console.log(a);]]></content>
      <tags>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS等比例缩放的盒子]]></title>
    <url>%2F2018%2F05%2F19%2FCSS%E7%AD%89%E6%AF%94%E4%BE%8B%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9B%92%E5%AD%90%2F</url>
    <content type="text"><![CDATA[你肯定已经知道，对于一个 img 元素而言，你可以单独地修改它的 width 或者 height 属性来设置它的大小，同时图片的比例还能够保持不变。 如下图所示，最上面是原始大小的图片，下面两张则分别是设置了 width: 50% 和 height: 50% 属性后的样子。 可以看到把宽度设置为了原来的一半的同时，图片的高度并不是保持原来的大小，而是相应的也变成了原来的一半，使得图片仍能够保持原有的比例。同理把高度设成原来的一半也如此。 作为对照，我们看看单独修改其他元素的宽和高会产生什么样的效果： 上图最左边的蓝色矩形是原始的 div 元素，之后两个分别是对其设置了 width: 50% 和 height: 50% 属性后的样子。可见与 img 元素不同，单独设置 div 元素的宽度（高度）时，对应的高度（宽度）并不会改变，从而导致元素的比例发生变化。这一结果相信每个稍微对前端有些了解的同学都能猜到。但是究竟是什么导致了同样的属性用于 img 和 div 后会产生不同的结果呢？ img 在元素分类中属于 replaced （被替换的）元素。replaced 元素表示这个元素内容的显示不是由 CSS 控制的。换句话说，对于 img 元素而言，图片的内容并不是由 CSS 定义的，而是通过其 src 属性指向的资源决定的。很多 replaced 元素来都会有自己的固有尺寸（Intrinsic dimension），img 也不例外1。当 img 的高度改变后，浏览器会计算出其缩放比例，而当元素的宽度是 auto（即默认值）时，浏览器则以原始宽度 * 缩放比例来作为元素的新宽度。从而使得 img 元素的比例始终保持一致。 然而这都并不是这篇文章讨论的重点。（那位同学请不要说脏话，不文明 重点是什么？重点就是题目：实现等比例缩放的盒子。 在响应式设计逐渐成为主流的今天，流式布局这个词即使放在一两年前也绝算不得是个新鲜词汇。下面是一个布局实例： 上图中每个蓝色的矩形分别对应一个 div 元素，每个元素的宽度占窗口宽度的四分之一（图示中为了演示方便给每个元素加了边距效果）。如果不做额外处理，当窗口宽度变小时上图的页面会变为如下所示： 可见每个元素的宽度进行了缩放，但高度并没有变化，看起来并不是很协调。所以有些场景下我们需要实现当窗口宽度缩放时，使得元素宽度自适应的同时，保证每个元素的宽高比例不变。 很多同学在我话还没讲完时，就已经纷纷掏出 JavaScript 大锤着手实现了起来。然而这个系列文章的标题是《你不知道的 CSS》，自然不会介绍 CSS 实现不了这种打自己脸的需求，而且就此例而言，使用 JavaScript 实现效果并不好，绑定 onresize 事件后在拖拽时某些星座的朋友会察觉出来些许卡顿（你试试便知），而且在 JavaScript 加载完成前是看不出效果的。 其实用 CSS 可以很容易地实现这样的效果，用的属性也是我们每个工作日和周末（如果加班的话）都会用到的：padding-bottom。padding-bottom 有一个让人很容易忽略的特性是当它的值是百分比形式时，百分比的基数是其所在元素的父元素的宽度而不是高度（同 padding-left 和 padding-right 一样）。这样解决方案也就非常明显了： 将元素的 height 设成 0，使得元素的高度等于 padding-bottom； 合理设置 padding-bottom 的值。比如每个元素的 width 是 25%，现在想让元素的高度始终保持为其宽度的两倍，则 padding-bottom 的值应该设置为 50%。 结果如下图所示： 相应的代码可以参见：http://jsfiddle.net/luin/25BbH/7/。 然而至此，这篇文章还没完。肯定会有很多同学疑惑既然 height 被设成了 0，那么如果元素的 overflow 为 hidden，里面的文字会不会因为超出了元素高度而被隐藏呢？ 答案是不会。根据 CSS 2.1 规范2，overflow 只会对处于 padding edge 外面的内容生效，即只有超出了 padding 区域的内容才会被 overflow 属性隐藏掉。 其实有一点例外的情况是当 img 的图片是 svg 时，它是没有固有尺寸的。 ↩ http://www.w3.org/TR/CSS2/visufx.html↩ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .item { float: left; width: 21%; margin: 10px 2%; height: 0; padding-bottom: 33.98%; background-color: #dbe0e4; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探索webpack 机制]]></title>
    <url>%2F2018%2F05%2F18%2F%E6%8E%A2%E7%B4%A2webpack-%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[本文从简单的例子入手，从打包文件去分析以下三个问题：webpack打包文件是怎样的？如何做到兼容各大模块化方案的？webpack3带来的新特性又是什么？ 一个简单的例子webpack配置 // webpack.config.js module.exports = { entry: &apos;./src/index.js&apos;, output: { filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) }, }; 简单的js文件 // src/index.js console.log(&apos;hello world&apos;); webpack打包后的代码 // dist/bundle.js /******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if(installedModules[moduleId]) { /******/ return installedModules[moduleId].exports; /******/ } /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ i: moduleId, /******/ l: false, /******/ exports: {} /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.l = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // define getter function for harmony exports /******/ __webpack_require__.d = function(exports, name, getter) { /******/ if(!__webpack_require__.o(exports, name)) { /******/ Object.defineProperty(exports, name, { /******/ configurable: false, /******/ enumerable: true, /******/ get: getter /******/ }); /******/ } /******/ }; /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules /******/ __webpack_require__.n = function(module) { /******/ var getter = module &amp;&amp; module.__esModule ? /******/ function getDefault() { return module[&apos;default&apos;]; } : /******/ function getModuleExports() { return module; }; /******/ __webpack_require__.d(getter, &apos;a&apos;, getter); /******/ return getter; /******/ }; /******/ /******/ // Object.prototype.hasOwnProperty.call /******/ __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = &quot;&quot;; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(__webpack_require__.s = 0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports) { console.log(&apos;hello world&apos;); /***/ }) /******/ ]); 一看你就会想，我就一行代码，你给我打包那么多？？？（黑人问号） 我们来分析一下这部分代码，先精简一下，其实整体就是一个自执行函数，然后传入一个模块数组 (function(modules) { //... })([function(module, exports) { //.. }]) 好了，传入模块数组做了什么(其实注释都很明显了，我只是大概翻译一下） /******/ (function(modules) { // webpackBootstrap /******/ // The module cache 缓存已经load过的模块 /******/ var installedModules = {}; /******/ /******/ // The require function 引用的函数 /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache 假如在缓存里就直接返回 /******/ if(installedModules[moduleId]) { /******/ return installedModules[moduleId].exports; /******/ } /******/ // Create a new module (and put it into the cache) 构造一个模块并放入缓存 /******/ var module = installedModules[moduleId] = { /******/ i: moduleId, //模块id /******/ l: false, // 是否已经加载完毕 /******/ exports: {} // 对外暴露的内容 /******/ }; /******/ /******/ // Execute the module function 传入模块参数，并执行模块 /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded 标记模块已经加载完毕 /******/ module.l = true; /******/ /******/ // Return the exports of the module 返回模块暴露的内容 /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) 暴露模块数组 /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache 暴露缓存数组 /******/ __webpack_require__.c = installedModules; /******/ /******/ // define getter function for harmony exports 为ES6 exports定义getter /******/ __webpack_require__.d = function(exports, name, getter) { /******/ if(!__webpack_require__.o(exports, name)) { // 假如exports本身不含有name这个属性 /******/ Object.defineProperty(exports, name, { /******/ configurable: false, /******/ enumerable: true, /******/ get: getter /******/ }); /******/ } /******/ }; /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules 解决ES module和Common js module的冲突，ES则返回module[&apos;default&apos;] /******/ __webpack_require__.n = function(module) { /******/ var getter = module &amp;&amp; module.__esModule ? /******/ function getDefault() { return module[&apos;default&apos;]; } : /******/ function getModuleExports() { return module; }; /******/ __webpack_require__.d(getter, &apos;a&apos;, getter); /******/ return getter; /******/ }; /******/ /******/ // Object.prototype.hasOwnProperty.call /******/ __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); }; /******/ /******/ // __webpack_public_path__ webpack配置下的公共路径 /******/ __webpack_require__.p = &quot;&quot;; /******/ /******/ // Load entry module and return exports 最后执行entry模块并且返回它的暴露内容 /******/ return __webpack_require__(__webpack_require__.s = 0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports) { console.log(&apos;hello world&apos;); /***/ }) /******/ ]); 整体流程是怎样的呢 传入module数组 调用webpack_require(webpack_require.s = 0) 构造module对象，放入缓存 调用module,传入相应参数modules[moduleId].call(module.exports, module, module.exports, webpack_require); （这里exports会被函数内部的东西修改） 标记module对象已经加载完毕 返回模块暴露的内容（注意到上面函数传入了module.exports,可以对引用进行修改） 模块函数中传入module, module.exports, webpack_require 执行过程中通过对上面三者的引用修改，完成变量暴露和引用 webpack模块机制是怎样的我们可以去官网看下webpack模块 https://doc.webpack-china.org/concepts/modules#-webpack-webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下： ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句。 样式(url(…))或 HTML 文件()中的图片链接(image url) 强大的webpack模块可以兼容各种模块化方案，并且无侵入性(non-opinionated) 我们可以再编写例子一探究竟 CommonJS修改src/index.js var cj = require(&apos;./cj.js&apos;); console.log(&apos;hello world&apos;); cj(); 新增src/cj.js，保持前面例子其他不变 // src/cj.js function a() { console.log(&quot;CommonJS&quot;); } module.exports = a; 再次运行webpack /******/ (function(modules) { // webpackBootstrap //... 省略代码 /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { let cj = __webpack_require__(1); console.log(&apos;hello world&apos;); cj(); /***/ }), /* 1 */ /***/ (function(module, exports) { function a() { console.log(&quot;CommonJS&quot;); } module.exports = a; /***/ }) /******/ ]); 我们可以看到模块数组多了个引入的文件，然后index.js模块函数多了个参数webpack_require，去引用文件（webpack_require在上一节有介绍），整体上就是依赖的模块修改了module.exports，然后主模块执行依赖模块，获取exports即可 ES2015 import新增src/es.js // src/es.js export default function b() { console.log(&apos;ES Modules&apos;); } 修改src/index.js // src/index.js import es from &apos;./es.js&apos;; console.log(&apos;hello world&apos;); es(); webpack.config.js不变，执行webpack /******/ (function(modules) { // webpackBootstrap // ... 省略代码 /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot;; Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true }); /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__es_js__ = __webpack_require__(1); console.log(&apos;hello world&apos;); Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;a&quot; /* default */])(); /***/ }), /* 1 */ /***/ (function(module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot;; /* harmony export (immutable) */ __webpack_exports__[&quot;a&quot;] = b; function b() { console.log(&apos;ES Modules&apos;); } /***/ }) /******/ ]); 我们可以看到它们都变成了严格模式，webpack自动采用的 表现其实跟CommonJS相似，也是传入export然后修改，在主模块再require进来， 我们可以看到这个 Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true }); 这个干嘛用的？其实就是标记当前的exports是es模块，还记得之前的webpack_require.n吗，我们再拿出来看看 /******/ // getDefaultExport function for compatibility with non-harmony modules 解决ES module和Common js module的冲突，ES则返回module[&apos;default&apos;] /******/ __webpack_require__.n = function(module) { /******/ var getter = module &amp;&amp; module.__esModule ? /******/ function getDefault() { return module[&apos;default&apos;]; } : /******/ function getModuleExports() { return module; }; /******/ __webpack_require__.d(getter, &apos;a&apos;, getter); /******/ return getter; /******/ }; 为了避免跟非ES Modules冲突？冲突在哪里呢？其实这部分如果你看到babel转换ES Modules源码就知道了，为了兼容模块，会把ES Modules直接挂在exports.default上，然后加上__esModule属性，引入的时候判断一次是否是转换模块，是则引入module[‘default’]，不是则引入module 我们再多引入几个ES Modules看看效果 // src/es.js export function es() { console.log(&apos;ES Modules&apos;); } export function esTwo() { console.log(&apos;ES Modules Two&apos;); } export function esThree() { console.log(&apos;ES Modules Three&apos;); } export function esFour() { console.log(&apos;ES Modules Four&apos;); } 我们多引入esTwo和esFour，但是不使用esFour // src/index.js import { es, esTwo, esFour} from &apos;./es.js&apos;; console.log(&apos;hello world&apos;); es(); esTwo(); 得出 /******/ (function(modules) { // webpackBootstrap // ... /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot;; Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true }); /* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__es_js__ = __webpack_require__(1); console.log(&apos;hello world&apos;); Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;a&quot; /* es */])(); Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;b&quot; /* esTwo */])(); /***/ }), /* 1 */ /***/ (function(module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot;; /* harmony export (immutable) */ __webpack_exports__[&quot;a&quot;] = es; /* harmony export (immutable) */ __webpack_exports__[&quot;b&quot;] = esTwo; /* unused harmony export esThree */ /* unused harmony export esFour */ function es() { console.log(&apos;ES Modules&apos;); } function esTwo() { console.log(&apos;ES Modules Two&apos;); } function esThree() { console.log(&apos;ES Modules Three&apos;); } function esFour() { console.log(&apos;ES Modules Four&apos;); } /***/ }) /******/ ]); 嗯嗯其实跟前面是一样的，举出这个例子重点在哪里呢，有没有注意到注释中 /* unused harmony export esThree */ /* unused harmony export esFour */ esThree是我们没有引入的模块，esFour是我们引用但是没有使用的模块，webpack均对它们做了unused的标记，其实这个如果你使用了webpack插件uglify，通过标记，就会把esThree和esFour这两个未使用的代码消除（其实它就是tree-shaking) AMD我们再来看看webpack怎么支持AMD 新增src/amd.js // src/amd.js define([ ],function(){ return { amd:function(){ console.log(&apos;AMD&apos;); } }; }); 修改index.js // src/index.js define([ &apos;./amd.js&apos; ],function(amdModule){ amdModule.amd(); }); 得到 /******/ (function(modules) { // webpackBootstrap // ... 省略代码 /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_RESULT__ = function(amdModule){ amdModule.amd(); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); /***/ }), /* 1 */ /***/ (function(module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ ], __WEBPACK_AMD_DEFINE_RESULT__ = function(){ return { amd:function(){ console.log(&apos;AMD&apos;); } }; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); /***/ }) /******/ ]); 先看amd.js整理一下代码 function(module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; !( __WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return { amd: function() { console.log(&apos;AMD&apos;); } }; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__) ); }) 简单来讲收集define Array然后置入返回函数，根据参数获取依赖 apply对数组拆解成一个一个参数 再看index.js模块部分 function(module, exports, __webpack_require__) { var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; !( __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(amdModule) { amdModule.amd(); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__) ); } 其实就是引入了amd.js暴露的{amd:[Function: amd]} css/image?css和image也可以成为webpack的模块，这是令人震惊的，这就不能通过普通的hack commonjs或者函数调用简单去调用了，这就是anything to JS，它就需要借助webpack loader去实现了 像css就是转换成一段js代码，通过处理，调用时就是可以用js将这段css插入到style中，image也类似，这部分就不详细阐述了，有兴趣的读者可以深入去研究 webpack3新特性我们可以再顺便看下webpack3新特性的表现具体可以看这里https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b Scope Hoisting我们可以发现模块数组是一个一个独立的函数然后闭包引用webpack主函数的相应内容，每个模块都是独立的，然后带来的结果是在浏览器中执行速度变慢，然后webpack3学习了Closure Compiler和RollupJS这两个工具，连接所有闭包到一个闭包里，放入一个函数，让执行速度更快,并且整体代码体积也会有所缩小 我们可以实际看一下效果（要注意的是这个特性只支持ES Modules,是不支持CommonJs和AMD的）使用上面的例子，配置webpack.config.js，增加new webpack.optimize.ModuleConcatenationPlugin() const path = require(&apos;path&apos;); const webpack = require(&apos;webpack&apos;); module.exports = { entry: &apos;./src/index.js&apos;, output: { filename: &apos;bundle.js&apos;, path: path.resolve(__dirname, &apos;dist&apos;) }, module: { }, plugins: [ new webpack.optimize.ModuleConcatenationPlugin(), ] }; 打包 /******/ (function(modules) { // webpackBootstrap // ... 省略代码 /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ (function(module, __webpack_exports__, __webpack_require__) { &quot;use strict&quot;; Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true }); // CONCATENATED MODULE: ./src/es.js function es() { console.log(&apos;ES Modules&apos;); } function esTwo() { console.log(&apos;ES Modules Two&apos;); } function esThree() { console.log(&apos;ES Modules Three&apos;); } function esFour() { console.log(&apos;ES Modules Four&apos;); } // CONCATENATED MODULE: ./src/index.js // src/index.js console.log(&apos;hello world&apos;); es(); /***/ }) /******/ ]); 我们可以惊喜的发现没有什么require了，它们拼接成了一个函数，good!? Magic Commentscode splitting是webpack一个重点特性之一，涉及到要动态引入的时候，webpack可以使用 require.ensure去实现，后来webpack2支持使用了符合 ECMAScript 提案 的 import() 语法，但是它有个不足之处，无法指定chunk的名称chunkName,为了解决这个问题，出现了Magic Comments，支持用注释的方式去指定，如下 import(/* webpackChunkName: &quot;my-chunk-name&quot; */ &apos;module&apos;); 小结webpack是一个强大的模块打包工具，在处理依赖、模块上都很优秀，本文从bundle.js文件分析出发去探索了不同模块方案的加载机制，初步去理解webpack，并且对webpack3特性进行阐述，当然，webpack还有很多地方需要去探索深究，敬请期待以后的文章吧～]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue源码必知必会]]></title>
    <url>%2F2018%2F05%2F02%2FVue%E6%BA%90%E7%A0%81%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[介绍Vue.js源码分析，记录了个人学习Vue.js源码的过程中的一些心得以及收获。以及对于Vue框架，周边库的一些学习心得和个人见解。 在学习的过程中我分别为Vue.js、Vuex、Vue-router加上了注释，分别在文件夹vue-src、vuex-src以及vue-router-src中，希望可以帮助有需要的同学更好地学习理解Vue.js及周边库的源码。 感谢尤大提高生产力。 当前Vue.js源码版本2.3.0，Vuex版本为2.4.0，Vue-router版本为3.0.1。 本项目希望对Vue.js做更进一步的探索与学习，Vue.js基础内容请参考Vue.js官网，https://cn.vuejs.org/v2/guide/。 可能会有理解存在偏差的地方，欢迎提issue指出，共同学习，共同进步。 目录源码相关Vue.js响应式原理 Vue.js依赖收集 从Vue.js源码角度再看数据绑定 Vue.js事件机制 VNode节点(Vue.js实现) Virtual DOM与diff(Vue.js实现) 聊聊Vue.js的template编译 Vue.js异步更新DOM策略及nextTick 从template到DOM（Vue.js源码角度看内部运行机制） Vuex源码解析 随笔杂谈Vue组件间通信 说说element组件库broadcast与dispatch 该源码分析，会带着大家一起学习Vue的大部分代码，而不是简单的讲一下它的原理，我会尽可能的多解释每一行主要的代码含义，另外一些辅助方法什么的，大家可以在学习的过程中，自己看一眼就知道了。 Vue源码目录结构整理 从入口文件查看Vue源码 从小栗子查看Vue的生命周期 双向数据绑定 compile概述 compile——生成ast compile——优化静态内容 compile——生成render字符串 vdom概述 Vue.extend vdom——VNode children的归一化处理 patch——创建dom patch——diff patch——自定义组件的处理流程 事件处理 指令的处理 directives概述 自定义指令 v-for v-if v-once v-show v-text、v-html、v-cloak、v-pre v-model 内置组件和标签 slot和作用域插槽 keep-alive 以下是整理一些比较零散的数据，主要是记录结构中每个数据表示什么意思，会不断完善更新： Vue全局属性 Vue实例属性 AstElement VNode]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20个 CSS高级技巧汇总]]></title>
    <url>%2F2018%2F05%2F02%2F20%E4%B8%AACSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[使用技巧会让人变的越来越懒，没错，我就是想让你变懒。下面是我收集的CSS高级技巧，希望你懒出境界。 1. 黑白图像这段代码会让你的彩色照片显示为黑白照片，是不是很酷？ img.desaturate { filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -ms-filter: grayscale(100%); -o-filter: grayscale(100%); } 2. 使用 :not() 在菜单上应用/取消应用边框先给每一个菜单项添加边框 /* add border */ .nav li { border-right: 1px solid #666; } 然后再除去最后一个元素 // remove border / .nav li:last-child { border-right: none; } 可以直接使用 :not() 伪类来应用元素： .nav li:not(:last-child) { border-right: 1px solid #666; } 这样代码就干净，易读，易于理解了。 当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）： .nav li:first-child ~ li { border-left: 1px solid #666; } 3. 页面顶部阴影下面这个简单的 CSS3 代码片段可以给网页加上漂亮的顶部阴影效果： body:before { content: &quot;&quot;; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100; } 4. 给 body 添加行高你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可： body { line-height: 1; } 这样文本元素就可以很容易地从 body 继承。 5. 所有一切都垂直居中要将所有元素垂直居中，太简单了： html, body { height: 100%; margin: 0; } body { -webkit-align-items: center; -ms-flex-align: center; align-items: center; display: -webkit-flex; display: flex; } 看，是不是很简单。 注意：在IE11中要小心flexbox 6. 逗号分隔的列表让HTML列表项看上去像一个真正的，用逗号分隔的列表： ul &gt; li:not(:last-child)::after { content: &quot;,&quot;; } 对最后一个列表项使用 :not() 伪类。 7. 使用负的 nth-child 选择项目在CSS中使用负的 nth-child 选择项目1到项目n。 li { display: none; } /* select items 1 through 3 and display them */ li:nth-child(-n+3) { display: block; } 8. 对图标使用 SVG我们没有理由不对图标使用SVG： .logo { background: url(&quot;logo.svg&quot;); } SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。 9. 优化显示文本有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你： html { -moz-osx-font-smoothing: grayscale; -webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility; } 注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。 10. 对纯 CSS 滑块使用 max-height使用 max-height 和溢出隐藏来实现只有CSS的滑块： .slider ul { max-height: 0; overlow: hidden; } .slider:hover ul { max-height: 1000px; transition: .3s ease; } 11. 继承 box-sizing让 box-sizing 继承 html： html { box-sizing: border-box; } *, *:before, *:after { box-sizing: inherit; } 这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。 12. 表格单元格等宽表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽： .calendar { table-layout: fixed; } 13. 用 Flexbox 摆脱外边距的各种 hack当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了： .list { display: flex; justify-content: space-between; } .list .person { flex-basis: 23%; } 现在，列表分隔符就会在均匀间隔的位置出现。 14. 使用属性选择器用于空链接当a元素没有文本值，但 href 属性有链接的时候显示链接： a[href^=&quot;http&quot;]:empty::before { content: attr(href); } 相当方便。 15. 检测鼠标双击HTML： &lt;div class=&quot;test3&quot;&gt; &lt;span&gt;&lt;input type=&quot;text&quot; value=&quot; &quot; readonly=&quot;true&quot; /&gt; &lt;a href=&quot;http://renpingjun.com&quot;&gt;Double click me&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; CSS： .test3 span { position: relative; } .test3 span a { position: relative; z-index: 2; } .test3 span a:hover, .test3 span a:active { z-index: 4; } .test3 span input { background: transparent; border: 0; cursor: pointer; position: absolute; top: -1px; left: 0; width: 101%; /* Hacky */ height: 301%; /* Hacky */ z-index: 3; } .test3 span input:focus { background: transparent; border: 0; z-index: 1; } 16. CSS 写出三角形/* create an arrow that points up */ div.arrow-up { width:0px; height:0px; border-left:5px solid transparent; /* left arrow slant */ border-right:5px solid transparent; /* right arrow slant */ border-bottom:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px; } /* create an arrow that points down */ div.arrow-down { width:0px; height:0px; border-left:5px solid transparent; border-right:5px solid transparent; border-top:5px solid #2f2f2f; font-size:0px; line-height:0px; } /* create an arrow that points left */ div.arrow-left { width:0px; height:0px; border-bottom:5px solid transparent; /* left arrow slant */ border-top:5px solid transparent; /* right arrow slant */ border-right:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px; } /* create an arrow that points right */ div.arrow-right { width:0px; height:0px; border-bottom:5px solid transparent; /* left arrow slant */ border-top:5px solid transparent; /* right arrow slant */ border-left:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px; } 17. CSS3 calc() 的使用calc() 用法类似于函数，能够给元素设置动态的值： /* basic calc */ .simpleBlock { width: calc(100% - 100px); } /* calc in calc */ .complexBlock { width: calc(100% - 50% / 3); padding: 5px calc(3% - 2px); margin-left: calc(10% + 10px); } 18. 文本渐变文本渐变效果很流行，使用 CSS3 能够很简单就实现： h2[data-text] { position: relative; } h2[data-text]::after { content: attr(data-text); z-index: 10; color: #e3e3e3; position: absolute; top: 0; left: 0; -webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));} 19. 禁用鼠标事件CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。 .disabled { pointer-events: none; } 20. 模糊文本简单但很漂亮的文本模糊效果，简单又好看！ .blur { color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5); }]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域之由Request Method:OPTIONS初窥CORS]]></title>
    <url>%2F2018%2F05%2F02%2F%E8%B7%A8%E5%9F%9F%E4%B9%8B%E7%94%B1Request-Method-OPTIONS%E5%88%9D%E7%AA%A5CORS%2F</url>
    <content type="text"><![CDATA[不就是跨域么?慌个XX - 掘金刚接触前端的时候，以为HTTP的Request Method只有GET与POST两种，后来才了解到，原来还有HEAD、PUT、DELETE、OPTIONS…… 目前的工作中，HEAD、PUT、DELETE我是真的没有见过……但是OPTIONS几乎天天都会遇到。本地环境跑公司项目的时候，每次POST之前，为啥浏览器还偷偷给我来一次没有返回的OPTIONS请求？ 原来，浏览器在某些请求中，在正式通信前会增加一次HTTP查询请求，称为”预检”请求（preflight）。OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 如果这个OPTIONS请求包含一个正文（有Content-Length或Transfer-Encoding存在），则必须有Content-Type来指定媒体类型。虽然规范里没有定义这种正文的用法，但是HTTP将来的扩展可能会用它来查询服务器上更详细的信息。不支持该扩展的服务器可以忽略该请求正文。 如果该URI是一个星号（“”），OPTIONS请求将试图应用于服务器，而不是某个指定资源。由于服务器的通信选项通常依赖于资源，所以此“”请求只能作为“ping”或者“no-op”方法；或者用来测试服务器的性能。例如，用来测试HTTP/1.1代理。 如果该URI不是星号，则只能用来获取该资源通信中可用的选项。 得到的200响应应该包含一个头域，指明服务器实现的和适用于该资源的可选特征（如：Allow），可能还包括该规范尚未定义的扩展。如果有响应正文，则应包含关于通信选项的信息。本规范没有定义该正文格式，但可能在HTTO将来的扩展中定义。可以利用内容协商来选择合适的响应格式。如果没有响应正文，响应必须包含Content-Length，并且值为“0”。 请求头的Max-Forwards用来请求特定代理。当代理收到一个允许URI转发的OPTIONS请求，则检查Max-Forwards。如果Max-Forwards值为0，则不能转发该消息；相反，代理会将自己的通信选项去响应。如果Max-Forwards是正整数，代理转发请求的时候会将该值减1。如果请求中没有Max-Forwards，转发的请求也不会有。 简而言之OPTIONS请求方法的主要用途有两个： 1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。 2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。如上两张图片，图2就是本地环境，本地环境请求接口的时候，每次请求接口之前都会多一次OPTIONS请求。 CORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 两种请求浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-so-simple request）。 同时满足以下条件，就是简单请求： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。都以Access-Control- 开头： （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 非简单请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 我工作中写的所有页面拉的接口都是非简单请求。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 在页面域名与接口域名不一致的情况下，就出现了每次请求前先发送一个options请求的问题。 OPTIONS请求头信息中，除了Origin字段，还至少会多两个特殊字段： （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。 至于其他乱七八糟的字段，现在的我还用不到也不懂，将会慢慢深入了解。 服务器收到预检请求后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://lizard.qa.nt.ctripcorp.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 XMLHttpRequest cannot load http://lizard.qa.nt.ctripcorp.comOrigin http://lizard.qa.nt.ctripcorp.com is not allowed by Access-Control-Allow-Origin. 其他字段中Access-Control-Max-Age 用来指定本次预检请求的有效期，单位为秒。该字段可选。 与JSONP的对比CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，JSONP的优势在于支持老旧浏览器。]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能监控：window.performance]]></title>
    <url>%2F2018%2F04%2F23%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%9Awindow-performance%2F</url>
    <content type="text"><![CDATA[window.performance 是W3C性能小组引入的新的API，目前IE9以上的浏览器都支持。一个performance对象的完整结构如下图所示： Window.performance虽然叫 Timing API 但是用起来却是 window.performance // 兼容性写法 const performance = window.performance || window.msPerformance || window.webkitPerformance; memory字段代表JavaScript对内存的占用。 performance.memory(内存) usedJSHeapSizeJS 对象（包括V8引擎内部对象）占用的内存 totalJSHeapSize可使用的内存 jsHeapSizeLimit内存大小限制 performance.navigation(我从哪里来) redirectCount如果有重定向的话，页面通过几次重定向跳转而来 type 0 即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等） 1 即 TYPE_RELOAD 通过 window.location.reload() 刷新的页面 2 即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录） 255 即 TYPE_UNDEFINED 非以上方式进入的页面 navigation字段统计的是一些网页导航相关的数据： redirectCount:重定向的数量（只读），但是这个接口有同源策略限制，即仅能检测同源的重定向； type 返回值应该是0,1,2 中的一个。分别对应三个枚举值: 0 : TYPE_NAVIGATE (用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式) 1 : TYPE_RELOAD (用户通过刷新，包括JS调用刷新接口等方式访问页面) 2 : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面) 最重要的是timing字段的统计数据，它包含了网络、解析等一系列的时间数据。 performance.timing(时间) 2.2.1 timing API timing的整体结构如上图所示： 各字段的含义如下： startTime：有些浏览器实现为navigationStart，代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览baidu.com，在地址栏输入google.com并回车，浏览器的执行动作依次为：unload当前文档（即http://baidu.com）-&gt;请求下一文档（即http://google.com）。navigationStart的值便是触发unload当前文档的时间节点。 如果当前文档为空，则navigationStart的值等于fetchStart。 redirectStart和redirectEnd：如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点； unloadEventStart和unloadEventEnd：如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0； fetchStart是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存； domainLookupStart和domainLookupEnd分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart； connectStart和connectEnd分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd； secureConnectionStart：可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0； requestStart代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等； responseStart和responseEnd分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻； domLoading代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点； domInteractive代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点； domContentLoadedEventStart：代表DOMContentLoaded事件触发的时间节点： 页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。 domContentLoadedEventEnd：代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间； domComplete：html文档完全解析完毕的时间节点； loadEventStart和loadEventEnd分别代表onload事件触发和结束的时间节点 2.2.2 计算性能指标 可以使用Navigation.timing 统计到的时间数据来计算一些页面性能指标，比如DNS查询耗时、白屏时间、domready等等。如下： DNS查询耗时 = domainLookupEnd - domainLookupStart TCP链接耗时 = connectEnd - connectStart request请求耗时 = responseEnd - responseStart 解析dom树耗时 = domComplete - domInteractive 白屏时间 = domloadng - fetchStart domready时间 = domContentLoadedEventEnd - fetchStart onload时间 = loadEventEnd - fetchStart 所以根据上面的时间点，我们可以计算常规的性能值，如下： （使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。） var timing = window.performance &amp;&amp; window.performance.timing; var navigation = window.performance &amp;&amp; window.performance.navigation; 重定向次数： var redirectCount = navigation &amp;&amp; navigation.redirectCount; 跳转耗时： var redirect = timing.redirectEnd - timing.redirectStart; APP CACHE 耗时： var appcache = Math.max(timing.domainLookupStart - timing.fetchStart, 0); DNS 解析耗时： var dns = timing.domainLookupEnd - timing.domainLookupStart; TCP 链接耗时： var conn = timing.connectEnd - timing.connectStart; 等待服务器响应耗时（注意是否存在cache）： var request = timing.responseStart - timing.requestStart; 内容加载耗时（注意是否存在cache）: var response = timing.responseEnd - timing.responseStart; 总体网络交互耗时，即开始跳转到服务器资源下载完成： var network = timing.responseEnd - timing.navigationStart; 渲染处理： var processing = (timing.domComplete || timing.domLoading) - timing.domLoading; 抛出 load 事件： var load = timing.loadEventEnd - timing.loadEventStart; 总耗时： var total = (timing.loadEventEnd || timing.loadEventStart || timing.domComplete || timing.domLoading) - timing.navigationStart; 可交互： var active = timing.domInteractive - timing.navigationStart; 请求响应耗时，即 T0，注意cache： var t0 = timing.responseStart - timing.navigationStart; 首次出现内容，即 T1： var t1 = timing.domLoading - timing.navigationStart; 内容加载完毕，即 T3： var t3 = timing.loadEventEnd - timing.navigationStart; 2.2.3 Resource timing API Resource timing API是用来统计静态资源相关的时间信息，详细的内容请参考W3C Resource timing。这里我们只介绍performance.getEntries方法，它可以获取页面中每个静态资源的请求，【以百度移动版首页的logo为例】如下： 比较有用的几个属性： name：资源的链接 initiatorType: 初始类型（注意这个类型并不准确，例如在css中的图片资源会这个值显示css，所以还是推荐用name中的后缀名） duration: 资源的总耗时（包括等待时长，请求时长，响应时长 相当于responseEnd - startTime） transferSize: 转换后的文件大小(略大于encodedBodySize, 为什么我取这个呢，因为这个值是和chrome的devtool Network里的size一致) 可以看到performance.getEntries返回一个数组，数组的每个元素代表对应的静态资源的信息，比如上图展示的第一个元素对应的资源类型initiatorType是图片img，请求花费的时间就是duration的值。 关于Resource timing API的使用场景，感兴趣的同学可以深入研究。 ; (function() { handleAddListener(&apos;load&apos;, getTiming) function handleAddListener(type, fn) { if(window.addEventListener) { window.addEventListener(type, fn) } else { window.attachEvent(&apos;on&apos; + type, fn) } } function getTiming() { try { var time = performance.timing; var timingObj = {}; var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000; if(loadTime &lt; 0) { setTimeout(function() { getTiming(); }, 200); return; } timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000; timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000; timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000; timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000; timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000; timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000; timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000; timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000; timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000; timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]); for(item in timingObj) { console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;); } console.log(performance.timing); } catch(e) { console.log(timingObj) console.log(performance.timing); } } })(); &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; /&gt; &lt;script src=&quot;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <tags>
        <tag>performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见跨域解决方案]]></title>
    <url>%2F2018%2F04%2F22%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1.) 资源跳转： A链接、重定向、表单提交 2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链 3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： 1.) Cookie、LocalStorage 和 IndexDB 无法读取 2.) DOM 和 Js对象无法获得 3.) AJAX 请求不能发送 常见跨域场景URL 说明 是否允许通信 http://www.domain.com/a.js http://www.domain.com/b.js 同一域名，不同文件或路径 允许 http://www.domain.com/lab/c.js http://www.domain.com:8000/a.js http://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.js https://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.js http://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.js http://x.domain.com/b.js 主域相同，子域不同 不允许 http://domain.com/c.js http://www.domain1.com/a.js http://www.domain2.com/b.js 不同域名 不允许 跨域解决方案1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域 一、 通过jsonp跨域通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.）原生实现： &lt;script&gt; var script = document.createElement(&apos;script&apos;); script.type = &apos;text/javascript&apos;; // 传参并指定回调执行函数为onBack script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&apos;; document.head.appendChild(script); // 回调执行函数 function onBack(res) { alert(JSON.stringify(res)); } &lt;/script&gt; 服务端返回如下（返回时即执行全局函数）： onBack({&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;}) 2.）jquery ajax： $.ajax({ url: &apos;http://www.domain2.com:8080/login&apos;, type: &apos;get&apos;, dataType: &apos;jsonp&apos;, // 请求方式为jsonp jsonpCallback: &quot;onBack&quot;, // 自定义回调函数名 data: {} }); 3.）vue.js： this.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;, { params: {}, jsonp: &apos;onBack&apos; }).then((res) =&gt; { console.log(res); }) 后端node.js代码示例： var querystring = require(&apos;querystring&apos;); var http = require(&apos;http&apos;); var server = http.createServer(); server.on(&apos;request&apos;, function(req, res) { var params = qs.parse(req.url.split(&apos;?&apos;)[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, { &apos;Content-Type&apos;: &apos;text/javascript&apos; }); res.write(fn + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;); res.end(); }); server.listen(&apos;8080&apos;); console.log(&apos;Server is running at port 8080...&apos;); jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.）父窗口：(http://www.domain.com/a.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt; &lt;script&gt; document.domain = &apos;domain.com&apos;; var user = &apos;admin&apos;; &lt;/script&gt; 2.）子窗口：(http://child.domain.com/b.html) &lt;script&gt; document.domain = &apos;domain.com&apos;; // 获取父窗口中变量 alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user); &lt;/script&gt; 三、 location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.）a.html：(http://www.domain1.com/a.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); // 向b.html传hash值 setTimeout(function() { iframe.src = iframe.src + &apos;#user=admin&apos;; }, 1000); // 开放给同域c.html的回调方法 function onCallback(res) { alert(&apos;data from c.html ---&gt; &apos; + res); } &lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash; }; &lt;/script&gt; 3.）c.html：(http://www.domain1.com/c.html) &lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () { // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;)); }; &lt;/script&gt; 四、 window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) var proxy = function(url, callback) { var state = 0; var iframe = document.createElement(&apos;iframe&apos;); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(&apos;&apos;); iframe.contentWindow.close(); document.body.removeChild(iframe); } }; // 请求跨域b页面数据 proxy(&apos;http://www.domain2.com/b.html&apos;, function(data){ alert(data); }); 2.）proxy.html：(http://www.domain1.com/proxy….中间代理页，与a.html同域，内容为空即可。 3.）b.html：(http://www.domain2.com/b.html) &lt;script&gt; window.name = &apos;This is domain2 data!&apos;; &lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 1.）a.html：(http://www.domain1.com/a.html) &lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt; &lt;script&gt; var iframe = document.getElementById(&apos;iframe&apos;); iframe.onload = function() { var data = { name: &apos;aym&apos; }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;); }; // 接受domain2返回数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain2 ---&gt; &apos; + e.data); }, false); &lt;/script&gt; 2.）b.html：(http://www.domain2.com/b.html) &lt;script&gt; // 接收domain1的数据 window.addEventListener(&apos;message&apos;, function(e) { alert(&apos;data from domain1 ---&gt; &apos; + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;); } }, false); &lt;/script&gt; 六、 跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。 目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置：1.）原生ajax // 前端设置是否带cookie xhr.withCredentials = true; 示例代码： var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookie xhr.withCredentials = true; xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true); xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;); xhr.send(&apos;user=admin&apos;); xhr.onreadystatechange = function() { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { alert(xhr.responseText); } }; 2.）jQuery ajax $.ajax({ ... xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ... }); 3.）vue框架在vue-resource封装的ajax组件中加入以下代码： Vue.http.options.credentials = true 2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台： /* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */ response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;); // 若有端口需写全（协议+域名+端口） response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); 2.）Nodejs后台示例： var http = require(&apos;http&apos;); var server = http.createServer(); var qs = require(&apos;querystring&apos;); server.on(&apos;request&apos;, function(req, res) { var postData = &apos;&apos;; // 数据块接收中 req.addListener(&apos;data&apos;, function(chunk) { postData += chunk; }); // 数据接收完毕 req.addListener(&apos;end&apos;, function() { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;, // 后端允许发送Cookie &apos;Access-Control-Allow-Origin&apos;: &apos;http://www.domain1.com&apos;, // 允许访问的域（协议+域名+端口） &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos; // HttpOnly:脚本无法读取cookie }); res.write(JSON.stringify(postData)); res.end(); }); }); server.listen(&apos;8080&apos;); console.log(&apos;Server is running at port 8080...&apos;); 七、 nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 location / { add_header Access-Control-Allow-Origin *; } 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置： #proxy服务器 server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; } } 1.) 前端代码示例： var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问nginx中的代理服务器 xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true); xhr.send(); 2.) Nodejs后台示例： var http = require(&apos;http&apos;); var server = http.createServer(); var qs = require(&apos;querystring&apos;); server.on(&apos;request&apos;, function(req, res) { var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, { &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos; // HttpOnly:脚本无法读取 }); res.write(JSON.stringify(params)); res.end(); }); server.listen(&apos;8080&apos;); console.log(&apos;Server is running at port 8080...&apos;); 八、 Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。 1、 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 1.）前端代码示例： var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问http-proxy-middleware代理服务器 xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true); xhr.send(); 2.）中间件服务器： var express = require(&apos;express&apos;); var proxy = require(&apos;http-proxy-middleware&apos;); var app = express(); app.use(&apos;/&apos;, proxy({ // 代理跨域目标接口 target: &apos;http://www.domain2.com:8080&apos;, changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;); res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: &apos;www.domain1.com&apos; // 可以为false，表示不修改 })); app.listen(3000); console.log(&apos;Proxy server is listen at port 3000...&apos;); 3.）Nodejs后台同（六：nginx） 2、 vue框架的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 webpack.config.js部分配置： module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: &apos;/login&apos;, target: &apos;http://www.domain2.com:8080&apos;, // 代理跨域目标接口 changeOrigin: true, cookieDomainRewrite: &apos;www.domain1.com&apos; // 可以为false，表示不修改 }], noInfo: true } } 九、 WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用http://Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.）前端代码： &lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var socket = io(&apos;http://www.domain2.com:8080&apos;); // 连接成功处理 socket.on(&apos;connect&apos;, function() { // 监听服务端消息 socket.on(&apos;message&apos;, function(msg) { console.log(&apos;data from server: ---&gt; &apos; + msg); }); // 监听服务端关闭 socket.on(&apos;disconnect&apos;, function() { console.log(&apos;Server socket has closed.&apos;); }); }); document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() { socket.send(this.value); }; &lt;/script&gt; 2.）Nodejs socket后台： var http = require(&apos;http&apos;); var socket = require(&apos;socket.io&apos;); // 启http服务 var server = http.createServer(function(req, res) { res.writeHead(200, { &apos;Content-type&apos;: &apos;text/html&apos; }); res.end(); }); server.listen(&apos;8080&apos;); console.log(&apos;Server is running at port 8080...&apos;); // 监听socket连接 socket.listen(server).on(&apos;connection&apos;, function(client) { // 接收信息 client.on(&apos;message&apos;, function(msg) { client.send(&apos;hello：&apos; + msg); console.log(&apos;data from client: ---&gt; &apos; + msg); }); // 断开处理 client.on(&apos;disconnect&apos;, function() { console.log(&apos;Client socket has closed.&apos;); }); });]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP三种缓存方式]]></title>
    <url>%2F2018%2F04%2F19%2FHTTP%E4%B8%89%E7%A7%8D%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[依然在学习node的艰辛过程中，最近学习了http相关的知识，学到了东西当然第一时间就来和大家分享分享，今天呢就教大家来看看利用node中的http模块去实现不同的缓存策略！！！ 我们都知道，对于我们前端开发来说，缓存是一个十分重要的东西，即希望用户不能每次请求过来都要重复下载我们的页面内容，希望为用户节省流量，并且能提高我们页面的浏览流畅度，但是同时当我们修改了一个bug后，又希望线上能够及时更新，这时候就要求爷爷告奶奶让运维小哥哥帮我们刷新一下缓存了，那么有没有一些比较好的缓存策略可以针对我们修改bug又能不麻烦运维及时更新呢，今天我们就利用node来看一下后端中的缓存策略是如何设置的。 强制缓存通常我们对于强制缓存的设置是服务端告诉客户端你刚刚已经请求过一次了，我们约定好十分钟内你再过来请求都直接读取缓存吧，意思也就是当客户端在十分钟内多次请求的话只有第一次会下载页面内容，其他的请求都是直接走缓存，不管我们页面在这期间有没有变化都不会影响客户端读取缓存。那我们来看一下代码的实现 let http = require(&apos;http&apos;); let path = require(&apos;path&apos;); let fs = require(&apos;fs&apos;); let url = require(&apos;url&apos;); // 创建一个服务 let server = http.createServer(); // 监听请求 server.on(&apos;request&apos;,(req,res)=&gt;{ // 获取到请求的路径 let {pathname,query} = url.parse(req.url,true); // 将路径拼接成服务器上对应得文件路径 let readPath = path.join(__dirname, &apos;public&apos;,pathname); console.log(readPath) try { // 获取路径状态 let statObj = fs.statSync(readPath); // 服务端设置响应头 Cache-Control 也就是缓存多久以秒为单位 res.setHeader(&apos;Cache-Control&apos;,&apos;max-age=10&apos;); // 服务器设置响应头Expires 过期时间 获取当前时间加上刚刚设置的缓存秒数 res.setHeader(&apos;Expires&apos;,new Date(Date.now()+10*1000).toGMTString()); //判断如果路径是一件文件夹 就默认查找该文件下的index.html if(statObj.isDirectory()){ let p = path.join(readPath,&apos;index.html&apos;); console.log(p); // 判断是否有index.html 没有就返回404 fs.statSync(p); // 创建文件可读流 并且pipe到响应res可写流中 fs.createReadStream(p).pipe(res) }else{ // 如果请求的就是一个文件 那么久直接返回 fs.createReadStream(readPath).pipe(res) } } catch (error) { // 读取不到 返回404 console.log(error) res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;) res.statusCode = 404; res.end(`未发现文件`) } }) // 监听3000端口 server.listen(3000) 复制代码 通过上面代码测试我们会发现当我们在10秒内进行对同一文件的请求，那么我们浏览器就会直接走缓存 通过上图可以看到我们重复请求的时候我们会看到css变成from memory cache，我们也看到我们刚刚的响应头也被设置上了 协商缓存上面的强制缓存我们就发现了 就是我们平时改完bug上线要苦苦等待的一个原因了，那么有没有其他的好的缓存处理方法呢，我们设想一下 假如我们能够知道我们文件有没有修改，假如我们修改了服务器就返回最新的内容假如没有修改 就一直默认缓存 ，这样是不是听起来十分的棒！那我们就想如果我们能够知道文件的最后修改时间是不是就可以实现了！ 通过文件最后修改时间来缓存let http = require(&apos;http&apos;); let path = require(&apos;path&apos;); let fs = require(&apos;fs&apos;); let url = require(&apos;url&apos;); let server = http.createServer(); server.on(&apos;request&apos;,(req,res)=&gt;{ // 获取到请求的路径 let {pathname,query} = url.parse(req.url,true); // 将路径拼接成服务器上对应得文件路径 let readPath = path.join(__dirname, &apos;public&apos;,pathname); try { // 获取路径状态 let statObj = fs.statSync(readPath); // 为了方便测试 我们告诉客户端不要走强制缓存了 res.setHeader(&apos;Cache-Control&apos;,&apos;no-cache&apos;); if(statObj.isDirectory()){ let p = path.join(readPath,&apos;index.html&apos;); let statObj = fs.statSync(p); // 我们通过获取到文件状态来拿到文件的最后修改时间 也就是ctime 我们把这个时间通过响应头Last-Modified来告诉客户端，客户端再下一次请求的时候会通过请求头If-Modified-Since把这个值带给服务端，我们只要判断这两个值是否相等，假如相等那么也就是说 文件没有被修改那么我们就告诉客户端304 你直接读缓存吧 res.setHeader(&apos;Last-Modified&apos;,statObj.ctime.toGMTString()); if(req.headers[&apos;if-modified-since&apos;] === statObj.ctime.toGMTString()){ res.statusCode = 304; res.end(); return } // 修改了那么我们就直接返回新的内容 fs.createReadStream(p).pipe(res) }else{ res.setHeader(&apos;Last-Modified&apos;,statObj.ctime.toGMTString()); if(req.headers[&apos;if-modified-since&apos;] === statObj.ctime.toGMTString()){ res.statusCode = 304; res.end(); return } fs.createReadStream(readPath).pipe(res) } } catch (error) { console.log(error) res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;) res.statusCode = 404; res.end(`未发现文件`) } }) server.listen(3000) 复制代码 我们通过请求可以看到，当我们第一次请求过后，无论怎么刷新请求都是304 直接读取的缓存，假如我们在服务端把这个文件修改了 那么我们就能看到又能请求到最新的内容了，这就是我们通过协商缓存来处理的，我们通过获取到文件状态来拿到文件的最后修改时间 也就是ctime 我们把这个时间通过响应头Last-Modified来告诉客户端，客户端再下一次请求的时候会通过请求头If-Modified-Since把这个值带给服务端，我们只要判断这两个值是否相等，假如相等那么也就是说 文件没有被修改那么我们就告诉客户端304 你直接读缓存吧 通过文件内容来缓存再再再再再假如我们在文件中删除了字符a然后又还原了，那么这时候保存我们的文件的修改时间其实也发生了变化，但是其实我们文件的真正内容并没有发生变化，所以这时候其实客户端继续走缓存也是可以的 ，我们来看看这样的缓存策略如何实现。 let http = require(&apos;http&apos;); let path = require(&apos;path&apos;); let fs = require(&apos;fs&apos;); let url = require(&apos;url&apos;); let crypto = require(&apos;crypto&apos;); let server = http.createServer(); server.on(&apos;request&apos;,(req,res)=&gt;{ // 获取到请求的路径 let {pathname,query} = url.parse(req.url,true); // 将路径拼接成服务器上对应得文件路径 let readPath = path.join(__dirname, &apos;public&apos;,pathname); try { // 获取路径状态 let statObj = fs.statSync(readPath); // 为了方便测试 我们告诉客户端不要走强制缓存了 res.setHeader(&apos;Cache-Control&apos;,&apos;no-cache&apos;); if(statObj.isDirectory()){ let p = path.join(readPath,&apos;index.html&apos;); let statObj = fs.statSync(p); // 我们通过流把文件读取出来 然后对读取问来的内容进行md5加密 得到一个base64加密hash值 let rs = fs.createReadStream(p); let md5 = crypto.createHash(&apos;md5&apos;); let arr = []; rs.on(&apos;data&apos;,(data)=&gt;{ arr.push(data); md5.update(data); }) rs.on(&apos;end&apos;,(data)=&gt;{ let r = md5.digest(&apos;base64&apos;); // 然后我们将这个hash值通过响应头Etag传给客户端，客户端再下一次请求的时候会把上一次的Etag值通过请求头if-none-match带过来，然后我们就可以继续比对文件生成的hash值和上次产生的hash是否一样 如果一样说明文件内容没有发生变化 就告诉客户端304 读取缓存 res.setHeader(&apos;Etag&apos;,r); if(req.headers[&apos;if-none-match&apos;]===r){ res.statusCode=304; res.end(); return; } res.end(Buffer.concat(arr)) }) }else{ let rs = fs.createReadStream(readPath); let md5 = crypto.createHash(&apos;md5&apos;); let arr = []; rs.on(&apos;data&apos;,(data)=&gt;{ arr.push(data); md5.update(data); }) rs.on(&apos;end&apos;,(data)=&gt;{ let r = md5.digest(&apos;base64&apos;); res.setHeader(&apos;Etag&apos;,r); if(req.headers[&apos;if-none-match&apos;]===r){ res.statusCode=304; res.end(); return; } res.end(Buffer.concat(arr)) }) } } catch (error) { console.log(error) res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;) res.statusCode = 404; res.end(`未发现文件`) } }) server.listen(3000) 复制代码 通过控制台我们可以看出来 请求头和响应头中都有我们上面所说的对应的值，但是从代码里我们也能看出来，我们每次在请求到来的时候都会把文件全部读取出来并且进行加密生产hash然后再做对比，这样其实十分的消耗性能，因此这种缓存方式也有他自己的缺点 总结我们通过node来亲自实现了三种缓存方式，我们可以总结出每种缓存方式对应的实现： 强制缓存 服务端设置响应头Cache-Control:max-age=xxx，并且设置Expires响应头过期时间，客户端自行判断是否读取缓存 协商缓存 通过状态码304告诉客户端该走缓存 修改时间：通过文件的最后修改时间判断该不该读取缓存，服务端设置响应头Last-Modified,客户端把上次服务端响应头中的Last-modified值通过if-modified-since 传递给服务端 ， 服务端通过比较当前文件的修改时间和上次修改时间(上次传给客户端的值),如果相等那么说明文件修改时间没变也就是没变化 文件内容：通过文件的内容来判断该不该读取缓存，服务端通过把文件内容读取出来，通过md5进行base64加密得出hash值，把这个值设置响应头Etag，客户端下一次请求通过if-none-match带过来，服务端再比对当前文件内容加密得出的hash值和上次是否一样，如果一样说明文件内容没有发生改变，这种方式是最准确的方式，但是也是最耗性能]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue你可能不知道的7个技巧]]></title>
    <url>%2F2018%2F04%2F10%2FVue%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%847%E4%B8%AA%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[一、善用watch的immediate属性这一点我在项目中也是这么写的。例如有请求需要再也没初始化的时候就执行一次，然后监听他的变化，很多人这么写： created(){ this.fetchPostList() }, watch: { searchInputValue(){ this.fetchPostList() } } 上面的这种写法我们可以完全如下写： watch: { searchInputValue:{ handler: &apos;fetchPostList&apos;, immediate: true } } 二、组件注册，值得借鉴一般情况下，我们组件如下写： import BaseButton from &apos;./baseButton&apos; import BaseIcon from &apos;./baseIcon&apos; import BaseInput from &apos;./baseInput&apos;export default { components: { BaseButton, BaseIcon, BaseInput } } &lt;BaseInput v-model=&quot;searchText&quot; @keydown.enter=&quot;search&quot; /&gt; &lt;BaseButton @click=&quot;search&quot;&gt; &lt;BaseIcon name=&quot;search&quot;/&gt;&lt;/BaseButton&gt; 步骤一般有三部， 第一步，引入、 第二步注册、 第三步才是正式的使用， 这也是最常见和通用的写法。但是这种写法经典归经典，好多组件，要引入多次，注册多次，感觉很烦。 我们可以借助一下webpack，使用 require.context() 方法来创建自己的（模块）上下文，从而实现自动动态require组件。 思路是：在src文件夹下面main.js中，借助webpack动态将需要的基础组件统统打包进来。 代码如下： import Vue from &apos;vue&apos; import upperFirst from &apos;lodash/upperFirst&apos; import camelCase from &apos;lodash/camelCase&apos; // Require in a base component context const requireComponent = require.context(&apos;./components&apos;, false, /base-[\w-]+\.vue$/) requireComponent.keys().forEach(fileName =&gt; { // Get component config const componentConfig = requireComponent(fileName) // Get PascalCase name of component const componentName = upperFirst( camelCase(fileName.replace(/^\.\//, &apos;&apos;).replace(/\.\w+$/, &apos;&apos;)) ) // Register component globally Vue.component(componentName, componentConfig.default || componentConfig) }) 这样我们引入组件只需要第三步就可以了： &lt;BaseInput v-model=&quot;searchText&quot; @keydown.enter=&quot;search&quot; /&gt; &lt;BaseButton @click=&quot;search&quot;&gt; &lt;BaseIcon name=&quot;search&quot;/&gt; &lt;/BaseButton&gt; 三、精简vuex的modules引入对于vuex，我们输出store如下写： import auth from &apos;./modules/auth&apos; import posts from &apos;./modules/posts&apos; import comments from &apos;./modules/comments&apos; export default new Vuex.Store({ modules: { auth, posts, comments } }) 要引入好多modules，然后再注册到Vuex.Store中~~ 精简的做法和上面类似，也是运用 require.context()读取文件，代码如下： import camelCase from &apos;lodash/camelCase&apos; const requireModule = require.context(&apos;.&apos;, false, /\.js$/) const modules = {} requireModule.keys().forEach(fileName =&gt; { // Don&apos;t register this file as a Vuex module if (fileName === &apos;./index.js&apos;) return const moduleName = camelCase( fileName.replace(/(\.\/|\.js)/g, &apos;&apos;) ) modules[moduleName] = { namespaced: true, ...requireModule(fileName), } }) export default modules 这样我们只需如下代码就可以了： import modules from &apos;./modules&apos; export default new Vuex.Store({ modules }) 四、路由的延迟加载这一点，关于vue的引入，我之前在中也提及过，可以通过require方式或者import()方式动态加载组件。 { path: &apos;/admin&apos;, name: &apos;admin-dashboard&apos;, component:require(&apos;@views/admin&apos;).default } 或者 { path: &apos;/admin&apos;, name: &apos;admin-dashboard&apos;, component:() =&gt; import(&apos;@views/admin&apos;) } 加载路由。 五、router key组件刷新下面这个场景真的是伤透了很多程序员的心… 先默认大家用的是Vue-router来实现路由的控制。 假设我们在写一个博客网站，需求是从/post-haorooms/a，跳转到/post-haorooms/b。然后我们惊人的发现，页面跳转后数据竟然没更新？！原因是vue-router”智能地”发现这是同一个组件，然后它就决定要复用这个组件，所以你在created函数里写的方法压根就没执行。通常的解决方案是监听$route的变化来初始化数据，如下： data() { return { loading: false, error: null, post: null } }, watch: { &apos;$route&apos;: { handler: &apos;resetData&apos;, immediate: true } }, methods: { resetData() { this.loading = false this.error = null this.post = null this.getPost(this.$route.params.id) }, getPost(id){ } } bug是解决了，可每次这么写也太不优雅了吧？秉持着能偷懒则偷懒的原则，我们希望代码这样写： data() { return { loading: false, error: null, post: null } }, created () { this.getPost(this.$route.params.id) }, methods () { getPost(postId) { // ... } } 解决方案：给router-view添加一个唯一的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件。 &lt;router-view :key=&quot;$route.fullpath&quot;&gt;&lt;/router-view&gt; 注：我个人的经验，这个一般应用在子路由里面，这样才可以不避免大量重绘，假设app.vue根目录添加这个属性，那么每次点击改变地址都会重绘，还是得不偿失的！ 六、唯一组件根元素场景如下： (Emitted value instead of an instance of Error) Error compiling template: &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; - Component template should contain exactly one root element. If you are using v-if on multiple elements, use v-else-if to chain them instead. 模板中div只能有一个，不能如上面那么平行2个div。 例如如下代码： &lt;template&gt; &lt;li v-for=&quot;route in routes&quot; :key=&quot;route.name&quot; &gt; &lt;router-link :to=&quot;route&quot;&gt; {{ route.title }} &lt;/router-link&gt; &lt;/li&gt; &lt;/template&gt; 会报错！ 我们可以用render函数来渲染 functional: true, render(h, { props }) { return props.routes.map(route =&gt; &lt;li key={route.name}&gt; &lt;router-link to={route}&gt; {route.title} &lt;/router-link&gt; &lt;/li&gt; ) } 七、组件包装、事件属性穿透问题当我们写组件的时候，通常我们都需要从父组件传递一系列的props到子组件，同时父组件监听子组件emit过来的一系列事件。举例子： //父组件 &lt;BaseInput :value=&quot;value&quot; label=&quot;密码&quot; placeholder=&quot;请填写密码&quot; @input=&quot;handleInput&quot; @focus=&quot;handleFocus&gt; &lt;/BaseInput&gt; //子组件 &lt;template&gt; &lt;label&gt; {{ label }} &lt;input :value=&quot;value&quot; :placeholder=&quot;placeholder&quot; @focus=$emit(&apos;focus&apos;, $event)&quot; @input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; &lt;/label&gt; &lt;/template&gt; 这样写很不精简，很多属性和事件都是手动定义的，我们可以如下写： &lt;input :value=&quot;value&quot; v-bind=&quot;$attrs&quot; v-on=&quot;listeners&quot; &gt; computed: { listeners() { return { ...this.$listeners, input: event =&gt; this.$emit(&apos;input&apos;, event.target.value) } } } $attrs包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定，并且可以通过 v-bind=”$attrs” 传入内部组件。 $listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2.0模板渲染底层思想]]></title>
    <url>%2F2018%2F04%2F02%2Fvue2-0%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93%E5%BA%95%E5%B1%82%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[初衷 在使用vue2.0的过程，有时看API很难理解vue作者的思想，这促使我想要去深入了解vue底层的思想，了解完底层的一些思想，才能更好的用活框架，虽然网上已经有很多源码解析的文档，但我觉得只有自己动手了，才能更加深印象。 vue2.0和1.0模板渲染的区别 Vue 2.0 中模板渲染与 Vue 1.0 完全不同，1.0 中采用的 DocumentFragment （想了解可以观看这篇文章），而 2.0 中借鉴 React 的 Virtual DOM。基于 Virtual DOM，2.0 还可以支持服务端渲染（SSR），也支持 JSX 语法（改良版的 render 函数）。 知识普及 在开始阅读源码之前，先了解一些相关的知识：AST 数据结构，VNode 数据结构，createElement 的问题，render函数。 AST 数据结构 AST 的全称是 Abstract Syntax Tree（抽象语法树），是源代码的抽象语法结构的树状表现形式，计算机学科中编译原理的概念。而vue就是将模板代码映射为AST数据结构，进行语法解析。 我们看一下 Vue 2.0 源码中 AST 数据结构 的定义： declare type ASTNode = ASTElement | ASTText | ASTExpression declare type ASTElement = { // 有关元素的一些定义 type: 1; tag: string; attrsList: Array&lt;{ name: string; value: string }&gt;; attrsMap: { [key: string]: string | null }; parent: ASTElement | void; children: Array&lt;ASTNode&gt;; //...... } declare type ASTExpression = { type: 2; expression: string; text: string; static?: boolean; } declare type ASTText = { type: 3; text: string; static?: boolean; } 我们看到 ASTNode 有三种形式：ASTElement，ASTText，ASTExpression。用属性 type 区分。 VNode数据结构 下面是 Vue 2.0 源码中 VNode 数据结构 的定义 (带注释的跟下面介绍的内容有关)： constructor { this.tag = tag //元素标签 this.data = data //属性 this.children = children //子元素列表 this.text = text this.elm = elm //对应的真实 DOM 元素 this.ns = undefined this.context = context this.functionalContext = undefined this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.componentInstance = undefined this.parent = undefined this.raw = false this.isStatic = false //是否被标记为静态节点 this.isRootInsert = true this.isComment = false this.isCloned = false this.isOnce = false } 真实DOM存在什么问题，为什么要用虚拟DOM 我们为什么不直接使用原生 DOM 元素，而是使用真实 DOM 元素的简化版 VNode，最大的原因就是 document.createElement 这个方法创建的真实 DOM 元素会带来性能上的损失。我们来看一个 document.createElement 方法的例子 let div = document.createElement(&apos;div&apos;); for(let k in div) { console.log(k); } 打开 console 运行一下上面的代码，会发现打印出来的属性多达 228 个，而这些属性有 90% 多对我们来说都是无用的。VNode 就是简化版的真实 DOM 元素，关联着真实的dom，比如属性elm，只包括我们需要的属性，并新增了一些在 diff 过程中需要使用的属性，例如 isStatic。 render函数 这个函数是通过编译模板文件得到的，其运行结果是 VNode。render 函数 与 JSX 类似，Vue 2.0 中除了 Template 也支持 JSX 的写法。大家可以使用 Vue.compile(template)方法编译下面这段模板。 &lt;div id=&quot;app&quot;&gt; &lt;header&gt; &lt;h1&gt;I am a template!&lt;/h1&gt; &lt;/header&gt; &lt;p v-if=&quot;message&quot;&gt; {{ message }} &lt;/p&gt; &lt;p v-else&gt; No message. &lt;/p&gt; &lt;/div&gt; 方法会返回一个对象，对象中有 render 和 staticRenderFns 两个值。看一下生成的 render函数 (function() { with(this){ return _c(&apos;div&apos;,{ //创建一个 div 元素 attrs:{&quot;id&quot;:&quot;app&quot;} //div 添加属性 id },[ _m(0), //静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render 函数 _v(&quot; &quot;), //空的文本节点 (message) //三元表达式，判断 message 是否存在 //如果存在，创建 p 元素，元素里面有文本，值为 toString(message) ?_c(&apos;p&apos;,[_v(&quot;\n &quot;+_s(message)+&quot;\n &quot;)]) //如果不存在，创建 p 元素，元素里面有文本，值为 No message. :_c(&apos;p&apos;,[_v(&quot;\n No message.\n &quot;)]) ] ) } }) 要看懂上面的 render函数，只需要了解 _c，_m，_v，_s 这几个函数的定义，其中 _c 是 createElement（创建元素），_m 是 renderStatic（渲染静态节点），_v 是 createTextVNode（创建文本dom），_s 是 toString （转换为字符串） 除了 render 函数，还有一个 staticRenderFns 数组，这个数组中的函数与 VDOM 中的 diff 算法优化相关，我们会在编译阶段给后面不会发生变化的 VNode 节点打上 static 为 true 的标签，那些被标记为静态节点的 VNode 就会单独生成 staticRenderFns 函数 (function() { //上面 render 函数 中的 _m(0) 会调用这个方法 with(this){ return _c(&apos;header&apos;,[_c(&apos;h1&apos;,[_v(&quot;I&apos;m a template!&quot;)])]) } }) 模板渲染过程（重要的函数介绍） 了解完一些基础知识后，接下来我们讲解下模板的渲染过程 $mount 函数，主要是获取 template，然后进入 compileToFunctions 函数。 compileToFunctions 函数，主要将 template 编译成 render 函数。首先读缓存，没有缓存就调用 compile 方法拿到 render 函数 的字符串形式，再通过 new Function 的方式生成 render 函数。 // 有缓存的话就直接在缓存里面拿 const key = options &amp;&amp; options.delimiters ? String(options.delimiters) + template : template if (cache[key]) { return cache[key] } const res = {} const compiled = compile(template, options) // compile 后面会详细讲 res.render = makeFunction(compiled.render) //通过 new Function 的方式生成 render 函数并缓存 const l = compiled.staticRenderFns.length res.staticRenderFns = new Array(l) for (let i = 0; i &lt; l; i++) { res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]) } ...... } return (cache[key] = res) // 记录至缓存中 compile 函数就是将 template 编译成 render 函数的字符串形式，后面一小节我们会详细讲到。 完成render方法的生成后，会进入 _mount 中进行DOM更新。该方法的核心逻辑如下： // 触发 beforeMount 生命周期钩子 callHook(vm, &apos;beforeMount&apos;) // 重点：新建一个 Watcher 并赋值给 vm._watcher vm._watcher = new Watcher(vm, function updateComponent () { vm._update(vm._render(), hydrating) }, noop) hydrating = false // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) { vm._isMounted = true callHook(vm, &apos;mounted&apos;) } return vm 首先会new一个watcher对象（主要是将模板与数据建立联系），在watcher对象创建后，会运行传入的方法 vm._update(vm._render(), hydrating) 。其中的vm._render()主要作用就是运行前面compiler生成的render方法，并返回一个vNode对象。vm.update() 则会对比新的 vdom 和当前 vdom，并把差异的部分渲染到真正的 DOM 树上。（想深入了解watcher的背后实现原理的，可以观看这篇文章 Vue2.0 源码阅读：响应式原理） compile 上文中提到 compile 函数就是将 template 编译成 render 函数 的字符串形式。 export function compile ( template: string, options: CompilerOptions ): CompiledResult { const AST = parse(template.trim(), options) //1. parse optimize(AST, options) //2.optimize const code = generate(AST, options) //3.generate return { AST, render: code.render, staticRenderFns: code.staticRenderFns } } 这个函数主要有三个步骤组成：parse，optimize 和 generate，分别输出一个包含 AST，staticRenderFns 的对象和 render函数 的字符串。 parse 函数，主要功能是将 template字符串解析成 AST。前面定义了ASTElement的数据结构，parse 函数就是将template里的结构（指令，属性，标签等）转换为AST形式存进ASTElement中，最后解析生成AST。 optimize 函数（src/compiler/optimizer.js）主要功能就是标记静态节点，为后面 patch 过程中对比新旧 VNode 树形结构做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。 generate 函数（src/compiler/codegen/index.js）主要功能就是根据 AST 结构拼接生成 render 函数的字符串。 const code = AST ? genElement(AST) : &apos;_c(&quot;div&quot;)&apos; staticRenderFns = prevStaticRenderFns onceCount = prevOnceCount return { render: `with(this){return ${code}}`, //最外层包一个 with(this) 之后返回 staticRenderFns: currentStaticRenderFns } 其中 genElement 函数（src/compiler/codegen/index.js）是会根据 AST 的属性调用不同的方法生成字符串返回。 function genElement (el: ASTElement): string { if (el.staticRoot &amp;&amp; !el.staticProcessed) { return genStatic(el) } else if (el.once &amp;&amp; !el.onceProcessed) { return genOnce(el) } else if (el.for &amp;&amp; !el.forProcessed) { return genFor(el) } else if (el.if &amp;&amp; !el.ifProcessed) { return genIf(el) } else if (el.tag === &apos;template&apos; &amp;&amp; !el.slotTarget) { return genChildren(el) || &apos;void 0&apos; } else if (el.tag === &apos;slot&apos;) { } return code } } 以上就是 compile 函数中三个核心步骤的介绍，compile 之后我们得到了 render 函数 的字符串形式，后面通过 new Function 得到真正的渲染函数。数据发现变化后，会执行 Watcher 中的 _update 函数（src/core/instance/lifecycle.js），_update 函数会执行这个渲染函数，输出一个新的 VNode 树形结构的数据。然后在调用 patch 函数，拿这个新的 VNode 与旧的 VNode 进行对比，只有发生了变化的节点才会被更新到真实 DOM 树上。 patch patch.js 就是新旧 VNode 对比的 diff 函数，主要是为了优化dom，通过算法使操作dom的行为降到最低，diff 算法来源于 snabbdom，是 VDOM 思想的核心。snabbdom 的算法为了 DOM 操作跨层级增删节点较少的这一目标进行优化，它只会在同层级进行, 不会跨层级比较。 想更加深入VNode diff算法原理的，可以观看（解析vue2.0的diff算法） 总结 compile 函数主要是将 template 转换为 AST，优化 AST，再将 AST 转换为 render函数； render函数 与数据通过 Watcher 产生关联； 在数据发生变化时调用 patch 函数，执行此 render 函数，生成新 VNode，与旧 VNode 进行 diff，最终更新 DOM 树。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM学习笔记整理]]></title>
    <url>%2F2018%2F04%2F01%2FNPM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[10个 NPM 使用技巧NPM 学习笔记整理 什么是-NPM什么是 NPMnpm 之于 Node ，就像 pip 之于 Python , gem 之于 Ruby , composer 之于 PHP 。 npm 是 Node 官方提供的包管理工具，他已经成了 Node 包的标准发布平台，用于 Node 包的发布、传播、依赖控制。npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。 为什么要使用-NPM为什么要使用 NPMnpm 是随同 Node 一起安装的包管理工具，能解决 Node 代码部署上的很多问题，常见的场景有以下几种： 允许用户从 npm 服务器下载别人编写的第三方包到本地使用。 允许用户从 npm 服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到 npm 服务器供别人使用。 npm 的背后，是基于 CouchDB 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。 如何使用-NPM如何使用 NPM安装安装npm 不需要单独安装。在安装 Node 的时候，会连带一起安装 npm 。但是，Node 附带的 npm 可能不是最新版本，最后用下面的命令，更新到最新版本。 $ sudo npm install npm@latest -g 如果是 Window 系统使用以下命令即可： npm install npm -g 也就是使用 npm 安装自己。之所以可以这样，是因为 npm 本身与 Node 的其他模块没有区别。 然后，运行下面的命令，查看各种信息。 # 查看 npm 命令列表 $ npm help # 查看各个命令的简单用法 $ npm -l # 查看 npm 的版本 $ npm -v # 查看 npm 的配置 $ npm config list -l 使用使用npm-initnpm initnpm init 用来初始化生成一个新的 package.json 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。如果使用了 -f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的 package.json 文件。 $ npm init -y npm-setnpm setnpm set 用来设置环境变量 $ npm set init-author-name &apos;Your name&apos; $ npm set init-author-email &apos;Your email&apos; $ npm set init-author-url &apos;http://yourdomain.com&apos; $ npm set init-license &apos;MIT&apos; 上面命令等于为 npm init 设置了默认值，以后执行 npm init 的时候，package.json的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 ~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 npm config。 npm-infonpm infonpm info 命令可以查看每个模块的具体信息。比如，查看 underscore 模块的信息。 $ npm info underscore 上面命令返回一个 JavaScript 对象，包含了 underscore 模块的详细信息。这个对象的每个成员，都可以直接从 info 命令查询。 $ npm info underscore description $ npm info underscore homepage $ npm info underscore version npm-searchnpm searchnpm search 命令用于搜索 npm 仓库，它后面可以跟字符串，也可以跟正则表达式。 $ npm search &lt;搜索词&gt; npm-listnpm listnpm list 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。 $ npm list # 加上 global 参数，会列出全局安装的模块 $ npm list -global # npm list 命令也可以列出单个模块 $ npm list underscore npm-installnpm install使用 npm 安装包的命令格式为：npm [install/i] [package_name] 本地模式和全局模式本地模式和全局模式npm 在默认情况下会从 NPM 搜索或下载包，将包安装到当前目录的 node_modules 子目录下。 如果你熟悉 Ruby 的 gem 或者 Python 的 pip ，你会发现 npm 与它们的行为不同， gem 或 pip 总是以全局模式安装，使包可以供所有的程序使用，而 npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。 我们在使用 supervisor 的时候使用了 npm install -g supervisor 命令，就是以全局模式安装 supervisor 。 这里注意一点的就是， supervisor 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 npm config set prefix &quot;路径&quot; 安装完以后就可以用 supervisor 来启动服务了。supervisor 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 Node 。 一般来说，全局安装只适用于工具模块，比如 eslint 和 gulp 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为 本地模式不会注册 PATH 环境变量。“本地安装”指的是将一个模块下载到当前项目的 node_modules 子目录，然后只有在项目目录之中，才能调用这个模块。 本地模式和全局模式的特点如下：模式可通过 require 使用注册 PATH本地模式是否全局模式否是 # 本地安装 $ npm install &lt;package name&gt; # 全局安装 $ sudo npm install -global &lt;package name&gt; $ sudo npm install -g &lt;package name&gt; npm install 也支持直接输入 Github 代码库地址。 $ npm install git://github.com/package/path.git $ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install 会先检查，node_modules 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过， npm 都要强制重新安装，可以使用 -f 或 --force 参数。 $ npm install &lt;packageName&gt; --force 安装不同版本安装不同版本install 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 @ 和版本号。 $ npm install sax@latest $ npm install sax@0.1.1 $ npm install sax@&quot;&gt;=0.1.0 &lt;0.2.0&quot; install 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 packages.json 文件的哪一项中。 –save：模块名将被添加到 dependencies，可以简化为参数-S。–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。 $ npm install sax --save $ npm install node-tap --save-dev # 或者 $ npm install sax -S $ npm install node-tap -D dependencies-依赖dependencies 依赖这个可以说是我们 npm 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 js 模块包。下面这段代码表示我们依赖了 markdown-it 这个包，版本是 ^8.1.0 ，代表最小依赖版本是 8.1.0 ，如果这个包有更新，那么当我们使用 npm install 命令的时候， npm 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。 &quot;dependencies&quot;: { &quot;markdown-it&quot;: &quot;^8.1.0&quot; } devDependencies-开发依赖devDependencies 开发依赖在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 devDependencies 的包，在别人引用的时候不会被 npm 下载。 &quot;devDependencies&quot;: { &quot;autoprefixer&quot;: &quot;^6.4.0&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;, &quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;, &quot;babel-register&quot;: &quot;^6.0.0&quot;, &quot;webpack&quot;: &quot;^1.13.2&quot;, &quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;, &quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot;, &quot;webpack-merge&quot;: &quot;^0.14.1&quot;, &quot;highlightjs&quot;: &quot;^9.8.0&quot; } 当你有了一个完整的 package.json文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 npm install 就可以很方便的下载好这个模块所需要的包。 npm install 默认会安装 dependencies 字段和 devDependencies 字段中的所有模块，如果使用 --production 参数，可以只安装 dependencies 字段的模块。 $ npm install --production # 或者 $ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用 require 命令加载这个模块。 var backbone = require(&apos;backbone&apos;) console.log(backbone.VERSION) npm-runnpm runnpm 不仅可以用于模块管理，还可以用于执行脚本。package.json 文件有一个 scripts 字段，可以用于指定脚本命令，供 npm 直接调用。package.json 文件内容： { &quot;name&quot;: &quot;myproject&quot;, &quot;devDependencies&quot;: { &quot;jshint&quot;: &quot;latest&quot;, &quot;browserify&quot;: &quot;latest&quot;, &quot;mocha&quot;: &quot;latest&quot; }, &quot;scripts&quot;: { &quot;lint&quot;: &quot;jshint **.js&quot;, &quot;test&quot;: &quot;mocha test/&quot; } } scripts-脚本scripts 脚本顾名思义，就是一些脚本代码，可以通过 npm run script-key 来调用，例如在这个 package.json 的文件夹下使用 npm run dev 就相当于运行了 node build/dev-server.js 这一段代码。使用 scripts 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。npm run 是 npm run-script 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。 // 脚本 &quot;scripts&quot;: { &quot;dev&quot;: &quot;node build/dev-server.js&quot;, &quot;build&quot;: &quot;node build/build.js&quot;, &quot;docs&quot;: &quot;node build/docs.js&quot;, &quot;build-docs&quot;: &quot;npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m &apos;auto-pages&apos; &amp; git push &amp; git checkout master&quot;, &quot;build-publish&quot;: &quot;rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push&quot;, &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot; } npm run 如果不加任何参数，直接运行，会列出 package.json 里面所有可以执行的脚本命令。npm 内置了两个命令简写， npm test 等同于执行 npm run test ，npm start 等同于执行 npm run start。 &quot;build&quot;: &quot;npm run build-js &amp;&amp; npm run build-css&quot; 上面的写法是先运行 npm run build-js ，然后再运行 npm run build-css ，两个命令中间用 &amp;&amp; 连接。如果希望两个命令同时平行执行，它们中间可以用 &amp; 连接。 写在 scripts 属性中的命令，也可以在 node_modules/.bin 目录中直接写成 bash 脚本。下面是一个 bash 脚本。 #!/bin/bash cd site/main browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为 build.sh ，并且权限为可执行，就可以在 scripts 属性中引用该文件。 &quot;build-js&quot;: &quot;bin/build.sh&quot; pre-和-post-脚本pre- 和 post- 脚本npm run 为每条命令提供了 pre- 和 post- 两个钩子（ hook ）。以 npm run lint 为例，执行这条命令之前， npm 会先查看有没有定义 prelint 和 postlint 两个钩子，如果有的话，就会先执行 npm run prelint ，然后执行 npm run lint ，最后执行 npm run postlint 。 { &quot;name&quot;: &quot;myproject&quot;, &quot;devDependencies&quot;: { &quot;eslint&quot;: &quot;latest&quot; &quot;karma&quot;: &quot;latest&quot; }, &quot;scripts&quot;: { &quot;lint&quot;: &quot;eslint --cache --ext .js --ext .jsx src&quot;, &quot;test&quot;: &quot;karma start --log-leve=error karma.config.js --single-run=true&quot;, &quot;pretest&quot;: &quot;npm run lint&quot;, &quot;posttest&quot;: &quot;echo &apos;Finished running tests&apos;&quot; } } 上面代码是一个 package.json 文件的例子。如果执行 npm test，会按下面的顺序执行相应的命令。 pretest test posttest 如果执行过程出错，就不会执行排在后面的脚本，即如果 prelint 脚本执行出错，就不会接着执行 lint 和 postlint 脚本。 npm-binnpm binnpm bin 命令显示相对于当前目录的，Node 模块的可执行脚本所在的目录（即 .bin 目录）。 # 项目根目录下执行 $ npm bin ./node_modules/.bin 创建全局链接创建全局链接npm 提供了一个有趣的命令 npm link，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用。但通过 npm link 命令可以打破这一限制。举个例子，我们已经通过 npm install -g express 安装了 express ，这时在工程的目录下运行命令：npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express我们可以在 node_modules 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。除了将全局的包链接到本地以外，使用 npm link 命令还可以将本地的包链接到全局。使用方法是在包目录（package.json 所在目录）中运行 npm link 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。 创建包创建包包是在模块基础上更深一步的抽象，Node 的包类似于 C/C++ 的函数库或者 Java 、.Net 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。Node 根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。Node 的包是一个目录，其中包含了一个 JSON 格式的包说明文件 package.json。严格符合 CommonJS 规范的包应该具备以下特征： package.json 必须在包的顶层目录下； 二进制文件应该在 bin 目录下； JavaScript 代码应该在 lib 目录下； 文档应该在 doc 目录下； 单元测试应该在 test 目录下。 Node 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。 我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 package.json，我们可以创建更复杂，更完善，更符合规范的包用于发布。 Node 在调用某个包时，会首先检查包中 packgage.json 文件的 main 字段，将其作为包的接口模块，如果 package.json 或 main 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。 package.json 是 CommonJS 规定的用来描述包的文件，完全符合规范的 package.json 文件应该含有以下字段：name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。description: 包的简要说明。version: 符合语义化版本识别规范的版本字符串。keywords: 关键字数组，通常用于搜索。maintainers: 维护者数组，每个元素要包含 name 、 email(可选)、 web(可选)字段。contributors: 贡献者数组，格式与 maintainers 相同。包的作者应该是贡献者数组的第一个元素。bugs: 提交 bug 的地址，可以是网址或者电子邮件地址。licenses: 许可证数组，每个元素要包含 type （许可证的名称）和 url（链接到许可证文本的地址）字段。repositories: 仓库托管地址数组，每个元素要包含 type （仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。 包的发布包的发布通过使用 npm init 可以根据交互式回答产生一个符合标准的 package.json。创建一个 index.js 作为包的接口,一个简单的包就制作完成了。在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 npm adduser 根据提示完成账号的创建完成后可以使用 npm whoami 检测是否已经取得了账号。接下来,在 package.json 所在目录下运行 npm publish，稍等片刻就可以完成发布了，打开浏览器，访问 NPM搜索 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 npm install neveryumodule 命令来安装它。如果你的包将来有更新,只需要在 package.json 文件中修改 version 字段,然后重新使用 npm publish命令就行了。如果你对已发布的包不满意，可以使用 npm unpublish 命令来取消发布。 需要说明的是： json 文件不能有注释 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package.json 好处 1.以json文件格式定义项目所依赖的包； 2.确定每个包的使用版本； 3.项目构建可重复，多人协助公用一套基础代码； 4.npm init 初始化 【必须含有的两个：name 和 version】 &#123; &quot;name&quot;: &quot;react-redux-webpack&quot;, &quot;version&quot;: &quot;1.1.0&quot;, &#125;devDependencies ：开发环境和测试环境所依赖的包列表dependencies ：在生产环境使用的依赖包列表 dependencies下记录的是项目在运行时必须依赖的插件，常见的例如react jquery等，即及时项目打包好了、上线了， 这些也是需要用的，否则程序无法正常执行。 devDependencies下记录的是项目在开发过程中使用的插件，例如这里我们开发过程中需要使用webpack打包， 而我在工作中使用fis3打包，但是一旦项目打包发布、上线了之后，webpack和fis3就都没有用了，可卸磨杀驴。本地安装 npm install --save|--save-dev 分别写入 dependencies|devDependencies 中；简写： npm i -S pkg | npm i -D pkg包（package)和模块（module）包：package.json 文件所描述的文件夹或者文件，符合CommonJS规范模块：任何被node.js中的require所载入的文件~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0* 这意味着安装最新版本的依赖包常用命令: npm init -y //强制生成 npm init //在项目中引导创建一个package.json文件 npm search mkdir //寻找包使用npm search命令 npm help //查看某条命令的详细帮助 npm root //查看包的安装路径 npm config //管理npm的配置路径 npm prefix -g //查看全局安装的包位置 -g全局 npm cache //管理模块的缓存 ,可以使用下面命令，偶尔清楚一下缓存： eg: npm cache clean npm info webpack //查看webpack 版本信息 npm install pkg //安装模块 简写：npm i pkg ,带版本: npm install underscore@1.8.2 npm uninstall //卸载模块 eg: npm uninstall webpack npm update // 更新模块 npm update underscore npm outdated //检查模块是否已经过时 npm ls //查看安装的模块 npm list //可以查看全局路径下的所有包 eg: npm list --global //也可以使用--depth=0来缩短返回的结果 eg: npm list -g --depth=0 npm stop //停止模块 npm restart //重新启动模块 npm test //测试模块 npm version //查看模块版本 npm publish //发布模块简写: npm i – 安装包 npm i -g – 安装包到全局下 npm un – 删除本地下包 npm up – 更新包 npm t – 运行测试 npm ls – 罗列已经安装包 npm ll or npm la – 罗列包时显示额外信息 npm i express momemt lodash mongoose webpack //也可以一次安装多个包 yarn cache clean //删除电脑上所有 yarn 安装的缓存 yarn //命令安装项目相关依赖 yarn cache dir //获取缓存文件夹地址]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.vue文件的一个小细节]]></title>
    <url>%2F2018%2F03%2F02%2Fvue%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[top.vue &lt;template&gt; &lt;div class=&quot;ds&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;p&gt;SX&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;p&gt;SB&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; console.log(&quot;-------------------------&quot;); //只执行一次 export default { props: [], data() { return {} }, components: { }, methods: { }, created() { }, mounted() { console.log(&quot;$$$$$$$$$$$$$$$$$$$$$$$&quot;)； //执行多次 } }; &lt;/script&gt; &lt;style lang=&quot;scss&quot; scoped=&quot;scoped&quot;&gt; .guize { box-sizing: border-box; padding: 0 0.4rem; margin-top: -0.3rem; width: 100%; height: 1.2rem; font-size: 0.24rem; color: white; position: relative; .left { color: #abc4ed; float: left; transform:scale(0.85); transform-origin:0 0; p { font-size: 0.24rem; line-height: 2; } } .right { float: left; width: 1.6rem; height: 0.44rem; line-height: 0.44rem; border: 1px solid white; color: white; border-radius: 0.24rem; text-align: center; position: absolute; right: 0.4rem; bottom: 0.04rem; } } &lt;/style&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 继承]]></title>
    <url>%2F2018%2F03%2F02%2FJS-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[众所周知，在 ES 6 之前没有类的概念，所以不能像 Java 中一个 extends 关键字就搞定了继承关系，需要一些 tricks 来实现，下面就介绍一些比较常用的方法。 (一) 原型链继承：function Parent(name) { this.name = name; } Parent.prototype.sayName = function() { console.log(&apos;parent name:&apos;, this.name); } function Child(name) { this.name = name; } Child.prototype = new Parent(&apos;father&apos;); Child.prototype.constructor = Child; Child.prototype.sayName = function() { console.log(&apos;child name:&apos;, this.name); } var child = new Child(&apos;son&apos;); child.sayName(); // child name: son 只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。 这种方法存在两个缺点： 子类型无法给超类型传递参数，在面向对象的继承中，我们总希望通过 var child = new Child(‘son’, ‘father’); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent(‘father’) 去调用父类。 Child.prototype.sayName 必须写在 Child.prototype = new Parent(‘father’); 之后，不然就会被覆盖掉。 (二) 类式继承：function Parent(name) { this.name = name; } Parent.prototype.sayName = function() { console.log(&apos;parent name:&apos;, this.name); } Parent.prototype.doSomthing = function() { console.log(&apos;parent do something!&apos;); } function Child(name, parentName) { Parent.call(this, parentName); this.name = name; } Child.prototype.sayName = function() { console.log(&apos;child name:&apos;, this.name); } var child = new Child(&apos;son&apos;); child.sayName(); // child name: son child.doSomthing(); // TypeError: child.doSomthing is not a function 相当于 Parent 这个函数在 Child 函数中执行了一遍，并且将所有与 this 绑定的变量都切换到了 Child 上，这样就克服了第一种方式带来的问题。 缺点： 没有原型，每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。 (三) 组合式继承：前两种方式的结合function Parent(name) { this.name = name; } Parent.prototype.sayName = function() { console.log(&apos;parent name:&apos;, this.name); } Parent.prototype.doSomething = function() { console.log(&apos;parent do something!&apos;); } function Child(name, parentName) { Parent.call(this, parentName); this.name = name; } Child.prototype.sayName = function() { console.log(&apos;child name:&apos;, this.name); } Child.prototype = new Parent(); Child.prototype.construtor = Child; var child = new Child(&apos;son&apos;); child.sayName(); // child name: son child.doSomething(); // parent do something! 组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 组合式继承是 JS 最常用的继承模式，但组合继承使用过程中会被调用两次：一次是创建子类型的时候，另一次是在子类型构造函数的内部。 function Parent(name) { this.name = name; } Parent.prototype.sayName = function() { console.log(&apos;parent name:&apos;, this.name); } Parent.prototype.doSomething = function() { console.log(&apos;parent do something!&apos;); } function Child(name, parentName) { Parent.call(this, parentName); // 第二次调用 this.name = name; } Child.prototype.sayName = function() { console.log(&apos;child name:&apos;, this.name); } Child.prototype = new Parent(); // 第一次调用 Child.prototype.construtor = Child; var child = new Child(&apos;son&apos;); child.sayName(); child.doSomething(); 显然从上述的代码中可以看出，第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了，所以这时候你可能会这样写： Child.prototype = Parent.prototype; 这样写显然是不对的： 首先，你这样写的话相当于是子类和父类都指向同一个对象，这时候如果你添加了新的方法给 Child 但实际上 Parent 并不需要，相当于强行给 Parent 添加了一个未知的方法。 其次，仔细想想，这样体现不出继承的多态性，比如此时子类想要重写父类的 getName 的方法，那么父类的方法也就会随之修改，这显然违背了多态性。 也就是说我们第一次调用构造函数的时候，其实是不管构造函数里面的内容，所以我们何不 new 一个空函数，将其 prototype 指向 Parent.prototype，代码如下： (四) 寄生组合式继承：function Parent(name) { this.name = name; } Parent.prototype.sayName = function() { console.log(&apos;parent name:&apos;, this.name); } function Child(name, parentName) { Parent.call(this, parentName); this.name = name; } function create(proto) { function F(){} F.prototype = proto; F.prototype.construtor = F; return new F(); } Child.prototype = create(Parent.prototype); Child.prototype.sayName = function() { console.log(&apos;child name:&apos;, this.name); } Child.prototype.construtor = Child; var parent = new Parent(&apos;father&apos;); parent.sayName(); // parent name: father var child = new Child(&apos;son&apos;, &apos;father&apos;); child.sayName(); // child name: son 这就是所谓的寄生组合式继承方式，跟组合式继承的区别在于，他不需要在一次实例中调用两次父类的构造函数，假如说父类的构造器代码很多，还需要调用两次的话对系统肯定会有影响，寄生组合式继承的思想在于：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。 在上面的代码中，我们手动创建了一个 create 函数，但是其实是存在于 Object 对象中，不需要我们手动去创建，所以上面的代码可以改为： function Parent(name) { this.name = name; } Parent.prototype.sayName = function() { console.log(&apos;parent name:&apos;, this.name); } function Child(name, parentName) { Parent.call(this, parentName); this.name = name; } function inheritPrototype(Parent, Child) { Child.prototype = Object.create(Parent.prototype); //修改 Child.prototype.construtor = Child; } inheritPrototype(Parent, Child); Child.prototype.sayName = function() { console.log(&apos;child name:&apos;, this.name); } var parent = new Parent(&apos;father&apos;); parent.sayName(); // parent name: father var child = new Child(&apos;son&apos;, &apos;father&apos;); child.sayName(); // child name: son (五) ES 6 继承：当然，如果你学习过 ES 6，那么写继承关系就会特别简单，如果你学过 Java 就会发现，ES 6 中的继承跟 Java 太像了，上述的代码可改为： class Parent { constructor(name) { this.name = name; } doSomething() { console.log(&apos;parent do something!&apos;); } sayName() { console.log(&apos;parent name:&apos;, this.name); } } class Child extends Parent { constructor(name, parentName) { super(parentName); this.name = name; } sayName() { console.log(&apos;child name:&apos;, this.name); } } const child = new Child(&apos;son&apos;, &apos;father&apos;); child.sayName(); // child name: son child.doSomething(); // parent do something! const parent = new Parent(&apos;father&apos;); parent.sayName(); // parent name: father JavaScript前端开发 JavaScript(ES5)中没有像Java那样类的概念，写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。但是我们可以通过原型链prototype来模拟类，去实现继承的相关功能。下面来看看ES5中实现继承常见的三种方法。代码如下： /** * JavaScript(ES5)中实现继承的几种方法 */ // 定义基类Person function Person(name, age) { this.name = name; this.age = age; } // 共享数据 Person.prototype.LEGS_NUM = 2; // 共享方法 Person.prototype.info = function () { console.log(&apos;My name is &apos; + this.name + &apos; .I\&apos;m &apos; + this.age + &apos; years old now&apos;); }; Person.prototype.walk = function () { console.log(this.name + &apos; is walking...&apos;); }; // Student子类 function Student(name, age, className) { // 调用父类 Person.call(this, name, age); this.className = className; } // 1⃣️ 方法一：Person.prototype直接赋值给Student.prototype // Student.prototype = Person.prototype; // 2⃣️ 方法二：Student.prototype为Person的实例 // Student.prototype = new Person(); // 3⃣️ 方法三：创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; // 覆盖父类的info方法 Student.prototype.info = function () { console.log(&apos;My name is &apos; + this.name + &apos;,I\&apos;m &apos; + this.age + &apos; years old now, and from class &apos; + this.className + &apos;.&apos;); }; // Student类的共享方法 Student.prototype.learn = function (subject) { console.log(this.name + &apos; is learning &apos; + subject + &apos;.&apos;); }; // 测试,创建一个Student的实例 var microzz = new Student(&apos;Microzz&apos;, 22, 5); microzz.info(); // My name is Microzz,I&apos;m 22 years old now, and from class 5. console.log(microzz.LEGS_NUM); // 2 microzz.walk(); // Microzz is walking... microzz.learn(&apos;JavaScript&apos;); // Microzz is learning JavaScript. console.log(microzz.__proto__.__proto__ === Person.prototype); // true console.log(microzz.__proto__ === Student.prototype); // true console.log(microzz.__proto__.constructor === Student); // true 三种方法比较 上面代码中有三种方法实现继承，现在我们可以来分析一下这几种方法。1⃣️这种方法中，Person.prototype直接赋值给Student.prototype，但是有一个很严重的问题，如果子类prototype添加新的东西的话也会改写父类。所以这种方法不推荐。2⃣️第二种方法Student.prototype为Person的实例，这也是可以实现的。但是Person构造函数有参数应该传什么呢？传任何一个都是很奇怪的。所以也不推荐。3⃣️第三种方法是比较理想的，创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype。但是Object.create也有一点小瑕疵，因为它是ES5之后才支持的，不过我们可以通过模拟实现Object.create方法。代码如下： if (!Object.create) { Object.prototype.create = function (proto) { function F() {} F.prototype = proto; return new F; } } 这样在ES5中就完美实现了继承😄 ES6中的实现概述 ES6提供了更接近传统语言”类”的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。下面我们用ES6的语法实现类的继承。 代码 // 基类 Person class Person { // 父类的构造方法 constructor(name, age) { this.name = name; this.age = age; // 共享变量 this.LEGS_NUM = 2; } // 父类的info方法 info() { console.log(`My name is ${this.name}, I\&apos;m ${this.age} years old now.`); } // 父类的walk方法 walk() { console.log(this.name + &apos; is walking...&apos;); } } // 子类 Student class Student extends Person { constructor(name, age, className) { // 调用基类的构造方法 super(name, age); this.className = className; } // 覆盖父类的info方法 info() { console.log(`My name is ${this.name}, I\&apos;m ${this.age} years old, and from class ${this.className}.`); } } // 实例化一个Student的实例 let stu = new Student(&apos;Zhaohui&apos;, 22, 5); stu.info(); // My name is Zhaohui, I&apos;m 22 years old, and from class 5. stu.walk(); // Zhaohui is walking... console.log(stu.LEGS_NUM); // 2 console.log(stu instanceof Student); // true console.log(stu instanceof Person); // true 这样我们就通过ES6中的class实现了“类”的继承了😄]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue大数据渲染虚拟滚动列表]]></title>
    <url>%2F2018%2F01%2F02%2FVue%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B8%B2%E6%9F%93%E8%99%9A%E6%8B%9F%E6%BB%9A%E5%8A%A8%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Github：tangbc/vue-virtual-scroll-list ; (function(root, factory) { var namespace = &apos;VirtualScrollList&apos; if(typeof exports === &apos;object&apos; &amp;&amp; typeof module === &apos;object&apos;) { module.exports = factory(namespace, require(&apos;vue&apos;)) } else if(typeof define === &apos;function&apos; &amp;&amp; define.amd) { define([&apos;vue&apos;], factory.bind(root, namespace)) } else if(typeof exports === &apos;object&apos;) { exports[namespace] = factory(namespace, require(&apos;vue&apos;)) } else { root[namespace] = factory(namespace, root[&apos;Vue&apos;]) } })(this, function(namespace, Vue2) { if(typeof Vue2 === &apos;object&apos; &amp;&amp; typeof Vue2.default === &apos;function&apos;) { Vue2 = Vue2.default } var _debounce = function(func, wait, immediate) { var timeout return function() { var context = this var args = arguments var later = function() { timeout = null if(!immediate) { func.apply(context, args) } } var callNow = immediate &amp;&amp; !timeout clearTimeout(timeout) timeout = setTimeout(later, wait) if(callNow) { func.apply(context, args) } } } return Vue2.component(namespace, { props: { size: { type: Number, required: true }, remain: { type: Number, required: true }, rtag: { type: String, default: &apos;div&apos; }, wtag: { type: String, default: &apos;p&apos; }, wclass: { type: String, default: &apos;&apos; }, start: { type: Number, default: 0 }, offset: { type: Number, default: 0 }, variable: [Function, Boolean], bench: Number, debounce: Number, totop: Function, tobottom: Function, onscroll: Function }, data(){ return { delta:{} } }, created: function() { // :size=&quot;60&quot; :remain=&quot;6&quot; :bench=&quot;44&quot; class=&quot;list&quot; :start=&quot;startIndex&quot; var start = this.start &gt;= this.remain ? this.start : 0 var keeps = this.remain + (this.bench || this.remain) console.log(start) console.log(keeps) this.delta = { start: start, // start index. //起始index end: start + keeps - 1, // end index. //显示列表last index keeps: keeps, // nums keeping in real dom. //要显示的列表数据 total: 0, // all items count, update in filter. //总的列表数据 offsetAll: 0, // cache all the scrollable offset. paddingTop: 0, // container wrapper real padding-top. paddingBottom: 0, // container wrapper real padding-bottom. varCache: {}, // object to cache variable index height and scroll offset. varAverSize: 0, // average/estimate item height before variable be calculated. varLastCalcIndex: 0 // last calculated variable height/offset index, always increase. } }, watch: { size: function() { this.alter = &apos;size&apos; }, remain: function() { this.alter = &apos;remain&apos; }, bench: function() { this.alter = &apos;bench&apos; }, start: function() { this.alter = &apos;start&apos; }, offset: function() { this.alter = &apos;offset&apos; } }, methods: { onScroll: function(e) { var delta = this.delta var offset = this.$refs.vsl.scrollTop if(delta.total &gt; delta.keeps) { this.updateZone(offset) } else { delta.end = delta.total - 1 } var offsetAll = delta.offsetAll if(this.onscroll) { this.onscroll(e, { offset: offset, offsetAll: offsetAll, start: delta.start, end: delta.end }) } if(!offset &amp;&amp; delta.total) { this.triggerEvent(&apos;totop&apos;) } if(offset &gt;= offsetAll) { this.triggerEvent(&apos;tobottom&apos;) } }, // update render zone by scroll offset. updateZone: function(offset) { var overs = this.variable ? this.getVarOvers(offset) : Math.floor(offset / this.size) var delta = this.delta var zone = this.getZone(overs) var bench = this.bench || this.remain // for better performance, if scroll pass items within now bench, do not update. if(!zone.isLast &amp;&amp; (overs &gt; delta.start) &amp;&amp; (overs - delta.start &lt;= bench)) { return } delta.end = zone.end delta.start = zone.start this.$forceUpdate() }, // return the scroll passed items count in variable. getVarOvers: function(offset) { var low = 0 var middle = 0 var middleOffset = 0 var delta = this.delta var high = delta.total while(low &lt;= high) { middle = low + Math.floor((high - low) / 2) middleOffset = this.getVarOffset(middle) // calculate the average variable height at first binary search. if(!delta.varAverSize) { delta.varAverSize = Math.floor(middleOffset / middle) } if(middleOffset === offset) { return middle } else if(middleOffset &lt; offset) { low = middle + 1 } else if(middleOffset &gt; offset) { high = middle - 1 } } return low &gt; 0 ? --low : 0 }, // return a variable scroll offset from given index. getVarOffset: function(index, nocache) { var delta = this.delta var cache = delta.varCache[index] if(!nocache &amp;&amp; cache) { return cache.offset } var offset = 0 for(var i = 0; i &lt; index; i++) { var size = this.getVarSize(i, nocache) delta.varCache[i] = { size: size, offset: offset } offset += size } delta.varLastCalcIndex = Math.max(delta.varLastCalcIndex, index - 1) delta.varLastCalcIndex = Math.min(delta.varLastCalcIndex, delta.total - 1) return offset }, // return a variable size (height) from given index. getVarSize: function(index, nocache) { var cache = this.delta.varCache[index] if(!nocache &amp;&amp; cache) { return cache.size } if(typeof this.variable === &apos;function&apos;) { return this.variable(index) || 0 } else { var slot = this.$slots.default[index] var style = slot &amp;&amp; slot.data &amp;&amp; slot.data.style if(style &amp;&amp; style.height) { var shm = style.height.match(/^(.*)px$/) return(shm &amp;&amp; +shm[1]) || 0 } } return 0 }, // return the variable paddingTop base current zone. // @todo: if set a large `start` before variable was calculated, // here will also case too much offset calculate when list is very large, // consider use estimate paddingTop in this case just like `getVarPaddingBottom`. getVarPaddingTop: function() { return this.getVarOffset(this.delta.start) }, // return the variable paddingBottom base current zone. getVarPaddingBottom: function() { var delta = this.delta var last = delta.total - 1 if(delta.total - delta.end &lt;= delta.keeps || delta.varLastCalcIndex === last) { return this.getVarOffset(last) - this.getVarOffset(delta.end) } else { // if unreached last zone or uncalculate real behind offset // return the estimate paddingBottom avoid too much calculate. return(delta.total - delta.end) * (delta.varAverSize || this.size) } }, // retun the variable all heights use to judge reach bottom. getVarAllHeight: function() { var delta = this.delta if(delta.total - delta.end &lt;= delta.keeps || delta.varLastCalcIndex === delta.total - 1) { return this.getVarOffset(delta.total) } else { return this.getVarOffset(delta.start) + (delta.total - delta.end) * (delta.varAverSize || this.size) } }, // the ONLY ONE public method, allow the parent update variable by index. updateVariable: function(index) { // clear/update all the offfsets and heights ahead of index. this.getVarOffset(index, true) }, // return the right zone info base on `start/index`. getZone: function(index) { var start, end var delta = this.delta index = parseInt(index, 10) index = Math.max(0, index) var lastStart = delta.total - delta.keeps var isLast = (index &lt;= delta.total &amp;&amp; index &gt;= lastStart) || (index &gt; delta.total) if(isLast) { end = delta.total - 1 start = Math.max(0, lastStart) } else { start = index end = start + delta.keeps - 1 } return { end: end, start: start, isLast: isLast } }, // trigger a props event on parent. triggerEvent: function(event) { if(this[event]) { this[event]() } }, // set manual scroll top. setScrollTop: function(scrollTop) { this.$refs.vsl.scrollTop = scrollTop }, // filter the shown items base on `start` and `end`. filter: function() { var delta = this.delta var slots = this.$slots.default if(!slots) { slots = [] delta.start = 0 } delta.total = slots.length var paddingTop, paddingBottom, allHeight; var hasPadding = delta.total &gt; delta.keeps if(this.variable) { allHeight = this.getVarAllHeight() paddingTop = hasPadding ? this.getVarPaddingTop() : 0 paddingBottom = hasPadding ? this.getVarPaddingBottom() : 0 } else { allHeight = this.size * delta.total paddingTop = this.size * (hasPadding ? delta.start : 0) paddingBottom = this.size * (hasPadding ? delta.total - delta.keeps : 0) - paddingTop } delta.paddingTop = paddingTop delta.paddingBottom = paddingBottom delta.offsetAll = allHeight - this.size * this.remain //总高度减去窗口的高度 return slots.filter(function(slot, index) { return index &gt;= delta.start &amp;&amp; index &lt;= delta.end }) } }, mounted: function() { if(this.start) { var start = this.getZone(this.start).start this.setScrollTop(this.variable ? this.getVarOffset(start) : start * this.size) } else if(this.offset) { this.setScrollTop(this.offset) } }, // check if delta should update when prorps change. beforeUpdate: function() { var delta = this.delta delta.keeps = this.remain + (this.bench || this.remain) var calcstart = this.alter === &apos;start&apos; ? this.start : delta.start var zone = this.getZone(calcstart) // if start, size or offset change, update scroll position. if(~[&apos;start&apos;, &apos;size&apos;, &apos;offset&apos;].indexOf(this.alter)) { this.$nextTick(this.setScrollTop.bind(this, this.alter === &apos;offset&apos; ? this.offset : this.variable ? this.getVarOffset(zone.isLast ? delta.total : zone.start) : zone.isLast ? delta.total * this.size : zone.start * this.size)) } // if points out difference, force update once again. if(calcstart !== zone.start || delta.end !== zone.end || this.alter) { this.alter = &apos;&apos; delta.end = zone.end delta.start = zone.start this.$forceUpdate() } }, render: function(h) { var list = this.filter() var delta = this.delta var dbc = this.debounce console.log(list) return h(this.rtag, { &apos;ref&apos;: &apos;vsl&apos;, &apos;style&apos;: { &apos;display&apos;: &apos;block&apos;, &apos;overflow-y&apos;: &apos;auto&apos;, &apos;height&apos;: this.size * this.remain + &apos;px&apos; }, &apos;on&apos;: { &apos;scroll&apos;: dbc ? _debounce(this.onScroll.bind(this), dbc) : this.onScroll } }, [ h(this.wtag, { &apos;style&apos;: { &apos;display&apos;: &apos;block&apos;, &apos;padding-top&apos;: delta.paddingTop + &apos;px&apos;, &apos;padding-bottom&apos;: delta.paddingBottom + &apos;px&apos; }, &apos;class&apos;: this.wclass }, list) ]) } }) }) &lt;template&gt; &lt;div class=&quot;appWraper&quot;&gt; &lt;div class=&quot;scrollToIndex&quot;&gt; &lt;span&gt;Scroll to index: &lt;/span&gt; &lt;input type=&quot;text&quot; v-model.number.lazy=&quot;startIndex&quot;&gt; &lt;small&gt;Change and blur to set start index.&lt;/small&gt; &lt;/div&gt; &lt;VirtualList :size=&quot;60&quot; :remain=&quot;6&quot; :bench=&quot;24&quot; class=&quot;list&quot; :start=&quot;startIndex&quot;&gt; &lt;Item v-for=&quot;(udf, index) of items&quot; :index=&quot;index&quot; :key=&quot;index&quot;&gt;&lt;/Item&gt; &lt;/VirtualList&gt; &lt;div class=&quot;source&quot;&gt; &lt;a href=&quot;https://github.com/tangbc/vue-virtual-scroll-list/blob/master/examples/finite/finite.vue#L1&quot;&gt; View this demo source code &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Item from &apos;./item.vue&apos; import VirtualList from &apos;./VirtualScrollList.js&apos; export default { name: &apos;finite-test&apos;, components: { Item, VirtualList }, data() { return { startIndex: 9, items: new Array(100) } } } &lt;/script&gt; &lt;style&gt; body { background: #fffaf0; } .appWraper { width: 440px; margin: 0 auto; overflow-y: auto; } .title { font-size: 25px; font-weight: 100; text-align: center; } @media (max-width: 640px) { .appWraper { width: 100%; } .title { font-size: 16px; } } .scrollToIndex { padding-bottom: 20px; } input { outline: none; padding: .4em .5em; width: 55px; height: 16px; border-radius: 3px; border: 1px solid; border-color: #dddddd; font-size: 16px; -webkit-appearance: none; -moz-appearance: none; appearance: none; } input:focus { border-color: #6495ed; } small { color: #999; } .list { background: #fff; border-radius: 3px; border: 1px solid #ddd; -webkit-overflow-scrolling: touch; overflow-scrolling: touch; } .source { text-align: center; padding-top: 20px; } .source a { color: #999; text-decoration: none; font-weight: 100; } @media (max-width: 640px) { small { display: none; } } &lt;/style&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise的模拟实现]]></title>
    <url>%2F2017%2F12%2F20%2Fpromise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[1.概述1.1 什么是promisePromise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。 1.2 promise解决的问题1.2.1 回调地狱Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。 1.2.2 并行结果如果几个异步操作之间并没有前后顺序之分,但需要等多个异步操作都完成后才能执行后续的任务，无法实现并行节约时间。 1.3 promise简介在 ES6 Promises 标准中定义的API还不是很多，目前大致有下面三种类型。 1.3.1 consturctor首先，Promise 是一个对象，也是一个构造函数。 functionf1(resolve, reject) { // 异步代码... } var promise = newPromise(f1); 1.3.2 Instance MethodPromise对象通过自身的状态，来控制异步操作。Promise实例具有三种状态。 异步操作未完成（pending） 异步操作成功（fulfilled） 异步操作失败（rejected） 这三种的状态的变化途径只有两种。 从“未完成”到“成功” 从“未完成”到“失败” 所以Promise的最终结果只有两个, 异步操作成功，Promise实例传回一个值（value）,状态变为fulfilled。 异步操作失败，Promise 实例抛出一个错误（error）,状态变为rejected。 promise.then(onFulfilled, onRejected) // resolve(成功)时,onFulfilled 会被调用// reject(失败)时,onRejected 会被调用 1.3.3 Static Method像 Promise这样的全局对象还拥有一些静态方法。包括 Promise.all()还有Promise.resolve() 等在内，主要都是一些对Promise进行操作的辅助方法。 2.Promise的实现2.1 resolve和rejectresolve和reject都是函数 //构造函数中functionPromise(executor) { let self = this; /*初始化status*/ self.status = &apos;pending&apos;; /*初始化value*/ self.value = undefined; /*订阅事件的数组*/ self.onResolvedCallBacks = []; self.onRejectedCallBacks = []; /*此函数将Promise实例的状态由pending 转化为 fulfilled*/functionresolve(value) { if (value instanceofPromise) { return value.then(resolve, reject); } setTimeout(function () { if (self.status === &apos;pending&apos;) { self.status = &apos;fulfilled&apos;; self.value = value; /*发布已经订阅过的事件*/ self.onResolvedCallBacks.forEach(item =&gt; item(self.value)) } }, 0) } /*此函数将Promise实例的状态由pending 转化为 rejected*/functionreject(reason) { setTimeout(function () { if (self.status === &apos;pending&apos;) { self.status = &apos;rejected&apos;; self.value = reason; /*发布已经订阅过的事件*/ self.onRejectedCallBacks.forEach(item =&gt; item(self.value)) } }, 0) } // new Promise 的时候，执行器（executor）的代码会立即执行try { executor(resolve, reject); } catch (e) { reject(e); } } 2.2 then方法promise成功后，onFullfilled会被调用。并且把promise的值当做它的第一个参数。promise在成功之前，不会调用它，并且只能被调用一次。reject也一样。 // 先封装一个方法 function resolvePromise(promise2,x,resolve,reject){ // if(promise2 === x){ return reject(new TypeError(&apos;循环引用&apos;)); } // 为了防止resolve和reject同时调用 let called = false;//promise2是否已经resolve 或reject了 if(x instanceof Promise){ if(x.status == PENDING){ x.then(function(y){ resolvePromise(promise2,y,resolve,reject); },reject); }else{ x.then(resolve,reject); } //x是一个thenable对象或函数，只要有then方法的对象， }elseif(x!= null &amp;&amp;((typeof x==&apos;object&apos;)||(typeof x == &apos;function&apos;))){ //当我们的promise和别的promise进行交互，编写这段代码的时候尽量的考虑兼容性， //允许别人瞎写，x可以是对象，也可以是函数 try{ letthen = x.then; if(typeof then == &apos;function&apos;){ //有些promise会同时执行成功和失败的回调 then.call(x,function(y){ //如果promise2已经成功或失败了，则不会再处理了 if(called)return; called = true; resolvePromise(promise2,y,resolve,reject) },function(err){ if(called)return; called = true; reject(err); }); }else{ //到此的话x不是一个thenable对象，那直接把它当成值resolve promise2就可以了 // 当返回一个对象 {name:&apos;a&apos;,then:{age:8}},对象里的then不是thenable对象 resolve(x); } }catch(e){ if(called)return; called = true; reject(e); } }else{ //如果X是一个普通 的值，则用x的值去resolve promise2 resolve(x); } } Promise.prototype.then = function(onFulfilled,onRejected){ //如果成功和失败的回调没有传，则表示这个then没有任何逻辑，只会把值往后抛,叫做值的穿透 // 例如：promise.then().then().then(function(data){},function(err){}) onFulfilled = typeof onFulfilled == &apos;function&apos;?onFulfilled:function(value){return value}; onRejected = typeof onRejected == &apos;function&apos;?onRejected:reason=&gt;{throw reason}; //如果当前promise状态已经是成功态了，onFulfilled直接取值 let self = this; let promise2; if(self.status == FULFILLED){ return promise2 = new Promise(function(resolve,reject){ setTimeout(function(){ try{ let x =onFulfilled(self.value); //如果获取到了返回值x,会走解析promise的过程 resolvePromise(promise2,x,resolve,reject); }catch(e){ //如果执行成功的回调过程中出错了，用错误原因把promise2 reject reject(e); } }) }); } if(self.status == REJECTED){ return promise2 = new Promise(function(resolve,reject){ setTimeout(function(){ try{ let x =onRejected(self.value); resolvePromise(promise2,x,resolve,reject); }catch(e){ reject(e); } }) }); } if(self.status == PENDING){ return promise2 = new Promise(function(resolve,reject){ self.onResolvedCallbacks.push(function(){ try{ let x =onFulfilled(self.value); //如果获取到了返回值x,会走解析promise的过程 resolvePromise(promise2,x,resolve,reject); }catch(e){ reject(e); } }); self.onRejectedCallbacks.push(function(){ try{ let x =onRejected(self.value); resolvePromise(promise2,x,resolve,reject); }catch(e){ reject(e); } }); }); } } 2.2 catch方法Promise.prototype.catch=function (callback) { returnthis.then(null,callback); } ---------使用------- let promise = newPromise(function (resolve, reject) { reject(&apos;错误&apos;); }) promise.then(function(data){console.log(data)}).catch(e=&gt;{console.log(e)}); 2.3 all 方法Promise.all = function (promises) { returnnewPromise(function (resolve,reject) { let arr =[];//arr是最终返回值的结果的集合。let j =0; functionprocessData(i,data){// 每调用一次此函数，j就会+1； arr[i] = data;// 每次成功的结果都放入数组中if(++j===promises.length){ resolve(arr); //只有promises中的最后一个成功，才能调用resolve方法。 } } for(let i=0;i&lt;promises.length;i++){ promises[i].then(function (data) { processData(i,data); },reject)// 如果有一个失败，整体就会失败 } }) } 使用方法： functionread(file) { returnnew Promise1(function (resolve, reject) { require(&apos;fs&apos;).readFile(file,&apos;utf8&apos;,function (err, data) { resolve(data); }) }) } Promise1.all([read(&apos;./1.txt&apos;),read(&apos;./2.txt&apos;)]).then(function (data) { console.log(data) }) // [&apos;file1&apos;,&apos;file2&apos;] 2.4 race 方法只要有一个promise成功，就会执行成功的回调，参数是由promise组成的数组 Promise.race=function (promises) { return new Promise(function (resolve, reject) { for(let i=0;i&lt;promises.length;i++){ promises[i].then(resolve,reject); } }) } 2.5 resolve方法Promise.resolve = function (value) { return new Promise(function (resolve, reject) { resolve(value) }) } 2.6 reject 方法Promise.reject = function (reason) { return new Promise(function (resolve, reject) { reject(reason); }) } 3.Promise对象的缺点： 1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。 2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 3、当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。]]></content>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call和apply的第一个参数是null/undefined时函数内的的this指向window或global]]></title>
    <url>%2F2017%2F11%2F11%2Fcall%E5%92%8Capply%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AFnull-undefined%E6%97%B6%E5%87%BD%E6%95%B0%E5%86%85%E7%9A%84%E7%9A%84this%E6%8C%87%E5%90%91window%E6%88%96global%2F</url>
    <content type="text"><![CDATA[谁说 JavaScript 很简单了？JavaScript系列——数组元素左右移动N位算法实现14年的面试题，想不到今天在群里有人还问了这个！call/apply用来改变函数的执行上下文（this），它们的第一个参数thisArg是个对象，即作为函数内的this。 多数时候你传啥函数内就是啥。仅以call示例 function fun() { alert(this); } fun.call(1); fun.call(&apos;a&apos;); fun.call(true); fun.call({name:&apos;jack&apos;}); 分别弹出“1”、“a”、“true”、“[object Object]”。 有两种情况需要注意，传null或undefined时，将是JS执行环境的全局变量。浏览器中是window，其它环境（如node）则是global。 fun.call(null); // window or global fun.call(undefined); // window or global 这在ECMAScript5.1 15.3.4.4中有解释，如下严格模式下情况又有所不同，ES3比较宽容尽量去揣测代码意图。ES5严格模式（ie6/7/8/9除外）则不再揣测，给call/apply传入的任何参数不再转换。如下 &apos;use strict&apos; function fun() { alert(this); } fun.call(null) // null fun.call(undefined) // undefined 几个面试小题：1.alert(alert(1)&amp;&amp;alert(2)): 第一个alert执行没返回undefined【alert 是函数，alert（1）相当调用，但没有返回值，所以是undefined】，alert（2） 直接短路掉。 2.alert(1&amp;&amp;2) &amp;&amp;第一个为true，才会执行第二个，如果全部是true返回最后一个值。 3.多次bind只保留第一次的。 4.5.6.自定义事件 var myEvent = new Event(&apos;myEvent&apos;); document.addEventListener(&apos;myEvent&apos;, log, false); function log() { console.log(&apos;hello event&apos;); } document.dispatchEvent(myEvent); 7.数组循环移动需求 假设有这样一个数组 [1,2,3,4,5] 现在想要左移或者右移N位，比如移动1位 //左移1位 [2,3,4,5,1] //右移1位 [5,1,2,3,4] 算法实现 这样一道题目，你先不要看我下面的代码，自己思考一下如何实现它，不管是复杂的还是简单的方法。可以先告诉你我用了2行代码实现左、右移动元素。 拆分法 当我们没有具体思路的时候，就先假设数组移动1位的情况。 [1,2,3,4,5] =&gt; [null,1,2,3,4] and [5,null,null,null,null] =&gt; [5,1,2,3,4] 这里可以看成2个数组，一个是没有到达边界的元素移动[null,1,2,3,4]，一个是到达了边界的元素移动[5,null,null,null,null]，当元素到达边界，就会往数组的初始位置移动，形成了一个循环的过程。 很明显，如果我们将这2个移动后的数组合并起来，就是需求的结果。 移动2位 同样符合2个移动后的数组合并起来为结果的情况 [1,2,3,4,5] =&gt; [null,null,1,2,3] and [4,5,null,null,null] =&gt; [4,5,1,2,3] 刚好移动数组长度 [1,2,3,4,5] =&gt; [1,2,3,4,5] and [] //如果没有，就假设为空数组 合并数组 假设移动1位的情况上面的步骤，我们找到了规律，接下来要做的是找到2个数组，需要用到slice截取数组元素。截取第一个数组 arr.slice(0,-1) // [1,2,3,4] 截取第二个数组 arr.slice(-1) // [5] 合并数组 arr.slice(-1).concat(arr.slice(0,-1)) // [5,1,2,3,4] 这样你就实现了移动1位的情况，接着，你继续拿+5和-5范围内的数字进行测试，发现都可以正常移动，当数字大于5或者小于-5的时候，代码就无效了，始终输出[1,2,3,4,5] arr.slice(-6).concat(arr.slice(0,-6)) // [1,2,3,4,5] 我们再加上一个小技巧，求余数，假设是移动6，那么，实际上和移动1是相同的，我们就可以根据公式求余数 n = n%arr.length // n = 6%5 余1 同理，当移动-6时 n = n%arr.length // n = -6%5 余-1 接着带入公式，发现输出全部都正确了！！ 思路分析完了，应该很清晰了吧，源码在下面、 算法源码 arr表示原始数组，n表示移动的距离，可以是正数、可以是0、也可以是负数、正数表示右移，负数表示左移，0表示不移动。 function moveElement(arr, n) { if(Math.abs(n)&gt;arr.length) n = n%arr.length return arr.slice(-n).concat(arr.slice(0,-n)) } // moveElement(arr, 9) // moveElement(arr, 0) // moveElement(arr, -9)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 的 4 个阶段的撤销更改]]></title>
    <url>%2F2017%2F11%2F03%2FGit-%E7%9A%84-4-%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E6%92%A4%E9%94%80%E6%9B%B4%E6%94%B9%2F</url>
    <content type="text"><![CDATA[虽然git诞生距今已有12年之久，网上各种关于git的介绍文章数不胜数，但是依然有很多人（包括我自己在内）对于它的功能不能完全掌握。以下的介绍只是基于我个人对于git的理解，并且可能生编硬造了一些不完全符合git说法的词语。目的只是为了让git通俗化，使初学者也能大概了解如何快速上手git。同时，下面所有讨论，我们都假设只使用一个分支，也就是主分支master的情况，虽然这种作法并不符合git规范，但是现实情况中绝大部分用户是直接在master分支上进行工作的，所以在这里我们不去引入更加复杂的各种分支的情况，也不涉及标签tag的操作，只讲在最简单的主分支上如何回退。 基本概念3个步骤 正常情况下，我们的工作流就是3个步骤，对应上图中的3个箭头线：1234567891011121314 git add . git commit -m &quot;comment&quot; git push git add .把所有文件放入暂存区； git commit把所有文件从暂存区提交进本地仓库； git push把所有文件从本地仓库推送进远程仓库。 4个区git之所以令人费解，主要是它相比于svn等等传统的版本管理工具，多引入了一个暂存区(Stage)的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么4个区就够了： 工作区(Working Area) 暂存区(Stage) 本地仓库(Local Repository) 远程仓库(Remote Repository) 5种状态以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。以下我们把这5种状态分别命名为： 未修改(Origin) 已修改(Modified) 已暂存(Staged) 已提交(Committed) 已推送(Pushed) 检查修改了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这3个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是diff，只是参数有所不同。 已修改，未暂存1git diff 首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做git add .之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验： 我们在文件开头的第2行胡乱加了4个数字1234，存盘，这时文件进入了已修改状态，但是还没有进入暂存区，我们运行git diff，结果如下：12345678910111213141516171819diff --git a/index.md b/index.mdindex 73ff1ba..1066758 100644--- a/index.md+++ b/index.md@@ -1,5 +1,5 @@----layout: main+1234layout: maincolor: black--- git diff的结果告诉我们哪些文件已经做了哪些修改。 已暂存，未提交1git diff --cached 现在我们把修改放入暂存区看一下。先执行git add .，然后执行git diff，你会发现没有任何结果： 这说明git diff这个命令只检查我们的工作区和暂存区之间的差异，如果我们想看到暂存区和本地仓库之间的差异，就需要加一个参数git diff –cached：12345678910111213141516171819diff --git a/index.md b/index.mdindex 73ff1ba..1066758 100644--- a/index.md+++ b/index.md@@ -1,5 +1,5 @@----layout: main+1234layout: maincolor: black--- 这时候我们看到的差异是暂存区和本地仓库之间的差异。 已提交，未推送1git diff master origin/master 现在，我们把修改从暂存区提交到本地仓库，再看一下差异。先执行git commit，然后再执行git diff –cached，没有差异，执行git diff master origin/master，可以看到差异： 在这里，master就是你的本地仓库，而origin/master就是你的远程仓库，master是主分支的意思，因为我们都在主分支上工作，所以这里两边都是master，而origin就代表远程。 撤销修改了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。 已修改，未暂存如果我们只是在编辑器里修改了文件，但还没有执行git add .，这时候我们的文件还在工作区，并没有进入暂存区，我们可以用：12345 git checkout .或者 git reset --hard 来进行撤销操作。 可以看到，在执行完git checkout .之后，修改已被撤销，git diff没有任何内容了。 一对反义词 git add .的反义词是git checkout .。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行git add .，如果你想向后退一步，撤销刚才的修改，就执行git checkout .。 已暂存，未提交你已经执行了git add .，但还没有执行git commit -m “comment”。这时候你意识到了错误，想要撤销，你可以执行：123git resetgit checkout . 或者1git reset --hard git reset只是把修改退回到了git add .之前的状态，也就是说文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行git checkout .。 或许你已经注意到了，以上两个步骤都可以用同一个命令git reset –hard来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到未修改的状态。 已提交，未推送 你的手太快，你既执行了git add .，又执行了git commit，这时候你的代码已经进入了你的本地仓库，然而你后悔了，怎么办？不要着急，还有办法。1git reset --hard origin/master 还是这个git reset –hard命令，只不过这次多了一个参数origin/master，正如我们上面讲过的，origin/master代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。 已推送 很不幸，你的手实在是太快了，你既git add了，又git commit了，并且还git push了，这时你的代码已经进入远程仓库。如果你想恢复的话，还好，由于你的本地仓库和远程仓库是等价的，你只需要先恢复本地仓库，再强制push到远程仓库就好了：123git reset --hard HEAD^git push -f 总结以上4种状态的撤销我们都用到了同一个命令git reset –hard，前2种状态的用法甚至完全一样，所以只要掌握了git reset –hard这个命令的用法，从此你再也不用担心提交错误了。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从Vue.js源码看nextTick机制]]></title>
    <url>%2F2017%2F10%2F29%2F%E4%BB%8EVue-js%E6%BA%90%E7%A0%81%E7%9C%8BnextTick%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！ 可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。操作DOM在使用vue.js的时候，有时候因为一些特定的业务场景，不得不去操作DOM，比如这样： &lt;template&gt; &lt;div&gt; &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; export default { data () { return { test: &apos;begin&apos; }; }, methods () { handleClick () { this.test = &apos;end&apos;; console.log(this.$refs.test.innerText);//打印“begin” } } } 打印的结果是begin，为什么我们明明已经将test设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“begin”呢？ Watcher队列带着疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。 update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } else if (this.sync) { /*同步则执行run直接渲染视图*/ this.run() } else { /*异步推送到观察者队列中，下一个tick时调用。*/ queueWatcher(this) } } 我们发现Vue.js默认是使用异步执行DOM更新。当异步执行update的时候，会调用queueWatcher函数。 /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/ export function queueWatcher (watcher: Watcher) { /*获取watcher的id*/ const id = watcher.id /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/ if (has[id] == null) { has[id] = true if (!flushing) { /*如果没有flush掉，直接push到队列中即可*/ queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt;= 0 &amp;&amp; queue[i].id &gt; watcher.id) { i-- } queue.splice(Math.max(i, index) + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true nextTick(flushSchedulerQueue) } } } 查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。 那么，什么是下一个tick？ nextTickvue.js提供了一个nextTick函数，其实也就是上面调用的nextTick。 nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion，看一下源码： /** * Defer a task to execute it asynchronously. */ /* 延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function 这个函数的作用是在task或者microtask中推入一个timerFunc， 在当前调用栈执行完以后以此执行直到执行到timerFunc 目的是延迟到当前调用栈执行完以后执行 */ export const nextTick = (function () { /*存放异步执行的回调*/ const callbacks = [] /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/ let pending = false /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/ let timerFunc /*下一个tick时的回调*/ function nextTickHandler () { /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/ pending = false /*执行所有callback*/ const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) { copies[i]() } } // the nextTick behavior leverages the microtask queue, which can be accessed // via either native Promise.then or MutationObserver. // MutationObserver has wider support, however it is seriously bugged in // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore if */ /* 这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 参考：https://www.zhihu.com/question/55364497 */ if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) { /*使用Promise*/ var p = Promise.resolve() var logError = err =&gt; { console.error(err) } timerFunc = () =&gt; { p.then(nextTickHandler).catch(logError) // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&apos;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) } } else if (typeof MutationObserver !== &apos;undefined&apos; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &apos;[object MutationObserverConstructor]&apos; )) { // use MutationObserver where native Promise is not available, // e.g. PhantomJS IE11, iOS7, Android 4.4 /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/ var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () =&gt; { counter = (counter + 1) % 2 textNode.data = String(counter) } } else { // fallback to setTimeout /* istanbul ignore next */ /*使用setTimeout将回调推入任务队列尾部*/ timerFunc = () =&gt; { setTimeout(nextTickHandler, 0) } } /* 推送到队列中下一个tick时执行 cb 回调函数 ctx 上下文 */ return function queueNextTick (cb?: Function, ctx?: Object) { let _resolve /*cb存到callbacks中*/ callbacks.push(() =&gt; { if (cb) { try { cb.call(ctx) } catch (e) { handleError(e, ctx, &apos;nextTick&apos;) } } else if (_resolve) { _resolve(ctx) } }) if (!pending) { pending = true timerFunc() } if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) { return new Promise((resolve, reject) =&gt; { _resolve = resolve }) } } })() 它是一个立即执行函数,返回一个queueNextTick接口。 传入的cb会被push进callbacks中存放起来，然后执行timerFunc（pending是一个状态标记，保证timerFunc在下一个tick之前只执行一次）。 timerFunc是什么？ 看了源码发现timerFunc会检测当前环境而不同实现，其实就是按照Promise，MutationObserver，setTimeout优先级，哪个存在使用哪个，最不济的环境下使用setTimeout。 两者的具体实现 macrotasks: setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染 microtasks: Promise， process.nextTick， Object.observe， MutationObserver 再简单点可以总结为： 在 macrotask 队列中执行最早的那个 task ，然后移出 再执行 microtask 队列中所有可用的任务，然后移出 下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步) 这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到： JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、 MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。 要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。 实在不行，只能用 setTimeout 创建 task 了。 为啥要用 microtask？ 根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。 反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。 首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调， MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。 至于 MutationObserver 如何模拟 nextTick 这点，直接看源码，其实就是创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容： var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () =&gt; { counter = (counter + 1) % 2 textNode.data = String(counter) } setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行： setTimeout(function(){ console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;); },0); 它会将回调函数加入task中，等到执行。 setTimeout(function(){console.log(4)},0); new Promise(function(resolve){ console.log(1) for( var i=0 ; i&lt;10000 ; i++ ){ i==9999 &amp;&amp; resolve() } console.log(2) }).then(function(){ console.log(5) }); console.log(3); 结果是： 1,2,3,5,4 再看这个，两个自执行同时执行： &lt;script&gt; (function test() { setTimeout(function () { console.log(4) }, 0); new Promise(function executor (resolve) { console.log(1); for(var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(2); }).then(function() { console.log(5); }); console.log(3); })() (function test2() { setTimeout(function () { console.log(42) }, 0); new Promise(function executor (resolve) { console.log(12); for(var i = 0; i &lt; 10000; i++) { i == 9999 &amp;&amp; resolve(); } console.log(22); }).then(function() { console.log(52); }); console.log(32); })() &lt;/script&gt; 整个执行过程是一个 main thread 【主线程】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的 setTimeout 进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。 当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候： 1.先执行 macrotasks：I/O -》 UI渲染 2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe 3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次： setTimeout ，setInterval –》setImmediate 综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 setImmediate(function(){ console.log(1); },0); setTimeout(function(){ console.log(2); },0); new Promise(function(resolve){ console.log(3); resolve(); console.log(4); }).then(function(){ console.log(5); }); console.log(6); process.nextTick(function(){ console.log(7); }); console.log(8); 结果是：3 4 6 8 7 5 2 1 flushSchedulerQueue/*Github:https://github.com/answershuto*/ /** * Flush both queues and run the watchers. */ /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/ function flushSchedulerQueue () { flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component&apos;s user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component&apos;s watcher run, // its watchers can be skipped. /* 给queue排序，这样做可以保证： 1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。 2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建 3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。 */ queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/ for (index = 0; index &lt; queue.length; index++) { watcher = queue[index] id = watcher.id /*将has的标记删除*/ has[id] = null /*执行watcher*/ watcher.run() // in dev build, check and stop circular updates. /* 在测试环境中，检测watch是否在死循环中 比如这样一种情况 watch: { test () { this.test++; } } 持续执行了一百次watch代表可能存在死循环 */ if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) { circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) { warn( &apos;You may have an infinite update loop &apos; + ( watcher.user ? `in watcher with expression &quot;${watcher.expression}&quot;` : `in a component render function.` ), watcher.vm ) break } } } // keep copies of post queues before resetting state /**/ /*得到队列的拷贝*/ const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() /*重置调度者的状态*/ resetSchedulerState() // call component updated and activated hooks /*使子组件状态都改编成active同时调用activated钩子*/ callActivatedHooks(activatedQueue) /*调用updated钩子*/ callUpdateHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) { devtools.emit(&apos;flush&apos;) } } flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图 为什么要异步更新视图来看一下下面这一段代码 &lt;template&gt; &lt;div&gt; &lt;div&gt;{{test}}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; export default { data () { return { test: 0 }; }, created () { for(let i = 0; i &lt; 1000; i++) { this.test++; } } } 现在有这样的一种情况，created的时候test的值会被++循环执行1000次。每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。 访问真实DOM节点更新后的数据所以我们需要在修改data中的数据后访问真实的DOM节点更新后的数据，只需要这样，我们把文章第一个例子进行修改。 &lt;template&gt; &lt;div&gt; &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; export default { data () { return { test: &apos;begin&apos; }; }, methods () { handleClick () { this.test = &apos;end&apos;; this.$nextTick(() =&gt; { console.log(this.$refs.test.innerText);//打印&quot;end&quot; }); console.log(this.$refs.test.innerText);//打印“begin” } } } 使用Vue.js的global API的$nextTick方法，即可在回调中获取已经更新好的DOM实例了。]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>nextTick</tag>
        <tag>event loop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS网格布局（Grid）完全教程]]></title>
    <url>%2F2017%2F10%2F28%2FCSS%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%EF%BC%88Grid%EF%BC%89%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[CSS网格布局（Grid）完全教程]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>Grid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手实现ES6 EventBus]]></title>
    <url>%2F2017%2F10%2F24%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0ES6-EventBus%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class EventBus &#123; constructor() &#123; this.events = &#123;&#125;; &#125; on(type, callback, scope, ...args) &#123; if (typeof this.events[type] == &quot;undefined&quot;) &#123; this.events[type] = []; &#125; this.events[type].push(&#123;scope: scope, callback: callback, args: args&#125;); &#125; off(type, callback, scope) &#123; if (typeof this.events[type] == &quot;undefined&quot;) &#123; return; &#125; let numOfCallbacks = this.events[type].length; let newArray = []; for (let i = 0; i &lt; numOfCallbacks; i++) &#123; let event = this.events[type][i]; if (event.scope == scope &amp;&amp; event.callback == callback) &#123; &#125; else &#123; newArray.push(event); &#125; &#125; this.events[type] = newArray; &#125; has(type, callback, scope) &#123; if (typeof this.events[type] == &quot;undefined&quot;) &#123; return false; &#125; let numOfCallbacks = this.events[type].length; if (callback === undefined &amp;&amp; scope === undefined) &#123; return numOfCallbacks &gt; 0; &#125; for (let i = 0; i &lt; numOfCallbacks; i++) &#123; let event = this.events[type][i]; if ((scope ? event.scope == scope : true) &amp;&amp; event.callback == callback) &#123; return true; &#125; &#125; return false; &#125; emit(type, target, ...args) &#123; if (typeof this.events[type] == &quot;undefined&quot;) &#123; return; &#125; let bag = &#123; type: type, target: target &#125;; args = [bag].concat(args); let events = this.events[type].slice(); let numOfCallbacks = events.length; for (let i = 0; i &lt; numOfCallbacks; i++) &#123; let event = events[i]; if (event &amp;&amp; event.callback) &#123; let concatArgs = args.concat(event.args); event.callback.apply(event.scope, concatArgs); &#125; &#125; &#125; debug() &#123; let str = &quot;&quot;; for (let type in this.events) &#123; let numOfCallbacks = this.events[type].length; for (let i = 0; i &lt; numOfCallbacks; i++) &#123; let event = this.events[type][i]; let className = &quot;Anonymous&quot;; if (event.scope) &#123; if (event.scope.constructor.name) &#123; className = event.scope.constructor.name; &#125; &#125; str += `$&#123;className&#125; listening for &quot;$&#123;type&#125;&quot;\n`; &#125; &#125; return str; &#125;&#125;;export default new EventBus(); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;EventBus Examples&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;module&quot;&gt; import EventBus from &apos;/src/eventbus.js&apos;; // Simple example &#123; function myHandler(event) &#123; console.log(&quot;myHandler / type: &quot; + event.type); &#125; EventBus.on(&quot;my_event&quot;, myHandler); EventBus.emit(&quot;my_event&quot;); &#125; // Keeping the scope &#123; class TestClass1 &#123; constructor() &#123; this.className = &quot;TestClass1&quot;; EventBus.on(&quot;callback_event&quot;, this.callback, this); &#125; callback(event) &#123; console.log(this.className + &quot; / type: &quot; + event.type + &quot; / dispatcher: &quot; + event.target.className); &#125; &#125; class TestClass2 &#123; constructor() &#123; this.className = &quot;TestClass2&quot;; &#125; dispatch() &#123; EventBus.emit(&quot;callback_event&quot;, this); &#125; &#125; let t1 = new TestClass1(); let t2 = new TestClass2(); t2.dispatch(); &#125; // Passing additional parameters &#123; class TestClass1 &#123; constructor() &#123; this.className = &quot;TestClass1&quot;; EventBus.on(&quot;custom_event&quot;, this.doSomething, this); &#125; doSomething(event, param1, param2) &#123; console.log(this.className + &quot;.doSomething&quot;); console.log(&quot;type=&quot; + event.type); console.log(&quot;params=&quot; + param1 + param2); console.log(&quot;coming from=&quot; + event.target.className); &#125; &#125; class TestClass2 &#123; constructor() &#123; this.className = &quot;TestClass2&quot;; &#125; ready() &#123; EventBus.emit(&quot;custom_event&quot;, this, &quot;javascript events&quot;, &quot; are really useful&quot;); &#125; &#125; let t1 = new TestClass1(); let t2 = new TestClass2(); t2.ready(); &#125; // Debugging console.log(EventBus.debug()); // Removing a registered handler &#123; var handler = function() &#123; console.log(&apos;example callback&apos;); &#125;; EventBus.on(&apos;EXAMPLE_EVENT&apos;, handler); EventBus.emit(&apos;EXAMPLE_EVENT&apos;); EventBus.off(&apos;EXAMPLE_EVENT&apos;, handler); // Not emitted because event was removed EventBus.emit(&apos;EXAMPLE_EVENT&apos;); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19 个 JavaScript 有用的简写技术]]></title>
    <url>%2F2017%2F10%2F11%2F19-%E4%B8%AA-JavaScript-%E6%9C%89%E7%94%A8%E7%9A%84%E7%AE%80%E5%86%99%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1.三元操作符当想写if…else语句时，使用三元操作符来代替。 const x = 20; let answer; if (x &gt; 10) { answer = &apos;is greater&apos;; } else { answer = &apos;is lesser&apos;; } 简写：const answer = x &gt; 10 ? &#39;is greater&#39; : &#39;is lesser&#39;; 也可以嵌套if语句：const big = x &gt; 10 ? &quot; greater 10&quot; : x 2.短路求值简写方式当给一个变量分配另一个值时，想确定源始值不是null，undefined或空值。可以写撰写一个多重条件的if语句。 if (variable1 !== null || variable1 !== undefined || variable1 !== &apos;&apos;) { let variable2 = variable1; } 或者可以使用短路求值方法：const variable2 = variable1 || &#39;new&#39;; 3.声明变量简写方法let x; let y; let z = 3; 简写方法：let x, y, z=3; 4.if存在条件简写方法if (likeJavaScript === true) 简写：if (likeJavaScript) 只有likeJavaScript是真值时，二者语句才相等 如果判断值不是真值，则可以这样： let a; if ( a !== true ) { // do something... } 简写： let a; if ( !a ) { // do something... } 5.JavaScript循环简写方法for (let i = 0; i &lt; allImgs.length; i++) 简写：for (let index in allImgs)也可以使用Array.forEach： function logArrayElements(element, index, array) { console.log(&quot;a[&quot; + index + &quot;] = &quot; + element); } [2, 5, 9].forEach(logArrayElements); // logs: // a[0] = 2 // a[1] = 5 // a[2] = 9 6.短路评价给一个变量分配的值是通过判断其值是否为null或undefined，则可以： let dbHost; if (process.env.DB_HOST) { dbHost = process.env.DB_HOST; } else { dbHost = &apos;localhost&apos;; } 简写：const dbHost = process.env.DB_HOST || &#39;localhost&#39;; 7.十进制指数当需要写数字带有很多零时（如10000000），可以采用指数（1e7）来代替这个数字：for (let i = 0; i &lt; 10000; i++) {}简写： for (let i = 0; i &lt; 1e7; i++) {} // 下面都是返回true 1e0 === 1; 1e1 === 10; 1e2 === 100; 1e3 === 1000; 1e4 === 10000; 1e5 === 100000; 8.对象属性简写如果属性名与key名相同，则可以采用ES6的方法：const obj = { x:x, y:y }; 简写：const obj = { x, y }; 9.箭头函数简写传统函数编写方法很容易让人理解和编写，但是当嵌套在另一个函数中，则这些优势就荡然无存。 function sayHello(name) { console.log(&apos;Hello&apos;, name); } setTimeout(function() { console.log(&apos;Loaded&apos;) }, 2000); list.forEach(function(item) { console.log(item); }); 简写： sayHello = name =&gt; console.log(&apos;Hello&apos;, name); setTimeout(() =&gt; console.log(&apos;Loaded&apos;), 2000); list.forEach(item =&gt; console.log(item)); 10.隐式返回值简写经常使用return语句来返回函数最终结果，一个单独语句的箭头函数能隐式返回其值（函数必须省略{}为了省略return关键字） 为返回多行语句（例如对象字面表达式），则需要使用()包围函数体。 function calcCircumference(diameter) { return Math.PI * diameter } var func = function func() { return { foo: 1 }; }; 简写： calcCircumference = diameter =&gt; ( Math.PI * diameter; ) var func = () =&gt; ({ foo: 1 }); 11.默认参数值为了给函数中参数传递默认值，通常使用if语句来编写，但是使用ES6定义默认值，则会很简洁： function volume(l, w, h) { if (w === undefined) w = 3; if (h === undefined) h = 4; return l * w * h; } 简写： volume = (l, w = 3, h = 4 ) =&gt; (l * w * h); volume(2) //output: 24 12.模板字符串传统的JavaScript语言，输出模板通常是这样写的。 const welcome = &apos;You have logged in as &apos; + first + &apos; &apos; + last + &apos;.&apos; const db = &apos;http://&apos; + host + &apos;:&apos; + port + &apos;/&apos; + database; ES6可以使用反引号和${}简写： const welcome = `You have logged in as ${first} ${last}`; const db = `http://${host}:${port}/${database}`; 13.解构赋值简写方法在web框架中，经常需要从组件和API之间来回传递数组或对象字面形式的数据，然后需要解构它 const observable = require(&apos;mobx/observable&apos;); const action = require(&apos;mobx/action&apos;); const runInAction = require(&apos;mobx/runInAction&apos;); const store = this.props.store; const form = this.props.form; const loading = this.props.loading; const errors = this.props.errors; const entity = this.props.entity; 简写： import { observable, action, runInAction } from &apos;mobx&apos;; const { store, form, loading, errors, entity } = this.props; 也可以分配变量名： const { store, form, loading, errors, entity:contact } = this.props; //最后一个变量名为contact 14.多行字符串简写需要输出多行字符串，需要使用+来拼接： const lorem = &apos;Lorem ipsum dolor sit amet, consectetur\n\t&apos; + &apos;adipisicing elit, sed do eiusmod tempor incididunt\n\t&apos; + &apos;ut labore et dolore magna aliqua. Ut enim ad minim\n\t&apos; + &apos;veniam, quis nostrud exercitation ullamco laboris\n\t&apos; + &apos;nisi ut aliquip ex ea commodo consequat. Duis aute\n\t&apos; + &apos;irure dolor in reprehenderit in voluptate velit esse.\n\t&apos; 使用反引号，则可以达到简写作用： const lorem = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse.` 15.扩展运算符简写扩展运算符有几种用例让JavaScript代码更加有效使用，可以用来代替某个数组函数。 // joining arrays const odd = [1, 3, 5]; const nums = [2 ,4 , 6].concat(odd); // cloning arrays const arr = [1, 2, 3, 4]; const arr2 = arr.slice() 简写： // joining arrays const odd = [1, 3, 5 ]; const nums = [2 ,4 , 6, ...odd]; console.log(nums); // [ 2, 4, 6, 1, 3, 5 ] // cloning arrays const arr = [1, 2, 3, 4]; const arr2 = [...arr]; 不像concat()函数，可以使用扩展运算符来在一个数组中任意处插入另一个数组。 const odd = [1, 3, 5 ]; const nums = [2, ...odd, 4 , 6]; 也可以使用扩展运算符解构： const { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 }; console.log(a) // 1 console.log(b) // 2 console.log(z) // { c: 3, d: 4 } 16.强制参数简写JavaScript中如果没有向函数参数传递值，则参数为undefined。为了增强参数赋值，可以使用if语句来抛出异常，或使用强制参数简写方法。 function foo(bar) { if(bar === undefined) { throw new Error(&apos;Missing parameter!&apos;); } return bar; } 简写： mandatory = () =&gt; { throw new Error(&apos;Missing parameter!&apos;); } foo = (bar = mandatory()) =&gt; { return bar; } 17.Array.find简写想从数组中查找某个值，则需要循环。在ES6中，find()函数能实现同样效果。 const pets = [ { type: &apos;Dog&apos;, name: &apos;Max&apos;}, { type: &apos;Cat&apos;, name: &apos;Karl&apos;}, { type: &apos;Dog&apos;, name: &apos;Tommy&apos;}, ] function findDog(name) { for(let i = 0; i&lt;pets.length; ++i) { if(pets[i].type === &apos;Dog&apos; &amp;&amp; pets[i].name === name) { return pets[i]; } } } 简写： pet = pets.find(pet =&gt; pet.type ===&apos;Dog&apos; &amp;&amp; pet.name === &apos;Tommy&apos;); console.log(pet); // { type: &apos;Dog&apos;, name: &apos;Tommy&apos; } 18.Object[key]简写考虑一个验证函数 function validate(values) { if(!values.first) return false; if(!values.last) return false; return true; } console.log(validate({first:&apos;Bruce&apos;,last:&apos;Wayne&apos;})); // true 假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认？ // 对象验证规则 const schema = { first: { required:true }, last: { required:true } } // 通用验证函数 const validate = (schema, values) =&gt; { for(field in schema) { if(schema[field].required) { if(!values[field]) { return false; } } } return true; } console.log(validate(schema, {first:&apos;Bruce&apos;})); // false console.log(validate(schema, {first:&apos;Bruce&apos;,last:&apos;Wayne&apos;})); // true 现在可以有适用于各种情况的验证函数，不需要为了每个而编写自定义验证函数了 19.双重非位运算简写有一个有效用例用于双重非运算操作符。可以用来代替Math.floor()，其优势在于运行更快，可以阅读此文章了解更多位运算。Math.floor(4.9) === 4 //true 简写：~~4.9 === 4 //true]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS如何实现文字两端对齐]]></title>
    <url>%2F2017%2F10%2F02%2FCSS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[最近在工作项目中接触到Web界面设计的问题，要实现文字两端对齐的效果。在网上搜索了一下，差不多都是互相转帖，用的都是类似的技巧： text-align:justify; text-justify:inter-ideograph; 但问题是，我怎么就看不到效果呢？无论是英文还是中文，在IE和chrome下都不起作用。后来，终于在StackOverflow上找到解决方法了。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .arter li { font-size: 14px; line-height: 24px; color: #4a4a4a; } .arter span { height: 24px; line-height: 24px; width: 65px; text-align: justify; display: inline-block; overflow: hidden; vertical-align: top; } .arter i { display: inline-block; width: 100%; height: 0; } .arter1 li { font-size: 14px; line-height: 24px; color: #4a4a4a; } .arter1 span { height: 24px; line-height: 24px; width: 65px; text-align: justify; display: inline-block; overflow: hidden; vertical-align: top; } .arter1 span:after { content: &quot; &quot;; display: inline-block; width: 100%; height: 0px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;arter&quot;&gt; &lt;li&gt;&lt;span&gt;作品名称&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 宝贝儿&lt;/li&gt; &lt;li&gt;&lt;span&gt;作品类型&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 油画&lt;/li&gt; &lt;li&gt;&lt;span&gt;艺术家&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 张玉瀛&lt;/li&gt; &lt;li&gt;&lt;span&gt;风格&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 超现实&lt;/li&gt; &lt;li&gt;&lt;span&gt;材质&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 布面油画&lt;/li&gt; &lt;li&gt;&lt;span&gt;题材&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 人物&lt;/li&gt; &lt;li&gt;&lt;span&gt;创作时间&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 2011&lt;/li&gt; &lt;li&gt;&lt;span&gt;所在位置&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 华东&lt;/li&gt; &lt;li&gt;&lt;span&gt;尺寸&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 78x78cm&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt;&lt;br /&gt; &lt;ul class=&quot;arter1&quot;&gt; &lt;li&gt;&lt;span&gt;作品名称&lt;/span&gt;： 宝贝儿&lt;/li&gt; &lt;li&gt;&lt;span&gt;作品类型&lt;/span&gt;： 油画&lt;/li&gt; &lt;li&gt;&lt;span&gt;艺术家&lt;/span&gt;： 张玉瀛&lt;/li&gt; &lt;li&gt;&lt;span&gt;风格&lt;/span&gt;： 超现实&lt;/li&gt; &lt;li&gt;&lt;span&gt;材质&lt;/span&gt;： 布面油画&lt;/li&gt; &lt;li&gt;&lt;span&gt;题材&lt;/span&gt;： 人物&lt;/li&gt; &lt;li&gt;&lt;span&gt;创作时间&lt;/span&gt;： 2011&lt;/li&gt; &lt;li&gt;&lt;span&gt;所在位置&lt;/span&gt;： 华东&lt;/li&gt; &lt;li&gt;&lt;span&gt;尺寸&lt;/span&gt;： 78x78cm&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 样式：从效果图可以看到，除了要在块级元素加text-align:justify样式外，还需要在里面加一个空的span元素，并应用样式。另外，对于中文还必须用空格隔开汉字，否则也没有两端对齐的效果。英文每个单词都有空格隔开，所以没问题。 但是加入HTML元素又违反了结构表现分离的原则，我们可以改用after、before伪元素： li:after { content: &quot; &quot;; display: inline-block; width: 100%; }]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 必知必会]]></title>
    <url>%2F2017%2F09%2F11%2FGit-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[Git是目前世界上最先进的分布式版本控制系统。 参考文章： 如何优雅地使用 Git - 掘金 GIT 常见命令学习整理GIT常用命令备忘Git远程操作详解一篇文章，教你学会Git如何在 Git 中使用撤消操作git使用中碰到的问题，持续更新Git 的 4 个阶段的撤销更改Git提交历史的修改删除合并 - 掘金 IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout直接执行git clean -d -fx即可。 可能很多人都不明白-d，-fx到底是啥意思， 其实git clean -d -fx表示：删除 一些 没有 git add 的 文件； git clean 参数 -n 显示将要删除的文件和目录； -x -----删除忽略文件已经对git来说不识别的文件 -d -----删除未被添加到git的路径中的文件 -f -----强制运行 git clean -n git clean -df git clean -f git reflog //该指令输出详细的操作历史，包括提交，操作，修改等 修改注释 git commit --amend 或 git commit --amend -m &quot;Fixes bug #42&quot; gitk 字符集编码： git config --global gui.encoding utf-8 //在git GUI中使用UTF-8编码 配置 git config --global user.name &quot;ihoey&quot; # 设置git用户名 git config --global user.email &quot;mail@ihoey.com&quot; # 设置git邮箱 git config --global color.ui true # 为true是终端着色 git config --global alias.co checkout # 配置checkout的别名 git config --global alias.ci commit # 配置commit的别名 git config --global alias.cm commit # 配置commit的别名 git config --global alias.st status # 配置status的别名 git config --global alias.br branch # 配置branch的别名 git config --global alias.cp cherry-pick # 配置cherry-pick的别名 git config --global alias.rb rebase # 配置rebase的别名 git config --global core.editor &quot;mate -w&quot; # 设置Editor使用textmate git config -l # 列举所有配置 #用户的git配置文件~/.gitconfig SSH 秘钥 ssh-keygen -t rsa -C &quot;mail@ihoey.com&quot; # 连续3个回车。如果不需要密码的话。 # 最后得到了两个文件：id_rsa和id_rsa.pub，在~/.ssh/文件夹下面 # id_rsa为你的私钥，不可以告诉别人 # id_rsa.pub为你的公钥，一般会放在你的服务器做ssh登录，或者放在github上面 基本命令 创建git仓库 git init 添加文件到暂存区 git add fileName / git add . 提交文件到仓库 git commit -m &quot;版本提交信息&quot; 查看文件提交状态 git status 查看文件修改的信息 git diff readme.txt git help &lt;command&gt; # 显示command的help git show # 显示某次提交的内容 git show $id git checkout -- &lt;file&gt; # 抛弃工作区修改 git checkout . # 抛弃工作区修改 git add &lt;file&gt; # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git reset SHA1 ID # 恢复指定提交 git commit -m &quot;some comments&quot; git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件 git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff git diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异 git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较 git diff --staged # 比较暂存区和版本库差异 git diff --cached # 比较暂存区和版本库差异 git diff --stat # 仅仅比较统计信息 查看提交记录 git log git log &lt;file&gt; # 查看该文件每次提交记录 git log -p &lt;file&gt; # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log --stat # 查看提交统计信息 分支管理 git branch -l # 查看本地分支 git branch -r # 查看远程分支 git branch &lt;new_branch&gt; # 创建新的分支 git branch -v # 查看各个分支最后提交信息 git branch --merged # 查看已经被合并到当前分支的分支 git branch --no-merged # 查看尚未被合并到当前分支的分支 git checkout &lt;branch&gt; # 切换到某个分支 git checkout -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git checkout -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch git checkout $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git checkout $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git branch -d &lt;branch&gt; # 删除某个分支 git branch -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 强行切换分支 git checkout -f branch_name 强制checkout分支覆盖本地文件 git checkout -f branchname 分支合并和rebase git merge &lt;branch&gt; # 将branch分支合并到当前分支 git merge --no-ff &lt;branch&gt; # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git checkout &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge &lt;branch&gt; 在我们操作过程中。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit 就可以了。 而rebase 操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行git rebase –continue继续操作，或者git rebase –skip忽略冲突。 Git暂存管理 git stash # 暂存 git stash pop # 恢复暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区 git stash list：查看储藏队列(Stash lists) git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes)) git stash clear：清空储藏队列 git stash save “name of the stash”：为储藏设置命名 git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏 git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏) 远程分支管理 git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git checkout –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d )，然后再push删除远程分支 git删除远程分支 git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限 清空git暂存区 git reset HEAD //可以清空之前git add 的内容 Git远程仓库管理 git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@github.com:ihoey/blog.git # 添加远程仓库地址 git remote set-url origin git@github.com:ihoey/blog.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库 git clone –bare ihoey.com blog.git # 用带版本的项目创建纯版本仓库 scp -r my_blog.git git@ihoey.com:~ # 将纯仓库上传到服务器上 mkdir blog.git &amp;&amp; cd blog.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 设置跟踪远程库和本地库 git branch –set-upstream master origin/master #master git branch –set-upstream develop origin/develop #develop 其他命令 mkdir XX #(创建一个空目录 XX指目录名) pwd #显示当前目录的路径。 cat XX #查看XX文件内容 rm XX #删除文件 命令别名设置: gitk --all &amp; //打开git 图形化界面 git fetch --all //刷新工作区 git remote -v //查看远端地址 git checkout -b dbg_master -t origin/master //基于远端master分支创建dbg_master分支 git merge --squash &lt;branch&gt;：将多次提交合并成一个，然后git add .;git commit -m &quot;XXXXX&quot;;git push origin XXXX... git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin local-branch #将当前local-branch 分支推送一个远程local-branch分支，本地分支和远程分支同名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支，将local_branch代码推送到remote_branch分支 git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 对最近一次commit的进行修改：git commit -a –amend Git pull 强制覆盖本地文件 git fetch --all git reset --hard origin/master git pull git remote add origin https://git.oschina.net/duandaoke/os.git要求服务已经建立同名仓库 git remote # 显示远程仓库 git remote -v # 显示远程仓库详情 git remote show origin # 显示 origin 远程库的详情 rebase的冲突解决 解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存） git add -u //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。 然后执行下面命令继续rebase： git rebase --continue //有冲突继续解决，重复这这些步骤，直到rebase完成。 如果中间遇到某个补丁不需要应用，可以用下面命令忽略： git rebase --skip 如果想回到rebase执行之前的状态，可以执行： git rebase --abort //放弃rebase 注：rebase之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。 cherry-pick的冲突解决 解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存） git add -u //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。 然后执行下面命令继续rebase： git cherry-pick --continue //有冲突继续解决，重复这这些步骤，直到cherry-pick完成。 如果中间遇到某个补丁不需要应用，可以用下面命令忽略： git cherry-pick --skip 如果想回到rebase执行之前的状态，可以执行： git cherry-pick --abort //放弃cherry-pick 注：cherry-pick之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。 手动编辑冲突的文件，使其内容和master_mlc分支上的内容一致， 然后git add此文件，最后执行git cherry-pick –continue即可。 1、git删除远程分支 git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限 2、清空git暂存区 git reset HEAD //可以清空之前git add 的内容 git clean命令用来从你的工作目录中删除所有没有tracked过的文件. git clean经常和git reset --hard一起结合使用. 记住reset只影响被track过的文件, 所以需要clean来删除没有track过的文件. 结合使用这两个命令能让你的工作目录完全回到一个指定的&lt;commit&gt;的状态. 用法 删除当前目录下没有被track过的文件和文件夹. git clean -xf 下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发. git reset --hard git clean -df 运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态, git status会告诉你这是一个干净的工作目录, 又是一个新的开始了. git config --global gui.encoding utf-8 //在git GUI中使用UTF-8编码 //git 回滚到之前某一commit git reset –hard 8ff24a6803173208f3e606e32dfcf82db9ac84d8 在使用Git的时候,经过几次提交后,发现需要回退到早些时候的状态.例如: 7edb8524a xxxxxxxxxxxxxxxxxx 83dae5691 xxxxxxxxxxxxxxxxxx 45eadd642 xxxxxxxxxxxxxxxxxx 657834ade xxxxxxxxxxxxxxxxxx 假设现在处于7edb8524a 状态,现在我想回退到657834ade时的状态,此时可以 git reset –hard 7edb8524a 然后 git reset –soft 657834ade 会将之间的修改全部进行revert,然后在进行add commit操作就行了. 另外权限足够的话,可以从657834ade 拉一个分支出来,然后将远程分支 删除,再将拉出来的分支push到远程仓库上,成为原来的分支,也可以实现回退到 657834ade 的目的.此方法不会保留中间的各种修改信息和状态. 根据–soft –mixed –hard，会对working tree和index和HEAD进行重置: git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容 已经push 对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令 revert git revert用于反转提交,执行evert命令时要求工作树必须是干净的. git revert用一个新提交来消除一个历史提交所做的任何修改. revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题) revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看. git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61 通常,前几位即可 git revert c011eb3 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit 看似达到的效果是一样的,其实完全不同. 合理的命令别名设置可以大大减少输入，有助于提高工作效率，建议遵守下述别名设置： git config --global alias.ci commit git config --global alias.co checkout git config --global alias.st status git config --global alias.rb rebase git config --global alias.ll “log --oneline --decorate --color” git config --global alias.lc “log --graph --color” 正确的回车换行设置，避免 Unix 和 Windows 下开发的回车换行的转换问题。 (Windows 下) git config --global core.autocrlf true git config --global core. safecrlf warn (Linux 下) git config --global core.autocrlf input git config --global core. safecrlf warn 基本命令 git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;youremail@example.com&quot; git config --global core.editor &lt;your favorite editor here&gt; Ex: git config --global core.editor vim git init：初始化一个repo，初始化本地git仓库（创建新仓库） Commit 结构 git status(gst)：查看 repo 状态 工作区： .git 目录 暂存区 工作目录 git add &lt;filename&gt;(ga)：添加一个文件到暂存区 git add .(gaa)：添加所有文件到暂存区 git add *.js：添加所有后缀为js的文件到暂存区 git rm --cached &lt;file&gt;：从暂存区删除一个新文件 git commit -m &quot;My first commit&quot;(gcmsg)：创建一次带 message 的提交 git commit -v -a(gca)： -v是 verbose 的缩写，会在底部显示差异信息和更多有意义的信息 -a 类似于 git add .，会添加所有被修改和删除的文件，但会忽略新创建的文件 git help &lt;command&gt;：查看对应命令的帮助手册 git log(glg,glgg,glo, glog)：查看项目的提交历史 暂存区管理 git reset HEAD &lt;filename&gt;(grh)：从暂存区删除一个被修改的文件 git reset HEAD(grh)：从暂存区删除所有被修改的文件 git checkout &lt;filename&gt;(gco)：从暂存区删除一个被修改的文件，并撤销文件的更改 // git checkout . git commit -m &quot;My first commit&quot; --amend：添加文件/更改在暂存区的最后一次提交 git commit -v -a --amend(gca!)：添加文件/更改在暂存区的最后一次提交 .gitignore：告诉git，哪些文件不被加入版本跟踪 可以使用 git add &lt;filename&gt; -f 命令添加一个不被版本跟踪的文件 git diff &lt;filename&gt;(gd)：查看基于当前文件的最后一次提交的更改差异 git diff (gd)：查看基于所有文件的最后一次提交的更改差异 git reset HEAD~2 --soft：从项目提交历史中删除最近两次提交，但不丢弃文件的更改 git reset HEAD~2 --hard：从项目提交历史中删除最近两次提交，但会丢弃文件的更改和在(最后两次)提交中创建的新文件 git reset &lt;commit&gt; --soft --hard： --soft：将所有被更改的文件回溯到“待提交”状态 --hard：commit 之后，对被git追踪的文件的任何更改都被丢弃 git reflog：显示包括&quot;被撤销&quot;在内的所有提交 git merge &lt;commit hash&gt;：重新提交(restore the commit) git clean -f：删除工作目录中不被git进行版本追踪的文件 Stashed &amp; BranchesStash git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区 git stash list：查看储藏队列(Stash lists) git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes)) git stash clear：清空储藏队列 git stash save &quot;name of the stash&quot;：为储藏设置命名 git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏 git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏) Branch git checkout -b dev(gco)：创建 dev 分支并从当前分支切换到 dev 分支 // git checkout -b dbg_master -t origin/master //基于master分支创建dbg_master分支 git branch(gb)：查看所有分支 git checkout master(gcm)：切换到主分支 git merge &lt;branch&gt;(gm)：合并分支 git rebase master：先将 master 上的更改合并到当前分支，再添加当前分支的更改。如果有冲突，解决冲突后加 --continue 参数继续合并 git branch -d &lt;branch&gt;： 删除分支，-D 则强制删除分支 git merge &lt;branch&gt; --squash：将多次提交合并成一个，其流程如下： # Go to the `master` branch git checkout master # Create a temp branch git checkout -b temp # Merge the feature/x branch into the temp using --squash git merge feature/x --squash # See the new modifications/files in the Staging Area git status # Create the unified commit git commit -m &quot;Add feature/x&quot; # Delete the feature/x branch git branch -D feature/x rebase 和 merge 的区别： rebase: 提交历史(的展示)是线性的 缺点：会删除最近一个 commit，然后创建一次新的 commit 如果已提交到远程，不要使用 rebase merge: 提交历史(的展示)是分叉的 对于两个分支的合并，会创建一个次新的 commit 远程仓库管理 git remote add &lt;name&gt; &lt;url&gt;：添加一个将被追踪的远程仓库 git remote rm &lt;name&gt;：移除一个远程仓库 git push &lt;remote&gt; &lt;remote-branch&gt;(gp,ggp)：将当前分支的本地 commit 推送到远程仓库 git fetch &lt;remote&gt; &lt;remote-branch&gt;：拉取远程仓库的最新 commit 到当前(本地)分支(&lt;remote&gt;/&lt;branch&gt;)，不会合并 git pull &lt;remote&gt; &lt;remote-branch&gt;(gl,ggl)：拉取远程仓库的最新 commit 到当前(本地)分支，并自动 merge git pull --rebase(gup)：以 rebase 的方式进行合并，而不是 merge 其它有用的命令 git tag &lt;name&gt;：创建一个 tag(如：v1.3) git push --tags：将本地 tags 推送到远程仓库 git push &lt;tag&gt;：推送指定的本地 tag 到远程 展示帮助信息 git help -g 回到远程仓库的状态 抛弃本地所有的修改，回到远程仓库的状态。 git fetch --all &amp;&amp; git reset --hard origin/master 重设第一个commit 也就是把所有的改动都重新放回工作区，并清空所有的commit，这样就可以重新提交第一个commit了 git update-ref -d HEAD 展示工作区和暂存区的不同 输出工作区和暂存区的different(不同)。 git diff 还可以展示本地仓库中任意两个commit之间的文件变动： git diff &lt;commit-id&gt; &lt;commit-id&gt; 展示暂存区和最近版本的不同 输出暂存区和本地最近的版本(commit)的different(不同)。 git diff --cached 展示暂存区、工作区和最近版本的不同 输出工作区、暂存区 和本地最近的版本(commit)的different(不同)。 git diff HEAD 快速切换分支 git checkout - 删除已经合并到master的分支 git branch --merged master | grep -v &apos;^\*\| master&apos; | xargs -n 1 git branch -d 展示本地分支关联远程仓库的情况 git branch -vv 关联远程分支 关联之后，git branch -vv就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。 git branch -u origin/mybranch 或者在push时加上-u参数 git push origin/mybranch -u 列出所有本地分支 -l参数相当于：local git branch -l 列出所有远程分支 -r参数相当于：remote git branch -r 列出本地和远程分支 -a参数相当于：all git branch -a 创建并切换到本地分支 git checkout -b &lt;branch-name&gt; 创建并切换到远程分支 git checkout -b &lt;branch-name&gt; -t origin/&lt;branch-name&gt; 删除本地分支 git branch -d &lt;local-branchname&gt; 删除远程分支 git push origin --delete &lt;remote-branchname&gt; 或者 git push origin :&lt;remote-branchname&gt; 重命名本地分支 git branch -m &lt;new-branch-name&gt; git branch -m &lt;oldbranchname&gt; &lt;newbranchname&gt;：尝试修改 git branch -M &lt;oldbranchname&gt; &lt;newbranchname&gt;：强制修改 查看标签 git tag 展示当前分支的最近的tag git describe --tags --abbrev=0 本地创建标签 git tag &lt;version-number&gt; 默认tag是打在最近的一次commit上，如果需要指定commit打tag： $ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt; 推送标签到远程仓库 首先要保证本地创建好了标签才可以推送标签到远程仓库： git push origin &lt;local-version-number&gt; 一次性推送所有标签，同步到远程仓库： git push origin --tags 删除本地标签 git tag -d &lt;tag-name&gt; 删除远程标签 删除远程标签需要先删除本地标签，再执行下面的命令： git push origin :refs/tags/&lt;tag-name&gt; 切回到某个标签 一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态： git checkout -b branch_name tag_name 放弃工作区的修改 git checkout &lt;file-name&gt; 放弃所有修改： git checkout . 恢复删除的文件 git rev-list -n 1 HEAD -- &lt;file_path&gt; #得到 deleting_commit git checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态 回到某一个commit的状态，并重新增添一个commit //回退，有记录 git revert &lt;commit-id&gt; 回到某个commit的状态，并删除后面的commit 和revert的区别：reset命令会抹去某个commit id之后的所有commit git reset &lt;commit-id&gt; 修改上一个commit的描述 git commit --amend 查看commit历史 git log 查看某段代码是谁写的 blame的意思为‘责怪’，你懂的。 git blame &lt;file-name&gt; 显示本地执行过git命令 就像shell的history一样 git reflog 修改作者名 git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos; 修改远程仓库的url git remote set-url origin &lt;URL&gt; 增加远程仓库 git remote add origin &lt;remote-url&gt; 列出所有远程仓库 git remote // git remote -v 查看两个星期内的改动 git whatchanged --since=&apos;2 weeks ago&apos; 把A分支的某一个commit，放到B分支上 这个过程需要cherry-pick命令，参考 git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt; 给git命令起别名 简化命令 git config --global alias.&lt;handle&gt; &lt;command&gt; 比如：git status 改成 git st，这样可以简化命令 git config --global alias.st status 存储当前的修改，但不用提交commit 详解可以参考廖雪峰老师的git教程 git stash 保存当前状态，包括untracked的文件 untracked文件：新建的文件 git stash -u 展示所有stashes git stash list 回到某个stash的状态 git stash apply &lt;stash@{n}&gt; 回到最后一个stash的状态，并删除这个stash git stash pop 删除所有的stash git stash clear 从stash中拿出某个文件的修改 git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt; 展示所有tracked的文件 git ls-files -t 展示所有untracked的文件 git ls-files --others 展示所有忽略的文件 git ls-files --others -i --exclude-standard 强制删除untracked的文件 可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。clean命令，注意两点： clean后，删除的文件无法找回 不会影响tracked的文件的改动，只会删除untracked的文件git clean &lt;file-name&gt; -f 强制删除untracked的目录 可以用来删除新建的目录，注意:这个命令也可以用来删除untracked的文件。详情见上一条 git clean &lt;directory-name&gt; -df 展示简化的commit历史 git log --pretty=oneline --graph --decorate --all 把某一个分支到导出成一个文件 git bundle create &lt;file&gt; &lt;branch-name&gt; 从包中导入分支 新建一个分支，分支内容就是上面git bundle create命令导出的内容 git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt; 执行rebase之前自动stash git rebase --autostash 从远程仓库根据ID，拉下某一状态，到本地分支 git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt; 详细展示一行中的修改 git diff --word-diff 清除gitignore文件中记录的文件 git clean -X -f 展示所有alias和configs 注意： config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config git config --local --list (当前目录) git config --global --list (全局) 展示忽略的文件 git status --ignored commit历史中显示Branch1有的，但是Branch2没有commit git log Branch1 ^Branch2 在commit log中显示GPG签名 git log --show-signature 删除全局设置 git config --global --unset &lt;entry-name&gt; 新建并切换到新分支上，同时这个分支没有任何commit 相当于保存修改，但是重写commit历史 git checkout --orphan &lt;branch-name&gt; 展示任意分支某一文件的内容 git show &lt;branch-name&gt;:&lt;file-name&gt; clone下来指定的单一分支 git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git 忽略某个文件的改动 关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动 git update-index --assume-unchanged path/to/file 恢复 track 指定文件的改动 git update-index --no-assume-unchanged path/to/file 忽略文件的权限变化 不再将文件的权限变化视作改动 git config core.fileMode false 展示本地所有的分支的commit 最新的放在最上面 git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/ 在commit log中查找相关内容 通过grep查找，given-text：所需要查找的字段 git log --all --grep=&apos;&lt;given-text&gt;&apos; 把暂存区的指定file放到工作区中 git reset &lt;file-name&gt; 强制推送 git push -f &lt;remote-name&gt; &lt;branch-name&gt;列出所有远程分支 -r参数相当于：remote git branch -r 更新到本地 # 源 + 分支名 git pull origin master 初始化本地git仓库（创建新仓库） git init # 初始化 git 项目 git init 安装好 Git 之后，配置你的资料: # 配置用户名 git config --global user.name &quot;Your Real Name&quot; # 配置邮箱地址 git config --global user.email you@email.address 配置用户名 git config --global user.name &quot;xxx&quot; 配置邮件 git config --global user.email &quot;xxx@xxx.com&quot; git status等命令自动着色 git config --global color.ui true git config --global color.status auto git config --global color.diff auto git config --global color.branch auto git config --global color.interactive auto clone远程仓库 git clone git+ssh://git@192.168.53.168/VT.git 查看当前版本状态（是否修改） git status 添加xyz文件至index git add xyz 增加当前子目录下所有更改过的文件至index git add . 提交 git commit -m &apos;xxx&apos; 合并上一次提交（用于反复修改） git commit --amend -m &apos;xxx&apos; 将add和commit合为一步 git commit -am &apos;xxx&apos; 删除index中的文件 git rm xxx 递归删除 git rm -r * 显示提交日志 git log 显示1行日志 -n为n行 git log -1 git log -5 显示提交日志及相关变动文件 git log --stat git log -p -m 显示某个提交的详细内容 git show dfb02e6e4f2f7b573337763e5c0013802e392818 可只用commitid的前几位 git show dfb02 显示HEAD提交日志 git show HEAD 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本 git show HEAD^ 显示已存在的tag git tag 增加v2.0的tag git tag -a v2.0 -m &apos;xxx&apos; 显示v2.0的日志及详细内容 git show v2.0 显示v2.0的日志 git log v2.0 显示所有未添加至index的变更 git diff 显示所有已添加index但还未commit的变更 git diff --cached 比较与上一个版本的差异 git diff HEAD^ 比较与HEAD版本lib目录的差异 git diff HEAD -- ./lib 比较远程分支master上有本地分支master上没有的 git diff origin/master..master 只显示差异的文件，不显示具体内容 git diff origin/master..master --stat 增加远程定义（用于push/pull/fetch） git remote add origin git+ssh://git@192.168.53.168/VT.git 显示本地分支 git branch 显示包含提交50089的分支 git branch --contains 50089 显示所有分支 git branch -a 显示所有原创分支 git branch -r 显示所有已合并到当前分支的分支 git branch --merged 显示所有未合并到当前分支的分支 git branch --no-merged 本地分支改名 git branch -m master master_copy 从当前分支创建新分支master_copy并检出 git checkout -b master_copy 上面的完整版 git checkout -b master master_copy 检出已存在的features/performance分支 git checkout features/performance 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支 git checkout --track hotfixes/BJVEP933 检出版本v2.0 git checkout v2.0 从远程分支develop创建新本地分支devel并检出 git checkout -b devel origin/develop 检出head版本的README文件（可用于修改错误回退） git checkout -- README 合并远程master分支至当前分支 git merge origin/master 合并提交ff44785404a8e的修改 git cherry-pick ff44785404a8e 将当前分支push到远程master分支 git push origin master 删除远程仓库的hotfixes/BJVEP933分支 git push origin :hotfixes/BJVEP933 把所有tag推送到远程仓库 git push --tags 获取所有远程分支（不更新本地分支，另需merge） git fetch 获取所有原创分支并清除服务器上已删掉的分支 git fetch --prune 获取远程分支master并merge到当前分支 git pull origin master 重命名文件README为README2 git mv README README2 将当前版本重置为HEAD（通常用于merge失败回退） git reset --hard HEAD git rebase 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支） git branch -d hotfixes/BJVEP933 强制删除分支hotfixes/BJVEP933 git branch -D hotfixes/BJVEP933 列出git index包含的文件 git ls-files 图示当前分支历史 git show-branch 图示所有分支历史 git show-branch --all 显示提交历史对应的文件修改 git whatchanged 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818 git revert dfb02e6e4f2f7b573337763e5c0013802e392818 内部命令：显示某个git对象 git ls-tree HEAD 内部命令：显示某个ref对于的SHA1 HASH git rev-parse v2.0 显示所有提交，包括孤立节点 git reflog git show HEAD@{5} 显示master分支昨天的状态 git show master@{yesterday} 图示提交日志 git log --pretty=format:&apos;%h %s&apos; --graph git show HEAD~3 git show -s --pretty=raw 2be7fcb476 暂存当前修改，将所有至为HEAD状态 git stash 查看所有暂存 git stash list 参考第一次暂存 git stash show -p stash@{0} 应用第一次暂存 git stash apply stash@{0} 文件中搜索文本“delete from” git grep &quot;delete from&quot; git grep -e &apos;#define&apos; --and -e SORT_DIRENT git gc git fsck]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用css让一个容器水平垂直居中]]></title>
    <url>%2F2017%2F08%2F15%2F%E7%94%A8css%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[阅读目录 方法一：position加margin 方法二： diaplay:table-cell 方法三：position加 transform 方法四：flex;align-items: center;justify-content: center 方法五：display:flex;margin:auto 方法六：纯position 这种css布局平时用的比较多，也是面试题常出的一个题，网上一搜一大丢，不过还是想自己总结一下。 这种方法比较多，本文只总结其中的几种，以便加深印象。 效果图都为这个： 回到顶部 方法一：position加margin/**html**/ &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /**css**/ .wrap { width: 200px; height: 200px; background: yellow; position: relative; } .wrap .center { width: 100px; height: 100px; background: green; margin: auto; position: absolute; left: 0; right: 0; top: 0; bottom: 0; } 兼容性：主流浏览器均支持，IE6不支持 回到顶部 方法二： diaplay:table-cell&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /*css*/ .wrap{ width: 200px; height: 200px; background: yellow; display: table-cell; vertical-align: middle; text-align: center; } .center{ display: inline-block; vertical-align: middle; width: 100px; height: 100px; background: green; } 兼容性：由于display:table-cell的原因，IE6\7不兼容 回到顶部 方法三：position加 transform&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap { position: relative; background: yellow; width: 200px; height: 200px;} .center { position: absolute; background: green; top:50%; left:50%; -webkit-transform:translate(-50%,-50%); transform:translate(-50%,-50%); width: 100px; height: 100px; } 兼容性：ie9以下不支持 transform，手机端表现的比较好。 回到顶部 方法四：flex;align-items: center;justify-content: center&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap { background: yellow; width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; } .center { background: green; width: 100px; height: 100px; } 移动端首选 回到顶部 方法五：display:flex;margin:auto&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap { background: yellow; width: 200px; height: 200px; display: flex; } .center { background: green; width: 100px; height: 100px; margin: auto; } 移动端首选 回到顶部 方法六：纯position&lt;!-- html --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;center&quot;&gt;&lt;/div&gt; &lt;/div&gt; /* css */ .wrap { background: yellow; width: 200px; height: 200px; position: relative; } /**方法一**/ .center { background: green; position: absolute; width: 100px; height: 100px; left: 50px; top: 50px; } /**方法二**/ .center { background: green; position: absolute; width: 100px; height: 100px; left: 50%; top: 50%; margin-left:-50px; margin-top:-50px; } 兼容性：适用于所有浏览器 方法六中的方法一计算公式如下： 子元素（conter）的left值计算公式：left=(父元素的宽 - 子元素的宽 ) / 2=(200-100) / 2=50px; 子元素（conter）的top值计算公式：top=(父元素的高 - 子元素的高 ) / 2=(200-100) / 2=50px; 方法二计算公式： left值固定为50%; 子元素的margin-left= -（子元素的宽/2）=-100/2= -50px; top值也一样，固定为50% 子元素的margin-top= -（子元素的高/2）=-100/2= -50px;]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法的时间复杂度和空间复杂度]]></title>
    <url>%2F2017%2F06%2F22%2F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[1 - 算法 算法的定义是这样的：解题方案的准确而完善的描述，是一系列解决问题的清晰指令。巴拉巴拉的，虽然是一小句但还是不想看（题外话：有时候吧专业名词记下来面试的时候还是挺有用的），其实就是解决一个问题的完整性描述。只不过这个描述就可能是用不同的方式或者说是“语言”了。 2 - 算法的效率 既然算法是解决问题的描述，那么就像一千个人眼中有一千个阿姆雷特他大姨夫一样，解决同一个问题的办法也是多种多样的，只是在这过程中我们所使用/消耗的时间或者时间以外的代价（计算机消耗的则为内存了）不一样。为了更快、更好、更强的发扬奥利奥..哦不，提高算法的效率。所以很多时候一个优秀的算法就在于它与其他实现同一个问题的算法相比，在时间或空间（内存）或者时间和空间（内存）上都得到明显的降低。 所以呢，算法的效率主要由以下两个复杂度来评估： 时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。 设计算法时，时间复杂度要比空间复杂度更容易出问题，所以一般情况一下我们只对时间复杂度进行研究。一般面试或者工作的时候没有特别说明的话，复杂度就是指时间复杂度。 2.0 - 时间复杂度 接下来我们还需要知道另一个概念：时间频度。这个时候你可能会说：“不是说好一起学算法吗，这些东东是什么？赠品吗？”。非也非也，这是非卖品。 因为一个算法执行所消耗的时间理论上是不能算出来的，没错正是理论上，so我们任然可以在程序中测试获得。但是我们不可能又没必要对每个算法进行测试，只需要知道大概的哪个算法执行所花费的时间多，哪个花费的时间少就行了。如果一个算法所花费的时间与算法中代码语句执行次数成正比，那么那个算法执行语句越多，它的花费时间也就越多。我们把一个算法中的语句执行次数称为时间频度。通常（ps:很想知道通常是谁）用T(n)表示。 在时间频度T(n)中，n又代表着问题的规模，当n不断变化时，T(n)也会不断地随之变化。为了了解这个变化的规律，时间复杂度这一概念就被引入了。一般情况下算法基础本操作的重复执行次数为问题规模n的某个函数，用也就是时间频度T(n)。如果有某个辅助函数f(n)，当趋于无穷大的时候，T(n)/f(n)的极限值是不为零的某个常数，那么f(n)是T(n)的同数量级函数，记作T(n)=O(f(n))，被称为算法的渐进时间复杂度，又简称为时间复杂度。 2.1 - 大O表示法 用O(n)来体现算法时间复杂度的记法被称作大O表示法 一般我们我们评估一个算法都是直接评估它的最坏的复杂度。 大O表示法O(f(n))中的f(n)的值可以为1、n、logn、n^2 等，所以我们将O(1)、O(n)、O(logn)、O( n^2 )分别称为常数阶、线性阶、对数阶和平方阶。下面我们来看看推导大O阶的方法： 推导大O阶 推导大O阶有一下三种规则： 用常数1取代运行时间中的所有加法常数 只保留最高阶项 去除最高阶的常数 举好多栗子 常数阶 let sum = 0, n = 10; // 语句执行一次 let sum = (1+n)*n/2; // 语句执行一次 console.log(The sum is : ${sum}) //语句执行一次 这样的一段代码它的执行次数为 3 ，然后我们套用规则1，则这个算法的时间复杂度为O(1)，也就是常数阶。 线性阶 let i =0; // 语句执行一次 while (i &lt; n) { // 语句执行n次 console.log(`Current i is ${i}`); //语句执行n次 i++; // 语句执行n次 } 这个算法中代码总共执行了 3n + 1次，根据规则 2-&gt;3，因此该算法的时间复杂度是O(n)。 对数阶 let number = 1; // 语句执行一次 while (number &lt; n) { // 语句执行logn次 number *= 2; // 语句执行logn次 } 上面的算法中，number每次都放大两倍，我们假设这个循环体执行了m次，那么2^m = n即m = logn，所以整段代码执行次数为1 + 2*logn，则f(n) = logn，时间复杂度为O(logn)。 平方阶 for (let i = 0; i &lt; n; i++) { // 语句执行n次 for (let j = 0; j &lt; n; j++) { // 语句执行n^2次 console.log(&apos;I am here!&apos;); // 语句执行n^2 } } 上面的嵌套循环中，代码共执行 2*n^2 + n，则f(n) = n^2。所以该算法的时间复杂度为O(n^2 ) 常见时间复杂度的比较 常见的时间复杂度函数相信大家在大学中都已经见过了，这里也不多做解释了： O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个 Virtual DOM 算法[转]]]></title>
    <url>%2F2017%2F05%2F01%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Virtual-DOM-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目录： 1 前言 2 对前端应用状态管理思考 3 Virtual DOM 算法 4 算法实现 4.1 步骤一：用JS对象模拟DOM树 4.2 步骤二：比较两棵虚拟DOM树的差异 4.3 步骤三：把差异应用到真正的DOM树上 5 结语 6 References 1 前言本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。 2 对前端应用状态管理的思考假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。 这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据：123var sortKey = &quot;new&quot; // 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数var sortType = 1 // 升序还是逆序var data = [&#123;...&#125;, &#123;...&#125;, &#123;..&#125;, ..] // 表格数据 用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。 这样做会导致的后果就是，随着应用程序越来越复杂，需要在JS里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的DOM操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是DOM操作），你需要操作的DOM还是需要操作，只是换了个地方。 既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看这篇介绍）。 MVVM 可以很好的降低我们维护状态 -&gt; 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在JS里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下innerHTML就完事了。 听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，input和textarea的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（Backbone就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。 但是这里要明白和记住这种做法，因为后面你会发现，其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更。 另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：维护状态，更新视图。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。 3 Virtual DOM算法DOM是很慢的。如果我们把一个简单的div元素的属性都打印出来，你会看到： 而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。 相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：1234567891011var element = &#123; tagName:&apos;ul&apos;, // 节点标签名 props: &#123; // DOM的属性，用一个对象存储键值对 id:&apos;list&apos; &#125;, children: [ // 该节点的子节点 &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 1&quot;]&#125;, &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 2&quot;]&#125;, &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 3&quot;]&#125;, ]&#125; 上面对应的HTML写法是：12345&lt;ulid=&apos;list&apos;&gt; &lt;liclass=&apos;item&apos;&gt;Item 1&lt;/li&gt; &lt;liclass=&apos;item&apos;&gt;Item 2&lt;/li&gt; &lt;liclass=&apos;item&apos;&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。 之前的章节所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。 这就是所谓的 Virtual DOM 算法。包括几个步骤： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 4 算法实现4.1 步骤一：用JS对象模拟DOM树用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js123456789functionElement (tagName, props, children) &#123; this.tagName= tagName this.props= props this.children= children&#125;module.exports=function (tagName, props, children) &#123; returnnewElement(tagName, props, children)&#125; 例如上面的 DOM 结构就可以简单的表示：1234567var el =require(&apos;./element&apos;)var ul =el(&apos;ul&apos;, &#123;id:&apos;list&apos;&#125;, [ el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 1&apos;]), el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 2&apos;]), el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 3&apos;])]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的&lt;ul&gt;：1234567891011121314Element.prototype.render=function () &#123; var el =document.createElement(this.tagName) // 根据tagName构建var props =this.propsfor (var propName in props) &#123; // 设置节点的DOM属性var propValue = props[propName] el.setAttribute(propName, propValue) &#125; var children =this.children|| [] children.forEach(function (child) &#123; var childEl = (child instanceofElement) ?child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点:document.createTextNode(child) // 如果字符串，只构建文本节点el.appendChild(childEl) &#125;) return el&#125; render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要：12var ulRoot =ul.render()document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的&lt;ul&gt;的DOM结构：12345&lt;ulid=&apos;list&apos;&gt; &lt;liclass=&apos;item&apos;&gt;Item 1&lt;/li&gt; &lt;liclass=&apos;item&apos;&gt;Item 2&lt;/li&gt; &lt;liclass=&apos;item&apos;&gt;Item 3&lt;/li&gt;&lt;/ul&gt; 完整代码可见 element.js。 4.2 步骤二：比较两棵虚拟DOM树的差异正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比： 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 4.2.1 深度优先遍历，记录差异在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。1234567891011121314151617181920// diff 函数，对比两棵树functiondiff (oldTree, newTree) &#123; var index =0// 当前节点的标志var patches = &#123;&#125; // 用来记录每个节点差异的对象dfsWalk(oldTree, newTree, index, patches) return patches&#125;// 对两棵树进行深度优先遍历functiondfsWalk (oldNode, newNode, index, patches) &#123; // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches)&#125;// 遍历子节点functiondiffChildren (oldChildren, newChildren, index, patches) &#123; var leftNode =nullvar currentNodeIndex = index oldChildren.forEach(function (child, i) &#123; var newChild = newChildren[i] currentNodeIndex = (leftNode &amp;&amp;leftNode.count) // 计算节点的标识? currentNodeIndex +leftNode.count+1: currentNodeIndex +1dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child &#125;)&#125; 例如，上面的div和新的div有差异，当前的标记是0，那么：1patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同 同理p是patches[1]，ul是patches[3]，类推。 4.2.2 差异类型上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型：1234var REPLACE = 0var REORDER = 1var PROPS = 2var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下：1234patches[0] = [&#123; type:REPALCE, node: newNode // el(&apos;section&apos;, props, children)&#125;] 如果给div新增了属性id为container，就记录下：123456789patches[0] = [&#123; type:REPALCE, node: newNode // el(&apos;section&apos;, props, children)&#125;, &#123; type:PROPS, props: &#123; id:&quot;container&quot; &#125;&#125;] 如果是文本节点，如上面的文本节点2，就记录下：1234patches[2] = [&#123; type:TEXT, content:&quot;Virtual DOM2&quot;&#125;] 那如果把我div的子节点重新排序呢？例如p, ul, div的顺序换成了div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 这牵涉到两个列表的对比算法，需要另外起一个小节来讨论。 4.2.3 列表对比算法假设现在可以英文字母唯一地标识每一个子节点：旧的节点顺序： a b c d e f g h i 现在对节点进行了删除、插入、移动的操作。新增j节点，删除e节点，移动h节点：新的节点顺序： a b c h d f g i j 现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考代码。 我们能够获取到某个父节点的子节点的操作，就可以记录下来：1234patches[0] = [&#123; type:REORDER, moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]&#125;] 但是要注意的是，因为tagName是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识key，列表对比的时候，使用key进行对比，这样才能复用老的 DOM 树上的节点。 这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 diff.js。 4.3 步骤三：把差异应用到真正的DOM树上因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。1234567891011121314functionpatch (node, patches) &#123; var walker = &#123;index:0&#125; dfsWalk(node, walker, patches)&#125;functiondfsWalk (node, walker, patches) &#123; var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异var len =node.childNodes?node.childNodes.length:0for (var i =0; i &lt; len; i++) &#123; // 深度遍历子节点var child =node.childNodes[i] walker.index++dfsWalk(child, walker, patches) &#125; if (currentPatches) &#123; applyPatches(node, currentPatches) // 对当前节点进行DOM操作 &#125;&#125; applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：123456789101112131415functionapplyPatches (node, currentPatches) &#123; currentPatches.forEach(function (currentPatch) &#123; switch (currentPatch.type) &#123; caseREPLACE: node.parentNode.replaceChild(currentPatch.node.render(), node) breakcaseREORDER: reorderChildren(node, currentPatch.moves) breakcasePROPS: setProps(node, currentPatch.props) breakcaseTEXT: node.textContent=currentPatch.contentbreakdefault: thrownewError(&apos;Unknown patch type &apos;+currentPatch.type) &#125; &#125;)&#125; 完整代码可见 patch.js。 5 结语Virtual DOM 算法主要是实现上面步骤的三个函数：element，diff，patch。然后就可以实际的进行使用：12345678910111213141516171819202122// 1. 构建虚拟DOMvar tree =el(&apos;div&apos;, &#123;&apos;id&apos;:&apos;container&apos;&#125;, [ el(&apos;h1&apos;, &#123;style:&apos;color: blue&apos;&#125;, [&apos;simple virtal dom&apos;]), el(&apos;p&apos;, [&apos;Hello, virtual-dom&apos;]), el(&apos;ul&apos;, [el(&apos;li&apos;)])])// 2. 通过虚拟DOM构建真正的DOMvar root =tree.render()document.body.appendChild(root)// 3. 生成新的虚拟DOMvar newTree =el(&apos;div&apos;, &#123;&apos;id&apos;:&apos;container&apos;&#125;, [ el(&apos;h1&apos;, &#123;style:&apos;color: red&apos;&#125;, [&apos;simple virtal dom&apos;]), el(&apos;p&apos;, [&apos;Hello, virtual-dom&apos;]), el(&apos;ul&apos;, [el(&apos;li&apos;), el(&apos;li&apos;)])])// 4. 比较两棵虚拟DOM树的不同var patches =diff(tree, newTree)// 5. 在真正的DOM元素上应用变更patch(root, patches) 当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。 本文所实现的完整代码存放在 Github，仅供学习。 本文所实现的完整代码存放在 Github。]]></content>
      <tags>
        <tag>Virtual DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简化版的vue-router]]></title>
    <url>%2F2017%2F04%2F18%2F%E7%AE%80%E5%8C%96%E7%89%88%E7%9A%84vue-router%2F</url>
    <content type="text"><![CDATA[本文旨在介绍vue-router的实现思路，并动手实现一个简化版的vue-router。我们先来看一下一般项目中对vue-router最基本的一个使用，可以看到，这里定义了四个路由组件,我们只要在根vue实例中注入该router对象就可以使用了. import VueRouter from&apos;vue-router&apos;; import Home from&apos;@/components/Home&apos;; import A from&apos;@/components/A&apos;; import B from&apos;@/components/B&apos;import C from&apos;@/components/C&apos; Vue.use(VueRouter) export default new VueRouter.Router({ // mode: &apos;history&apos;, routes: [ { path: &apos;/&apos;, component: Home }, { path: &apos;/a&apos;, component: A }, { path: &apos;/b&apos;, component: B }, { path: &apos;/c&apos;, component: C } ] }) vue-router提供两个全局组件，router-view和router-link，前者是用于路由组件的占位，后者用于点击时跳转到指定路由。此外组件内部可以通过this.$router.push,this.$rouer.replace等api实现路由跳转。本文将实现上述两个全局组件以及push和replace两个api，调用的时候支持params传参，并且支持hash和history两种模式，忽略其余api、嵌套路由、异步路由、abstract路由以及导航守卫等高级功能的实现，这样有助于理解vue-router的核心原理。本文的最终代码不建议在生产环境使用，只做一个学习用途，下面我们就来一步步实现它。 install实现任何一个vue插件都要实现一个install方法，通过Vue.use调用插件的时候就是在调用插件的install方法，那么路由的install要做哪些事情呢？首先我们知道 我们会用new关键字生成一个router实例，就像前面的代码实例一样，然后将其挂载到根vue实例上，那么作为一个全局路由，我们当然需要在各个组件中都可以拿到这个router实例。另外我们使用了全局组件router-view和router-link，由于install会接收到Vue构造函数作为实参，方便我们调用Vue.component来注册全局组件。因此，在install中主要就做两件事，给各个组件都挂载router实例，以及实现router-view和router-link两个全局组件。下面是代码： const install = (Vue) =&gt; { if (this._Vue) { return; }; Vue.mixin({ beforeCreate() { if (this.$options &amp;&amp; this.$options.router) { this._routerRoot = this; this._router = this.$options.router; Vue.util.defineReactive(this, &apos;_routeHistory&apos;, this._router.history) } else { this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this } Object.defineProperty(this, &apos;$router&apos;, { get() { returnthis._routerRoot._router; } }) Object.defineProperty(this, &apos;$route&apos;, { get() { return { current: this._routerRoot._routeHistory.current, ...this._routerRoot._router.route }; } }) } }); Vue.component(&apos;router-view&apos;, { render(h) { ... } }) Vue.component(&apos;router-link&apos;, { props: { to: String, tag: String, }, render(h) { ... } }) this._Vue = Vue; } 这里的this代表的就是vue-router对象，它有两个属性暴露出来供外界调用，一个是install，一个是Router构造函数，这样可以保证插件的正确安装以及路由实例化。我们先忽略Router构造函数，来看install，上面代码中的this._Vue是个开始没有定义的属性，他的目的是防止多次安装。我们使用Vue.mixin对每个组件的beforeCreate钩子做全局混入，目的是让每个组件实例共享router实例，即通过this.$router拿到路由实例，通过this.$route拿到路由状态。需要重点关注的是这行代码： Vue.util.defineReactive(this, &apos;_routeHistory&apos;, this._router.history) 这行代码利用vue的响应式原理，对根vue实例注册了一个_routeHistory属性，指向路由实例的history对象，这样history也变成了响应式的。因此一旦路由的history发生变化，用到这个值的组件就会触发render函数重新渲染，这里的组件就是router-view。从这里可以窥察到vue-router实现的一个基本思路。上述的代码中对于两个全局组件的render函数的实现，因为会依赖于router对象，我们先放一放，稍后再来实现它们，下面我们分析一下Router构造函数。 Router构造函数经过刚才的分析，我们知道router实例需要有一个history对象，需要一个保存当前路由状态的对象route，另外很显然还需要接受路由配置表routes，根据routes需要一个路由映射表routerMap来实现组件搜索，还需要一个变量mode判断是什么模式下的路由，需要实现push和replace两个api，代码如下： const Router = function (options) { this.routes = options.routes; // 存放路由配置this.mode = options.mode || &apos;hash&apos;; this.route = Object.create(null), // 生成路由状态this.routerMap = createMap(this.routes) // 生成路由表this.history = new RouterHistory(); // 实例化路由历史对象this.init(); // 初始化 } Router.prototype.push = (options) =&gt; { ... } Router.prototype.replace = (options) =&gt; { ... } Router.prototype.init = () =&gt; { ... } 我们看一下路由表routerMap的实现，由于不考虑嵌套等其他情况，实现很简单，如下： const createMap = (routes) =&gt; { let resMap = Object.create(null); routes.forEach(route =&gt; { resMap[route[&apos;path&apos;]] = route[&apos;component&apos;]; }) return resMap; } RouterHistory的实现也很简单，根据前面分析，我们只需要一个current属性就可以，如下： const RouterHistory = function (mode) { this.current = null; } 有了路由表和history，router-view的实现就很容易了，如下： Vue.component(&apos;router-view&apos;, { render(h) { let routerMap = this._self.$router.routerMap; return h(routerMap[this._self.$route.current]) } }) 这里的this是一个renderProxy实例，他有一个属性_self可以拿到当前的组件实例，进而访问到routerMap，可以看到路由实例history的current本质上就是我们配置的路由表中的path。 接下来我们看一下Router要做哪些初始化工作。对于hash路由而言，url上hash值的改变不会引起页面刷新，但是可以触发一个hashchange事件。由于路由history.current初始为null，因此匹配不到任何一个路由，所以会导致页面刷新加载不出任何路由组件。基于这两点，在init方法中，我们需要实现对页面加载完成的监听，以及hash变化的监听。对于history路由，为了实现浏览器前进后退时准确渲染对应组件，还要监听一个popstate事件。代码如下: Router.prototype.init = function () { if (this.mode === &apos;hash&apos;) { fixHash() window.addEventListener(&apos;hashchange&apos;, () =&gt; { this.history.current = getHash(); }) window.addEventListener(&apos;load&apos;, () =&gt; { this.history.current = getHash(); }) } if (this.mode === &apos;history&apos;) { removeHash(this); window.addEventListener(&apos;load&apos;, () =&gt; { this.history.current = location.pathname; }) window.addEventListener(&apos;popstate&apos;, (e) =&gt; { if (e.state) { this.history.current = e.state.path; } }) } } 当启用hash模式的时候，我们要检测url上是否存在hash值，没有的话强制赋值一个默认path，hash路由时会根据hash值作为key来查找路由表。fixHash和getHash实现如下： const fixHash = () =&gt; { if (!location.hash) { location.hash = &apos;/&apos;; } } const getHash = () =&gt; { return location.hash.slice(1) || &apos;/&apos;; } 这样在刷新页面和hash改变的时候，current可以得到赋值和更新，页面能根据hash值准确渲染路由。history模式也是一样的道理，只是它通过location.pathname作为key搜索路由组件，另外history模式需要去除url上可能存在的hash,removeHash实现如下： const removeHash = (route) =&gt; { let url = location.href.split(&apos;#&apos;)[1] if (url) { route.current = url; history.replaceState({}, null, url) } } 我们可以看到当浏览器后退的时候，history模式会触发popstate事件，这个时候是通过state状态去获取path的，那么state状态从哪里来呢，答案是从window.history对象的pushState和replaceState而来，这两个方法正好可以用来实现router的push方法和replace方法，我们看一下这里它们的实现： Router.prototype.push = (options) =&gt; { this.history.current = options.path; if (this.mode === &apos;history&apos;) { history.pushState({ path: options.path }, null, options.path); } elseif (this.mode === &apos;hash&apos;) { location.hash = options.path; } this.route.params = { ...options.params } } Router.prototype.replace = (options) =&gt; { this.history.current = options.path; if (this.mode === &apos;history&apos;) { history.replaceState({ path: options.path }, null, options.path); } elseif (this.mode === &apos;hash&apos;) { location.replace(`#${options.path}`) } this.route.params = { ...options.params } } pushState和replaceState能够实现改变url的值但不引起页面刷新，从而不会导致新请求发生，pushState会生成一条历史记录而replaceState不会，后者只是替换当前url。在这两个方法执行的时候将path存入state，这就使得popstate触发的时候可以拿到路径从而触发组件渲染了。我们在组件内按照如下方式调用，会将params写入router实例的route属性中，从而在跳转后的组件B内通过this.$route.params可以访问到传参。 this.$router.push({ path: &apos;/b&apos;, params: { id: 55 } }); router-link实现router-view的实现很简单，前面已经说过。最后，我们来看一下router-link的实现,先放上代码： Vue.component(&apos;router-link&apos;, { props: { to: String, tag: String, }, render(h) { let mode = this._self.$router.mode; let tag = this.tag || &apos;a&apos;; let routerHistory = this._self.$router.history; return h(tag, { attrs: tag === &apos;a&apos; ? { href: mode === &apos;hash&apos; ? &apos;#&apos; + this.to : this.to, } : {}, on: { click: (e) =&gt; { if (this.to === routerHistory.current) { e.preventDefault(); return; } routerHistory.current = this.to; switch (mode) { case&apos;hash&apos;: if (tag === &apos;a&apos;) return; location.hash = this.to; break; case&apos;history&apos;: history.pushState({ path: this.to }, null, this.to); break; default: } e.preventDefault(); } }, style: { cursor: &apos;pointer&apos; } }, this.$slots.default) } }) router-link可以接受两个属性，to表示要跳转的路由路径，tag表示router-link要渲染的标签名，默认a为标签。如果是a标签，我们为其添加一个href属性。我们给标签绑定click事件，如果检测到本次跳转为当前路由的话什么都不做直接返回，并且阻止默认行为，否则根据to更换路由。hash模式下并且是a标签时候可以直接利用浏览器的默认行为完成url上hash的替换，否者重新为location.hash赋值。history模式下则利用pushState去更新url。 以上实现就是一个简单的vue-router.]]></content>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生 JS 汇总]]></title>
    <url>%2F2017%2F03%2F01%2F%E5%8E%9F%E7%94%9F-JS-%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[JS选取DOM元素的方法 注意：原生JS选取DOM元素比使用jQuery类库选取要快很多 1、通过ID选取元素 document.getElementById(&apos;myid&apos;); 2、通过CLASS选取元素 document.getElementsByClassName(&apos;myclass&apos;)[0]; 3、通过标签选取元素 document.getElementsByTagName(&apos;mydiv&apos;)[0]; 4、通过NAME属性选取元素（常用于表单） document.getElementsByName(&apos;myname&apos;)[0]; JS修改CSS样式 document.getElementById(&apos;myid&apos;).style.display = &apos;none&apos;; class 操作： JS修改CLASS属性 document.getElementById(&apos;myid&apos;).className = &apos;active&apos;; 如果有多个CLASS属性，即用空格隔开 document.getElementById(&apos;myid&apos;).className = &apos;active div-1&apos;; 移除该元素上的所有CLASS document.getElementById(&apos;myid&apos;).className = &apos;&apos;; 注意：使用classList会优于使用className document.getElementById(&apos;myid&apos;).classList.item(0);//item为类名的索引 document.getElementById(&apos;myid&apos;).classList.length;//只读属性 document.getElementById(&apos;myid&apos;).classList.add(&apos;newClass&apos;);//添加class document.getElementById(&apos;myid&apos;).classList.remove(&apos;newClass&apos;);//移除class document.getElementById(&apos;myid&apos;).classList.toggle(&apos;newClass&apos;);//切换，有则移除，没有则添加 document.getElementById(&apos;myid&apos;).classList.contains(&apos;newClass&apos;);//判断是否存在该class 补充：add和remove方法不允许链式操作，因为返回的都是undefined，其次，也不允许同时添加或删除多个class，可以自行扩展一下 DOMTokenList.prototype.adds = function(tokens){ tokens.split(&apos; &apos;).forEach(function(token){ this.add(token); }).bind(this)); return this; }; var clList = document.body.classList; clList.adds(&apos;a b c&apos;).toString(); //a b c JS修改文本 document.getElementById(&apos;myid&apos;).innerHTML = &apos;123&apos;; JS创建元素并向其中追加文本 var newdiv = document.createElement(&apos;div&apos;); var newtext = document.createTextNode(&apos;123&apos;); newdiv.appendChild(newtext); document.body.appendChild(newdiv); 同理：removeChild()移除节点，并返回节点 cloneNode()复制节点 insertBefore()插入节点（父节点内容的最前面） 注意：insertBefore()有两个参数，第一个是插入的节点，第二个是插入的位置 例子： var list = document.getElementById(&apos;myList&apos;); list.insertBefore(newItem,list.childNodes[1]); //插入新节点newItem到list的第二个子节点 JS返回所有子节点对象childNodes var mylist = document.getElementById(&apos;myid&apos;); for(var i=0,i&lt;mylist.childNodes.length;i++){ console.log(mylist.childNodes[i]); } firstChild返回第一个子节点 lastChild返回最后一个子节点 parentNode返回父节点对象 nextSibling返回下一个兄弟节点对象 previousSibling返回前一个兄弟节点对象 nodeName返回节点的HTML标记名称 原生JS汇总： 一、节点 1.1 节点属性 Node.nodeName //返回节点名称，只读 Node.nodeType //返回节点类型的常数值，只读 Node.nodeValue //返回Text或Comment节点的文本值，只读 Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写 Node.baseURI //返回当前网页的绝对路径 Node.ownerDocument //返回当前节点所在的顶层文档对象，即document Node.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点 Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点 Node.parentNode //返回当前节点的父节点 Node.parentElement //返回当前节点的父Element节点 Node.childNodes //返回当前节点的所有子节点 Node.firstChild //返回当前节点的第一个子节点 Node.lastChild //返回当前节点的最后一个子节点 //parentNode接口 Node.children //返回指定节点的所有Element子节点 Node.firstElementChild //返回当前节点的第一个Element子节点 Node.lastElementChild //返回当前节点的最后一个Element子节点 Node.childElementCount //返回当前节点所有Element子节点的数目。 1.2 操作 Node.appendChild(node) //向节点添加最后一个子节点 Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点 Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代) Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点 Node.removeChild(node) //删除节点，在要删除节点的父节点上操作 Node.replaceChild(newChild,oldChild) //替换节点 Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。 Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系 Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。 Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。 //ChildNode接口 Node.remove() //用于删除当前节点 Node.before() // Node.after() Node.replaceWith() 1.3 Document节点 1.3.1 Document节点的属性 document.doctype // document.documentElement //返回当前文档的根节点 document.defaultView //返回document对象所在的window对象 document.body //返回当前文档的&lt;body&gt;节点 document.head //返回当前文档的&lt;head&gt;节点 document.activeElement //返回当前文档中获得焦点的那个元素。 //节点集合属性 document.links //返回当前文档的所有a元素 document.forms //返回页面中所有表单元素 document.images //返回页面中所有图片元素 document.embeds //返回网页中所有嵌入对象 document.scripts //返回当前文档的所有脚本 document.styleSheets //返回当前网页的所有样式表 //文档信息属性 document.documentURI //表示当前文档的网址 document.URL //返回当前文档的网址 document.domain //返回当前文档的域名 document.lastModified //返回当前文档最后修改的时间戳 document.location //返回location对象，提供当前文档的URL信息 document.referrer //返回当前文档的访问来源 document.title //返回当前文档的标题 document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。 document.readyState //返回当前文档的状态 document.designMode //控制当前文档是否可编辑，可读写 document.compatMode //返回浏览器处理文档的模式 document.cookie //用来操作Cookie 1.3.2 Document节点的方法 （1）读写方法 document.open() //用于新建并打开一个文档 document.close() //不安比open方法所新建的文档 document.write() //用于向当前文档写入内容 document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 （2）查找节点 document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。 document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。 document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素 document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素 document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等） document.getElementById(id) //返回匹配指定id属性的元素节点。 document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。 （3）生成节点 document.createElement(tagName) //用来生成HTML元素节点。 document.createTextNode(text) //用来生成文本节点 document.createAttribute(name) //生成一个新的属性对象节点，并返回它。 document.createDocumentFragment() //生成一个DocumentFragment对象 （4）事件方法 document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用 document.addEventListener(type,listener,capture) //注册事件 document.removeEventListener(type,listener,capture) //注销事件 document.dispatchEvent(event) //触发事件 （5）其他 document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。 document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。 document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 1.4 Element节点 1.4.1 Element节点的属性 （1）特性属性 Element.attributes //返回当前元素节点的所有属性节点 Element.id //返回指定元素的id属性，可读写 Element.tagName //返回指定元素的大写标签名 Element.innerHTML //返回该元素包含的HTML代码，可读写 Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写 Element.className //返回当前元素的class属性，可读写 Element.classList //返回当前元素节点的所有class集合 Element.dataset //返回元素节点中所有的data-*属性。 （2）尺寸属性 Element.clientHeight //返回元素节点可见部分的高度 Element.clientWidth //返回元素节点可见部分的宽度 Element.clientLeft //返回元素节点左边框的宽度 Element.clientTop //返回元素节点顶部边框的宽度 Element.scrollHeight //返回元素节点的总高度 Element.scrollWidth //返回元素节点的总宽度 Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置 Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值 Element.offsetHeight //返回元素的垂直高度(包含border,padding) Element.offsetWidth //返回元素的水平宽度(包含border,padding) Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移 Element.offsetTop //返回水平位移 Element.style //返回元素节点的行内样式 （3）节点相关属性 Element.children //包括当前元素节点的所有子元素 Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数 Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点 Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点 Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。 1.4.2 Element节点的方法 （1）位置方法 getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高 // top 元素上外边界距窗口最上面的距离 // right 元素右外边界距窗口最上面的距离 // bottom 元素下外边界距窗口最上面的距离 // left 元素左外边界距窗口最上面的距离 // width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。 // 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return { top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft } （2）属性方法 Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性 （3）查找方法 Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() （4）事件方法 Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件 //ie8 Element.attachEvent(oneventName,listener) Element.detachEvent(oneventName,listener) // event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement; // 事件代理 ul.addEventListener(&apos;click&apos;, function(event) { if (event.target.tagName.toLowerCase() === &apos;li&apos;) { console.log(event.target.innerHTML) } }); （5）其他 Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域 //解析HTML字符串，然后将生成的节点插入DOM树的指定位置。 Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入 Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入 Element.remove() //用于将当前元素节点从DOM中移除 Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS操作 （1）类名操作 //ie8以下 Element.className //获取元素节点的类名 Element.className += &apos; &apos; + newClassName //新增一个类名 //判断是否有某个类名 function hasClass(element,className){ return new RegExp(className,&apos;gi&apos;).test(element.className); } //移除class function removeClass(element,className){ element.className = element.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;); } //ie10 element.classList.add(className) //新增 element.classList.remove(className) //删除 element.classList.contains(className) //是否包含 element.classList.toggle(className) //toggle class （2）style操作 element.setAttribute(&apos;style&apos;,&apos;&apos;) element.style.backgroundColor = &apos;red&apos; element.style.cssText //用来读写或删除整个style属性 element.style.setProperty(propertyName,value) //设置css属性 element.style.getPropertyValue(property) //获取css属性 element.style.removeProperty(property) //删除css属性 操作非内联样式 //ie8 element.currentStyle[attrName] //ie9+ window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName) //伪类 window.getComputedStyle(el,&apos;:after&apos;)[attrName] 三、对象 3.1 Object对象 （1）生成实例对象 var o = new Object() （2）属性 Object.prototype //返回原型对象 （3）方法 Object.keys(o) //遍历对象的可枚举属性 Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法 valueOf()：返回当前对象对应的值。 toString()：返回当前对象对应的字符串形式。 toLocaleString()：返回当前对象对应的本地字符串形式。 hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。 propertyIsEnumerable()：判断某个属性是否可枚举。 3.2 Array对象 （1）生成实例对象 var a = new Array() （2）属性 a.length //长度 （3）Array.isArray() Array.isArray(a) //用来判断一个值是否为数组 （4）Array实例的方法 [1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot; a.valueof() //返回数组本身 a.toString() //返回数组的字符串形式 a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。 pop() //用于删除数组的最后一个元素，并返回该元素 join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。 concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。 shift() //用于删除数组的第一个元素，并返回该元素。 unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。 reverse() //用于颠倒数组中元素的顺序，返回改变后的数组 slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。 splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。 sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。 map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。 map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。 forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。 filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。 reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员） reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员） indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 3.3 Number对象 （1）生成对象 var n = new Number() （2）Number对象的属性 Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 （4）Number对象实例的方法 toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。 toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。 toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。 toPrecision() //用于将一个数转为指定位数的有效数字。 3.4 String 对象 （1）生成实例对象 var s = new String() （2）String对象的属性 s.length //返回字符串的长度 （3）方法 s.chatAt(index) //返回指定位置的字符 //&quot;123456&quot;[0] == &quot;1&quot; s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。 s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示） s.concat(s2) //用于连接两个字符串 s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。 s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。 s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。 s.trim() //用于去除字符串两端的空格，返回一个新字符串 s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。 s.toUpperCase() //全部转为大写 s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。 s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 3.5 Math对象 （1）属性 Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 （2）数学方法 Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。 Math.exp()：返回e的指数，也就是常数e的参数次方。 Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 （3）三角函数方法 Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） 3.6 JSON对象 （1）方法 JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。 //（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。 //还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 JSON.parse() //用于将JSON字符串转化成对象。 3.7 console对象 （1）方法 console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。 console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。 console.warn() //输出信息时，在最前面加一个黄色三角，表示警告； console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈 console.table() //可以将复合类型的数据转为表格显示。 console.count() //用于计数，输出它被调用了多少次。 console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。 console.dirxml() //用于以目录树的形式，显示DOM节点。 console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 //这两个方法用于计时，可以算出一个操作所花费的准确时间。 console.time() console.timeEnd() //time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。 console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。 console.profileEnd() //用来结束正在运行的性能测试器。 console.group() console.groupend() //上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。 console.trace() //显示当前执行的代码在堆栈中的调用路径。 console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。 正则表达式： 只允许输入汉字：onkeyup=&quot;value=value.replace(/[^\u4E00-\u9FA5]/g,&apos;&apos;)&quot; 只允许输入数字：onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot; [1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot; 例子： &lt;ul class=”main”&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; 请用原生JS实现： &lt;ul class=”main”&gt; &lt;div&gt;A&lt;/div&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;div&gt;B&lt;/div&gt; &lt;/ul&gt; &lt;body&gt; &lt;ul id=&quot;main&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; var main=document.getElementById(&quot;main&quot;); var DIV=document.createElement(&quot;div&quot;); DIV.innerText=&quot;B&quot;; var P=document.createElement(&quot;p&quot;); P.innerText=&quot;A&quot;; main.appendChild(DIV); main.insertBefore(P, main.firstChild); &lt;/script&gt; &lt;/body&gt; JQuery选择器： 0、常用选择器 $(&apos;#div1&apos;) //id为div1的节点，如&lt;div id=&apos;div1&apos;&gt;&lt;/div&gt; $(&apos;span&apos;) //所有的span结点，一个包装集 $(&apos;p span&apos;) //p标签下的所有span节点，后代节点 $(&apos;p&gt;span&apos;) //p标签下的所有span子节点，子代节点 $(&apos;.red&apos;) //使用样式red的节点，如&lt;span class=&quot;red&quot;&gt;&lt;/span&gt; $(&apos;*&apos;) //所有节点 $(&quot;div,span,p.cls&quot;) //选取所有&lt;div&gt;，&lt;span&gt;和拥有class为cls的&lt;p&gt;标签的一组元素 1、基本筛选器 $(&apos;span:first&apos;) //第一个节点 $(&apos;span:last&apos;) //最后一个节点 $(&quot;td:even&quot;) //索引为偶数的节点，从 0 开始 $(&quot;td:odd&quot;) //索引为奇数的节点，从 0 开始 $(&quot;td:eq(1)&quot;) //给定索引值的节点 $(&quot;td:gt(0)&quot;) //大于给定索引值的节点 $(&quot;td:lt(2)&quot;) //小于给定索引值的节点 $(&quot;:focus&quot;) //当前获取焦点的节点 $(&quot;:animated&quot;) //正在执行动画效果的节点 2、内容选择器 $(&quot;div:contains(&apos;hello&apos;)&quot;) //包含hello文本的节点 $(&quot;td:empty&quot;) //不包含子节点或者文本的空节点 $(&quot;div:has(p)&quot;) //含有选择器所匹配的节点 $(&quot;td:parent&quot;) //含有子节点或者文本的节点 3、表单选择器 $(&quot;input:checked&quot;) //所有选中的节点 $(&quot;select option:selected&quot;) //select中所有选中的option节点 $(&quot;:input&quot;) //匹配所有 input, textarea, select 和 button 节点 $(&quot;:text&quot;) //所有的单行文本框 $(&quot;:password&quot;) //所有密码框 $(&quot;:radio&quot;) //所有单选按钮 $(&quot;:checkbox&quot;) //所有复选框 $(&quot;:submit&quot;) //所有提交按钮 $(&quot;:reset&quot;) //所有重置按钮 $(&quot;:button&quot;) //所有button按钮 $(&quot;:file&quot;) //所有文件域 4、筛选与查找 $(&quot;p&quot;).eq(0) //当前操作中第N个jQuery对象,类似索引 $(&apos;li&apos;).first() //第一个节点 $(&apos;li&apos;).last() //最后一个节点 $(this).hasClass(&quot;node&quot;) //节点是否含有某个特定的类,返回布尔值 $(&apos;li&apos;).has(&apos;ul&apos;) //包含特定后代的节点 $(&quot;div&quot;).children() //div中的每个子节点,第一层 $(&quot;div&quot;).find(&quot;span&quot;) //查找div下的所有span节点 $(&quot;p&quot;).next() //紧邻p节点后的一个同辈节点 $(&quot;p&quot;).nextAll() //p节点之后所有的同辈节点 $(&quot;#node&quot;).nextUntil(&quot;#node2&quot;) //id为&quot;#node&quot;节点之后到id为&apos;#node2&apos;之间所有的同辈节点,掐头去尾 $(&quot;p&quot;).prev() //紧邻p节点前的一个同辈节点 $(&quot;p&quot;).prevAll() //p节点之前所有的同辈节点 $(&quot;#node&quot;).prevUntil(&quot;#node2&quot;) //id为&quot;#node&quot;节点之前到id为&apos;#node2&apos;之间所有的同辈节点,掐头去尾 $(&quot;p&quot;).parent() //每个p节点的父节点 $(&quot;p&quot;).parents() //每个p节点的所有祖先节点,body,html $(&quot;#node&quot;).parentsUntil(&quot;#node2&quot;) //id为&quot;#node&quot;节点到id为&apos;#node2&apos;之间所有的父级节点,掐头去尾 $(&quot;div&quot;).siblings() //所有的同辈节点,不包括自己 5、属性操作 $(&quot;img&quot;).attr(&quot;src&quot;); //返回文档中所有图像的src属性值 $(&quot;img&quot;).attr(&quot;src&quot;,&quot;node.jpg&quot;); //设置所有图像的src属性 $(&quot;img&quot;).removeAttr(&quot;src&quot;); //将文档中图像的src属性删除 $(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, true); //选中复选框 $(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, false); //不选中复选框 $(&quot;img&quot;).removeProp(&quot;src&quot;); //删除img的src属性 6、样式操作 $(&quot;p&quot;).addClass(&quot;selected&quot;); //为p节点加上 &apos;selected&apos; 类 $(&quot;p&quot;).removeClass(&quot;selected&quot;); //从p节点中删除 &apos;selected&apos; 类 $(&quot;p&quot;).toggleClass(&quot;selected&quot;); //如果存在就删除,否则就添加HTML代码/文本/值 7、内容操作 $(&apos;p&apos;).html(); //返回p节点的html内容 $(&quot;p&quot;).html(&quot;Hello &lt;b&gt;hello&lt;/b&gt;!&quot;); //设置p节点的html内容 $(&apos;p&apos;).text(); //返回p节点的文本内容 $(&quot;p&quot;).text(&quot;hello&quot;); //设置p节点的文本内容 $(&quot;input&quot;).val(); //获取文本框中的值 $(&quot;input&quot;).val(&quot;hello&quot;); //设置文本框中的内容 8、CSS操作 $(&quot;p&quot;).css(&quot;color&quot;); //访问查看p节点的color属性 $(&quot;p&quot;).css(&quot;color&quot;,&quot;red&quot;); //设置p节点的color属性为red $(&quot;p&quot;).css({ &quot;color&quot;: &quot;red&quot;, &quot;background&quot;: &quot;yellow&quot; }); //设置p节点的color为red，background属性为yellow（设置多个属性要用{}字典形式） 9、定位与偏移 $(&apos;p&apos;).offset() //节点在当前视口的相对偏移,对象 {top: 5, left: 9} $(&apos;p&apos;).offset().top $(&apos;p&apos;).offset().left $(&quot;p&quot;).position() //节点相对父节点的偏移,对可见节点有效，Object {top: 5, left: 8} $(window).scrollTop() //获取滚轮滑的高度 $(window).scrollLeft() //获取滚轮滑的宽度 $(window).scrollTop(&apos;25&apos;) //设置滚轮滑的高度为25 10、尺寸 $(&quot;p&quot;).height(); //获取p节点的高度 $(&quot;p&quot;).width(); //获取p节点的宽度 $(&quot;p:first&quot;).innerHeight() //获取第一个匹配节点内部区域高度(包括补白、不包括边框) $(&quot;p:first&quot;).innerWidth() //获取第一个匹配节点内部区域宽度(包括补白、不包括边框) $(&quot;p:first&quot;).outerHeight() //匹配节点外部高度(默认包括补白和边框) $(&quot;p:first&quot;).outerWidth() //匹配节点外部宽度(默认包括补白和边框) $(&quot;p:first&quot;).outerHeight(true) //为true时包括边距 11、DOM内部插入 $(&quot;p&quot;).append(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;); //每个p节点内后面追加内容 $(&quot;p&quot;).appendTo(&quot;div&quot;); //p节点追加到div内后 $(&quot;p&quot;).prepend(&quot;&lt;b&gt;Hello&lt;/b&gt;&quot;); //每个p节点内前面追加内容 $(&quot;p&quot;).prependTo(&quot;div&quot;); //p节点追加到div内前 12、DOM外部插入 $(&quot;p&quot;).after(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;); //每个p节点同级之后插入内容 $(&quot;p&quot;).before(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;); //在每个p节点同级之前插入内容 $(&quot;p&quot;).insertAfter(&quot;#node&quot;); //所有p节点插入到id为node节点的后面 $(&quot;p&quot;).insertBefore(&quot;#node&quot;); //所有p节点插入到id为node节点的前面 13、DOM替换 $(&quot;p&quot;).replaceWith(&quot;&lt;b&gt;Paragraph. &lt;/b&gt;&quot;); //将所有匹配的节点替换成指定的HTML或DOM节点 $(&quot;&lt;b&gt;Paragraph. &lt;/b&gt;&quot;).replaceAll(&quot;p&quot;); //用匹配的节点替换掉所有 selector匹配到的节点 14、DOM删除 $(&quot;p&quot;).empty(); //删除匹配的节点集合中所有的子节点，不包括本身 $(&quot;p&quot;).remove(); //删除所有匹配的节点,包括本身 $(&quot;p&quot;).detach(); //删除所有匹配的节点(和remove()不同的是:所有绑定的事件、附加的数据会保留下来) 15、DOM复制 $(&quot;p&quot;).clone() //克隆节点并选中克隆的副本 $(&quot;p&quot;).clone(true) //布尔值指事件处理函数是否会被复制 16、DOM加载完成事件 $(document).ready(function(){ 您的代码... }); //缩写 $(function($) { 您的代码... }); 17、绑定事件 //bind 为每个匹配节点绑定事件处理函数，绑定多个用{}。 $(&quot;p&quot;).bind(&quot;click&quot;, function(){ alert( $(this).text() ); }); $(&apos;#div1&apos;).bind({ &quot;mouseover&quot;:function () { $(&apos;#div1&apos;).parent().removeClass(&quot;hide&quot;); },&quot;mouseout&quot;:function () { $(&apos;#div1&apos;).parent().addClass(&quot;hide&quot;); } }); $(&quot;p&quot;).one( &quot;click&quot;, function(){}) //事件绑定后只会执行一次 $(&quot;p&quot;).unbind( &quot;click&quot; ) //反绑一个事件 // 与bind 不同的是当时间发生时才去临时绑定。 $(&quot;p&quot;).delegate(&quot;click&quot;,function(){ 您的代码 }); $(&quot;p&quot;).undelegate(); //p节点删除由 delegate() 方法添加的所有事件 $(&quot;p&quot;).undelegate(&quot;click&quot;) //从p节点删除由 delegate() 方法添加的所有click事件 $(&quot;p&quot;).click(); //单击事件 $(&quot;p&quot;).dblclick(); //双击事件 $(&quot;input[type=text]&quot;).focus() //节点获得焦点时,触发 focus 事件 $(&quot;input[type=text]&quot;).blur() //节点失去焦点时,触发 blur事件 $(&quot;button&quot;).mousedown()//当按下鼠标时触发事件 $(&quot;button&quot;).mouseup() //节点上放松鼠标按钮时触发事件 $(&quot;p&quot;).mousemove() //当鼠标指针在指定的节点中移动时触发事件 $(&quot;p&quot;).mouseover() //当鼠标指针位于节点上方时触发事件 $(&quot;p&quot;).mouseout() //当鼠标指针从节点上移开时触发事件 $(window).keydown() //当键盘或按钮被按下时触发事件 $(window).keypress() //当键盘或按钮被按下时触发事件,每输入一个字符都触发一次 $(&quot;input&quot;).keyup() //当按钮被松开时触发事件 $(window).scroll() //当用户滚动时触发事件 $(window).resize() //当调整浏览器窗口的大小时触发事件 $(&quot;input[type=&apos;text&apos;]&quot;).change() //当节点的值发生改变时触发事件 $(&quot;input&quot;).select() //当input 节点中的文本被选择时触发事件 $(&quot;form&quot;).submit() //当提交表单时触发事件 $(window).unload() //用户离开页面时 18、事件对象 $(&quot;p&quot;).click(function(event){ alert(event.type); //&quot;click&quot; }); (evnet object)属性方法： event.pageX //事件发生时，鼠标距离网页左上角的水平距离 event.pageY //事件发生时，鼠标距离网页左上角的垂直距离 event.type //事件的类型 event.which //按下了哪一个键 event.data //在事件对象上绑定数据，然后传入事件处理函数 event.target //事件针对的网页节点 event.preventDefault() //阻止事件的默认行为(比如点击链接，会自动打开新页面) event.stopPropagation() //停止事件向上层节点冒泡 19、动态事件绑定 $(&quot;p&quot;).on(&quot;click&quot;,&apos;span&apos;,function(){ alert( $(this).text() ); }); //当p中增加span时仍然有效 20、动画效果 $(&quot;p&quot;).show() //显示隐藏的匹配节点 $(&quot;p&quot;).show(&quot;slow&quot;); //参数表示速度,(&quot;slow&quot;,&quot;normal&quot;,&quot;fast&quot;),也可为600毫秒 $(&quot;p&quot;).hide() //隐藏显示的节点 $(&quot;p&quot;).toggle(); //切换 显示/隐藏 $(&quot;p&quot;).slideDown(&quot;600&quot;); //用600毫秒时间将段落滑下 $(&quot;p&quot;).slideUp(&quot;600&quot;); //用600毫秒时间将段落滑上 $(&quot;p&quot;).slideToggle(&quot;600&quot;); //用600毫秒时间将段落滑上，滑下淡入淡出 $(&quot;p&quot;).fadeIn(&quot;600&quot;); //用600毫秒时间将段落淡入 $(&quot;p&quot;).fadeOut(&quot;600&quot;); //用600毫秒时间将段落淡出 $(&quot;p&quot;).fadeToggle(&quot;600&quot;); //用600毫秒时间将段落淡入,淡出 $(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.6); //用600毫秒时间将段落的透明度调整到0.6 21、工具方法 $(&quot;#form1&quot;).serialize() //序列表表格内容为字符串。 $(&quot;select, :radio&quot;).serializeArray(); //序列化表单元素为数组返回 JSON 数据结构数据 $.trim() //去除字符串两端的空格 $.each() //遍历一个数组或对象，for循环 $.inArray() //返回一个值在数组中的索引位置，不存在返回-1 $.grep() //返回数组中符合某种标准的节点 $.extend({a:1,b:2},{b:3,c:4},{c:5:d:6}) //将多个对象，合并到第一个对象{a:1,b:3,c:5,d:6} $.makeArray() //将对象转化为数组 $.type() //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等 $.isArray() //判断某个参数是否为数组 $.isEmptyObject() //判断某个对象是否为空(不含有任何属性) $.isFunction() //判断某个参数是否为函数 $.isPlainObject() //判断某个参数是否为用&quot;{}&quot;或&quot;new Object&quot;建立的对象 $.support() //判断浏览器是否支持某个特性 22、AJAX //保存数据到服务器，成功时显示信息 $.ajax({ type: &quot;POST&quot;, url: &quot;some.php&quot;, data: &quot;name=John&amp;location=Boston&quot;, success: function(msg){ alert( &quot;Data Saved: &quot; + msg ); } }); //加载 feeds.html 文件内容。 $(&quot;#feeds&quot;).load(&quot;feeds.html&quot;); //请求 test.php 网页，传送2个参数，忽略返回值。 $.get(&quot;test.php&quot;, { name: &quot;John&quot;, time: &quot;2pm&quot; } ); //从 Flickr JSONP API 载入 4 张最新的关于猫的图片。 $.getJSON(&quot;http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;tagmode=any&amp;format =json&amp;jsoncallback=?&quot;, function(data){ $.each(data.items, function(i,item){ $(&quot;&lt;img/&gt;&quot;).attr(&quot;src&quot;, item.media.m).appendTo(&quot;#images&quot;); if ( i == 3 ) return false; }); }); //加载并执行 test.js ，成功后显示信息 $.getScript(&quot;test.js&quot;, function(){ alert(&quot;Script loaded and executed.&quot;); }); //向页面 test.php 发送数据，并输出结果（HTML 或 XML，取决于所返回的内容）： $.post(&quot;test.php&quot;, { name: &quot;John&quot;, time: &quot;2pm&quot; }, function(data){ alert(&quot;Data Loaded: &quot; + data); }); //AJAX 请求完成时执行函数。 $(&quot;#msg&quot;).ajaxComplete(function(event,request, settings){ $(this).append(&quot;&lt;li&gt;请求完成.&lt;/li&gt;&quot;); }); //AJAX 请求失败时显示信息。 $(&quot;#msg&quot;).ajaxError(function(event,request, settings){ $(this).append(&quot;&lt;li&gt;出错页面:&quot; + settings.url + &quot;&lt;/li&gt;&quot;); }); //AJAX 请求发送前显示信息。 $(&quot;#msg&quot;).ajaxSend(function(evt, request, settings){ $(this).append(&quot;&lt;li&gt;开始请求: &quot; + settings.url + &quot;&lt;/li&gt;&quot;); }); //AJAX 请求开始时显示信息。 $(&quot;#loading&quot;).ajaxStart(function(){ $(this).show(); }); //AJAX 请求结束后隐藏信息。 $(&quot;#loading&quot;).ajaxStop(function(){ $(this).hide(); }); //当 AJAX 请求成功后显示消息。 $(&quot;#msg&quot;).ajaxSuccess(function(evt, request, settings){ $(this).append(&quot;&lt;li&gt;请求成功!&lt;/li&gt;&quot;); }); //请求前过滤 $.ajaxPrefilter( function( options, originalOptions, jqXHR ) { // Modify options, control originalOptions, store jqXHR, etc }); //设置全局 AJAX 默认选项，设置 AJAX 请求默认地址为 &quot;/xmlhttp/&quot;，禁止触发全局 AJAX 事件，用 POST 代替默认 GET 方法。其后的 AJAX 请求不再设置任何选项参数。 $.ajaxSetup({ url: &quot;/xmlhttp/&quot;, global: false, type: &quot;POST&quot; }); $.ajax({ data: myData }); JavaScript中巧用位运算 日常前端开发中我们很少用到位运算，容易让人遗忘，让我们一起回顾下一下js中的位运算。 位运算详细说明查看JavaScript|MDN 下面主要回顾一下一些常用的位运算的巧用。 将十进制转化为二进制 var number = 3; var result = number.toString(2); var result2 = 14..toString(2); // &quot;1110&quot; 我们使用位运算来代替Math.floor()来向下取整 var data = 2.2352524535; var result = data | 0; // 2 var re2 = ~~data; // 2 将颜色从RGA转换为Hex格式 var color = {r: 186, g: 218, b: 85}; // RGB to HEX var rgb2hex = function(r, g, b) { return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).substr(1); } rgb2hex(color.r, color.g, color.b);//&quot;#bada55&quot; 区分两个数的大小 // variables var a = 9285; var b = 3569; // 取大 var max = a ^ ((a ^ b) &amp; -(a &lt; b));//9285; // 取小 var min = b ^ ((a ^ b) &amp; -(a &lt; b);//3569 交换变量 var a = 10; var b = 99; a = (b^=a^=b)^a; console.log(a) // 99 console.log(b) // 10 判断正负 function isPos(n) { return (n === (n &gt;&gt;&gt; 0)) ? true : false; } isPos(-1); // false isPos(1); // true 常用函数： /*========================常用函数========================*/ /*时间格式化*/ Date.prototype.Format = function (fmt) { var o = { &quot;M+&quot;: this.getMonth() + 1, /*月份*/ &quot;d+&quot;: this.getDate(), /*日*/ &quot;h+&quot;: this.getHours(), /*小时*/ &quot;m+&quot;: this.getMinutes(), /*分*/ &quot;s+&quot;: this.getSeconds(), /*秒*/ &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), /*季度*/ &quot;S&quot;: this.getMilliseconds() /*毫秒*/ }; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); return fmt; }; /*IE浏览器不支持date(time),所以用此方法转换*/ function NewDate(fmt) { /*首先将日期分隔 ，获取到日期部分 和 时间部分*/ var day = fmt.split(&apos; &apos;); /*获取日期部分的年月日*/ var days = day[0].split(&apos;-&apos;); /*获取时间部分的 时分秒*/ var mi = day[day.length - 1].split(&apos;:&apos;); /*获取当前date类型日期*/ var date = new Date(); /*给date赋值 年月日*/ date.setUTCFullYear(days[0], days[1] - 1, days[2]); /*给date赋值 时分秒 首先转换utc时区 ：+8*/ date.setUTCHours(mi[0] - 8, mi[1], mi[2]); return date; } /*为空判断*/ function isEmpty(s) { switch (typeof(s)) { case &apos;string&apos;: return !s.length; break; case &apos;array&apos;: case &apos;object&apos;: for (var i in s) return false; return true; break; case &apos;undefined&apos;: return true; break; default: return !s; break; } } /*数字判断*/ function isNumber(s) { return typeof(s) == &apos;number&apos; ? true : false; } /*整数判断*/ function isInt(s) { var re = /^-?\d*$/; return re.test(s); } /*正整数判断*/ function isUInt(s) { var re = /^\d*$/; return re.test(s) &amp;&amp; s &gt;= 0; } /*小数判断*/ function isDecimal(s, bit) { if (!arguments[1]) bit = -1; if (bit == -1) { var re = /^-?\d*.?\d*$/; return re.test(s); } else { var re = new RegExp(&apos;^-?\\d*.?\\d{0,&apos; + bit + &apos;}$&apos;); return re.test(s); } } /*正小数判断*/ function isUDecimal(s, bit) { if (!arguments[1]) bit = -1; if (bit == -1) { var re = /^\d*.?\d*$/; return re.test(s) &amp;&amp; s &gt;= 0; } else { var re = new RegExp(&apos;^\\d*.?\\d{0,&apos; + bit + &apos;}$&apos;); return re.test(s) &amp;&amp; s &gt;= 0; } } /*字符串判断*/ function isString(s) { return typeof(s) == &apos;string&apos;; } /*========================/常用函数========================*/ js onkeyup replace 自动替换 检测浮点数 只能是整数或者小数 多余的就replace 掉 的表单验证 function checkFloatNum(obj) { //先把非数字的都替换掉，除了数字和. obj.value = obj.value.replace(/[^\d.]/g,&quot;&quot;); //必须保证第一个为数字而不是. obj.value = obj.value.replace(/^\./g,&quot;&quot;); //保证只有出现一个.而没有多个. obj.value = obj.value.replace(/\.{2,}/g,&quot;.&quot;); //保证.只出现一次，而不能出现两次以上 obj.value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;); } 解决键盘弹出遮挡： // 解决键盘弹出后挡表单的问题 window.addEventListener(&apos;resize&apos;, function() { if( document.activeElement.tagName === &apos;INPUT&apos; || document.activeElement.tagName === &apos;TEXTAREA&apos; ) { window.setTimeout(function() { if(&apos;scrollIntoView&apos; in document.activeElement) { document.activeElement.scrollIntoView(); } else { document.activeElement.scrollIntoViewIfNeeded(); } }, 0); } }); 单个for循环实现排序： var a = [12, 13, 65, 54, 86, 21, 37, 1, 95, 4]; var l=a.length; for(var i = 0; i &lt; l; i++) { if(a[i] &gt; a[i + 1]) { var tem = a[i]; a[i] = a[i + 1]; a[i + 1] = tem; } if(i == l - 1) { i = -1; l--; } } console.log(a); Object.assign实现: if (!Object.assign) { // 定义assign方法 Object.defineProperty(Object, &apos;assign&apos;, { enumerable: false, configurable: true, writable: true, value: function(target) { // assign方法的第一个参数 &apos;use strict&apos;; // 第一个参数为空，则抛错 if (target === undefined || target === null) { throw new TypeError(&apos;Cannot convert first argument to object&apos;); } var to = Object(target); // 遍历剩余所有参数 for (var i = 1; i &lt; arguments.length; i++) { var nextSource = arguments[i]; // 参数为空，则跳过，继续下一个 if (nextSource === undefined || nextSource === null) { continue; } nextSource = Object(nextSource); // 获取改参数的所有key值，并遍历 var keysArray = Object.keys(nextSource); for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) { var nextKey = keysArray[nextIndex]; var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey); // 如果不为空且可枚举，则直接浅拷贝赋值 if (desc !== undefined &amp;&amp; desc.enumerable) { to[nextKey] = nextSource[nextKey]; } } } return to; } }); }]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS类型判断]]></title>
    <url>%2F2017%2F02%2F03%2FJS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[先看typeof&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; var a; console.log(&quot;1:&quot; + typeof a); var b = null; console.log(&quot;2:&quot; + typeof b); var c = undefined; console.log(&quot;3:&quot; + typeof c); var d = new Object; console.log(&quot;4:&quot; + typeof d); var e = function() {}; console.log(&quot;5:&quot; + typeof e); var f = {}; console.log(&quot;6:&quot; + typeof f); var g = &apos;&apos;; console.log(&quot;7:&quot; + typeof g); var h = []; console.log(&quot;8:&quot; + typeof h); var i = true; console.log(&quot;9:&quot; + typeof i); var j = 123; console.log(&quot;10:&quot; + typeof j); var k = NaN; console.log(&quot;11:&quot; + typeof k); var l = /^[-+]?\d+$/; console.log(&quot;12:&quot; + typeof l); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 按照上面的打印结果,总结出下面要注意的几点 typeof (引用类型) 除了函数, 都是 ‘object’,比如 typeof /123/ typeof null 为’object’ typeof undefined 为 ‘undefined’,通常, 如果使用两等号, null == undefined 为真. 转换为数字的常见用法 “10”-0或+”10”, 如果没有转换成功,返回NaN,由于NaN 的一个特性: NaN != NaN,故判断转换成功与否的常见做法: (这也是我参见 jQuery的源码发现的,jQuery源码读100遍都不为过) (“10x” - 0) == (“10x” - 0);// 结果为假! 再看看constructor 和 instanceofinstanceof 用于判断一个变量是否某个对象的实例,或用于判断一个变量是否某个对象的实例； constructor 用于判断一个变量的原型，constructor 属性返回对创建此对象的数组函数的引用。 Javascript中对象的prototype属性的解释是:返回对象类型原型的引用。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; console.log(&quot;----------------Number---------------&quot;); var A = 123; console.log(A instanceof Number); //false console.log(A.constructor == Number); //true console.log(A.constructor); console.log(&quot;----------------String---------------&quot;); var B = &quot;javascript&quot;; console.log(B instanceof String); //false console.log(B.constructor == String); //true console.log(B.constructor); console.log(&quot;----------------Boolean---------------&quot;); var C = true; console.log(C instanceof Boolean); //false console.log(C.constructor == Boolean); //true console.log(C.constructor); console.log(&quot;----------------null---------------&quot;); var D = null; console.log(D instanceof Object); //false //console.log(D.constructor == null); //报错 //console.log(D.constructor); //报错 console.log(&quot;----------------undefined---------------&quot;); var E = undefined; //console.log(E instanceof undefined); // //报错 //console.log(E.constructor == undefined); //报错 //console.log(E.constructor); //报错 console.log(&quot;----------------function---------------&quot;); var F = function() {}; console.log(F instanceof Function); console.log(F.constructor == Function); console.log(F.constructor); console.log(&quot;----------------new function---------------&quot;); function SB() {}; var G = new SB(); console.log(G instanceof SB); console.log(G.constructor == SB); console.log(G.constructor); console.log(&quot;----------------new Object---------------&quot;); var H = new Object; console.log(H instanceof Object); console.log(H.constructor == Object); console.log(H.constructor); console.log(&quot;-----------------Array--------------&quot;); var I = []; console.log(I instanceof Array); console.log(I.constructor == Array); console.log(I.constructor); console.log(&quot;-----------------JSON--------------&quot;); var J = { &quot;good&quot;: &quot;js&quot;, &quot;node&quot;: &quot;very good&quot; }; console.log(J instanceof Object); console.log(J.constructor == Object); console.log(J.constructor); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 再看看{}.toString.call(obj)&lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; console.log({}.toString.call(1)); console.log({}.toString.call(&quot;11&quot;)); console.log({}.toString.call(/123/)); console.log({}.toString.call({})); console.log({}.toString.call(function() {})); console.log({}.toString.call([])); console.log({}.toString.call(true)); console.log({}.toString.call(new Date())); console.log({}.toString.call(new Error())); console.log({}.toString.call(null)); console.log({}.toString.call(undefined)); console.log(String(null)); console.log(String(undefined)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 使用jQuery中的方法$.type()现在看看jQuery是怎么做的 // 先申明一个对象,目的是用来做映射 var class2type = {}; // 申明一个core_toString() 的方法,得到最原始的toString() 方法,因为在很多对象中,toStrintg() 已经被重写 var core_toString() = class2type.toString; // 这里为 toStrintg() 后的结果和类型名做一个映射,申明一个core_toString() 后的结果,而值就是类型名 jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) { class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase(); }); &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; console.log($.type(1)); console.log($.type(&quot;11&quot;)); console.log($.type(/123/)); console.log($.type({})); console.log($.type(function() {})); console.log($.type([])); console.log($.type(true)); console.log($.type(new Date())); console.log($.type(new Error())); console.log($.type(null)); console.log($.type(undefined)); console.log(String(null)); console.log(String(undefined)); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 上面的打印结果与 class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase(); 不谋而合! 这是jQuery.type 的核心方法 type: function( obj ) { if ( obj == null ) { return String( obj ); } // Support: Safari &lt;= 5.1 (functionish RegExp) return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ? class2type[ core_toString.call(obj) ] || &quot;object&quot; : typeof obj; }, 注意,为什么把 null 或者 undefined 单独讨论呢,因为 在一些版本浏览器中console.log(core_toString.call(null));console.log(core_toString.call(undefined)); 这是会报错的! 如果是对象类型,另:由于 在一些低版本的浏览器中,typeof /123/ 会返回的是 &quot;function&quot; 而不是 &quot;object&quot;,所以这里要判断是否是函数,要明白 这里的 typeof obj === function 不是为了函数讨论的,因为函数本身就可以通过typeof 来得到类型. typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ? class2type[ core_toString.call(obj) ] 就直接返回class2type 中键值对的结果,,如果不是,那么一定就是基本类型, 通过 typeof 就可以啦. class2type[ core_toString.call(obj) ] || &quot;object&quot; : // 这是防止一些未知情况的,如果未取到,就返回object 但是 jQuery.type 有一个很大的缺陷这是一个自定义类型 function Person() { this.name = &apos;pawn&apos;; } var p = new Person(); console.log($.type(p)); console.log({}.toString.call(p)); // 注意,这里会打印 [object Object],通过上面的方法,无法得到精确的自定义类型这也是 它的一个大缺陷了! 下面,我们通过构造函数的方式来获取精确类型 通过构造函数来获取类型在理解这个方法之前,需要理解两个点 prorotype 原型属性 我们知道,任何对象或者函数都直接或者间接的继承自Object 或者 Function， （其实最终Function 是继承自 Object 的，这属于原型链的知识了，见下图）。那么，任何一个对象都具有原型对象 __proto__ (这个对象只在chrome 和 firefox 暴露，但是在其他浏览器中也是存在的)，这个原型对象就是这个对象的构造函数的原型属性(这里可能有点绕,直接上图). 由于 任何函数都具有 原型属性prototype,并且这个原型属性具有一个默认属性 constructor,它是这个函数的引用,看下面的代码 function Person(){ this.name = &apos;pawn&apos;; } console.log(Person.prototype.constructor === Person); //true 发现,这两个东西其实一个东西 但是,在某些情况下,需要这么写 function Person(){ this.name = &apos;pawn&apos;; } Person.protype = { XX: ... , xx: ... , ... } 这么做,就会覆盖原本的 protype 方法,那么construcor 就不存在了,这是,必须要显示的申明这个对象， construction: Person, 这句话非常重要，作用是修正this指向Person.protype = { construction: Person, //这句话的作用是修正this指向 XX: ... , xx: ... , ... } 在jQuery的中,就是这么做的, jQuery.fn = jQuery.prototype = { constructor: jQuery, init: function( selector, context, rootjQuery ) { var match, elem; 关于 jQuery对象封装的方式 也是非常值得研究 注意,这里已经不是熟悉 [object Object],而是 已经重写了. 也就是,如果调用一个函数的toString() 方法.那么就会打印这个函数的函数体. 如何通过构造函数来获得变量的类型? 判断是否是基本类型 var getType = function(obj){ if(obj == null){ return String(obj); } if(typeof obj === &apos;object&apos; || typeof obj === &apos;fucntion&apos;){ ... }else{ // 如果不是引用类型,那么就是基本类型 return typeof obj } } 如果是对象或者函数类型 function Person(){ this.name = &apos;pawn&apos;; } var p = new Person(); console.log(p.constructor); //返回function Person(){...} 现在要做的事 : 如何将Person 提取出来呢?毋庸置疑,字符串切割那一套肯定可以办到,但是太 low 啦!这里,我使用正则将Person提取出来 var regex = /function\s(.+?)\(/ function Person(){ this.name = &apos;pawn&apos;; } var p = new Person(); var c = p.constructor var regex = /function\s(.+?)\(/; console.log(&apos;|&apos; + regex.exec(c)[1] + &apos;|&apos;); 其实,除了上面的正则,每个函数还有一个name属性,返回函数名,但是ie8 是不支持的. 因此上面的代码可以写为: var getType = function(obj){ if(obj == null){ return String(obj); } if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){ var constructor = obj.constructor; if(constructor &amp;&amp; constructor.name){ return constructor.name; } var regex = /function\s(.+?)\(/; return regex.exec(c)[1]; }else{ // 如果不是引用类型,那么就是基本;类型 return typeof obj; } }; 但是上面的代码太丑啦,将其简化 简化 var getType = function(obj){ if(obj == null){ return String(obj); } if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){ return obj.constructor &amp;&amp; obj.constructor.name.toLowerCase() || /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase(); }else{ // 如果不是引用类型,那么就是基本类型 return typeof obj; } }; 还是比较麻烦,继续简化 var getType = function(obj){ if(obj == null){ return String(obj); } return typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos; ? obj.constructor &amp;&amp; obj.constructor.name &amp;&amp; obj.constructor.name.toLowerCase() || /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase(): typeof obj; }; 好了,已经全部弄完了,写个代码测试一下: function Person(){ this.name = &apos;pawn&apos;; } var p = new Person(); console.log(getType(p)); console.log(getType(1)); console.log(getType(&quot;a&quot;)); console.log(getType(false)); console.log(getType(/123/)); console.log(getType({})); console.log(getType(function(){})); console.log(getType(new Date())); console.log(getType(new Error())); console.log(getType( null)); console.log(getType( undefined)); 1.有时会看到Object.prototype.toString.call() 2.toString()是一个怎样的方法,他定义在哪里？ 3.call.apply.bind可以吗？ 4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function A(){ this.say=function(){ console.log(&quot;我是1&quot;); } } function B(){ this.say=function(){ console.log(&quot;我是2&quot;); } } var a=new A(); var b=new B(); a.say.call(b); //我是1 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function A(){ this.name=&apos;SB&apos;; this.say=function(){ console.log(&quot;我是1&quot;); } } function B(){ A.call(this); //B继承A，重写say方法 this.say=function(){ console.log(&quot;我是2&quot;); } } var a=new A(); var b=new B(); console.log(b.name); //SB b.say(); //我是2 a.say.call(b); //我是1 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。5.Object.prototype.toString方法的原理是什么？参考链接：http://www.jb51.net/article/79941.htm 在JavaScript中,想要判断某个对象值属于哪种内置类型,最靠谱的做法就是通过Object.prototype.toString方法. 12var arr = [];console.log(Object.prototype.toString.call(arr)) //“[object Array]” 本文要讲的就是,toString方法是如何做到这一点的,原理是什么. ECMAScript 3 在ES3中,Object.prototype.toString方法的规范如下: 115.2.4.2 Object.prototype.toString() 在toString方法被调用时,会执行下面的操作步骤: 获取this对象的[[Class]]属性的值. 计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串. 返回第二步的操作结果Result(2). [[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的 [[Class]]一个字符串值,表明了该对象的类型. 然后给了一段解释: 所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2). 也就是说,把Object.prototype.toString方法返回的字符串,去掉前面固定的”[object “和后面固定的”]”,就是内部属性[[class]]的值,也就达到了判断对象类型的目的.jQuery中的工具方法$.type(),就是干这个的. 在ES3中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有10种.分别是:”Array”, “Boolean”, “Date”, “Error”, “Function”, “Math”, “Number”, “Object”, “RegExp”, “String”. ECMAScript 5 在ES5.1中,除了规范写的更详细一些以外,Object.prototype.toString方法和[[class]]内部属性的定义上也有一些变化,Object.prototype.toString方法的规范如下: 15.2.4.2 Object.prototype.toString ( ) 在toString方法被调用时,会执行下面的操作步骤: 如果this的值为undefined,则返回”[object Undefined]”. 如果this的值为null,则返回”[object Null]”. 让O成为调用ToObject(this)的结果. 让class成为O的内部属性[[Class]]的值. 返回三个字符串”[object “, class, 以及 “]”连接后的新字符串. 可以看出,比ES3多了1,2,3步.第1,2步属于新规则,比较特殊,因为”Undefined”和”Null”并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this的值才会保持undefined或null,非严格模式下会自动成为全局对象).第3步并不算是新规则,因为在ES3的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来.ES5中,[[Class]]属性的解释更加详细: 所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2). 和ES3对比一下,第一个差别就是[[class]]内部属性的值多了两种,成了12种,一种是arguments对象的[[class]]成了”Arguments”,而不是以前的”Object”,还有就是多个了全局对象JSON,它的[[class]]值为”JSON”.第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这12种值冲突,不过在支持ES3的浏览器中,貌似也没有发现哪些宿主对象故意使用那10个值. ECMAScript 6 ES6目前还只是工作草案,但能够肯定的是,[[class]]内部属性没有了,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的: 内部属性属性值描述[[NativeBrand]]枚举NativeBrand的一个成员.该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型. [[NativeBrand]]属性的解释: [[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的ECMAScript原生对象.只有在表10中明确指出的对象类型才有[[NativeBrand]]内部属性. 表10 — [[NativeBrand]]内部属性的值 属性值对应类型NativeFunctionFunction objectsNativeArrayArray objectsStringWrapperString objectsBooleanWrapperBoolean objectsNumberWrapperNumber objectsNativeMathThe Math objectNativeDateDate objectsNativeRegExpRegExp objectsNativeErrorError objectsNativeJSONThe JSON objectNativeArgumentsArguments objectsNativePrivateNamePrivate Name objects 可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]].同时,Object.prototype.toString方法的规范也改成了下面这样: 15.2.4.2 Object.prototype.toString ( ) 在toString方法被调用时,会执行下面的操作步骤: 如果this的值为undefined,则返回”[object Undefined]”. 如果this的值为null,则返回”[object Null]”. 让O成为调用ToObject(this)的结果. 如果O有[[NativeBrand]]内部属性,让tag成为表29中对应的值. 否则 让hasTag成为调用O的[[HasProperty]]内部方法后的结果,参数为@@toStringTag. 如果hasTag为false,则让tag为”Object”. 否则, 让tag成为调用O的[[Get]]内部方法后的结果,参数为@@toStringTag. 如果tag是一个abrupt completion,则让tag成为NormalCompletion(“???”). 让tag成为tag.[[value]]. 如果Type(tag)不是字符串,则让tag成为”???”. 如果tag的值为”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”,或 者”String”中的任一个,则让tag成为字符串”~”和tag当前的值连接后的结果. 返回三个字符串”[object “, tag, and “]”连接后的新字符串. 表29 — [[NativeBrand]] 标志值 [[NativeBrand]]值标志值NativeFunction”Function”NativeArray”Array”StringWrapper”String”BooleanWrapper”Boolean”NumberWrapper”Number”NativeMath”Math”NativeDate”Date”NativeRegExp”RegExp”NativeError”Error”NativeJSON”JSON”NativeArguments”Arguments” 可以看到,在规范上有了很大的变化,不过对于普通用户来说,貌似感觉不到. 也许你发现了,ES6里的新类型Map,Set等,都没有在表29中.它们在执行toString方法的时候返回的是什么? console.log(Object.prototype.toString.call(Map())) //“[object Map]” console.log(Object.prototype.toString.call(Set())) //“[object Set]” 其中的字符串”Map”是怎么来的呢: 15.14.5.13 Map.prototype.@@toStringTag @@toStringTag 属性的初始值为字符串”Map”. 由于ES6的规范还在制定中,各种相关规定都有可能改变,所以如果想了解更多细节.看看下面这两个链接,现在只需要知道的是:[[class]]没了,使用了更复杂的机制. 以上所述是小编给大家分享的JavaScript中Object.prototype.toString方法的原理，希望对大家有所帮助！]]></content>
      <tags>
        <tag>js</tag>
        <tag>类型判断</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript进阶提高必读]]></title>
    <url>%2F2016%2F12%2F31%2FJavaScript%E8%BF%9B%E9%98%B6%E6%8F%90%E9%AB%98%E5%BF%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[冴羽写博客的地方vue源码-内部运行机制剖析进度JavaScript深入系列 15 篇已完结。 JavaScript专题系列 20 篇已完结。 underscore 系列 8 篇已完结。 深入系列目录 JavaScirpt深入之从原型到原型链 JavaScript深入之词法作用域和动态作用域 JavaScript深入之执行上下文栈 JavaScript深入之变量对象 JavaScript深入之作用域链 JavaScript深入之从ECMAScript规范解读this JavaScript深入之执行上下文 JavaScript深入之闭包 JavaScript深入之参数按值传递 JavaScript深入之call和apply的模拟实现 JavaScript深入之bind的模拟实现 JavaScript深入之new的模拟实现 JavaScript深入之类数组对象与arguments JavaScript深入之创建对象的多种方式以及优缺点 JavaScript深入之继承的多种方式以及优缺点 JavaScript深入系列15篇正式完结！ 专题系列目录 JavaScript专题之跟着underscore学防抖 JavaScript专题之跟着underscore学节流 JavaScript专题之数组去重 JavaScript专题之类型判断(上) JavaScript专题之类型判断(下) JavaScript专题之深浅拷贝 JavaScript专题之从零实现jQuery的extend JavaScript专题之如何求数组的最大值和最小值 JavaScript专题之数组扁平化 JavaScript专题之学underscore在数组中查找指定元素 JavaScript专题之jQuery通用遍历方法each的实现 JavaScript专题之如何判断两个对象相等 JavaScript专题之函数柯里化 JavaScript专题之偏函数 JavaScript专题之惰性函数 JavaScript专题之函数组合 JavaScript专题之函数记忆 JavaScript专题之递归 JavaScript专题之乱序 JavaScript专题之解读 v8 排序源码 JavaScript专题系列20篇正式完结！ underscore 系列目录 underscore 系列之如何写自己的 underscore underscore 系列之链式调用 underscore 系列之内部函数 cb 和 optimizeCb underscore 系列之内部函数 restArgs underscore 系列之防冲突与 Utility Functions underscore 系列之实现一个模板引擎(上) underscore 系列之实现一个模板引擎(下) underscore 系列之字符实体与 _.escape underscore 的源码该如何阅读？ ES6 系列目录 ES6 系列之 let 和 const ES6 系列之模板字符串 ES6 系列之箭头函数 ES6 系列之模拟实现 Symbol 类型 ES6 系列之迭代器与 for of ES6 系列之模拟实现一个 Set 数据结构 ES6 系列之 WeakMap ES6 系列之我们来聊聊 Promise ES6 系列之 Generator 的自动执行]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 模块化解析]]></title>
    <url>%2F2016%2F12%2F22%2FJavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[随着 JavasScript 语言逐渐发展，JavaScript 应用从简单的表单验证，到复杂的网站交互，再到服务端，移动端，PC 客户端的语言支持。JavaScript 应用领域变的越来越广泛，工程代码变得越来越庞大，代码的管理变得越来越困难，于是乎 JavaScript 模块化方案在社区中应声而起，其中一些优秀的模块化方案，逐渐成为 JavaScript 的语言规范，下面我们就 JavaScript 模块化这个话题展开讨论，本文的主要包含以几部分内容。 什么是模块 为什么需要模块化 JavaScript 模块化之 CommonJS JavaScript 模块化之 AMD JavaScript 模块化之 CMD JavaScript 模块化之 ES Module 总结 什么是模块模块，又称构件，是能够单独命名并独立地完成一定功能的程序语句的集合 (即程序代码和数据结构的集合体)。它具有两个基本的特征：外部特征和内部特征。外部特征是指模块跟外部环境联系的接口 (即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量) 和模块的功能，内部特征是指模块的内部环境具有的特点 (即该模块的局部数据和程序代码)。简而言之，模块就是一个具有独立作用域，对外暴露特定功能接口的代码集合。 为什么需要模块化首先让我们回到过去，看看原始 JavaScript 模块文件的写法。 // add.jsfunctionadd(a, b) { return a + b; } // decrease.jsfunctiondecrease(a, b) { return a - b; } // formula.jsfunctionsquare_difference(a, b) { return add(a, b) * decrease(a, b); } 上面我们在三个 JavaScript 文件里面，实现了几个功能函数。其中，第三个功能函数需要依赖第一个和第二个 JavaScript 文件的功能函数，所以我们在使用的时候，一般会这样写：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155 &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;add.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;decrease.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;formula.js&quot;&gt;&lt;/script&gt; &lt;!--使用--&gt; &lt;script&gt; var result = square_difference(3, 4); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;``` 这样的管理方式会造成以下几个问题：- 模块的引入顺序可能会出错- 会污染全局变量- 模块之间的依赖关系不明显基于上述的原因，就有了对上述问题的解决方案，即是 JavaScript 模块化规范，目前主流的有 CommonJS，AMD，CMD，ES6 Module 这四种规范。## Javascript 模块化之 CommonJSCommonJS 规范的主要内容有，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中，下面讲述一下 NodeJs 中 CommonJS 的模块化机制。### 使用方式 // 模块定义 add.jsmodule.eports.add = function(a, b) &#123; return a + b; &#125;; // 模块定义 decrease.jsmodule.exports.decrease = function(a, b) &#123; return a - b; &#125;; // formula.js,模块使用，利用 require() 方法加载模块,require 导出的即是 module.exports 的内容const add = require(&quot;./add.js&quot;).add; const decrease = require(&quot;./decrease.js&quot;).decrease; module.exports.square_difference = function(a, b) &#123; return add(a, b) * decrease(a, b); &#125;; ### exports 和 module.exportsexports 和 module.exports 是指向同一个东西的变量，即是 module.exports = exports = &#123;&#125;，所以你也可以这样导出模块 //add.js exports.add = function(a, b) &#123; return a + b; &#125;; 但是如果直接修改 exports 的指向是无效的，例如: // add.js exports = function(a, b) &#123; return a + b; &#125;; // main.jsvar add = require(&quot;./add.js&quot;); 此时得到的 add 是一个空对象，因为 require 导入的是，对应模块的 module.exports 的内容，在上面的代码中，虽然一开始 exports = module.exports，但是当执行如下代码的时候，其实就将 exports 指向了 function,而 module.exports 的内容并没有改变，所以这个模块的导出为空对象。 exports = function(a, b) &#123; return a + b; &#125;; ### CommonJS 在 NodeJs 中的模块加载机制以下根据 [NodeJs 中 CommonJS 模块加载源码](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnodejs%2Fnode%2Fblob%2Fmaster%2Flib%2Finternal%2Fmodules%2Fcjs%2Floader.js) 来分析 NodeJS 中模块的加载机制。在 NodeJs 中引入模块 (require)，需要经历如下 3 个步骤：1. 路径分析2. 文件定位3. 编译执行与前端浏览器会缓存静态脚本文件以提高性能一样，NodeJs 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的是，浏览器仅缓存文件，而在 NodeJs 中缓存的是编译和执行后的对象。#### 路径分析 + 文件定位其流程如下图所示：#### 模块编译在定位到文件后，首先会检查该文件是否有缓存，有的话直接读取缓存，否则，会新创建一个 Module 对象，其定义如下： functionModule(id, parent) &#123; this.id = id; // 模块的识别符，通常是带有绝对路径的模块文件名。this.exports = &#123;&#125;; // 表示模块对外输出的值this.parent = parent; // 返回一个对象，表示调用该模块的模块。if (parent &amp;&amp; parent.children) &#123; this.parent.children.push(this); &#125; this.filename = null; this.loaded = false; // 返回一个布尔值，表示模块是否已经完成加载。this.childrent = []; // 返回一个数组，表示该模块要用到的其他模块。 &#125; require 操作代码如下所示： Module.prototype.require = function(id) &#123; // 检查模块标识符if (typeof id !== &quot;string&quot;) &#123; thrownew ERR_INVALID_ARG_TYPE(&quot;id&quot;, &quot;string&quot;, id); &#125; if (id === &quot;&quot;) &#123; thrownew ERR_INVALID_ARG_VALUE(&quot;id&quot;, id, &quot;must be a non-empty string&quot;); &#125; // 调用模块加载方法return Module._load(id, this, /* isMain */false); &#125;; 接下来是解析模块路径，判断是否有缓存，然后生成 Module 对象： Module._load = function(request, parent, isMain) &#123; if (parent) &#123; debug(&quot;Module._load REQUEST %s parent: %s&quot;, request, parent.id); &#125; // 解析文件名var filename = Module._resolveFilename(request, parent, isMain); var cachedModule = Module._cache[filename]; // 判断是否有缓存，有的话返回缓存对象的 exportsif (cachedModule) &#123; updateChildren(parent, cachedModule, true); return cachedModule.exports; &#125; // 判断是否为原生核心模块，是的话从内存加载if (NativeModule.nonInternalExists(filename)) &#123; debug(&quot;load native module %s&quot;, request); return NativeModule.require(filename); &#125; // 生成模块对象varmodule = new Module(filename, parent); if (isMain) &#123; process.mainModule = module; module.id = &quot;.&quot;; &#125; // 缓存模块对象 Module._cache[filename] = module; // 加载模块 tryModuleLoad(module, filename); returnmodule.exports; &#125;; tryModuleLoad 的代码如下所示： functiontryModuleLoad(module, filename) { var threw = true; try { // 调用模块实例load方法module.load(filename); threw = false; } finally { if (threw) { // 如果加载出错，则删除缓存delete Module._cache[filename]; } } } 1模块对象执行载入操作 module.load 代码如下所示： Module.prototype.load = function(filename) { debug(&quot;load %j for module %j&quot;, filename, this.id); assert(!this.loaded); this.filename = filename; // 解析路径this.paths = Module._nodeModulePaths(path.dirname(filename)); // 判断扩展名，并且默认为 .js 扩展var extension = path.extname(filename) || &quot;.js&quot;; // 判断是否有对应格式文件的处理函数， 没有的话，扩展名改为 .jsif (!Module._extensions[extension]) extension = &quot;.js&quot;; // 调用相应的文件处理方法，并传入模块对象 Module._extensions[extension](this, filename); this.loaded = true; // 处理 ES Moduleif (experimentalModules) { if (asyncESM === undefined) lazyLoadESM(); const ESMLoader = asyncESM.ESMLoader; const url = pathToFileURL(filename); const urlString = `${url}`; const exports = this.exports; if (ESMLoader.moduleMap.has(urlString) !== true) { ESMLoader.moduleMap.set( urlString, new ModuleJob(ESMLoader, url, async () =&gt; { const ctx = createDynamicModule([&quot;default&quot;], url); ctx.reflect.exports.default.set(exports); return ctx; }) ); } else { const job = ESMLoader.moduleMap.get(urlString); if (job.reflect) job.reflect.exports.default.set(exports); } } }; 12在这里同步读取模块，再执行编译操作： Module._extensions[&quot;.js&quot;] = function(module, filename) { // 同步读取文件var content = fs.readFileSync(filename, &quot;utf8&quot;); // 编译代码module._compile(stripBOM(content), filename); }; 1234编译过程主要做了以下的操作：1. 将 JavaScript 代码用函数体包装，隔离作用域，例如： exports.add = (function(a, b) { return a + b; } `会被转换为 ( function(exports, require, modules, __filename, __dirname) { exports.add = function(a, b) { return a + b; }; } ); 执行函数，注入模块对象的 exports 属性，require 全局方法，以及对象实例，filename, dirname，然后执行模块的源码。 返回模块对象 exports 属性。 JavaScript 模块化之 AMDAMD, Asynchronous Module Definition，即异步模块加载机制，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句都定义在一个回调函数中，等到依赖加载完成之后，这个回调函数才会运行。 AMD 的诞生，就是为了解决这两个问题： 实现 JavaScript 文件的异步加载，避免网页失去响应 管理模块之间的依赖性，便于代码的编写和维护 // 模块定义 define(id?: String, dependencies?: String[], factory: Function|Object); id 是模块的名字，它是可选的参数。 dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数。每个依赖的模块的输出都将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。 factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值，如果是对象，此对象应该为模块的输出值。 举个例子： // 模块定义，add.js define(function() { let add = function(a, b) { return a + b; }; return add; }); // 模块定义，decrease.js define(function() { let decrease = function(a, b) { return a - b; }; return decrease; }); // 模块定义，square.js define([&quot;./add&quot;, &quot;./decrease&quot;], function(add, decrease) { let square = function(a, b) { return add(a, b) * decrease(a, b); }; return square; }); // 模块使用，主入口文件 main.jsrequire([&quot;square&quot;], function(math) { console.log(square(6, 3)); }); 这里用实现了 AMD 规范的 RequireJS 来分析，RequireJS 源码较为复杂，这里只对异步模块加载原理做一个分析。在加载模块的过程中， RequireJS 会调用如下函数： /** * * @param {Object} context the require context to find state. * @param {String} moduleName the name of the module. * @param {Object} url the URL to the module. */ req.load = function(context, moduleName, url) { var config = (context &amp;&amp; context.config) || {}, node; // 判断是否为浏览器if (isBrowser) { // 根据模块名称和 url 创建一个 Script 标签 node = req.createNode(config, moduleName, url); node.setAttribute(&quot;data-requirecontext&quot;, context.contextName); node.setAttribute(&quot;data-requiremodule&quot;, moduleName); // 对不同的浏览器 Script 标签事件监听做兼容处理if ( node.attachEvent &amp;&amp; !( node.attachEvent.toString &amp;&amp; node.attachEvent.toString().indexOf(&quot;[native code&quot;) &lt; 0 ) &amp;&amp; !isOpera ) { useInteractive = true; node.attachEvent(&quot;onreadystatechange&quot;, context.onScriptLoad); } else { node.addEventListener(&quot;load&quot;, context.onScriptLoad, false); node.addEventListener(&quot;error&quot;, context.onScriptError, false); } // 设置 Script 标签的 src 属性为模块路径 node.src = url; if (config.onNodeCreated) { config.onNodeCreated(node, config, moduleName, url); } currentlyAddingScript = node; // 将 Script 标签插入到页面中if (baseElement) { head.insertBefore(node, baseElement); } else { head.appendChild(node); } currentlyAddingScript = null; return node; } elseif (isWebWorker) { try { //In a web worker, use importScripts. This is not a very//efficient use of importScripts, importScripts will block until//its script is downloaded and evaluated. However, if web workers//are in play, the expectation is that a build has been done so//that only one script needs to be loaded anyway. This may need//to be reevaluated if other use cases become common.// Post a task to the event loop to work around a bug in WebKit// where the worker gets garbage-collected after calling// importScripts(): https://webkit.org/b/153317 setTimeout(function() {}, 0); importScripts(url); //Account for anonymous modules context.completeLoad(moduleName); } catch (e) { context.onError( makeError( &quot;importscripts&quot;, &quot;importScripts failed for &quot; + moduleName + &quot; at &quot; + url, e, [moduleName] ) ); } } }; // 创建异步 Script 标签 req.createNode = function(config, moduleName, url) { var node = config.xhtml ? document.createElementNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;html:script&quot;) : document.createElement(&quot;script&quot;); node.type = config.scriptType || &quot;text/javascript&quot;; node.charset = &quot;utf-8&quot;; node.async = true; return node; }; 可以看出，这里主要是根据模块的 Url，创建了一个异步的 Script 标签，并将模块 id 名称添加到的标签的 data-requiremodule 上，再将这个 Script 标签添加到了 html 页面中。同时为 Script 标签的 load 事件添加了处理函数，当该模块文件被加载完毕的时候，就会触发 context.onScriptLoad。我们在 onScriptLoad 添加断点，可以看到页面结构如下图所示: 由图可以看到，Html 中添加了一个 Script 标签，这也就是异步加载模块的原理。 JavaScript 模块化之 CMDCMD (Common Module Definition) 通用模块定义，CMD 在浏览器端的实现有 SeaJS， 和 RequireJS 一样，SeaJS 加载原理也是动态创建异步 Script 标签。二者的区别主要是依赖写法上不同，AMD 推崇一开始就加载所有的依赖，而 CMD 则推崇在需要用的地方才进行依赖加载。 // ADM 在执行以下代码的时候，RequireJS 会首先分析依赖数组，然后依次加载，直到所有加载完毕再执行回到函数 define([&quot;add&quot;, &quot;decrease&quot;], function(add, decrease) { let result1 = add(9, 7); let result2 = decrease(9, 7); console.log(result1 * result2); }); // CMD 在执行以下代码的时候， SeaJS 会首先用正则匹配出代码里面所有的 require 语句，拿到依赖，然后依次加载，加载完成再执行回调函数 define(function(require) { let add = require(&quot;add&quot;); let result1 = add(9, 7); let add = require(&quot;decrease&quot;); let result2 = decrease(9, 7); console.log(result1 * result2); }); JavaScript 模块化之 ES ModuleES Module 是在 ECMAScript 6 中引入的模块化功能。模块功能主要由两个命令构成，分别是 export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。 其使用方式如下: // 模块定义 add.jsexportfunctionadd(a, b) { return a + b; } // 模块使用 main.jsimport { add } from&quot;./add.js&quot;; console.log(add(1, 2)); // 3 下面讲述几个较为重要的点。 export 和 export default在一个文件或模块中，export 可以有多个，export default 仅有一个, export 类似于具名导出，而 default 类似于导出一个变量名为 default 的变量。同时在 import 的时候，对于 export 的变量，必须要用具名的对象去承接，而对于 default，则可以任意指定变量名，例如： // a.jsexportvar a = 2; exportvar b = 3 ; // main.js 在导出的时候必须要用具名变量 a, b 且以解构的方式得到导出变量import {a, b} from&apos;a.js&apos;// √ a= 2, b = 3import a from&apos;a.js&apos;// x// b.js export default 方式const a = 3exportdefault a // 注意不能 export default const a = 3 ,因为这里 default 就相当于一个变量名// 导出import b form &apos;b.js&apos;// √import c form &apos;b.js&apos;// √ 因为 b 模块导出的是 default，对于导出的default，可以用任意变量去承接 ES Module 模块加载和导出过程以如下代码为例子： // counter.jsexportlet count = 5// display.jsexportfunctionrender() { console.log(&apos;render&apos;) } // main.jsimport { counter } from&apos;./counter.js&apos;; import { render } from&apos;./display.js&apos; ......// more code 在模块加载模块的过程中，主要经历以下几个步骤： 构建 (Construction)这个过程执行查找，下载，并将文件转化为模块记录 (Module record)。所谓的模块记录是指一个记录了对应模块的语法树，依赖信息，以及各种属性和方法 (这里不是很明白)。同样也是在这个过程对模块记录进行了缓存的操作，下图是一个模块记录表： 下图是缓存记录表： 实例化 (Instantiation)这个过程会在内存中开辟一个存储空间 (此时还没有填充值)，然后将该模块所有的 export 和 import 了该模块的变量指向这个内存，这个过程叫做链接。其写入 export 示意图如下所示： 然后是链接 import，其示意图如下所示： 赋值(Evaluation)这个过程会执行模块代码，并用真实的值填充上一阶段开辟的内存空间，此过程后 import 链接到的值就是 export 导出的真实值。 根据上面的过程我们可以知道。ES Module 模块 export 和 import 其实指向的是同一块内存，但有一个点需要注意的是，import 处不能对这块内存的值进行修改，而 export 可以，其示意图如下： 总结本文主要对目前主流的 JavaScript 模块化方案 CommonJs，AMD，CMD, ES Module 进行了学习和了解，并对其中最有代表性的模块化实现 (NodeJs，RequireJS，SeaJS，ES6) 做了一个简单的分析。对于服务端的模块而言，由于其模块都是存储在本地的，模块加载方便，所以通常是采用同步读取文件的方式进行模块加载。而对于浏览器而言，其模块一般是存储在远程网络上的，模块的下载是一个十分耗时的过程，所以通常是采用动态异步脚本加载的方式加载模块文件。另外，无论是客户端还是服务端的 JavaScript 模块化实现，都会对模块进行缓存，以此减少二次加载的开销。]]></content>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26个精选的JavaScript面试问题]]></title>
    <url>%2F2016%2F10%2F31%2F26%E4%B8%AA%E7%B2%BE%E9%80%89%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在JavaScript中，在两个不同类型之间的转换叫做coercion。在JavaScript中有两种形式：显示转换和隐式转换。 下面是一个显示转换的例子： var a = &quot;42&quot;; var b = Number( a ); a; // &quot;42&quot; b; // 42 -- the number! 下面是一个隐式转换的例子： var a = &quot;42&quot;; var b = a * 1; // &quot;42&quot; implicitly coerced to 42 here a; // &quot;42&quot; b; // 42 -- the number! 来源: FullStack.Cafe Q2: JavaScript中的作用域是怎样的？ 话题: JavaScript难度: ⭐ 在JavaScript中，每一个函数都有各自的作用域(scope)。作用域可以理解为是一个变量的集合以及相应的如何访问它的规则。只有在函数内部的变量才可以访问到该函数域的变量。 在同一个作用域内部，变量名必须要唯一。作用域可以嵌套。在最内部的作用域中，可以访问任何外部的作用域中的变量。 Q3: 请解释JavaScript中的相等判断 话题: JavaScript难度: ⭐ JavaScript中的相等判断有严格判断和带隐式转换的判断两种： 严格判断(strict comparision): 比如===，比较的时候不会隐式转换类型； 抽象判断(abstract comparasion)：比如==，比较的时候会隐式转换类型。 var a = “42”; var b = 42; a == b; // true a === b; // false 一些简单的规则： 如果两边都是布尔类型的值，使用===; 如果两边是0,&quot;&quot;,[]，使用===; 所有其它类型，使用==是安全的。而且在很多情况下会简化代码、增加可读性。 Q4: 请解释什么叫做回调函数并提供一个简单的例子 话题: JavaScript难度: ⭐⭐ 回调函数是一个函数，它被作为参数传入另一个函数，当某些操作结束后，该函数被调用。下面是一个简单的例子，当数组被修改后，调用回调函数打印一行日志。 functionmodifyArray(arr, callback) { // do something to arr here arr.push(100); // then execute the callback function that was passed callback(); } var arr = [1, 2, 3, 4, 5]; modifyArray(arr, function() { console.log(&quot;array has been modified&quot;, arr); }); Q5: “use strict”到底有何用处？ 话题: JavaScript难度: ⭐⭐ use strict放在文件的顶部或则函数的第一行来启动更加严格的检查来避免失误引起的错误。比如，下面的代码会抛出错误： functiondoSomething(val) { &quot;use strict&quot;; x = val + 10; } 因为x没有定义，如果使用了use strict，x是不会被当做全局的变量来看待。下面的代码修复了这个BUG： functiondoSomething(val) { &quot;use strict&quot;; var x = val + 10; } Q6: 请解释Null和Undefined 话题: JavaScript难度: ⭐⭐ JavaScript和TypeScript有两个最基本的类型null和undefined。它们的含义是不同的： 如果还没有被初始化，则是undefined; 如果不可用，则可以用null来表示； Q7: 请实现如下函数 话题: JavaScript难度: ⭐⭐ var addSix = createBase(6); addSix(10); // returns 16 addSix(21); // returns 27 addSix是一个函数，也就是说createBase函数的返回是一个函数。 functioncreateBase(baseNumber) { returnfunction(N) { // we are referencing baseNumber here even though it was declared// outside of this function. Closures allow us to do this in JavaScriptreturn baseNumber + N; } } var addSix = createBase(6); addSix(10); addSix(21); Q8: 请解释JavaScript中的值和类型 话题: JavaScript难度: ⭐⭐ 下面是JavaScript内置的可用类型： string number boolean null和undefined object symbol (ES6的新语法) Q9: 请解释事件冒泡以及如何阻止它？ 话题: JavaScript难度: ⭐⭐ 事件冒泡的概念是指：在最内层的元素上绑定的事件被触发后，会按照嵌套的层次由内向外逐步触发。因此，点击某个孩子节点可能会触发父节点的事件。 一个阻止事件冒泡的办法就是使用event.stopPropagation()，在IE&lt;9的浏览器上使用event.cancelBubble()。 来源：github.com/kennymkchan Q10. 请解释JavaScript中的let关键字 话题: JavaScript难度: ⭐⭐ ES6允许你使用let关键字来申明块作用域({...})的变量。 来源: github.com/getify Q11: 如何检查一个数字是否是整数？ 话题: JavaScript难度: ⭐⭐ 一个最简单的方法是判断除以1的余数是否为0. functionisInt(num) { return num % 1 === 0; } console.log(isInt(4)); // trueconsole.log(isInt(12.2)); // falseconsole.log(isInt(0.3)); // false 来源: coderbyte.com Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)? 话题: JavaScript难度: ⭐⭐ IIFE叫做立即执行表达式，顾名思义，该表达式一被创建就立即执行。 (functionIIFE(){ console.log( &quot;Hello!&quot; ); })(); // &quot;Hello!&quot; 该方法常用语避免污染全局的命名空间，因为所以在IIFE中使用的变量外部都无法访问。 来源: stackoverflow.com Q13: 如果比较JavaScript中的两个对象？ 话题: JavaScript难度: ⭐⭐ 两个非基本类型的值，比如对象(包括函数和数组)都是通过引用的形式来访问。如果直接通过==和===来判断，那么只会简单的判断其引用地址是否相同，而不是它们实际对应的值。 如果数组和字符串做比较，那么数组会通过逗号拼接转换为字符串。通过等号判断的时候，两个相同的数组不会相等，但是和相同数据的字符串比较反而相等。 var a = [1,2,3]; var b = [1,2,3]; var c = &quot;1,2,3&quot;; a == c; // true b == c; // true a == b; // false 如果要深度比较，可以使用第三方库，比如deep-equal或则你自己实现一个比较算法。 Q14: 请解释ES5和ES6的不同点 话题: JavaScript难度: ⭐⭐⭐ ECMAScript 5 (ES5): 第5个ECMAScript版本，于2009年标准化。该标准几乎所有的浏览器都完全支持。 ECMAScript 6 (ES6)/ECMAScript 2015 (ES2015): 第6个ECMAScript版本，于2015年标准化。目前各大浏览器还只是部分支持。 接下来介绍它们主要的区别： 箭头函数和字符串嵌入： const greetings = (name) =&gt; { return`hello ${name}`; } 甚至： const greetings = name =&gt;`hello ${name}`; 常量声明(Const): 如同其它编程语言中的常量一样，但又有不同。这里的const代表了constant reference。也就是说，你可以修改其指向的对象的值。但是你不能修改其reference的值。 const NAMES = []; NAMES.push(“Jim”); console.log(NAMES.length === 1); // true NAMES = [“Steve”, “John”]; // error 块作用域变量：ES6中的新关键字let允许允许开发者将变量的作用域限定在块级别。不会像var一样变量提升。 参数默认值：允许在函数定义的时候指定默认的值。 // Basic syntaxfunctionmultiply (a, b = 2) { return a * b; } multiply(5); // 10 类定义和继承 ES6开始支持定义类(使用class关键字)，构造函数(使用constructor关键字)，和extend关键字来实现继承。 for-of操作 for...of语句用来迭代访问一个对象的所有属性。 Spread操作符：用于对象合并 const obj1 = { a: 1, b: 2 } const obj2 = { a: 2, c: 3, d: 4} const obj3 = {…obj1, …obj2} Promise: Promises提供了一个处理异步操作的方法。你可以用回调函数来实现，但是Promise更加简洁和可读。 const isGreater = (a, b) =&gt; { returnnewPromise ((resolve, reject) =&gt; { if(a &gt; b) { resolve(true) } else { reject(false) } }) } isGreater(1, 2) .then(result =&gt; { console.log(&apos;greater&apos;) }) .catch(result =&gt; { console.log(&apos;smaller&apos;) }) 模块的export和import。 const myModule = { x: 1, y: () =&gt; { console.log(‘This is ES5’) }} exportdefault myModule; import myModule from&apos;./myModule&apos;; 来源: Bulby.io Q15: 请解释undefined和not defined的区别 话题: JavaScript难度: ⭐⭐⭐ 在JavaScript中，如果你尝试使用不存在的还未申明的变量，JavaScript会抛出错误var name is not defined。但是如果你用typeof来查看其类型，会返回undefined。 我们先来澄清一下声明和定义的区别：var x是一个声明，因为你并没有定义其具体的值，你只是声明其存在性。 var x; // declaring xconsole.log(x); //output: undefined var x = 1同时兼具声明和定义，我们也可以叫它初始化。在JavaScript中，每一个变量和函数声明都会被提升到顶部。 如果我们访问一个声明了但是未定义的变量，会返回undefined。 var x; // Declarationif(typeof x === &apos;undefined&apos;) // Will return true 访问一个未声明未定义的变量，会返回not defined错误。 console.log(y); // Output: ReferenceError: y is not defined 来源: stackoverflow.com Q16: 匿名函数和命名函数的区别？ 话题: JavaScript难度: ⭐⭐⭐ var foo = function() { // anonymous function assigned to variable foo// .. }; var x = functionbar(){ // named function (bar) assigned to variable x // .. }; foo(); // actual function execution x(); 译者补充：匿名函数如果不赋值给某个变量，则无法被调用了；命名函数再次被赋值不是多此一举么。 Q17: JavaScript中闭包是什么？请提供一个例子 话题: JavaScript难度: ⭐⭐⭐⭐ 闭包是一个定义在其它函数(父函数)里面的函数，它拥有对父函数里面变量的访问权。闭包拥有如下三个作用域的访问权： 自身的作用域 父作用域 全局作用域 var globalVar = “abc”; // Parent self invoking function (functionouterFunction (outerArg) { // begin of scope outerFunction// Variable declared in outerFunction function scopevar outerFuncVar = ‘x’; // Closure self-invoking function (functioninnerFunction (innerArg) { // begin of scope innerFunction// variable declared in innerFunction function scopevar innerFuncVar = &quot;y&quot;; console.log( &quot;outerArg = &quot; + outerArg + &quot;\n&quot; + &quot;outerFuncVar = &quot; + outerFuncVar + &quot;\n&quot; + &quot;innerArg = &quot; + innerArg + &quot;\n&quot; + &quot;innerFuncVar = &quot; + innerFuncVar + &quot;\n&quot; + &quot;globalVar = &quot; + globalVar); // end of scope innerFunction })(5); // Pass 5 as parameter// end of scope outerFunction })(7); // Pass 7 as parameter innerFunction是一个闭包，定义在outerFunction中，它可以访问outerFunction作用域的所有变量。当然，它还可以访问全局变量。 输出结果如下： outerArg = 7 outerFuncVar = x innerArg = 5 innerFuncVar = y globalVar = abc 来源: github.com/ganqqwerty Q18: 在JavaScript中如何创建私有变量？ 话题: JavaScript难度: ⭐⭐⭐⭐ 你可以通过在函数中声明变量来创建私有变量。因为在函数中，外部无法直接访问。 functionfunc() { var priv = &quot;secret code&quot;; } console.log(priv); // throws error 为了访问该变量，可以构造一个帮助函数来返回该值。 functionfunc() { var priv = &quot;secret code&quot;; returnfunction() { return priv; } } var getPriv = func(); console.log(getPriv()); // =&gt; secret code 来源:coderbyte.com Q19: 请解释原型模式(Prototype Design Pattern) 话题: JavaScript难度: ⭐⭐⭐⭐ 原型模式会创建一个新的对象，但不是创建一个未初始化的对象，而是通过拷贝原型链上的值或则被拷贝对象的值来完成初始化。传统的语言很少使用原型模式，但是JavaScript作为一个基于原型的语言，使用原型模式来创建新的对象。 来源: dofactory.com Q20: 判断给定的字符串是否同态(isomorphic) 话题: JavaScript难度: ⭐⭐⭐⭐ 首先介绍什么叫做同态：两个字符串，如果A字符串中的每一个字符都可以在B字符串中找到唯一对应，并且顺序一一对应；如果存在这样的函数，那么A和B同态。 paper和title同态 egg和sad不同态 dgg和add同态 isIsomorphic(“egg”, ‘add’); // true isIsomorphic(“paper”, ‘title’); // true isIsomorphic(“kick”, ‘side’); // falsefunctionisIsomorphic(firstString, secondString) { // Check if the same length. If not, they cannot be isomorphicif (firstString.length !== secondString.length) returnfalsevar letterMap = {}; for (var i = 0; i &lt; firstString.length; i++) { var letterA = firstString[i], letterB = secondString[i]; // If the letter does not exist, create a map and map it to the value// of the second letterif (letterMap[letterA] === undefined) { letterMap[letterA] = letterB; } elseif (letterMap[letterA] !== letterB) { // Eles if letterA already exists in the map, but it does not map to// letterB, that means that A is mapping to more than one letter.returnfalse; } } // If after iterating through and conditions are satisfied, return true.// They are isomorphicreturntrue; } 来源: github.com/kennymkchan Q21: Transpiling代表了什么意思？ 话题: JavaScript难度: ⭐⭐⭐⭐ Transpiling是transforming + compiling的合成词。对于一些新的语法，浏览器还不支持。最好的办法就是将其变换到旧的等价的代码，这个过程通常叫做transpiling。 典型的，你可以在build的过程中加入transpiler，就如同code linter和minifier一样。 已经有很多知名的transpilers可供使用： Babel: 将ES6编译到ES5 Traceur：将ES6,ES7等编译到ES5 来源: You Don’t Know JS, Up &amp;going Q22: this关键字如何工作？请提供一些例子 话题: JavaScript难度: ⭐⭐⭐⭐ 在JavaScript中，this总是指向函数的“拥有者”(也就是指向该函数的对象)，或则拥有该函数的对象。 functionfoo() { console.log( this.bar ); } var bar = &quot;global&quot;; var obj1 = { bar: &quot;obj1&quot;, foo: foo }; var obj2 = { bar: &quot;obj2&quot; }; foo(); // &quot;global&quot; obj1.foo(); // &quot;obj1&quot; foo.call( obj2 ); // &quot;obj2&quot;new foo(); // undefined 来源: quirksmode.org Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。 话题: JavaScript难度: ⭐⭐⭐⭐ var arr = [1, 2, 3, 4, 5]; var avg = arr.average(); console.log(avg); JavaScript是一个基于原型的语言。也就是说对象之间通过原型链接，并继承其函数。为了给Array对象添加函数，我们可以修改其原型定义Array prorotype。 Array.prototype.average = function() { // calculate sumvar sum = this.reduce(function(prev, cur) { return prev + cur; }); // return sum divided by number of elementsreturn sum / this.length; } var arr = [1, 2, 3, 4, 5]; var avg = arr.average(); console.log(avg); // =&gt; 3 来源: coderbyte.com Q24: JavaScript中提升(hoisting)是什么意思？ 话题: JavaScript难度: ⭐⭐⭐⭐ 提升(hoisting)是指JavaScript的解释器将所有的变量和函数声明都提升到该作用域的顶部，有两种提升类型： 变量提升 函数提升 在一个作用域中通过声明的变量和函数在整个作用域中都可以使用。 var a = 2; foo(); // works because `foo()`// declaration is &quot;hoisted&quot;functionfoo() { a = 3; console.log( a ); // 3var a; // declaration is &quot;hoisted&quot;// to the top of `foo()` } console.log( a ); // 2 虽然foo()函数在后面定义，但是在前面也可以调用。 Q25: 如下代码会返回什么结果？ 话题: JavaScript难度: ⭐⭐⭐⭐ 0.1 + 0.2 === 0.3 不要惊讶，其结果是false。因为浮点数在系统内的精确度问题，0.1+0.2的结果并不是0.3，而是0.30000000000000004。要避免这个问题的方法是指定返回结果的小数位数。 来源: coderbyte.com Q26: 请描述一下揭示模式(Revealing Module Pattern) 话题: JavaScript难度: ⭐⭐⭐⭐⭐ Module pattern的一个变种是Revealing Module Pattern。该设计模式的目的是做到很好的代码隔离，只是将需要对外公开的变量和函数暴露出来。一个直接的实现如下所示： var Exposer = (function() { var privateVariable = 10; var privateMethod = function() { console.log(&apos;Inside a private method!&apos;); privateVariable++; } var methodToExpose = function() { console.log(&apos;This is a method I want to expose!&apos;); } var otherMethodIWantToExpose = function() { privateMethod(); } return { first: methodToExpose, second: otherMethodIWantToExpose }; })(); Exposer.first(); // Output: This is a method I want to expose! Exposer.second(); // Output: Inside a private method! Exposer.methodToExpose; // undefined]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSBridge的原理]]></title>
    <url>%2F2016%2F10%2F28%2FJSBridge%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。 当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。 1 前言有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。 2 JSBridge 的起源为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？ 当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的 最易编写 、 最易维护 、最易部署 的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。 因此，开发维护成本 和 更新成本 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。 PhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。 移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上： 基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案 非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native 【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。 3 JSBridge 的用途JSBridge 简单来讲，主要是 给 JavaScript 提供调用 Native 功能的接口，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。 既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 构建 Native 和非 Native 间消息通信的通道，而且是 双向通信的通道。所谓 双向通信的通道: JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。 Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。 这里有些同学有疑问了：消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？对于这个问题，在下一节里会给出解释。 4 JSBridge 的实现原理JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。 在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信） 和 句柄解析调用。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程） 通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 Hybrid 方案 为案例从这几点来剖析 JSBridge 的实现原理。 4.1 JSBridge 的通信原理Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。 4.1.1 JavaScript 调用 NativeJavaScript 调用 Native 的方式，主要有两种：注入 API 和 拦截 URL SCHEME 。 4.1.1.1 注入API注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。 对于 iOS 的 UIWebView，实例如下： JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;]; context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) { // Native 逻辑 }; 前端调用方式： window.postBridgeMessage(message); 对于 iOS 的 WKWebView 可以用以下方式： @interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt; @implementation WKWebVIewVC - (void)viewDidLoad { [super viewDidLoad]; WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init]; configuration.userContentController = [[WKUserContentController alloc] init]; WKUserContentController *userCC = configuration.userContentController; // 注入对象，前端调用其方法时，Native 可以捕获到 [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;]; WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; // TODO 显示 WebView } - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) { NSLog(@&quot;前端传递的数据 %@: &quot;,message.body); // Native 逻辑 } } 前端调用方式： window.webkit.messageHandlers.nativeBridge.postMessage(message); 对于 Android 可以采用下面的方式： publicclassJavaScriptInterfaceDemoActivityextendsActivity{ private WebView Wv; @Override publicvoidonCreate(Bundle savedInstanceState){ super.onCreate(savedInstanceState); Wv = (WebView)findViewById(R.id.webView); final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this); Wv.getSettings().setJavaScriptEnabled(true); Wv.addJavascriptInterface(myJavaScriptInterface, &quot;nativeBridge&quot;); // TODO 显示 WebView } publicclassJavaScriptInterface{ Context mContext; JavaScriptInterface(Context c) { mContext = c; } publicvoidpostMessage(String webMessage){ // Native 逻辑 } } } 前端调用方式： window.nativeBridge.postMessage(message); 在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 有兼容性问题的。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。） 4.1.1.2 拦截 URL SCHEME先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=ymfe.tech，protocol 是 qunarhy，host 则是 hy。 拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。 在时间过程中，这种方式有一定的 缺陷： 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。 创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。 但是之前为什么很多方案使用这种方式呢？因为它 支持 iOS6。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 并不优雅 的方式。 【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。 【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。 4.1.2 Native 调用 JavaScript相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。 Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了） 对于 iOS 的 UIWebView，示例如下： result = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString]; 对于 iOS 的 WKWebView，示例如下： [wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler]; 对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现： webView.loadUrl(&quot;javascript:&quot; + javaScriptString); 而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现： webView.evaluateJavascript(javaScriptString, new ValueCallback&lt;String&gt;() { @Override publicvoidonReceiveValue(String value){ } }); 【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。 4.1.3 通信原理小总结通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下： JavaScript 调用 Native 推荐使用 注入 API 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。 Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。 对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。 以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 为了与 Native 开发里事件响应机制一致，设计成 需要在 Object-C 去调 JavaScript 时才通过返回值触发调用。原理基本一样，只是实现方式不同。 当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。 4.2 JSBridge 接口实现从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：调用 Native（给 Native 发消息） 和 接被 Native 调用（接收 Native 消息）。因此，JSBridge 可以设计如下： window.JSBridge = { // 调用 Native invoke: function(msg) { // 判断环境，获取不同的 nativeBridge nativeBridge.postMessage(msg); }, receiveMessage: function(msg) { // 处理 msg } }; 在上面的文章中，提到过 RPC 中有一个非常重要的环节是 句柄解析调用 ，这点在 JSBridge 中体现为 句柄与功能对应关系。同时，我们将句柄抽象为 桥名（BridgeName），最终演化为 一个 BridgeName 对应一个 Native 功能或者一类 Native 消息。 基于此点，JSBridge 的实现可以优化为如下： window.JSBridge = { // 调用 Native invoke: function(bridgeName, data) { // 判断环境，获取不同的 nativeBridge nativeBridge.postMessage({ bridgeName: bridgeName, data: data || {} }); }, receiveMessage: function(msg) { var bridgeName = msg.bridgeName, data = msg.data || {}; // 具体逻辑 } }; JSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？ 对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释： 当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 当前页面唯一 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。 由此可见，callback 参数这个 唯一标识 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。 (function () { var id = 0, callbacks = {}; window.JSBridge = { // 调用 Native invoke: function(bridgeName, callback, data) { // 判断环境，获取不同的 nativeBridge var thisId = id ++; // 获取唯一 id callbacks[thisId] = callback; // 存储 Callback nativeBridge.postMessage({ bridgeName: bridgeName, data: data || {}, callbackId: thisId // 传到 Native 端 }); }, receiveMessage: function(msg) { var bridgeName = msg.bridgeName, data = msg.data || {}, callbackId = msg.callbackId; // Native 将 callbackId 原封不动传回 // 具体逻辑 // bridgeName 和 callbackId 不会同时存在 if (callbackId) { if (callbacks[callbackId]) { // 找到相应句柄 callbacks[callbackId](msg.data); // 执行调用 } } elseif (bridgeName) { } } }; })(); 最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下： (function () { var id = 0, callbacks = {}, registerFuncs = {}; window.JSBridge = { // 调用 Native invoke: function(bridgeName, callback, data) { // 判断环境，获取不同的 nativeBridge var thisId = id ++; // 获取唯一 id callbacks[thisId] = callback; // 存储 Callback nativeBridge.postMessage({ bridgeName: bridgeName, data: data || {}, callbackId: thisId // 传到 Native 端 }); }, receiveMessage: function(msg) { var bridgeName = msg.bridgeName, data = msg.data || {}, callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回 responstId = msg.responstId; // 具体逻辑 // bridgeName 和 callbackId 不会同时存在 if (callbackId) { if (callbacks[callbackId]) { // 找到相应句柄 callbacks[callbackId](msg.data); // 执行调用 } } elseif (bridgeName) { if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄 var ret = {}, flag = false; registerFuncs[bridgeName].forEach(function(callback) =&gt; { callback(data, function(r) { flag = true; ret = Object.assign(ret, r); }); }); if (flag) { nativeBridge.postMessage({ // 回调 Native responstId: responstId, ret: ret }); } } } }, register: function(bridgeName, callback) { if (!registerFuncs[bridgeName]) { registerFuncs[bridgeName] = []; } registerFuncs[bridgeName].push(callback); // 存储回调 } }; })(); 当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。 【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 =&gt; 解析参数，拿到 bridgeName、data 和 callbackId =&gt; 根据 bridgeName 找到功能方法，以 data 为参数执行 =&gt; 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。 5 JSBridge 如何引用对于 JSBridge 的引用，常用有两种方式，各有利弊。 5.1 由 Native 端进行注入注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。 它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。 5.2 由 JavaScript 端引用直接与 JavaScript 一起执行。 与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。 如何调用三种唤端媒介无论是 URL Scheme 还是 Intent 或者 Universal Link ，他们都算是 URL ，只是 URL Scheme 和 Intent 算是特殊的 URL。所以我们可以拿使用 URL 的方法来使用它们。 iframe 1&lt;iframe src=&quot;sinaweibo://qrcode&quot;&gt; 在只有 URL Scheme 的日子里，iframe 是使用最多的了。因为在未安装 app 的情况下，不会去跳转错误页面。但是 iframe 在各个系统以及各个应用中的兼容问题还是挺多的，不能全部使用 URL Scheme。 a 标签 1&lt;a href=&quot;intent://scan/#Intent;scheme=zxing;package=com.google.zxing.client.android;end&quot;&quot;&gt;扫一扫&lt;/a&gt; 对于动态生成的 a 标签，使用 dispatch 来模拟触发点击事件，发现很多种 event 传递过去都无效；使用 click() 来模拟触发，部分场景下存在这样的情况，第一次点击过后，回到原先页面，再次点击，点击位置和页面所识别位置有不小的偏移，所以 Intent 协议从 a 标签换成了 window.location。 window.location URL Scheme 在 ios 9+ 上诸如 safari、UC、QQ浏览器中， iframe 均无法成功唤起 APP，只能通过 window.location 才能成功唤端。当然，如果我们的 app 支持 Universal Link，ios 9+ 就用不到 URL Scheme 了。而 Universal Link 在使用过程中，我发现在 qq 中，无论是 iframe 导航 还是 a 标签打开 又或者 window.location 都无法成功唤端，一开始我以为是 qq 和微信一样禁止了 Universal Link 唤端的功能，其实不然，百般试验下，通过 top.location 唤端成功了。 判断唤端是否成功1234567891011121314151617181920212223const initialTime = new Date();let counter = 0;let waitTime = 0;const checkOpen = setInterval(() =&gt; &#123; count++; waitTime = new Date() - initialTime; if (waitTime &gt; 2500) &#123; clearInterval(checkOpen); cb(); &#125; if (counter &lt; 100) return; clearInterval(checkOpen); const hide = document.hidden || document.webkitHidden; if (!hide) &#123; cb(); // 唤端失败的回调函数 &#125;&#125;, 20); APP 如果被唤起的话，页面就会进入后台运行，setInterval 在 ios 中不会停止运行，在 android 中停止运行。每 20ms 执行一次，执行 100次 在页面中实际耗费与 2000 ms 不会相差多少。我们的判断条件比预期时间多设置了 500ms，所以如果安卓中 setInterval 内的函数执行 100 次以内所费时间超过 2500ms，则说明 APP 唤起成功，反之则代表失败。我们通过 document.hidden 和 document.webkitHidden 属性来判断 APP 在 ios 中是否被正常唤起，2000ms 内，页面转入后台运行，document.hidden 会返回 true，代表唤端成功，反之则代表失败。 判断是否安装app并打开,否则跳转下载的方法 应用场景 App产品在运营推广上有一个需求，就是要求可以让用户在访问我们的推广网页时，就可以判断出这个用户手机上是否安装了我们的App，如果安装了则可以直接在网页上打开，否则就引导用户前往下载。从而形成一个推广上的闭环。 解决办法 而对于点击链接后，能否直接打开，可以通过下面的代码来实现。前提条件：你得知道你的APP对应的打开协议，如贴吧APP，协议为：com.baidu.tieba:// ，微信的：weixin:// ，等等 12345678910111213141516&lt;!-- a标签点击打开的动作，在click事件中注册 --&gt;&lt;a href=&quot;javascript:;&quot; id=&quot;openApp&quot;&gt;贴吧客户端&lt;/a&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123; // 通过iframe的方式试图打开APP，如果能正常打开，会直接切换到APP，并自动阻止js其他行为 var ifr = document.createElement(&apos;iframe&apos;); ifr.src = &apos;com.baidu.tieba://&apos;;//打开app的协议，有app同事提供 ifr.style.display = &apos;none&apos;; document.body.appendChild(ifr); window.setTimeout(function()&#123; document.body.removeChild(ifr); window.location.href = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;//打开app下载地址，有app同事提供 &#125;,2000) &#125;;&lt;/script&gt; 此方法有些浏览器不兼容iframe，可以window.location的方法解决123456789&lt;a href=&quot;javascript:;&quot; id=&quot;openApp&quot;&gt;贴吧客户端&lt;/a&gt;&lt;script type=&quot;text/javascript&quot;&gt; document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123; window.location.href = &quot;com.baidu.tieba://&quot;; window.setTimeout(function()&#123; window.location.href = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;//打开app下载地址，有app同事提供 &#125;,2000) &#125;;&lt;/script&gt; js判断本地是否安装app123456789101112131415161718192021222324252627&lt;script language=&quot;javascript&quot;&gt; document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123; if(navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123; var loadDateTime = new Date(); window.setTimeout(function() &#123; var timeOutDateTime = new Date(); if(timeOutDateTime - loadDateTime &lt; 5000) &#123; window.location = &quot;https://itunes.apple.com/cn/app/id477927812&quot;; &#125; else &#123; window.close(); &#125; &#125;, 25); window.location = &quot;weixin:// &quot;; &#125; else if(navigator.userAgent.match(/android/i)) &#123; var state = null; try &#123; state = window.open(&quot;weixin://&quot;); &#125; catch(e) &#123;&#125; if(state) &#123; window.close(); &#125; else &#123; window.location = &quot;http://dldir1.qq.com/weixin/android/weixin656android1020.apk&quot;; &#125; &#125; &#125; &lt;/script&gt; 如果本地安装了app那么直接打开，否则苹果要跳转到app-store，安卓则要跳到对应的市场 解决方案 一 123456789101112131415161718192021222324//html代码中 的 a 标签，以微信为例，默认的是调用weixin scheme，去打开本机的微信，如果没有则跳转到相应连接 &lt;a href=&quot;weixin://&quot; class=&quot;btn-download&quot;&gt;立即打开&lt;/a&gt; // 为btn-download 绑定事件，如果在500ms内，没有解析到协议，那么就会跳转到下载链接 var appstore, ua = navigator.userAgent; if(ua.match(/Android/i))&#123; appstore = &apos;market://search?q=com.singtel.travelbuddy.android&apos;; &#125; if(ua.match(/iphone|ipod|ipad/))&#123; appstore = &quot;https://itunes.apple.com/cn/app/wei-xin/id414478124?mt=8&amp;ign-mpt=uo%3D4&quot;; &#125; function applink(fail)&#123; return function()&#123; var clickedAt = +new Date; // During tests on 3g/3gs this timeout fires immediately if less than 500ms. setTimeout(function()&#123; // To avoid failing on return to MobileSafari, ensure freshness! if (+new Date - clickedAt &lt; 2000)&#123; window.location = fail; &#125; &#125;, 500); &#125;; &#125; $(&apos;.icon-download, .btn-download&apos;)[0].onclick = applink(appstore); 解决方案二 通过在页面中生成一个隐藏的iframe，iframe的src指向 app 协议，例如 weixin scheme，并监听onerror事件，意思是如果无法解析协议，就会触发onerror事件，但是我尝试了一下，未果。代码如下，可参考一下 12345678910111213141516// 页面中有div#iframe-box 用来插入生成的iframe，还是以微信为例 var ifm = document.createElement(&apos;iframe&apos;), isInstalled; ifm.style.display = &apos;none&apos;; ifm.src = &apos;wixin://&apos;; ifm.onload = function(e)&#123; var e = e || window.event; e.preventDefault(); &#125; ifm.onerror = function()&#123; //isInstalled = false; alert(1); &#125; document.getElementById(&apos;iframe-box&apos;).appendChild(ifm); // 但这时的问题是，iframe的src成功解析到了协议，则会直接跳转，但是解析不到的话，也不会触发error事件，这个还要继续研究 // 可以把上面的代码，放到函数中，然后作为某个按钮的响应函数。 解决方案三 对于ios手机，会有如下写法1&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=414478124&quot; /&gt; 将上面代码放到head中，根据name也会知道意思，app-id是微信的app-id，用ios手机看会看到提示，andriod比可以，结果自行实验。（ios就是强大） H5唤起客户端通用机方案H5唤起客户端6 总结这篇文章主要剖析的 JSBridge 的实现及应用，包括 JavaScript 与 Native 间的通信原理，JSBridge 的 JavaScript 端实现 以及 引用方式，并给出了一些示例代码，希望对读者有一定的帮助。 JSBridge实战]]></content>
      <tags>
        <tag>JSBridge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建一个私有的npm仓库]]></title>
    <url>%2F2016%2F10%2F26%2FES6-%E4%B8%AD-Promise-%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[说明最近在复习 Promise 的知识，所以就做了一些题，这里挑出几道题，大家一起看看吧。 题目一const promise = new Promise((resolve, reject) =&gt; { console.log(1); resolve(); console.log(2); }) promise.then(() =&gt; { console.log(3); }) console.log(4); 解析首先 Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then() 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3。 答案1243 题目二const promise = newPromise((resolve, reject) =&gt; { resolve(&apos;success1&apos;); reject(&apos;error&apos;); resolve(&apos;success2&apos;); }); promise.then((res) =&gt; { console.log(&apos;then:&apos;, res); }).catch((err) =&gt; { console.log(&apos;catch:&apos;, err); }) 解析resolve 函数将 Promise 对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject 函数将 Promise 对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 而一旦状态改变，就不会再变。所以 代码中的reject(&#39;error&#39;); 不会有作用。 Promise 只能 resolve 一次，剩下的调用都会被忽略。所以 第二次的 resolve(&#39;success2&#39;); 也不会有作用。 答案then: success1 题目三Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log) 解析Promise.resolve 方法的参数如果是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为resolved，Promise.resolve 方法的参数，会同时传给回调函数。 then 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 then(null)，这就会导致前一个 Promise 的结果会穿透下面。 答案1 题目四红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promse实现）三个亮灯函数已经存在： functionred() { console.log(&apos;red&apos;); } functiongreen() { console.log(&apos;green&apos;); } functionyellow() { console.log(&apos;yellow&apos;); } 解析红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，意思就是3秒，执行一次 red 函数，2秒执行一次 green 函数，1秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以就利用递归来实现。 答案functionred() { console.log(&apos;red&apos;); } functiongreen() { console.log(&apos;green&apos;); } functionyellow() { console.log(&apos;yellow&apos;); } var light = function (timmer, cb) { returnnewPromise(function (resolve, reject) { setTimeout(function () { cb(); resolve(); }, timmer); }); }; var step = function () { Promise.resolve().then(function () { return light(3000, red); }).then(function () { return light(2000, green); }).then(function () { return light(1000, yellow); }).then(function () { step(); }); } step(); 题目五实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。 const timeout = ms =&gt;newPromise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(); }, ms); }); const ajax1 = () =&gt; timeout(2000).then(() =&gt; { console.log(&apos;1&apos;); return1; }); const ajax2 = () =&gt; timeout(1000).then(() =&gt; { console.log(&apos;2&apos;); return2; }); const ajax3 = () =&gt; timeout(2000).then(() =&gt; { console.log(&apos;3&apos;); return3; }); const mergePromise = ajaxArray =&gt; { // 在这里实现你的代码 }; mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; { console.log(&apos;done&apos;); console.log(data); // data 为 [1, 2, 3] }); // 要求分别输出// 1// 2// 3// done// [1, 2, 3] 解析首先 ajax1 、ajax2、ajax3 都是函数，只是这些函数执行后会返回一个 Promise，按题目的要求我们只要顺序执行这三个函数就好了，然后把结果放到 data 中，但是这些函数里都是异步操作，想要按顺序执行，然后输出 1，2，3并没有那么简单，看个例子。 functionA() { setTimeout(function () { console.log(&apos;a&apos;); }, 3000); } functionB() { setTimeout(function () { console.log(&apos;b&apos;); }, 1000); } A(); B(); // b// a 例子中我们是按顺序执行的 A，B 但是输出的结果却是 b，a 对于这些异步函数来说，并不会按顺序执行完一个，再执行后一个。这道题就是考用 Promise 控制异步流程，我们要想办法，让这些函数，一个执行完之后，再执行下一个，看答案吧。 答案// 保存数组中的函数执行后的结果var data = []; // Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。var sequence = Promise.resolve(); ajaxArray.forEach(function (item) { // 第一次的 then 方法用来执行数组中的每个函数，// 第二次的 then 方法接受数组中的函数执行后返回的结果，// 并把结果添加到 data 中，然后把 data 返回。 sequence = sequence.then(item).then(function (res) { data.push(res); return data; }); }) // 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。return sequence; 题目六以下代码最后输出什么？ const first = () =&gt; (newPromise((resolve, reject) =&gt; { console.log(3); let p = newPromise((resolve, reject) =&gt; { console.log(7); setTimeout(() =&gt; { console.log(5); resolve(6); }, 0) resolve(1); }); resolve(2); p.then((arg) =&gt; { console.log(arg); }); })); first().then((arg) =&gt; { console.log(arg); }); console.log(4); 解析这道题就其实和 Promise 的关系不太大，主要是需要理解 JS执行机制，才能很好的解决这道题，对于 JS 执行机制不了解的朋友推荐看看这篇文章 这一次，彻底弄懂 JavaScript 执行机制 第一轮事件循环先执行宏任务，主script ，new Promise立即执行，输出【3】， 执行 p 这个new Promise 操作，输出【7】， 发现 setTimeout，将回调放入下一轮任务队列（Event Queue），p 的 then，姑且叫做 then1，放入微任务队列，发现 first 的 then，叫 then2，放入微任务队列。执行console.log(4)，输出【4】，宏任务执行结束。 再执行微任务，执行 then1，输出【1】， 执行 then2，输出【2】。 到此为止，第一轮事件循环结束。开始执行第二轮。 第二轮事件循环先执行宏任务里面的，也就是 setTimeout 的回调，输出【5】。resolve(6) 不会生效，因为 p 这个 Promise 的状态一旦改变就不会在改变了。 答案374125 题目七有 8 个图片资源的 url，已经存储在数组 urls 中（即urls = [&#39;http://example.com/1.jpg&#39;, ...., &#39;http://example.com/8.jpg&#39;]），而且已经有一个函数 function loadImg，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。 var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;]; functionloadImg(url) { returnnewPromise((resolve, reject) =&gt; { const img = new Image() img.onload = function () { console.log(&apos;一张图片加载完成&apos;); resolve(); } img.onerror = reject img.src = url }) }; 解析题目的意思是需要我们这么做，先并发请求 3 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 3 个，直到需要加载的图片都全部发起请求。 用 Promise 来实现就是，先并发请求3个图片资源，这样可以得到 3 个 Promise，组成一个数组，就叫promises 吧，然后不断的调用 Promise.race 来返回最快改变状态的 Promise，然后从数组（promises）中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 url 被取完，最后再使用 Promise.all 来处理一遍数组（promises）中没有改变状态的 Promise。 答案var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;]; functionloadImg(url) { returnnewPromise((resolve, reject) =&gt; { const img = new Image() img.onload = function () { console.log(&apos;一张图片加载完成&apos;); resolve(); } img.onerror = reject img.src = url }) }; functionlimitLoad(urls, handler, limit) { // 对数组做一个拷贝const sequence = [].concat(urls) let promises = []; //并发请求到最大数 promises = sequence.splice(0, limit).map((url, index) =&gt; { // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标return handler(url).then(() =&gt; { return index }); }); // 利用数组的 reduce 方法来以队列的形式执行return sequence.reduce((last, url, currentIndex) =&gt; { return last.then(() =&gt; { // 返回最快改变状态的 PromisereturnPromise.race(promises) }).catch(err =&gt; { // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误// 更重要的是防止中断整个链式调用console.error(err) }).then((res) =&gt; { // 用新的 Promise 替换掉最快改变状态的 Promise promises[res] = handler(sequence[currentIndex]).then(() =&gt; { return res }); }) }, Promise.resolve()).then(() =&gt; { returnPromise.all(promises) }) } limitLoad(urls, loadImg, 3) /* 因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用 limitLoad(urls, loadImg, 3).then(() =&gt; { console.log(&apos;所有图片加载完成&apos;); }).catch(err =&gt; { console.error(err); }) */ 总结这几道题，有考查 Promise 基础知识的，也有考对 Promise 灵活运用的，如果这些题你都做的很好的话，那你对 Promise 的理解应该是不错的了。]]></content>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS,AMD,CMD,ES6]]></title>
    <url>%2F2016%2F10%2F25%2FCommonJS-AMD-CMD-ES6%2F</url>
    <content type="text"><![CDATA[CommonJS,AMD,CMD,ES6 commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。 CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。 /** AMD写法 **/ define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) { // 等于在最前面声明并初始化了要用到的所有模块 a.doSomething(); if (false) { // 即便没用到某个模块 b，但 b 还是提前执行了 b.doSomething() } }); /** CMD写法 **/ define(function(require, exports, module) { var a = require(&apos;./a&apos;); //在需要时申明 a.doSomething(); if (false) { var b = require(&apos;./b&apos;); b.doSomething(); } }); ES6 模块是动态引用:ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。 ES6 模块与 CommonJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用,CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。编译时加载: ES6模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于Viewport与device-width的一点理解]]></title>
    <url>%2F2016%2F04%2F26%2F%E5%85%B3%E4%BA%8EViewport%E4%B8%8Edevice-width%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[再进行移动web开发的时候都要加一句：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; 我们经常使用的里的viewport究竟是什么意思，这里的device-width跟我们用JS获取到的屏宽的区别与联系分别是什么，为什么去掉标签后页面会变得很小很小？ 为什么很多分辨率很大的屏幕宽度其实并不大，屏幕分辨率与用JS获取到的屏宽的区别与联系分别又是什么？ 要说这个，先来了解下一些移动端基础知识： 1、物理像素(设备像素，分辨率)设备像素，在同一个设备上，它的物理像素是固定的，这是厂商在出厂时就设置好了的，即一个设备的分辨率是固定的。 2、逻辑像素(CSS像素)CSS像素，viewport中的一个小方格，CSS样式代码中使用的是逻辑像素。如果在一个设备中，物理像素与逻辑像素相等，将不会产生任何问题。但是，在iphone 4中，物理像素是640px960px，而逻辑像素数为320480px。因此，需要使用大约4个物理像素来显示一个CSS像素。 3、像素比物理像素与逻辑像素之间的比例。当像素比为1:1时，使用1个物理像素显示1个逻辑像素；当像素比为2:1时，使用4个物理像素显示1个逻辑像素。 4、CSS中的1px并不等于设备的1px在CSS中一般使用px作为单位，在Web浏览器中CSS的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成一个错觉，那就是CSS中的像素就是设备的物理像素。但实际情况却并非如此，CSS中的像素只是一个抽象的单位，在不同的设备或不同的环境中，CSS中的1px所代表的设备物理像素是不同的。在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320480，在iphone3上，1个CSS像素确实是等于1个物理像素的。后来随着技术的发展，移动设备的像素越来越高，从iphone4开始，推出了所谓的Retina屏，分辨率提高了一倍，变成640960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，1个CSS像素是等于4个物理像素的。 5、实现真正的1物理像素当viewport的属性initial-scale为1时，页面大小正常，但initial-scale为0.5时，页面被缩小了1倍，像素比为2:1的设备本来1个CSS像素宽度占2个物理像素宽度，缩小后的1个CSS像素宽度就只占1个物理像素，即实现了真正的1物理像素。eg：border-width:1px并不是最小边框，浏览器可以显示的最小粒度比1px还要小。为什么会出现比border-width:1px更细的边框？屏幕能够显示的最小粒度是1个物理像素，iPhone4的像素比为2，设置border-width:1px后，边框占了4个物理像素，如果能让边框的宽度为1物理像素，那么它就比1个CSS像素要细，这可以通过设置&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=0.5&quot;&gt;。 CSS pixel与device pixels (css px与device px)首先了解下什么是CSS pixels，什么是device pixels； 1．CSS pixels可以理解为css像素，是浏览器使用的抽象单位，主要用来在网页上绘制内容。也可以说css px是专门为web开发者提出的一个抽象概念，也只跟我们平时写的css样式有关，与分辨率（比如720px*1280px）里的px没关系。 2． device pixels可以理解为是设备像素，官方的解释是：显示屏幕的最小物理单位，每个dp包含自己的颜色、高宽等。 对于我们做web开发的人来说，我们用到的最多的地方是“css像素”，即类似width:300px;font-size:14px;这类的css语句里用到的。它跟设备自身的px是没关系的。也就是说1个CSS 像素占多少个物理像素是不确定的，这个问题通过页面的放缩比较容易理解。比如一个普通的html页面上，有一个300px的元素；如果我们放大页面，元素会占据更多的设备像素（即device pixels），但它的CSS pixels不变，依然是300px；缩小页面也是同样的道理，占据了更少的device pixels，但它的CSS pixels不变。也就是说，元素占据了多少device pixels，是由当前页面的放缩比例而定的。 不过，页面的缩放对我们web开发来说是好像没有任何意义的。但有一个问题，我们开发出来的页面是想要在各个屏幕个以最佳的样式展示出来的，我们不能让页面里存在不能控制的元素。所以就出现了它：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot; /&gt; 也就是我们在进行web开发的时候经常用到的viewport。那么viewport到底是个什么玩意儿呢，而且content里面width为什么要等于device-width呢，device-width又是个什么概念呢？下面我们来看看它们哥俩儿是什么。 Viewport 与 device-width在解释这两个概念之前，先说一个大家都知道，但不明白为什么的情况：把一个普通的在PC上开发的HTML页面直接放手机上，你会发现不管多大的页面都可以在小小的手机屏幕上显示，但是图文都会显示的特别小；如果你用js获取下页面宽度，你会发现，大多数的页面宽度都是980px的，这个就跟viewport有关。 Viewport起源于苹果，但现在已经被大多数浏览器支持。关于viewport有两个概念visual viewport跟layout viewport。这里visual viewport也就是视觉上的窗口，可以理解为设备自己的宽度。这时，如果你有一个长960的页面，有一个元素是20%（实际解析出来就是192px）。但如果我用宽为320px的屏幕打开呢，这个元素就成了64px，但是这个时候我设置的字体大小是12px，在320px的屏幕上就只能显示64/12个字了～ 鉴于这个问题，苹果找到一种解决方法，在移动版的safari中定义了viewport meta标签，它的作用就是创建一个虚拟的窗口（viewport），这个虚拟的窗口就是layout viewport分辨率接近桌面显示器，apple将其定位为980px。在手机上，可以通过document.documentElement.clientWidth来获取。 其他浏览器厂商也有不同的解决办法，例如UCweb是使用的中间技术。 另外据说，不同浏览器厂商对于layout viewport的大小都有自己的定义。但是，我用手上不多的几个手机（小米2s、SONY、金立、ipad）测试的结果，都是980px。其中在小米2s上测试了小米自带浏览器、QQ浏览器、UC浏览器、谷歌浏览器，还有opera浏览器，结果都一样；其他的手机上面不管装了什么浏览器，都测试了，结果都是980px。但是这个值对于我们web开发来说，好像也没有什么用处。 因为大多数情况下，&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;这个标签对我们来说是最给力的，可以让我们的页面里的图文显示的是正常的，很大程度上提高了页面的可读性。而这一meta标签的功能就是设置layout viewport为device-width的宽度。但是device-width具体是什么呢？ 第一代iphone的时候，分辨率为320480，屏幕尺寸为3.5寸（注意，这个3.5寸说的是屏幕的对角线宽），这时候device-width就是320px，也是手机的分辨率宽，此时device-width就是设备宽。但第二代的iphone分辨率提高为了480960，屏幕尺寸为依然为3.5寸，如果device-width还是设备宽，那么同样是320px的页面放480*960的手机屏上，图文就会变得比较小，又会影响其可读性。因此iphone的device-width一直维持在320px，ipad一直维持在1024px。这个时候，device-width就不是设备宽了（也就不是分辨率的宽了），是一个中间层。Android采用的也是这一概念，其device-width值以360居多，但也不乏有像540px和600px这样的奇葩。在设置了标签以后，device-width值可以用window.innerWidth来获取device-width值。 有关DPIdpi(Dots Per Inch)，有时也叫做ppi(Point Per Inch)，翻译过来也叫像素密度，表示设备每英寸所占有的像素数；数值越高，即代表显示屏能够以越高的密度显示图像。（注：这里的像素，指的是device pixels。）DPI的计算公式： 有意思的是，这个值比苹果官网上公布的326还有高一点点。 其中，PPI在120-160之间的手机被归为低密度手机，160-240被归为中密度，240-320被归为高密度，320以上被归为超高密度（Apple给了它一个上流的名字——retina）。 这些密度对应着一个特定的缩放比例值，拿我们最熟悉的iphone4或4s来说，它们的PPI是326，属于超高密度的手机。当我们书写一个宽度为320px的页面放到iphone中显示，你会发现，它竟然是满宽的。这是因为，页面被默认放大了两倍，也就是640px，而iphone4或4s的宽，正是640px。 DevicePixelRadioDevicePixelRadio，定义：window.devicePixelRatio是设备上物理像素（也就是device-width）和设备独立像素（device-independent pixels，即dips）的比例。公式表示就是：window.devicePixelRatio = 物理像素/dips Android 和 iPhone 中，都有一个占整个屏幕大小的换算单位， Android 中叫 dip 或 dp，iPhone 中叫 point 。Dip，就是device independent pixels，设备独立像素。而设备的物理像素和 dip 的比例就是 devicePixelRatio，此值可以通过 window.devicePixelRatio 属性获取。 据我查找到的一些资料显示，这里的独立像素的值其实就是device-width值。这个值也就是我们平时在手机上布局用的宽度，当然是在设置了标签的前提下。 这里为什么提到devicePixelRatio这个概念呢？因为当devicePixelRatio=1.5的时候，也就是说当屏幕分辨率宽与device-width的比值为1.5时，某些手机自带的浏览器（特别是三星手机出现在最多）会出现1px的线解析成2px的bug，但是经测试同一部手机上安装的UC浏览器一般不会有这个bug。]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS属性之attr()]]></title>
    <url>%2F2016%2F03%2F25%2FCSS%E5%B1%9E%E6%80%A7%E4%B9%8Battr%2F</url>
    <content type="text"><![CDATA[那具体怎么用呢，给大家举个栗子，前段时间刚好用到的，给按钮实现提示功能，就是鼠标放上去后，出来个小提示：123&lt;div class=&quot;wrap&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;btn&quot; data-tip=&quot;点击作答&quot;&gt;一个按钮&lt;/a&gt;&lt;/div&gt;复制代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445.btn &#123; display: inline-block; padding: 5px 20px; border-radius: 4px; background-color: #6495ed; color: #fff; font-size: 14px; text-decoration: none; text-align: center; position: relative;&#125;.btn::before &#123; content: attr(data-tip); width: 80px; padding: 5px 10px; border-radius: 4px; background-color: #000; color: #ccc; position: absolute; top: -30px; left: 50%; transform: translate(-50%); text-align: center; opacity: 0; transition: all .3s;&#125;.btn::after &#123; content: &apos;&apos;; border: 8px solid transparent; border-top: 8px solid #000; position: absolute; top: -3px; left: 50%; transform: translate(-50%); opacity: 0; transition: all .3s;&#125;.btn:hover::before &#123; top: -40px; opacity: 1;&#125;.btn:hover::after &#123; top: -13px; opacity: 1;&#125; 当然attr()还可以获取更多的其他属性，比如a标签里的href属性等，更多的用法大家自行尝试吧。]]></content>
  </entry>
  <entry>
    <title><![CDATA[eval() 和 new Function() 执行JS代码]]></title>
    <url>%2F2016%2F02%2F28%2Feval-%E5%92%8C-new-Function-%E6%89%A7%E8%A1%8CJS%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[DEMO1234567891011var a = &apos;global scope&apos;function b()&#123; var a = &apos;local scope&apos; eval(&apos;console.log(a)&apos;) //local scope ;(new Function(&apos;&apos;,&apos;console.log(a)&apos;))() //global scope&#125; b() local scopeglobal scope eval中的代码执行时的作用域为当前作用域。它可以访问到函数中的局部变量。 new Function中的代码执行时的作用域为全局作用域，不论它的在哪个地方调用的。所以它访问的是全局变量a。它根本无法访问b函数内的局部变量。 eval()以 str 的方式运行 JavaScript 代码，比如：123&gt; var a = 12;&gt; eval( &apos;a+5&apos; );&gt; 17 注意语句上下文 eval()的解析：1234&gt; eval( &apos;&#123; foo: 123 &#125;&apos; );&gt; 123&gt; eval( &apos;(&#123; foo: 123 &#125;)&apos; );&gt; &#123; foo: 123 &#125; 严格模式下的 eval()对于 eval()，理应当在严格模式下使用。在松散模式下运行代码会在当前的作用域中创建局部变量： function f(){ eval( &apos;var foo = 1&apos; ); console.log( foo ); // 1 } 严格模式下就不会出现该情况。但是，运行代码仍然具有读写当前作用域中变量的权限。你需要通过间接调用 eval() 来阻止这种权限。 全局作用域下间接执行 eval() 有两种调用 eval() 的方式： 直接方式：通过直接调用名为 “eval” 的函数。 间接方式：使用其他的一些方式。（通过 call 调用，将其以其他名字作为 window 下的一个方法存储，在那里进行调用） 之前已经看过，在当前作用域直接使用 eval 执行代码 123456var x = &apos;global&apos;; function directEval()&#123; &apos;use strict&apos;; var x = &apos;local&apos;; console.log( eval(&apos;x&apos;) ); // local &#125; 反之，在全局作用域中间接调用 eval。 12345678910111213var x = &apos;global&apos;; function indirectEval()&#123; &apos;use strict&apos;; var x = &apos;local&apos;; // 不同方式调用 call console.log( eval.call(null, &apos;x&apos;) ); // global console.log( window.eval(&apos;x&apos;) ); // global console.log( (1,eval)(&apos;x&apos;) ); // global (1) var xeval = eval; console.log( xeval(&apos;x&apos;) ); // global var obj = &#123; eval: eval &#125; console.log( obj.eval(&apos;x&apos;) ); // global&#125; 说明：当你通过一个名称来引用一个变量的时候，其初始值为一个所谓的引用，数据结构分为两部分： 基础是指向存储变量的值的数据结构。 引用名是变量的名称在一个函数调用 eval 的时候，该函数的调用操作符（括号）遇到一个对 eval 的引用可以确定被调用函数的名称。所以此时函数会触发一个直接的 eval 调用。当然你可以不给调用操作符引用来强制间接调用 eval。这是由于在操作符运行之前获取引用的值来实现的。在 （1）标注的那一行，逗号操作符为我们实现的这点。这个运算符运行了第一个运算元并返回了第二个运算元的结果。运算结果总是返回 值 的，意味着引用已经被解析。 间接的运行代码总是松散的。这是由于代码被独立的在当前环境中运行的结果。 1234567function strictFunc()&#123; &apos;use strict&apos;; var code = &apos;(function()&#123; return this; &#125;())&apos;; var result = eval.call( null, code ); console.log( result !== undefined ); // true sloppy mode&#125; new Function()Function 构造函数的函数签名。new Function( param1, param2, …, paramN,funcBody );它创建一个包含0个或者过个参数名为 param1 等的函数，函数体为 funcBody。相当于如下方式创建函数：123function ( (param1), (param2), ..., (paramN) )&#123; (funcBody) &#125; 例如： 12var f = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x+y&apos;); f( 3, 4 ) 与间接 eval 调用类似，newFunction() 创建的函数作用域也是全局的。 var x = &apos;global&apos;; function strictFunc(){ &apos;use strict&apos;; var x = &apos;local&apos;; var f = new Function(&apos;return x&apos;); console.log( f() ); //global } 以下的函数也是默认松散模式 function strictFunc(){ &apos;use strict&apos;; var sl = newFunction( &apos;return this&apos; ); console.log( sl() !== undefined ); // true, sloppy modevar st = newFunction( &apos;&quot;use strict&quot;; return this;&apos; ); console.log( st() !== undefined ); // true, strict mode } eval() 对比 new Function()一般来说，使用 new Function() 运行代码比 eval() 更为好一些：函数的参数提供了清晰的接口来运行代码，而没有必要使用较为笨拙的语法来间接的调用 eval() 确保代码只能访问自己的和全局的变量。 最佳实践通常：避免使用 eval() 和 new Function() 。动态运行代码不但速度较慢，还有潜在的安全风险。一般都可以找到更好地替代方案。你也不应该使用 eval() 或者 newFunction() 来解析 JSON格式的数据。那也是不安全的。要么使用 ECMAScript 5 内置的对JSON的支持方法，要么使用一个类库。合理使用实例。依旧有一些较为合理，对 eval() 和 newFunction() 使用较为高级的：配置函数数据（JSON 不允许），模板库，解析，命令行和模块系统。]]></content>
  </entry>
  <entry>
    <title><![CDATA[防抖和节流原理分析]]></title>
    <url>%2F2016%2F02%2F11%2F%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[窗口的resize、scroll、输入框内容校验等操作时，如果这些操作处理函数是较为复杂或页面频繁重渲染等操作时，在这种情况下如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少触发的频率，同时又不影响实际效果。 防抖debounce（防抖），简单来说就是防止抖动。 当持续触发事件时，debounce 会合并事件且不会去触发事件，当一定时间内没有触发再这个事件时，才真正去触发事件。 非立即执行版非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 const debounce = (func, wait, ...args) =&gt; { let timeout; return function(){ const context = this; if (timeout) clearTimeout(timeout); timeout = setTimeout(() =&gt; { func.apply(context, args) },wait); } } 如此调用： content.onmousemove = debounce(count,1000); 立即执行版立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。 const debounce = (func, wait, ...args) =&gt; { let timeout; return function(){ const context = this; if (timeout) cleatTimeout(timeout); let callNow = !timeout; timeout = setTimeout(() =&gt; { timeout = null; },wait) if(callNow) func.apply(context,args) } } 结合版/** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */functiondebounce(func,wait,immediate) { var timeout; returnfunction () { var context = this; var args = arguments; if (timeout) clearTimeout(timeout); if (immediate) { var callNow = !timeout; timeout = setTimeout(function(){ timeout = null; }, wait) if (callNow) func.apply(context, args) } else { timeout = setTimeout(function(){ func.apply(context, args) }, wait); } } } 节流throttle（节流），当持续触发事件时，保证隔间时间触发一次事件。 持续触发事件时，throttle 会合并一定时间内的事件，并在该时间结束时真正去触发一次事件。 时间戳版在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。 const throttle = (func, wait, ...args) =&gt; { let pre = 0; returnfunction(){ const context = this; let now = Date.now(); if (now - pre &gt;= wait){ func.apply(context, args); pre = Date.now(); } } } 定时器版在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。 const throttle = (func, wait, ...args) =&gt; { let timeout; return function(){ const context = this; if(!timeout){ timeout = setTimeout(() =&gt; { timeout = null; func.apply(context,args); },wait) } } } 结合版其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。 /** * @desc 函数节流 * @param func 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */functionthrottle(func, wait ,type) { if(type===1){ var previous = 0; }elseif(type===2){ var timeout; } returnfunction() { var context = this; var args = arguments; if(type===1){ var now = Date.now(); if (now - previous &gt; wait) { func.apply(context, args); previous = now; } }elseif(type===2){ if (!timeout) { timeout = setTimeout(function() { timeout = null; func.apply(context, args) }, wait) } } } }]]></content>
      <tags>
        <tag>防抖</tag>
        <tag>节流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[defer和async的区别]]></title>
    <url>%2F2016%2F01%2F25%2Fdefer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[先来试个一句话解释仨，当浏览器碰到 script 脚本的时候： &lt;script src=&quot;&quot;&gt;&lt;/script&gt; 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 &lt;script async src=&quot;&quot;&gt;&lt;/script&gt; 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 &lt;script defer src=&quot;&quot;&gt;&lt;/script&gt; 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 然后从实用角度来说呢，首先把所有脚本都丢到 &lt;/body&gt; 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。 接着，我们来看一张图咯： 蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】此图告诉我们以下几个要点： defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析） 它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的 关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用 async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行 仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastClick-源码解析]]></title>
    <url>%2F2016%2F01%2F22%2FFastClick-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687;(function() &#123; &apos;use strict&apos;; //构造函数 function FastClick(layer, options) &#123; var oldOnClick; options = options || &#123;&#125;; //是否开始追踪click事件 this.trackingClick = false; //存储第一次按下时间戳 this.trackingClickStart = 0; //目标元素 this.targetElement = null; //存放坐标值X this.touchStartX = 0; //存放坐标值Y this.touchStartY = 0; //主要hack iOS4下的一个怪异问题 this.lastTouchIdentifier = 0; //用于区分是click还是Touchmove，若出点移动超过该值则视为touchmove this.touchBoundary = options.touchBoundary || 10; // 绑定了FastClick的元素，一般是是body this.layer = layer; //双击最小点击时间差 this.tapDelay = options.tapDelay || 200; //长按最大时间 this.tapTimeout = options.tapTimeout || 700; //如果是属于不需要处理的元素类型，则直接返回 if(FastClick.notNeeded(layer)) &#123; return; &#125; //语法糖，兼容一些用不了 Function.prototype.bind 的旧安卓 //所以后面不走 layer.addEventListener(&apos;click&apos;, this.onClick.bind(this), true); function bind(method, context) &#123; return function() &#123; return method.apply(context, arguments); &#125;; &#125; var methods = [&apos;onMouse&apos;, &apos;onClick&apos;, &apos;onTouchStart&apos;, &apos;onTouchMove&apos;, &apos;onTouchEnd&apos;, &apos;onTouchCancel&apos;]; var context = this; for(var i = 0, l = methods.length; i &lt; l; i++) &#123; context[methods[i]] = bind(context[methods[i]], context); &#125; //安卓则做额外处理 if(deviceIsAndroid) &#123; layer.addEventListener(&apos;mouseover&apos;, this.onMouse, true); layer.addEventListener(&apos;mousedown&apos;, this.onMouse, true); layer.addEventListener(&apos;mouseup&apos;, this.onMouse, true); &#125; layer.addEventListener(&apos;click&apos;, this.onClick, true); layer.addEventListener(&apos;touchstart&apos;, this.onTouchStart, false); layer.addEventListener(&apos;touchmove&apos;, this.onTouchMove, false); layer.addEventListener(&apos;touchend&apos;, this.onTouchEnd, false); layer.addEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false); // 兼容不支持 stopImmediatePropagation 的浏览器(比如 Android 2) if(!Event.prototype.stopImmediatePropagation) &#123; layer.removeEventListener = function(type, callback, capture) &#123; var rmv = Node.prototype.removeEventListener; if(type === &apos;click&apos;) &#123; rmv.call(layer, type, callback.hijacked || callback, capture); &#125; else &#123; rmv.call(layer, type, callback, capture); &#125; &#125;; layer.addEventListener = function(type, callback, capture) &#123; var adv = Node.prototype.addEventListener; if(type === &apos;click&apos;) &#123; //留意这里 callback.hijacked 中会判断 event.propagationStopped 是否为真来确保（安卓的onMouse事件）只执行一次 //在 onMouse 事件里会给 event.propagationStopped 赋值 true adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) &#123; if(!event.propagationStopped) &#123; callback(event); &#125; &#125;), capture); &#125; else &#123; adv.call(layer, type, callback, capture); &#125; &#125;; &#125; // 如果layer直接在DOM上写了 onclick 方法，那我们需要把它替换为 addEventListener 绑定形式 if(typeof layer.onclick === &apos;function&apos;) &#123; oldOnClick = layer.onclick; layer.addEventListener(&apos;click&apos;, function(event) &#123; oldOnClick(event); &#125;, false); layer.onclick = null; &#125; &#125; /** * Windows Phone 8.1 fakes user agent string to look like Android and iPhone. * * @type boolean */ var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0; /** * Android requires exceptions. * * @type boolean */ var deviceIsAndroid = navigator.userAgent.indexOf(&apos;Android&apos;) &gt; 0 &amp;&amp; !deviceIsWindowsPhone; /** * iOS requires exceptions. * * @type boolean */ var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone; /** * iOS 4 requires an exception for select elements. * * @type boolean */ var deviceIsIOS4 = deviceIsIOS &amp;&amp; (/OS 4_\d(_\d)?/).test(navigator.userAgent); /** * iOS 6.0-7.* requires the target element to be manually derived * * @type boolean */ var deviceIsIOSWithBadTarget = deviceIsIOS &amp;&amp; (/OS [6-7]_\d/).test(navigator.userAgent); /** * BlackBerry requires exceptions. * * @type boolean */ var deviceIsBlackBerry10 = navigator.userAgent.indexOf(&apos;BB10&apos;) &gt; 0; //判断元素是否要保留穿透功能 FastClick.prototype.needsClick = function(target) &#123; switch(target.nodeName.toLowerCase()) &#123; // disabled的input case &apos;button&apos;: case &apos;select&apos;: case &apos;textarea&apos;: if(target.disabled) &#123; return true; &#125; break; case &apos;input&apos;: // file组件必须通过原生click事件点击才有效 if((deviceIsIOS &amp;&amp; target.type === &apos;file&apos;) || target.disabled) &#123; return true; &#125; break; case &apos;label&apos;: case &apos;iframe&apos;: case &apos;video&apos;: return true; &#125; //元素带了名为“bneedsclick”的class也返回true return(/\bneedsclick\b/).test(target.className); &#125;; //判断给定元素是否需要通过合成click事件来模拟聚焦 FastClick.prototype.needsFocus = function(target) &#123; switch(target.nodeName.toLowerCase()) &#123; case &apos;textarea&apos;: return true; case &apos;select&apos;: return !deviceIsAndroid; //iOS下的select得走穿透点击才行 case &apos;input&apos;: switch(target.type) &#123; case &apos;button&apos;: case &apos;checkbox&apos;: case &apos;file&apos;: case &apos;image&apos;: case &apos;radio&apos;: case &apos;submit&apos;: return false; &#125; return !target.disabled &amp;&amp; !target.readOnly; default: //带有名为“bneedsfocus”的class则返回true return(/\bneedsfocus\b/).test(target.className); &#125; &#125;; //合成一个click事件并在指定元素上触发 FastClick.prototype.sendClick = function(targetElement, event) &#123; var clickEvent, touch; // 在一些安卓机器中，得让页面所存在的 activeElement（聚焦的元素，比如input）失焦，否则合成的click事件将无效 if(document.activeElement &amp;&amp; document.activeElement !== targetElement) &#123; document.activeElement.blur(); &#125; touch = event.changedTouches[0]; // 合成(Synthesise) 一个 click 事件 // 通过一个额外属性确保它能被追踪（tracked） clickEvent = document.createEvent(&apos;MouseEvents&apos;); clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null); clickEvent.forwardedTouchEvent = true; // fastclick的内部变量，用来识别click事件是原生还是合成的 targetElement.dispatchEvent(clickEvent); //立即触发其click事件 &#125;; FastClick.prototype.determineEventType = function(targetElement) &#123; //安卓设备下 Select 无法通过合成的 click 事件被展开，得改为 mousedown if(deviceIsAndroid &amp;&amp; targetElement.tagName.toLowerCase() === &apos;select&apos;) &#123; return &apos;mousedown&apos;; &#125; return &apos;click&apos;; &#125;; //设置元素聚焦事件 FastClick.prototype.focus = function(targetElement) &#123; var length; // 组件建议通过setSelectionRange(selectionStart, selectionEnd)来设定光标范围（注意这样还没有聚焦 // 要等到后面触发 sendClick 事件才会聚焦） // 另外 iOS7 下有些input元素(比如 date datetime month) 的 selectionStart 和 selectionEnd 特性是没有整型值的， // 导致会抛出一个关于 setSelectionRange 的模糊错误，它们需要改用 focus 事件触发 if(deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&apos;date&apos;) !== 0 &amp;&amp; targetElement.type !== &apos;time&apos; &amp;&amp; targetElement.type !== &apos;month&apos;) &#123; length = targetElement.value.length; targetElement.setSelectionRange(length, length); &#125; else &#123; //直接触发其focus事件 targetElement.focus(); &#125; &#125;; /** * 检查target是否一个滚动容器里的子元素，如果是则给它加个标记 */ FastClick.prototype.updateScrollParent = function(targetElement) &#123; var scrollParent, parentElement; scrollParent = targetElement.fastClickScrollParent; // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the // target element was moved to another parent. if(!scrollParent || !scrollParent.contains(targetElement)) &#123; parentElement = targetElement; do &#123; if(parentElement.scrollHeight &gt; parentElement.offsetHeight) &#123; scrollParent = parentElement; targetElement.fastClickScrollParent = parentElement; break; &#125; parentElement = parentElement.parentElement; &#125; while (parentElement); &#125; // 给滚动容器加个标志fastClickLastScrollTop，值为其当前垂直滚动偏移 if(scrollParent) &#123; scrollParent.fastClickLastScrollTop = scrollParent.scrollTop; &#125; &#125;; /** * 返回目标元素 */ FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) &#123; // 一些较老的浏览器，target 可能会是一个文本节点，得返回其DOM节点 if(eventTarget.nodeType === Node.TEXT_NODE) &#123; return eventTarget.parentNode; &#125; return eventTarget; &#125;; FastClick.prototype.onTouchStart = function(event) &#123; var targetElement, touch, selection; // 多指触控的手势则忽略 if(event.targetTouches.length &gt; 1) &#123; return true; &#125; targetElement = this.getTargetElementFromEventTarget(event.target); //一些较老的浏览器，target 可能会是一个文本节点，得返回其DOM节点 touch = event.targetTouches[0]; if(deviceIsIOS) &#123; //IOS处理 // 若用户已经选中了一些内容（比如选中了一段文本打算复制），则忽略 selection = window.getSelection(); if(selection.rangeCount &amp;&amp; !selection.isCollapsed) &#123; return true; &#125; if(!deviceIsIOS4) &#123; //是否IOS4 //怪异特性处理——若click事件回调打开了一个alert/confirm，用户下一次tap页面的其它地方时，新的touchstart和touchend //事件会拥有同一个touch.identifier（新的 touch event 会跟上一次触发alert点击的 touch event 一样）， //为避免将新的event当作之前的event导致问题，这里需要禁用默认事件 //另外chrome的开发工具启用&apos;Emulate touch events&apos;后，iOS UA下的 identifier 会变成0，所以要做容错避免调试过程也被禁用事件了 if(touch.identifier &amp;&amp; touch.identifier === this.lastTouchIdentifier) &#123; event.preventDefault(); return false; &#125; this.lastTouchIdentifier = touch.identifier; // 如果target是一个滚动容器里的一个子元素(使用了 -webkit-overflow-scrolling: touch) ，而且满足: // 1) 用户非常快速地滚动外层滚动容器 // 2) 用户通过tap停止住了这个快速滚动 // 这时候最后的&apos;touchend&apos;的event.target会变成用户最终手指下的那个元素 // 所以当快速滚动开始的时候，需要做检查target是否滚动容器的子元素，如果是，做个标记 // 在touchend时检查这个标记的值（滚动容器的scrolltop）是否改变了，如果是则说明页面在滚动中，需要取消fastclick处理 this.updateScrollParent(targetElement); &#125; &#125; this.trackingClick = true; //做个标志表示开始追踪click事件了 this.trackingClickStart = event.timeStamp; //标记下touch事件开始的时间戳 this.targetElement = targetElement; //标记touch起始点的页面偏移值 this.touchStartX = touch.pageX; this.touchStartY = touch.pageY; // this.lastClickTime 是在 touchend 里标记的事件时间戳 // this.tapDelay 为常量 200 （ms） // 此举用来避免 phantom 的双击（200ms内快速点了两次）触发 click // 反正200ms内的第二次点击会禁止触发点击的默认事件 if((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123; event.preventDefault(); &#125; return true; &#125;; //判断是否移动了 //this.touchBoundary是常量，值为10 //如果touch已经移动了10个偏移量单位，则应当作为移动事件处理而非click事件 FastClick.prototype.touchHasMoved = function(event) &#123; var touch = event.changedTouches[0], boundary = this.touchBoundary; if(Math.abs(touch.pageX - this.touchStartX) &gt; boundary || Math.abs(touch.pageY - this.touchStartY) &gt; boundary) &#123; return true; &#125; return false; &#125;; FastClick.prototype.onTouchMove = function(event) &#123; //不是需要被追踪click的事件则忽略 if(!this.trackingClick) &#123; return true; &#125; // 如果target突然改变了，或者用户其实是在移动手势而非想要click // 则应该清掉this.trackingClick和this.targetElement，告诉后面的事件你们也不用处理了 if(this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) &#123; this.trackingClick = false; this.targetElement = null; &#125; return true; &#125;; //找到label标签所映射的组件，方便让用户点label的时候直接激活该组件 FastClick.prototype.findControl = function(labelElement) &#123; // 有缓存则直接读缓存着的 if(labelElement.control !== undefined) &#123; return labelElement.control; &#125; // 获取指向的组件 if(labelElement.htmlFor) &#123; return document.getElementById(labelElement.htmlFor); &#125; // 没有for属性则激活页面第一个组件（labellable 元素） return labelElement.querySelector(&apos;button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea&apos;); &#125;; FastClick.prototype.onTouchEnd = function(event) &#123; var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement; if(!this.trackingClick) &#123; return true; &#125; // 避免 phantom 的双击（200ms内快速点了两次）触发 click // 我们在 ontouchstart 里已经做过一次判断了（仅仅禁用默认事件），这里再做一次判断 if((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123; this.cancelNextClick = true; //该属性会在 onMouse 事件中被判断，为true则彻底禁用事件和冒泡 return true; &#125; //this.tapTimeout是常量，值为700 //识别是否为长按事件，如果是（大于700ms）则忽略 if((event.timeStamp - this.trackingClickStart) &gt; this.tapTimeout) &#123; return true; &#125; // 得重置为false，避免input事件被意外取消 // 例子见 https://github.com/ftlabs/fastclick/issues/156 this.cancelNextClick = false; this.lastClickTime = event.timeStamp; //标记touchend时间，方便下一次的touchstart做双击校验 trackingClickStart = this.trackingClickStart; //重置 this.trackingClick 和 this.trackingClickStart this.trackingClick = false; this.trackingClickStart = 0; // iOS 6.0-7.*版本下有个问题 —— 如果layer处于transition或scroll过程，event所提供的target是不正确的 // 所以咱们得重找 targetElement（这里通过 document.elementFromPoint 接口来寻找） if(deviceIsIOSWithBadTarget) &#123; //iOS 6.0-7.*版本 touch = event.changedTouches[0]; //手指离开前的触点 // 有些情况下 elementFromPoint 里的参数是预期外/不可用的, 所以还得避免 targetElement 为 null targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement; // target可能不正确需要重找，但fastClickScrollParent是不会变的 targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent; &#125; targetTagName = targetElement.tagName.toLowerCase(); if(targetTagName === &apos;label&apos;) &#123; //是label则激活其指向的组件 forElement = this.findControl(targetElement); if(forElement) &#123; this.focus(targetElement); //安卓直接返回（无需合成click事件触发，因为点击和激活元素不同，不存在点透） if(deviceIsAndroid) &#123; return false; &#125; targetElement = forElement; &#125; &#125; else if(this.needsFocus(targetElement)) &#123; //非label则识别是否需要focus的元素 //手势停留在组件元素时长超过100ms，则置空this.targetElement并返回 //（而不是通过调用this.focus来触发其聚焦事件，走的原生的click/focus事件触发流程） //这也是为何文章开头提到的问题中，稍微久按一点（超过100ms）textarea是可以把光标定位在正确的地方的原因 //另外iOS下有个意料之外的bug——如果被点击的元素所在文档是在iframe中的，手动调用其focus的话， //会发现你往其中输入的text是看不到的（即使value做了更新），so这里也直接返回 if((event.timeStamp - trackingClickStart) &gt; 100 || (deviceIsIOS &amp;&amp; window.top !== window &amp;&amp; targetTagName === &apos;input&apos;)) &#123; this.targetElement = null; return false; &#125; this.focus(targetElement); this.sendClick(targetElement, event); //立即触发其click事件，而无须等待300ms //iOS4下的 select 元素不能禁用默认事件（要确保它能被穿透），否则不会打开select目录 //有时候 iOS6/7 下（VoiceOver开启的情况下）也会如此 if(!deviceIsIOS || targetTagName !== &apos;select&apos;) &#123; this.targetElement = null; event.preventDefault(); &#125; return false; &#125; if(deviceIsIOS &amp;&amp; !deviceIsIOS4) &#123; // 滚动容器的垂直滚动偏移改变了，说明是容器在做滚动而非点击，则忽略 scrollParent = targetElement.fastClickScrollParent; if(scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) &#123; return true; &#125; &#125; // 查看元素是否无需处理的白名单内（比如加了名为“needsclick”的class） // 不是白名单的则照旧预防穿透处理，立即触发合成的click事件 if(!this.needsClick(targetElement)) &#123; event.preventDefault(); this.sendClick(targetElement, event); &#125; return false; &#125;; FastClick.prototype.onTouchCancel = function() &#123; this.trackingClick = false; this.targetElement = null; &#125;; //用于决定是否允许穿透事件（触发layer的click默认事件） FastClick.prototype.onMouse = function(event) &#123; // touch事件一直没触发 if(!this.targetElement) &#123; return true; &#125; if(event.forwardedTouchEvent) &#123; //触发的click事件是合成的 return true; &#125; // 编程派生的事件所对应元素事件可以被允许 // 确保其没执行过 preventDefault 方法（event.cancelable 不为 true）即可 if(!event.cancelable) &#123; return true; &#125; // 需要做预防穿透处理的元素，或者做了快速（200ms）双击的情况 if(!this.needsClick(this.targetElement) || this.cancelNextClick) &#123; //停止当前默认事件和冒泡 if(event.stopImmediatePropagation) &#123; event.stopImmediatePropagation(); &#125; else &#123; // 不支持 stopImmediatePropagation 的设备(比如Android 2)做标记， // 确保该事件回调不会执行（见126行） event.propagationStopped = true; &#125; // 取消事件和冒泡 event.stopPropagation(); event.preventDefault(); return false; &#125; //允许穿透 return true; &#125;; //click事件常规都是touch事件衍生来的，也排在touch后面触发。 //对于那些我们在touch事件过程没有禁用掉默认事件的event来说，我们还需要在click的捕获阶段进一步 //做判断决定是否要禁掉点击事件（防穿透） FastClick.prototype.onClick = function(event) &#123; var permitted; // 如果还有 trackingClick 存在，可能是某些UI事件阻塞了touchEnd 的执行 if(this.trackingClick) &#123; this.targetElement = null; this.trackingClick = false; return true; &#125; // 依旧是对 iOS 怪异行为的处理 —— 如果用户点击了iOS模拟器里某个表单中的一个submit元素 // 或者点击了弹出来的键盘里的“Go”按钮，会触发一个“伪”click事件（target是一个submit-type的input元素） if(event.target.type === &apos;submit&apos; &amp;&amp; event.detail === 0) &#123; return true; &#125; permitted = this.onMouse(event); if(!permitted) &#123; //如果点击是被允许的，将this.targetElement置空可以确保onMouse事件里不会阻止默认事件 this.targetElement = null; &#125; //没有多大意义 return permitted; &#125;; //销毁Fastclick所注册的监听事件。是给外部实例去调用的 FastClick.prototype.destroy = function() &#123; var layer = this.layer; if(deviceIsAndroid) &#123; layer.removeEventListener(&apos;mouseover&apos;, this.onMouse, true); layer.removeEventListener(&apos;mousedown&apos;, this.onMouse, true); layer.removeEventListener(&apos;mouseup&apos;, this.onMouse, true); &#125; layer.removeEventListener(&apos;click&apos;, this.onClick, true); layer.removeEventListener(&apos;touchstart&apos;, this.onTouchStart, false); layer.removeEventListener(&apos;touchmove&apos;, this.onTouchMove, false); layer.removeEventListener(&apos;touchend&apos;, this.onTouchEnd, false); layer.removeEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false); &#125;; //是否没必要使用到 Fastclick 的检测 FastClick.notNeeded = function(layer) &#123; var metaViewport; var chromeVersion; var blackberryVersion; var firefoxVersion; // 不支持触摸的设备 if(typeof window.ontouchstart === &apos;undefined&apos;) &#123; return true; &#125; // 获取Chrome版本号，若非Chrome则返回0 chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1]; if(chromeVersion) &#123; if(deviceIsAndroid) &#123; //安卓 metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;); if(metaViewport) &#123; // 安卓下，带有 user-scalable=&quot;no&quot; 的 meta 标签的 chrome 是会自动禁用 300ms 延迟的，所以无需 Fastclick if(metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1) &#123; return true; &#125; // 安卓Chrome 32 及以上版本，若带有 width=device-width 的 meta 标签也是无需 FastClick 的 if(chromeVersion &gt; 31 &amp;&amp; document.documentElement.scrollWidth &lt;= window.outerWidth) &#123; return true; &#125; &#125; // 其它的就肯定是桌面级的 Chrome 了，更不需要 FastClick 啦 &#125; else &#123; return true; &#125; &#125; if(deviceIsBlackBerry10) &#123; //黑莓，和上面安卓同理，就不写注释了 blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/); if(blackberryVersion[1] &gt;= 10 &amp;&amp; blackberryVersion[2] &gt;= 3) &#123; metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;); if(metaViewport) &#123; if(metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1) &#123; return true; &#125; if(document.documentElement.scrollWidth &lt;= window.outerWidth) &#123; return true; &#125; &#125; &#125; &#125; // 带有 -ms-touch-action: none / manipulation 特性的 IE10 会禁用双击放大，也没有 300ms 时延 if(layer.style.msTouchAction === &apos;none&apos; || layer.style.touchAction === &apos;manipulation&apos;) &#123; return true; &#125; // Firefox检测，同上 firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1]; if(firefoxVersion &gt;= 27) &#123; metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;); if(metaViewport &amp;&amp; (metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1 || document.documentElement.scrollWidth &lt;= window.outerWidth)) &#123; return true; &#125; &#125; // IE11 推荐使用没有“-ms-”前缀的 touch-action 样式特性名 if(layer.style.touchAction === &apos;none&apos; || layer.style.touchAction === &apos;manipulation&apos;) &#123; return true; &#125; return false; &#125;; FastClick.attach = function(layer, options) &#123; return new FastClick(layer, options); &#125;; if(typeof define === &apos;function&apos; &amp;&amp; typeof define.amd === &apos;object&apos; &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define(function() &#123; return FastClick; &#125;); &#125; else if(typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123; module.exports = FastClick.attach; module.exports.FastClick = FastClick; &#125; else &#123; window.FastClick = FastClick; &#125;&#125;()); 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;title&gt;Demo&lt;/title&gt; &lt;script src=&quot;./fastclick.js&quot;&gt;&lt;/script&gt; &lt;style&gt; div &#123; width: 200px; background: red;Y margin: 0 auto; height: 200px; color: wheat; font-size: 25px; display: flex; justify-content: center; align-items: center; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;main&quot;&gt;FastClick&lt;/div&gt; &lt;script&gt; FastClick.attach(document.body); document.getElementById(&quot;main&quot;).addEventListener(&quot;click&quot;, function(event) &#123; console.log(event.target.innerText) &#125;, false) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>fastclick</tag>
      </tags>
  </entry>
</search>

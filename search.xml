<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Blob进行文件上传</title>
      <link href="/2018/12/15/Blob%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2018/12/15/Blob%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="BLOB-binary-large-object"><a href="#BLOB-binary-large-object" class="headerlink" title="BLOB (binary large object)"></a>BLOB (binary large object)</h2><blockquote><p>二进制大对象，是一个可以存储二进制文件的容器。</p></blockquote><p>Blob，Binary Large Object的缩写，二进制类型的大对象，代表不可改变的原始数据<br>在计算机中，BLOB常常是数据库中用来存储二进制文件的字段类型。</p><ul><li>Blob基本用法</li><li>Blob对象</li></ul><p>Blob对象指的是字节序列，并且具有size属性，是字节序列中的字节总数，和一个type属性，它是小写的ASCII编码的字符串表示的媒体类型字节序列。</p><ul><li>size:以字节数返回字节序列的大小。获取时，符合要求的用户代理必须返回一个FileReader或一个FileReaderSync对象可以读取的总字节数，如果Blob没有要读取的字节，则返回0 。</li><li>type:小写的ASCII编码字符串表示媒体类型Blob。在获取时，用户代理必须Blob以小写形式返回a类型的ASCII编码字符串，这样当它转换为字节序列时，它是可解析的MIME类型，或者是空字符串（0字节）如果是类型无法确定。<br>构造函数<br>创建blob对象本质上和创建一个其他对象的方式是一样的，都是使用Blob() 的构造函数来进行创建。 构造函数接受两个参数：</li></ul><p>第一个参数为一个数据序列，格式可以是ArrayBuffer, ArrayBufferView, Blob, DOMString<br>第二个参数是一个包含以下两个属性的对象</p><ul><li>type: MIME的类型,</li><li>endings: 决定第一个参数的数据格式。默认值为”transparent”，用于指定包含行结束符n的字符串如何被写入。 它是以下两个值中的一个： “native”，表示行结束符会被更改为适合宿主操作系统文件系统的换行符； “transparent”，表示会保持blob中保存的结束符不变。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data1 = <span class="string">"a"</span>;</span><br><span class="line"><span class="keyword">var</span> blob1 = <span class="keyword">new</span> Blob([data1]);</span><br><span class="line"><span class="built_in">console</span>.log(blob1); <span class="comment">//输出：Blob &#123;size: 1, type: ""&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> debug = &#123;<span class="attr">hello</span>: <span class="string">"world"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(debug, <span class="literal">null</span>, <span class="number">2</span>)],&#123;<span class="attr">type</span> : <span class="string">'application/json'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(blob) <span class="comment">// 输出 Blob(22) &#123;size: 22, type: "application/json"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个8字节的ArrayBuffer，在其上创建一个每个数组元素为2字节的“视图”</span></span><br><span class="line"><span class="keyword">var</span> abf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">var</span> abv = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(abf)</span><br><span class="line"><span class="keyword">var</span> bolb_ArrayBuffer = <span class="keyword">new</span> Blob(abv, &#123;<span class="attr">type</span> : <span class="string">'text/plain'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(bolb_ArrayBuffer) <span class="comment">//输出 Blob(4) &#123;size: 4, type: "text/plain"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//window.atob 对用base-64编码过的字符串进行解码 。你可以使用 window.btoa() 方法来编码一个可能在传输过程中出现问题的数据，并且在接受数据之后，使用 atob() 方法再将数据解码。</span></span><br><span class="line"><span class="keyword">let</span> encodedData = <span class="built_in">window</span>.btoa(<span class="string">"Hello, world"</span>); <span class="comment">// 编码 "SGVsbG8sIHdvcmxk"</span></span><br><span class="line"><span class="keyword">let</span> decodedData = <span class="built_in">window</span>.atob(encodedData); <span class="comment">// 解码 "Hello, world"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="string">"Hello World!"</span>],&#123;<span class="attr">type</span>:<span class="string">"text/plain"</span>&#125;);  <span class="comment">//Blob(12) &#123;size: 12, type: "text/plain"&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dataURL to blob</span></span><br><span class="line"><span class="comment"> * @param dataURI</span></span><br><span class="line"><span class="comment"> * @returns &#123;Blob&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span>(<span class="params">dataURI</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> byteString = atob(dataURI.split(<span class="string">','</span>)[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">var</span> mimeString = dataURI.split(<span class="string">','</span>)[<span class="number">0</span>].split(<span class="string">':'</span>)[<span class="number">1</span>].split(<span class="string">';'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(byteString.length);</span><br><span class="line">    <span class="keyword">var</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(ab);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; byteString.length; i++) &#123;</span><br><span class="line">        ia[i] = byteString.charCodeAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([ab], &#123;<span class="attr">type</span>: mimeString&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// atob() 将base64解码</span></span><br><span class="line"><span class="comment">// btoa() 将字符串转码为base64</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'javascript'</span>;</span><br><span class="line"><span class="built_in">window</span>.btoa(str)</span><br><span class="line"><span class="comment">//转码结果 "amF2YXNjcmlwdA=="</span></span><br><span class="line"><span class="built_in">window</span>.atob(<span class="string">"amF2YXNjcmlwdA=="</span>)</span><br><span class="line"><span class="comment">//解码结果 "javascript"</span></span><br></pre></td></tr></table></figure><h2 id="Blob-URL和Data-URL的区别"><a href="#Blob-URL和Data-URL的区别" class="headerlink" title="Blob URL和Data URL的区别"></a>Blob URL和Data URL的区别</h2><blockquote><p>Blob URL</p></blockquote><p><img src="/2018/12/15/Blob进行文件上传/2.png" alt=""></p><blockquote><p>Data URL</p></blockquote><p><img src="/2018/12/15/Blob进行文件上传/3.png" alt=""></p><p>Blob URL的长度一般比较短，但Data URL因为直接存储图片base64编码后的数据，往往很长，如上图所示，浏览器在显示Data URL时使用了省略号（…）。当显式大图片时，使用Blob URL能获取更好的可能性。<br>Blob URL可以方便的使用XMLHttpRequest获取源数据,比如设置XMLHttpRequest返回的数据类型为blob<br>Blob URL 只能在当前应用内部使用，把Blob URL复制到浏览器的地址栏中，是无法获取数据的。Data URL相比之下，就有很好的移植性，可以在任意浏览器中使用。</p><h2 id="Blob上传文件预览"><a href="#Blob上传文件预览" class="headerlink" title="Blob上传文件预览"></a>Blob上传文件预览</h2><p><img src="/2018/12/15/Blob进行文件上传/1.png" alt=""><br><img src="/2018/12/15/Blob进行文件上传/4.png" alt=""><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">body &#123;</span></span><br><span class="line"><span class="undefined">background:palegreen;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">div&#123;</span></span><br><span class="line"><span class="undefined">float: left;</span></span><br><span class="line"><span class="undefined">margin-left: 50px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>默认<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"sample1"</span> <span class="attr">img2blob</span>=<span class="string">"img/1.png"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>加水印<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"sample2"</span> <span class="attr">img2blob</span>=<span class="string">"img/2.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">img2blob</span>(<span class="params">imgUrl, obj = &#123;&#125;</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> b = &#123;</span></span><br><span class="line"><span class="javascript">watermark: <span class="string">''</span>,</span></span><br><span class="line"><span class="javascript">fontStyle: <span class="string">'Arial'</span>,</span></span><br><span class="line"><span class="javascript">fontSize: <span class="string">'30'</span>,</span></span><br><span class="line"><span class="javascript">fontColor: <span class="string">'black'</span>,</span></span><br><span class="line"><span class="undefined">fontX: 10,</span></span><br><span class="line"><span class="undefined">fontY: 50</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> d = imgUrl.getAttribute(<span class="string">'img2blob'</span>),</span></span><br><span class="line"><span class="javascript">a = <span class="built_in">Object</span>.assign(b, obj),</span></span><br><span class="line"><span class="javascript">f = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="undefined">f.src = d;</span></span><br><span class="line"><span class="javascript">f.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> g = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span></span><br><span class="line"><span class="undefined">g.width = f.naturalWidth;</span></span><br><span class="line"><span class="undefined">g.height = f.naturalHeight;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> h = g.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="undefined">h.drawImage(f, 0, 0);</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(a.watermark != <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">h.font = a.fontSize + <span class="string">'px '</span> + a.fontStyle;</span></span><br><span class="line"><span class="undefined">h.fillStyle = a.fontColor;</span></span><br><span class="line"><span class="undefined">h.fillText(a.watermark, a.fontX, a.fontY);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> j = g.toDataURL(<span class="string">'image/png'</span>),</span></span><br><span class="line"><span class="undefined">k = DataUriToBinary(j),</span></span><br><span class="line"><span class="javascript">l = <span class="keyword">new</span> Blob([k], &#123;</span></span><br><span class="line"><span class="javascript">type: <span class="string">'image/png'</span></span></span><br><span class="line"><span class="undefined">&#125;),</span></span><br><span class="line"><span class="javascript">m = <span class="built_in">window</span>.URL.createObjectURL(l);</span></span><br><span class="line"><span class="javascript">imgUrl.setAttribute(<span class="string">'src'</span>, m)</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(m)</span></span><br><span class="line"><span class="undefined">&#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">DataUriToBinary</span>(<span class="params">n</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> o = <span class="string">';base64,'</span>,</span></span><br><span class="line"><span class="undefined">p = n.indexOf(o) + o.length,</span></span><br><span class="line"><span class="undefined">q = n.substring(p),</span></span><br><span class="line"><span class="javascript">r = <span class="built_in">window</span>.atob(q),</span></span><br><span class="line"><span class="undefined">s = r.length,</span></span><br><span class="line"><span class="javascript">t = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(s));</span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span></span><br><span class="line"><span class="undefined">t[i] = r.charCodeAt(i);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> t;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">img2blob(<span class="built_in">document</span>.querySelector(<span class="string">".sample1"</span>))</span></span><br><span class="line"><span class="javascript">img2blob(<span class="built_in">document</span>.querySelector(<span class="string">".sample2"</span>), &#123;</span></span><br><span class="line"><span class="javascript">watermark: <span class="string">'@Blob测试'</span>,</span></span><br><span class="line"><span class="javascript">fontStyle: <span class="string">'Arial'</span>,</span></span><br><span class="line"><span class="javascript">fontSize: <span class="string">'30'</span>, <span class="comment">// px</span></span></span><br><span class="line"><span class="javascript">fontColor: <span class="string">'#ff0000'</span>, <span class="comment">// default 'black'</span></span></span><br><span class="line"><span class="javascript">fontX: <span class="number">30</span>, <span class="comment">// The x coordinate where to start painting the text</span></span></span><br><span class="line"><span class="javascript">fontY: <span class="number">50</span> <span class="comment">// The y coordinate where to start painting the text</span></span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="DataURI（base64）对象转blob对象（二进制）"><a href="#DataURI（base64）对象转blob对象（二进制）" class="headerlink" title="DataURI（base64）对象转blob对象（二进制）"></a>DataURI（base64）对象转blob对象（二进制）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 工具方法：dataURL(base64字符串)转换为Blob对象（二进制大对象） */</span></span><br><span class="line"><span class="comment">//data:image/png;base64,iVBORw0KGgoAAAANSUhEUg......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoBlob</span>(<span class="params">dataurl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = dataurl.split(<span class="string">','</span>);</span><br><span class="line">    <span class="keyword">var</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];<span class="comment">// 结果：   image/png</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"arr[0]===="</span> + <span class="built_in">JSON</span>.stringify(arr[<span class="number">0</span>]));<span class="comment">//   "data:image/png;base64"</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"arr[0].match(/:(.*?);/)===="</span> + arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>));<span class="comment">// :image/png;,image/png</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"arr[0].match(/:(.*?);/)[1]===="</span> + arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>]);<span class="comment">//   image/png</span></span><br><span class="line">    <span class="keyword">var</span> bstr = atob(arr[<span class="number">1</span>].replace(<span class="regexp">/\s/g</span>, <span class="string">''</span>));</span><br><span class="line">    <span class="keyword">var</span> n = bstr.length;</span><br><span class="line">    <span class="keyword">var</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123;<span class="attr">type</span>: mime&#125;);   <span class="comment">//值，类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DataUriToBinary</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> o = <span class="string">';base64,'</span>,</span><br><span class="line">p = n.indexOf(o) + o.length,</span><br><span class="line">q = n.substring(p),</span><br><span class="line">r = <span class="built_in">window</span>.atob(q),</span><br><span class="line">s = r.length,</span><br><span class="line">t = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(s));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s; i++) &#123;</span><br><span class="line">t[i] = r.charCodeAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>ES6模拟call,apply,bind</title>
      <link href="/2018/12/05/ES6%E6%A8%A1%E6%8B%9Fcall-apply-bind/"/>
      <url>/2018/12/05/ES6%E6%A8%A1%E6%8B%9Fcall-apply-bind/</url>
      
        <content type="html"><![CDATA[<h3 id="ES6自己实现"><a href="#ES6自己实现" class="headerlink" title="ES6自己实现"></a>ES6自己实现</h3><blockquote><p>call</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call2 = <span class="function"><span class="keyword">function</span>(<span class="params">context,...list</span>) </span>&#123;</span><br><span class="line">context = context || <span class="built_in">window</span>;</span><br><span class="line">context.fn = <span class="keyword">this</span>; </span><br><span class="line"><span class="keyword">let</span> result = context.fn(...list);</span><br><span class="line"><span class="keyword">delete</span> context.fn</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"JS"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">value: <span class="string">"Node"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">bar.call2(<span class="literal">null</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">bar.call2(<span class="literal">undefined</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure><blockquote><p>apply</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span>(<span class="params">context,arr</span>) </span>&#123;</span><br><span class="line">context = context || <span class="built_in">window</span>;</span><br><span class="line">context.fn = <span class="keyword">this</span>; </span><br><span class="line"><span class="keyword">let</span> result = context.fn(...arr);</span><br><span class="line"><span class="keyword">delete</span> context.fn</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"JS"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">value: <span class="string">"Node"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.apply2(foo,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line">bar.apply2(<span class="literal">null</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br><span class="line">bar.apply2(<span class="literal">undefined</span>,[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>bind1</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...arr1</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arr2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func.apply(context, [...arr1, ...arr2]);</span></span><br><span class="line"></span><br><span class="line">func.call(context, ...arr1, ...arr2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"JS"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">value: <span class="string">"Node"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.bind1(foo, <span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">bar.bind1(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>)(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">bar.bind1(<span class="literal">null</span>)(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">bar.bind1(<span class="literal">undefined</span>)(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><blockquote><p>bind2</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span>(<span class="params">context, ...arr1</span>) </span>&#123;</span><br><span class="line">context = context || <span class="built_in">window</span>;</span><br><span class="line">context.fn = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...arr2</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.fn(...arr1, ...arr2);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="string">"JS"</span>;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">value: <span class="string">"Node"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line"><span class="built_in">console</span>.log(list)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.bind2(foo, <span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">bar.bind2(<span class="literal">null</span>, <span class="number">5</span>, <span class="number">6</span>)(<span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">bar.bind2(<span class="literal">null</span>)(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">bar.bind2(<span class="literal">undefined</span>)(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><h3 id="有什么问题？"><a href="#有什么问题？" class="headerlink" title="有什么问题？"></a>有什么问题？</h3><p>前面我们用的 eval 方式可以用 ES6 的解决还存在的一些问题，有没有注意到，这段代码是有问题的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.fn = this;</span><br></pre></td></tr></table></figure></p><p><strong> 假如对象在被 call 调用前，已经有 fn 属性怎么办？ </strong></p><p>ES6 中提供了一种新的基本数据类型，Symbol，表示独一无二的值，另外，Symbol 作为属性的时候，不能使用点运算符。所以再加上 ES 的 rest 剩余参数替代 arguments 遍历的工作就有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newCall = <span class="function"><span class="keyword">function</span> (<span class="params">context,...params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">'object'</span>) &#123;</span><br><span class="line">        context = context || <span class="built_in">window</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn] = thisvar result = context[fn](...params);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"jayChou"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">functionsay(age, sex) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>,age: <span class="subst">$&#123;age&#125;</span>, sex: <span class="subst">$&#123;sex&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> age + sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> check = say.newCall(person, <span class="number">18</span>, <span class="string">'男'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(check); <span class="comment">// 18男</span></span><br></pre></td></tr></table></figure><p>apply 和 call 的实现原理，基本类似，区别在于 apply 的参数是以数组的形式传入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.newApply = <span class="function"><span class="keyword">function</span>(<span class="params">context, parameter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> context === <span class="string">'object'</span>) &#123;</span><br><span class="line">    context = context || <span class="built_in">window</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">Symbol</span>()</span><br><span class="line">  context[fn] = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> result = context[fn](...parameter);</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> call </tag>
            
            <tag> apply </tag>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS尾递归</title>
      <link href="/2018/12/01/JS%E5%B0%BE%E9%80%92%E5%BD%92/"/>
      <url>/2018/12/01/JS%E5%B0%BE%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h3 id="源于前端群里面的一道社招笔试题"><a href="#源于前端群里面的一道社招笔试题" class="headerlink" title="源于前端群里面的一道社招笔试题"></a>源于前端群里面的一道社招笔试题</h3><blockquote><p>实现一个斐波拉契数列， 已知第一项为0，第二项为1，第三项为1，后一项是前两项之和,如下，即<code>f(n) = f(n - 1) + f(n -2)</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, ...</span><br></pre></td></tr></table></figure><p>拿到这个题目，二话没想就写了,扔到群里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(n) &#123;</span><br><span class="line">    if(n === 0) return0;</span><br><span class="line">    if(n === 1) return1;</span><br><span class="line">    return f(n - 1) + f(n -2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>群里有大神提醒这个题放到社招题里面明显没这么简单，每次递归调用都会呈指数往调用栈里增加记录<code>调用帧</code>，这样做，当项比较多，就会出现<code>栈溢出</code>的！！！</p><p>也就是，以上Code只能说刚刚及格，正确姿势应该用<strong>尾递归优化</strong>，<code>调用帧</code>保持只有一个。</p><blockquote><p>正解就是：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(n, prev, next) &#123;</span><br><span class="line">    if(n &lt;= 1) &#123;</span><br><span class="line">        return next;</span><br><span class="line">    &#125;</span><br><span class="line">    return f(n - 1, next, prev + next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来复习一下知识点：尾调用和尾递归。</p><h3 id="尾调优化"><a href="#尾调优化" class="headerlink" title="尾调优化"></a>尾调优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 尾递归方式</span><br><span class="line">function factorial1(n,total) &#123;</span><br><span class="line">    if (n === 1) &#123;</span><br><span class="line">        return total;</span><br><span class="line">    &#125;</span><br><span class="line">    return factorial1(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 普通递归方式</span><br><span class="line">function factorial2(n) &#123;</span><br><span class="line">    if (n === 1) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n * factorial2(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(factorial1(25,1)); // 1.5511210043330984e+25 </span><br><span class="line">console.log(factorial2(25)); // 1.5511210043330986e+25</span><br></pre></td></tr></table></figure><p>在知道尾递归之前，我们要直到什么是尾调用优化，因为尾调用优化是尾递归的基础。<br><strong>尾调用就是：在函数的最后一步调用另一个函数。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return g()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>最后一步必须是调用另一函数，而不能是一个常量或是一个表达式，如 <code>return y</code>或 <code>return g() + 1</code></strong></p></blockquote><h4 id="尾调用优化的原理是什么？"><a href="#尾调用优化的原理是什么？" class="headerlink" title="尾调用优化的原理是什么？"></a>尾调用优化的原理是什么？</h4><p>按照<a href="http://es6.ruanyifeng.com/#docs/function#%E5%B0%BE%E8%B0%83%E7%94%A8%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">阮一峰老师在es6的函数扩展</a>中的解释就是：</p><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p><span style="border-bottom:2px solid red;">我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</span></p><p><font color="#dd0000"><strong> 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</strong></font><br> </p><p>这里的“调用帧”和“调用栈”，说的应该就是“执行环境”和“作用域链”。因为尾调用时函数的最后一部操作，所以不再需要保留外层的调用帧，而是直接取代外层的调用帧，所以可以起到一个优化的作用。</p><h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p>尾调用是指某个函数的最后一步是调用另一个函数。  </p><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p><p>以下三种情况都不是尾调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 情况一</span><br><span class="line">function f(x) &#123;</span><br><span class="line">    let y = g(x);</span><br><span class="line">    return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况二</span><br><span class="line">function f(x) &#123;</span><br><span class="line">    return g(x) + 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 情况三</span><br><span class="line">function f(x) &#123;</span><br><span class="line">    g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>情况一是调用函数<code>g</code>之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也是属于调用后还有操作。情况三等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g(x);</span><br><span class="line">return undefined;</span><br></pre></td></tr></table></figure></p><p>函数调用会在内存形成一个“调用记录”，又称“调用帧”，保存调用位置和内存变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，依次类推。所有的调用帧，就形成一个“调用栈”。</p><p>尾调用由于是函数的最后一步操作，所有不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">    let m = 1;</span><br><span class="line">    let n = 2;</span><br><span class="line">    return g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function f() &#123;</span><br><span class="line">    return g(3);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">g(3);</span><br></pre></td></tr></table></figure></p><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p><p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p><p>如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”。</p><p><strong>注意</strong>:只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function addOne(a) &#123;</span><br><span class="line">    var one = 1;</span><br><span class="line">    function inner(b) &#123;</span><br><span class="line">        return b + one;</span><br><span class="line">    &#125;</span><br><span class="line">    return inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><tr><td bgcolor="#C0FF3E"><font color="#dd0000"> 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。这一是闭包常驻内存的原因！！！</font></td></tr></table><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p><span style="border-bottom:2px solid red;">函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</span></p><p><span style="border-bottom:2px solid red;">递归非常耗费内存，因为需要同时保存成百上千调用帧，很容易发生“栈溢出”错误。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</span><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n) &#123;</span><br><span class="line">    if (n === 1) return1;</span><br><span class="line">    return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line">console.log(factorial(5)); // 120</span><br></pre></td></tr></table></figure></p><p>上面最多保存<code>n</code>个调用记录，复杂度是<code>O(n)</code>。</p><p>如果改成尾递归，只保留一个调用记录，复杂度<code>O(1)</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n, total) &#123;</span><br><span class="line">    if (n === 0) return total;</span><br><span class="line">    return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">console.log(factorial(5, 1)); // 120</span><br></pre></td></tr></table></figure></p><p>下面回到我们的主题，计算Fibonacci数列。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    if(n &lt;= 1) return 1;</span><br><span class="line">    return fibonacci(n -1) + fibonacci(n -2);</span><br><span class="line">&#125;</span><br><span class="line">console.log(fibonacci(10)); // 89</span><br><span class="line">console.log(fibonacci(50)); // stack overflow</span><br></pre></td></tr></table></figure></p><p>上面不使用尾递归，项数稍大点就发生”栈溢出“了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(n, prev, next) &#123;</span><br><span class="line">    if(n &lt;= 1) return next;</span><br><span class="line">    return fibonacci(n-1, next, prev + next);</span><br><span class="line">&#125;</span><br><span class="line">console.log(fibonacci(10, 1, 1)); // 89</span><br><span class="line">console.log(fibonacci(100, 1, 1)); // 573147844013817200000</span><br><span class="line">console.log(fibonacci(1000, 1, 1)); // 7.0330367711422765e+208</span><br></pre></td></tr></table></figure></p><p>上面项数再大都状态良好。</p><h3 id="柯理化改写"><a href="#柯理化改写" class="headerlink" title="柯理化改写"></a>柯理化改写</h3><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。但是这样的话就会增加初始入参，比如<code>fibonacci(10, 1, 1)</code>，后面的两个参数<code>1</code>和<code>1</code>意思不明确，直接用<code>fibonacci(100)</code>才是习惯用法。所以需要在中间预先设置好初始入参，将多个入参转化成单个入参的形式，叫做函数柯理化。通用方式为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function curry(fn) &#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var innerArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">        var finalArgs = innerArgs.concat(args);</span><br><span class="line">        return fn.apply(null, finalArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用函数柯理化改写阶乘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function tailFactorial(n, total) &#123;</span><br><span class="line">    if(n === 1) return total;</span><br><span class="line">    return tailFactorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var factorial = curry(tailFactorial, 1); </span><br><span class="line">console.log(factorial(5)); // 120</span><br></pre></td></tr></table></figure></p><p>同样改写斐波拉契数列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function tailFibonacci(n, prev, next) &#123;</span><br><span class="line">    if(n &lt;= 1) return next;</span><br><span class="line">    return tailFibonacci(n - 1, next, prev + next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fibonacci = curry(fibonacci, 1, 1);</span><br><span class="line">console.log(fibonacci(10)); // 89</span><br><span class="line">console.log(fibonacci(100)); // 573147844013817200000</span><br><span class="line">console.log(fibonacci(1000)); // 7.0330367711422765e+208</span><br></pre></td></tr></table></figure></p><h3 id="ES6改写"><a href="#ES6改写" class="headerlink" title="ES6改写"></a>ES6改写</h3><p>柯理化的过程其实是初始化一些参数的过程，在ES6中，是可以直接函数参数默认赋值的。</p><p>用ES6改写阶乘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const factorial = (n, total = 1) =&gt; &#123;</span><br><span class="line">    if(n === 1) return total;</span><br><span class="line">    return factorial(n - 1, n * total);</span><br><span class="line">&#125;</span><br><span class="line">console.log(factorial(5)); // 120</span><br></pre></td></tr></table></figure></p><p>用ES6改写斐波拉契数列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const fibonacci = (n, prev = 1, next = 1) =&gt; &#123;</span><br><span class="line">    if(n &lt;= 1) return next;</span><br><span class="line">    return fibonacci(n - 1, next, prev + next);</span><br><span class="line">&#125;</span><br><span class="line">console.log(fibonacci(10)); // 89</span><br><span class="line">console.log(fibonacci(100)); // 573147844013817200000 </span><br><span class="line">console.log(fibonacci(1000)); // 7.0330367711422765e+208</span><br></pre></td></tr></table></figure></p><p>用ES6极大方便了算法运用！</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p><p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p><ul><li>func.arguments：返回调用时函数的参数。</li><li>func.caller：返回调用当前函数的那个函数。</li></ul><p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function restricted() &#123;</span><br><span class="line">  &apos;use strict&apos;;</span><br><span class="line">  restricted.caller;    // 报错</span><br><span class="line">  restricted.arguments; // 报错</span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>综上，这个问题解决的思路是：</p><ol><li>尾递归+函数柯理化；</li><li>尾递归+ES6默认赋值；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 尾递归 </tag>
            
            <tag> 尾调用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>new原理及模拟实现</title>
      <link href="/2018/11/30/new%E5%8E%9F%E7%90%86%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/30/new%E5%8E%9F%E7%90%86%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">new 运算符</a>创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。</p></blockquote><p>举个栗子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.start = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color + <span class="string">" car start"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="string">"black"</span>);</span><br><span class="line">car.color; <span class="comment">// 访问构造函数里的属性</span></span><br><span class="line"><span class="comment">// black</span></span><br><span class="line"></span><br><span class="line">car.start(); <span class="comment">// 访问原型里的属性</span></span><br><span class="line"><span class="comment">// black car start</span></span><br></pre></td></tr></table></figure></p><p>可以看出 new 创建的实例有以下 2 个特性</p><ul><li><p>访问到构造函数里的属性</p></li><li><p>访问到原型里的属性</p></li></ul><p>注意点</p><blockquote><p>ES6新增 symbol 类型，不可以使用 new Symbol()，因为 symbol 是基本数据类型，每个从Symbol()返回的 symbol 值都是唯一的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">"123"</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">123</span>); <span class="comment">// "123"</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">123</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="number">123</span>); <span class="comment">// Symbol(123)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="string">"123"</span>); <span class="comment">// Number &#123;123&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">123</span>); <span class="comment">// String &#123;"123"&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>(<span class="number">123</span>); <span class="comment">// Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><blockquote><p>new操作符的工作原理</p></blockquote><ul><li>一个新对象被创建，它继承自func.prototype。</li><li>构造函数func 被执行，执行的时候，相应的参数会被传入，同时上下文（this） 会被指定为这个新实例。</li><li>如果构造函数返回了一个新对象，那么这个对象会取代整个new出来的结果，如果构造函数没有返回对象，<br>那么new出来的结果为步骤1创建的对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">废话不多说，直接上代码</span><br><span class="line"><span class="keyword">var</span> newObj = <span class="function"><span class="keyword">function</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> t = &#123;&#125;</span><br><span class="line">    t.prototype = func.prototype</span><br><span class="line">    <span class="keyword">var</span> o = t</span><br><span class="line">    <span class="keyword">var</span> k =func.call(o);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> k === <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> k;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parent1 = newObj(Parent) <span class="comment">//等价于new操作</span></span><br></pre></td></tr></table></figure><p>DEMO:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new2 new关键字的代码实现演示</span></span><br><span class="line"><span class="comment"> * @param &#123;function&#125; func 被new的类 (构造函数)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建了一个实例对象 o，并且这个对象__proto__指向func这个类的原型对象 </span></span><br><span class="line">    <span class="keyword">let</span> o = <span class="built_in">Object</span>.create(func.prototype); </span><br><span class="line">    <span class="comment">// (在构造函数中this指向当前实例)让这个类作为普通函数值行 并且里面this为实例对象 </span></span><br><span class="line">    <span class="keyword">let</span> k = func.call(o);</span><br><span class="line">    <span class="comment">// 最后再将实例对象返回 如果你在类中显示指定返回值k，</span></span><br><span class="line">    <span class="comment">// 注意如果返回的是引用类型则将默认返回的实例对象o替代掉</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> k === <span class="string">'object'</span> ? k : o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实验</span></span><br><span class="line">functionM() &#123; <span class="comment">// 即将被new的类</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'liwenli'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> m = new2(M); <span class="comment">// 等价于 new M 这里只是模拟</span></span><br><span class="line"><span class="built_in">console</span>.log(m <span class="keyword">instanceof</span> M); <span class="comment">// instanceof 检测实例</span></span><br><span class="line"><span class="built_in">console</span>.log(m <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.__proto__.constructor === M);</span><br></pre></td></tr></table></figure></p><blockquote><p>Object.create 兼容实现</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">id</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>._create = <span class="function">(<span class="params">o</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> Fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 临时的构造函数</span></span><br><span class="line">    Fn.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>._create(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2.__proto__ === obj1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.id); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生的Object.create</span></span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj3.__proto__ === obj1); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj3.id); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>完整代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params">MyFun, ...list</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> o = <span class="built_in">Object</span>.create(MyFun.prototype);</span><br><span class="line"><span class="keyword">let</span> k = MyFun.call(o, ...list);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> k === <span class="string">'object'</span> ? k : o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color, name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"new car"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.fun=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.color,<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=new2(Car,<span class="number">123</span>,<span class="string">'小花'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__===Car.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(Car.prototype.isPrototypeOf(obj))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(obj))</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Car)</span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor===Car)</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/30/new原理及模拟实现/1.webp" alt=""></p><blockquote><p><strong>有什么问题？</strong></p></blockquote><ul><li><code>typeof k === &#39;object&#39;</code> 如果k为null怎么办？</li><li>MyFun传null，undefined怎么办？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new2</span>(<span class="params">MyFun, ...list</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!MyFun)  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"第一个参数必须是函数"</span>);</span><br><span class="line"><span class="keyword">let</span> o = <span class="built_in">Object</span>.create(MyFun.prototype);</span><br><span class="line"><span class="keyword">let</span> k = MyFun.call(o, ...list);</span><br><span class="line"><span class="keyword">return</span> k&amp;&amp;(<span class="keyword">typeof</span> k === <span class="string">'object'</span>) ? k : o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">color, name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.fun=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.color,<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=new2(Car,<span class="number">123</span>,<span class="string">'小花'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__===Car.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(Car.prototype.isPrototypeOf(obj))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.isPrototypeOf(obj))</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> Car)</span><br><span class="line"><span class="built_in">console</span>.log(obj.constructor===Car);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=new2(<span class="literal">null</span>,<span class="number">123</span>,<span class="string">'小花'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分查找,二分边界查找算法，indexOf方法模拟</title>
      <link href="/2018/11/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BA%8C%E5%88%86%E8%BE%B9%E7%95%8C%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2018/11/24/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E4%BA%8C%E5%88%86%E8%BE%B9%E7%95%8C%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>二分查找作为程序员的一项基本技能，是面试官最常使用来考察程序员基本素质的算法之一，也是解决很多查找类题目的常用方法，它可以达到 <font color="#ff0000"><strong> O(log n) </strong></font>的时间复杂度。  </p><p>一般而言，当一个题目出现以下特性时，你就应该立即联想到它可能需要使用二分查找：</p><ol><li>待查找的数组有序或者部分有序</li><li>要求时间复杂度低于O(n)，或者直接要求时间复杂度为O(log n)</li></ol><p>二分查找有很多种变体，使用时需要注意查找条件，判断条件和左右边界的更新方式，三者配合不好就很容易出现死循环或者遗漏区域，本篇中我们将介绍常见的几种查找方式的模板代码，包括：</p><ol><li>标准的二分查找</li><li>二分查找左边界</li><li>二分查找右边界</li></ol><p>本文的内容来自于笔者个人的总结，事实上二分查找有很多种等价的写法，本文只是列出了笔者认为的最容易理解和记忆的方法。</p><h2 id="标准二分查找"><a href="#标准二分查找" class="headerlink" title="标准二分查找"></a>标准二分查找</h2><p>首先给出标准二分查找的模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function search(arr, target) &#123;</span><br><span class="line">var left = 0;</span><br><span class="line">var right = arr.length - 1;</span><br><span class="line">while(left &lt;= right) &#123;</span><br><span class="line">var mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">if(arr[mid] == target) &#123;</span><br><span class="line">return mid;</span><br><span class="line">&#125; else if(arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">left = mid + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var index=search([1, 2, 3, 4, 5,6], 5);</span><br><span class="line">console.log(index)</span><br></pre></td></tr></table></figure></p><ul><li>循环条件： <code>left &lt;= right</code></li><li>中间位置计算： <code>mid = left + ((right -left) &gt;&gt; 1)</code></li><li>左边界更新：<code>left = mid + 1</code></li><li>右边界更新： <code>right = mid - 1</code></li><li>返回值： <code>mid / -1</code></li></ul><p>这里有几点需要注意：</p><ol><li>我们的循环条件中包含了 <code>left == right</code>的情况，则我们必须在每次循环中改变 <code>left</code> 和 <code>right</code>的指向，以防止进入死循环</li><li><p>循环终止的条件包括：</p><ul><li>找到了目标值</li><li><code>left &gt; right</code> （这种情况发生于当left, mid, right指向同一个数时，这个数还不是目标值，则整个查找结束。）</li></ul></li></ol><p>3.<code>left + ((right -left) &gt;&gt; 1)</code> 其实和 <code>(left + right) / 2</code>是等价的，这样写的目的一个是为了防止 <code>(left + right)</code>出现溢出，一个是用右移操作替代除法提升性能。<br>4.<code>left + ((right -left) &gt;&gt; 1)</code> 对于目标区域长度为奇数而言，是处于正中间的，对于长度为偶数而言，是中间偏左的。因此左右边界相遇时，只会是以下两种情况：</p><ul><li><code>left/mid</code> , <code>right</code> (left, mid 指向同一个数，right指向它的下一个数)</li><li><code>left/mid/right</code> （left, mid, right 指向同一个数）   </li></ul><p>即因为<code>mid</code>对于长度为偶数的区间总是偏左的，所以当区间长度小于等于2时，<code>mid</code> 总是和 <code>left</code>在同一侧。</p><h2 id="二分查找左边界"><a href="#二分查找左边界" class="headerlink" title="二分查找左边界"></a>二分查找左边界</h2><p>既然要寻找左边界，搜索范围就需要从右边开始，不断往左边收缩，也就是说即使我们找到了<code>nums[mid] == target</code>, 这个<code>mid</code>的位置也不一定就是最左侧的那个边界，我们还是要向左侧查找，所以我们在<code>nums[mid]</code>偏大或<code>者nums[mid]</code>就等于目标值的时候，继续收缩右边界，算法模板如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function search(arr, target) &#123;</span><br><span class="line">var left = 0;</span><br><span class="line">var right = arr.length - 1;</span><br><span class="line">while(left &lt; right) &#123;</span><br><span class="line">var mid = left + ((right - left) &gt;&gt; 1);</span><br><span class="line">if(arr[mid] &lt; target) &#123;</span><br><span class="line">left = mid + 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(left,right,mid)</span><br><span class="line">return arr[left] == target ? left : -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var index = search([1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 6], 5);</span><br><span class="line">console.log(index)</span><br></pre></td></tr></table></figure><ul><li>循环条件： <code>left &lt; right</code></li><li>中间位置计算： <code>mid = left + ((right -left) &gt;&gt; 1)</code></li><li>左边界更新：<code>left = mid + 1</code></li><li>右边界更新： <code>right = mid</code></li><li>返回值： <code>nums[left] == target ? left : -1</code></li></ul><p>与标准的二分查找不同：</p><p>首先，这里的右边界的更新是<code>right = mid</code>，因为我们需要在找到目标值后，继续向左寻找左边界。</p><p>其次，这里的循环条件是<code>left &lt; right</code>。<br>因为在最后<code>left</code>与<code>right</code>相邻的时候，<code>mid</code>和<code>left</code>处于相同的位置(前面说过，<code>mid</code>偏左)，则下一步，无论怎样，<code>left</code>, <code>mid</code>, <code>right</code>都将指向同一个位置，如果此时循环的条件是<code>left &lt;= right</code>，则我们需要再进入一遍循环，此时，如果<code>nums[mid] &lt; target</code>还好说，循环正常终止；否则，我们会令<code>right = mid</code>，这样并没有改变<code>left</code>,<code>mid</code>,<code>right</code>的位置，将进入死循环。</p><p>事实上，我们只需要遍历到<code>left</code>和<code>right</code>相邻的情况就行了，因为这一轮循环后，无论怎样，<code>left</code>,<code>mid</code>,<code>right</code>都会指向同一个位置，而如果这个位置的值等于目标值，则它就一定是最左侧的目标值；如果不等于目标值，则说明没有找到目标值，这也就是为什么返回值是<code>nums[left] == target ? left : -1</code>。</p><h2 id="二分查找右边界"><a href="#二分查找右边界" class="headerlink" title="二分查找右边界"></a>二分查找右边界</h2><p>有了寻找左边界的分析之后，再来看寻找右边界就容易很多了，毕竟左右两种情况是对称的嘛，关于使用场景这里就不再赘述了，大家对称着理解就好。我们直接给出模板代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function search(arr, target) &#123;</span><br><span class="line">var left = 0;</span><br><span class="line">var right = arr.length - 1;</span><br><span class="line">while(left &lt; right) &#123;</span><br><span class="line">var mid = left + ((right - left) &gt;&gt; 1) + 1;</span><br><span class="line">if(arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - 1;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">left = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(left, right, mid)</span><br><span class="line">return arr[right] == target ? right : -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var index = search([1, 2, 3, 4, 5, 5, 5, 5, 5, 5, 6], 5);</span><br><span class="line">console.log(index)</span><br></pre></td></tr></table></figure><ul><li>循环条件： <code>left &lt; right</code></li><li>中间位置计算： <code>mid = left + ((right -left) &gt;&gt; 1) + 1</code></li><li>左边界更新：<code>left = mid</code></li><li>右边界更新： <code>right = mid - 1</code></li><li>返回值： <code>nums[left] == target ? left : -1</code></li></ul><p>这里大部分和寻找左边界是对称着来写的，唯独有一点需要尤其注意——中间位置的计算变了，我们在末尾多加了1。这样，<strong>无论对于奇数还是偶数，这个中间的位置都是偏右的。</strong></p><p>对于这个操作的理解，从对称的角度看，寻找左边界的时候，中间位置是偏左的，那寻找右边界的时候，中间位置就应该偏右呗，但是这显然不是根本原因。根本原因是，在最后<code>left</code>和<code>right</code>相邻时，如果<code>mid</code>偏左，则<code>left</code>, <code>mid</code>指向同一个位置，<code>right</code>指向它们的下一个位置，在<code>nums[left]</code>已经等于目标值的情况下，这三个位置的值都不会更新，从而进入了死循环。所以我们应该让<code>mid</code>偏右，这样<code>left</code>就能向右移动。这也就是为什么我们之前一直强调查找条件，判断条件和左右边界的更新方式三者之间需要配合使用。</p><p>右边界的查找一般来说不会单独使用，如有需要，一般是需要同时查找左右边界。</p><h2 id="二分查找左右边界"><a href="#二分查找左右边界" class="headerlink" title="二分查找左右边界"></a>二分查找左右边界</h2><p>前面我们介绍了左边界和右边界的查找，那么查找左右边界就容易很多了——只要分别查找左边界和右边界就行了。</p><h2 id="二分查找极值"><a href="#二分查找极值" class="headerlink" title="二分查找极值"></a>二分查找极值</h2><p>二分查找还有一种有趣的变体是二分查找极值点，之前我们使用<code>nums[mid]</code>去比较的时候，常常是和给定的目标值<code>target</code>比，或者和左右边界比较，在二分查找极值点的应用中，我们是和相邻元素去比，以完成某种单调性的检测。</p><h2 id="二分查找、二分边界查找算法的模板代码总结"><a href="#二分查找、二分边界查找算法的模板代码总结" class="headerlink" title="二分查找、二分边界查找算法的模板代码总结"></a><a href="https://segmentfault.com/a/1190000016825704" target="_blank" rel="noopener">二分查找、二分边界查找算法的模板代码总结</a></h2><h2 id="idnexOf模拟"><a href="#idnexOf模拟" class="headerlink" title="idnexOf模拟"></a>idnexOf模拟</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a=&apos;abcdefghijkl&apos;</span><br><span class="line">var b=&apos;ghi&apos;</span><br><span class="line">var aL=a.length;</span><br><span class="line">var bL=b.length;</span><br><span class="line"></span><br><span class="line">function indexOf(str,item)&#123;</span><br><span class="line">for(var i=0;i&lt;=aL-bL;i++)&#123;</span><br><span class="line">if(str.slice(i,bL+i)==item)&#123;</span><br><span class="line">return i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(indexOf(a,b))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;abcdefghijkl&apos;</span><br><span class="line">var b = &apos;ghi&apos;</span><br><span class="line"></span><br><span class="line">function indexOf(s,sub) &#123;</span><br><span class="line">var sIndex=0,subIndex=0,sLength=s.length,subLength=sub.length;</span><br><span class="line">while(sIndex &lt; sLength &amp;&amp; subIndex &lt; subLength) &#123;</span><br><span class="line">if(s[sIndex] == sub[subIndex]) &#123;</span><br><span class="line">subIndex++;</span><br><span class="line">sIndex++;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">sIndex = sIndex - subIndex + 1;</span><br><span class="line">subIndex = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var index = subIndex == subLength ? (subLength &gt; 1 ? sIndex - subLength : sIndex - 1) : -1;</span><br><span class="line">return index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(indexOf(a,b))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function idnexOf(a,b)&#123;</span><br><span class="line">var reg=new RegExp(`$&#123;b&#125;`,&apos;gi&apos;);</span><br><span class="line">var c=reg.exec(a);</span><br><span class="line">console.log(c ? c.index : -1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = &apos;abcdefghijkl&apos;</span><br><span class="line">var b = &apos;jkl&apos;</span><br><span class="line">idnexOf(a,b)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP缓存机制(200还是304)</title>
      <link href="/2018/11/22/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-200%E8%BF%98%E6%98%AF304/"/>
      <url>/2018/11/22/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6-200%E8%BF%98%E6%98%AF304/</url>
      
        <content type="html"><![CDATA[<h2 id="f5到底刷新了点什么，你知道吗"><a href="#f5到底刷新了点什么，你知道吗" class="headerlink" title="f5到底刷新了点什么，你知道吗"></a><a href="https://juejin.im/post/5bfcd79e6fb9a04a08215cf3" target="_blank" rel="noopener">f5到底刷新了点什么，你知道吗</a></h2><h2 id="缓存从入门到放弃"><a href="#缓存从入门到放弃" class="headerlink" title="缓存从入门到放弃"></a><a href="https://juejin.im/post/5bfe879a51882531b81b0891" target="_blank" rel="noopener">缓存从入门到放弃</a></h2><p><img src="/2018/11/22/HTTP缓存机制-200还是304/0.webp" alt=""><br>当浏览器第一次加载资源的时候，返回一般为200，意思是成功获取资源，并会在浏览器的缓存中记录下max-age，第二次访问的时候： 如果只是用浏览器打开，那么浏览器会去判断这个资源在缓存里有没有，如果有的话，会去判断max-age，看看过期没有，如果没有过期，则直接读缓存，根本不会和服务器进行交互，换句话说，断网都能打开，就和本地跑一样！如果已经过期了，那就去服务器请求，等待服务器响应，这是很费时间的，服务器如果发现资源没有改变过，那么就会返回304，告诉浏览器，我没变过，你去读缓存吧，于是浏览器也不用从服务器拉数据了，然而，等待服务器响应也是一个很要命的问题，在网速发达的今天，等一个响应，有时比下载还慢。 如果是用浏览器刷新的，那么浏览器不会去判断max-age了，直接去服务器拿，如果服务器判断资源没变过，则还是会返回304，和上面是一样的，所以刷新一下，其实很可怕，等于把所有的资源都要去服务器请求一边，问问服务器我过期了没有。</p><p>浏览器在第一次请求资源的时候，服务端响应头里可以设置expires字段，该字段表示该资源的缓存过期时间，第二次请求的时候，如果时间还在该缓存时间之内，则会直接使用缓存，否则重新加载资源，<strong> 这个expires字段有个缺陷，就是它必须服务端和客户端的时间严格同步才能生效，所以现在很多人不会使用改方案。</strong> 另外一种方案是第一次请求资源的时候，服务端设置响应头cache-control: max-age，这样设置的意思是告诉浏览器，这个资源什么时候过期，等第二次请求资源的时候，判断是否超出了过期时间，如果没超出，直接使用缓存。</p><h2 id="记一次前端面试的全过程"><a href="#记一次前端面试的全过程" class="headerlink" title="记一次前端面试的全过程"></a><a href="https://juejin.im/post/5bf8fe2ee51d452d705fee3d" target="_blank" rel="noopener">记一次前端面试的全过程</a></h2><h2 id="缓存状态码-200-OK-from-cache-与-304-Not-Modified"><a href="#缓存状态码-200-OK-from-cache-与-304-Not-Modified" class="headerlink" title="缓存状态码 200 OK (from cache) 与   304 Not Modified"></a>缓存状态码 200 OK (from cache) 与   304 Not Modified</h2><blockquote><p>200 OK (from cache)  是浏览器没有跟服务器确认，直接用了浏览器缓存；</p></blockquote><blockquote><p>304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。</p></blockquote><blockquote><p>304 Not Modified：客户端有缓冲的文件并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。</p></blockquote><blockquote><p>304 Not Modified 比 200 OK (from cache) 慢，指的是浏览器还向服务器确认了下 “If-Not-Modified”，才用的缓存</p></blockquote><h2 id="参考http-200、301、304等状态码详解"><a href="#参考http-200、301、304等状态码详解" class="headerlink" title="参考http 200、301、304等状态码详解"></a>参考<a href="https://www.jb51.net/article/119562.htm" target="_blank" rel="noopener">http 200、301、304等状态码详解</a></h2><h2 id="200和304特点"><a href="#200和304特点" class="headerlink" title="200和304特点"></a>200和304特点</h2><blockquote><p>状态码200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数据为全量的数据，如果文件不通过GZIP压缩的话，文件是多大，则要有多大传输量。</p></blockquote><blockquote><p>状态码304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有修改过，则不需要返回全量的数据。</p></blockquote><font color="#dd0000"> <strong> 状态为304的请求要比状态为200的请求的数据量小很多，因为304只需要返回响应头，并不需要返回整个文件，所以只需要几字节就可以了，这样能够节省大量的网络带宽，并减少了页面的渲染时间。 </strong> </font><h2 id="缓存HTTP头信息"><a href="#缓存HTTP头信息" class="headerlink" title="缓存HTTP头信息"></a>缓存HTTP头信息</h2><p>Date：原服务器发送该资源响应报文的时间（GMT格式）</p><p>Age：Age表示这个响应已经存活了多久了(HTTP/1.0的响应不带Age)</p><p>Expires：即在 HTTP 头中指明具体失效的时间(HTTP/1.0)，Expires = HTTP-date</p><p>Pragma：no-cache，每次请求页面时都不要读缓存，兼容HTTP/1.0，优先级高于Expires(HTTP/1.0 + HTTP/1.1)</p><p>Cache Control：优先级高于Pragma、Expires(HTTP/1.1)  <font color="#ff0000"><strong> 【public，客户端和服务端都可以缓存；private，只能客户端缓存；no-store，不使用缓存；no-cache，使用协商缓存。】 </strong></font></p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><ul><li>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回。</li><li>Expires第二次请求时，将和本地时间比对。</li></ul><blockquote><p>Expires 第一次请求服务器是，响应头会返回一个Expires的文件过期时间。<br>Expires 第二次请求，客户端使用本地时间和文件的过期时间进行比对，如果文件未过期则直接使用本地缓存，返回状态码200(from memory cache)或200(from disk cache)。</p></blockquote><h3 id="Expires-Cache-Control"><a href="#Expires-Cache-Control" class="headerlink" title="Expires Cache-Control"></a>Expires Cache-Control</h3><ul><li>Cache-Control: no-cache    必须先与代理服务器确认是否更改，然后在在决定使用缓存还是请求，类似于协商缓存（304）</li><li>Cache-Control: no-store 才是真正的不缓存数据到本地</li><li>Cache-Control: public 可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器</li><li>Cache-Control: private 只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存</li><li>Cache-Control: must-revalidate如果缓存内容失效，请求必须发送服务器进行验证</li><li>Cache-Control: max-age=s    缓存内容在s秒后失效，仅HTTP1.1可用</li></ul><blockquote><p>max-gae 第一次请求服务器时，响应头会返回一个 max-age，是文件多少时间后过期。<br>max-gae 第二次请求，客户端会校验文件是否过期，如果文件未过期则直接使用本地缓存，返回状态码200(from memory cache)或200(from disk cache)。 </p></blockquote><hr><p>本地缓存，是指在客户端本地机器中的缓存。</p><p>共享缓存，处于客户端和服务器之间的缓存，例如：CDN。</p><p>请求 Cache Control</p><table><thead><tr><th>–</th><th style="text-align:left">–</th></tr></thead><tbody><tr><td>max-age</td><td style="text-align:left">可以接收缓存最长时间</td></tr><tr><td>max-stale</td><td style="text-align:left">可以接收过期的资源，但是过期时间必须小于 max-stale 值</td></tr><tr><td>min-fresh</td><td style="text-align:left">可以接收一个更新过的资源，fresh生命期大于其当前 Age 跟 min-fresh 值之和</td></tr><tr><td>no-cache</td><td style="text-align:left">在源服务器返回成功的验证之前不能使用缓存响应</td></tr><tr><td>no-store</td><td style="text-align:left">直接禁止浏览器和所有中继缓存存储返回的任何版本的响应</td></tr><tr><td>no-transform</td><td style="text-align:left">获取没有被转换过（比如压缩）的资源</td></tr><tr><td>only-if-cached</td><td style="text-align:left">希望获取缓存内容而不发起请求</td></tr></tbody></table><p>响应 Cache Control</p><table><thead><tr><th>–</th><th style="text-align:left">–</th></tr></thead><tbody><tr><td>no-cache</td><td style="text-align:left">缓存必须重新校验</td></tr><tr><td>no-store</td><td style="text-align:left">不存储缓存</td></tr><tr><td>no-transform</td><td style="text-align:left">缓存内容时不能对改变任何数据</td></tr><tr><td>public</td><td style="text-align:left">响应可被任何缓存区缓存</td></tr><tr><td>private</td><td style="text-align:left">只在本地缓存，不允许任何中继缓存对其进行缓存（例如，浏览器可以缓存，但是CDN不能缓存）</td></tr><tr><td>must-revalidate</td><td style="text-align:left">如果缓存的内容失效，请求必须发送到服务器以进行重新验证（请求失败返回504，而非中间缓存CDN）</td></tr><tr><td>proxy-revalidate</td><td style="text-align:left">与must-revalidate类似，仅能用于共享缓存（如：CDN）</td></tr><tr><td>max-age</td><td style="text-align:left">只接受 Age 值小于 max-age 值，并且没有过期的资源</td></tr><tr><td>s-maxage</td><td style="text-align:left">仅能用于共享缓存，一般用在cache服务器上(如：CDN)</td></tr></tbody></table><p>Cache Control Extensions</p><p>通过使用1个或多个cache-extension tokens扩展（可选）字段，服务器不识别则忽略掉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:private, community=&quot;UCI&quot;</span><br></pre></td></tr></table></figure></p><p>Cache-Control 允许自由组合可选值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=3600, must-revalidate</span><br></pre></td></tr></table></figure></p><p>Last-Modified/If-Modified-Since：文件最后一次修改的时间（精度是秒，HTTP/1.0），需要Cache-Contral过期</p><p>Etag：当前资源在服务器的唯一标识（生成规则由服务器决定）ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的，优先级高于Last-Modified；在分布式的Web系统中，当访问落在不同的物理机上时会返回不同的ETag，进而导致304失效，降级为200请求（HTTP/1.1），需要Cache-Contral过期</p><p>如果 Last-Modified 和 ETag 同时被使用，则要求它们的验证都必须通过才会返回304，否则返回200。</p><h2 id="Meta标签"><a href="#Meta标签" class="headerlink" title="Meta标签"></a>Meta标签</h2><p>meta是用来在HTML文档中模拟HTTP协议的响应头报文。在HTML页面加上meta标签来给请求报头加上请求字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Expires&quot;content=&quot;0&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Pragma&quot;content=&quot;no-cache&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Cache-Control&quot;content=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>Pragma的meta标签只有IE能识别</p><p><a href="https://support.microsoft.com/zh-cn/help/222064/-pragma-no-cache-tag-may-not-prevent-page-from-being-cached" target="_blank" rel="noopener">“Pragma:No-cache”标记可能无法防止页面被缓存</a></p><blockquote><p><strong>优先级：Cache-Control &gt; Pragma &gt; Expires </strong></p></blockquote><p>清除浏览器中的缓存，必须从服务端获取最新内容，但不是所有浏览器都支持</p><h2 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h2><blockquote><p>Freshness</p></blockquote><p>和浏览器策略以及Cache Control（HTTP/1.1）与Expires(HTTP/1.0)有关</p><p>最好的请求是不必与服务器进行通信的请求：通过响应的本地缓存，可以避免所有的网络延迟以及数据传输的数据成本。</p><p>服务器给响应设置显示过期时间（explicit expiration time），当请求资源时，只需要检测资源的过期状态，判断是否使用缓存。</p><p>服务器不提供一个显示过期时间，HTTP缓存通常会设置一个启发式过期时间（heuristic expiration time），采用算法通过其他值（例如Last-Modified）估计一个合理的时间。</p><p>如何判断响应是否新的？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response_is_fresh =(freshness_lifetime &gt; current_age)</span><br></pre></td></tr></table></figure></p><p>freshness_lifetime计算，同时存在多个，按优先级获取</p><ul><li><p>如果是共享缓存，使用s-maxage</p></li><li><p>如果有max-age字段，使用max-age</p></li><li><p>如果有Expires字段，使用Expires超过Date的时间数</p></li><li><p>如果没有显示过期时间设置，使用浏览器的启发式过期时间（heuristic expiration time）</p></li></ul><p>current_age计算</p><ul><li><p>age_value Age字段的值</p></li><li><p>date_value Date字段的值</p></li><li><p>now 当前时间</p></li><li><p>request_time 请求时间</p></li><li><p>response_time 响应时间</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apparent_age = max(0, response_time - date_value);</span><br><span class="line">response_delay = response_time - request_time;</span><br><span class="line">corrected_age_value = age_value + response_delay;</span><br><span class="line">corrected_initial_age = max(apparent_age, corrected_age_value);</span><br><span class="line">resident_time = now - response_time;</span><br><span class="line">current_age = corrected_initial_age + resident_time;</span><br></pre></td></tr></table></figure><p>缓存策略</p><p><img src="/2018/11/22/HTTP缓存机制-200还是304/1.png" alt=""></p><p>HTML5 Boilerplate 项目<a href="https://github.com/h5bp/server-configs-nginx" target="_blank" rel="noopener">nginx配置文件样例</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># cache.appcache, your document html and data</span><br><span class="line">location ~* \.(?:manifest|appcache|html?|xml|json)$ &#123;</span><br><span class="line">  expires -1;</span><br><span class="line">&#125;</span><br><span class="line"># Feed</span><br><span class="line">location ~* \.(?:rss|atom)$ &#123;</span><br><span class="line">  expires 1h;</span><br><span class="line">&#125;</span><br><span class="line"># Media: images, icons, video, audio, HTC</span><br><span class="line">location ~* \.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|mp4|ogg|ogv|webm|htc)$ &#123;</span><br><span class="line">  expires 1M;</span><br><span class="line">  access_log off;</span><br><span class="line">  add_header Cache-Control &quot;public&quot;;</span><br><span class="line">&#125;</span><br><span class="line"># CSS and Javascript</span><br><span class="line">location ~* \.(?:css|js)$ &#123;</span><br><span class="line">  expires 1y;</span><br><span class="line">  access_log off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Validation</p></blockquote><p>检查一个缓存的响应是否仍然可用 <code>Last-Modified和ETag（entity-tag）</code><br>通过验证令牌可以进行高效的资源更新检查：如果资源未更改，则不会传输任何数据<br><img src="/2018/11/22/HTTP缓存机制-200还是304/2.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status Code:304 Not Modified</span><br><span class="line">Response Head</span><br><span class="line">ETag:&quot;578ba64c-7ddf&quot;</span><br><span class="line">Last-Modified:Sun, 17 Jul 2016 15:37:48 GMT</span><br><span class="line">Request Head</span><br><span class="line">If-Modified-Since:Sun, 17 Jul 2016 15:37:48 GMT</span><br><span class="line">If-None-Match:&quot;578ba64c-7ddf&quot;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/22/HTTP缓存机制-200还是304/3.png" alt=""></p><blockquote><p>Invalidation</p></blockquote><p>类似PUT、POST 和 DELETE的”非安全”请求可能会改变原服务端状态，在此期间缓存会让它们的内容过期失效。</p><p>当一个非安全的请求收到非错误的返回状态码（2xx或者3xx），缓存必须使请求URI的包括其他相关URI(s)的Location和Content-Location响应头字段失效。</p><p>为了防止服务器攻击拒绝，一个基于Location或Content-Location头域里的URI的无效性处理必须只有在host部分和请求URI里的host部分相同时才被执行。</p><p>注：只读请求（GET/HEAD）认为是“安全”的，详细可查看<a href="http://httpwg.org/specs/rfc7231.html#safe.methods" target="_blank" rel="noopener">safe.methods</a>。</p><h2 id="200-or-304"><a href="#200-or-304" class="headerlink" title="200 or 304"></a>200 or 304</h2><p>在没有设置Cache-Contral的情况下，设置Last-Modified和ETag缓存，会出现时而200（from cache），时而304 出现的情况。</p><p>chrome 测试 刷新 和 输入URL回车 测试并不会影响200（from cache）和304 的出现。</p><p>可能的情况，是在服务器没有设置显示缓存时间的情况下，freshness_lifetime是浏览器按某种算法计算出来，这个时间并不长，所以会出现这种情况。</p><p>设置Cache-Contral max-age的情况下，max-age过期后首次刷新会出现304(如果有更新内容，则是200)，之后在max-age缓存过期之前刷新都是200（from cache）。</p><h2 id="缓存方案"><a href="#缓存方案" class="headerlink" title="缓存方案"></a>缓存方案</h2><p>较长的过期时间，节省带宽，提高性能；更改资源的网址，强制用户下载新响应</p><p><img src="/2018/11/22/HTTP缓存机制-200还是304/4.png" alt=""></p><p>按需更新，精确的缓存控制</p><p>静态资源CDN部署</p><p>更资源发布路径实现非覆盖式发布（多版本共存）</p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue3 Proxy观察者机制探索</title>
      <link href="/2018/11/21/Vue-Proxy%E8%A7%82%E5%AF%9F%E8%80%85%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%B4%A2/"/>
      <url>/2018/11/21/Vue-Proxy%E8%A7%82%E5%AF%9F%E8%80%85%E6%9C%BA%E5%88%B6%E6%8E%A2%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/11/21/Vue-Proxy观察者机制探索/1.png" alt=""></p><h3 id="为什么Proxy可以优化vue的数据监听机制"><a href="#为什么Proxy可以优化vue的数据监听机制" class="headerlink" title="为什么Proxy可以优化vue的数据监听机制?"></a>为什么Proxy可以优化vue的数据监听机制?</h3><h4 id="vue2-x中的实现"><a href="#vue2-x中的实现" class="headerlink" title="vue2.x中的实现"></a>vue2.x中的实现</h4><p>其本质是<code>new Watcher(data, key, callback)</code>的方式，而在调用之前是先将data中的所有属性转化成可监听的对象, 其主要就是利用<code>Object.defineProperty</code>，。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Watcher&#123;</span><br><span class="line">    constructor(data, key, cb)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//转换成可监听对象functionobserve(data)&#123;</span><br><span class="line">    new Observer(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//修改数据的getter和setterfunctiondefineReactive(obj, key)&#123;</span><br><span class="line">    let value = obj[key];</span><br><span class="line">    Object.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get()&#123;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newVal)&#123;</span><br><span class="line">            value = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Observer的实现很简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Observer&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.walk(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    walk(data)&#123;</span><br><span class="line">        for(var key in data) &#123;</span><br><span class="line">            // 这里不考虑嵌套的问题，否则的话需要递归调用walk</span><br><span class="line">            defineReactive(data, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在怎么将watcher和getter/setter联系起来，vue的方法是添加一个依赖类：Dep<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Watcher&#123;</span><br><span class="line">    constructor(data, key, cb)&#123;</span><br><span class="line">        this.cb = cb;</span><br><span class="line">        Dep.target = this; //每次新建watcher的时候讲给target赋值，对target的管理这里简化了vue的实现</span><br><span class="line">        data[key];//调用getter，执行addSub, 将target传入对应的dep; vue的实现本质就是如此</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Dep&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.subs = [];</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub)&#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123;</span><br><span class="line">        this.subs.forEach(sub =&gt; sub.cb())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function defineReactive(obj, key)&#123;</span><br><span class="line">    let value = obj[key];</span><br><span class="line">    let dep = new Dep(); //每一个属性都有一个对应的dep，作为闭包保存Object.defineProperty(obj, key, &#123;</span><br><span class="line">        enumerable: true,</span><br><span class="line">        configurable: true,</span><br><span class="line">        get()&#123;</span><br><span class="line">            dep.addSub(Dep.target)</span><br><span class="line">            Dep.target = null;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;,</span><br><span class="line">        set(newVal)&#123;</span><br><span class="line">            value = newVal</span><br><span class="line">            dep.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是vue的思路，vue3之所以要从新实现，主要有这几个原因：</p><ul><li><ol><li><code>Object.defineProperty</code>的性能开销。</li></ol></li><li><ol start="2"><li><code>defineReactive</code>一开始就要对要监听的对象所有属性都执行一遍，因为传统方法要将一个对象转换成可监听对象，只能如此。</li></ol></li><li><ol start="3"><li>添加删除属性的问题。</li></ol></li><li><ol start="4"><li>还有一点就是这个模块被耦合到了vue里面，新版本可以单独作为一个库来使用。</li></ol></li></ul><p>然后我们来看看同样的功能采用Proxy会怎样实现。</p><h4 id="Proxy的实现"><a href="#Proxy的实现" class="headerlink" title="Proxy的实现"></a>Proxy的实现</h4><p>将一个对象转换成Proxy的方式很简单，只需要作为参数传给proxy即可；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Watcher&#123;</span><br><span class="line">    constructor(proxy, key, cb) &#123;</span><br><span class="line">        this.cb = cb;</span><br><span class="line">        Dep.target = this;</span><br><span class="line">        this.value = proxy[key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dep&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub)&#123;</span><br><span class="line">        this.subs.push(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    notify(newVal)&#123;</span><br><span class="line">        this.subs.forEach(sub =&gt; &#123;</span><br><span class="line">            sub.cb(newVal, sub.value);</span><br><span class="line">            sub.value = newVal;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const observe = (obj) =&gt; &#123;</span><br><span class="line">    const deps = &#123;&#125;;</span><br><span class="line">    returnnewProxy(obj, &#123;</span><br><span class="line">        get: function (target, key, receiver) &#123;</span><br><span class="line">            const dep = (deps[key] = deps[key] || new Dep);</span><br><span class="line">            Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">            Dep.target = null;</span><br><span class="line">            returnReflect.get(target, key, receiver);</span><br><span class="line">        &#125;,</span><br><span class="line">        set: function (target, key, value, receiver) &#123;</span><br><span class="line">            const dep = (deps[key] = deps[key] || new Dep);</span><br><span class="line">            Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">                dep.notify(value);</span><br><span class="line">            &#125;)</span><br><span class="line">            returnReflect.set(target, key, value, receiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var state = observe(&#123;x:0&#125;)</span><br><span class="line">new Watcher(state, &apos;x&apos;, function(n, o)&#123;</span><br><span class="line">    console.log(n, o)</span><br><span class="line">&#125;);</span><br><span class="line">new Watcher(state, &apos;y&apos;, function(n, o)&#123;</span><br><span class="line">    console.log(n, o)</span><br><span class="line">&#125;);</span><br><span class="line">state.x = 3;</span><br><span class="line">state.y = 3;</span><br></pre></td></tr></table></figure><p>也许一开始我们只关心<code>x</code>和<code>y</code>，那么就不会对其他的属性做相应的处理，除非添加watcher，其他时间target都是null</p><hr><p>Vue 3 以下方面值得我们期待 ：</p><ul><li>更快</li><li>更小</li><li>更易于维护</li><li>更多的原生支持</li><li>更易于开发使用</li></ul><p>学不动的同学还可以缓缓 ^_^</p><h3 id="为什么要取代Object-defineProperty"><a href="#为什么要取代Object-defineProperty" class="headerlink" title="为什么要取代Object.defineProperty"></a>为什么要取代Object.defineProperty</h3><p>既然要取代Object.defineProperty，那它肯定是有一些明显的缺点，总结起来大概是下面两个：</p><blockquote><p>Object.defineProperty无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过vue内部处理后可以使用以下几种方法来监听数组</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line">shift()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure><p>由于只针对了以上八种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。</p><blockquote><p>Object.defineProperty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x里，是通过 递归 + 遍历 data 对象来实现对数据的监控的，如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。</p></blockquote><p>而要取代它的Proxy有以下两个优点;</p><ul><li>可以劫持整个对象，并返回一个新对象</li><li>有13种劫持操作</li></ul><p>看到这可能有同学要问了，既然Proxy能解决以上两个问题，而且Proxy作为es6的新属性在vue2.x之前就有了，为什么vue2.x不使用Proxy呢？一个很重要的原因就是：</p><blockquote><p>Proxy是es6提供的新特性，兼容性不好，最主要的是这个属性无法用polyfill来兼容</p></blockquote><p>关于Object.defineProperty来实现观察者机制，可以参照<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000006599500" target="_blank" rel="noopener">剖析Vue原理&amp;实现双向绑定MVVM</a>这篇文章，下面的内容主要介绍如何基于 Proxy来实现vue观察者机制。</p><h3 id="什么是Proxy-ECMAScript-6-入门"><a href="#什么是Proxy-ECMAScript-6-入门" class="headerlink" title="什么是Proxy , ECMAScript 6 入门"></a>什么是Proxy , <a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">ECMAScript 6 入门</a></h3><p>1.含义：</p><ul><li>Proxy是 ES6 中新增的一个特性，翻译过来意思是”代理”，用在这里表示由它来“代理”某些操作。</li><li>Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</li><li>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</li><li>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</li></ul><p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p><p>2.基本用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let p = new Proxy(target, handler);</span><br></pre></td></tr></table></figure></p><p>参数：</p><ul><li><code>target</code> 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li><li><code>handler</code> 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数。</li><li><code>p</code> 是代理后的对象。当外界每次对 p 进行操作时，就会执行 handler 对象上的一些方法。Proxy共有13种劫持操作，handler代理的一些常用的方法有如下几个：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get：读取</span><br><span class="line">set：修改</span><br><span class="line">has：判断对象是否有该属性</span><br><span class="line">construct：构造函数</span><br></pre></td></tr></table></figure><p>3.示例：</p><p>下面就用Proxy来定义一个对象的get和set，作为一个基础demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line"> let handler = &#123;</span><br><span class="line">   get(target, property) &#123;</span><br><span class="line">    console.log(`$&#123;property&#125; 被读取`);</span><br><span class="line">    return property in target ? target[property] : 3;</span><br><span class="line">   &#125;,</span><br><span class="line">   set(target, property, value) &#123;</span><br><span class="line">    console.log(`$&#123;property&#125; 被设置为 $&#123;value&#125;`);</span><br><span class="line">    target[property] = value;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> let p = new Proxy(obj, handler);</span><br><span class="line"> p.name = &apos;tom&apos; //name 被设置为 tom</span><br><span class="line"> p.age; //age 被读取 3</span><br></pre></td></tr></table></figure></p><ul><li>p 读取属性的值时，实际上执行的是 handler.get() ：在控制台输出信息，并且读取被代理对象 obj 的属性。</li><li>p 设置属性值时，实际上执行的是 handler.set() ：在控制台输出信息，并且设置被代理对象 obj 的属性的值。</li></ul><p>以上介绍了Proxy基本用法，实际上这个属性还有许多内容，具体可参考<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FProxy" target="_blank" rel="noopener">Proxy文档</a></p><h3 id="基于Proxy来实现双向绑定"><a href="#基于Proxy来实现双向绑定" class="headerlink" title="基于Proxy来实现双向绑定"></a>基于Proxy来实现双向绑定</h3><p>话不多说，接下来我们就来用Proxy来实现一个经典的双向绑定todolist，首先简单的写一点html结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; id=&quot;input&quot; /&gt;</span><br><span class="line">     &lt;div&gt;您输入的是： &lt;span id=&quot;title&quot;&gt;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">     &lt;button type=&quot;button&quot; name=&quot;button&quot; id=&quot;btn&quot;&gt;添加到todolist&lt;/button&gt;</span><br><span class="line">     &lt;ul id=&quot;list&quot;&gt;&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>先来一个Proxy，实现输入框的双向绑定显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;&#125;;</span><br><span class="line">const input = document.getElementById(&quot;input&quot;);</span><br><span class="line">const title = document.getElementById(&quot;title&quot;);</span><br><span class="line"></span><br><span class="line">const newObj = new Proxy(obj, &#123;</span><br><span class="line">  get: function(target, key, receiver) &#123;</span><br><span class="line">    console.log(`getting $&#123;key&#125;!`);</span><br><span class="line">    return Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(target, key, value, receiver) &#123;</span><br><span class="line">    console.log(target, key, value, receiver);</span><br><span class="line">    if (key === &quot;text&quot;) &#123;</span><br><span class="line">      input.value = value;</span><br><span class="line">      title.innerHTML = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">input.addEventListener(&quot;keyup&quot;, function(e) &#123;</span><br><span class="line">  newObj.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里代码涉及到<code>Reflect</code>属性，这也是一个es6的新特性，还不太了解的同学可以参考<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FReflect" target="_blank" rel="noopener">Reflect文档</a>.<br>接下来就是添加todolist列表，先把数组渲染到页面上去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> // 渲染todolist列表</span><br><span class="line">const Render = &#123;</span><br><span class="line">  // 初始化</span><br><span class="line">  init: function(arr) &#123;</span><br><span class="line">    const fragment = document.createDocumentFragment();</span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      const li = document.createElement(&quot;li&quot;);</span><br><span class="line">      li.textContent = arr[i];</span><br><span class="line">      fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    list.appendChild(fragment);</span><br><span class="line">  &#125;,</span><br><span class="line">  addList: function(val) &#123;</span><br><span class="line">    const li = document.createElement(&quot;li&quot;);</span><br><span class="line">    li.textContent = val;</span><br><span class="line">    list.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>再来一个Proxy，实现Todolist的添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const arr = [];</span><br><span class="line">// 监听数组</span><br><span class="line">const newArr = new Proxy(arr, &#123;</span><br><span class="line">  get: function(target, key, receiver) &#123;</span><br><span class="line">    return Reflect.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function(target, key, value, receiver) &#123;</span><br><span class="line">    console.log(target, key, value, receiver);</span><br><span class="line">    if (key !== &quot;length&quot;) &#123;</span><br><span class="line">      Render.addList(value);</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">// 初始化</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">  Render.init(arr);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">btn.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">  newArr.push(parseInt(newObj.text));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这样就用 Proxy实现了一个简单的双向绑定Todolist,具体代码可参考<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnightzing%2Fvue3-Proxy%2Fblob%2Fmaster%2Fproxy.html" target="_blank" rel="noopener">proxy.html</a></p><h3 id="基于Proxy来实现vue的观察者机制"><a href="#基于Proxy来实现vue的观察者机制" class="headerlink" title="基于Proxy来实现vue的观察者机制"></a>基于Proxy来实现vue的观察者机制</h3><p>1.Proxy实现observe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">observe(data) &#123;</span><br><span class="line">    const that = this;</span><br><span class="line">    let handler = &#123;</span><br><span class="line">     get(target, property) &#123;</span><br><span class="line">        return target[property];</span><br><span class="line">      &#125;,</span><br><span class="line">      set(target, key, value) &#123;</span><br><span class="line">        let res = Reflect.set(target, key, value);</span><br><span class="line">        that.subscribe[key].map(item =&gt; &#123;</span><br><span class="line">          item.update();</span><br><span class="line">        &#125;);</span><br><span class="line">        return res;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.$data = new Proxy(data, handler);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这段代码里把代理器返回的对象代理到<code>this.$data</code>，即<code>this.$data</code>是代理后的对象，外部每次对<code>this.$data</code>进行操作时，实际上执行的是这段代码里handler对象上的方法。</p><p>2.compile和watcher</p><ul><li>比较熟悉vue的同学都很清楚，vue2.x在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」。类似于下面这个内部流程图：<br><img src="/2018/11/21/Vue-Proxy观察者机制探索/2.png" alt=""></li><li>而我们上面已经用Proxy取代了Object.defineProperty这部分观察者机制，而要实现整个基本mvvm双向绑定流程，除了observe还需要compile和watche等一系列机制，我们这里像模板编译的工作就不展开描述了，为了实现基于Proxy的vue添加Totolist,这里只写了</li><li>compile和watcher来支持observe的工作，具体代码参考<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnightzing%2Fvue3-Proxy%2Fblob%2Fmaster%2FproxyVue.html" target="_blank" rel="noopener">proxyVue</a>,这个代码相当于一个基于Proxy的一个简化版vue，主要是实现双向绑定这个功能，为了方便这里把js放到了html页面中，大家本地运行后可以发现，现在的效果和第三章的效果达到一致了，等到明年vue3发布，它源码里基于 Proxy实现的的观察者机制可能和这里的实现会有很多不同，这篇文章主要是对 Proxy这个特性做了一些介绍以及它的一些应用，而作者本人也通过对Proxy 的观察者机制探索学到了不少东西，所以整合资源，总结出了这篇文章，希望能和大家共勉之，以上，我们下次有缘再见。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Proxy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React Hooks</title>
      <link href="/2018/11/06/React-Hooks/"/>
      <url>/2018/11/06/React-Hooks/</url>
      
        <content type="html"><![CDATA[<p>一句话总结 React Hooks 就是在 react 函数组件中，也可以使用类组件（classes components）的 state 和 组件生命周期，而不需要在 mixin、 函数组件、HOC组件和 render props 之间来回切换，使得函数组件的功能更加实在，更加方便我们在业务中实现业务逻辑代码的分离和组件的复用。</p><p>React 一直在解决一个问题，如何实现分离业务逻辑代码，实现组件内部相关业务逻辑的复用。<br>一般情况下，我们都是通过组件和自上而下传递的数据流将我们页面上的大型UI组织成为独立的小型UI，实现组件的重用。但是我们经常遇到很难侵入一个复杂的组件中实现重用，因为组件的逻辑是有状态的，无法提取到函数组件当中。这在处理动画和表单的时候，尤其常见，当我们在组件中连接外部的数据源，然后希望在组件中执行更多其他的操作的时候，我们就会把组件搞得特别糟糕：</p><ul><li>难以重用和共享组件中的与状态相关的逻辑，造成产生很多巨大的组件</li><li>逻辑复杂的组件难以开发与维护，当我们的组件需要处理多个互不相关的 localstate 时，每个生命周期函数中可能会包含着各种互不相关的逻辑在里面。</li><li>复杂的模式，如渲染道具和高阶组件。</li><li>由于业务变动，函数组件不得不改为类组件。</li></ul><p>这时候，Hooks就派上用场了。 Hooks 允许我们将组件内部的逻辑，组织成为一个可复用的隔离模块。</p><h4 id="粗暴点总结React-Hooks-就是在函数组件-HOC组件和静态组件找到一种平衡的组件实现方式"><a href="#粗暴点总结React-Hooks-就是在函数组件-HOC组件和静态组件找到一种平衡的组件实现方式" class="headerlink" title=" 粗暴点总结React Hooks:就是在函数组件,HOC组件和静态组件找到一种平衡的组件实现方式 "></a><font color="#ff0000"><strong> 粗暴点总结React Hooks:就是在函数组件,HOC组件和静态组件找到一种平衡的组件实现方式 </strong></font></h4><h2 id="一个最简单的Hooks"><a href="#一个最简单的Hooks" class="headerlink" title="一个最简单的Hooks"></a>一个最简单的Hooks</h2><p>首先让我们看一下一个简单的有状态组件：</p><pre><code>class Example extends React.Component {  constructor(props) {    super(props);    this.state = {      count: 0    };  }  render() {    return (      &lt;div&gt;        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;          Click me        &lt;/button&gt;      &lt;/div&gt;    );  }}</code></pre><p>我们再来看一下使用hooks后的版本：</p><pre><code>import { useState } from &apos;react&apos;;function Example() {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );}</code></pre><p>是不是简单多了！可以看到，<code>Example</code>变成了一个函数，但这个函数却有自己的状态（count），同时它还可以更新自己的状态（setCount）。这个函数之所以这么了不得，就是因为它注入了一个hook–<code>useState</code>，就是这个hook让我们的函数变成了一个有状态的函数。</p><p>除了<code>useState</code>这个hook外，还有很多别的hook，比如<code>useEffect</code>提供了类似于<code>componentDidMount</code>等生命周期钩子的功能，<code>useContext</code>提供了上下文（context）的功能等等。</p><p>Hooks本质上就是一类特殊的函数，它们可以为你的函数型组件（function component）注入一些特殊的功能。咦？这听起来有点像被诟病的Mixins啊？难道是Mixins要在react中死灰复燃了吗？当然不会了，等会我们再来谈两者的区别。总而言之，这些hooks的目标就是让你不再写class，让function一统江湖。</p><h2 id="React为什么要搞一个Hooks？"><a href="#React为什么要搞一个Hooks？" class="headerlink" title="React为什么要搞一个Hooks？"></a>React为什么要搞一个Hooks？</h2><h3 id="想要复用一个有状态的组件太麻烦了！"><a href="#想要复用一个有状态的组件太麻烦了！" class="headerlink" title="想要复用一个有状态的组件太麻烦了！"></a>想要复用一个有状态的组件太麻烦了！</h3><p>我们都知道react都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用react，你会发现你的项目中实际上很多react组件冗长且难以复用。尤其是那些写成class的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。</p><p>那之前，官方推荐怎么解决这个问题呢？答案是：<font color="#ff0000">渲染属性（Render Props）</font>和 <font color="#ff0000">高阶组件（Higher-Order Components）</font> 。我们可以稍微跑下题简单看一下这两种模式。</p><p>渲染属性指的是使用一个值为函数的prop来传递需要动态渲染的nodes或组件。如下面的代码可以看到我们的<code>DataProvider</code>组件包含了所有跟状态相关的代码，而<code>Cat</code>组件则可以是一个单纯的展示型组件，这样一来<code>DataProvider</code>就可以单独复用了。</p><pre><code>import Cat from &apos;components/cat&apos;class DataProvider extends React.Component {  constructor(props) {    super(props);    this.state = { target: &apos;Zac&apos; };  }  render() {    return (      &lt;div&gt;        {this.props.render(this.state)}      &lt;/div&gt;    )  }}&lt;DataProvider render={data =&gt; (  &lt;Cat target={data.target} /&gt;)}/&gt;</code></pre><p>虽然这个模式叫Render Props，但不是说非用一个叫render的props不可，习惯上大家更常写成下面这种：</p><pre><code>...&lt;DataProvider&gt;  {data =&gt; (    &lt;Cat target={data.target} /&gt;  )}&lt;/DataProvider&gt;</code></pre><p>高阶组件这个概念就更好理解了，说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，<code>withUser</code>函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。</p><pre><code>const withUser = WrappedComponent =&gt; {  const user = sessionStorage.getItem(&quot;user&quot;);  return props =&gt; &lt;WrappedComponent user={user} {...props} /&gt;;};const UserPage = props =&gt; (  &lt;div class=&quot;user-container&quot;&gt;    &lt;p&gt;My name is {props.user}!&lt;/p&gt;  &lt;/div&gt;);export default withUser(UserPage);</code></pre><p>以上这两种模式看上去都挺不错的，很多库也运用了这种模式，比如我们常用的React Router。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开devtool看看你的组件层级嵌套是不是很夸张吧。这时候再回过头看我们上一节给出的hooks例子，是不是简洁多了，没有多余的层级嵌套。把各种想要的功能写成一个一个可复用的自定义hook，当你的组件想用什么功能时，直接在组件里调用这个hook即可。</p><h3 id="生命周期钩子函数里的逻辑太乱了吧！"><a href="#生命周期钩子函数里的逻辑太乱了吧！" class="headerlink" title="生命周期钩子函数里的逻辑太乱了吧！"></a>生命周期钩子函数里的逻辑太乱了吧！</h3><p>我们通常希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情。比如我们需要在<code>componentDidMount</code>中发起ajax请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在<code>componentDidUpdate</code>做一遍同样的事情。当项目变复杂后，这一块的代码也变得不那么直观。</p><h3 id="classes真的太让人困惑了！"><a href="#classes真的太让人困惑了！" class="headerlink" title="classes真的太让人困惑了！"></a>classes真的太让人困惑了！</h3><p>我们用class来创建react组件时，还有一件很麻烦的事情，就是this的指向问题。为了保证this的指向正确，我们要经常写这样的代码：<code>this.handleClick = this.handleClick.bind(this)</code>，或者是这样的代码：<code>&lt;button onClick={() =&gt; this.handleClick(e)}&gt;</code>。一旦我们不小心忘了绑定this，各种bug就随之而来，很麻烦。</p><p>还有一件让我很苦恼的事情。我在之前的react系列文章当中曾经说过，尽可能把你的组件写成无状态组件的形式，因为它们更方便复用，可独立测试。然而很多时候，我们用function写了一个简洁完美的无状态组件，后来因为需求变动这个组件必须得有自己的state，我们又得很麻烦的把function改成class。</p><p>在这样的背景下，Hooks便横空出世了！</p><h2 id="什么是State-Hooks？"><a href="#什么是State-Hooks？" class="headerlink" title="什么是State Hooks？"></a>什么是State Hooks？</h2><p>回到一开始我们用的例子，我们分解来看到底state hooks做了什么：</p><pre><code>import { useState } from &apos;react&apos;;function Example() {  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );}</code></pre><h3 id="声明一个状态变量"><a href="#声明一个状态变量" class="headerlink" title="声明一个状态变量"></a>声明一个状态变量</h3><pre><code>import { useState } from &apos;react&apos;;function Example() {  const [count, setCount] = useState(0);</code></pre><p><code>useState</code>是react自带的一个hook函数，它的作用就是用来声明状态变量。<code>useState</code>这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第<code>[0]</code>项是当前当前的状态值，第<code>[1]</code>项是可以改变状态值的方法函数。</p><p>所以我们做的事情其实就是，声明了一个状态变量count，把它的初始值设为0，同时提供了一个可以更改count的函数setCount。</p><p>上面这种表达形式，是借用了<code>es6的数组解构</code> ，它可以让我们的代码看起来更简洁。</p><p>如果不用数组解构的话，可以写成下面这样。实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。具体可以去这篇文章的分析<a href="https://link.juejin.im?target=https%3A%2F%2Fdocs.google.com%2Fdocument%2Fd%2F1hWb-lQW4NSG9yRpyyiAA_9Ktytd5lypLnVLhPX9vamE%2Fedit%23" target="_blank" rel="noopener">Array destructuring for multi-value returns (in light of React hooks)</a>，这里不详细展开，我们就按照官方推荐使用数组解构就好。</p><pre><code>let _useState = useState(0);let count = _useState[0];let setCount = _useState[1];</code></pre><h3 id="读取状态值"><a href="#读取状态值" class="headerlink" title="读取状态值"></a>读取状态值</h3><pre><code>&lt;p&gt;You clicked {count} times&lt;/p&gt;</code></pre><p>是不是超简单？因为我们的状态count就是一个单纯的变量而已，我们再也不需要写成<code>{this.state.count}</code>这样了。</p><h3 id="更新状态"><a href="#更新状态" class="headerlink" title="更新状态"></a>更新状态</h3><pre><code>&lt;button onClick={() =&gt; setCount(count + 1)}&gt;  Click me&lt;/button&gt;</code></pre><p>当用户点击按钮时，我们调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给react了，react将会重新渲染我们的Example组件，并且使用的是更新后的新的状态，即count=1。这里我们要停下来思考一下，Example本质上也是一个普通的函数，为什么它可以记住之前的状态？</p><h3 id="一个至关重要的问题"><a href="#一个至关重要的问题" class="headerlink" title="一个至关重要的问题"></a>一个至关重要的问题</h3><p>这里我们就发现了问题，通常来说我们在一个函数中声明的变量，当函数运行完成后，这个变量也就销毁了（这里我们先不考虑闭包等情况），比如考虑下面的例子：</p><pre><code>function add(n) {    const result = 0;    return result + 1;}add(1); //1add(1); //1</code></pre><p>不管我们反复调用add函数多少次，结果都是1。因为每一次我们调用add时，result变量都是从初始值0开始的。那为什么上面的Example函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？答案是：是react帮我们记住的。至于react是用什么机制记住的，我们可以再思考一下。</p><h3 id="假如一个组件有多个状态值怎么办？"><a href="#假如一个组件有多个状态值怎么办？" class="headerlink" title="假如一个组件有多个状态值怎么办？"></a>假如一个组件有多个状态值怎么办？</h3><p>首先，useState是可以多次调用的，所以我们完全可以这样写：</p><pre><code>function ExampleWithManyStates() {  const [age, setAge] = useState(42);  const [fruit, setFruit] = useState(&apos;banana&apos;);  const [todos, setTodos] = useState([{ text: &apos;Learn Hooks&apos; }]);</code></pre><p>其次，useState接收的初始值没有规定一定要是string/number/boolean这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的<code>this.setState</code>做的是合并状态后返回一个新状态，而<code>useState</code>是直接替换老状态后返回新状态。最后，react也给我们提供了一个useReducer的hook，如果你更喜欢redux式的状态管理方案的话。</p><p>从ExampleWithManyStates函数我们可以看到，useState无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？</p><p>其实我们看hook的“形态”，有点类似之前被官方否定掉的Mixins这种方案，都是提供一种“插拔式的功能注入”的能力。而mixins之所以被否定，是因为Mixins机制是让多个Mixins共享一个对象的数据空间，这样就很难确保不同Mixins依赖的状态不发生冲突。</p><p>而现在我们的hook，一方面它是直接用在function当中，而不是class；另一方面每一个hook都是相互独立的，不同组件调用同一个hook也能保证各自状态的独立性。这就是两者的本质区别了。</p><h3 id="react是怎么保证多个useState的相互独立的？"><a href="#react是怎么保证多个useState的相互独立的？" class="headerlink" title="react是怎么保证多个useState的相互独立的？"></a>react是怎么保证多个useState的相互独立的？</h3><p>还是看上面给出的ExampleWithManyStates例子，我们调用了三次useState，每次我们传的参数只是一个值（如42，‘banana’），我们根本没有告诉react这些值对应的key是哪个，那react是怎么保证这三个useState找到它对应的state呢？</p><p>答案是，react是根据useState出现的顺序来定的。我们具体来看一下：</p><pre><code>//第一次渲染useState(42);  //将age初始化为42useState(&apos;banana&apos;);  //将fruit初始化为bananauseState([{ text: &apos;Learn Hooks&apos; }]); //...//第二次渲染useState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）useState(&apos;banana&apos;);  //读取状态变量fruit的值（这时候传的参数banana直接被忽略）useState([{ text: &apos;Learn Hooks&apos; }]); //...</code></pre><p>假如我们改一下代码：</p><pre><code>let showFruit = true;function ExampleWithManyStates() {  const [age, setAge] = useState(42);  if(showFruit) {    const [fruit, setFruit] = useState(&apos;banana&apos;);    showFruit = false;  }  const [todos, setTodos] = useState([{ text: &apos;Learn Hooks&apos; }]);</code></pre><p>这样一来，</p><pre><code>//第一次渲染useState(42);  //将age初始化为42useState(&apos;banana&apos;);  //将fruit初始化为bananauseState([{ text: &apos;Learn Hooks&apos; }]); //...//第二次渲染useState(42);  //读取状态变量age的值（这时候传的参数42直接被忽略）// useState(&apos;banana&apos;);  useState([{ text: &apos;Learn Hooks&apos; }]); //读取到的却是状态变量fruit的值，导致报错</code></pre><p>鉴于此，react规定我们必须把hooks写在函数的最外层，不能写在ifelse等条件语句当中，来确保hooks的执行顺序一致。</p><h2 id="什么是Effect-Hooks"><a href="#什么是Effect-Hooks" class="headerlink" title="什么是Effect Hooks?"></a>什么是Effect Hooks?</h2><p>我们在上一节的例子中增加一个新功能：</p><pre><code>import { useState, useEffect } from &apos;react&apos;;function Example() {  const [count, setCount] = useState(0);  // 类似于componentDidMount 和 componentDidUpdate:  useEffect(() =&gt; {    // 更新文档的标题    document.title = `You clicked ${count}times`;  });  return (    &lt;div&gt;      &lt;p&gt;You clicked {count} times&lt;/p&gt;      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );}</code></pre><p>我们对比着看一下，如果没有hooks，我们会怎么写？</p><pre><code>class Example extends React.Component {  constructor(props) {    super(props);    this.state = {      count: 0    };  }  componentDidMount() {    document.title = `You clicked ${this.state.count}times`;  }  componentDidUpdate() {    document.title = `You clicked ${this.state.count}times`;  }  render() {    return (      &lt;div&gt;        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;          Click me        &lt;/button&gt;      &lt;/div&gt;    );  }}</code></pre><p>我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起ajax请求获取数据，添加一些监听的注册和取消注册，手动修改dom等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如componentDidMount，componentDidUpdate和componentWillUnmount。而现在的useEffect就相当与这些声明周期函数钩子的集合体。它以一抵三。</p><p>同时，由于前文所说hooks可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的useEffect钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。</p><h3 id="useEffect做了什么？"><a href="#useEffect做了什么？" class="headerlink" title="useEffect做了什么？"></a>useEffect做了什么？</h3><p>我们再梳理一遍下面代码的逻辑：</p><pre><code>function Example() {  const [count, setCount] = useState(0);  useEffect(() =&gt; {    document.title = `You clicked ${count}times`;  });</code></pre><p>首先，我们声明了一个状态变量<code>count</code>，将它的初始值设为0。然后我们告诉react，我们的这个组件有一个副作用。我们给<code>useEffect</code>hook传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我们的副作用是调用browser API来修改文档标题。当react要渲染我们的组件时，它会先记住我们用到的副作用。等react更新了DOM之后，它再依次执行我们定义的副作用函数。</p><p>这里要注意几点：<br>第一，react首次渲染和之后的每次渲染都会调用一遍传给useEffect的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount），和之后的更新导致的重新渲染（componentDidUpdate）。</p><p>第二，useEffect中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的componentDidMount或componentDidUpdate中的代码则是同步执行的。这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据DOM计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。</p><h3 id="useEffect怎么解绑一些副作用"><a href="#useEffect怎么解绑一些副作用" class="headerlink" title="useEffect怎么解绑一些副作用"></a>useEffect怎么解绑一些副作用</h3><p>这种场景很常见，当我们在componentDidMount里添加了一个注册，我们得马上在componentWillUnmount中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。</p><p>怎么清除呢？让我们传给useEffect的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些pubsub模式的实现中很常见。看下面的例子：</p><pre><code>import { useState, useEffect } from &apos;react&apos;;function FriendStatus(props) {  const [isOnline, setIsOnline] = useState(null);  function handleStatusChange(status) {    setIsOnline(status.isOnline);  }  useEffect(() =&gt; {    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);    // 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup    returnfunctioncleanup() {      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);    };  });  if (isOnline === null) {    return&apos;Loading...&apos;;  }  return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;}</code></pre><p>这里有一个点需要重视！这种解绑的模式跟componentWillUnmount不一样。componentWillUnmount只会在组件被销毁前执行一次而已，而useEffect里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。</p><h3 id="为什么要让副作用函数每次组件更新都执行一遍？"><a href="#为什么要让副作用函数每次组件更新都执行一遍？" class="headerlink" title="为什么要让副作用函数每次组件更新都执行一遍？"></a>为什么要让副作用函数每次组件更新都执行一遍？</h3><p>我们先看以前的模式：</p><pre><code>componentDidMount() {    ChatAPI.subscribeToFriendStatus(      this.props.friend.id,      this.handleStatusChange    );  }  componentWillUnmount() {    ChatAPI.unsubscribeFromFriendStatus(      this.props.friend.id,      this.handleStatusChange    );  }</code></pre><p>很清除，我们在componentDidMount注册，再在componentWillUnmount清除注册。但假如这时候<code>props.friend.id</code>变了怎么办？我们不得不再添加一个componentDidUpdate来处理这种情况：</p><pre><code>...  componentDidUpdate(prevProps) {    // 先把上一个friend.id解绑    ChatAPI.unsubscribeFromFriendStatus(      prevProps.friend.id,      this.handleStatusChange    );    // 再重新注册新但friend.id    ChatAPI.subscribeToFriendStatus(      this.props.friend.id,      this.handleStatusChange    );  }...</code></pre><p>看到了吗？很繁琐，而我们但useEffect则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：</p><pre><code>1.页面首次渲染2.替friend.id=1的朋友注册3.突然friend.id变成了24.页面重新渲染5.清除friend.id=1的绑定6.替friend.id=2的朋友注册...</code></pre><h3 id="怎么跳过一些不必要的副作用函数"><a href="#怎么跳过一些不必要的副作用函数" class="headerlink" title="怎么跳过一些不必要的副作用函数"></a>怎么跳过一些不必要的副作用函数</h3><p>按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。</p><pre><code>useEffect(() =&gt; {  document.title = `You clicked ${count}times`;}, [count]);     // 只有当count的值发生变化时，才会重新执行`document.title`这一句</code></pre><p>当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是componentDidMount加componentWillUnmount的模式。不过这种用法可能带来bug，少用。</p><h2 id="还有哪些自带的Effect-Hooks"><a href="#还有哪些自带的Effect-Hooks" class="headerlink" title="还有哪些自带的Effect Hooks?"></a>还有哪些自带的Effect Hooks?</h2><p>除了上文重点介绍的useState和useEffect，react还给我们提供来很多有用的hooks：</p><p>useContext<br>useReducer<br>useCallback<br>useMemo<br>useRef<br>useImperativeMethods<br>useMutationEffect<br>useLayoutEffect</p><p>我不再一一介绍，大家自行去查阅官方文档。</p><h2 id="怎么写自定义的Effect-Hooks"><a href="#怎么写自定义的Effect-Hooks" class="headerlink" title="怎么写自定义的Effect Hooks?"></a>怎么写自定义的Effect Hooks?</h2><p>为什么要自己去写一个Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。</p><p>比如我们可以把上面写的FriendStatus组件中判断朋友是否在线的功能抽出来，新建一个useFriendStatus的hook专门用来判断某个id是否在线。</p><pre><code>import { useState, useEffect } from &apos;react&apos;;function useFriendStatus(friendID) {  const [isOnline, setIsOnline] = useState(null);  function handleStatusChange(status) {    setIsOnline(status.isOnline);  }  useEffect(() =&gt; {    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);    return () =&gt; {      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);    };  });  return isOnline;}</code></pre><p>这时候FriendStatus组件就可以简写为：</p><pre><code>function FriendStatus(props) {  const isOnline = useFriendStatus(props.friend.id);  if (isOnline === null) {    return &apos;Loading...&apos;;  }  return isOnline ? &apos;Online&apos; : &apos;Offline&apos;;}</code></pre><p>简直Perfect！假如这个时候我们又有一个朋友列表也需要显示是否在线的信息：</p><pre><code>function FriendListItem(props) {  const isOnline = useFriendStatus(props.friend.id);  return (    &lt;li style={{ color: isOnline ? 'green' : 'black' }}&gt;      {props.friend.name}    &lt;/li&gt;  );}</code></pre><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a><a href="https://github.com/libin1991/webpack4-vue-more-page-cli/tree/master/React-Hooks" target="_blank" rel="noopener">DEMO</a></h2><p><img src="/2018/11/06/React-Hooks/1.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">// import React from &apos;react&apos;;</span><br><span class="line">import logo from &apos;./logo.svg&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import React, &#123;</span><br><span class="line">// useHooks,</span><br><span class="line">useState,</span><br><span class="line">useEffect,</span><br><span class="line">useContext,</span><br><span class="line">useReducer,</span><br><span class="line">useRef</span><br><span class="line">&#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext(&#123;</span><br><span class="line">background: &apos;#282c34&apos;,</span><br><span class="line">color: &apos;#61dafb&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 监控浏览器变化</span><br><span class="line"> * @return &#123;number&#125; innerWidth 返回当前窗口宽度</span><br><span class="line"> * **/</span><br><span class="line">const useWindowWith = () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">const [innerWidth, setInnerWidth] = useState(window.innerWidth);</span><br><span class="line"></span><br><span class="line">const handleResize = () =&gt; setInnerWidth(window.innerWidth)</span><br><span class="line"></span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">window.addEventListener(&apos;resize&apos;, handleResize)</span><br><span class="line">return() =&gt; &#123;</span><br><span class="line">window.removeEventListener(&apos;resize&apos;, handleResize)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">return innerWidth</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 计数</span><br><span class="line"> * @param  &#123;number&#125; initialState 初始值</span><br><span class="line"> * @return &#123;number&#125; count 值</span><br><span class="line"> * @return &#123;function&#125; setCount 改变值的方法</span><br><span class="line"> * */</span><br><span class="line">const useCount = (initialState) =&gt; &#123;</span><br><span class="line">const [count, setCount] = useState(initialState);</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">console.log(&apos;change&apos;)</span><br><span class="line">&#125;, [count])</span><br><span class="line">return [count, setCount]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * count-reducer</span><br><span class="line"> * * */</span><br><span class="line"></span><br><span class="line">const initialState = &#123;</span><br><span class="line">count: 0</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">switch(action.type) &#123;</span><br><span class="line">case &apos;reset&apos;:</span><br><span class="line">return initialState;</span><br><span class="line">case &apos;increment&apos;:</span><br><span class="line">return &#123;</span><br><span class="line">count: state.count + 1</span><br><span class="line">&#125;;</span><br><span class="line">case &apos;decrement&apos;:</span><br><span class="line">return &#123;</span><br><span class="line">count: state.count - 1</span><br><span class="line">&#125;;</span><br><span class="line">default:</span><br><span class="line">return state</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 点击获取焦点</span><br><span class="line"> * @param  &#123;number&#125; initial 初始值</span><br><span class="line"> * @return &#123;object&#125; ref 当前的ref对象</span><br><span class="line"> * @return &#123;function&#125; focusHandle 使用该ref对象的函数</span><br><span class="line"> * */</span><br><span class="line">function useRefHandle(initial) &#123;</span><br><span class="line">let ref = useRef(initial)</span><br><span class="line">let focusHandle = () =&gt; ref.current.focus();</span><br><span class="line">return [ref, focusHandle]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const App = (props) =&gt; &#123;</span><br><span class="line">const innerWidth = useWindowWith()</span><br><span class="line">const [count, setCount] = useCount(0);</span><br><span class="line">const &#123;</span><br><span class="line">color,</span><br><span class="line">background</span><br><span class="line">&#125; = useContext(ThemeContext);</span><br><span class="line">const [state, dispatch] = useReducer(reducer, initialState)</span><br><span class="line">let [inputEl, focusHandle] = useRefHandle(null);</span><br><span class="line">console.log(&apos;render number&apos;)</span><br><span class="line">return(</span><br><span class="line">&lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &#123;/* useContext demo */&#125;</span><br><span class="line">        &lt;header className=&quot;App-header&quot; style=&#123;&#123;backgroundColor:background&#125;&#125;&gt;</span><br><span class="line">          &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">          &lt;p&gt;  react hook demo &lt;/p&gt;</span><br><span class="line"></span><br><span class="line">          &#123;/* useState demo */&#125;</span><br><span class="line">          &lt;p&gt;count:&#123;count&#125;&lt;/p&gt;</span><br><span class="line">          &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125; className=&quot;App-button&quot;  &gt;点击&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">          &#123;/* useReducer demo */&#125;</span><br><span class="line">          &lt;p&gt;reducer count:&#123;state.count&#125;&lt;/p&gt;</span><br><span class="line">          &lt;div  className=&quot;App-button-group&quot; &gt;</span><br><span class="line">            &lt;button  onClick=&#123;()=&gt;dispatch(&#123;type: &apos;increment&apos;&#125;)&#125; &gt;increment&lt;/button&gt;</span><br><span class="line">            &lt;button  onClick=&#123;()=&gt;dispatch(&#123;type: &apos;decrement&apos;&#125;)&#125; &gt;decrement&lt;/button&gt;</span><br><span class="line">            &lt;button  onClick=&#123;()=&gt;dispatch(&#123;type: &apos;reset&apos;&#125;)&#125; &gt;reset&lt;/button&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">          &#123;/* useEffect demo */&#125;</span><br><span class="line">          &lt;p&gt;当前屏幕宽度：&#123;innerWidth&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">          &#123;/* useRef demo */&#125;</span><br><span class="line">          &lt;p&gt;</span><br><span class="line">          useRef: &lt;input type=&apos;text&apos; ref=&#123;inputEl&#125;/&gt;&lt;button onClick=&#123;focusHandle&#125;&gt;搜索&lt;/button&gt;</span><br><span class="line">          &lt;/p&gt;</span><br><span class="line">          </span><br><span class="line">          &#123;/* useContext demo */&#125;</span><br><span class="line">          &lt;a</span><br><span class="line">            className=&quot;App-link&quot;</span><br><span class="line">            href=&quot;https://reactjs.org&quot;</span><br><span class="line">            target=&quot;_blank&quot;</span><br><span class="line">            rel=&quot;noopener noreferrer&quot;</span><br><span class="line">            style=&#123;&#123;color:color&#125;&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            Learn React</span><br><span class="line">          &lt;/a&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redux源码分析</title>
      <link href="/2018/11/05/Redux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/11/05/Redux%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>抛开React不谈，Redux其实就只是一个管理状态的数据中心，然而作为一个数据中心它的特色在于我们不能够直接修改数据中心里面的数据，我们需要自行定义操作逻辑<code>reducer</code>，以及操作类型<code>action</code>,通过分发不同的<code>action</code>来匹配<code>reducer</code>里面对应的操作，才能达到修改数据的目的。</p><p>一般来说我们会通过以下方式来创建一个数据中心<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from&apos;redux&apos;</span><br><span class="line">const store = createStore(...blablabla)</span><br></pre></td></tr></table></figure></p><p>这里最为关键的就是<code>createStore</code>这个函数，接下来我想详细地对它做个分析。</p><h2 id="createStore方法剖析"><a href="#createStore方法剖析" class="headerlink" title="createStore方法剖析"></a>createStore方法剖析</h2><p>createStore.js这个文件纯代码的部分大概有100多行，如果把他们全部贴出来再一一分析并非明智之举，我认为只对关键的部分进行分析是更恰当的做法。<br><strong>要分析一个方法我觉得比较有意义的是看它接收了什么，以及返回了什么。</strong></p><h3 id="接收的参数"><a href="#接收的参数" class="headerlink" title="接收的参数"></a>接收的参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法接受三个参数，分别是<code>reducer</code>, <code>preloadedState</code>, <code>enhancer</code>。以上都分别可以由开发者进行定义，<code>reducer</code>就是由开发者定义的一个操作方法，它会以旧的状态作为参数，处理过后返回一个新的状态。<code>preloadedState</code>则可以理解成数据中心的初始状态，它是个可选值。</p><p>最后的<code>enhancer</code>又是什么呢？从字面上理解它是一个增强器，用于增强<code>createStore</code>。从源码看它的工作方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  .....</span><br><span class="line">  if (typeof preloadedState === &apos;function&apos; &amp;&amp; typeof enhancer === &apos;undefined&apos;) &#123; // 参数归一</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = undefined</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (typeof enhancer !== &apos;undefined&apos;) &#123;</span><br><span class="line">    if (typeof enhancer !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new Error(&apos;Expected the enhancer to be a function.&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return enhancer(createStore)(reducer, preloadedState) // 直接返回一个增强后的`createStore</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可见，它接收了原来的<code>createStore</code>作为参数，并且返回了一个增强了的方法，最后用增强过的方法来调用原来传入的参数。了解原理之后我们可以很容易地写出一个<code>状态打印增强器</code>，用于打印<code>dispatch</code>前后的状态信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">function enhancer(createStore) &#123;</span><br><span class="line">  return (reducer, initialState, enhancer) =&gt; &#123;</span><br><span class="line">    const store = createStore(reducer, initialState, enhancer)</span><br><span class="line"></span><br><span class="line">    function dispatch(action) &#123;</span><br><span class="line">      console.log(&apos;old&apos;, store.getState())</span><br><span class="line">      const res = store.dispatch(action);</span><br><span class="line">      console.log(&apos;new&apos;, store.getState())</span><br><span class="line">      return res</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 用心的dispatch方法来替换原有的dispatch方法</span><br><span class="line">    return &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducers, undefined, enhancer)</span><br></pre></td></tr></table></figure></p><p>另外，从Redux的源码可以看到<code>createStore</code>做了一种叫做参数归一的处理，在许多JS库中都会采用这种方式兼容不同情况下的参数传入。当我们不需要传入初始状态，而只需要使用<code>enhancer</code>增强器的时候，我们还可以把代码写成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const store = createStore(reducers, enhancer)</span><br></pre></td></tr></table></figure></p><h3 id="2-返回值"><a href="#2-返回值" class="headerlink" title="2) 返回值"></a>2) 返回值</h3><p>接下来我们看看返回值。<code>createStore</code>最终会返回一个对象，包含的东西如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import $$observable from &apos;symbol-observable&apos;</span><br><span class="line"></span><br><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  .....</span><br><span class="line">  return &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer,</span><br><span class="line">    [$$observable]: observable</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些便是我们数据中心为外部提供的全部接口了。最后一个看起来有点奇怪，其他的从字面上应该都比较容易理解，容许许我一一分析。</p><h4 id="a-getState–返回当前状态"><a href="#a-getState–返回当前状态" class="headerlink" title="a. getState–返回当前状态"></a>a. getState–返回当前状态</h4><p>Redux的核心理念之一就是不支持直接修改状态，它是通过闭包来实现这一点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  let currentState = preloadedState</span><br><span class="line"></span><br><span class="line">  function getState() &#123;</span><br><span class="line">    .....</span><br><span class="line">    return currentState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它先是定义了一个内部的变量<code>currentState</code>，然后通过一个名为<code>getState</code>的方法来返回它的值。这就造成了<code>currentState</code>这个状态对我们而言是只读的，我们没办法直接修改它的值。在代码里面我们可以通过<code>getState</code>这个方法来返回当前状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(store.getState())</span><br></pre></td></tr></table></figure></p><h4 id="b-subscribe–构造监听者队列"><a href="#b-subscribe–构造监听者队列" class="headerlink" title="b. subscribe–构造监听者队列"></a>b. subscribe–构造监听者队列</h4><p>每个<code>store</code>本身会维护一个监听者队列，我们可以把它想象成一个方法的队列，在每次分发<code>action</code>的时候都会依次调用监听者队列中所有方法。通过这个<code>subscribe</code>方法可以手动地把一些回调函数添加到监听者队列中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  let currentListeners = []</span><br><span class="line">  let nextListeners = currentListeners</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  function ensureCanMutateNextListeners() &#123;</span><br><span class="line">    if (nextListeners === currentListeners) &#123;</span><br><span class="line">      nextListeners = currentListeners.slice()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  function subscribe(listener) &#123;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    let isSubscribed = true</span><br><span class="line"></span><br><span class="line">    ensureCanMutateNextListeners()</span><br><span class="line">    nextListeners.push(listener)</span><br><span class="line"></span><br><span class="line">    return function unsubscribe() &#123;</span><br><span class="line">      if (!isSubscribed) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ....</span><br><span class="line"></span><br><span class="line">      isSubscribed = false</span><br><span class="line"></span><br><span class="line">      ensureCanMutateNextListeners()</span><br><span class="line">      const index = nextListeners.indexOf(listener)</span><br><span class="line">      nextListeners.splice(index, 1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逻辑其实很简单，为了减少篇幅我把一些类型检查的代码去掉了。每次调用<code>subscribe</code>的时候传入一个回调函数，<code>subscribe</code>会把它放到一个监听者队列中去，并返回一个<code>unsubscribe</code>的方法。这个<code>unsubscribe</code>方法是让开发者可以方便地从列表中删除对应的回调函数，此外该方法还维护着一个<code>isSubscribed</code>标识订阅状态。</p><p>这里面有一个比较有意思的<code>ensureCanMutateNextListeners</code>的方法，按照代码的逻辑，它是要保证监听者的添加与删除并不在<code>currentListeners</code>这个原始的队列里面进行直接操作，我们操作的只是它的一个副本。直到我们调用<code>dispatch</code>方法进行分发的时候，<code>currentListeners</code>与<code>nextListeners</code>才会再一次指向同一个对象，这个在后面的代码里面会看到。</p><h4 id="c-dispatch–低调的action分发者"><a href="#c-dispatch–低调的action分发者" class="headerlink" title="c. dispatch–低调的action分发者"></a>c. dispatch–低调的action分发者</h4><p><code>dispatch</code>方法是用来分发<code>action</code>的，可以把它理解成用于触发数据更新的方法。它的核心实现也比较简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  ...</span><br><span class="line">  function dispatch(action) &#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    // 调用reducer</span><br><span class="line">    try &#123;</span><br><span class="line">      isDispatching = true</span><br><span class="line">      currentState = currentReducer(currentState, action)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isDispatching = false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用监听者</span><br><span class="line">    const listeners = (currentListeners = nextListeners)</span><br><span class="line">    for (let i = 0; i &lt; listeners.length; i++) &#123;</span><br><span class="line">      const listener = listeners[i]</span><br><span class="line">      listener()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return action</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我依旧把一些类型检查的代码去掉，首先<code>dispatch</code>方法会以当前的状态<code>currentState</code>以及我们定义的动作<code>action</code>作为参数来调用当前的<code>reducer</code>方法。另外它使用<code>isDispatching</code>变量来记录分发的状态，正在分发则设置为<code>true</code>。这里需要注意的是我们的<code>reducer</code>方法将会被设置成一个<strong>纯函数</strong>–它不会产生副作用，并且对于同样的输入它会返回同样的输出。换句话说它不会直接在原来状态的基础上进行修改，而是会直接返回一个新的状态，并对原有状态进行替换。</p><p>完成了上面这些之后我们会依次遍历所有的监听者，并且手动调用所有的回调函数。这里需要注意的是之前有讲过的，订阅/取消订阅的时候我们会生成一个<code>currentLIsteners</code>的副本<code>nextListeners</code>并在它上面添加/删除回调函数。然而到了<code>dispatch</code>这一步他们会做一次同步，这样他们就又会指向同一个对象了。</p><h4 id="d-replaceReducer–替换当前的reducer"><a href="#d-replaceReducer–替换当前的reducer" class="headerlink" title="d. replaceReducer–替换当前的reducer"></a>d. replaceReducer–替换当前的reducer</h4><p><code>replaceReducer</code>这个方法做的事情其实很简单，它可以用新的<code>reducer</code>替换掉当前的<code>reducer</code>，并且分发一个替换的<code>action</code>，下面是源代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  .....</span><br><span class="line">  function replaceReducer(nextReducer) &#123;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    currentReducer = nextReducer</span><br><span class="line">    dispatch(&#123; type: ActionTypes.REPLACE &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>据说这种方式在调试环境下会用得比较多。在正式环境下一般都不会在中途更替<code>reducer</code>，以免得增加维护成本。</p><h4 id="e-observable–观察者"><a href="#e-observable–观察者" class="headerlink" title="e. observable–观察者"></a>e. observable–观察者</h4><p>这个是比较让我费解的一个功能了，然而Redux的数据中心居然把它作为api开放出来，咱门先贴源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default function createStore(reducer, preloadedState, enhancer) &#123;</span><br><span class="line">  ....</span><br><span class="line">  function observable() &#123;</span><br><span class="line">    const outerSubscribe = subscribe</span><br><span class="line">    return &#123;</span><br><span class="line">      ...</span><br><span class="line">      subscribe(observer) &#123;</span><br><span class="line">        ....</span><br><span class="line">        function observeState() &#123;</span><br><span class="line">          if (observer.next) &#123;</span><br><span class="line">            observer.next(getState())</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        observeState()</span><br><span class="line">        const unsubscribe = outerSubscribe(observeState)</span><br><span class="line">        return &#123; unsubscribe &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      [$$observable]() &#123;</span><br><span class="line">        return this</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果直接调用这个接口，它会返回一个对象，而对象里面包含了<code>subscribe</code>方法，并且我们可以把一个包含<code>next</code>字段(它是一个函数)的对象作为<code>subscribe</code>方法的参数，就可以在每次数据变动的时候以<strong>当前状态<code>getState()</code></strong>作为参数调用<code>next</code>所携带的函数。</p><p>这么说有点拗口，可能给个例子会比较直观</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import $$observable from &apos;symbol-observable&apos;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">const store = createStore(reducer)</span><br><span class="line"></span><br><span class="line">const subObject = store[$$observable]()</span><br><span class="line">subObject.subscribe(&#123;</span><br><span class="line">  next: (a) =&gt; &#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就可以做到每次动作被分发的时候都会调用<code>next</code>所携带的方法，并打印出<code>getState()</code>的值。这种观察者模式的写法有什么特殊的意义我也还没有时间去深究，似乎是<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftc39%2Fproposal-observable" target="_blank" rel="noopener">草案</a>的一部分，估计目前用的也不多，先不深入探究了。</p><hr><h2 id="1-中间件"><a href="#1-中间件" class="headerlink" title="1. 中间件"></a>1. 中间件</h2><p><img src="/2018/11/05/Redux源码分析/1.jpg" alt=""><br>中间件这个概念存在于许多流行的Web框架中，可以把它想象成是请求/响应分发的中间层，用于对请求/响应做进一步的处理，而无需改变原有的代码逻辑。在<code>node.js</code>社区的<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkoajs%2Fkoa" target="_blank" rel="noopener">KOA</a>轻量级框架很出色地体现了这一点(当然它肯定不是第一个这样干的人)。koa本身只提供了最基础的请求/响应功能，如果想要更强大的功能(比如说日志，时间记录等功能)则需要自己添加相应的中间件。</p><p>Redux继承了这一理念，它把中间件应用到了<code>dispatch</code>方法的扩展中，让我们可以优雅地扩展<code>dispatch</code>方法，而不需要重写原有的<code>dispatch</code>方法，接下来我们好好体会一下它的精妙之处。</p><h2 id="2-中间件在Redux中的应用"><a href="#2-中间件在Redux中的应用" class="headerlink" title="2. 中间件在Redux中的应用"></a>2. 中间件在Redux中的应用</h2><p>在分析源码之前先来看看在Redux里面如何使用中间件，最关键的是<code>applyMiddleware</code>这个方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore, applyMiddleware &#125; from &apos;redux&apos;</span><br><span class="line">// Add thunk</span><br><span class="line">import thunk from &apos;redux-thunk&apos;</span><br><span class="line">import logger from &apos;redux-logger&apos;</span><br><span class="line"></span><br><span class="line">const reducer = (state) =&gt; state</span><br><span class="line"></span><br><span class="line">let newCreateStore = applyMiddleware(</span><br><span class="line">  logger,</span><br><span class="line">  thunk</span><br><span class="line">)(createStore)</span><br><span class="line"></span><br><span class="line">// 创建store，数据中心</span><br><span class="line">let store = newCreateStore(reducer)</span><br></pre></td></tr></table></figure></p><p>其中<code>thunk</code>跟<code>logger</code>就是我们提到的中间件，依次把它们传入<code>applyMiddleware</code>函数中，就会返回一个新的函数，然后再用这个函数处理原始的<code>createStore</code>方法就会返回一个增强过的<code>createStore</code>方法。</p><p>另外，还记得<code>createStore</code>函数可以接收<code>enhancer</code>这个参数不？其实<code>applyMiddleware</code>这个方法经过调用后所得到的就是一个增强器。为此我们还可以这样调用<code>createStore</code>，并生成<code>store</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">let enhancer = applyMiddleware(</span><br><span class="line">  logger,</span><br><span class="line">  thunk</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">let store = createStore(reducer, enhancer)</span><br></pre></td></tr></table></figure></p><p>这种做法跟前面的扩展效果是一样的。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><h3 id="1-中间件原理"><a href="#1-中间件原理" class="headerlink" title="1) 中间件原理"></a>1) 中间件原理</h3><p>在源码分析之前，先举个例子来看看一个简单的<code>中间件</code>内部应该是什么样子的，我分别定义<code>middleware1</code>，<code>middleware2</code>两个中间件(他们本质是高阶函数)，并用来扩展<code>originDispatch</code>函数</p><pre><code>let originDispatch = (...args) =&gt; {  console.log(...args)}const middleware1 = (dispatch) =&gt; {  return(...args) =&gt; {    console.log(&apos;middleware1 before dispatch&apos;)    dispatch(...args)    console.log(&apos;middleware1 after dispatch&apos;)  }}const middleware2 = (dispatch) =&gt; {  return(...args) =&gt; {    console.log(&apos;middleware2 before dispatch&apos;)    dispatch(...args)    console.log(&apos;middleware2 before dispatch&apos;)  }}originDispatch = middleware2(middleware1(originDispatch))originDispatch(&apos;ruby&apos;, &apos;cool&apos;, &apos;language&apos;)</code></pre><p>结果如下</p><pre><code>middleware2 before dispatchmiddleware1 before dispatchruby cool languagemiddleware1 after dispatchmiddleware2 before dispatch</code></pre><p>是不是运行过程是不是有点像洋葱？我们可以使用中间件来对原有的方法进行增强，并返回一个增强了的方法，然后再用另一个中间件来对这个已经增强过的方法再进一步增强，模型示意图如下<br><img src="/2018/11/05/Redux源码分析/164250984dffa839.webp" alt=""></p><h3 id="2-compose–方法封链辅助函数"><a href="#2-compose–方法封链辅助函数" class="headerlink" title="2) compose–方法封链辅助函数"></a>2) compose–方法封链辅助函数</h3><p>从上面的洋葱模型可以看出我们如果要增强一个方法，它的步骤如下</p><pre><code>newFunc = f1(f2(func))</code></pre><p>可以简单地把<code>f1</code>,<code>f2</code>理解成我们需要各自定义的中间件函数，然而如果我们每次都要手动调用这些方法的话似乎并不太优雅，这个时候可以使用<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux%2Fblob%2Fmaster%2Fsrc%2Fcompose.js" target="_blank" rel="noopener">compose</a>函数来完成这种事情。</p><p><code>compose</code>在中文里面是组合的意思，Redux所定义的<code>compose</code>函数可以把函数的参数列表构造成依次调用的形式，并返回一个新的函数。它的源码如下</p><pre><code>export default functioncompose(...funcs) {  ...  // 以上都是判断  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))}</code></pre><p>文字解释可能还不如流程图来得直观，下面简单地分析一下<code>compose(f1, f2, f3, f4)</code>的调用过程</p><pre><code>a: f1, b: f2, return: (...args) =&gt; f1(f2(...args))a: (...args) =&gt; f1(f2(...args)), b: f3, return: (...args) =&gt; f1(f2(f3(...args)))a: (...args) =&gt; f1(f2(f3(...args))), b: f4, return: (...args) =&gt; f1(f2(f3(f4(...args))))</code></pre><p>把这个方法应用在最初的例子中</p><pre><code>&gt; newfunc = compose(middleware2, middleware1)(originDispatch)[Function]&gt; newfunc(&apos;node&apos;, &apos;good&apos;, &apos;languate&apos;)middleware2 before dispatchmiddleware1 before dispatchnode good languatemiddleware1 after dispatchmiddleware2 before dispatch</code></pre><p>结果是一样的。而且从这个例子还可以看出在<code>compose</code>函数的参数列表中越靠后的函数，在构造完成之后，距离原始函数就越近。</p><h3 id="3-applyMiddleware–收集中间件，扩展createStore"><a href="#3-applyMiddleware–收集中间件，扩展createStore" class="headerlink" title="3) applyMiddleware–收集中间件，扩展createStore"></a>3) applyMiddleware–收集中间件，扩展createStore</h3><p>applyMiddleware.js这个文件里面就包含着它的源码</p><pre><code>export default function applyMiddleware(...middlewares) {  return createStore =&gt; (...args) =&gt; {    const store = createStore(...args)    let dispatch = () =&gt; {      throw new Error(        `Dispatching while constructing your middleware is not allowed. ` +          `Other middleware would not be applied to this dispatch.`      )    }    const middlewareAPI = {      getState: store.getState,      dispatch: (...args) =&gt; dispatch(...args)    }    // #1 中间件应该接收store    const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))    // #2 返回的函数用于处理dispatch函数    dispatch = compose(...chain)(store.dispatch)    // #3 替换dispatchreturn {      ...store,      dispatch    }  }}</code></pre><p>代码片段<code>#2</code>中我们传入<code>compose</code>函数里的所有函数都是用于扩展<code>dispatch</code>的，这些函数会被定义为这种形式</p><pre><code>(dispatch) =&gt; {  return function(...args) {    // do something before    dispatch(...args)    // do something after  }}</code></pre><p>这些函数会接收一个<code>dispatch</code>方法为参数，并返回一个增强的<code>dispatch</code>方法。然而我们需要编写的中间件却不仅如此，接下来再看看代码片段<code>#1</code>，以及相关的上下文逻辑</p><pre><code>export default function applyMiddleware(...middlewares) {  ....  const middlewareAPI = {    getState: store.getState,    dispatch: (...args) =&gt; dispatch(...args)  }  // #1 中间件应该接收store  const chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))  // #2 返回的函数用于处理dispatch函数  dispatch = compose(...chain)(store.dispatch)  ...}</code></pre><p>我们通过<code>map</code>方法来处理<code>applyMiddleware</code>所接收的所有中间件，让他们分别以<code>middlewareAPI</code>这个对象作为参数调用过后会返回一个新的函数列表，而这个函数列表才是真正用来增强<code>dispatch</code>的。</p><p><code>middlewareAPI</code>是仅仅包含了<code>getState</code>与<code>dispatch</code>这两个字段的对象，可以把它看成是一个精简版的<code>store</code>。因此我们需要编写的中间件应该是以<code>store</code>作为参数，并且返回一个用于增强<code>dispatch</code>方法的函数，而这个<code>store</code>我们只能够使用<code>getState</code>，<code>dispatch</code>这两个接口。听起来有点拗口，下面我们自行编写一个用于打印状态日志的中间件。</p><pre><code>const Logger = (store) =&gt; (dispatch) =&gt; {  return function(...args) {    const wrappedDispatch = store.dispatch    const getState = store.getState    console.log(&apos;before dispatch&apos;, getState())    dispatch(...args)    console.log(&apos;after dispatch&apos;, getState())    console.info(dispatch)    console.info(wrappedDispatch)  }}</code></pre><p>其中<code>dispatch</code>与<code>wrappedDispatch</code>所指代的分发方法是不一样的。</p><p><code>dispatch</code>是从参数中传入，如果当前中间件是第一个对<code>dispatch</code>方法进行增强的中间件，则当前的<code>dispatch</code>所指向的就是Redux原生定义的<code>dispatch</code>方法。如果当前中间件前面已经有若干中间件的调用，则当前<code>dispatch</code>所指代的是经过前面中间件加强过的新的<code>dispatch</code>方法。我们可以来验证一下</p><pre><code>let enhancer = applyMiddleware(  Logger, // 我们自己编写的Logger  thunk)</code></pre><p><code>dispatch</code>的打印结果如下</p><pre><code>ƒ(action) {  if (typeof action === &apos;function&apos;) {    return action(dispatch, getState, extraArgument);  }  return next(action);}</code></pre><p>可见，这是一个经过<code>thunk</code>中间件处理后返回的方法。</p><p><code>wrappedDispatch</code>因为匿名函数<code>(...args) =&gt; dispatch(...args)</code>的关系，在<code>applyMiddleware</code>函数运行完成并返回之后，匿名函数内部的<code>dispatch</code>会始终指向经过我们增强的<code>dispatch</code>方法。也就是说在中间件里面执行<code>store.dispatch</code>就会始终运行最外层的被增强过的<code>dispatch</code>方法。模型如下<br><img src="/2018/11/05/Redux源码分析/2.webp" alt=""><br><code>wrappedDispatch</code>打印结果虽然看不出什么，但我也顺手贴一下吧</p><pre><code>ƒ dispatch() {  return _dispatch.apply(undefined, arguments);}</code></pre><p>接下来，我们看<code>applyMiddleware</code>的返回值，它会返回一个新的函数，该函数会以<code>createStore</code>作为参数，处理过后返回一个新的<code>createStore</code>方法，它的模式大概是这样子</p><pre><code>(createStore) =&gt; (...args) =&gt; {  // createStore方法用来创建store  return {    ...    getState: ...    dispatch: ...  }}</code></pre><p>而在<code>applyMiddleware</code>中实际上我们只需要增强<code>dispatch</code>方法，为此我们只需要用新的<code>dispatch</code>方法来替换原来的便可。代码片段<code>#3</code>就是用新的<code>dispatch</code>方法取代原来<code>store</code>中的<code>dispatch</code>方法。</p><pre><code>....    return {      ...store,      dispatch    }....</code></pre><hr><h2 id="1-模块化reducer"><a href="#1-模块化reducer" class="headerlink" title="1. 模块化reducer"></a>1. 模块化reducer</h2><p>我们写代码的时候也有这种情况<strong>当一个文件包含的代码太多的时候我们会考虑按逻辑把它们拆分成几个模块，而当我们遇到一些细粒度同类模块的集合时，则会考虑把他们汇总为一个的模块。</strong>至于什么时候该拆，什么时候该合，可能不同的领域自有它的权衡方式。</p><p>今天主要谈谈Redux里面如何模块化管理多个reducer函数。在Redux应用里reducer函数可以理解成一个处理状态的函数，它接受一个状态，以及一个动作，处理之后返回一个更新后的状态。一个简单的reducer函数大概如下</p><pre><code>function reducerExample(state={}, action) {  switch (action.type) {    case&apos;INCREMENT&apos;:      return Object.assign({}, state, {counter: state.counter + 1})    case&apos;DECREMENT&apos;:      return Object.assign({}, state, {counter: state.counter - 1})    default:      return state  }}</code></pre><p>然而这个函数所包含的逻辑仅仅是对状态的<code>counter</code>字段进行加一以及减一操作。Redux是数据中心，它所管理的状态可能会包含很多个字段，当字段相当多的时候，我们需要在<code>reducerExample</code>函数中定义的操作也会渐渐多起来</p><pre><code>function reducerExample(state={}, action) {  switch (action.type) {    case&apos;INCREMENT&apos;:      return Object.assign({}, state, {counter: state.counter + 1})    case&apos;DECREMENT&apos;:      return Object.assign({}, state, {counter: state.counter - 1})    case&apos;MULTI&apos;:      return Object.assign({}, state, {otherCounter: state.otherCounter * 2})    ....    // 此处省略100行代码    ....    default:      return state  }}</code></pre><p>随着状态越来越多，操作函数也将会越来越复杂，单一的reducer函数并非长久之计。这也是Redux为何提供<code>combineReducers</code>的原因，它使得我们可以以模块的方式来管理多个reducer函数。</p><p>简单讲解该函数的使用，假设Redux管理的应用状态如下</p><pre><code>{  counter: 0,  article: {    title: &quot;&quot;,    content: &quot;&quot;  }}</code></pre><p>则我们可以分别定义两个reducer函数<code>counterReducer</code>与<code>articleReducer</code></p><pre><code>function counterReducer(counter=0, action) {  ...}function articleReducer(article={}, action) {  ...}</code></pre><p>在<code>counterReducer</code>里面只定义与<code>counter</code>字段有关的数据操作，而在<code>articleReducer</code>里面只定义与<code>article</code>字段有关的数据操作，最后通过<code>combineReducers</code>来合并两个reducer函数，并生成新的函数<code>reducer</code>，我们只需要把这个新的函数<code>reducer</code>与系统进行集成即可。</p><pre><code>const reducer = combineReducers({  counter: counterReducer,  article: articleReducer})</code></pre><p>我们甚至可以把<code>counterReducer</code>与<code>articleReducer</code>两个函数放在不同的文件中，然后在同一个地方汇总(通过<code>combineReducers</code>)。当我们分发指定的动作之后只有定义了该动作的函数会改变它所对应字段的状态信息。</p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><p>接下来分析一下<code>combineReducers</code>函数的工作原理。<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux%2Fblob%2Fmaster%2Fsrc%2FcombineReducers.js" target="_blank" rel="noopener">combineReducers.js</a>这个文件代码加注释大概100多行，然而我们真正需要了解的核心就仅仅是该脚本中需要导出的<code>combineReducers</code>这个函数，其他代码大多是用于断言，暂且略过不谈。</p><h3 id="1-收集reducers"><a href="#1-收集reducers" class="headerlink" title="1) 收集reducers"></a>1) 收集reducers</h3><p>我们都知道函数接收对象的每个键所对应的值都应该是一个可以用于改变状态的reducer函数，为此我们会先遍历<code>combineReducers</code>函数所接收的对象，排除其中不是函数的字段。</p><pre><code>export default function combineReducers(reducers) {  const reducerKeys = Object.keys(reducers)  const finalReducers = {}  for (let i = 0; i &lt; reducerKeys.length; i++) { // #1    const key = reducerKeys[i]    ....    if (typeof reducers[key] === &apos;function&apos;) { // #2      finalReducers[key] = reducers[key]    }  }  ......}</code></pre><p>代码片段<code>#1</code>遍历函数接收的对象的所有键，代码片段<code>#2</code>判断该键在原对象中指向的内容是否是一个函数。如果是函数的话，则把该函数以同样的键存储到<code>finalReducers</code>这个对象中，等循环结束以后<code>finalReducers</code>对象的每一个键所对应的值则都是一个函数了。</p><h3 id="2-返回一个新的reducer函数"><a href="#2-返回一个新的reducer函数" class="headerlink" title="2) 返回一个新的reducer函数"></a>2) 返回一个新的reducer函数</h3><p><code>combineReducers</code>其实是一个reducer函数的工厂，在收集不同模块的reducer函数之后，它的责任就是返回一个新的reducer，而这个新的reducer函数能够调度先前收集的所有reducer。我把后续源码中的断言都去掉之后就剩下下列代码</p><pre><code>export default function combineReducers(reducers) {  ...  const finalReducerKeys = Object.keys(finalReducers) // # 1    return function combination(state = {}, action) {    .....    let hasChanged = false    const nextState = {}    for (let i = 0; i &lt; finalReducerKeys.length; i++) {      const key = finalReducerKeys[i]      const reducer = finalReducers[key] // #2      const previousStateForKey = state[key] // #3      const nextStateForKey = reducer(previousStateForKey, action) // #4      ....      nextState[key] = nextStateForKey      hasChanged = hasChanged || nextStateForKey !== previousStateForKey    }    return hasChanged ? nextState : state  }}</code></pre><p>首先会在代码片段<code>#1</code>获取先前过滤好的<code>finalReducers</code>对象的所有键，并存储到<code>finalReducerKeys</code>中。然后当前函数会返回一个新的reducer函数，这个函数能够访问<code>finalReducers</code>形成一个闭包。</p><p>当调用这个新的reducer函数的时，它会遍历<code>finalReducerKeys</code>这个数组中的每一个键，在代码<code>#2</code>处获取当前键所对应的reducer函数并存储到常量<code>reducer</code>，然后在代码<code>#3</code>处获取当前键所对应的状态<code>previousStateForKey</code>。</p><p>接下来在代码<code>#4</code>处以当前状态<code>previousStateForKey</code>以及<code>action</code>作为参数来调用<code>reducer</code>函数，返回该键所对应的新状态<code>nextStateForKey</code>。在每次迭代中都会把当前键<code>key</code>作为字段，把新的状态存储到<code>nextState</code>这个对象中去，循环结束之后，我们就能够保证<code>action</code>被充分调度了。</p><p>另外，还记得咱门编写reducer函数的时候会经常使用这种语法吗？</p><pre><code>Object.assign({}, state, {counter: state.counter + 1})</code></pre><p>这表明了我们不会在原来的<code>state</code>基础上进行修改操作，而是生成了一个新的<code>state</code>，原理大概如下</p><pre><code>&gt; a = {}{}&gt; b = Object.assign(a, {counter: 1}){ counter: 1 }&gt; c = Object.assign({}, a, {counter: 1}){ counter: 1 }&gt; a === btrue&gt; a === cfalse</code></pre><p>而在Redux中，正常情况下如果reducer方法被调用后并没有产生新的对象，而只是在原有的对象中进行操作的话，则在绑定组件的时候，状态的修改将有可能不会引起组件的更新。reducer函数的定位是纯函数，不应该造成任何副作用，为此，reducer函数都应该要生成新的对象。</p><p>在<code>combineReducers</code>这个函数里也会有相应的处理，这里需要着重关注<code>hasChanged</code>这个变量</p><pre><code>...  return hasChanged ? nextState : state...</code></pre><p>当且仅当，这个变量为真值的时候我们才会返回新的状态，不然的话依旧返回原有的状态。这个<code>hasChanged</code>是由以下代码控制的</p><pre><code>...for (let i = 0; i &lt; finalReducerKeys.length; i++) {  ....  hasChanged = hasChanged || nextStateForKey !== previousStateForKey}</code></pre><p>也就是说在所有的迭代中至少有一次迭代符合<code>nextStateForKey !== previousStateForKey</code>这个条件的时候(所对应的reducer返回了新的对象)<code>hasChanged</code>才会为真，新的reducer函数才会返回新的状态对象<code>nextState</code>。否则将返回原有的状态对象<code>state</code>，这样在绑定React组件的时候则有可能会出现状态数据更新了，组件却没有响应的情况。</p><h2 id="为什么Redux-需要-reducers是纯函数？"><a href="#为什么Redux-需要-reducers是纯函数？" class="headerlink" title="为什么Redux 需要 reducers是纯函数？"></a><a href="http://localhost:4000/2018/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88Redux-%E9%9C%80%E8%A6%81-reducers%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9F/" target="_blank" rel="noopener">为什么Redux 需要 reducers是纯函数？</a></h2><h2 id="1-ActionCreator创建动作"><a href="#1-ActionCreator创建动作" class="headerlink" title="1. ActionCreator创建动作"></a>1. ActionCreator创建动作</h2><p>在深入分析源码之前我们先来聊聊<code>ActionCreator</code>。从字面上理解，它是一个动作的创造者，或者说是动作的工厂。如果我们想根据不同的参数来生成不同步长的计数器动作，则可以把工厂函数声明为</p><pre><code>const counterIncActionCreator = function(step) {  return {    type: &apos;INCREMENT&apos;,    step: step || 1  }}</code></pre><p>随着业务逻辑越来越复杂，我们可以通过定义更加复杂的工厂函数来生成更多样化的动作类型。</p><h2 id="2-bindActionCreator高阶函数"><a href="#2-bindActionCreator高阶函数" class="headerlink" title="2. bindActionCreator高阶函数"></a>2. bindActionCreator高阶函数</h2><p>从上述的例子出发，如果我们想生产出不同步长的计数器动作，并分发他们，则需要把代码写成下面这样子</p><pre><code>// 为了简化代码我把dispatch函数定义为只有打印功能的函数const dispatch = function(action) {  console.log(action)}const action1 = counterIncActionCreator()dispatch(action1) // { type: &apos;INCREMENT&apos;, step: 1 }const action2 = counterIncActionCreator(2)dispatch(action2) // { type: &apos;INCREMENT&apos;, step: 2 }const action3 = counterIncActionCreator(3)dispatch(action3) // { type: &apos;INCREMENT&apos;, step: 3 }</code></pre><p>可见每次分发动作之前我们都得手动调用<code>counterIncActionCreator</code>来生产相应的动作，这种方式并不是那么的优雅。这个时候我们就可以采用<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Freduxjs%2Fredux%2Fblob%2Fmaster%2Fsrc%2FbindActionCreators.js" target="_blank" rel="noopener">bindActionCreators</a>这个文件里面的<code>bindActionCreator</code>工具函数来优化代码了，该函数的源码如下</p><pre><code>function bindActionCreator(actionCreator, dispatch) {  return function() {    return dispatch(actionCreator.apply(this, arguments))  }}</code></pre><p><code>bindActionCreator</code>将会返回一个新函数，这个函数会用自身所接收的参数来调用<code>actionCreator</code>并生成对应动作，并且这个生成的动作将会作为<code>dispatch</code>函数的参数。也就是说我们把</p><ol><li>生成动作</li><li>调度动作</li></ol><p>这两个步骤都封装到一个函数里面了，于是便得到了更为优雅的调度过程</p><pre><code>...const increment = bindActionCreator(counterIncActionCreator, dispatch)increment() // { type: &apos;INCREMENT&apos;, step: 1 }increment(2) // { type: &apos;INCREMENT&apos;, step: 2 }increment(3) // { type: &apos;INCREMENT&apos;, step: 3 }</code></pre><h2 id="3-bindActionCreators"><a href="#3-bindActionCreators" class="headerlink" title="3. bindActionCreators"></a>3. bindActionCreators</h2><p>接下来看看<code>bindActionCreators</code>这个函数，它是<code>bindActionCreator</code>函数的加强版。删掉一些断言语句之后源码如下</p><pre><code>export default functionbindActionCreators(actionCreators, dispatch) {  if (typeof actionCreators === &apos;function&apos;) { // #1     return bindActionCreator(actionCreators, dispatch) // #2  }  ....  const keys = Object.keys(actionCreators)  const boundActionCreators = {}  for (let i = 0; i &lt; keys.length; i++) {    const key = keys[i]    const actionCreator = actionCreators[key]    if (typeof actionCreator === &apos;function&apos;) { // #3      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)    }  }  return boundActionCreators}</code></pre><p>代码<code>#1</code>的判断语句是为了做兼容处理，当接收的参数<code>actionCreators</code>为一个函数的时候，则认为它是单一的动作工厂，便在代码<code>#2</code>处直接调用<code>bindActionCreator</code>工具函数来封装调度过程。</p><p>另一情况是当<code>actionCreators</code>参数是一个对象的时候，则遍历这个对象。代码<code>#3</code>会判断每个键在原始对象中的值是否是个函数，如果是一个函数则认为它是一个动作工厂，并使用<code>bindActionCreator</code>函数来封装调度过程，最后把生成的新函数以同样的键<code>key</code>存储到<code>boundActionCreators</code>对象中。在函数的末尾会返回<code>boundActionCreators</code>对象。</p><p>举个简单应用例子，首先使用一个对象来存储两个事件工厂</p><pre><code>const MyActionCreators = {  increment: function(step) {    return {      type: &apos;INCREMENT&apos;,      step: step || 1    }  },  decrement: function(step) {    return {      type: &apos;DECREMENT&apos;,      step: - (step || 1)    }  }}</code></pre><p>然后通过<code>bindActionCreators</code>来封装调度过程，并返回一个新的对象</p><pre><code>const dispatch = function(action) {  console.log(action)}const MyNewActionCreators = bindActionCreators(MyActionCreators, dispatch)</code></pre><p>最后我们便可以用新的对象来主导调度过程了</p><pre><code>MyNewActionCreators.increment() // { type: &apos;INCREMENT&apos;, step: 1 }MyNewActionCreators.increment(2) // { type: &apos;INCREMENT&apos;, step: 2 }MyNewActionCreators.increment(3) // { type: &apos;INCREMENT&apos;, step: 3 }MyNewActionCreators.decrement() // { type: &apos;DECREMENT&apos;, step: -1 }MyNewActionCreators.decrement(2) // { type: &apos;DECREMENT&apos;, step: -2 }MyNewActionCreators.decrement(3) // { type: &apos;DECREMENT&apos;, step: -3 }</code></pre><p>这种调度方式显然比原始的依次调用的方式更为优雅</p><pre><code>// 原始的调度方式dispatch(MyActionCreators.increment()) // { type: &apos;INCREMENT&apos;, step: 1 }dispatch(MyActionCreators.increment(2)) // { type: &apos;INCREMENT&apos;, step: 2 }dispatch(MyActionCreators.increment(3)) // { type: &apos;INCREMENT&apos;, step: 3 }dispatch(MyActionCreators.decrement()) // { type: &apos;DECREMENT&apos;, step: -1 }dispatch(MyActionCreators.decrement(2)) // { type: &apos;DECREMENT&apos;, step: -2 }dispatch(MyActionCreators.decrement(3)) // { type: &apos;DECREMENT&apos;, step: -3 }</code></pre><hr><h2 id="重点说说redux-middleware"><a href="#重点说说redux-middleware" class="headerlink" title="重点说说redux middleware"></a>重点说说redux middleware</h2><h3 id="middleware-的由来"><a href="#middleware-的由来" class="headerlink" title="middleware 的由来"></a>middleware 的由来</h3><p>在业务中需要打印每一个 action 信息来调试，又或者希望 dispatch 或 reducer 拥有异步请求的功能。面对这些场景时，一个个修改 dispatch 或 reducer 代码有些乏力，我们需要一个可组合的、自由增减的插件机制，Redux 借鉴了 Koa 中 middleware 的思想，利用它我们可以在前端应用中便捷地实现如日志打印、异步请求等功能。<br><img src="/2018/11/05/Redux源码分析/3.webp" alt=""></p><p>比如在项目中，进行了如下调用后，redux 就集成了 thunk 函数调用以及打印日志的功能。</p><pre><code>import thunk from&apos;redux-thunk&apos;import logger from&apos;../middleware/logger&apos;const enhancer = applyMiddleware(thunk, logger),  // 以 redux-thunk、logger 中间件为例介绍中间件的使用const store = createStore(rootReducer, enhancer)</code></pre><p>下面追本溯源，来分析下源码。</p><h3 id="applyMiddleware-调用入口"><a href="#applyMiddleware-调用入口" class="headerlink" title="applyMiddleware 调用入口"></a>applyMiddleware 调用入口</h3><pre><code>export default function createStore(reducer, preloadedState, enhancer) {  // 通过下面代码可以发现，如果 createStore 传入 2 个参数，第二个参数相当于就是 enhancer  if (typeof preloadedState === &apos;function&apos; &amp;&amp; typeof enhancer === &apos;undefined&apos;) {    enhancer = preloadedState    preloadedState = undefined  }  if (typeof enhancer !== &apos;undefined&apos;) {    return enhancer(createStore)(reducer, preloadedState)  }  ...}</code></pre><p>由上述 createStore 发现，applyMiddleware 会进行 <code>applyMiddleware(thunk, logger)(createStore)(reducer, preloadedState)</code> 的调用。</p><p>applyMiddleware 源码  如下</p><pre><code>export default function applyMiddleware(...middlewares) {  return createStore =&gt; (...args) =&gt; {    const store = createStore(...args)    let dispatch = store.dispatch    let chain = []    const middlewareAPI = {      getState: store.getState,                // 调用 redux 原生方法，获取状态      dispatch: (...args) =&gt; dispatch(...args) // 调用 redux 原生 dispatch 方法    }    // 串行 middleware    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))    dispatch = compose(...chain)(store.dispatch)    return {      ...store,      dispatch // 返回加工过的 dispatch    }  }}</code></pre><p>可以发现 applyMiddleware 的作用其实就是返回加工过的 dispatch，下面会着重分析 middlewares 是如何串行起来的以及 dispatch 是如何被加工的。</p><h3 id="串行-middleware"><a href="#串行-middleware" class="headerlink" title="串行 middleware"></a>串行 middleware</h3><pre><code>const middlewareAPI = {  getState: store.getState,  dispatch: (...args) =&gt; dispatch(...args)}chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))dispatch = compose(...chain)(store.dispatch)</code></pre><p>观察上述代码后发现每个 middleware 都会传入参数 middlewareAPI，来看下中间件 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FMuYunyun%2FreactSPA%2Fblob%2F274c00870853638fb0f77df8497f911eb560b617%2Fsrc%2Fclient%2Fmiddleware%2Flogger.js%23L1" target="_blank" rel="noopener">logger 的源码</a> 以及 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgaearon%2Fredux-thunk%2Fblob%2Fmaster%2Fsrc%2Findex.js" target="_blank" rel="noopener">redux-thunk 的源码</a>, 发现中间件接受的第一个参数正是 ({ dispatch, getState })</p><pre><code>// logger 源码export default ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {  console.log(action)  return next(action) // 经 compose 源码分析，此处 next 为 Store.dispatch}// redux-thunk 源码export default ({ dispatch, getState }) =&gt; next =&gt; action =&gt; {  if (typeof action === &apos;function&apos;) {    return action(dispatch,getState);  }  //这里可以理解为dispatch(action),本质上就是调用 middleware 链中下一个 middleware 的 dispatch。  return next(action) // 此处 next 为 logger 中间件返回的 (action） =&gt; {} 函数}//使用redux-thunkconst store = createStore(    reducer,  applyMiddleware(thunk));//然后我们实现一个thunkActionCreator//过一秒加1export function thunkActionCreator(payload){    return function(dispatch,getState){        setTimeout(function(){            dispatch({type:types.INCREMENT,payload:payload});        },1000);    }},//最后，在组件中dispatch thunkthis.dispatch(thunkActionCreator(payload));DEMO:export const getNav = () =&gt; async (dispatch, getState) =&gt; {    try {        let response = await instance.get(`book/navigation`)        await dispatch(receiveNav(response.data))    } catch (error) {        console.log(&apos;error: &apos;, error)    }  }</code></pre><h3 id="dispatch-是如何被加工的"><a href="#dispatch-是如何被加工的" class="headerlink" title="dispatch 是如何被加工的"></a>dispatch 是如何被加工的</h3><p>接着上个小节，在 <code>dispatch = compose(...chain)(store.dispatch)</code> 中发现了 compose 函数，来看下 compose 的源码 </p><pre><code>export default function compose(...funcs) {  // ...  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))}</code></pre><p>compose 源码中的 <code>funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))</code> 算是比较重要的一句，它的作用是返回组合参数后的函数，比如 compose(f, g, h) 等价于 (…args) =&gt; f(g(h(…args)))，效果图如下所示，调用 this.props.dispatch() 后，会调用相应的中间件，最终会调用 redux 原生的 store.dispatch()，并且可以看到中间件调用的形式类似数据结构中的栈(先进后出)。<br><img src="/2018/11/05/Redux源码分析/4.webp" alt=""><br>拿上个小节提到的 logger、redux-thunk 中间件为例，其 middleware 的内部串行调用方式如下，从而完成了 dispatch 功能的增强(支持如 <code>this.props.dispatch(func)</code> 的调用以及日志功能)。具体可以看 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FMuYunyun%2FreactSPA%2Fblob%2F274c00870853638fb0f77df8497f911eb560b617%2Fsrc%2Fcommon%2Fpages%2Fmusic%2Findex.js%23L35" target="_blank" rel="noopener">项目中的运用</a></p><pre><code>action =&gt; {  if (typeof action === &apos;function&apos;) {    return action(dispatch)  }  return (action =&gt; {    console.log(action)    return store.dispatch(action)  })(action)}</code></pre><h3 id="redux-promise"><a href="#redux-promise" class="headerlink" title="redux-promise"></a>redux-promise</h3><p>redux-promise也是延迟执行的表达式，它是解决异步的另外一种方案。</p><p>redux-thunk和核心思想是把action变成thunk，而redux-promise的核心思想是让action返回一个promise对象。</p><p>这个中间件使得store.dispatch方法可以接收Promise对象作为参数。这时 ，action 有两种写法:</p><p>写法一、返回值是一个Promise对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function promiseIncrement(payload)&#123;</span><br><span class="line"> //  return &#123;type:types.INCREMENT,payload:payload&#125;  以前是这种写法</span><br><span class="line">    return new Promise(function(resolve,reject)&#123;</span><br><span class="line">      setTimeout(function()&#123;</span><br><span class="line">        resolve(&#123;type:types.INCREMENT,payload:payload&#125;);</span><br><span class="line">      &#125;,1000);</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p><p>写法二，action 对象的payload属性是一个Promise对象，这需要从<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function payloadIncrement()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        type:types.INCREMENT,</span><br><span class="line">        payload: new Promise(function(resolve,reject)&#123;</span><br><span class="line">            setTimeout(function()&#123;</span><br><span class="line">                if(Math.random()&gt;.5)&#123;</span><br><span class="line">                    resolve(100);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    reject(-100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,1000)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们来看看 redux-promise是怎么实现的，就会明白它内部是怎么操作的.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let promise = (&#123;dispatch,getState&#125;)=&gt;next=&gt;action=&gt;&#123;</span><br><span class="line">    if(action.then &amp;&amp; typeof action.then == &apos;function&apos;)&#123;</span><br><span class="line">        action.then(dispatch);</span><br><span class="line">        // 这里的dispatch就是一个函数，dispatch(action)&#123;state:reducer(state,action)&#125;;</span><br><span class="line">    &#125;else if(action.payload&amp;&amp; action.payload.then&amp;&amp; typeof action.payload.then == &apos;function&apos;)&#123;</span><br><span class="line">        action.payload.then(payload=&gt;dispatch(&#123;...action,payload&#125;),payload=&gt;dispatch(&#123;...action,payload&#125;));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        next(action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码可以看出，如果Action本身就是一个Promise，它resolve以后的值应该是一个Action对象，会被dispatch方法送出action.then(dispatch)；如果Action对象的 payload属性是一个Promise对象，那么无论resolve和reject,dispatch 方法都会发出Action。</p><h2 id="理解-funcs-reduce-a-b-gt-args-gt-a-b-args"><a href="#理解-funcs-reduce-a-b-gt-args-gt-a-b-args" class="headerlink" title="理解 funcs.reduce((a, b) =&gt; (args) =&gt; a(b(args)))"></a>理解 funcs.reduce((a, b) =&gt; (args) =&gt; a(b(args)))</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function originDispatch(...args) &#123;</span><br><span class="line">console.log(...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function middleware1(dispatch) &#123;</span><br><span class="line">return (...args) =&gt; &#123;</span><br><span class="line">console.log(&apos;middleware1 before dispatch&apos;)</span><br><span class="line">dispatch(...args)</span><br><span class="line">console.log(&apos;middleware1 after dispatch&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function middleware2(dispatch) &#123;</span><br><span class="line">return (...args) =&gt; &#123;</span><br><span class="line">console.log(&apos;middleware2 before dispatch&apos;)</span><br><span class="line">dispatch(...args)</span><br><span class="line">console.log(&apos;middleware2 after dispatch&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function middleware3(dispatch) &#123;</span><br><span class="line">return (...args) =&gt; &#123;</span><br><span class="line">console.log(&apos;middleware3 before dispatch&apos;)</span><br><span class="line">dispatch(...args)</span><br><span class="line">console.log(&apos;middleware3 after dispatch&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//originDispatch = middleware2(middleware1(originDispatch))</span><br><span class="line">//originDispatch(&apos;redux&apos;, &apos;is&apos;, &apos;cool&apos;);</span><br><span class="line"></span><br><span class="line">function compose(...funcs) &#123;</span><br><span class="line">return funcs.reduce((a, b) =&gt; (args) =&gt; a(b(args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            //console.log(compose(middleware2, middleware1))</span><br><span class="line">               //(args) =&gt; middleware2(middleware1(args))  </span><br><span class="line">               //(originDispatch)=&gt;middleware2(middleware1(originDispatch))  </span><br><span class="line">               </span><br><span class="line">compose(middleware2, middleware1)(originDispatch)(&apos;redux&apos;, &apos;is&apos;, &apos;cool&apos;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li><code>compose(middleware2, middleware1)</code>返回<code>(args) =&gt; middleware2(middleware1(args))</code>;</li><li><code>compose(middleware2, middleware1)(originDispatch)</code> 返回<code>middleware2(middleware1(originDispatch))</code></li><li>将<code>middleware1(originDispatch)</code>当做一个整体,<code>middleware2(middleware1(originDispatch))</code>中的<code>middleware2</code>返回一个函数，等着接受<code>...args</code>;当<code>compose(middleware2, middleware1)(originDispatch)(&#39;redux&#39;, &#39;is&#39;, &#39;cool&#39;)</code>,<code>...args</code>为<code>(&#39;redux&#39;, &#39;is&#39;, &#39;cool&#39;)</code>。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JWT入门与实战</title>
      <link href="/2018/11/02/JWT%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
      <url>/2018/11/02/JWT%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h3 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h3><p>实现用户登录认证的方式常见的有两种：一种是基于 cookie 的认证，另外一种是基于 token 的认证 。本文以基于cookie的认证为参照，详细介绍JWT标准，并实现基于该标签的用户认证接口</p><h4 id="cookie认证"><a href="#cookie认证" class="headerlink" title="cookie认证"></a>cookie认证</h4><blockquote><p>传统的基于 cookie 的认证方式基本有下面几个步骤：</p></blockquote><p>　　1、用户输入用户名和密码，发送给服务器</p><p>　　2、服务器验证用户名和密码，正确的话就创建一个会话（ session ），同时会把这个会话的 ID 保存到客户端浏览器中，因为保存的地方是浏览器的 cookie ，所以这种认证方式叫做基于 cookie 的认证方式</p><p>　　3、后续的请求中，浏览器会发送会话 ID 到服务器，服务器上如果能找到对应 ID 的会话，那么服务器就会返回需要的数据给浏览器</p><p>　　4、当用户退出登录，会话会同时在客户端和服务器端被销毁</p><blockquote><p>这种认证方式的不足之处有两点</p></blockquote><p>　　1、服务器端要为每个用户保留 session信息，连接用户多了，服务器内存压力巨大</p><p>　　2、适合单一域名，不适合第三方请求cookie认证的后端典型代码如下所示:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>)</span><br><span class="line"><span class="keyword">const</span> pug = <span class="built_in">require</span>(<span class="string">'pug'</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'pug'</span>);</span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret: <span class="string">'keyboard cat'</span>,</span><br><span class="line">  resave: <span class="literal">false</span>,</span><br><span class="line">  saveUninitialized: <span class="literal">true</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentUser = req.session.username;</span><br><span class="line">  res.render(<span class="string">'index'</span>, &#123;currentUser&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.sendFile(<span class="string">'login.html'</span>, &#123;<span class="attr">root</span>: <span class="string">'public'</span>&#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/login'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> username = req.body.username;</span><br><span class="line">  req.session.username = username;</span><br><span class="line">  res.redirect(<span class="string">'/'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/logout'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  req.session.destroy();</span><br><span class="line">  res.redirect(<span class="string">'/'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3006</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'running on port 3006...'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="token认证"><a href="#token认证" class="headerlink" title="token认证"></a>token认证</h4><p>下面来介绍token认证。详细认证过程如下</p><p>　　1、用户输入用户名密码，发送给服务器</p><p>　　2、服务器验证用户名和密码，正确的话就返回一个签名过的 token（ token 可以认为就是个长长的字符串），客户端浏览器拿到这个 token</p><p>　　3、后续每次请求中，浏览器会把 token 作为 http header 发送给服务器，服务器可以验证一下签名是否有效，如果有效那么认证就成功了，可以返回客户端需要的数据</p><p>　　4、一旦用户退出登录，只需要客户端销毁一下 token 即可，服务器端不需要有任何操作</p><p>　　这种方式的特点就是客户端的 token 中自己保留有大量信息，服务器没有存储这些信息，而只负责验证，不必进行数据库查询，执行效率大大提高.　　</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li>传统的 session 流程<ul><li>浏览器发起请求登陆</li><li>服务端验证身份，生成身份验证信息，存储在服务端，并且告诉浏览器写入 Cookie</li><li>浏览器发起请求获取用户资料，此时 Cookie 内容也跟随这发送到服务器</li><li>服务器发现 Cookie 中有身份信息，验明正身</li><li>服务器返回该用户的用户资料</li></ul></li><li><p>JWT 流程</p><ul><li>浏览器发起请求登陆</li><li>服务端验证身份，根据算法，将用户标识符打包生成 token, 并且返回给浏览器</li><li>浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器</li><li>服务器发现数据中有 token，验明正身</li><li>服务器返回该用户的用户资料</li></ul></li><li><p>session 存储在服务端占用服务器资源，而 JWT 存储在客户端</p></li><li>session 存储在 Cookie 中，存在伪造跨站请求伪造攻击的风险</li><li>session 只存在一台服务器上，那么下次请求就必须请求这台服务器，不利于分布式应用</li><li>存储在客户端的 JWT 比存储在服务端的 session 更具有扩展性</li></ul><h4 id="如果加强-JWT-的安全性？"><a href="#如果加强-JWT-的安全性？" class="headerlink" title="如果加强 JWT 的安全性？"></a>如果加强 JWT 的安全性？</h4><ul><li>缩短 token 有效时间</li><li>使用安全系数高的加密算法</li><li>token 不要放在 Cookie 中，有 CSRF 风险</li><li>使用 HTTPS 加密协议</li><li>对标准字段 iss、sub、aud、nbf、exp 进行校验</li><li>使用成熟的开源库，不要手贱造轮子</li><li>特殊场景下可以把用户的 UA、IP 放进 payload 进行校验(不推荐)</li></ul><h3 id="JWT-简述"><a href="#JWT-简述" class="headerlink" title="JWT 简述"></a>JWT 简述</h3><blockquote><p>JWT（json web token）是为了在网络应用环境之间传递声明而基于 json 的开放标准，JWT 的声明一般被采用在身份提供者和服务器提供者间传递被认证的身份信息，以便于从资源服务器获取资源。</p></blockquote><h4 id="JWT-的应用场景"><a href="#JWT-的应用场景" class="headerlink" title="JWT 的应用场景"></a>JWT 的应用场景</h4><p>JWT 一般用于用户登录上，身份认证在这种场景下，一旦用户登录完成，在接下来的每个涉及用户权限的请求中都包含 JWT，可以对用户身份、路由、服务和资源的访问权限进行验证。</p><p>举一个例子，假如一个电商网站，在用户登录以后，需要验证用户的地方其实有很多，比如购物车，订单页，个人中心等等，访问这些页面正常的逻辑是先验证用户权限和登录状态，如果验证通过，则进入访问的页面，否则重定向到登录页。</p><p>而在 JWT 之前，这样的验证我们大多都是通过 cookie 和 session 去实现的，我们接下来就来对比以下这两种方式的不同。</p><h4 id="JWT-特点"><a href="#JWT-特点" class="headerlink" title="JWT 特点"></a>JWT 特点</h4><ul><li>体积小，因而传输速度快</li><li>传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输</li><li>严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。</li><li>支持跨域验证，可以应用于单点登录。</li></ul><h3 id="JWT-对比-cookie-session"><a href="#JWT-对比-cookie-session" class="headerlink" title="JWT 对比 cookie/session"></a>JWT 对比 cookie/session</h3><h4 id="cookie-session-的过程："><a href="#cookie-session-的过程：" class="headerlink" title="cookie/session 的过程："></a>cookie/session 的过程：</h4><p>由于浏览器的请求是无状态的，cookie 的存在就是为了带给服务器一些状态信息，服务器在接收到请求时会对其进行验证（其实是在登录时，服务器发给浏览器的），如果验证通过则正常返回结果，如果验证不通过则重定向到登录页，而服务器是根据 session 中存储的结果和收到的信息进行对比决定是否验证通过，当然这里只是简述过程。</p><h4 id="cookie-session-的问题："><a href="#cookie-session-的问题：" class="headerlink" title="cookie/session 的问题："></a>cookie/session 的问题：</h4><p>从上面可以看出服务器种植 cookie 后每次请求都会带上 cookie，浪费带宽，而且 cookie 不支持跨域，不方便与其他的系统之间进行跨域访问，而服务器会用 session 来存储这些用户验证的信息，这样浪费了服务器的内存，当多个服务器想要共享 session 需要都拷贝过去。</p><h3 id="JWT-的过程："><a href="#JWT-的过程：" class="headerlink" title="JWT 的过程："></a>JWT 的过程：</h3><p>当用户发送请求，将用户信息带给服务器的时候，服务器不再像过去一样存储在 session 中，而是将浏览器发来的内容通过内部的密钥加上这些信息，使用 sha256 和 RSA 等加密算法生成一个 token 令牌和用户信息一起返回给浏览器，当涉及验证用户的所有请求只需要将这个 token 和用户信息发送给服务器，而服务器将用户信息和自己的密钥通过既定好的算法进行签名，然后将发来的签名和生成的签名比较，严格相等则说明用户信息没被篡改和伪造，验证通过。</p><p>JWT 的过程中，服务器不再需要额外的内存存储用户信息，和多个服务器之间只需要共享密钥就可以让多个服务器都有验证能力，同时也解决了 cookie 不能跨域的问题。</p><h3 id="JWT-的结构-https-jwt-io"><a href="#JWT-的结构-https-jwt-io" class="headerlink" title="JWT 的结构 https://jwt.io/"></a>JWT 的结构 <a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a></h3><p><img src="/2018/11/02/JWT入门与实战/1.webp" alt=""><br>JWT 之所以能被作为一种声明传递的标准是因为它有自己的结构，并不是随便的发个 token 就可以的，JWT 用于生成 token 的结构有三个部分，使用 . 隔开。</p><p>1、Header [头部]</p><p>Header 头部中主要包含两部分，token 类型和加密算法，如<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>jwt的头部包含两部分信息：</p><ul><li>声明类型，这里是jwt</li><li>声明加密的算法 通常直接使用 HMAC SHA256</li></ul><p>然后将头部进行base64加密（该加密是可以对称解密的)，构成了第一部分。<br>HS256 就是指 sha256 算法，会将这个对象转成 base64。</p><p>2、Payload（载荷）</p><p><strong>由于这里用的是可逆的base64 编码，所以第二部分的数据实际上是明文的。我们应该避免在这里存放不能公开的隐私信息。</strong></p><p>Payload 负载就是存放有效信息的地方，有效信息被分为标准中注册的声明、公共的声明和私有的声明.</p><p>载荷就是存放有效信息的地方。这些有效信息包含三个部分：</p><p>标准中注册声明</p><ul><li>公共的声名</li><li>私有的声明</li><li>公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。</li><li>私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</li></ul><p>下面是一个例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"libin"</span>,</span><br><span class="line">  <span class="string">"id"</span>: <span class="string">"5c170dfb5966f9060d290fe8"</span>,</span><br><span class="line">  <span class="string">"iat"</span>: <span class="number">1545014835</span>,</span><br><span class="line">  <span class="string">"exp"</span>: <span class="number">1545101235</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>(1) 标准中注册的声明<br>下面是标准中注册的声明，建议但不强制使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包括需要传递的用户信息</span></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  <span class="string">"iss"</span>: <span class="string">"Online JWT TEST"</span>, </span><br><span class="line">  <span class="string">"iat"</span>: <span class="number">1416797419</span>, </span><br><span class="line">  <span class="string">"exp"</span>: <span class="number">1448333419</span>, </span><br><span class="line">  <span class="string">"aud"</span>: <span class="string">"www.jwt.io"</span>, </span><br><span class="line">  <span class="string">"sub"</span>: <span class="string">"uid"</span>, </span><br><span class="line">  <span class="string">"nickname"</span>: <span class="string">"jwttest"</span>, </span><br><span class="line">  <span class="string">"username"</span>: <span class="string">"jwttest"</span>, </span><br><span class="line">  <span class="string">"scopes"</span>: [ <span class="string">"admin"</span>, <span class="string">"user"</span> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>iss：jwt 签发者；</li><li>sub：jwt 所面向的用户；</li><li>aud：接收 jwt 的一方；</li><li>exp：jwt 的过期时间，这个过期时间必须要大于签发时间，这是一个秒数；</li><li>nbf：定义在什么时间之前，该 jwt 都是不可用的；</li><li>iat：jwt 的签发时间。<br>上面的标准中注册的声明中常用的有 exp 和 nbf。</li></ul><p>其他还有：</p><ul><li>nbf (Not Before)：如果当前时间在nbf里的时间之前，则Token不被接受；一般都会留一些余地，比如几分钟；，是否使用是可选的；</li><li>jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。</li></ul><p>(2) 公共声明</p><p>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密，如 {“id”, username: “panda”, adress: “Beijing”}，会将这个对象转成 base64。</p><p>(3) 私有声明</p><p>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为 base64 是对称解密的，意味着该部分信息可以归类为明文信息。</p><p>3、Signature [签名]<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据alg算法与私有秘钥进行加密得到的签名字串；</span></span><br><span class="line"><span class="comment">// 这一段是最重要的敏感信息，只能在服务端解密；</span></span><br><span class="line"></span><br><span class="line">HMACSHA256(  </span><br><span class="line">    base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">    base64UrlEncode(payload),</span><br><span class="line">    your<span class="number">-256</span>-bit-secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p><ul><li>header (base64后的)</li><li>payload (base64后的)</li><li>secret</li></ul><p>Signature 这一部分指将 Header 和 Payload 通过密钥 secret 和加盐算法进行加密后生成的签名，secret，密钥保存在服务端，不会发送给任何人，所以 JWT 的传输方式是很安全的。</p><p>最后将三部分使用 . 连接成字符串，就是要返回给浏览器的 token 浏览器一般会将这个 token 存储在 localStorge 以备其他需要验证用户的请求使用。</p><p>将上面的编码后的字符串都用句号.连接在一起（头部在前），就形成了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImxpYmluIiwiaWQiOiI1YzE3MGRmYjU5NjZmOTA2MGQyOTBmZTgiLCJpYXQiOjE1NDUwMTQ4MzUsImV4cCI6MTU0NTEwMTIzNX0.FDWkBfas2b-jvXWuzedlNlhZmT4vQBey1w9q8vu2B8Q</span><br></pre></td></tr></table></figure></p><p><img src="/2018/11/02/JWT入门与实战/2.webp" alt=""></p><h3 id="JWT-使用场景"><a href="#JWT-使用场景" class="headerlink" title="JWT 使用场景"></a>JWT 使用场景</h3><p>JWT的主要优势在于使用无状态、可扩展的方式处理应用中的用户会话。服务端可以通过内嵌的声明信息，很容易地获取用户的会话信息，而不需要去访问用户或会话的数据库。在一个分布式的面向服务的框架中，这一点非常有用。</p><p>但是，如果系统中需要使用黑名单实现长期有效的token刷新机制，这种无状态的优势就不明显了。</p><blockquote><p>优点:快速开发，json格式简单，不需要cookie JSON在移动端的广泛应用 不依赖于社交登录 相对简单的概念理解，同session相比，性能更好一些，省去了处理分布session的问题；</p></blockquote><ul><li>支持跨域访问: Cookie是不允许垮域访问的，这一点对Token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输.</li><li>无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</li><li>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可.</li><li>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</li><li>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</li><li>CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。- 性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.</li><li>不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理.</li><li>基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.</li></ul><blockquote><p>缺点:Token有长度限制 Token不能撤销 需要token有失效时间限制(exp)</p></blockquote><p>经过上面对 JWT 的叙述可能还是没有完全的理解什么是 JWT，具体怎么操作的，我们接下来实现一个小的案例，为了方便，服务端使用 express 框架，数据库使用 mongo 来存储用户信息，前端使用 Vue 来实现，做一个登录页登录后进入订单页验证 token 的功能。</p><h3 id="Vue-Koa2-JWT-完整代码"><a href="#Vue-Koa2-JWT-完整代码" class="headerlink" title="Vue+Koa2+JWT 完整代码"></a>Vue+Koa2+JWT <a href="https://github.com/libin1991/webpack4-vue-more-page-cli/tree/master/vue%2Bkoa2%2Bjwt%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%20%2B%20todolist%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5" target="_blank" rel="noopener">完整代码</a></h3><p><img src="/2018/11/02/JWT入门与实战/3.webp" alt=""></p><h4 id="jsonwebtoken"><a href="#jsonwebtoken" class="headerlink" title="jsonwebtoken"></a>jsonwebtoken</h4><h5 id="jwt-sign-payload-secretOrPrivateKey-options-callback"><a href="#jwt-sign-payload-secretOrPrivateKey-options-callback" class="headerlink" title="jwt.sign(payload, secretOrPrivateKey, [options, callback])"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])</h5><ul><li>（异步）如果提供回调，则使用err或JWT 调用回调。</li><li>（同步）将JsonWebToken返回为字符串。</li></ul><p>payload必须是一个object, buffer或者string。请注意， exp只有当payload是object字面量时才可以设置。<br>secretOrPrivateKey 是包含HMAC算法的密钥或RSA和ECDSA的PEM编码私钥的string或buffer。</p><p>options:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">algorithm：加密算法（默认值：HS256）</span><br><span class="line">expiresIn：以秒表示或描述时间跨度zeit / ms的字符串。如60，&quot;2 days&quot;，&quot;10h&quot;，&quot;7d&quot;，Expiration time，过期时间</span><br><span class="line">notBefore：以秒表示或描述时间跨度zeit / ms的字符串。如：60，&quot;2days&quot;，&quot;10h&quot;，&quot;7d&quot;</span><br><span class="line">audience：Audience，观众</span><br><span class="line">issuer：Issuer，发行者</span><br><span class="line">jwtid：JWT ID</span><br><span class="line">subject：Subject，主题</span><br><span class="line">noTimestamp</span><br><span class="line">header</span><br></pre></td></tr></table></figure></p><p>如果payload不是buffer或string，它将被强制转换为使用的字符串JSON.stringify()。<br>在expiresIn，notBefore，audience，subject，issuer没有默认值时。也可以直接在payload中用exp，nbf，aud，sub和iss分别表示，但是你不能在这两个地方同时设置。<br>请记住exp，nbf，iat是NumericDate类型。<br>生成的jwts通常会包含一个iat值除非指定了noTimestamp。如果iat插入payload中，则将使用它来代替实际的时间戳来计算其他事情，诸如options.expiresIn给定一个exp这样的时间间隔。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sign with default (HMAC SHA256)</span></span><br><span class="line"><span class="keyword">var</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>);</span><br><span class="line"><span class="keyword">var</span> token = jwt.sign(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;, <span class="string">'shhhhh'</span>);</span><br><span class="line"><span class="comment">//backdate a jwt 30 seconds</span></span><br><span class="line"><span class="keyword">var</span> older_token = jwt.sign(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">iat</span>: <span class="built_in">Math</span>.floor(<span class="built_in">Date</span>.now() / <span class="number">1000</span>) - <span class="number">30</span> &#125;, <span class="string">'shhhhh'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sign with RSA SHA256</span></span><br><span class="line"><span class="keyword">var</span> cert = fs.readFileSync(<span class="string">'private.key'</span>);  <span class="comment">// get private key</span></span><br><span class="line"><span class="keyword">var</span> token = jwt.sign(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;, cert, &#123; <span class="attr">algorithm</span>: <span class="string">'RS256'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sign asynchronously</span></span><br><span class="line">jwt.sign(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;, cert, &#123; <span class="attr">algorithm</span>: <span class="string">'RS256'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, token</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(token);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//签署1小时期限的token:</span></span><br><span class="line">jwt.sign(&#123;</span><br><span class="line">  exp: <span class="built_in">Math</span>.floor(<span class="built_in">Date</span>.now() / <span class="number">1000</span>) + (<span class="number">60</span> * <span class="number">60</span>),</span><br><span class="line">  data: <span class="string">'foobar'</span></span><br><span class="line">&#125;, <span class="string">'secret'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用此库生成令牌的另一种方法是:</span></span><br><span class="line">jwt.sign(&#123;</span><br><span class="line">  data: <span class="string">'foobar'</span></span><br><span class="line">&#125;, <span class="string">'secret'</span>, &#123; <span class="attr">expiresIn</span>: <span class="number">60</span> * <span class="number">60</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//or even better:</span></span><br><span class="line"></span><br><span class="line">jwt.sign(&#123;</span><br><span class="line">  data: <span class="string">'foobar'</span></span><br><span class="line">&#125;, <span class="string">'secret'</span>, &#123; <span class="attr">expiresIn</span>: <span class="string">'1h'</span> &#125;);</span><br></pre></td></tr></table></figure></p><h5 id="jwt-verify（token，secretOrPublicKey，-options，callback-）"><a href="#jwt-verify（token，secretOrPublicKey，-options，callback-）" class="headerlink" title="jwt.verify（token，secretOrPublicKey，[options，callback]）"></a>jwt.verify（token，secretOrPublicKey，[options，callback]）</h5><p>验证token的合法性</p><h5 id="wt-decode（token-，options-）"><a href="#wt-decode（token-，options-）" class="headerlink" title="wt.decode（token [，options]）"></a>wt.decode（token [，options]）</h5><p>（同步）返回解码没有验证签名是否有效的payload。<br>警告：这不会验证签名是否有效。你应该不为不可信的消息使用此。你最有可能要使用jwt.verify()。</p><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">'../models/UserModels'</span>)</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">'jsonwebtoken'</span>)</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'../config/config'</span>)</span><br><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">'md5'</span>)</span><br><span class="line"><span class="comment">// 密码使用md5加密存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注册</span></span><br><span class="line"><span class="keyword">let</span> addUser =  <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;username, password&#125; = ctx.request.body</span><br><span class="line">  password = md5(password) <span class="comment">// md5加密处理</span></span><br><span class="line">  <span class="keyword">await</span> user.addUser(username,password) <span class="comment">// 异步处理,因为ctx.body不支持异步回调</span></span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      data,</span><br><span class="line">      type: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      data,</span><br><span class="line">      type: <span class="number">0</span> <span class="comment">// 有毛病 type字段我定于或者不定义 都是type:1 莫名其妙</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//登录</span></span><br><span class="line"><span class="keyword">let</span> verifyUser = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;username, password&#125; = ctx.request.body</span><br><span class="line">  password = md5(password)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">await</span> user.verifyUser(username, password)</span><br><span class="line">  .then(<span class="function">(<span class="params">data</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;text, id&#125; = data</span><br><span class="line">    <span class="comment">// 处理token  </span></span><br><span class="line">    <span class="keyword">let</span> token = jwt.sign(&#123;</span><br><span class="line">      username,</span><br><span class="line">      id</span><br><span class="line">    &#125;, config.secretOrPublicKey, &#123;</span><br><span class="line">      expiresIn: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> <span class="comment">// 24小时过期</span></span><br><span class="line">    &#125;)</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      text,</span><br><span class="line">      token,</span><br><span class="line">      type: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      data,</span><br><span class="line">      type: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">let</span> verification = <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; token &#125; = ctx.request.body</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> jwt.verify(token, config.secretOrPublicKey, (err, decoded)=&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          data: <span class="string">'登录信息失效'</span>,</span><br><span class="line">          type: <span class="number">0</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (decoded) &#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          type: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">      data: <span class="string">'登录信息出错'</span>,</span><br><span class="line">      type: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  addUser,</span><br><span class="line">  verifyUser,</span><br><span class="line">  verification</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成Token<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jwt.sign(&#123;</span><br><span class="line">      username,</span><br><span class="line">      id</span><br><span class="line">    &#125;, config.secretOrPublicKey, &#123;</span><br><span class="line">      expiresIn: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> <span class="comment">// 24小时过期</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>解析Token<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jwt.verify(token, config.secretOrPublicKey, (err, decoded)=&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          data: &apos;登录信息失效&apos;,</span><br><span class="line">          type: 0 </span><br><span class="line">        &#125;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      if (decoded) &#123;</span><br><span class="line">        ctx.body = &#123;</span><br><span class="line">          type: 1</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> token = localStorage.getItem(<span class="string">'token'</span>) <span class="comment">// 获取token</span></span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">'login'</span> &amp;&amp; to.name !== <span class="string">'todoList'</span>) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (to.name == <span class="string">'login'</span>) &#123; <span class="comment">// 假如登录 判断token是不是存在 存在让他跳转到主页面</span></span><br><span class="line">    verification(token, next)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.data.type) &#123; <span class="comment">// type 为1 直接跳过登录</span></span><br><span class="line">        Message(&#123;</span><br><span class="line">          showClose: <span class="literal">true</span>,</span><br><span class="line">          message: <span class="string">'欢迎回来'</span></span><br><span class="line">        &#125;);</span><br><span class="line">        next(<span class="string">'/todolist'</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (to.name == <span class="string">'todoList'</span>) &#123;</span><br><span class="line">    verification(token, next)</span><br><span class="line">    .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.data.type) &#123;</span><br><span class="line">        <span class="comment">// type 为1说明token没有失效</span></span><br><span class="line">        <span class="comment">// 跳转到主页面</span></span><br><span class="line">        next()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// token失效 强制定位到登录页面</span></span><br><span class="line">        <span class="keyword">if</span> (token === <span class="literal">null</span>) &#123; <span class="comment">// 说明从来没有登陆过</span></span><br><span class="line">          Message(&#123;</span><br><span class="line">            showClose: <span class="literal">true</span>,</span><br><span class="line">            message: <span class="string">'您还没有登录'</span>,</span><br><span class="line">            type: <span class="string">'warning'</span></span><br><span class="line">          &#125;)</span><br><span class="line">          next(<span class="string">'/login'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          Message.error(<span class="string">'登录信息失效'</span>)</span><br><span class="line">          next(<span class="string">'/login'</span>)</span><br><span class="line">          localStorage.removeItem(<span class="string">'token'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (to.meta.title) &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = to.meta.title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="keyword">let</span> verification = <span class="function">(<span class="params">token, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.post(<span class="string">'/api/verification'</span>, &#123; token &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端解析Token<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt <span class="keyword">from</span> <span class="string">'jsonwebtoken'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">let</span> token = localStorage.getItem(<span class="string">'token'</span>)</span><br><span class="line">    <span class="keyword">let</span> Payload = jwt.decode(token)</span><br><span class="line">    <span class="keyword">this</span>.username = Payload.username <span class="comment">// 解密用户名</span></span><br><span class="line">    <span class="keyword">this</span>._id = Payload.id</span><br><span class="line">    <span class="keyword">this</span>.getData() <span class="comment">// 获取待完成时间</span></span><br><span class="line">    <span class="keyword">this</span>.getfulfilData()</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Koa2对MongoDB连接的单例模式的封装</title>
      <link href="/2018/11/01/Koa2%E5%AF%B9MongoDB%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B0%81%E8%A3%85/"/>
      <url>/2018/11/01/Koa2%E5%AF%B9MongoDB%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>单例模式是最常用到的设计模式之一，熟悉设计模式的朋友对单例模式都不会陌生。一般介绍单例模式的书籍都会提到 饿汉式 和 懒汉式 这两种实现方式。但是除了这两种方式，本文还会介绍其他几种实现单例的方式，让我们来一起看看吧。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。</p><p>许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p><h2 id="基本的实现思路"><a href="#基本的实现思路" class="headerlink" title="基本的实现思路"></a>基本的实现思路</h2><p>单例模式要求类能够有返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用<code>ES6 class static</code>这个关键字）。</p><p>单例的实现主要是通过以下两个步骤：</p><blockquote><p>将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；</p></blockquote><blockquote><p>在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。</p></blockquote><h2 id="单例模式特点："><a href="#单例模式特点：" class="headerlink" title="单例模式特点："></a>单例模式特点：</h2><p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p><p>单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new，可能会给其他开发人员造成困扰，特别是看不到源码的时候。</p><h2 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h2><ul><li>需要频繁的进行创建和销毁的对象；</li><li>创建对象时耗时过多或耗费资源过多，但又经常用到的对象；</li><li>工具类对象；</li><li>频繁访问数据库或文件的对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"></span><br><span class="line"> * http://mongodb.github.io/node-mongodb-native</span><br><span class="line"></span><br><span class="line"> * http://mongodb.github.io/node-mongodb-native/3.0/api/</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">//DB库</span><br><span class="line">var MongoDB=require(&apos;mongodb&apos;);</span><br><span class="line">var MongoClient =MongoDB.MongoClient;</span><br><span class="line">const ObjectID = MongoDB.ObjectID;</span><br><span class="line"></span><br><span class="line">var Config=require(&apos;./config.js&apos;);</span><br><span class="line"></span><br><span class="line">class Db&#123;</span><br><span class="line"></span><br><span class="line">    static getInstance()&#123;   /*1、单例  多次实例化实例不共享的问题*/</span><br><span class="line"></span><br><span class="line">        if(!Db.instance)&#123;</span><br><span class="line">            Db.instance=new Db();</span><br><span class="line">        &#125;</span><br><span class="line">        return  Db.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor()&#123;</span><br><span class="line"></span><br><span class="line">        this.dbClient=&apos;&apos;; /*属性 放db对象*/</span><br><span class="line">        this.connect();   /*实例化的时候就连接数据库*/</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connect()&#123;  /*连接数据库*/</span><br><span class="line">      let _that=this;</span><br><span class="line">      return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">          if(!_that.dbClient)&#123;         /*1、解决数据库多次连接的问题*/</span><br><span class="line">              MongoClient.connect(Config.dbUrl,(err,client)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">                  if(err)&#123;</span><br><span class="line">                      reject(err)</span><br><span class="line"></span><br><span class="line">                  &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                      _that.dbClient=client.db(Config.dbName);</span><br><span class="line">                      resolve(_that.dbClient)</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line"></span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              resolve(_that.dbClient);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find(collectionName,json)&#123;</span><br><span class="line"></span><br><span class="line">       return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">            this.connect().then((db)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">                var result=db.collection(collectionName).find(json);</span><br><span class="line"></span><br><span class="line">                result.toArray(function(err,docs)&#123;</span><br><span class="line"></span><br><span class="line">                    if(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    resolve(docs);</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    update(collectionName,json1,json2)&#123;</span><br><span class="line">        return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                this.connect().then((db)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">                    //db.user.update(&#123;&#125;,&#123;$set:&#123;&#125;&#125;)</span><br><span class="line">                    db.collection(collectionName).updateOne(json1,&#123;</span><br><span class="line">                        $set:json2</span><br><span class="line">                    &#125;,(err,result)=&gt;&#123;</span><br><span class="line">                        if(err)&#123;</span><br><span class="line">                            reject(err);</span><br><span class="line">                        &#125;else&#123;</span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line"></span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    insert(collectionName,json)&#123;</span><br><span class="line">        return new  Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            this.connect().then((db)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">                db.collection(collectionName).insertOne(json,function(err,result)&#123;</span><br><span class="line">                    if(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove(collectionName,json)&#123;</span><br><span class="line"></span><br><span class="line">        return new  Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">            this.connect().then((db)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">                db.collection(collectionName).removeOne(json,function(err,result)&#123;</span><br><span class="line">                    if(err)&#123;</span><br><span class="line">                        reject(err);</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    getObjectId(id)&#123;    /*mongodb里面查询 _id 把字符串转换成对象*/</span><br><span class="line"></span><br><span class="line">        return new ObjectID(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports=Db.getInstance();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Koa </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue-cli3通用多页面脚手架</title>
      <link href="/2018/10/29/Vue-cli3%E9%80%9A%E7%94%A8%E5%A4%9A%E9%A1%B5%E9%9D%A2%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
      <url>/2018/10/29/Vue-cli3%E9%80%9A%E7%94%A8%E5%A4%9A%E9%A1%B5%E9%9D%A2%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>目前 vue-cli3 生成的配置是做单页面的，然而，我们有时也会有多页面的需求 。比如我们最常见的一个项目跑多个独立的小型的H5页面，这些页面不可能每一次都开一个新项目.但是在实际的项目中，我们需要这样的脚手架，参考了很多大牛的脚手架，这里提供了一种我的单页面脚手架转换为多页面脚手架的方案，供大家参考。</p><h3 id="要求："><a href="#要求：" class="headerlink" title="要求："></a>要求：</h3><ul><li>1.首页显示项目所有的H5链接列表；</li><li>2.支持小型本地收据mock,方便本地测试接口【我个人不推荐，建议mock和项目分离】</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>使用vue-cli生成一个你需要的单页面项目脚手架，然后我们就可以为所欲为了，目录我就不说明了，默认大家都知道。</p><p><img src="/2018/10/29/Vue-cli3通用多页面脚手架/1.webp" alt=""></p><blockquote><p>每一次新开的页面都在pages里面起一个文件夹,<strong>文件夹名字就是H5页面名字,入口文件是文件夹的index.html和index.js</strong>。</p></blockquote><p>修改vue.config.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">let path = require(&apos;path&apos;)</span><br><span class="line">let glob = require(&apos;glob&apos;)</span><br><span class="line">let mock = require(&apos;./src/mock/index.json&apos;);</span><br><span class="line">var BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line">//配置pages多页面获取当前文件夹下的html和js</span><br><span class="line">function getEntry(globPath) &#123;</span><br><span class="line">let entries = &#123;&#125;;</span><br><span class="line">glob.sync(globPath).forEach(function(entry) &#123;</span><br><span class="line">var tmp = entry.split(&apos;/&apos;).splice(-3);</span><br><span class="line">entries[tmp[1]] = &#123;</span><br><span class="line">entry: &apos;src/&apos; + tmp[0] + &apos;/&apos; + tmp[1] + &apos;/&apos; + &apos;index.js&apos;,</span><br><span class="line">template: &apos;src/&apos; + tmp[0] + &apos;/&apos; + tmp[1] + &apos;/&apos; + &apos;index.html&apos;,</span><br><span class="line">filename: tmp[1]</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line">return entries;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pages = getEntry(&apos;./src/pages/**?/*.html&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">lintOnSave: false, </span><br><span class="line">baseUrl: process.env.NODE_ENV === &quot;production&quot; ? &apos;https://www.baidu.com/&apos; : &apos;/&apos;,</span><br><span class="line">productionSourceMap: false,</span><br><span class="line">pages,</span><br><span class="line">devServer: &#123;</span><br><span class="line">index: &apos;/&apos;, </span><br><span class="line">open: process.platform === &apos;darwin&apos;,</span><br><span class="line">host: &apos;&apos;,</span><br><span class="line">port: 9527,</span><br><span class="line">https: false,</span><br><span class="line">hotOnly: false,</span><br><span class="line">proxy: &#123;</span><br><span class="line">&apos;/xrf/&apos;: &#123;</span><br><span class="line">target: &apos;http://reg.tool.hexun.com/&apos;,</span><br><span class="line">changeOrigin: true,</span><br><span class="line">pathRewrite: &#123;</span><br><span class="line">&apos;^/xrf&apos;: &apos;&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;, // 设置代理</span><br><span class="line">before: app =&gt; &#123;     </span><br><span class="line">app.get(&apos;/&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">for(let i in pages)&#123;</span><br><span class="line">res.write(`&lt;a target=&quot;_self&quot; href=&quot;/$&#123;i&#125;&quot;&gt;/$&#123;i&#125;&lt;/a&gt;&lt;/br&gt;`);</span><br><span class="line">&#125;</span><br><span class="line">res.end()</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&apos;/goods/list&apos;, (req, res, next) =&gt; &#123;  //mock数据</span><br><span class="line">res.status(299).json(mock)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">chainWebpack: config =&gt; &#123;</span><br><span class="line">config.module</span><br><span class="line">.rule(&apos;images&apos;)</span><br><span class="line">.use(&apos;url-loader&apos;)</span><br><span class="line">.loader(&apos;url-loader&apos;)</span><br><span class="line">.tap(options =&gt; &#123;</span><br><span class="line">// 修改它的选项...</span><br><span class="line">options.limit = 100</span><br><span class="line">return options</span><br><span class="line">&#125;)</span><br><span class="line">Object.keys(pages).forEach(entryName =&gt; &#123;</span><br><span class="line">config.plugins.delete(`prefetch-$&#123;entryName&#125;`);</span><br><span class="line">&#125;);</span><br><span class="line">if(process.env.NODE_ENV === &quot;production&quot;) &#123;</span><br><span class="line">config.plugin(&quot;extract-css&quot;).tap(() =&gt; [&#123;</span><br><span class="line">path: path.join(__dirname, &quot;./dist&quot;),</span><br><span class="line">filename: &quot;css/[name].[contenthash:8].css&quot;</span><br><span class="line">&#125;]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">configureWebpack: config =&gt; &#123;</span><br><span class="line">//if(process.env.NODE_ENV === &quot;production&quot;) &#123;</span><br><span class="line">//config.output = &#123;</span><br><span class="line">//path: path.join(__dirname, &quot;./dist&quot;),</span><br><span class="line">//filename: &quot;js/[name].[contenthash:8].js&quot;</span><br><span class="line">//&#125;;</span><br><span class="line">//&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>启动项目，显示项目所有H5连接</p><p><img src="/2018/10/29/Vue-cli3通用多页面脚手架/2.webp" alt=""></p><p>最主要的是修改：</p><blockquote><p><strong> before第一个参数express实例。</strong></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">before: app =&gt; &#123;     </span><br><span class="line">app.get(&apos;/&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">for(let i in pages)&#123;    //遍历项目链接</span><br><span class="line">res.write(`&lt;a target=&quot;_self&quot; href=&quot;/$&#123;i&#125;&quot;&gt;/$&#123;i&#125;&lt;/a&gt;&lt;/br&gt;`);</span><br><span class="line">&#125;</span><br><span class="line">res.end()</span><br><span class="line">&#125;);</span><br><span class="line">app.get(&apos;/goods/list&apos;, (req, res, next) =&gt; &#123;  //mock数据</span><br><span class="line">res.status(299).json(mock)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="vue-cli3-全面配置-持续更新"><a href="#vue-cli3-全面配置-持续更新" class="headerlink" title="vue-cli3 全面配置(持续更新)"></a>vue-cli3 全面配置(持续更新)</h3><p><span id="top">目录</span></p><ul><li><a href="#env">√ 配置多环境变量</a></li><li><a href="#base">√ 配置基础 vue.config.js</a></li><li><a href="#proxy">√ 配置 proxy 跨域</a></li><li><a href="#hmr">√ 修复 HMR(热更新)失效</a></li><li><a href="#lazyloading">√ 修复 Lazy loading routes Error： Cyclic dependency</a></li><li><a href="#alias">√ 添加别名</a></li><li><a href="#removecss">√ 去除多余无效的 css</a></li><li><a href="#analyze">√ 添加打包分析</a></li><li><a href="#externals">√ 配置 externals</a></li><li><a href="#log">√ 去掉 console.log</a></li><li><a href="#gzip">√ 开启 gzip 压缩</a></li><li><a href="#globalscss">√ 为 sass 提供全局样式，以及全局变量</a></li><li><a href="#ie">√ 添加 IE 兼容</a></li><li><a href="#alioss">√ 文件上传 ali oss</a></li><li><a href="#allconfig">√ 完整依赖</a></li></ul><h3 id="☞-配置多环境变量"><a href="#☞-配置多环境变量" class="headerlink" title="☞ 配置多环境变量"></a><span id="env">☞ 配置多环境变量</span></h3><p>&emsp;&emsp;通过在 package.json 里的 scripts 配置项中添加–mode xxx 来选择不同环境</p><p>&emsp;&emsp;在项目根目录中新建.env, .env.production, .env.analyz 等文件</p><p>&emsp;&emsp;只有以 VUE<em>APP</em> 开头的变量会被 webpack.DefinePlugin 静态嵌入到客户端侧的包中，代码中可以通过 process.env.VUE_APP_BASE_API 访问</p><p>&emsp;&emsp;NODE_ENV 和 BASE_URL 是两个特殊变量，在代码中始终可用</p><h5 id="env-serve-默认的环境变量"><a href="#env-serve-默认的环境变量" class="headerlink" title=".env serve 默认的环境变量"></a>.env serve 默认的环境变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = &apos;development&apos;</span><br><span class="line">VUE_APP_BASE_API = &apos;https://demo.cn/api&apos;</span><br></pre></td></tr></table></figure><h5 id="env-production-build-默认的环境变量"><a href="#env-production-build-默认的环境变量" class="headerlink" title=".env.production build 默认的环境变量"></a>.env.production build 默认的环境变量</h5><p>&emsp;&emsp;如果开启 ali oss,VUE_APP_SRC 配置为 ali oss 资源 url 前缀，如：’<a href="https://staven.oss-cn-hangzhou.aliyuncs.com/demo&#39;" target="_blank" rel="noopener">https://staven.oss-cn-hangzhou.aliyuncs.com/demo&#39;</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = &apos;production&apos;</span><br><span class="line"></span><br><span class="line">VUE_APP_BASE_API = &apos;https://demo.com/api&apos;</span><br><span class="line">VUE_APP_SRC = &apos;/&apos;</span><br><span class="line"></span><br><span class="line">ACCESS_KEY_ID = &apos;&apos;</span><br><span class="line">ACCESS_KEY_SECRET = &apos;&apos;</span><br><span class="line">REGION = &apos;oss-cn-hangzhou&apos;</span><br><span class="line">BUCKET = &apos;staven&apos;</span><br><span class="line">PREFIX = &apos;demo&apos;</span><br></pre></td></tr></table></figure><h5 id="env-analyz-用于-webpack-bundle-analyzer-打包分析"><a href="#env-analyz-用于-webpack-bundle-analyzer-打包分析" class="headerlink" title=".env.analyz 用于 webpack-bundle-analyzer 打包分析"></a>.env.analyz 用于 webpack-bundle-analyzer 打包分析</h5><p>&emsp;&emsp;如果开启 ali oss,VUE_APP_SRC 配置为 ali oss 资源 url 前缀，如：’<a href="https://staven.oss-cn-hangzhou.aliyuncs.com/demo&#39;" target="_blank" rel="noopener">https://staven.oss-cn-hangzhou.aliyuncs.com/demo&#39;</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = &apos;production&apos;</span><br><span class="line">IS_ANALYZ = &apos;analyz&apos;</span><br><span class="line"></span><br><span class="line">VUE_APP_BASE_API = &apos;https://demo.com/api&apos;</span><br><span class="line">VUE_APP_SRC = &apos;/&apos;</span><br><span class="line"></span><br><span class="line">ACCESS_KEY_ID = &apos;&apos;</span><br><span class="line">ACCESS_KEY_SECRET = &apos;&apos;</span><br><span class="line">REGION = &apos;oss-cn-hangzhou&apos;</span><br><span class="line">BUCKET = &apos;staven&apos;</span><br><span class="line">PREFIX = &apos;demo&apos;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;修改 package.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">  &quot;analyz&quot;: &quot;vue-cli-service build --mode analyz&quot;,</span><br><span class="line">  &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-配置基础-vue-config-js"><a href="#☞-配置基础-vue-config-js" class="headerlink" title="☞ 配置基础 vue.config.js"></a><span id="base">☞ 配置基础 vue.config.js</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const IS_PROD = [&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  baseUrl: &apos;./&apos;, // 默认&apos;/&apos;，部署应用包时的基本 URL</span><br><span class="line">  outputDir: process.env.outputDir || &apos;dist&apos;, // &apos;dist&apos;, 生产环境构建文件的目录</span><br><span class="line">  assetsDir: &apos;&apos;,  // 相对于outputDir的静态资源(js、css、img、fonts)目录</span><br><span class="line">  lintOnSave: false,</span><br><span class="line">  runtimeCompiler: true, // 是否使用包含运行时编译器的 Vue 构建版本</span><br><span class="line">  productionSourceMap: false,  // 生产环境的 source map</span><br><span class="line">  parallel: require(&apos;os&apos;).cpus().length &gt; 1,</span><br><span class="line">  pwa: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-配置-proxy-跨域"><a href="#☞-配置-proxy-跨域" class="headerlink" title="☞ 配置 proxy 跨域"></a><span id="proxy">☞ 配置 proxy 跨域</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const IS_PROD = [&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        // overlay: &#123;</span><br><span class="line">        //   warnings: true,</span><br><span class="line">        //   errors: true</span><br><span class="line">        // &#125;,</span><br><span class="line">        open: IS_PROD,</span><br><span class="line">        host: &apos;0.0.0.0&apos;,</span><br><span class="line">        port: 8000,</span><br><span class="line">        https: false,</span><br><span class="line">        hotOnly: false,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">          &apos;/api&apos;: &#123;</span><br><span class="line">            target: process.env.VUE_APP_BASE_API || &apos;http://127.0.0.1:8080&apos;,</span><br><span class="line">            changeOrigin: true</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-修复-HMR-热更新-失效"><a href="#☞-修复-HMR-热更新-失效" class="headerlink" title="☞ 修复 HMR(热更新)失效"></a><span id="hmr">☞ 修复 HMR(热更新)失效</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        // 修复HMR</span><br><span class="line">        config.resolve.symlinks(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-修复-Lazy-loading-routes-Error：-Cyclic-dependency-https-github-com-vuejs-vue-cli-issues-1669"><a href="#☞-修复-Lazy-loading-routes-Error：-Cyclic-dependency-https-github-com-vuejs-vue-cli-issues-1669" class="headerlink" title="☞ 修复 Lazy loading routes Error： Cyclic dependency https://github.com/vuejs/vue-cli/issues/1669"></a><span id="lazyloading">☞ 修复 Lazy loading routes Error： Cyclic dependency</span> <a href="https://github.com/vuejs/vue-cli/issues/1669" target="_blank" rel="noopener">https://github.com/vuejs/vue-cli/issues/1669</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        config.plugin(&apos;html&apos;).tap(args =&gt; &#123;</span><br><span class="line">            args[0].chunksSortMode = &apos;none&apos;;</span><br><span class="line">            return args;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-添加别名"><a href="#☞-添加别名" class="headerlink" title="☞ 添加别名"></a><span id="alias">☞ 添加别名</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const path =  require(&apos;path&apos;);</span><br><span class="line">const resolve = (dir) =&gt; path.join(__dirname, dir);</span><br><span class="line">const IS_PROD = [&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        // 添加别名</span><br><span class="line">        config.resolve.alias</span><br><span class="line">          .set(&apos;@&apos;, resolve(&apos;src&apos;))</span><br><span class="line">          .set(&apos;assets&apos;, resolve(&apos;src/assets&apos;))</span><br><span class="line">          .set(&apos;components&apos;, resolve(&apos;src/components&apos;))</span><br><span class="line">          .set(&apos;layout&apos;, resolve(&apos;src/layout&apos;))</span><br><span class="line">          .set(&apos;base&apos;, resolve(&apos;src/base&apos;))</span><br><span class="line">          .set(&apos;static&apos;, resolve(&apos;src/static&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-去除多余无效的-css"><a href="#☞-去除多余无效的-css" class="headerlink" title="☞ 去除多余无效的 css"></a><span id="removecss">☞ 去除多余无效的 css</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev glob-all purgecss-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const PurgecssPlugin = require(&apos;purgecss-webpack-plugin&apos;);</span><br><span class="line">const glob = require(&apos;glob-all&apos;);</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (IS_PROD) &#123;</span><br><span class="line">            const plugins = [];</span><br><span class="line">            plugins.push(</span><br><span class="line">                new PurgecssPlugin(&#123;</span><br><span class="line">                    paths: glob.sync([</span><br><span class="line">                    path.join(__dirname, &apos;./src/index.html&apos;),</span><br><span class="line">                    path.join(__dirname, &apos;./**/*.vue&apos;),</span><br><span class="line">                    path.join(__dirname, &apos;./src/**/*.js&apos;)</span><br><span class="line">                    ])</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">            config.plugins = [</span><br><span class="line">                ...config.plugins,</span><br><span class="line">                ...plugins</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-添加打包分析"><a href="#☞-添加打包分析" class="headerlink" title="☞ 添加打包分析"></a><span id="analyze">☞ 添加打包分析</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&apos;webpack-bundle-analyzer&apos;).BundleAnalyzerPlugin;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    chainWebpack: config =&gt; &#123;</span><br><span class="line">        // 打包分析</span><br><span class="line">        if (process.env.IS_ANALYZ) &#123;</span><br><span class="line">          config.plugin(&apos;webpack-report&apos;)</span><br><span class="line">            .use(BundleAnalyzerPlugin, [&#123;</span><br><span class="line">              analyzerMode: &apos;static&apos;,</span><br><span class="line">            &#125;]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-配置-externals"><a href="#☞-配置-externals" class="headerlink" title="☞ 配置 externals"></a><span id="externals">☞ 配置 externals</span></h3><p>&emsp;&emsp;防止将某些 import 的包(package)打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些扩展依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        config.externals = &#123;</span><br><span class="line">          &apos;vue&apos;: &apos;Vue&apos;,</span><br><span class="line">          &apos;element-ui&apos;: &apos;ELEMENT&apos;,</span><br><span class="line">          &apos;vue-router&apos;: &apos;VueRouter&apos;,</span><br><span class="line">          &apos;vuex&apos;: &apos;Vuex&apos;,</span><br><span class="line">          &apos;axios&apos;: &apos;axios&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-去掉-console-log"><a href="#☞-去掉-console-log" class="headerlink" title="☞ 去掉 console.log"></a><span id="log">☞ 去掉 console.log</span></h3><h5 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const UglifyJsPlugin = require(&apos;uglifyjs-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (IS_PROD) &#123;</span><br><span class="line">            const plugins = [];</span><br><span class="line">            plugins.push(</span><br><span class="line">                new UglifyJsPlugin(&#123;</span><br><span class="line">                    uglifyOptions: &#123;</span><br><span class="line">                        compress: &#123;</span><br><span class="line">                            warnings: false,</span><br><span class="line">                            drop_console: true,</span><br><span class="line">                            drop_debugger: false,</span><br><span class="line">                            pure_funcs: [&apos;console.log&apos;]//移除console</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    sourceMap: false,</span><br><span class="line">                    parallel: true</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">            config.plugins = [</span><br><span class="line">                ...config.plugins,</span><br><span class="line">                ...plugins</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法二：使用-babel-plugin-transform-remove-console-插件"><a href="#方法二：使用-babel-plugin-transform-remove-console-插件" class="headerlink" title="方法二：使用 babel-plugin-transform-remove-console 插件"></a>方法二：使用 babel-plugin-transform-remove-console 插件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev babel-plugin-transform-remove-console</span><br></pre></td></tr></table></figure><p>在 babel.config.js 中配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const plugins = [];</span><br><span class="line">if([&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV)) &#123;</span><br><span class="line">  plugins.push(&quot;transform-remove-console&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [[&quot;@vue/app&quot;,&#123;&quot;useBuiltIns&quot;: &quot;entry&quot;&#125;]],</span><br><span class="line">  plugins: plugins</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-开启-gzip-压缩"><a href="#☞-开启-gzip-压缩" class="headerlink" title="☞ 开启 gzip 压缩"></a><span id="gzip">☞ 开启 gzip 压缩</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev compression-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);</span><br><span class="line">const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (IS_PROD) &#123;</span><br><span class="line">            const plugins = [];</span><br><span class="line">            plugins.push(</span><br><span class="line">                new CompressionWebpackPlugin(&#123;</span><br><span class="line">                    filename: &apos;[path].gz[query]&apos;,</span><br><span class="line">                    algorithm: &apos;gzip&apos;,</span><br><span class="line">                    test: productionGzipExtensions,</span><br><span class="line">                    threshold: 10240,</span><br><span class="line">                    minRatio: 0.8</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">            config.plugins = [</span><br><span class="line">                ...config.plugins,</span><br><span class="line">                ...plugins</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;还可以开启比 gzip 体验更好的 Zopfli 压缩详见<a href="https://webpack.js.org/plugins/compression-webpack-plugin" target="_blank" rel="noopener">https://webpack.js.org/plugins/compression-webpack-plugin</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev @gfx/zopfli brotli-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const CompressionWebpackPlugin = require(&apos;compression-webpack-plugin&apos;);</span><br><span class="line">const zopfli = require(&quot;@gfx/zopfli&quot;);</span><br><span class="line">const BrotliPlugin = require(&quot;brotli-webpack-plugin&quot;);</span><br><span class="line">const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (IS_PROD) &#123;</span><br><span class="line">            const plugins = [];</span><br><span class="line">            plugins.push(</span><br><span class="line">                new CompressionWebpackPlugin(&#123;</span><br><span class="line">                    algorithm(input, compressionOptions, callback) &#123;</span><br><span class="line">                      return zopfli.gzip(input, compressionOptions, callback);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    compressionOptions: &#123;</span><br><span class="line">                      numiterations: 15</span><br><span class="line">                    &#125;,</span><br><span class="line">                    minRatio: 0.99,</span><br><span class="line">                    test: productionGzipExtensions</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">            plugins.push(</span><br><span class="line">                new BrotliPlugin(&#123;</span><br><span class="line">                    test: productionGzipExtensions,</span><br><span class="line">                    minRatio: 0.99</span><br><span class="line">                &#125;)</span><br><span class="line">            );</span><br><span class="line">            config.plugins = [</span><br><span class="line">                ...config.plugins,</span><br><span class="line">                ...plugins</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-为-sass-提供全局样式，以及全局变量"><a href="#☞-为-sass-提供全局样式，以及全局变量" class="headerlink" title="☞ 为 sass 提供全局样式，以及全局变量"></a><span id="globalscss">☞ 为 sass 提供全局样式，以及全局变量</span></h3><p>&emsp;&emsp;可以通过在 main.js 中 Vue.prototype.$src = process.env.VUE_APP_SRC;挂载环境变量中的配置信息，然后在js中使用$src 访问。</p><p>&emsp;&emsp;css 中可以使用注入 sass 变量访问环境变量中的配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    css: &#123;</span><br><span class="line">        modules: false,</span><br><span class="line">        extract: IS_PROD,</span><br><span class="line">        sourceMap: false,</span><br><span class="line">        loaderOptions: &#123;</span><br><span class="line">          sass: &#123;</span><br><span class="line">            // 向全局sass样式传入共享的全局变量</span><br><span class="line">            data: `@import &quot;~assets/scss/variables.scss&quot;;$src: &quot;$&#123;process.env.VUE_APP_SRC&#125;&quot;;`</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 scss 中引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.home &#123;</span><br><span class="line">    background: url($src + &apos;/images/500.png&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-添加-IE-兼容"><a href="#☞-添加-IE-兼容" class="headerlink" title="☞ 添加 IE 兼容"></a><span id="ie">☞ 添加 IE 兼容</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save @babel/polyfill</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在 main.js 中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &apos;@babel/polyfill&apos;;</span><br></pre></td></tr></table></figure><p>配置 babel.config.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const plugins = [];</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [[&quot;@vue/app&quot;,&#123;&quot;useBuiltIns&quot;: &quot;entry&quot;&#125;]],</span><br><span class="line">  plugins: plugins</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-文件上传-ali-oss"><a href="#☞-文件上传-ali-oss" class="headerlink" title="☞ 文件上传 ali oss"></a><span id="alioss">☞ 文件上传 ali oss</span></h3><p>&emsp;&emsp;开启文件上传 ali oss，需要将 baseUrl 改成 ali oss 资源 url 前缀,也就是修改 VUE_APP_SRC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev webpack-oss</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const AliOssPlugin = require(&apos;webpack-oss&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    configureWebpack: config =&gt; &#123;</span><br><span class="line">        if (IS_PROD) &#123;</span><br><span class="line">            const plugins = [];</span><br><span class="line">            // 上传文件到oss</span><br><span class="line">            if (process.env.ACCESS_KEY_ID || process.env.ACCESS_KEY_SECRET || process.env.REGION || process.env.BUCKET || process.env.PREFIX) &#123;</span><br><span class="line">                plugins.push(</span><br><span class="line">                    new AliOssPlugin(&#123;</span><br><span class="line">                        accessKeyId: process.env.ACCESS_KEY_ID,</span><br><span class="line">                        accessKeySecret: process.env.ACCESS_KEY_SECRET,</span><br><span class="line">                        region: process.env.REGION,</span><br><span class="line">                        bucket: process.env.BUCKET,</span><br><span class="line">                        prefix: process.env.PREFIX,</span><br><span class="line">                        exclude: /.*\.html$/,</span><br><span class="line">                        deleteAll: false</span><br><span class="line">                    &#125;)</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            config.plugins = [</span><br><span class="line">                ...config.plugins,</span><br><span class="line">                ...plugins</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="#top">▲ 回顶部</a></p><h3 id="☞-完整配置"><a href="#☞-完整配置" class="headerlink" title="☞ 完整配置"></a><span id="allconfig">☞ 完整配置</span></h3><ul><li>安装依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev compression-webpack-plugin babel-plugin-transform-remove-console  glob-all purgecss-webpack-plugin</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其他依赖(@gfx/zopfli、brotli-webpack-plugin、webpack-oss)根据需求选择安装</p><ul><li>环境配置</li></ul><p>.env</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = &apos;development&apos;</span><br><span class="line">VUE_APP_BASE_API = &apos;https://demo.cn/api&apos;</span><br></pre></td></tr></table></figure><p>.env.production</p><p>&emsp;&emsp;如果开启 ali oss,VUE_APP_SRC 配置为 ali oss 资源 url 前缀，如：’<a href="https://staven.oss-cn-hangzhou.aliyuncs.com/demo&#39;" target="_blank" rel="noopener">https://staven.oss-cn-hangzhou.aliyuncs.com/demo&#39;</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = &apos;production&apos;</span><br><span class="line"></span><br><span class="line">VUE_APP_BASE_API = &apos;https://demo.com/api&apos;</span><br><span class="line">VUE_APP_SRC = &apos;/&apos;</span><br><span class="line"></span><br><span class="line">ACCESS_KEY_ID = &apos;&apos;</span><br><span class="line">ACCESS_KEY_SECRET = &apos;&apos;</span><br><span class="line">REGION = &apos;oss-cn-hangzhou&apos;</span><br><span class="line">BUCKET = &apos;staven&apos;</span><br><span class="line">PREFIX = &apos;demo&apos;</span><br></pre></td></tr></table></figure><p>.env.analyz</p><p>&emsp;&emsp;如果开启 ali oss,VUE_APP_SRC 配置为 ali oss 资源 url 前缀，如：’<a href="https://staven.oss-cn-hangzhou.aliyuncs.com/demo&#39;" target="_blank" rel="noopener">https://staven.oss-cn-hangzhou.aliyuncs.com/demo&#39;</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV = &apos;production&apos;</span><br><span class="line">IS_ANALYZ = &apos;analyz&apos;</span><br><span class="line"></span><br><span class="line">VUE_APP_BASE_API = &apos;https://demo.com/api&apos;</span><br><span class="line">VUE_APP_SRC = VUE_APP_SRC = &apos;/&apos;</span><br><span class="line"></span><br><span class="line">ACCESS_KEY_ID = &apos;&apos;</span><br><span class="line">ACCESS_KEY_SECRET = &apos;&apos;</span><br><span class="line">REGION = &apos;oss-cn-hangzhou&apos;</span><br><span class="line">BUCKET = &apos;staven&apos;</span><br><span class="line">PREFIX = &apos;demo&apos;</span><br></pre></td></tr></table></figure><ul><li>package.json</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;serve&quot;: &quot;vue-cli-service serve&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;vue-cli-service build&quot;,</span><br><span class="line">    &quot;analyz&quot;: &quot;vue-cli-service build --mode analyz&quot;,</span><br><span class="line">    &quot;lint&quot;: &quot;vue-cli-service lint&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>babel.config.js</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const plugins = [];</span><br><span class="line">// if([&apos;production&apos;, &apos;prod&apos;].includes(process.env.NODE_ENV)) &#123;</span><br><span class="line">//   plugins.push(&quot;transform-remove-console&quot;)</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [[&quot;@vue/app&quot;,&#123;&quot;useBuiltIns&quot;: &quot;entry&quot;&#125;]],</span><br><span class="line">  plugins: plugins</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>vue.config.js</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line">const BundleAnalyzerPlugin = require(&quot;webpack-bundle-analyzer&quot;)</span><br><span class="line">  .BundleAnalyzerPlugin;</span><br><span class="line">const UglifyJsPlugin = require(&quot;uglifyjs-webpack-plugin&quot;);</span><br><span class="line">const CompressionWebpackPlugin = require(&quot;compression-webpack-plugin&quot;);</span><br><span class="line">// const zopfli = require(&quot;@gfx/zopfli&quot;);</span><br><span class="line">// const BrotliPlugin = require(&quot;brotli-webpack-plugin&quot;);</span><br><span class="line">const AliOssPlugin = require(&quot;webpack-oss&quot;);</span><br><span class="line"></span><br><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">const PurgecssPlugin = require(&quot;purgecss-webpack-plugin&quot;);</span><br><span class="line">const glob = require(&quot;glob-all&quot;);</span><br><span class="line"></span><br><span class="line">const resolve = dir =&gt; path.join(__dirname, dir);</span><br><span class="line">const IS_PROD = [&quot;production&quot;, &quot;prod&quot;].includes(process.env.NODE_ENV);</span><br><span class="line">const productionGzipExtensions = /\.(js|css|json|txt|html|ico|svg)(\?.*)?$/i;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  baseUrl: IS_PROD ? process.env.VUE_APP_SRC || &quot;/&quot; : &quot;./&quot;, // 默认&apos;/&apos;，部署应用包时的基本 URL</span><br><span class="line">  outputDir: process.env.outputDir || &quot;dist&quot;, // &apos;dist&apos;, 生产环境构建文件的目录</span><br><span class="line">  assetsDir: &quot;&quot;, // 相对于outputDir的静态资源(js、css、img、fonts)目录</span><br><span class="line">  lintOnSave: false,</span><br><span class="line">  runtimeCompiler: true, // 是否使用包含运行时编译器的 Vue 构建版本</span><br><span class="line">  productionSourceMap: false, // 生产环境的 source map</span><br><span class="line"></span><br><span class="line">  configureWebpack: config =&gt; &#123;</span><br><span class="line">    // cdn引用时配置externals</span><br><span class="line">    // config.externals = &#123;</span><br><span class="line">    //     &apos;vue&apos;: &apos;Vue&apos;,</span><br><span class="line">    //     &apos;element-ui&apos;: &apos;ELEMENT&apos;,</span><br><span class="line">    //     &apos;vue-router&apos;: &apos;VueRouter&apos;,</span><br><span class="line">    //     &apos;vuex&apos;: &apos;Vuex&apos;,</span><br><span class="line">    //     &apos;axios&apos;: &apos;axios&apos;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    if (IS_PROD) &#123;</span><br><span class="line">      const plugins = [];</span><br><span class="line"></span><br><span class="line">      plugins.push(</span><br><span class="line">        new PurgecssPlugin(&#123;</span><br><span class="line">          paths: glob.sync([</span><br><span class="line">            path.join(__dirname, &quot;./src/index.html&quot;),</span><br><span class="line">            path.join(__dirname, &quot;./**/*.vue&quot;),</span><br><span class="line">            path.join(__dirname, &quot;./src/**/*.js&quot;)</span><br><span class="line">          ])</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      plugins.push(</span><br><span class="line">        new UglifyJsPlugin(&#123;</span><br><span class="line">          uglifyOptions: &#123;</span><br><span class="line">            compress: &#123;</span><br><span class="line">              warnings: false,</span><br><span class="line">              drop_console: true,</span><br><span class="line">              drop_debugger: false,</span><br><span class="line">              pure_funcs: [&quot;console.log&quot;] //移除console</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          sourceMap: false,</span><br><span class="line">          parallel: true</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">      plugins.push(</span><br><span class="line">        new CompressionWebpackPlugin(&#123;</span><br><span class="line">          filename: &quot;[path].gz[query]&quot;,</span><br><span class="line">          algorithm: &quot;gzip&quot;,</span><br><span class="line">          test: productionGzipExtensions,</span><br><span class="line">          threshold: 10240,</span><br><span class="line">          minRatio: 0.8</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      // 上传文件到oss</span><br><span class="line">      //if (process.env.ACCESS_KEY_ID || process.env.ACCESS_KEY_SECRET || process.env.REGION || process.env.BUCKET || process.env.PREFIX) &#123;</span><br><span class="line">      //    plugins.push(</span><br><span class="line">      //        new AliOssPlugin(&#123;</span><br><span class="line">      //            accessKeyId: process.env.ACCESS_KEY_ID,</span><br><span class="line">      //            accessKeySecret: process.env.ACCESS_KEY_SECRET,</span><br><span class="line">      //            region: process.env.REGION,</span><br><span class="line">      //            bucket: process.env.BUCKET,</span><br><span class="line">      //            prefix: process.env.PREFIX,</span><br><span class="line">      //            exclude: /.*\.html$/,</span><br><span class="line">      //            deleteAll: false</span><br><span class="line">      //        &#125;)</span><br><span class="line">      //    );</span><br><span class="line">      //&#125;</span><br><span class="line"></span><br><span class="line">      // Zopfli压缩，需要响应VC库 https://webpack.js.org/plugins/compression-webpack-plugin/</span><br><span class="line">      // plugins.push(</span><br><span class="line">      //     new CompressionWebpackPlugin(&#123;</span><br><span class="line">      //         algorithm(input, compressionOptions, callback) &#123;</span><br><span class="line">      //             return zopfli.gzip(input, compressionOptions, callback);</span><br><span class="line">      //         &#125;,</span><br><span class="line">      //         compressionOptions: &#123;</span><br><span class="line">      //             numiterations: 15</span><br><span class="line">      //         &#125;,</span><br><span class="line">      //         minRatio: 0.99,</span><br><span class="line">      //         test: productionGzipExtensions</span><br><span class="line">      //     &#125;)</span><br><span class="line">      // );</span><br><span class="line">      // plugins.push(</span><br><span class="line">      //     new BrotliPlugin(&#123;</span><br><span class="line">      //         test: productionGzipExtensions,</span><br><span class="line">      //         minRatio: 0.99</span><br><span class="line">      //     &#125;)</span><br><span class="line">      // );</span><br><span class="line">      config.plugins = [...config.plugins, ...plugins];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  chainWebpack: config =&gt; &#123;</span><br><span class="line">    // 修复HMR</span><br><span class="line">    config.resolve.symlinks(true);</span><br><span class="line"></span><br><span class="line">    // 修复Lazy loading routes Error： Cyclic dependency  [https://github.com/vuejs/vue-cli/issues/1669]</span><br><span class="line">    config.plugin(&quot;html&quot;).tap(args =&gt; &#123;</span><br><span class="line">      args[0].chunksSortMode = &quot;none&quot;;</span><br><span class="line">      return args;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 添加别名</span><br><span class="line">    config.resolve.alias</span><br><span class="line">      .set(&quot;@&quot;, resolve(&quot;src&quot;))</span><br><span class="line">      .set(&quot;assets&quot;, resolve(&quot;src/assets&quot;))</span><br><span class="line">      .set(&quot;components&quot;, resolve(&quot;src/components&quot;))</span><br><span class="line">      .set(&quot;layout&quot;, resolve(&quot;src/layout&quot;))</span><br><span class="line">      .set(&quot;base&quot;, resolve(&quot;src/base&quot;))</span><br><span class="line">      .set(&quot;static&quot;, resolve(&quot;src/static&quot;));</span><br><span class="line"></span><br><span class="line">    // 打包分析</span><br><span class="line">    if (process.env.IS_ANALYZ) &#123;</span><br><span class="line">      config.plugin(&quot;webpack-report&quot;).use(BundleAnalyzerPlugin, [</span><br><span class="line">        &#123;</span><br><span class="line">          analyzerMode: &quot;static&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      ]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 多页面配置，为js添加hash</span><br><span class="line">    // config.output.chunkFilename(`js/[name].[chunkhash:8].js`)</span><br><span class="line"></span><br><span class="line">    // 修改图片输出路径</span><br><span class="line">    // config.module</span><br><span class="line">    //   .rule(&apos;images&apos;)</span><br><span class="line">    //   .test(/\.(png|jpe?g|gif|ico)(\?.*)?$/)</span><br><span class="line">    //   .use(&apos;url-loader&apos;)</span><br><span class="line">    //   .loader(&apos;url-loader&apos;)</span><br><span class="line">    //   .options(&#123;</span><br><span class="line">    //       name: path.join(&apos;../assets/&apos;, &apos;img/[name].[ext]&apos;)</span><br><span class="line">    //   &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  css: &#123;</span><br><span class="line">    modules: false,</span><br><span class="line">    extract: IS_PROD,</span><br><span class="line">    // 为css后缀添加hash</span><br><span class="line">    // extract: &#123;</span><br><span class="line">    //  filename: &apos;css/[name].[hash:8].css&apos;,</span><br><span class="line">    //  chunkFilename: &apos;css/[name].[hash:8].css&apos;</span><br><span class="line">    //&#125;，</span><br><span class="line">    sourceMap: false,</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      sass: &#123;</span><br><span class="line">        // 向全局sass样式传入共享的全局变量</span><br><span class="line">        // data: `@import &quot;~assets/scss/variables.scss&quot;;$src: &quot;$&#123;process.env.VUE_APP_SRC&#125;&quot;;`</span><br><span class="line">        data: `$src: &quot;$&#123;process.env.VUE_APP_SRC&#125;&quot;;`</span><br><span class="line">      &#125;</span><br><span class="line">      // px转换为rem</span><br><span class="line">      // postcss: &#123;</span><br><span class="line">      //   plugins: [</span><br><span class="line">      //     require(&apos;postcss-pxtorem&apos;)(&#123;</span><br><span class="line">      //       rootValue : 1, // 换算的基数</span><br><span class="line">      //       selectorBlackList  : [&apos;weui&apos;, &apos;el&apos;], // 忽略转换正则匹配项</span><br><span class="line">      //       propList   : [&apos;*&apos;]</span><br><span class="line">      //     &#125;)</span><br><span class="line">      //   ]</span><br><span class="line">      // &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  pluginOptions: &#123;</span><br><span class="line">    // 安装vue-cli-plugin-style-resources-loader插件</span><br><span class="line">    // 添加全局样式global.scss</span><br><span class="line">    // &quot;style-resources-loader&quot;: &#123;</span><br><span class="line">    //   preProcessor: &quot;scss&quot;,</span><br><span class="line">    //   patterns: [</span><br><span class="line">    //     resolve(__dirname, &quot;./src/scss/scss/variables.scss&quot;)</span><br><span class="line">    //   ]</span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  parallel: require(&quot;os&quot;).cpus().length &gt; 1,</span><br><span class="line">  pwa: &#123;&#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    // overlay: &#123;</span><br><span class="line">    //   warnings: true,</span><br><span class="line">    //   errors: true</span><br><span class="line">    // &#125;,</span><br><span class="line">    open: IS_PROD,</span><br><span class="line">    host: &quot;0.0.0.0&quot;,</span><br><span class="line">    port: 8000,</span><br><span class="line">    https: false,</span><br><span class="line">    hotOnly: false,</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &quot;/api&quot;: &#123;</span><br><span class="line">        target: process.env.VUE_APP_BASE_API || &quot;http://127.0.0.1:8080&quot;,</span><br><span class="line">        changeOrigin: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Vue-cli </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>剖析node的Common.JS</title>
      <link href="/2018/10/27/%E5%89%96%E6%9E%90node%E7%9A%84Common-JS/"/>
      <url>/2018/10/27/%E5%89%96%E6%9E%90node%E7%9A%84Common-JS/</url>
      
        <content type="html"><![CDATA[<h3 id="Javascript最开始是怎样实现模块化呢？"><a href="#Javascript最开始是怎样实现模块化呢？" class="headerlink" title="Javascript最开始是怎样实现模块化呢？"></a>Javascript最开始是怎样实现模块化呢？</h3><p>我们知道javascript最开始是面向过程的思维编程，随着代码越来越庞大、复杂，在这种实际遇到的问题中，大佬们逐渐把面向对象、模块化的思想用在javascript当中。</p><h4 id="一开始，我们是把不同功能写在不同函数当中"><a href="#一开始，我们是把不同功能写在不同函数当中" class="headerlink" title="一开始，我们是把不同功能写在不同函数当中"></a>一开始，我们是把不同功能写在不同函数当中</h4><pre><code>// 比如getCssAttr函数来获取Css属性，当我们需要获取Css属性的时候可以直接调用该方法function getCssAttr(obj, attr) {    if (obj.currentStyle) {        return obj.currentStyle[attr];    } else {        return window.getComputedStyle(obj, null)[attr];    }}// 比如toJSON函数能够把url的query转为JSON对象function toJSON(str) {  var obj = {}, allArr = [], splitArr = [];  str = str.indexOf(&apos;?&apos;) &gt;= 0 ? str.substr(1) : str;  allArr = str.split(&apos;&amp;&apos;);  for (var i = 0; i &lt; allArr.length; i++) {    splitArr = allArr[i].split(&apos;=&apos;);    obj[splitArr[0]] = splitArr[1];  }  return obj;}</code></pre><p>这样getCssAttr函数和toJSON组成了模块，当需要使用的时候，直接调用即可，但是随着项目代码量越来越庞大和复杂，而且这种方式会对全局变量造成了污染。</p><h4 id="为了解决上面的问题，会想到把这些方法、变量放到对象中"><a href="#为了解决上面的问题，会想到把这些方法、变量放到对象中" class="headerlink" title="为了解决上面的问题，会想到把这些方法、变量放到对象中"></a>为了解决上面的问题，会想到把这些方法、变量放到对象中</h4><pre><code>let utils = new Object({    getCssAttr:function(){...},    toJSON:function(){...}})</code></pre><p>当需要调用相应函数时，我们通过对象调用即可，<code>utils.getCssAttr()</code>、<code>utils.toJSON()</code>，但是这样会存在一个问题，就是可以直接通过外部修改内部方法属性。</p><pre><code>utils.getCssAttr = null</code></pre><h4 id="那么我们有办法让内部方法属性不被修改吗？"><a href="#那么我们有办法让内部方法属性不被修改吗？" class="headerlink" title="那么我们有办法让内部方法属性不被修改吗？"></a>那么我们有办法让内部方法属性不被修改吗？</h4><p>答案是可以的，我们可以通过闭包的方式，使私有成员不暴露在外部。</p><pre><code>let utils = (function(){    let getCssAttr = function(){...}    let toJSON = function(){...}    return {        getCssAttr,        toJSON    }})()</code></pre><p>这样的话，外部就无法改变内部的私有成员了。</p><hr><h2 id="CMD和AMD规范"><a href="#CMD和AMD规范" class="headerlink" title="CMD和AMD规范"></a>CMD和AMD规范</h2><p>试想一下，如果一个项目，所有轮子都自己造，在现在追求敏捷开发的环境下，我们有必要所有轮子都自己造吗？一些常用通用的功能，是否可以提取出来，供大家使用，提高开发效率？</p><p>正所谓，无规矩不成方圆，每个程序猿的代码风格肯定是有差异的，你写你的，我写我的，这样就很难流通了，但是如果大家都遵循一个规范编写代码，形成一个个模块，就显得非常重要了。</p><p>在这样的背景下，形成了两种规范，一种是以sea.js为代表的CMD规范，另外一种是以require.js为代表的AMD规范。</p><ul><li>CMD规范（Common Module Definition 通用模块定义）</li><li>AMD规范（Asynchronous Module Definition 异步模块定义）</li></ul><p>在node.js中是遵循commonJS规范的，在对模块的导入是同步的，为什么这样说？因为在服务器中，模块都是存在本地的，即使要导入模块，也只是耗费了从硬盘读取模块的时间，而且可控。</p><p>但是在浏览器中，模块是需要通过网络请求获取的，如果是同步获取的话，那么网络请求的时间没办法保证，会造成浏览器假死的，但是异步的话，是不会阻塞主线程，所以不管是CMD还是AMD，都是属于异步的，CMD和AMD都是属于异步加载模块，当所需要依赖的模块加载完毕后，才通过一个回调函数，写我们所需要的业务逻辑。</p><h4 id="CMD和AMD的异同"><a href="#CMD和AMD的异同" class="headerlink" title="CMD和AMD的异同"></a>CMD和AMD的异同</h4><ul><li>CMD是<code>延迟执行，依赖就近</code>，而AMD是<code>提前执行，依赖前置</code>（require2.0开始可以改成延迟执行），怎么理解呢？看看下面代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">define(function(require,exports,module)&#123;</span><br><span class="line">    var a = require(&apos;./a&apos;)</span><br><span class="line">    a.run()</span><br><span class="line">    </span><br><span class="line">    var b = require(&apos;./b&apos;)</span><br><span class="line">    b.eat()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// AMD</span><br><span class="line">define([&apos;./a&apos;,&apos;./b&apos;],function(a,b)&#123;</span><br><span class="line">    a.run()</span><br><span class="line">    b.eat()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h4 id="CMD-AMD执行对比"><a href="#CMD-AMD执行对比" class="headerlink" title="CMD,AMD执行对比"></a>CMD,AMD执行对比</h4><table><thead><tr><th>—</th><th style="text-align:center">CMD</th><th style="text-align:right">AMD</th></tr></thead><tbody><tr><td> 执行回调函数的时机</td><td style="text-align:center">快</td><td style="text-align:right">慢</td></tr><tr><td> 执行回调函数内的业务</td><td style="text-align:center">慢</td><td style="text-align:right">快</td></tr></tbody></table><hr><h2 id="node-js遵循的commonJs规范"><a href="#node-js遵循的commonJs规范" class="headerlink" title="node.js遵循的commonJs规范"></a>node.js遵循的commonJs规范</h2><h3 id="首先，我们来剖析一下commonJs的源码"><a href="#首先，我们来剖析一下commonJs的源码" class="headerlink" title="首先，我们来剖析一下commonJs的源码"></a>首先，我们来剖析一下commonJs的源码</h3><p>我们分别创建两个文件<code>useModule.js</code>、<code>module.js</code>，并且打上断点。<br><img src="/2018/10/27/剖析node的Common-JS/166abfe6e856dc15.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// useModule.js</span><br><span class="line">let utils = require(&apos;./module&apos;)</span><br><span class="line">utils = require(&apos;./module&apos;)</span><br><span class="line">utils.sayhello()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// module.js</span><br><span class="line">let utils = &#123;</span><br><span class="line">  sayhello:function()&#123;</span><br><span class="line">    console.log(&apos;hello swr&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = utils</span><br></pre></td></tr></table></figure></p><p>然后开始执行，我们首先会进入commonJs的源码了<br><img src="/2018/10/27/剖析node的Common-JS/166ac006849ff31e.webp" alt=""><br> 在最上面可以看出是一个闭包的形式<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(exports,require,module,__filename,__dirname))&#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> ，这里可以看出<code>__dirname</code>和<code>__filename</code>并非是<code>global</code>上的属性，而是每个模块对应的路径。</p><p>而且我们在模块当中<code>this</code>并不是指向<code>global</code>的，而是指向<code>module.exports</code>，至于为什么会这样呢？下面会讲到。</p><p>在红框中，我们可以看到<code>require</code>函数，<code>exports.requireDepth</code>可以暂时不用管，是一个引用深度的变量，接下来我们往下看，<code>return mod.require(path)</code>，这里的<code>mod</code>就是每一个文件、模块，而里面都有一个<code>require</code>方法，接下来我们看看<code>mod.require</code>函数内部是怎么写的。<br><img src="/2018/10/27/剖析node的Common-JS/1.webp" alt=""><br>进来后，我们会看到2个<code>assert</code>断言，用来判断<code>path</code>参数是否传递了，<code>path</code>是否字符串类型等等。</p><p><code>return Module._load(path,this,false)</code>，<code>path</code>为我们传入的模块路径，this则是这个模块，false则不是主要模块，主要模块的意思是，如果a.js加载了b.js，那么a.js是主要模块，而b.js则是非主要模块。</p><p>接下来我们看看<code>Module._load</code>这个静态方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line"></span><br><span class="line">  //  计算绝对路径</span><br><span class="line">  var filename = Module._resolveFilename(request, parent);</span><br><span class="line"></span><br><span class="line">  //  第一步：如果有缓存，取出缓存</span><br><span class="line">  var cachedModule = Module._cache[filename];</span><br><span class="line">  if (cachedModule) &#123;</span><br><span class="line">    return cachedModule.exports;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 第二步：是否为内置模块</span><br><span class="line">  if (NativeModule.exists(filename)) &#123;</span><br><span class="line">    return NativeModule.require(filename);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 第三步：生成模块实例，存入缓存</span><br><span class="line">  var module = new Module(filename, parent);</span><br><span class="line">  Module._cache[filename] = module;</span><br><span class="line"></span><br><span class="line">  // 第四步：加载模块</span><br><span class="line">  try &#123;</span><br><span class="line">    module.load(filename);</span><br><span class="line">    hadException = false;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (hadException) &#123;</span><br><span class="line">      delete Module._cache[filename];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 第五步：输出模块的exports属性</span><br><span class="line">  return module.exports;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/10/27/剖析node的Common-JS/2.webp" alt=""><br><img src="/2018/10/27/剖析node的Common-JS/3.webp" alt=""><br><code>var filename = Module._resolveFilename(request, parent, isMain)</code>，这里的目的是解析出一个绝对路径，我们可以进去看看<code>Module._resolveFilename</code>函数是怎么写的<br><img src="/2018/10/27/剖析node的Common-JS/4.webp" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Module._resolveFilename = function(request, parent) &#123;</span><br><span class="line"></span><br><span class="line"> // 第一步：如果是内置模块，不含路径返回</span><br><span class="line"> if (NativeModule.exists(request)) &#123;</span><br><span class="line">   return request;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 第二步：确定所有可能的路径</span><br><span class="line"> var resolvedModule = Module._resolveLookupPaths(request, parent);</span><br><span class="line"> var id = resolvedModule[0];</span><br><span class="line"> var paths = resolvedModule[1];</span><br><span class="line"></span><br><span class="line"> // 第三步：确定哪一个路径为真</span><br><span class="line"> var filename = Module._findPath(request, paths);</span><br><span class="line"> if (!filename) &#123;</span><br><span class="line">   var err = new Error(&quot;Cannot find module &apos;&quot; + request + &quot;&apos;&quot;);</span><br><span class="line">   err.code = &apos;MODULE_NOT_FOUND&apos;;</span><br><span class="line">   throw err;</span><br><span class="line"> &#125;</span><br><span class="line"> return filename;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面代码中，在 Module.resolveFilrename 方法内部，又调用了两个方法  Module.reqolveLookPaths()和 Module._findPath(),前者用来列出可能的路径，后者用来确认哪一个路径为真。<br>有了可能的路径以后，下面就是 Module._findPath()的源码，用来确定到底哪一个是正确路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Module._findPath = function(request, paths) &#123;</span><br><span class="line"></span><br><span class="line"> // 列出所有可能的后缀名：.js，.json, .node</span><br><span class="line"> var exts = Object.keys(Module._extensions);</span><br><span class="line"></span><br><span class="line"> // 如果是绝对路径，就不再搜索</span><br><span class="line"> if (request.charAt(0) === &apos;/&apos;) &#123;</span><br><span class="line">   paths = [&apos;&apos;];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 是否有后缀的目录斜杠</span><br><span class="line"> var trailingSlash = (request.slice(-1) === &apos;/&apos;);</span><br><span class="line"></span><br><span class="line"> // 第一步：如果当前路径已在缓存中，就直接返回缓存</span><br><span class="line"> var cacheKey = JSON.stringify(&#123;request: request, paths: paths&#125;);</span><br><span class="line"> if (Module._pathCache[cacheKey]) &#123;</span><br><span class="line">   return Module._pathCache[cacheKey];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 第二步：依次遍历所有路径</span><br><span class="line"> for (var i = 0, PL = paths.length; i &lt; PL; i++) &#123;</span><br><span class="line">   var basePath = path.resolve(paths[i], request);</span><br><span class="line">   var filename;</span><br><span class="line"></span><br><span class="line">   if (!trailingSlash) &#123;</span><br><span class="line">     // 第三步：是否存在该模块文件</span><br><span class="line">     filename = tryFile(basePath);</span><br><span class="line"></span><br><span class="line">     if (!filename &amp;&amp; !trailingSlash) &#123;</span><br><span class="line">       // 第四步：该模块文件加上后缀名，是否存在</span><br><span class="line">       filename = tryExtensions(basePath, exts);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 第五步：目录中是否存在 package.json </span><br><span class="line">   if (!filename) &#123;</span><br><span class="line">     filename = tryPackage(basePath, exts);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (!filename) &#123;</span><br><span class="line">     // 第六步：是否存在目录名 + index + 后缀名 </span><br><span class="line">     filename = tryExtensions(path.resolve(basePath, &apos;index&apos;), exts);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // 第七步：将找到的文件路径存入返回缓存，然后返回</span><br><span class="line">   if (filename) &#123;</span><br><span class="line">     Module._pathCache[cacheKey] = filename;</span><br><span class="line">     return filename;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 第八步：没有找到文件，返回false </span><br><span class="line"> return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>有时在项目代码中，需要调用模块的绝对路径，那么除了 module.filename ，Node 还提供一个 require.resolve 方法，供外部调用，用于从模块名取到绝对路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">require.resolve = function(request) &#123;</span><br><span class="line">  return Module._resolveFilename(request, self);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 用法</span><br><span class="line">require.resolve(&apos;a.js&apos;)</span><br><span class="line">// 返回  /Users/danlan/workspace/node-stu/ree/a.js</span><br></pre></td></tr></table></figure></p><p><code>Module._resolveFilename</code>函数也没什么好说的，就是判断各种情况，然后解析出一个绝对路径出来，我们跳出这个函数，回到<code>Module._load</code>中.<br>然后我们看到<code>var cachedModule = Module._cache[filename]</code>，这是我们加载模块的缓存机制，就是说我们加载过一次模块后，会缓存到Module._cache这个对象中，并且是以<code>filename</code>作为键名，因为路径是唯一的，所以以路径作为唯一标识，如果已经缓存过，则会直接返回这个缓存过的模块。</p><p><code>NativeModule.nonInternalExists(filename)</code>判断是否原生模块，是的话则直接返回模块。</p><p>经过上面两个判断，基本可以判定这个模块没被加载过，那么接下来看到<code>var module = new Module(filename, parent)</code>，创建了一个模块，我们看看<code>Module</code>这个构造函数有什么内容<br><img src="/2018/10/27/剖析node的Common-JS/5.webp" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.id 模块的识别符，通常是带有绝对路径的模块文件名。</span><br><span class="line">module.filename 模块的文件名，带有绝对路径。</span><br><span class="line">module.loaded 返回一个布尔值，表示模块是否已经完成加载。</span><br><span class="line">module.parent 返回一个对象，表示调用该模块的模块。</span><br><span class="line">module.children 返回一个数组，表示该模块要用到的其他模块。</span><br><span class="line">module.exports 表示模块对外输出的值。</span><br></pre></td></tr></table></figure></p><blockquote><p>下面是一个示例文件，最后一行输出module变量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// example.js</span><br><span class="line">var jquery = require(&apos;jquery&apos;);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line">console.log(module);</span><br></pre></td></tr></table></figure><blockquote><p>执行这个文件，命令行会输出如下信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; id: &apos;.&apos;,</span><br><span class="line">  exports: &#123; &apos;$&apos;: [Function] &#125;,</span><br><span class="line">  parent: null,</span><br><span class="line">  filename: &apos;/path/to/example.js&apos;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children:</span><br><span class="line">   [ &#123; id: &apos;/path/to/node_modules/jquery/dist/jquery.js&apos;,</span><br><span class="line">       exports: [Function],</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: &apos;/path/to/node_modules/jquery/dist/jquery.js&apos;,</span><br><span class="line">       loaded: true,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [Object] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ &apos;/home/user/deleted/node_modules&apos;,</span><br><span class="line">     &apos;/home/user/node_modules&apos;,</span><br><span class="line">     &apos;/home/node_modules&apos;,</span><br><span class="line">     &apos;/node_modules&apos; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里的<code>id</code>，实际上就是<code>filename</code>唯一路径，另外一个很重要的是<code>this.exports</code>，也就是将来用于暴露模块的。<br>我们接着往下看，在创建一个实例后，接下来把这个实例存在缓存当中，<code>Module._cache[filename] = module</code><br>然后执行<code>tryModuleLoad(module, filename)</code>，这个函数非常重要，是用来加载模块的，我们看看是怎么写的<br><img src="/2018/10/27/剖析node的Common-JS/6.webp" alt=""><br> 这里有个<code>module.load</code>，我们再往里面看看是怎么写的<br><img src="/2018/10/27/剖析node的Common-JS/7.webp" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype.load = function (filename) &#123;</span><br><span class="line">    var extension = path.extname(filename)  || &apos;js&apos;</span><br><span class="line">    if(!Module._extensions[extensions]) extension = &apos;.js&apos;</span><br><span class="line">    Module._extensions[extension](this, filename)</span><br><span class="line">    this.loaded = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 兜兜转转，终于来到最核心的地方了<br><code>this.paths = Module._nodeModulePaths(path.dirname(filename))</code>，我们知道，我们安装npm包时，node会由里到外一层层找<code>node_modules</code>文件夹，而这一步，则是路径一层层丢进数组里，我们可以看看<code>this.paths</code>的数组</p><h4 id="CommonJS-模块查找规范"><a href="#CommonJS-模块查找规范" class="headerlink" title="CommonJS 模块查找规范"></a>CommonJS 模块查找规范</h4><p><img src="/2018/10/27/剖析node的Common-JS/13.svg" alt=""><br><img src="/2018/10/27/剖析node的Common-JS/8.webp" alt=""></p><blockquote><p>新建一个b.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a = require(&apos;./a.js&apos;)</span><br></pre></td></tr></table></figure><blockquote><p>运行一下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module.id:  /Users/danlan/workspace/node-stu/ree/a.js</span><br><span class="line">module.exports:  &#123;&#125;</span><br><span class="line">module.parent:  Module &#123;</span><br><span class="line">  id: &apos;.&apos;,</span><br><span class="line">  exports: &#123;&#125;,</span><br><span class="line">  parent: null,</span><br><span class="line">  filename: &apos;/Users/danlan/workspace/node-stu/ree/b.js&apos;,</span><br><span class="line">  loaded: false,</span><br><span class="line">  children:</span><br><span class="line">   [ Module &#123;</span><br><span class="line">       id: &apos;/Users/danlan/workspace/node-stu/ree/a.js&apos;,</span><br><span class="line">       exports: &#123;&#125;,</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: &apos;/Users/danlan/workspace/node-stu/ree/a.js&apos;,</span><br><span class="line">       loaded: false,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [Array] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ &apos;/Users/danlan/workspace/node-stu/ree/node_modules&apos;,</span><br><span class="line">     &apos;/Users/danlan/workspace/node-stu/node_modules&apos;,</span><br><span class="line">     &apos;/Users/danlan/workspace/node_modules&apos;,</span><br><span class="line">     &apos;/Users/danlan/node_modules&apos;,</span><br><span class="line">     &apos;/Users/node_modules&apos;,</span><br><span class="line">     &apos;/node_modules&apos; ] &#125;</span><br><span class="line">module.filename:  /Users/danlan/workspace/node-stu/ree/a.js</span><br><span class="line">module.loaded:  false</span><br><span class="line">module.children:  []</span><br><span class="line">module.paths:  [ &apos;/Users/danlan/workspace/node-stu/ree/node_modules&apos;,</span><br><span class="line">  &apos;/Users/danlan/workspace/node-stu/node_modules&apos;,</span><br><span class="line">  &apos;/Users/danlan/workspace/node_modules&apos;,</span><br><span class="line">  &apos;/Users/danlan/node_modules&apos;,</span><br><span class="line">  &apos;/Users/node_modules&apos;,</span><br><span class="line">  &apos;/node_modules&apos; ]</span><br></pre></td></tr></table></figure><blockquote><p>举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/node/bar.js</span><br><span class="line">/home/user/projects/node_modules/bar.js</span><br><span class="line">/home/user/node_modules/bar.js</span><br><span class="line">/home/node_modules/bar.js</span><br><span class="line">/node_modules/bar.js</span><br></pre></td></tr></table></figure><p>这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</p><ul><li>如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</li><li><font color="#ff0000">如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</font></li><li>如果想得到require命令加载的确切文件名，使用require.resolve()方法。</li></ul><p>目录的加载规则</p><blockquote><p>在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123; </span><br><span class="line">  &quot;name&quot; : &quot;some-library&quot;,</span><br><span class="line">  &quot;main&quot; : &quot;./lib/some-library.js&quot; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 继续往下看，<code>var extension = path.extname(filename) || &#39;.js&#39;</code>是获取后缀名，如果没有后缀名的话，暂时默认添加一个<code>.js</code>后缀名。<br>继续往下看，<code>if (!Module._extensions[extension]) extension = &#39;.js&#39;</code>是判断<code>Module._extensions</code>这个对象，是否有这个属性，如果没有的话，则让这个后缀名为<code>.js</code><br>继续往下看，<code>Module._extensions[extension](this, filename)</code>，根据后缀名，执行对应的函数，那么我们看一下<code>Module._extensions</code>对象有哪几个函数<br><img src="/2018/10/27/剖析node的Common-JS/9.webp" alt=""><br> 从这里我们可以看到，<code>Module._extensions</code>中有3个函数，分别是<code>.js</code>、<code>.json</code>、<code>.node</code>函数，意思是根据不同的后缀名，执行不同的函数，来解析不同的内容，我们可以留意到读取文件都是用<code>fs.readFileSync</code>同步读取，因为这些文件都是保存在服务器硬盘中，读取这些文件耗费时间非常短，所以采用了同步而不是异步<br>其中<code>.json</code>最为简单，读取出文件后，再通过<code>JSON.parse</code>把字符串转化为<code>JSON</code>对象，然后把结果赋值给<code>module.exports</code><br>接下来看看<code>.js</code>，也是一样先读取出文件内容，然后通过<code>module._compile</code>这个函数来解析<code>.js</code>的内容，我们看一下<code>module._compile</code>函数怎么写的<br> <img src="/2018/10/27/剖析node的Common-JS/10.webp" alt=""><br> <img src="/2018/10/27/剖析node的Common-JS/11.webp" alt=""><br> <code>var wrapper = Module.wrap(content)</code>这里对<code>.js</code>文件的内容进行了一层处理，我们可以看看<code>Module.wrap</code>怎么写的<br>  <img src="/2018/10/27/剖析node的Common-JS/12.webp" alt=""><br> 在这里可以看出，<code>NativeModule.wrapper</code>数组中有两个数组成员，是不是看起来似曾相识？没错，这就是闭包的形式，而<code>Module.wrap</code>中，是直接把js文件的内容，和这个闭包拼接成一段字符串，对，就是在这里，把一个个模块，套一层闭包！实际上拼接出来的是</p><pre><code>// 字符串&quot;(function(exports,require,module,__filename,__dirname){    let utils = {      sayhello:function(){        console.log(&apos;hello swr&apos;)      }    }})&quot;</code></pre><p>我们跳出来，回到<code>Module.prototype._compile</code>看看，接下来看到<code>var compiledWrapper = vm.runInThisContext(wrapper,{...})</code>，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//虚拟机，帮我们创建一个黑箱执行代码，防止变量污染</span><br><span class="line">const vm = require(&quot;vm&quot;);</span><br></pre></td></tr></table></figure></p><p>在nodejs中是通过vm这个虚拟机，执行字符串，而且这样的好处是使内部完全是封闭的，不会被外在变量污染，而在前端的字符串模板则是通过<code>new Function()</code>来执行字符串，达到不被外在变量污染</p><p>继续往下看，<code>result = compiledWrapper.call(this.exports, this.exports, require, this,filename, dirname)</code>，其中<code>compiledWrapper</code>就是我们通过vm虚拟机执行的字符串后返回的闭包，而且通过<code>call</code>来把这个模块中的<code>this</code>指向更改为当前模块，而不是全局的<code>global</code>，这里就是为什么我们在模块当中打印<code>this</code>时，指向的是当前的<code>module.exports</code>而不是<code>global</code>，然后后面依次把相应的参数传递过去</p><p>最终一层层跳出后<code>Module._load</code>中，最后是<code>return module.exports</code>，也就是说我们通过<code>require</code>导入的模块，取的是<code>module.exports</code></p><h4 id="通过剖析commonJs源码，我们收获了什么？"><a href="#通过剖析commonJs源码，我们收获了什么？" class="headerlink" title="通过剖析commonJs源码，我们收获了什么？"></a>通过剖析commonJs源码，我们收获了什么？</h4><ul><li><p>懂得了模块加载的整个流程</p><ul><li>第一步：解析出一个绝对路径,如果是核心模块，比如fs，就直接返回模块</li><li>第二步：如文件没添加后缀，则添加<code>.js</code>、<code>.json</code>、<code>.node</code>作为后缀，然后通过<code>fs.existsSync</code>来判断文件是否存在<ul><li>.js 解析为JavaScript 文本文件</li><li>.json解析JSON对象</li><li>.node解析为二进制插件模块</li></ul></li><li>第三步：到缓存中找该模块是否被加载过(如果是带有路径的如/,./等等，则拼接出一个绝对路径，然后先读取缓存require.cache再读取文件。如果没有加后缀，则自动加后缀然后一一识别。)</li><li>第四步：new一个模块实例</li><li>第五步：把模块存到缓存当中(首次加载后的模块会缓存在require.cache之中，所以多次加载require，得到的对象是同一个。)</li><li>第六步：根据后缀名，加载这个模块<ul><li>在执行模块代码的时候，会将模块包装成如下模式，以便于作用域在模块范围之内。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   (function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">   // 模块的代码实际上在这里</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>知道如何实现由里到外一层层查找<code>node_modules</code></p></li><li>知道针对<code>.js</code>和<code>.json</code>是怎么解析的<ul><li><code>.js</code>是通过拼接字符串，形成一个闭包形式的字符串</li><li><code>.json</code>则是通过<code>JSON.parse</code>转为<code>JSON</code>对象</li></ul></li><li><p>知道如何执行字符串，并且不受外部变量污染</p><ul><li><p>nodejs中通过vm虚拟机来执行字符串</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   let vm=require(&quot;vm&quot;)</span><br><span class="line">   let a=&apos;console.log(&quot;a&quot;)&apos;</span><br><span class="line">vm.runInThisContext(a)</span><br></pre></td></tr></table></figure></li><li><p>前端则是通过<code>new Function()</code>来执行字符串</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x+y&apos;); </span><br><span class="line">      f( 3, 4 )</span><br></pre></td></tr></table></figure></li></ul></li><li><p>知道为什么模块中的<code>this</code>指向的是<code>this.exports</code>而不是<code>global</code></p><ul><li>通过<code>call</code>把指针指向了<code>this.exports</code></li></ul></li></ul><hr><h3 id="接下来，我们手写一个简陋版的commonJs源码"><a href="#接下来，我们手写一个简陋版的commonJs源码" class="headerlink" title="接下来，我们手写一个简陋版的commonJs源码"></a>接下来，我们手写一个简陋版的commonJs源码</h3><p>commonJs其实在加载模块的时候，做了以下几个步骤</p><ul><li>第一步：解析出一个绝对路径</li><li>第二步：如文件没添加后缀，则添加<code>.js</code>、<code>.json</code>、<code>.node</code>作为后缀，然后通过<code>fs.existsSync</code>来判断文件是否存在</li><li>第三步：到缓存中找该模块是否被加载过</li><li>第四步：new一个模块实例</li><li>第五步：把模块存到缓存当中</li><li>第六步：根据后缀名，加载这个模块</li></ul><p>那么我们根据这几个步骤，来手写一下源码~</p><pre><code>// module.jslet utils = {  sayhello: function () {    console.log(&apos;hello swr&apos;)  }}console.log(&apos;执行了&apos;)module.exports = utils</code></pre><p>首先写出解析一个绝对路径以及如文件没添加后缀，则添加<code>.js</code>、<code>.json</code>作为后缀，然后通过<code>fs.existsSync</code>来判断文件是否存在（ .. 每个步骤我都会标识1、2、3…</p><pre><code>// useModule.js// 1.引入核心模块let fs = require(&apos;fs&apos;)let path = require(&apos;path&apos;)// 3.声明一个Module构造函数function Module(id) {  this.id = id   this.exports = {} // 将来暴露模块的内容}// 8.支持的后缀名类型Module._extensions = {  &quot;.js&quot;:function(){},  &quot;.json&quot;:function(){}}// 5.解析出绝对路径，_resolveFilename是Module的静态方法Module._resolveFilename = function (relativePath) {  // 6.返回一个路径  let p = path.resolve(__dirname,relativePath)  // 7.该路径是否存在文件，如果存在则直接返回  //   这种情况主要考虑用户自行添加了后缀名  //   如&apos;./module.js&apos;let exists = fs.existsSync(p)  if(exists) return p  // 9.如果relativePath传入的如&apos;./module&apos;，没有添加后缀  //   那么我们给它添加后缀，并且判断添加后缀后是否存在该文件  let keys = Object.keys(Module._extensions)  let r = falsefor(let val of keys){ // 这里用for循环，是当找到文件后可以直接break跳出循环    let realPath = p + val // 拼接后缀    let exists = fs.existsSync(realPath)    if(exists){      r = realPath      break    }  }  if(!r){ // 如果找不到文件，则抛出错误    throw new Error(&apos;file not exists&apos;)  }  return r}// 2.为了不与require冲突，这个函数命名为req//   传入一个参数p 路径function req(p) {  // 10.因为Module._resolveFilename存在找不到文件  //    找不到文件时会抛出错误，所以我们这里捕获错误  try {     // 4.通过Module._resolveFilename解析出一个绝对路径    let filename = Module._resolveFilename(p)  } catch (e) {    console.log(e)  }}// 导入模块，并且导入两次，主要是校验是否加载过一次后// 在有缓存的情况下，会不会直接返回缓存的模块// 为此特意在module.js中添加了console.log(&quot;执行了&quot;)// 来看打印了几次let utils = req(&apos;./module&apos;)utils = req(&apos;./module&apos;)utils.sayhello()</code></pre><p>然后到缓存中找该模块是否被加载过，如果没有加载过则new一个模块实例，把模块存到缓存当中，最后根据后缀名，加载这个模块（ .. 每个步骤我都会标识1、2、3…</p><pre><code>// useModule.js// 1.引入核心模块let fs = require(&apos;fs&apos;)let path = require(&apos;path&apos;)// 3.声明一个Module构造函数function Module(id) {  this.id = id   this.exports = {} // 将来暴露模块的内容}// * 21.因为处理js文件时，需要包裹一个闭包，我们写一个数组Module.wrapper = [  &quot;(function(exports,require,module){&quot;,  &quot;\n})&quot;]// * 22.通过Module.wrap包裹成闭包的字符串形式Module.wrap = function(script){  return Module.wrapper[0] + script + Module.wrapper[1]}// 8.支持的后缀名类型Module._extensions = {  &quot;.js&quot;:function(module){ // * 20.其次看看js是如何处理的    let str = fs.readFileSync(module.id,&apos;utf8&apos;)    // * 23.通过Module.wrap函数把内容包裹成闭包    let fnStr = Module.wrap(str)    // * 24.引入vm虚拟机来执行字符串    let vm = require(&apos;vm&apos;)    let fn = vm.runInThisContext(fnStr)    // 让产生的fn执行，并且把this指向更改为当前的module.exports    fn.call(this.exports,this.exports,req,module)  },  &quot;.json&quot;:function(module){ // * 18.首先看看json是如何处理的    let str = fs.readFileSync(module.id,&apos;utf8&apos;)    // * 19.通过JSON.parse处理，并且赋值给module.exports    let json = JSON.parse(str)    module.exports = json  }}// * 15.加载Module.prototype._load = function(filename){  // * 16.获取后缀名  let extension = path.extname(filename)  // * 17.根据不同后缀名 执行不同的方法  Module._extensions[extension](this)}// 5.解析出绝对路径，_resolveFilename是Module的静态方法Module._resolveFilename = function (relativePath) {  // 6.返回一个路径  let p = path.resolve(__dirname,relativePath)  // 7.该路径是否存在文件，如果存在则直接返回  //   这种情况主要考虑用户自行添加了后缀名  //   如&apos;./module.js&apos;let exists = fs.existsSync(p)  if(exists) return p  // 9.如果relativePath传入的如&apos;./module&apos;，没有添加后缀  //   那么我们给它添加后缀，并且判断添加后缀后是否存在该文件  let keys = Object.keys(Module._extensions)  let r = falsefor(let val of keys){ // 这里用for循环，是当找到文件后可以直接break跳出循环    let realPath = p + val // 拼接后缀    let exists = fs.existsSync(realPath)    if(exists){      r = realPath      break    }  }  if(!r){ // 如果找不到文件，则抛出错误    throw new Error(&apos;file not exists&apos;)  }  return r}// * 11.缓存对象Module._cache = {}// 2.为了不与require冲突，这个函数命名为req//   传入一个参数p 路径function req(p) {  // 10.因为Module._resolveFilename存在找不到文件  //    找不到文件时会抛出错误，所以我们这里捕获错误  try {     // 4.通过Module._resolveFilename解析出一个绝对路径    let filename = Module._resolveFilename(p)    // * 12.判断是否有缓存，如果有缓存的话，则直接返回缓存    if(Module._cache[filename]){      // * 因为实例的exports才是最终暴露出的内容      return Module._cache[filename].exports    }    // * 13.new一个Module实例    let module = new Module(filename)    // * 14.加载这个模块    module._load(filename)    // * 25.把module存到缓存    Module._cache[filename] = module    // * 26.返回module.exprots    return module.exports  } catch (e) {    console.log(e)  }}// 导入模块，并且导入两次，主要是校验是否加载过一次后// 在有缓存的情况下，会不会直接返回缓存的模块// 为此特意在module.js中添加了console.log(&quot;执行了&quot;)// 来看打印了几次let utils = req(&apos;./module&apos;)utils = req(&apos;./module&apos;)utils.sayhello()</code></pre><p>这样我们就完成了一个简陋版的commonJs，而且我们多次导入这个模块，只会打印出一次<code>执行了</code>，说明了只要缓存中有的，就直接返回，而不是重新加载这个模块<br>这里建议大家一个步骤一个步骤去理解，尝试敲一下代码，这样感悟会更加深</p><h4 id="那么为什么exports-xxx-却失效了呢？"><a href="#那么为什么exports-xxx-却失效了呢？" class="headerlink" title="那么为什么exports = xxx 却失效了呢？"></a>那么为什么exports = xxx 却失效了呢？</h4><pre><code>// 从上面源码我们可以看出，实际上// exports = module.exports = {}// 但是当我们exports = {name:&quot;CommonJS&quot;}时，// require出来却获取不到这个对象，这是因为我们在上面源码中，// req函数（即require）内部return出的是module.exports，而不是exports，// 当我们exports = { name:&quot;CommonJS&quot; }时，实际上这个exports指向了一个新的对象，// 而不是module.exports// 那么我们的exports是不是多余的呢？肯定不是多余的，我们可以这样写exports.name = &quot;CommonJS&quot; // 这样写没有改变exports的指向，而是在exports指向的module.exports对象上新增了属性// 那么什么时候用exports，什么时候用module.exports呢？// 如果导出的东西是一个，那么可以用module.exports，如果导出多个属性可以用exports，// 一般情况下是用module.exports// 还有一种方式，就是把属性挂载到global上供全局访问，不过不推荐。</code></pre><h3 id="CommonJS模块总结"><a href="#CommonJS模块总结" class="headerlink" title="CommonJS模块总结"></a>CommonJS模块总结</h3><p><img src="/2018/10/27/剖析node的Common-JS/14.png" alt=""><br>CommonJS模块只能运行再支持此规范的环境之中，nodejs是基于CommonJS规范开发的，因此可以很完美地运行CommonJS模块，然后nodejs不支持ES6的模块规范，所以nodejs的服务器开发大家一般使用CommonJS规范来写。<br>CommonJS模块导入用require，导出用module.exports。导出的对象需注意，如果是静态值，而且非常量，后期可能会有所改动的，请使用函数动态获取，否则无法获取修改值。导入的参数，是可以随意改动的，所以大家使用时要小心。</p><h3 id="开发者需要了解的nodejs中require的机制"><a href="#开发者需要了解的nodejs中require的机制" class="headerlink" title="开发者需要了解的nodejs中require的机制"></a><a href="https://juejin.im/post/5bdea6b1518825170f50c485" target="_blank" rel="noopener">开发者需要了解的nodejs中require的机制</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> Common.JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解密webpack tree-starking</title>
      <link href="/2018/10/25/%E8%A7%A3%E5%AF%86webpack-tree-starking/"/>
      <url>/2018/10/25/%E8%A7%A3%E5%AF%86webpack-tree-starking/</url>
      
        <content type="html"><![CDATA[<h2 id="Tree-Shaking-简介"><a href="#Tree-Shaking-简介" class="headerlink" title="Tree-Shaking 简介"></a>Tree-Shaking 简介</h2><p>最近看了一篇 <strong> <a href="https://juejin.im/post/5a5652d8f265da3e497ff3de" target="_blank" rel="noopener">你的Tree-Shaking并没什么卵用</a> </strong>吓得我赶紧好好研究Tree-Shaking。</p><p><code>tree-sharking</code> 是 <code>Webpack 2</code> 后续版本的优化功能，顾名思义，就是将多余的代码给 “摇晃” 掉，在开发中我们经常使用一些第三方库，而这些第三方库只使用了这个库的一部门功能或代码，未使用的代码也要被打包进来，这样出口文件会非常大，<code>tree-sharking</code> 帮我们解决了这个问题，它可以将各个模块中没有使用的方法过滤掉，只对有效代码进行打包。</p><p>Tree-Shaking在前端界由rollup首先提出并实现，后续webpack在2.x版本也借助于UglifyJS实现了。自那以后，在各类讨论优化打包的文章中，都能看到Tree-Shaking的身影。</p><h4 id="Tree-Shaking的原理"><a href="#Tree-Shaking的原理" class="headerlink" title="Tree-Shaking的原理"></a>Tree-Shaking的原理</h4><p>这里我不多冗余阐述，直接贴百度外卖前端的一篇文章：<strong> <a href="https://juejin.im/post/5a4dc842518825698e7279a9" target="_blank" rel="noopener">Tree-Shaking性能优化实践 - 原理篇</a> </strong>。</p><hr><h3 id="AST-语法树分析"><a href="#AST-语法树分析" class="headerlink" title="AST 语法树分析"></a>AST 语法树分析</h3><blockquote><p>AST 抽象语法树简介</p></blockquote><p>AST（Abstract Syntax Tree）是源代码的抽象语法结构树状表现形式，Webpack、ESLint、JSX、TypeScript 的编译和模块化规则之间的转化都是通过 AST 来实现对代码的检查、分析以及编译等操作。</p><h3 id="JavaScript-语法的-AST-语法树"><a href="#JavaScript-语法的-AST-语法树" class="headerlink" title="JavaScript 语法的 AST 语法树"></a>JavaScript 语法的 AST 语法树</h3><blockquote><p>JavaScript 中想要使用 AST 进行开发，要知道抽象成语法树之后的结构是什么，里面的字段名称都代表什么含义以及遍历的规则，<br>我们可以通过在线转换网站<strong><a href="http://esprima.org/demo/parse.html" target="_blank" rel="noopener">http://esprima.org/demo/parse.html</a></strong>将 JS 代码装换成 AST 语法树。</p></blockquote><p>通过在线编译工具，可以将 <code>function fn(a, b) {}</code>编译为下面的结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line">            &quot;id&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                &quot;name&quot;: &quot;fn&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;params&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;a&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                    &quot;name&quot;: &quot;b&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;body&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line">                &quot;body&quot;: []</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;generator&quot;: false,</span><br><span class="line">            &quot;expression&quot;: false,</span><br><span class="line">            &quot;async&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>将 JavaScript 语法编译成抽象语法树后，需要对它进行遍历、修该并重新编译，遍历树结构的过程为 “先序深度优先”。</p></blockquote><h2 id="esprima、estraverse-和-escodegen"><a href="#esprima、estraverse-和-escodegen" class="headerlink" title="esprima、estraverse 和 escodegen"></a>esprima、estraverse 和 escodegen</h2><p><code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 模块是操作 AST 的三个重要模块，也是实现 <code>babel</code> 的核心依赖，下面是分别介绍三个模块的作用。</p><h3 id="1、esprima-将-JS-转换成-AST"><a href="#1、esprima-将-JS-转换成-AST" class="headerlink" title="1、esprima 将 JS 转换成 AST"></a>1、esprima 将 JS 转换成 AST</h3><p><strong>esprima 模块的用法如下：</strong></p><blockquote><p>文件：esprima-test.js</p></blockquote><pre><code>const esprima = require(&quot;esprima&quot;);let code = &quot;function fn() {}&quot;;// 生成语法树let tree = esprima.parseScript(code);console.log(tree);// Script {//   type: &apos;Program&apos;,//   body://    [ FunctionDeclaration {//        type: &apos;FunctionDeclaration&apos;,//        id: [Identifier],//        params: [],//        body: [BlockStatement],//        generator: false,//        expression: false,//        async: false } ],//   sourceType: &apos;script&apos; }</code></pre><p>通过上面的案例可以看出，通过 <code>esprima</code> 模块的 <code>parseScript</code> 方法将 JS 代码块转换成语法树，代码块需要转换成字符串，也可以通过 <code>parseModule</code> 方法转换一个模块。</p><h3 id="2、estraverse-遍历和修改-AST"><a href="#2、estraverse-遍历和修改-AST" class="headerlink" title="2、estraverse 遍历和修改 AST"></a>2、estraverse 遍历和修改 AST</h3><p><strong>查看遍历过程：</strong></p><blockquote><p>文件：estraverse-test.js</p></blockquote><pre><code>const esprima = require(&quot;esprima&quot;);const estraverse = require(&quot;estraverse&quot;);let code = &quot;function fn() {}&quot;;// 遍历语法树estraverse.traverse(esprima.parseScript(code), {    enter(node) {console.log(&quot;enter&quot;, node.type);    },    leave() {console.log(&quot;leave&quot;, node.type);    }});// enter Program// enter FunctionDeclaration// enter Identifier// leave Identifier// enter BlockStatement// leave BlockStatement// leave FunctionDeclaration// leave Program</code></pre><p>上面代码通过 <code>estraverse</code> 模块的 <code>traverse</code> 方法将 <code>esprima</code> 模块转换的 AST 进行了遍历，并打印了所有的 <code>type</code> 属性并打印，每含有一个 <code>type</code> 属性的对象被叫做一个节点，修改是获取对应的类型并修改该节点中的属性即可。</p><p>其实深度遍历 AST 就是在遍历每一层的 <code>type</code> 属性，所以遍历会分为两个阶段，进入阶段和离开阶段，在 <code>estraverse</code> 的 <code>traverse</code> 方法中分别用参数指定的 <code>entry</code> 和 <code>leave</code> 两个函数监听，但是我们一般只使用 <code>entry</code>。</p><h3 id="3、escodegen-将-AST-转换成-JS"><a href="#3、escodegen-将-AST-转换成-JS" class="headerlink" title="3、escodegen 将 AST 转换成 JS"></a>3、escodegen 将 AST 转换成 JS</h3><p>下面的案例是一个段 JS 代码块被转换成 AST，并将遍历、修改后的 AST 重新转换成 JS 的全过程。</p><blockquote><p>文件：escodegen-test.js</p></blockquote><pre><code>const esprima = require(&quot;esprima&quot;);const estraverse = require(&quot;estraverse&quot;);const escodegen = require(&quot;escodegen&quot;);let code = &quot;function fn() {}&quot;;// 生成语法树let tree = esprima.parseScript(code);// 遍历语法树estraverse.traverse(tree, {    enter(node) {// 修改函数名if (node.type === &quot;FunctionDeclaration&quot;) {            node.id.name = &quot;ast&quot;;        }    }});// 编译语法树let result = escodegen.generate(tree);console.log(result);// function ast() {// }</code></pre><p><strong><em>在遍历 AST 的过程中 <code>params</code> 值为数组，没有 <code>type</code> 属性。</em></strong></p><hr><h2 id="实现-Babel-语法转换插件"><a href="#实现-Babel-语法转换插件" class="headerlink" title="实现 Babel 语法转换插件"></a>实现 Babel 语法转换插件</h2><p>实现语法转换插件需要借助 <code>babel-core</code> 和 <code>babel-types</code> 两个模块，其实这两个模块就是依赖 <code>esprima</code>、<code>estraverse</code> 和 <code>escodegen</code> 的。</p><p><strong>使用这两个模块需要安装，命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-types</span><br></pre></td></tr></table></figure><h3 id="1、plugin-transform-arrow-functions"><a href="#1、plugin-transform-arrow-functions" class="headerlink" title="1、plugin-transform-arrow-functions"></a>1、plugin-transform-arrow-functions</h3><p><code>plugin-transform-arrow-functions</code> 是 Babel 家族成员之一，用于将箭头函数转换 ES5 语法的函数表达式。</p><blockquote><p>文件：plugin-transform-arrow-functions.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">// 箭头函数代码块</span><br><span class="line">let sumCode = `</span><br><span class="line">const sum = (a, b) =&gt; &#123;</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;`;</span><br><span class="line">let minusCode = `const minus = (a, b) =&gt; a - b;`;</span><br><span class="line"></span><br><span class="line">// 转化 ES5 插件</span><br><span class="line">let ArrowPlugin = &#123;</span><br><span class="line">// 访问者（访问者模式）</span><br><span class="line">    visitor: &#123;</span><br><span class="line">// path 是树的路径</span><br><span class="line">        ArrowFunctionExpression(path) &#123;</span><br><span class="line">// 获取树节点</span><br><span class="line">let node = path.node;</span><br><span class="line"></span><br><span class="line">// 获取参数和函数体</span><br><span class="line">let params = node.params;</span><br><span class="line">let body = node.body;</span><br><span class="line"></span><br><span class="line">// 判断函数体是否是代码块，不是代码块则添加 return 和 &#123;&#125;</span><br><span class="line">if (!types.isBlockStatement(body)) &#123;</span><br><span class="line">let returnStatement = types.returnStatement(body);</span><br><span class="line">                body = types.blockStatement([returnStatement]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">// 生成一个函数表达式树结构</span><br><span class="line">let func = types.functionExpression(null, params, body, false, false);</span><br><span class="line"></span><br><span class="line">// 用新的树结构替换掉旧的树结构</span><br><span class="line">            types.replaceWith(func);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 生成转换后的代码块</span><br><span class="line">let sumResult = babel.transform(sumCode, &#123;</span><br><span class="line">    plugins: [ArrowPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let minusResult = babel.transform(minusCode, &#123;</span><br><span class="line">    plugins: [ArrowPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(sumResult.code);</span><br><span class="line">console.log(minusResult.code);</span><br><span class="line"></span><br><span class="line">// let sum = function (a, b) &#123;</span><br><span class="line">//   return a + b;</span><br><span class="line">// &#125;;</span><br><span class="line">// let minus = function (a, b) &#123;</span><br><span class="line">//   return a - b;</span><br><span class="line">// &#125;;</span><br></pre></td></tr></table></figure><p>我们主要使用 <code>babel-core</code> 的 <code>transform</code> 方法将 AST 转化成代码块，第一个参数为转换前的代码块（字符串），第二个参数为配置项，其中 <code>plugins</code> 值为数组，存储修改 <code>babal-core</code> 转换的 AST 的插件（对象），使用 <code>transform</code> 方法将旧的 AST 处理成新的代码块后，返回值为一个对象，对象的 <code>code</code> 属性为转换后的代码块（字符串）。</p><p>内部修改通过 <code>babel-types</code> 模块提供的方法实现，API 可以到 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank" rel="noopener">https://github.com/babel/babel/tree/6.x/packages/babel-types</a> 中查看。</p><p><code>ArrowPlugin</code> 就是传入 <code>transform</code> 方法的插件，必须含有 <code>visitor</code> 属性（固定），值同为对象，用于存储修改语法树的方法，方法名要严格按照 API，对应的方法会修改 AST 对应的节点。</p><p>在 <code>types.functionExpression</code> 方法中参数分别代表，函数名（匿名函数为 <code>null</code>）、函数参数（必填）、函数体（必填）、是否为 <code>generator</code> 函数（默认 <code>false</code>）、是否为 <code>async</code> 函数（默认 <code>false</code>），返回值为修改后的 AST，<code>types.replaceWith</code> 方法用于替换 AST，参数为新的 AST。</p><h3 id="2、plugin-transform-classes"><a href="#2、plugin-transform-classes" class="headerlink" title="2、plugin-transform-classes"></a>2、plugin-transform-classes</h3><p><code>plugin-transform-classes</code> 也是 Babel 家族中的成员之一，用于将 ES6 的 <code>class</code> 类转换成 ES5 的构造函数。</p><blockquote><p>文件：plugin-transform-classes.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">// 类</span><br><span class="line">let code = `</span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    getName () &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;`;</span><br><span class="line"></span><br><span class="line">// 将类转化 ES5 构造函数插件</span><br><span class="line">let ClassPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ClassDeclaration(path) &#123;</span><br><span class="line">let node = path.node;</span><br><span class="line">let classList = node.body.body;</span><br><span class="line"></span><br><span class="line">// 将取到的类名转换成标识符 &#123; type: &apos;Identifier&apos;, name: &apos;Person&apos; &#125;</span><br><span class="line">let className = types.identifier(node.id.name);</span><br><span class="line">let body = types.blockStatement([]);</span><br><span class="line">let func = types.functionDeclaration(className, [], body, false, false);</span><br><span class="line">            path.replaceWith(func);</span><br><span class="line"></span><br><span class="line">// 用于存储多个原型方法</span><br><span class="line">let es5Func = [];</span><br><span class="line"></span><br><span class="line">// 获取 class 中的代码体</span><br><span class="line">            classList.forEach((item, index) =&gt; &#123;</span><br><span class="line">// 函数的代码体</span><br><span class="line">let body = classList[index].body;</span><br><span class="line"></span><br><span class="line">// 获取参数</span><br><span class="line">let params = item.params.length ? item.params.map(val =&gt; val.name) : [];</span><br><span class="line"></span><br><span class="line">// 转化参数为标识符</span><br><span class="line">                params = types.identifier(params);</span><br><span class="line"></span><br><span class="line">// 判断是否是 constructor，如果构造函数那就生成新的函数替换</span><br><span class="line">if (item.kind === &quot;constructor&quot;) &#123;</span><br><span class="line">// 生成一个构造函数树结构</span><br><span class="line">                    func = types.functionDeclaration(className, [params], body, false, false);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">// 其他情况是原型方法</span><br><span class="line">let proto = types.memberExpression(className, types.identifier(&quot;prototype&quot;));</span><br><span class="line"></span><br><span class="line">// 左侧层层定义标识符 Person.prototype.getName</span><br><span class="line">let left = types.memberExpression(proto, types.identifier(item.key.name));</span><br><span class="line"></span><br><span class="line">// 右侧定义匿名函数</span><br><span class="line">let right = types.functionExpression(null, [params], body, false, false);</span><br><span class="line"></span><br><span class="line">// 将左侧和右侧进行合并并存入数组</span><br><span class="line">                    es5Func.push(types.assignmentExpression(&quot;=&quot;, left, right));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">// 如果没有原型方法，直接替换</span><br><span class="line">if (es5Func.length === 0) &#123;</span><br><span class="line">                path.replaceWith(func);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                es5Func.push(func);</span><br><span class="line">// 替换 n 个节点</span><br><span class="line">                path.replaceWithMultiple(es5Func);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 生成转换后的代码块</span><br><span class="line">result = babel.transform(code, &#123;</span><br><span class="line">    plugins: [ClassPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result.code);</span><br><span class="line"></span><br><span class="line">// Person.prototype.getName = function () &#123;</span><br><span class="line">//     return this.name;</span><br><span class="line">// &#125;</span><br><span class="line">// function Person(name) &#123;</span><br><span class="line">//     this.name = name;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure><p>上面这个插件的实现要比 <code>plugin-transform-arrow-functions</code> 复杂一些，归根结底还是将要互相转换的 ES6 和 ES5 语法树做对比，找到他们的不同，并使用 <code>babel-types</code> 提供的 API 对语法树对应的节点属性进行修改并替换语法树，值得注意的是 <code>path.replaceWithMultiple</code> 与 <code>path.replaceWith</code> 不同，参数为一个数组，数组支持多个语法树结构，可根据具体修改语法树的场景选择使用，也可根据不同情况使用不同的替换方法。</p><blockquote><p>通过本节我们了解了什么是 AST 抽象语法树、抽象语法树在 JavaScript 中的体现以及在 NodeJS 中用于生成、遍历和修改 AST 抽象语法树的核心依赖，并通过使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块简易模拟了 ES6 新特性转换为 ES5 语法的过程，希望可以为后面自己实现一些编译插件提供了思路。</p></blockquote><hr><p>假设我们现在使用了 ElementUI 库的两个组件，通常会使用解构赋值来引入。</p><blockquote><p>优化前</p></blockquote><pre><code>import { Button, Alert } from&quot;element-ui&quot;;</code></pre><p>这样引用资源， Webpack 在打包的时候会找到 <code>element-ui</code> 并把里面所有的代码全部打包到出口文件，我们只使用了两个组件，全部打包不是我们所希望的，<code>tree-sharking</code> 是通过在 Webpack 中配置 <code>babel-plugin-import</code> 插件来实现的，它可以将解构的代码转换成下面的形式。</p><blockquote><p>优化后</p></blockquote><pre><code>import Button from&quot;element-ui/lib/button&quot;;import Alert from&quot;element-ui/lib/Alert&quot;;</code></pre><p>转化后会去 <code>node_modules</code> 中的 <code>element-ui</code> 模块找到 <code>Button</code> 和 <code>Alert</code> 两个组件对应的文件，并打包到出口文件中。</p><p>通过上面的转换可以看出，其实 <code>tree-sharking</code> 的实现原理是通过改变 AST 语法树的结构来实现的，如果不了解抽象语法树可以参考 <a href="https://www.pandashen.com/2018/07/25/20180725130233/" target="_blank" rel="noopener">AST 抽象语法树</a>，</p><blockquote><p>优化前的 AST 语法树</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;imported&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;imported&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优化后的 AST 语法树</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;body&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Button&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui/lib/button&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui/lib/button\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;ImportDeclaration&quot;,</span><br><span class="line">            &quot;specifiers&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;type&quot;: &quot;ImportDefaultSpecifier&quot;,</span><br><span class="line">                    &quot;local&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                        &quot;name&quot;: &quot;Alert&quot;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;source&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;Literal&quot;,</span><br><span class="line">                &quot;value&quot;: &quot;element-ui/lib/Alert&quot;,</span><br><span class="line">                &quot;raw&quot;: &quot;\&quot;element-ui/lib/Alert\&quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;sourceType&quot;: &quot;module&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的语法树对比，可以看出在优化前 <code>body</code> 里面只有一个对象，使用的组件信息存在 <code>specifiers</code> 里，<code>source</code> 指向了 <code>element-ui</code>，而在优化后，将两个组件分别拆成了两个对象存在 <code>body</code> 中，每个对象的的 <code>specifiers</code> 只存储一个组件，并在 <code>source</code> 里面指向了当前组件对应的路径。</p><hr><h2 id="模拟-tree-starking"><a href="#模拟-tree-starking" class="headerlink" title="模拟 tree-starking"></a>模拟 tree-starking</h2><p>既然我们已经清楚要修改语法树的位置，下面就使用 AST 来模拟 <code>tree-sharking</code> 功能，对语法树的操作是依赖于 <code>babel-core</code> 和 <code>babel-types</code> 两个核心模块的，下面先安装依赖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-core babel-types</span><br></pre></td></tr></table></figure></p><blockquote><p>文件：babel-plugin-my-import.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">let code = `import &#123; Button, Alert &#125; from &quot;element-ui&quot;`;</span><br><span class="line"></span><br><span class="line">let importPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ImportDeclaration(path) &#123;</span><br><span class="line">            let node = path.node;</span><br><span class="line">            let source = node.source.value;</span><br><span class="line">            let specifiers = node.specifiers;</span><br><span class="line"></span><br><span class="line">            // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出</span><br><span class="line">            if (!types.isImportDefaultSpecifier(specifiers[0])) &#123;</span><br><span class="line">                // 如果不是默认导出，则需要转换</span><br><span class="line">                specifiers = specifiers.map(specifier =&gt; &#123;</span><br><span class="line">                    // 数组内容：当前默认导出的标识、从哪里导入</span><br><span class="line">                    return types.importDeclaration(</span><br><span class="line">                        [types.importDefaultSpecifier(specifier.local)],</span><br><span class="line">                        types.stringLiteral(`$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;`)</span><br><span class="line">                    );</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // 替换树结构</span><br><span class="line">                path.replaceWithMultiple(specifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let result = babel.transform(code, &#123;</span><br><span class="line">    plugins: [importPlugin]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(result.code);</span><br><span class="line"></span><br><span class="line">// import Button from &quot;element-ui/lib/button&quot;;</span><br><span class="line">// import Alert from &quot;element-ui/lib/alert&quot;;</span><br></pre></td></tr></table></figure><p>通过上面的代码可以发现我们使用 <code>babel-core</code> 和 <code>babel-types</code> 两个模块的核心方法对语法书进行了遍历、修改和替换，更详细的 API 可以查看 <a href="https://github.com/babel/babel/tree/6.x/packages/babel-types" target="_blank" rel="noopener">https://github.com/babel/babel/tree/6.x/packages/babel-types</a>。</p><hr><h2 id="结合-Webpack-使用插件"><a href="#结合-Webpack-使用插件" class="headerlink" title="结合 Webpack 使用插件"></a>结合 Webpack 使用插件</h2><p>前面只是验证了 <code>tree-sharking</code> 中 JS 语法的转换过程，接下来将上面的代码转换成插件配合 Webpack 使用，来彻底感受 <code>tree-sharking</code> 的工作过程。</p><blockquote><p>文件：~node_modules/babel-plugin-my-import.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const babel = require(&quot;babel-core&quot;);</span><br><span class="line">const types = require(&quot;babel-types&quot;);</span><br><span class="line"></span><br><span class="line">let importPlugin = &#123;</span><br><span class="line">    visitor: &#123;</span><br><span class="line">        ImportDeclaration(path) &#123;</span><br><span class="line">            let node = path.node;</span><br><span class="line">            let source = node.source.value;</span><br><span class="line">            let specifiers = node.specifiers;</span><br><span class="line"></span><br><span class="line">            // 判断是否是默认导出，其中一个不是默认导出，则都不是默认导出</span><br><span class="line">            if (!types.isImportDefaultSpecifier(specifiers[0])) &#123;</span><br><span class="line">                // 如果不是默认导出，则需要转换</span><br><span class="line">                specifiers = specifiers.map(specifier =&gt; &#123;</span><br><span class="line">                    // 数组内容：当前默认导出的标识、从哪里导入</span><br><span class="line">                    return types.importDeclaration(</span><br><span class="line">                        [types.importDefaultSpecifier(specifier.local)],</span><br><span class="line">                        types.stringLiteral(`$&#123;source&#125;/lib/$&#123;specifier.local.name.toLowerCase()&#125;`)</span><br><span class="line">                    );</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // 替换树解构</span><br><span class="line">                path.replaceWithMultiple(specifiers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = importPlugin;</span><br></pre></td></tr></table></figure><p>上面删掉了多余的测试代码，将模块中的 <code>importPlugin</code> 插件导出，并把 <code>babel-plugin-my-import.js</code> 移入了 <code>node_modules</code> 当中。</p><p><strong>接下来安装需要的依赖：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli babel-loader babel-presets-env</span><br><span class="line">npm install vue element-ui --save</span><br></pre></td></tr></table></figure></p><p>安装完依赖，写一个要编译的文件，使用 Webpack 进行打包，查看使用插件前和使用插件后出口文件的大小。<br>文件：import.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Vue from&quot;vue&quot;;</span><br><span class="line">import &#123; Button, Alert &#125; from&quot;element-ui&quot;;</span><br></pre></td></tr></table></figure></p><p>下面来写一个简单的 Webpack 配置文件。</p><blockquote><p>文件：webpcak.config.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    module.exports = &#123;</span><br><span class="line">    mode: &quot;development&quot;,</span><br><span class="line">    entry: &quot;import.js&quot;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;bundle.js&quot;,</span><br><span class="line">        path: __dirname</span><br><span class="line">    &#125;,</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: &#123;</span><br><span class="line">                loader: &quot;babel-loader&quot;,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    presets: [</span><br><span class="line">                        &quot;env&quot;,</span><br><span class="line">                    ],</span><br><span class="line">                    plugins: [</span><br><span class="line">                        // 插件：不使用插件打包注释掉该行即可</span><br><span class="line">                        [&quot;my-import&quot;, &#123; libararyName: &quot;element-ui&quot; &#125;]</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            exclude: /node_modules/</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了防止 <code>babel</code> 相关的依赖升级 <code>7.0</code> 后出现一些问题导致 Webpack 无法启动，再此贴出 <code>package.json</code> 文件，按照对应版本下载依赖保证上面 Webpack 配置生效。</p><blockquote><p>文件：package.json</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;name&quot;: &quot;ast-lesson&quot;,</span><br><span class="line"> &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line"> &quot;description&quot;: &quot;tree-starking&quot;,</span><br><span class="line"> &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line"> &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">   &#125;,</span><br><span class="line"> &quot;keywords&quot;: [],</span><br><span class="line"> &quot;author&quot;: &quot;&quot;,</span><br><span class="line"> &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line"> &quot;dependencies&quot;: &#123;</span><br><span class="line"> &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class="line"> &quot;babel-loader&quot;: &quot;^7.1.5&quot;,</span><br><span class="line"> &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,</span><br><span class="line"> &quot;babel-types&quot;: &quot;^6.26.0&quot;,</span><br><span class="line"> &quot;escodegen&quot;: &quot;^1.10.0&quot;,</span><br><span class="line"> &quot;esprima&quot;: &quot;^4.0.0&quot;,</span><br><span class="line"> &quot;estraverse&quot;: &quot;^4.2.0&quot;,</span><br><span class="line"> &quot;webpack&quot;: &quot;^4.16.0&quot;,</span><br><span class="line"> &quot;webpack-cli&quot;: &quot;^3.0.8&quot;</span><br><span class="line">   &#125;,</span><br><span class="line"> &quot;devDependencies&quot;: &#123;</span><br><span class="line"> &quot;vue&quot;: &quot;^2.5.17&quot;,</span><br><span class="line"> &quot;element-ui&quot;: &quot;^2.4.6&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="对比使用插件前后的出口文件"><a href="#对比使用插件前后的出口文件" class="headerlink" title="对比使用插件前后的出口文件"></a>对比使用插件前后的出口文件</h2><p>接下来分别在使用插件和不使用插件时执行打包命令，查看出口文件 <code>bondle.js</code> 的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></p><p>使用 <code>babel-plugin-my-import</code> 前：</p><p><a href="/2018/07/26/20180726122146/before-babel-plugin.jpg"><img src="/2018/10/25/解密webpack-tree-starking/before-babel-plugin.jpg" alt="使用 tree-starking 之前"></a></p><p>使用 <code>babel-plugin-my-import</code> 后：</p><p><a href="/2018/07/26/20180726122146/after-babel-plugin.jpg"><img src="/2018/10/25/解密webpack-tree-starking/after-babel-plugin.jpg" alt="使用 tree-starking 之后"></a></p><p>通过对比，可以看到使用 <code>tree-sharking</code> 即我们自己实现的 <code>babel-plugin-my-import</code> 插件后，打包的出口文件大大减小，其原因是将引入第三方库没有使用的代码全都过滤掉了，只打包了有效代码。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面对 Webpack 的 <code>tree-sharking</code> 进行了分析，并模拟 <code>babel-plugin-import</code> 简易的实现了一版 <code>tree-sharking</code> 的优化插件，这个过程中相信大家已经了解了 <code>tree-sharking</code> 的原理以及实现类似插件的思路，并已经具备了开发类似插件的基本条件，最后还有一点需要补充，<code>tree-sharking</code> 优化的方式是根据 ES6 语法 <code>import</code> “静态” 引入的特性实现的，如果要说 <code>tree-sharking</code> 很强大，还不如说 ES6 模块化规范 “静态” 引入的特性强大，正由于是基于 “静态” 引入，所以目前 <code>tree-sharking</code> 只支持遍历一层 <code>import</code> 关键字。</p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Tree-Shaking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>koa-bodyparser中间件模拟</title>
      <link href="/2018/10/10/koa-bodyparser%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A8%A1%E6%8B%9F/"/>
      <url>/2018/10/10/koa-bodyparser%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%A8%A1%E6%8B%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Koa 2.x</code> 版本是当下最流行的 NodeJS 框架，<code>Koa 2.0</code> 的源码特别精简，不像 <code>Express</code> 封装的功能那么多，所以大部分的功能都是由 <code>Koa</code> 开发团队（同 <code>Express</code> 是一家出品）和社区贡献者针对 <code>Koa</code> 对 NodeJS 的封装特性实现的中间件来提供的，用法非常简单，就是引入中间件，并调用 <code>Koa</code> 的 <code>use</code> 方法使用在对应的位置，这样就可以通过在内部操作 <code>ctx</code> 实现一些功能，我们接下来就讨论常用中间件的实现原理以及我们应该如何开发一个 <code>Koa</code> 中间件供自己和别人使用。</p><h2 id="Koa-的洋葱模型介绍"><a href="#Koa-的洋葱模型介绍" class="headerlink" title="Koa 的洋葱模型介绍"></a>Koa 的洋葱模型介绍</h2><p>我们本次不对洋葱模型的实现原理进行过多的刨析，主要根据 API 的使用方式及洋葱模型分析中间件是如何工作的。</p><pre><code>// 洋葱模型特点// 引入 Koaconst Koa = require(&quot;koa&quot;);// 创建服务const app = new Koa();app.use(async (ctx, next) =&gt; {    console.log(1);    await next();    console.log(2);});app.use(async (ctx, next) =&gt; {    console.log(3);    await next();    console.log(4);});app.use(async (ctx, next) =&gt; {    console.log(5);    await next();    console.log(6);});// 监听服务app.listen(3000);// 1// 3// 5// 6// 4// 2</code></pre><p>我们知道 <code>Koa</code> 的 <code>use</code> 方法是支持异步的，所以为了保证正常的按照洋葱模型的执行顺序执行代码，需要在调用 <code>next</code> 的时候让代码等待，等待异步结束后再继续向下执行，所以我们在 <code>Koa</code> 中都是建议使用 <code>async/await</code> 的，引入的中间件都是在 <code>use</code> 方法中调用，由此我们可以分析出每一个 <code>Koa</code> 的中间件都是返回一个 <code>async</code> 函数的。</p><h2 id="koa-bodyparser-中间件模拟"><a href="#koa-bodyparser-中间件模拟" class="headerlink" title="koa-bodyparser 中间件模拟"></a>koa-bodyparser 中间件模拟</h2><p>想要分析 <code>koa-bodyparser</code> 的原理首先需要知道用法和作用，<code>koa-bodyparser</code> 中间件是将我们的 <code>post</code> 请求和表单提交的查询字符串转换成对象，并挂在 <code>ctx.request.body</code> 上，方便我们在其他中间件或接口处取值，使用前需提前安装。</p><blockquote><p>npm install koa koa-bodyparser</p></blockquote><p><strong>koa-bodyparser 具体用法如下：</strong></p><pre><code>// koa-bodyparser 的用法const Koa = require(&quot;koa&quot;);const bodyParser = require(&quot;koa-bodyparser&quot;);const app = new Koa();// 使用中间件app.use(bodyParser());app.use(async (ctx, next) =&gt; {    if (ctx.path === &quot;/&quot; &amp;&amp; ctx.method === &quot;POST&quot;) {        // 使用中间件后 ctx.request.body 属性自动加上了 post 请求的数据        console.log(ctx.request.body);    }});app.listen(3000);</code></pre><p>根据用法我们可以看出 <code>koa-bodyparser</code> 中间件引入的其实是一个函数，我们把它放在了 <code>use</code> 中执行，根据 <code>Koa</code> 的特点，我们推断出 <code>koa-bodyparser</code> 的函数执行后应该给我们返回了一个 <code>async</code> 函数，下面是我们模拟实现的代码。</p><pre><code>// 文件：my-koa-bodyparser.jsconst querystring = require(&quot;querystring&quot;);module.exports = functionbodyParser() {    returnasync (ctx, next) =&gt; {        await new Promise((resolve, reject) =&gt; {            // 存储数据的数组            let dataArr = [];            // 接收数据            ctx.req.on(&quot;data&quot;, data =&gt; dataArr.push(data));            // 整合数据并使用 Promise 成功            ctx.req.on(&quot;end&quot;, () =&gt; {                // 获取请求数据的类型 json 或表单                let contentType = ctx.get(&quot;Content-Type&quot;);                // 获取数据 Buffer 格式                let data = Buffer.concat(dataArr).toString();                if (contentType === &quot;application/x-www-form-urlencoded&quot;) {                    // 如果是表单提交，则将查询字符串转换成对象赋值给 ctx.request.body                    ctx.request.body = querystring.parse(data);                } elseif (contentType === &quot;applaction/json&quot;) {                    // 如果是 json，则将字符串格式的对象转换成对象赋值给 ctx.request.body                    ctx.request.body = JSON.parse(data);                }                // 执行成功的回调                resolve();            });        });        // 继续向下执行        await next();    };};</code></pre><p>在上面代码中由几点是需要我们注意的，即 <code>next</code> 的调用以及为什么通过流接收数据、处理数据和将数据挂在 <code>ctx.request.body</code> 要在 Promise 中进行。</p><p><strong>首先是 <code>next</code> 的调用，我们知道 <code>Koa</code> 的 <code>next</code> 执行，其实就是在执行下一个中间件的函数，即下一个 <code>use</code> 中的 <code>async</code> 函数，为了保证后面的异步代码执行完毕后再继续执行当前的代码，所以我们需要使用 <code>await</code> 进行等待，其次就是数据从接收到挂在 <code>ctx.request.body</code> 都在 Promise 中执行，是因为在接收数据的操作是异步的，整个处理数据的过程需要等待异步完成后，再把数据挂在 <code>ctx.request.body</code> 上，可以保证我们在下一个 <code>use</code> 的 <code>async</code> 函数中可以在 <code>ctx.request.body</code> 上拿到数据，所以我们使用 <code>await</code> 等待一个 Promise 成功后再执行 <code>next</code>。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> koa </tag>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于IntersectionObserver的图片懒加载实现</title>
      <link href="/2018/10/08/%E5%9F%BA%E4%BA%8EIntersectionObserver%E7%9A%84%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/10/08/%E5%9F%BA%E4%BA%8EIntersectionObserver%E7%9A%84%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;图片懒加载&lt;/title&gt;</span><br><span class="line">  &lt;link href=&quot;./css/style.css&quot; rel=&quot;stylesheet&quot;/&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div id=&quot;view&quot;&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://img.pconline.com.cn/images/upload/upc/tx/wallpaper/1301/05/c0/17135331_1357355776882.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://f.hiphotos.baidu.com/zhidao/pic/item/eac4b74543a982267a3d54978a82b9014b90eb86.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://pic1.win4000.com/wallpaper/2/58b61f7dc6c1d.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://file03.16sucai.com/2017/1100/16sucai_p20161106032_0c2.JPG&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://imgsrc.baidu.com/image/c0%3Dpixel_huitu%2C0%2C0%2C294%2C40/sign=5a7938d38acb39dbd5cd6f16b96e6c48/aec379310a55b3196c79de4c48a98226cffc1702.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">    &lt;img data-src=&quot;http://c.hiphotos.baidu.com/zhidao/pic/item/8d5494eef01f3a2987a8062f9f25bc315d607ceb.jpg&quot; class=&quot;lazy-image&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;link href=&quot;./css/style.css&quot; rel=&quot;stylesheet&quot;/&gt;</span><br><span class="line">&lt;script src=&quot;js/lazy-image.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(document.documentElement.clientHeight)</span><br><span class="line">  new LazyImage(&apos;.lazy-image&apos;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class LazyImage &#123;</span><br><span class="line">    constructor(selector) &#123;</span><br><span class="line">      // 懒记载图片列表，将伪数组转为数组，以便可以使用数组的api</span><br><span class="line">      this.lazyImages = Array.prototype.slice.call(document.querySelectorAll(selector))</span><br><span class="line">      this.init()</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    inViewShow() &#123;</span><br><span class="line">      // 不支持IntersectionObserver api的情况下判断图片是否出现在可视区域内</span><br><span class="line">      let len = this.lazyImages.length</span><br><span class="line">      for(let i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        let lazyImage = this.lazyImages[i]</span><br><span class="line">        const rect = lazyImage.getBoundingClientRect()</span><br><span class="line">        // 出现在视野的时候加载图片</span><br><span class="line">        if(rect.top &lt; document.documentElement.clientHeight) &#123;</span><br><span class="line">          lazyImage.src = lazyImage.dataset.src</span><br><span class="line">          // 移除掉已经显示的</span><br><span class="line">          this.lazyImages.splice(i, 1)</span><br><span class="line">          len--</span><br><span class="line">          i--</span><br><span class="line">          if(this.lazyImages.length === 0) &#123;</span><br><span class="line">            // 如果全部都加载完 则去掉滚动事件监听</span><br><span class="line">            document.removeEventListener(&apos;scroll&apos;, this._throttleFn)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    throttle(fn, delay = 15, mustRun = 30) &#123;</span><br><span class="line">      let t_start = null</span><br><span class="line">      let timer = null</span><br><span class="line">      let context = this</span><br><span class="line">      return function() &#123;</span><br><span class="line">        let t_current = +(new Date())</span><br><span class="line">        let args = Array.prototype.slice.call(arguments)</span><br><span class="line">        clearTimeout(timer)</span><br><span class="line">        if(!t_start) &#123;</span><br><span class="line">          t_start = t_current</span><br><span class="line">        &#125;</span><br><span class="line">        if(t_current - t_start &gt; mustRun) &#123;</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">          t_start = t_current</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          timer = setTimeout(() =&gt; &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">          &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    init() &#123;</span><br><span class="line">      // 通过IntersectionObserver api判断图片是否出现在可视区域内，不需要监听Scroll来判断</span><br><span class="line">      if (&quot;IntersectionObserver&quot; in window) &#123;</span><br><span class="line">        let lazyImageObserver = new IntersectionObserver((entries, observer) =&gt; &#123;</span><br><span class="line">          entries.forEach((entry, index) =&gt; &#123;</span><br><span class="line">            // 如果元素可见</span><br><span class="line">            if (entry.isIntersecting) &#123;</span><br><span class="line">              let lazyImage = entry.target</span><br><span class="line">              lazyImage.src = lazyImage.dataset.src</span><br><span class="line">              lazyImageObserver.unobserve(lazyImage)</span><br><span class="line">              // this.lazyImages.splice(index, 1)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.lazyImages.forEach(function(lazyImage) &#123;</span><br><span class="line">          lazyImageObserver.observe(lazyImage);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.inViewShow()</span><br><span class="line">        this._throttleFn = this.throttle(this.inViewShow)</span><br><span class="line">        document.addEventListener(&apos;scroll&apos;, this._throttleFn)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">html,body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  width: 100%;</span><br><span class="line">  margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#view &#123;</span><br><span class="line">  color: red;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 300px</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.lazy-image &#123;</span><br><span class="line">  background: url(&apos;../img/loading.gif&apos;) no-repeat center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">img&#123;</span><br><span class="line">  margin-top: 100px;</span><br><span class="line">  background-size: cover;</span><br><span class="line">  background-position: center;</span><br><span class="line">  width: 490px;</span><br><span class="line">  height: 242px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 懒加载 </tag>
            
            <tag> IntersectionObserver </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Babel 将 Generator 编译成了什么</title>
      <link href="/2018/10/05/Babel-%E5%B0%86-Generator-%E7%BC%96%E8%AF%91%E6%88%90%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2018/10/05/Babel-%E5%B0%86-Generator-%E7%BC%96%E8%AF%91%E6%88%90%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文就是简单介绍下 Generator 语法编译后的代码。</p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><pre><code>function* helloWorldGenerator() {  yield&apos;hello&apos;;  yield&apos;world&apos;;  return&apos;ending&apos;;}</code></pre><p>我们打印下执行的结果：</p><pre><code>var hw = helloWorldGenerator();console.log(hw.next()); // {value: &quot;hello&quot;, done: false}console.log(hw.next()); // {value: &quot;world&quot;, done: false}console.log(hw.next()); // {value: &quot;ending&quot;, done: true}console.log(hw.next()); // {value: undefined, done: true}</code></pre><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>具体的执行过程就不说了，我们直接在 Babel 官网的 <a href="https://babeljs.io/repl" target="_blank" rel="noopener">Try it out</a> 粘贴上述代码，然后查看代码被编译成了什么样子：</p><pre><code>/** * 我们就称呼这个版本为简单编译版本吧 */var _marked = /*#__PURE__*/ regeneratorRuntime.mark(helloWorldGenerator);functionhelloWorldGenerator() {  return regeneratorRuntime.wrap(    functionhelloWorldGenerator$(_context) {      while (1) {        switch ((_context.prev = _context.next)) {          case0:            _context.next = 2;            return&quot;hello&quot;;          case2:            _context.next = 4;            return&quot;world&quot;;          case4:            return _context.abrupt(&quot;return&quot;, &quot;ending&quot;);          case5:          case&quot;end&quot;:            return _context.stop();        }      }    },    _marked,    this  );}</code></pre><p>猛一看，好像编译后的代码还蛮少的，但是细细一看，编译后的代码肯定是不能用的呀，<code>regeneratorRuntime</code> 是个什么鬼？哪里有声明呀？<code>mark</code> 和 <code>wrap</code> 方法又都做了什么？</p><p>难道就不能编译一个完整可用的代码吗？</p><h2 id="regenerator"><a href="#regenerator" class="headerlink" title="regenerator"></a>regenerator</h2><p>如果你想看到完整可用的代码，你可以使用 <a href="https://github.com/facebook/regenerator" target="_blank" rel="noopener">regenerator</a>，这是 facebook 下的一个工具，用于编译 ES6 的 generator 函数。</p><p>我们先安装一下 regenerator：</p><pre><code>npm install -g regenerator</code></pre><p>然后新建一个 generator.js 文件，里面的代码就是文章最一开始的代码，我们执行命令：</p><pre><code>regenerator --include-runtime generator.js &gt; generator-es5.js</code></pre><p>我们就可以在 generator-es5.js 文件看到编译后的完整可用的代码。</p><p>而这一编译就编译了 700 多行…… 编译后的代码可以查看 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Copyright (c) 2014-present, Facebook, Inc.</span><br><span class="line"> *</span><br><span class="line"> * This source code is licensed under the MIT license found in the</span><br><span class="line"> * LICENSE file in the root directory of this source tree.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">!(function(global) &#123;</span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">  var Op = Object.prototype;</span><br><span class="line">  var hasOwn = Op.hasOwnProperty;</span><br><span class="line">  var undefined; // More compressible than void 0.</span><br><span class="line">  var $Symbol = typeof Symbol === &quot;function&quot; ? Symbol : &#123;&#125;;</span><br><span class="line">  var iteratorSymbol = $Symbol.iterator || &quot;@@iterator&quot;;</span><br><span class="line">  var asyncIteratorSymbol = $Symbol.asyncIterator || &quot;@@asyncIterator&quot;;</span><br><span class="line">  var toStringTagSymbol = $Symbol.toStringTag || &quot;@@toStringTag&quot;;</span><br><span class="line"></span><br><span class="line">  var inModule = typeof module === &quot;object&quot;;</span><br><span class="line">  var runtime = global.regeneratorRuntime;</span><br><span class="line">  if (runtime) &#123;</span><br><span class="line">    if (inModule) &#123;</span><br><span class="line">      // If regeneratorRuntime is defined globally and we&apos;re in a module,</span><br><span class="line">      // make the exports object identical to regeneratorRuntime.</span><br><span class="line">      module.exports = runtime;</span><br><span class="line">    &#125;</span><br><span class="line">    // Don&apos;t bother evaluating the rest of this file if the runtime was</span><br><span class="line">    // already defined globally.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Define the runtime globally (as expected by generated code) as either</span><br><span class="line">  // module.exports (if we&apos;re in a module) or a new, empty object.</span><br><span class="line">  runtime = global.regeneratorRuntime = inModule ? module.exports : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  function wrap(innerFn, outerFn, self, tryLocsList) &#123;</span><br><span class="line">    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.</span><br><span class="line">    var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn : Generator;</span><br><span class="line">    var generator = Object.create(protoGenerator.prototype);</span><br><span class="line">    var context = new Context(tryLocsList || []);</span><br><span class="line"></span><br><span class="line">    // The ._invoke method unifies the implementations of the .next,</span><br><span class="line">    // .throw, and .return methods.</span><br><span class="line">    generator._invoke = makeInvokeMethod(innerFn, self, context);</span><br><span class="line"></span><br><span class="line">    return generator;</span><br><span class="line">  &#125;</span><br><span class="line">  runtime.wrap = wrap;</span><br><span class="line"></span><br><span class="line">  // Try/catch helper to minimize deoptimizations. Returns a completion</span><br><span class="line">  // record like context.tryEntries[i].completion. This interface could</span><br><span class="line">  // have been (and was previously) designed to take a closure to be</span><br><span class="line">  // invoked without arguments, but in all the cases we care about we</span><br><span class="line">  // already have an existing method we want to call, so there&apos;s no need</span><br><span class="line">  // to create a new function object. We can even get away with assuming</span><br><span class="line">  // the method takes exactly one argument, since that happens to be true</span><br><span class="line">  // in every case, so we don&apos;t have to touch the arguments object. The</span><br><span class="line">  // only additional allocation required is the completion record, which</span><br><span class="line">  // has a stable shape and so hopefully should be cheap to allocate.</span><br><span class="line">  function tryCatch(fn, obj, arg) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      return &#123; type: &quot;normal&quot;, arg: fn.call(obj, arg) &#125;;</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      return &#123; type: &quot;throw&quot;, arg: err &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var GenStateSuspendedStart = &quot;suspendedStart&quot;;</span><br><span class="line">  var GenStateSuspendedYield = &quot;suspendedYield&quot;;</span><br><span class="line">  var GenStateExecuting = &quot;executing&quot;;</span><br><span class="line">  var GenStateCompleted = &quot;completed&quot;;</span><br><span class="line"></span><br><span class="line">  // Returning this object from the innerFn has the same effect as</span><br><span class="line">  // breaking out of the dispatch switch statement.</span><br><span class="line">  var ContinueSentinel = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  // Dummy constructor functions that we use as the .constructor and</span><br><span class="line">  // .constructor.prototype properties for functions that return Generator</span><br><span class="line">  // objects. For full spec compliance, you may wish to configure your</span><br><span class="line">  // minifier not to mangle the names of these two functions.</span><br><span class="line">  function Generator() &#123;&#125;</span><br><span class="line">  function GeneratorFunction() &#123;&#125;</span><br><span class="line">  function GeneratorFunctionPrototype() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // This is a polyfill for %IteratorPrototype% for environments that</span><br><span class="line">  // don&apos;t natively support it.</span><br><span class="line">  var IteratorPrototype = &#123;&#125;;</span><br><span class="line">  IteratorPrototype[iteratorSymbol] = function () &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var getProto = Object.getPrototypeOf;</span><br><span class="line">  var NativeIteratorPrototype = getProto &amp;&amp; getProto(getProto(values([])));</span><br><span class="line">  if (NativeIteratorPrototype &amp;&amp;</span><br><span class="line">      NativeIteratorPrototype !== Op &amp;&amp;</span><br><span class="line">      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) &#123;</span><br><span class="line">    // This environment has a native %IteratorPrototype%; use it instead</span><br><span class="line">    // of the polyfill.</span><br><span class="line">    IteratorPrototype = NativeIteratorPrototype;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var Gp = GeneratorFunctionPrototype.prototype =</span><br><span class="line">    Generator.prototype = Object.create(IteratorPrototype);</span><br><span class="line">  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;</span><br><span class="line">  GeneratorFunctionPrototype.constructor = GeneratorFunction;</span><br><span class="line">  GeneratorFunctionPrototype[toStringTagSymbol] =</span><br><span class="line">    GeneratorFunction.displayName = &quot;GeneratorFunction&quot;;</span><br><span class="line"></span><br><span class="line">  // Helper for defining the .next, .throw, and .return methods of the</span><br><span class="line">  // Iterator interface in terms of a single ._invoke method.</span><br><span class="line">  function defineIteratorMethods(prototype) &#123;</span><br><span class="line">    [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) &#123;</span><br><span class="line">      prototype[method] = function(arg) &#123;</span><br><span class="line">        return this._invoke(method, arg);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  runtime.isGeneratorFunction = function(genFun) &#123;</span><br><span class="line">    var ctor = typeof genFun === &quot;function&quot; &amp;&amp; genFun.constructor;</span><br><span class="line">    return ctor</span><br><span class="line">      ? ctor === GeneratorFunction ||</span><br><span class="line">        // For the native GeneratorFunction constructor, the best we can</span><br><span class="line">        // do is to check its .name property.</span><br><span class="line">        (ctor.displayName || ctor.name) === &quot;GeneratorFunction&quot;</span><br><span class="line">      : false;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  runtime.mark = function(genFun) &#123;</span><br><span class="line">    if (Object.setPrototypeOf) &#123;</span><br><span class="line">      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      genFun.__proto__ = GeneratorFunctionPrototype;</span><br><span class="line">      if (!(toStringTagSymbol in genFun)) &#123;</span><br><span class="line">        genFun[toStringTagSymbol] = &quot;GeneratorFunction&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    genFun.prototype = Object.create(Gp);</span><br><span class="line">    return genFun;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // Within the body of any async function, `await x` is transformed to</span><br><span class="line">  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test</span><br><span class="line">  // `hasOwn.call(value, &quot;__await&quot;)` to determine if the yielded value is</span><br><span class="line">  // meant to be awaited.</span><br><span class="line">  runtime.awrap = function(arg) &#123;</span><br><span class="line">    return &#123; __await: arg &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function AsyncIterator(generator) &#123;</span><br><span class="line">    function invoke(method, arg, resolve, reject) &#123;</span><br><span class="line">      var record = tryCatch(generator[method], generator, arg);</span><br><span class="line">      if (record.type === &quot;throw&quot;) &#123;</span><br><span class="line">        reject(record.arg);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        var result = record.arg;</span><br><span class="line">        var value = result.value;</span><br><span class="line">        if (value &amp;&amp;</span><br><span class="line">            typeof value === &quot;object&quot; &amp;&amp;</span><br><span class="line">            hasOwn.call(value, &quot;__await&quot;)) &#123;</span><br><span class="line">          return Promise.resolve(value.__await).then(function(value) &#123;</span><br><span class="line">            invoke(&quot;next&quot;, value, resolve, reject);</span><br><span class="line">          &#125;, function(err) &#123;</span><br><span class="line">            invoke(&quot;throw&quot;, err, resolve, reject);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Promise.resolve(value).then(function(unwrapped) &#123;</span><br><span class="line">          // When a yielded Promise is resolved, its final value becomes</span><br><span class="line">          // the .value of the Promise&lt;&#123;value,done&#125;&gt; result for the</span><br><span class="line">          // current iteration.</span><br><span class="line">          result.value = unwrapped;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;, function(error) &#123;</span><br><span class="line">          // If a rejected Promise was yielded, throw the rejection back</span><br><span class="line">          // into the async generator function so it can be handled there.</span><br><span class="line">          return invoke(&quot;throw&quot;, error, resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var previousPromise;</span><br><span class="line"></span><br><span class="line">    function enqueue(method, arg) &#123;</span><br><span class="line">      function callInvokeWithMethodAndArg() &#123;</span><br><span class="line">        return new Promise(function(resolve, reject) &#123;</span><br><span class="line">          invoke(method, arg, resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return previousPromise =</span><br><span class="line">        // If enqueue has been called before, then we want to wait until</span><br><span class="line">        // all previous Promises have been resolved before calling invoke,</span><br><span class="line">        // so that results are always delivered in the correct order. If</span><br><span class="line">        // enqueue has not been called before, then it is important to</span><br><span class="line">        // call invoke immediately, without waiting on a callback to fire,</span><br><span class="line">        // so that the async generator function has the opportunity to do</span><br><span class="line">        // any necessary setup in a predictable way. This predictability</span><br><span class="line">        // is why the Promise constructor synchronously invokes its</span><br><span class="line">        // executor callback, and why async functions synchronously</span><br><span class="line">        // execute code before the first await. Since we implement simple</span><br><span class="line">        // async functions in terms of async generators, it is especially</span><br><span class="line">        // important to get this right, even though it requires care.</span><br><span class="line">        previousPromise ? previousPromise.then(</span><br><span class="line">          callInvokeWithMethodAndArg,</span><br><span class="line">          // Avoid propagating failures to Promises returned by later</span><br><span class="line">          // invocations of the iterator.</span><br><span class="line">          callInvokeWithMethodAndArg</span><br><span class="line">        ) : callInvokeWithMethodAndArg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Define the unified helper method that is used to implement .next,</span><br><span class="line">    // .throw, and .return (see defineIteratorMethods).</span><br><span class="line">    this._invoke = enqueue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  defineIteratorMethods(AsyncIterator.prototype);</span><br><span class="line">  AsyncIterator.prototype[asyncIteratorSymbol] = function () &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;;</span><br><span class="line">  runtime.AsyncIterator = AsyncIterator;</span><br><span class="line"></span><br><span class="line">  // Note that simple async functions are implemented on top of</span><br><span class="line">  // AsyncIterator objects; they just return a Promise for the value of</span><br><span class="line">  // the final result produced by the iterator.</span><br><span class="line">  runtime.async = function(innerFn, outerFn, self, tryLocsList) &#123;</span><br><span class="line">    var iter = new AsyncIterator(</span><br><span class="line">      wrap(innerFn, outerFn, self, tryLocsList)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    return runtime.isGeneratorFunction(outerFn)</span><br><span class="line">      ? iter // If outerFn is a generator, return the full iterator.</span><br><span class="line">      : iter.next().then(function(result) &#123;</span><br><span class="line">          return result.done ? result.value : iter.next();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function makeInvokeMethod(innerFn, self, context) &#123;</span><br><span class="line">    var state = GenStateSuspendedStart;</span><br><span class="line"></span><br><span class="line">    return function invoke(method, arg) &#123;</span><br><span class="line">      if (state === GenStateExecuting) &#123;</span><br><span class="line">        throw new Error(&quot;Generator is already running&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (state === GenStateCompleted) &#123;</span><br><span class="line">        if (method === &quot;throw&quot;) &#123;</span><br><span class="line">          throw arg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Be forgiving, per 25.3.3.3.3 of the spec:</span><br><span class="line">        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume</span><br><span class="line">        return doneResult();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      context.method = method;</span><br><span class="line">      context.arg = arg;</span><br><span class="line"></span><br><span class="line">      while (true) &#123;</span><br><span class="line">        var delegate = context.delegate;</span><br><span class="line">        if (delegate) &#123;</span><br><span class="line">          var delegateResult = maybeInvokeDelegate(delegate, context);</span><br><span class="line">          if (delegateResult) &#123;</span><br><span class="line">            if (delegateResult === ContinueSentinel) continue;</span><br><span class="line">            return delegateResult;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (context.method === &quot;next&quot;) &#123;</span><br><span class="line">          // Setting context._sent for legacy support of Babel&apos;s</span><br><span class="line">          // function.sent implementation.</span><br><span class="line">          context.sent = context._sent = context.arg;</span><br><span class="line"></span><br><span class="line">        &#125; else if (context.method === &quot;throw&quot;) &#123;</span><br><span class="line">          if (state === GenStateSuspendedStart) &#123;</span><br><span class="line">            state = GenStateCompleted;</span><br><span class="line">            throw context.arg;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          context.dispatchException(context.arg);</span><br><span class="line"></span><br><span class="line">        &#125; else if (context.method === &quot;return&quot;) &#123;</span><br><span class="line">          context.abrupt(&quot;return&quot;, context.arg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        state = GenStateExecuting;</span><br><span class="line"></span><br><span class="line">        var record = tryCatch(innerFn, self, context);</span><br><span class="line">        if (record.type === &quot;normal&quot;) &#123;</span><br><span class="line">          // If an exception is thrown from innerFn, we leave state ===</span><br><span class="line">          // GenStateExecuting and loop back for another invocation.</span><br><span class="line">          state = context.done</span><br><span class="line">            ? GenStateCompleted</span><br><span class="line">            : GenStateSuspendedYield;</span><br><span class="line"></span><br><span class="line">          if (record.arg === ContinueSentinel) &#123;</span><br><span class="line">            continue;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return &#123;</span><br><span class="line">            value: record.arg,</span><br><span class="line">            done: context.done</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">        &#125; else if (record.type === &quot;throw&quot;) &#123;</span><br><span class="line">          state = GenStateCompleted;</span><br><span class="line">          // Dispatch the exception by looping back around to the</span><br><span class="line">          // context.dispatchException(context.arg) call above.</span><br><span class="line">          context.method = &quot;throw&quot;;</span><br><span class="line">          context.arg = record.arg;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Call delegate.iterator[context.method](context.arg) and handle the</span><br><span class="line">  // result, either by returning a &#123; value, done &#125; result from the</span><br><span class="line">  // delegate iterator, or by modifying context.method and context.arg,</span><br><span class="line">  // setting context.delegate to null, and returning the ContinueSentinel.</span><br><span class="line">  function maybeInvokeDelegate(delegate, context) &#123;</span><br><span class="line">    var method = delegate.iterator[context.method];</span><br><span class="line">    if (method === undefined) &#123;</span><br><span class="line">      // A .throw or .return when the delegate iterator has no .throw</span><br><span class="line">      // method always terminates the yield* loop.</span><br><span class="line">      context.delegate = null;</span><br><span class="line"></span><br><span class="line">      if (context.method === &quot;throw&quot;) &#123;</span><br><span class="line">        if (delegate.iterator.return) &#123;</span><br><span class="line">          // If the delegate iterator has a return method, give it a</span><br><span class="line">          // chance to clean up.</span><br><span class="line">          context.method = &quot;return&quot;;</span><br><span class="line">          context.arg = undefined;</span><br><span class="line">          maybeInvokeDelegate(delegate, context);</span><br><span class="line"></span><br><span class="line">          if (context.method === &quot;throw&quot;) &#123;</span><br><span class="line">            // If maybeInvokeDelegate(context) changed context.method from</span><br><span class="line">            // &quot;return&quot; to &quot;throw&quot;, let that override the TypeError below.</span><br><span class="line">            return ContinueSentinel;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        context.method = &quot;throw&quot;;</span><br><span class="line">        context.arg = new TypeError(</span><br><span class="line">          &quot;The iterator does not provide a &apos;throw&apos; method&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return ContinueSentinel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var record = tryCatch(method, delegate.iterator, context.arg);</span><br><span class="line"></span><br><span class="line">    if (record.type === &quot;throw&quot;) &#123;</span><br><span class="line">      context.method = &quot;throw&quot;;</span><br><span class="line">      context.arg = record.arg;</span><br><span class="line">      context.delegate = null;</span><br><span class="line">      return ContinueSentinel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var info = record.arg;</span><br><span class="line"></span><br><span class="line">    if (! info) &#123;</span><br><span class="line">      context.method = &quot;throw&quot;;</span><br><span class="line">      context.arg = new TypeError(&quot;iterator result is not an object&quot;);</span><br><span class="line">      context.delegate = null;</span><br><span class="line">      return ContinueSentinel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (info.done) &#123;</span><br><span class="line">      // Assign the result of the finished delegate to the temporary</span><br><span class="line">      // variable specified by delegate.resultName (see delegateYield).</span><br><span class="line">      context[delegate.resultName] = info.value;</span><br><span class="line"></span><br><span class="line">      // Resume execution at the desired location (see delegateYield).</span><br><span class="line">      context.next = delegate.nextLoc;</span><br><span class="line"></span><br><span class="line">      // If context.method was &quot;throw&quot; but the delegate handled the</span><br><span class="line">      // exception, let the outer generator proceed normally. If</span><br><span class="line">      // context.method was &quot;next&quot;, forget context.arg since it has been</span><br><span class="line">      // &quot;consumed&quot; by the delegate iterator. If context.method was</span><br><span class="line">      // &quot;return&quot;, allow the original .return call to continue in the</span><br><span class="line">      // outer generator.</span><br><span class="line">      if (context.method !== &quot;return&quot;) &#123;</span><br><span class="line">        context.method = &quot;next&quot;;</span><br><span class="line">        context.arg = undefined;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Re-yield the result returned by the delegate method.</span><br><span class="line">      return info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The delegate iterator is finished, so forget it and continue with</span><br><span class="line">    // the outer generator.</span><br><span class="line">    context.delegate = null;</span><br><span class="line">    return ContinueSentinel;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Define Generator.prototype.&#123;next,throw,return&#125; in terms of the</span><br><span class="line">  // unified ._invoke helper method.</span><br><span class="line">  defineIteratorMethods(Gp);</span><br><span class="line"></span><br><span class="line">  Gp[toStringTagSymbol] = &quot;Generator&quot;;</span><br><span class="line"></span><br><span class="line">  // A Generator should always return itself as the iterator object when the</span><br><span class="line">  // @@iterator function is called on it. Some browsers&apos; implementations of the</span><br><span class="line">  // iterator prototype chain incorrectly implement this, causing the Generator</span><br><span class="line">  // object to not be returned from this call. This ensures that doesn&apos;t happen.</span><br><span class="line">  // See https://github.com/facebook/regenerator/issues/274 for more details.</span><br><span class="line">  Gp[iteratorSymbol] = function() &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Gp.toString = function() &#123;</span><br><span class="line">    return &quot;[object Generator]&quot;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function pushTryEntry(locs) &#123;</span><br><span class="line">    var entry = &#123; tryLoc: locs[0] &#125;;</span><br><span class="line"></span><br><span class="line">    if (1 in locs) &#123;</span><br><span class="line">      entry.catchLoc = locs[1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (2 in locs) &#123;</span><br><span class="line">      entry.finallyLoc = locs[2];</span><br><span class="line">      entry.afterLoc = locs[3];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.tryEntries.push(entry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function resetTryEntry(entry) &#123;</span><br><span class="line">    var record = entry.completion || &#123;&#125;;</span><br><span class="line">    record.type = &quot;normal&quot;;</span><br><span class="line">    delete record.arg;</span><br><span class="line">    entry.completion = record;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function Context(tryLocsList) &#123;</span><br><span class="line">    // The root entry object (effectively a try statement without a catch</span><br><span class="line">    // or a finally block) gives us a place to store values thrown from</span><br><span class="line">    // locations where there is no enclosing try statement.</span><br><span class="line">    this.tryEntries = [&#123; tryLoc: &quot;root&quot; &#125;];</span><br><span class="line">    tryLocsList.forEach(pushTryEntry, this);</span><br><span class="line">    this.reset(true);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  runtime.keys = function(object) &#123;</span><br><span class="line">    var keys = [];</span><br><span class="line">    for (var key in object) &#123;</span><br><span class="line">      keys.push(key);</span><br><span class="line">    &#125;</span><br><span class="line">    keys.reverse();</span><br><span class="line"></span><br><span class="line">    // Rather than returning an object with a next method, we keep</span><br><span class="line">    // things simple and return the next function itself.</span><br><span class="line">    return function next() &#123;</span><br><span class="line">      while (keys.length) &#123;</span><br><span class="line">        var key = keys.pop();</span><br><span class="line">        if (key in object) &#123;</span><br><span class="line">          next.value = key;</span><br><span class="line">          next.done = false;</span><br><span class="line">          return next;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // To avoid creating an additional object, we just hang the .value</span><br><span class="line">      // and .done properties off the next function object itself. This</span><br><span class="line">      // also ensures that the minifier will not anonymize the function.</span><br><span class="line">      next.done = true;</span><br><span class="line">      return next;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  function values(iterable) &#123;</span><br><span class="line">    if (iterable) &#123;</span><br><span class="line">      var iteratorMethod = iterable[iteratorSymbol];</span><br><span class="line">      if (iteratorMethod) &#123;</span><br><span class="line">        return iteratorMethod.call(iterable);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (typeof iterable.next === &quot;function&quot;) &#123;</span><br><span class="line">        return iterable;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!isNaN(iterable.length)) &#123;</span><br><span class="line">        var i = -1, next = function next() &#123;</span><br><span class="line">          while (++i &lt; iterable.length) &#123;</span><br><span class="line">            if (hasOwn.call(iterable, i)) &#123;</span><br><span class="line">              next.value = iterable[i];</span><br><span class="line">              next.done = false;</span><br><span class="line">              return next;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          next.value = undefined;</span><br><span class="line">          next.done = true;</span><br><span class="line"></span><br><span class="line">          return next;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        return next.next = next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return an iterator with no values.</span><br><span class="line">    return &#123; next: doneResult &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  runtime.values = values;</span><br><span class="line"></span><br><span class="line">  function doneResult() &#123;</span><br><span class="line">    return &#123; value: undefined, done: true &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Context.prototype = &#123;</span><br><span class="line">    constructor: Context,</span><br><span class="line"></span><br><span class="line">    reset: function(skipTempReset) &#123;</span><br><span class="line">      this.prev = 0;</span><br><span class="line">      this.next = 0;</span><br><span class="line">      // Resetting context._sent for legacy support of Babel&apos;s</span><br><span class="line">      // function.sent implementation.</span><br><span class="line">      this.sent = this._sent = undefined;</span><br><span class="line">      this.done = false;</span><br><span class="line">      this.delegate = null;</span><br><span class="line"></span><br><span class="line">      this.method = &quot;next&quot;;</span><br><span class="line">      this.arg = undefined;</span><br><span class="line"></span><br><span class="line">      this.tryEntries.forEach(resetTryEntry);</span><br><span class="line"></span><br><span class="line">      if (!skipTempReset) &#123;</span><br><span class="line">        for (var name in this) &#123;</span><br><span class="line">          // Not sure about the optimal order of these conditions:</span><br><span class="line">          if (name.charAt(0) === &quot;t&quot; &amp;&amp;</span><br><span class="line">              hasOwn.call(this, name) &amp;&amp;</span><br><span class="line">              !isNaN(+name.slice(1))) &#123;</span><br><span class="line">            this[name] = undefined;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    stop: function() &#123;</span><br><span class="line">      this.done = true;</span><br><span class="line"></span><br><span class="line">      var rootEntry = this.tryEntries[0];</span><br><span class="line">      var rootRecord = rootEntry.completion;</span><br><span class="line">      if (rootRecord.type === &quot;throw&quot;) &#123;</span><br><span class="line">        throw rootRecord.arg;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return this.rval;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dispatchException: function(exception) &#123;</span><br><span class="line">      if (this.done) &#123;</span><br><span class="line">        throw exception;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var context = this;</span><br><span class="line">      function handle(loc, caught) &#123;</span><br><span class="line">        record.type = &quot;throw&quot;;</span><br><span class="line">        record.arg = exception;</span><br><span class="line">        context.next = loc;</span><br><span class="line"></span><br><span class="line">        if (caught) &#123;</span><br><span class="line">          // If the dispatched exception was caught by a catch block,</span><br><span class="line">          // then let that catch block handle the exception normally.</span><br><span class="line">          context.method = &quot;next&quot;;</span><br><span class="line">          context.arg = undefined;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return !! caught;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        var entry = this.tryEntries[i];</span><br><span class="line">        var record = entry.completion;</span><br><span class="line"></span><br><span class="line">        if (entry.tryLoc === &quot;root&quot;) &#123;</span><br><span class="line">          // Exception thrown outside of any try block that could handle</span><br><span class="line">          // it, so set the completion value of the entire function to</span><br><span class="line">          // throw the exception.</span><br><span class="line">          return handle(&quot;end&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (entry.tryLoc &lt;= this.prev) &#123;</span><br><span class="line">          var hasCatch = hasOwn.call(entry, &quot;catchLoc&quot;);</span><br><span class="line">          var hasFinally = hasOwn.call(entry, &quot;finallyLoc&quot;);</span><br><span class="line"></span><br><span class="line">          if (hasCatch &amp;&amp; hasFinally) &#123;</span><br><span class="line">            if (this.prev &lt; entry.catchLoc) &#123;</span><br><span class="line">              return handle(entry.catchLoc, true);</span><br><span class="line">            &#125; else if (this.prev &lt; entry.finallyLoc) &#123;</span><br><span class="line">              return handle(entry.finallyLoc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else if (hasCatch) &#123;</span><br><span class="line">            if (this.prev &lt; entry.catchLoc) &#123;</span><br><span class="line">              return handle(entry.catchLoc, true);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else if (hasFinally) &#123;</span><br><span class="line">            if (this.prev &lt; entry.finallyLoc) &#123;</span><br><span class="line">              return handle(entry.finallyLoc);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            throw new Error(&quot;try statement without catch or finally&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    abrupt: function(type, arg) &#123;</span><br><span class="line">      for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        var entry = this.tryEntries[i];</span><br><span class="line">        if (entry.tryLoc &lt;= this.prev &amp;&amp;</span><br><span class="line">            hasOwn.call(entry, &quot;finallyLoc&quot;) &amp;&amp;</span><br><span class="line">            this.prev &lt; entry.finallyLoc) &#123;</span><br><span class="line">          var finallyEntry = entry;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (finallyEntry &amp;&amp;</span><br><span class="line">          (type === &quot;break&quot; ||</span><br><span class="line">           type === &quot;continue&quot;) &amp;&amp;</span><br><span class="line">          finallyEntry.tryLoc &lt;= arg &amp;&amp;</span><br><span class="line">          arg &lt;= finallyEntry.finallyLoc) &#123;</span><br><span class="line">        // Ignore the finally entry if control is not jumping to a</span><br><span class="line">        // location outside the try/catch block.</span><br><span class="line">        finallyEntry = null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var record = finallyEntry ? finallyEntry.completion : &#123;&#125;;</span><br><span class="line">      record.type = type;</span><br><span class="line">      record.arg = arg;</span><br><span class="line"></span><br><span class="line">      if (finallyEntry) &#123;</span><br><span class="line">        this.method = &quot;next&quot;;</span><br><span class="line">        this.next = finallyEntry.finallyLoc;</span><br><span class="line">        return ContinueSentinel;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return this.complete(record);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    complete: function(record, afterLoc) &#123;</span><br><span class="line">      if (record.type === &quot;throw&quot;) &#123;</span><br><span class="line">        throw record.arg;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (record.type === &quot;break&quot; ||</span><br><span class="line">          record.type === &quot;continue&quot;) &#123;</span><br><span class="line">        this.next = record.arg;</span><br><span class="line">      &#125; else if (record.type === &quot;return&quot;) &#123;</span><br><span class="line">        this.rval = this.arg = record.arg;</span><br><span class="line">        this.method = &quot;return&quot;;</span><br><span class="line">        this.next = &quot;end&quot;;</span><br><span class="line">      &#125; else if (record.type === &quot;normal&quot; &amp;&amp; afterLoc) &#123;</span><br><span class="line">        this.next = afterLoc;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return ContinueSentinel;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    finish: function(finallyLoc) &#123;</span><br><span class="line">      for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        var entry = this.tryEntries[i];</span><br><span class="line">        if (entry.finallyLoc === finallyLoc) &#123;</span><br><span class="line">          this.complete(entry.completion, entry.afterLoc);</span><br><span class="line">          resetTryEntry(entry);</span><br><span class="line">          return ContinueSentinel;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &quot;catch&quot;: function(tryLoc) &#123;</span><br><span class="line">      for (var i = this.tryEntries.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">        var entry = this.tryEntries[i];</span><br><span class="line">        if (entry.tryLoc === tryLoc) &#123;</span><br><span class="line">          var record = entry.completion;</span><br><span class="line">          if (record.type === &quot;throw&quot;) &#123;</span><br><span class="line">            var thrown = record.arg;</span><br><span class="line">            resetTryEntry(entry);</span><br><span class="line">          &#125;</span><br><span class="line">          return thrown;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // The context.catch method must only be called with a location</span><br><span class="line">      // argument that corresponds to a known catch block.</span><br><span class="line">      throw new Error(&quot;illegal catch attempt&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    delegateYield: function(iterable, resultName, nextLoc) &#123;</span><br><span class="line">      this.delegate = &#123;</span><br><span class="line">        iterator: values(iterable),</span><br><span class="line">        resultName: resultName,</span><br><span class="line">        nextLoc: nextLoc</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      if (this.method === &quot;next&quot;) &#123;</span><br><span class="line">        // Deliberately forget the last sent value so that we don&apos;t</span><br><span class="line">        // accidentally pass it on to the delegate.</span><br><span class="line">        this.arg = undefined;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return ContinueSentinel;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(</span><br><span class="line">  // In sloppy mode, unbound `this` refers to the global object, fallback to</span><br><span class="line">  // Function constructor if we&apos;re in global strict mode. That is sadly a form</span><br><span class="line">  // of indirect eval which violates Content Security Policy.</span><br><span class="line">  (function() &#123;</span><br><span class="line">    return this || (typeof self === &quot;object&quot; &amp;&amp; self);</span><br><span class="line">  &#125;)() || Function(&quot;return this&quot;)()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">var _marked =</span><br><span class="line">/*#__PURE__*/</span><br><span class="line">regeneratorRuntime.mark(helloWorldGenerator);</span><br><span class="line"></span><br><span class="line">function helloWorldGenerator() &#123;</span><br><span class="line">  return regeneratorRuntime.wrap(function helloWorldGenerator$(_context) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      switch (_context.prev = _context.next) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">          _context.next = 2;</span><br><span class="line">          return &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">        case 2:</span><br><span class="line">          _context.next = 4;</span><br><span class="line">          return &apos;world&apos;;</span><br><span class="line"></span><br><span class="line">        case 4:</span><br><span class="line">          return _context.abrupt(&quot;return&quot;, &apos;ending&apos;);</span><br><span class="line"></span><br><span class="line">        case 5:</span><br><span class="line">        case &quot;end&quot;:</span><br><span class="line">          return _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, _marked, this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var hw = helloWorldGenerator();</span><br><span class="line">console.log(hw.next()); // &#123;value: &quot;hello&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">console.log(hw.next()); // &#123;value: &quot;world&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">console.log(hw.next()); // &#123;value: &quot;ending&quot;, done: true&#125;</span><br><span class="line"></span><br><span class="line">console.log(hw.next()); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>总之编译后的代码还蛮复杂，我们可以从中抽离出大致的逻辑，至少让简单编译的那段代码能够跑起来。</p><h2 id="mark-函数"><a href="#mark-函数" class="headerlink" title="mark 函数"></a>mark 函数</h2><p>简单编译后的代码第一段是这样的：</p><pre><code>var _marked = /*#__PURE__*/ regeneratorRuntime.mark(helloWorldGenerator);</code></pre><p>我们查看完整编译版本中 mark 函数的源码：</p><pre><code>runtime.mark = function(genFun) {  genFun.__proto__ = GeneratorFunctionPrototype;  genFun.prototype = Object.create(Gp);  return genFun;};</code></pre><p>这其中又涉及了 GeneratorFunctionPrototype 和 Gp 变量，我们也查看下对应的代码：</p><pre><code>functionGenerator() {}functionGeneratorFunction() {}functionGeneratorFunctionPrototype() {}...var Gp = GeneratorFunctionPrototype.prototype =  Generator.prototype = Object.create(IteratorPrototype);GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;GeneratorFunctionPrototype.constructor = GeneratorFunction;GeneratorFunctionPrototype[toStringTagSymbol] =  GeneratorFunction.displayName = &quot;GeneratorFunction&quot;;</code></pre><p>这段代码构建了一堆看起来很复杂的关系链，其实这是参照着 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.ecma-international.org%2Fecma-262%2F6.0%2F%23sec-generatorfunction-constructor" target="_blank" rel="noopener">ES6 规范</a>构建的关系链:<br><img src="/2018/10/05/Babel-将-Generator-编译成了什么/166c52b4064a3c92.webp" alt="regenerator"><br>图中 <code>+@@toStringTag:s = &#39;Generator&#39;</code> 的就是 Gp，<code>+@@toStringTag:s = &#39;GeneratorFunction&#39;</code> 的就是 GeneratorFunctionPrototype。</p><p>构建关系链的目的在于判断关系的时候能够跟原生的保持一致，就比如：</p><pre><code>function* f() {}var g = f();console.log(g.__proto__ === f.prototype); // trueconsole.log(g.__proto__.__proto__ === f.__proto__.prototype); // true</code></pre><p>为了简化起见，我们可以把 Gp 先设置为一个空对象，不过正如你在上图中看到的，next()、 throw()、return() 函数都是挂载在 Gp 对象上，实际上，在完整的编译代码中，确实有为 Gp 添加这三个函数的方法：</p><pre><code>// 117 行functiondefineIteratorMethods(prototype) {  [&quot;next&quot;, &quot;throw&quot;, &quot;return&quot;].forEach(function(method) {    prototype[method] = function(arg) {      returnthis._invoke(method, arg);    };  });}// 406 行defineIteratorMethods(Gp);</code></pre><p>为了简单起见，我们将整个 mark 函数简化为：</p><pre><code>runtime.mark = function(genFun) {  var generator = Object.create({    next: function(arg) {      returnthis._invoke(&apos;next&apos;, arg)    }  });  genFun.prototype = generator;  return genFun;};</code></pre><h2 id="wrap-函数"><a href="#wrap-函数" class="headerlink" title="wrap 函数"></a>wrap 函数</h2><p>除了设置关系链之外，mark 函数的返回值 genFun 还作为了 wrap 函数的第二个参数传入：</p><pre><code>functionhelloWorldGenerator() {  return regeneratorRuntime.wrap(    functionhelloWorldGenerator$(_context) {      ...    },    _marked,    this  );}</code></pre><p>我们再看下 wrap 函数：</p><pre><code>functionwrap(innerFn, outerFn, self) {  var generator = Object.create(outerFn.prototype);  var context = new Context([]);  generator._invoke = makeInvokeMethod(innerFn, self, context);  return generator;}</code></pre><p>所以当执行 <code>var hw = helloWorldGenerator();</code> 的时候，其实执行的是 wrap 函数，wrap 函数返回了 generator，generator 是一个对象，原型是 <code>outerFn.prototype</code>, <code>outerFn.prototype</code> 其实就是 <code>genFun.prototype</code>， <code>genFun.prototype</code> 是一个空对象，原型上有 next() 方法。</p><p>所以当你执行 <code>hw.next()</code> 的时候，执行的其实是 hw 原型的原型上的 next 函数，next 函数执行的又是 hw 的 _invoke 函数：</p><pre><code>generator._invoke = makeInvokeMethod(innerFn, self, context);</code></pre><p>innerFn 就是 wrap 包裹的那个函数，其实就是 helloWordGenerato$ 函数，呐，就是这个函数：</p><pre><code>functionhelloWorldGenerator$(_context) {  while (1) {    switch ((_context.prev = _context.next)) {      case0:        _context.next = 2;        return&quot;hello&quot;;      case2:        _context.next = 4;        return&quot;world&quot;;      case4:        return _context.abrupt(&quot;return&quot;, &quot;ending&quot;);      case5:      case&quot;end&quot;:        return _context.stop();    }  }}</code></pre><p>而 context 你可以直接理解为这样一个全局对象：</p><pre><code>var ContinueSentinel = {};var context = {  done: false,  method: &quot;next&quot;,  next: 0,  prev: 0,  abrupt: function(type, arg) {    var record = {};    record.type = type;    record.arg = arg;    returnthis.complete(record);  },  complete: function(record, afterLoc) {    if (record.type === &quot;return&quot;) {      this.rval = this.arg = record.arg;      this.method = &quot;return&quot;;      this.next = &quot;end&quot;;    }    return ContinueSentinel;  },  stop: function() {    this.done = true;    returnthis.rval;  }};</code></pre><p>每次 <code>hw.next</code> 的时候，就会修改 next 和 prev 属性的值，当在 generator 函数中 return 的时候会执行 abrupt，abrupt 中又会执行 complete，执行完 complete，因为 <code>this.next = end</code> 的缘故，再执行就会执行 stop 函数。</p><p>我们来看下 makeInvokeMethod 函数：</p><pre><code>var ContinueSentinel = {};functionmakeInvokeMethod(innerFn, self, context) {  var state = &apos;start&apos;;  returnfunctioninvoke(method, arg) {    if (state === &apos;completed&apos;) {      return { value: undefined, done: true };    }    context.method = method;    context.arg = arg;    while (true) {      state = &apos;executing&apos;;      var record = {        type: &apos;normal&apos;,        arg: innerFn.call(self, context)      };      if (record.type === &quot;normal&quot;) {        state = context.done          ? &apos;completed&apos;          : &apos;yield&apos;;        if (record.arg === ContinueSentinel) {          continue;        }        return {          value: record.arg,          done: context.done        };      }    }  };}</code></pre><p>基本的执行过程就不分析了，我们重点看第三次执行 <code>hw.next()</code> 的时候:</p><p>第三次执行 <code>hw.next()</code> 的时候，其实执行了</p><pre><code>this._invoke(&quot;next&quot;, undefined);</code></pre><p>我们在 invoke 函数中构建了一个 record 对象：</p><pre><code>var record = {  type: &quot;normal&quot;,  arg: innerFn.call(self, context)};</code></pre><p>而在 <code>innerFn.call(self, context)</code> 中，因为 _context.next 为 4 的缘故，其实执行了:</p><pre><code>_context.abrupt(&quot;return&quot;, &apos;ending&apos;);</code></pre><p>而在 abrupt 中，我们又构建了一个 record 对象：</p><pre><code>var record = {};record.type = &apos;return&apos;;record.arg = &apos;ending&apos;;</code></pre><p>然后执行了 <code>this.complete(record)</code>，</p><p>在 complete 中，因为 <code>record.type === &quot;return&quot;</code></p><pre><code>this.rval = &apos;ending&apos;;this.method = &quot;return&quot;;this.next = &quot;end&quot;;</code></pre><p>然后返回了全局对象 ContinueSentinel，其实就是一个全局空对象。</p><p>然后在 invoke 函数中，因为 <code>record.arg === ContinueSentinel</code> 的缘故，没有执行后面的 return 语句，就直接进入下一个循环。</p><p>于是又执行了一遍 <code>innerFn.call(self, context)</code>，此时 <code>_context.next</code> 为 end, 执行了 <code>_context.stop()</code>, 在 stop 函数中：</p><pre><code>this.done = true;returnthis.rval; // this.rval 其实就是 `ending`</code></pre><p>所以最终返回的值为:</p><pre><code>{  value: &apos;ending&apos;,  done: true};</code></pre><p>之后，我们再执行 hw.next() 的时候，因为 state 已经是 ‘completed’ 的缘故，直接就返回 <code>{ value: undefined, done: true}</code></p><h2 id="不完整但可用的源码"><a href="#不完整但可用的源码" class="headerlink" title="不完整但可用的源码"></a>不完整但可用的源码</h2><p>当然这个过程，看文字理解起来可能有些难度，不完整但可用的代码如下，你可以断点调试查看具体的过程：</p><pre><code>(function() {  var ContinueSentinel = {};  var mark = function(genFun) {    var generator = Object.create({      next: function(arg) {        returnthis._invoke(&quot;next&quot;, arg);      }    });    genFun.prototype = generator;    return genFun;  };  functionwrap(innerFn, outerFn, self) {    var generator = Object.create(outerFn.prototype);    var context = {      done: false,      method: &quot;next&quot;,      next: 0,      prev: 0,      abrupt: function(type, arg) {        var record = {};        record.type = type;        record.arg = arg;        returnthis.complete(record);      },      complete: function(record, afterLoc) {        if (record.type === &quot;return&quot;) {          this.rval = this.arg = record.arg;          this.method = &quot;return&quot;;          this.next = &quot;end&quot;;        }        return ContinueSentinel;      },      stop: function() {        this.done = true;        returnthis.rval;      }    };    generator._invoke = makeInvokeMethod(innerFn, context);    return generator;  }  functionmakeInvokeMethod(innerFn, context) {    var state = &quot;start&quot;;    returnfunctioninvoke(method, arg) {      if (state === &quot;completed&quot;) {        return { value: undefined, done: true };      }      context.method = method;      context.arg = arg;      while (true) {        state = &quot;executing&quot;;        var record = {          type: &quot;normal&quot;,          arg: innerFn.call(self, context)        };        if (record.type === &quot;normal&quot;) {          state = context.done ? &quot;completed&quot; : &quot;yield&quot;;          if (record.arg === ContinueSentinel) {            continue;          }          return {            value: record.arg,            done: context.done          };        }      }    };  }  window.regeneratorRuntime = {};  regeneratorRuntime.wrap = wrap;  regeneratorRuntime.mark = mark;})();var _marked = regeneratorRuntime.mark(helloWorldGenerator);functionhelloWorldGenerator() {  return regeneratorRuntime.wrap(    functionhelloWorldGenerator$(_context) {      while (1) {        switch ((_context.prev = _context.next)) {          case0:            _context.next = 2;            return&quot;hello&quot;;          case2:            _context.next = 4;            return&quot;world&quot;;          case4:            return _context.abrupt(&quot;return&quot;, &quot;ending&quot;);          case5:          case&quot;end&quot;:            return _context.stop();        }      }    },    _marked,    this  );}var hw = helloWorldGenerator();console.log(hw.next());console.log(hw.next());console.log(hw.next());console.log(hw.next());</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Generator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简单理解async、await语法实现原理</title>
      <link href="/2018/10/04/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3async%E3%80%81await%E8%AF%AD%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/10/04/%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3async%E3%80%81await%E8%AF%AD%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>现在最新的前端框架生态都开始用上了Generator和yield，<br>有的甚至已经开始使用最新的async、await语法了，<br><strong>这两样都是基于Generator自动执行的原理。</strong></p><h2 id="阮一峰-async-函数的实现原理"><a href="#阮一峰-async-函数的实现原理" class="headerlink" title="阮一峰 async-函数的实现原理"></a>阮一峰 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fasync%23async-%25E5%2587%25BD%25E6%2595%25B0%25E7%259A%2584%25E5%25AE%259E%25E7%258E%25B0%25E5%258E%259F%25E7%2590%2586" target="_blank" rel="noopener">async-函数的实现原理</a></h2><h4 id="async-函数的实现原理，就是将-Generator-函数和自动执行器，包装在一个函数里。"><a href="#async-函数的实现原理，就是将-Generator-函数和自动执行器，包装在一个函数里。" class="headerlink" title="async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。"></a>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function fn(args) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">function fn(args) &#123;</span><br><span class="line">  return spawn(function* () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。</p><p>下面给出spawn函数的实现，基本就是前文自动执行器的翻版。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function spawn(genF) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    const gen = genF();</span><br><span class="line">    function step(nextF) &#123;</span><br><span class="line">      let next;</span><br><span class="line">      try &#123;</span><br><span class="line">        next = nextF();</span><br><span class="line">      &#125; catch(e) &#123;</span><br><span class="line">        return reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      if(next.done) &#123;</span><br><span class="line">        return resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      Promise.resolve(next.value).then(function(v) &#123;</span><br><span class="line">        step(function() &#123; return gen.next(v); &#125;);</span><br><span class="line">      &#125;, function(e) &#123;</span><br><span class="line">        step(function() &#123; return gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(function() &#123; return gen.next(undefined); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function timeout(ms) &#123;</span><br><span class="line">return &#123;</span><br><span class="line">text: &apos;done&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* start() &#123;</span><br><span class="line">const res = yield timeout(1000);</span><br><span class="line">return res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">             </span><br><span class="line"></span><br><span class="line">function fn(args) &#123;</span><br><span class="line">return spawn(start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function spawn(genF) &#123;</span><br><span class="line">return new Promise(function(resolve, reject) &#123;</span><br><span class="line">const gen = genF();</span><br><span class="line">function step(nextF) &#123;</span><br><span class="line">let next;</span><br><span class="line">try &#123;</span><br><span class="line">next = nextF();</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">return reject(e);</span><br><span class="line">&#125;</span><br><span class="line">if(next.done) &#123;</span><br><span class="line">return resolve(next.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Promise.resolve(next.value).then(function(v) &#123;</span><br><span class="line">step(function() &#123;</span><br><span class="line">return gen.next(v);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, function(e) &#123;</span><br><span class="line">step(function() &#123;</span><br><span class="line">return gen.throw(e);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">step(function() &#123;</span><br><span class="line">return gen.next();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> fn().then((data)=&gt;&#123;</span><br><span class="line">console.log(data)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="看下babel转换后的"><a href="#看下babel转换后的" class="headerlink" title="看下babel转换后的"></a>看下babel转换后的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function fns(args) &#123;</span><br><span class="line">const res = await fetch(&apos;google.com&apos;);</span><br><span class="line">return res.text();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">    </span><br><span class="line">var fns = function() &#123;</span><br><span class="line">var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee(args) &#123;</span><br><span class="line">var res;</span><br><span class="line">return regeneratorRuntime.wrap(function _callee$(_context) &#123;</span><br><span class="line">while(1) &#123;</span><br><span class="line">switch(_context.prev = _context.next) &#123;</span><br><span class="line">case 0:</span><br><span class="line">_context.next = 2;</span><br><span class="line">return fetch(&apos;google.com&apos;);</span><br><span class="line">    </span><br><span class="line">case 2:</span><br><span class="line">res = _context.sent;</span><br><span class="line">return _context.abrupt(&apos;return&apos;, res.text());</span><br><span class="line">    </span><br><span class="line">case 4:</span><br><span class="line">case&apos;end&apos;:</span><br><span class="line">return _context.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, _callee, this);</span><br><span class="line">&#125;));</span><br><span class="line">    </span><br><span class="line">returnfunction fns(_x) &#123;</span><br><span class="line">return _ref.apply(this, arguments);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;();</span><br><span class="line">    </span><br><span class="line">function _asyncToGenerator(fn) &#123;  //Generator函数自动执行</span><br><span class="line">returnfunction() &#123;</span><br><span class="line">var gen = fn.apply(this, arguments);</span><br><span class="line">return new Promise(function(resolve, reject) &#123;</span><br><span class="line">function step(key, arg) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var info = gen[key](arg);</span><br><span class="line">var value = info.value;</span><br><span class="line">&#125; catch(error) &#123;</span><br><span class="line">reject(error);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if(info.done) &#123;</span><br><span class="line">resolve(value);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return Promise.resolve(value).then(function(value) &#123;</span><br><span class="line">step(&quot;next&quot;, value);</span><br><span class="line">&#125;, function(err) &#123;</span><br><span class="line">step(&quot;throw&quot;, err);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return step(&quot;next&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一、thunk函数<br>thunk函数指的是能将执行结果传入回调函数，并将该回调函数返回的函数。<br>是不是有点抽象，举个例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var readFile = function (fileName) &#123;</span><br><span class="line">    returnfunction (callback) &#123;</span><br><span class="line">        return fs.readFile(fileName, callback)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们来看下thunk函数怎样执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readFile(&apos;./package.json&apos;)((err, str) =&gt; &#123;</span><br><span class="line">    console.log(str.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>问: thunk的执行比普通函数要麻烦不少，那么它有什么优势呢？</p><h3 id="thunk函数的优势在于它能将异步操作返回结果的获取权交给thunk函数的返回值，"><a href="#thunk函数的优势在于它能将异步操作返回结果的获取权交给thunk函数的返回值，" class="headerlink" title="thunk函数的优势在于它能将异步操作返回结果的获取权交给thunk函数的返回值，"></a>thunk函数的优势在于它能将异步操作返回结果的获取权交给thunk函数的返回值，</h3><p>而不是将异步操作结果传入thunk函数本身的作用域内，这点很重要，<br>因为它能结合Generator语法让Generator函数自动执行</p><p>二、Generator<br>es6的Generator函数，具体语法这里就不介绍了，</p><p>我们来编写一个基于thunk函数的Generator：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let gen = function* () &#123;</span><br><span class="line">    let r1 = yield readFile(&apos;./package.json&apos;)</span><br><span class="line">    console.log(r1.toString())</span><br><span class="line">    let r2 = yield readFile(&apos;./index.js&apos;)</span><br><span class="line">    console.log(r2.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们来手动执行一下这个Generator:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let g = gen()</span><br><span class="line">let r1 = g.next()</span><br><span class="line">r1.value(function (err, data) &#123;</span><br><span class="line">    if (err) &#123;</span><br><span class="line">        throw err</span><br><span class="line">    &#125;</span><br><span class="line">    let r2 = g.next(data)</span><br><span class="line">    r2.value(function (err, data) &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            throw err</span><br><span class="line">        &#125;</span><br><span class="line">        g.next(data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>可以注意到，在我们手动执行基于thunk函数的Generator时，<br>有很多代码是可以复用的，<br>没错，所谓的Generator自动执行就是把这些可复用的部分封装成函数，<br>然后让它们递归执行，直到执行完所有的yield。</p><p>三、Generator自动执行器<br>下面就是Generator自动执行的核心代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function run(fn) &#123;</span><br><span class="line">    let gen = fn()</span><br><span class="line">    function next(err, data) &#123;</span><br><span class="line">        let result = gen.next(data)</span><br><span class="line">        if (result.done) &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        result.value(next)</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到无非就是把可复用的部分封装成next函数，然后让其<strong>递归</strong>执行，<br>直到执行完所有的yield</p><p>其调用代码为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run(gen)</span><br></pre></td></tr></table></figure></p><p>这样就将原本繁杂的异步操作封装的十分简单了</p><p>基于Promise的Generator的自动执行<br>上面的例子是基于thunk函数的，而即将出现的es7的async、await语法是基于Promise的</p><p>这里再上一个基于Promise的Generator的自动执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//包装返回Promise对象的函数</span><br><span class="line">functionreadFile(fileName) &#123;</span><br><span class="line">    return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">        fs.readFile(fileName, (error, data) =&gt; &#123;</span><br><span class="line">            if (error) &#123;</span><br><span class="line">                reject(error)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 编写Generator</span><br><span class="line">let gen = function* () &#123;</span><br><span class="line">    let r1 = yield readFile(&apos;./package.json&apos;)</span><br><span class="line">    console.log(r1.toString())</span><br><span class="line">    let r2 = yield readFile(&apos;./index.js&apos;)</span><br><span class="line">    console.log(r2.toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编写Generator执行器</span><br><span class="line">function run(gen) &#123;</span><br><span class="line">    let g = gen()</span><br><span class="line">    function next(data) &#123;</span><br><span class="line">        let result = g.next(data)</span><br><span class="line">        if (result.done) &#123;</span><br><span class="line">            return result.value</span><br><span class="line">        &#125;</span><br><span class="line">        result.value.then((data) =&gt; next(data))</span><br><span class="line">    &#125;</span><br><span class="line">    next()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//用Generator执行器自动执行</span><br><span class="line">run(gen)</span><br></pre></td></tr></table></figure></p><p>这个和基于thunk函数的大同小异，只是把函数返回值的获取权以Promise的方式交出</p><h4 id="参考-简单理解Generator自执行及async、await语法原理"><a href="#参考-简单理解Generator自执行及async、await语法原理" class="headerlink" title="参考 简单理解Generator自执行及async、await语法原理"></a>参考 <a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000008254704" target="_blank" rel="noopener">简单理解Generator自执行及async、await语法原理</a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> async </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6之 Generator 的惰性执行</title>
      <link href="/2018/10/04/ES6%E4%B9%8B-Generator-%E7%9A%84%E6%83%B0%E6%80%A7%E6%89%A7%E8%A1%8C/"/>
      <url>/2018/10/04/ES6%E4%B9%8B-Generator-%E7%9A%84%E6%83%B0%E6%80%A7%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="单个异步任务"><a href="#单个异步任务" class="headerlink" title="单个异步任务"></a>单个异步任务</h2><pre><code>var fetch = require(&apos;node-fetch&apos;);function* gen(){    var url = &apos;https://api.github.com/users/github&apos;;    var result = yield fetch(url);    console.log(result.bio);}</code></pre><p>为了获得最终的执行结果，你需要这样做：</p><pre><code>var g = gen();var result = g.next();result.value.then(function(data){    return data.json();}).then(function(data){    g.next(data);});</code></pre><p>首先执行 Generator 函数，获取遍历器对象。</p><p>然后使用 next 方法，执行异步任务的第一阶段，即 fetch(url)。</p><p>注意，由于 fetch(url) 会返回一个 Promise 对象，所以 result 的值为：</p><pre><code>{ value: Promise { &lt;pending&gt; }, done: false }</code></pre><p>最后我们为这个 Promise 对象添加一个 then 方法，先将其返回的数据格式化(<code>data.json()</code>)，再调用 g.next，将获得的数据传进去，由此可以执行异步任务的第二阶段，代码执行完毕。</p><h2 id="多个异步任务"><a href="#多个异步任务" class="headerlink" title="多个异步任务"></a>多个异步任务</h2><p>上节我们只调用了一个接口，那如果我们调用了多个接口，使用了多个 yield，我们岂不是要在 then 函数中不断的嵌套下去……</p><p>所以我们来看看执行多个异步任务的情况：</p><pre><code>var fetch = require(&apos;node-fetch&apos;);function* gen() {    var r1 = yield fetch(&apos;https://api.github.com/users/github&apos;);    var r2 = yield fetch(&apos;https://api.github.com/users/github/followers&apos;);    var r3 = yield fetch(&apos;https://api.github.com/users/github/repos&apos;);    console.log([r1.bio, r2[0].login, r3[0].full_name].join(&apos;\n&apos;));}</code></pre><p>为了获得最终的执行结果，你可能要写成：</p><pre><code>var g = gen();var result1 = g.next();result1.value.then(function(data){    return data.json();}).then(function(data){    return g.next(data).value;}).then(function(data){    return data.json();}).then(function(data){    return g.next(data).value}).then(function(data){    return data.json();}).then(function(data){    g.next(data)});</code></pre><p>但我知道你肯定不想写成这样……</p><p>其实，利用递归，我们可以这样写：</p><pre><code>functionrun(gen) {    var g = gen();    function next(data) {        var result = g.next(data);        if (result.done) return;        result.value.then(function(data) {            return data.json();        }).then(function(data) {            next(data);        });    }    next();}run(gen);</code></pre><p>其中的关键就是 yield 的时候返回一个 Promise 对象，给这个 Promise 对象添加 then 方法，当异步操作成功时执行 then 中的 onFullfilled 函数，onFullfilled 函数中又去执行 g.next，从而让 Generator 继续执行，然后再返回一个 Promise，再在成功时执行 g.next，然后再返回……</p><h2 id="启动器函数"><a href="#启动器函数" class="headerlink" title="启动器函数"></a>启动器函数</h2><p>在 run 这个启动器函数中，我们在 then 函数中将数据格式化 <code>data.json()</code>，但在更广泛的情况下，比如 yield 直接跟一个 Promise，而非一个 fetch 函数返回的 Promise，因为没有 json 方法，代码就会报错。所以为了更具备通用性，连同这个例子和启动器，我们修改为：</p><pre><code>var fetch = require(&apos;node-fetch&apos;);function* gen() {    var r1 = yield fetch(&apos;https://api.github.com/users/github&apos;);    var json1 = yield r1.json();    var r2 = yield fetch(&apos;https://api.github.com/users/github/followers&apos;);    var json2 = yield r2.json();    var r3 = yield fetch(&apos;https://api.github.com/users/github/repos&apos;);    var json3 = yield r3.json();    console.log([json1.bio, json2[0].login, json3[0].full_name].join(&apos;\n&apos;));}function run(gen) {    var g = gen();    functionnext(data) {        var result = g.next(data);        if (result.done) return;        result.value.then(function(data) {            next(data);        });    }    next();}run(gen);</code></pre><p>只要 yield 后跟着一个 Promise 对象，我们就可以利用这个 run 函数将 Generator 函数自动执行。</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>yield 后一定要跟着一个 Promise 对象才能保证 Generator 的自动执行吗？如果只是一个回调函数呢？我们来看个例子：</p><p>首先我们来模拟一个普通的异步请求：</p><pre><code>function fetchData(url, cb) {    setTimeout(function(){        cb({status: 200, data: url})    }, 1000)}</code></pre><p>我们将这种函数改造成：</p><pre><code>function fetchData(url) {    returnfunction(cb){        setTimeout(function(){            cb({status: 200, data: url})        }, 1000)    }}</code></pre><p>对于这样的 Generator 函数：</p><pre><code>function* gen() {    var r1 = yield fetchData(&apos;https://api.github.com/users/github&apos;);    var r2 = yield fetchData(&apos;https://api.github.com/users/github/followers&apos;);    console.log([r1.data, r2.data].join(&apos;\n&apos;));}</code></pre><p>如果要获得最终的结果：</p><pre><code>var g = gen();var r1 = g.next();r1.value(function(data) {    var r2 = g.next(data);    r2.value(function(data) {        g.next(data);    });});</code></pre><p>如果写成这样的话，我们会面临跟第一节同样的问题，那就是当使用多个 yield 时，代码会循环嵌套起来……</p><p>同样利用递归，所以我们可以将其改造为：</p><pre><code>functionrun(gen) {    var g = gen();    functionnext(data) {        var result = g.next(data);        if (result.done) return;        result.value(next);    }    next();}run(gen);</code></pre><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>由此可以看到 Generator 函数的自动执行需要一种机制，即当异步操作有了结果，能够自动交回执行权。</p><p>而两种方法可以做到这一点。</p><p>（1）回调函数。将异步操作进行包装，暴露出回调函数，在回调函数里面交回执行权。</p><p>（2）Promise 对象。将异步操作包装成 Promise 对象，用 then 方法交回执行权。</p><p>在两种方法中，我们各写了一个 run 启动器函数，那我们能不能将这两种方式结合在一些，写一个通用的 run 函数呢？我们尝试一下：</p><pre><code>// 第一版functionrun(gen) {    var gen = gen();    functionnext(data) {        var result = gen.next(data);        if (result.done) return;        if (isPromise(result.value)) {            result.value.then(function(data) {                next(data);            });        } else {            result.value(next)        }    }    next()}functionisPromise(obj) {    return&apos;function&apos; == typeof obj.then;}module.exports = run;</code></pre><p>其实实现的很简单，判断 result.value 是否是 Promise，是就添加 then 函数，不是就直接执行。</p><h2 id="return-Promise"><a href="#return-Promise" class="headerlink" title="return Promise"></a>return Promise</h2><p>我们已经写了一个不错的启动器函数，支持 yield 后跟回调函数或者 Promise 对象。</p><p>现在有一个问题需要思考，就是我们如何获得 Generator 函数的返回值呢？又如果 Generator 函数中出现了错误，就比如 fetch 了一个不存在的接口，这个错误该如何捕获呢？</p><p>这很容易让人想到 Promise，如果这个启动器函数返回一个 Promise，我们就可以给这个 Promise 对象添加 then 函数，当所有的异步操作执行成功后，我们执行 onFullfilled 函数，如果有任何失败，就执行 onRejected 函数。</p><p>我们写一版：</p><pre><code>// 第二版functionrun(gen) {    var gen = gen();    returnnewPromise(function(resolve, reject) {        functionnext(data) {            try {                var result = gen.next(data);            } catch (e) {                return reject(e);            }            if (result.done) {                return resolve(result.value)            };            var value = toPromise(result.value);            value.then(function(data) {                next(data);            }, function(e) {                reject(e)            });        }        next()    })}functionisPromise(obj) {    return&apos;function&apos; == typeof obj.then;}functiontoPromise(obj) {    if (isPromise(obj)) return obj;    if (&apos;function&apos; == typeof obj) return thunkToPromise(obj);    return obj;}functionthunkToPromise(fn) {    returnnewPromise(function(resolve, reject) {        fn(function(err, res) {            if (err) return reject(err);            resolve(res);        });    });}module.exports = run;</code></pre><p>与第一版有很大的不同：</p><p>首先，我们返回了一个 Promise，当 <code>result.done</code> 为 true 的时候，我们将该值 <code>resolve(result.value)</code>，如果执行的过程中出现错误，被 catch 住，我们会将原因 <code>reject(e)</code>。</p><p>其次，我们会使用 <code>thunkToPromise</code> 将回调函数包装成一个 Promise，然后统一的添加 then 函数。在这里值得注意的是，在 <code>thunkToPromise</code> 函数中，我们遵循了 error first 的原则，这意味着当我们处理回调函数的情况时：</p><pre><code>// 模拟数据请求functionfetchData(url) {    returnfunction(cb) {        setTimeout(function() {            cb(null, { status: 200, data: url })        }, 1000)    }}</code></pre><p>在成功时，第一个参数应该返回 null，表示没有错误原因。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>我们在第二版的基础上将代码写的更加简洁优雅一点，最终的代码如下：</p><pre><code>// 第三版functionrun(gen) {    returnnewPromise(function(resolve, reject) {        if (typeof gen == &apos;function&apos;) gen = gen();        // 如果 gen 不是一个迭代器if (!gen || typeof gen.next !== &apos;function&apos;) return resolve(gen)        onFulfilled();        functiononFulfilled(res) {            var ret;            try {                ret = gen.next(res);            } catch (e) {                return reject(e);            }            next(ret);        }        functiononRejected(err) {            var ret;            try {                ret = gen.throw(err);            } catch (e) {                return reject(e);            }            next(ret);        }        functionnext(ret) {            if (ret.done) return resolve(ret.value);            var value = toPromise(ret.value);            if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected);            return onRejected(newTypeError(&apos;You may only yield a function, promise &apos; +                &apos;but the following object was passed: &quot;&apos; + String(ret.value) + &apos;&quot;&apos;));        }    })}functionisPromise(obj) {    return&apos;function&apos; == typeof obj.then;}functiontoPromise(obj) {    if (isPromise(obj)) return obj;    if (&apos;function&apos; == typeof obj) return thunkToPromise(obj);    return obj;}functionthunkToPromise(fn) {    returnnewPromise(function(resolve, reject) {        fn(function(err, res) {            if (err) return reject(err);            resolve(res);        });    });}module.exports = run;</code></pre><h2 id="co"><a href="#co" class="headerlink" title="co"></a>co</h2><p>如果我们再将这个启动器函数写的完善一些，我们就相当于写了一个 co，实际上，上面的代码确实是来自于 co……</p><p>而 co 是什么？ co 是大神 TJ Holowaychuk 于 2013 年 6 月发布的一个小模块，用于 Generator 函数的自动执行。</p><p>如果直接使用 co 模块，这两种不同的例子可以简写为：</p><pre><code>// yield 后是一个 Promisevar fetch = require(&apos;node-fetch&apos;);var co = require(&apos;co&apos;);function* gen() {    var r1 = yield fetch(&apos;https://api.github.com/users/github&apos;);    var json1 = yield r1.json();    var r2 = yield fetch(&apos;https://api.github.com/users/github/followers&apos;);    var json2 = yield r2.json();    var r3 = yield fetch(&apos;https://api.github.com/users/github/repos&apos;);    var json3 = yield r3.json();    console.log([json1.bio, json2[0].login, json3[0].full_name].join(&apos;\n&apos;));}co(gen);// yield 后是一个回调函数var co = require(&apos;co&apos;);functionfetchData(url) {    returnfunction(cb) {        setTimeout(function() {            cb(null, { status: 200, data: url })        }, 1000)    }}function* gen() {    var r1 = yield fetchData(&apos;https://api.github.com/users/github&apos;);    var r2 = yield fetchData(&apos;https://api.github.com/users/github/followers&apos;);    console.log([r1.data, r2.data].join(&apos;\n&apos;));}co(gen);</code></pre><p>是不是特别的好用？</p><h2 id="ES6-系列"><a href="#ES6-系列" class="headerlink" title="ES6 系列"></a>ES6 系列</h2><p>ES6 系列预计写二十篇左右，旨在加深 ES6 部分知识点的理解，重点讲解块级作用域、标签模板、箭头函数、Symbol、Set、Map 以及 Promise 的模拟实现、模块加载方案、异步处理等内容。</p><p>如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。</p>]]></content>
      
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> Generator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue权限控制addRoutes</title>
      <link href="/2018/10/03/Vue%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6addRoutes/"/>
      <url>/2018/10/03/Vue%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6addRoutes/</url>
      
        <content type="html"><![CDATA[<h3 id="说到Vue权限控制，你可能会第一个想到"><a href="#说到Vue权限控制，你可能会第一个想到" class="headerlink" title="说到Vue权限控制，你可能会第一个想到"></a>说到Vue权限控制，你可能会第一个想到</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by superman on 17/2/16.</span><br><span class="line"> * http配置</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import store from &apos;./store/store&apos;</span><br><span class="line">import * as types from &apos;./store/types&apos;</span><br><span class="line">import router from &apos;./router&apos;</span><br><span class="line"></span><br><span class="line">// axios 配置</span><br><span class="line">axios.defaults.timeout = 5000;</span><br><span class="line">axios.defaults.baseURL = &apos;https://api.github.com&apos;;</span><br><span class="line"></span><br><span class="line">// http request 拦截器</span><br><span class="line">axios.interceptors.request.use(</span><br><span class="line">    config =&gt; &#123;</span><br><span class="line">        if (store.state.token) &#123;</span><br><span class="line">            config.headers.Authorization = `token $&#123;store.state.token&#125;`;</span><br><span class="line">        &#125;</span><br><span class="line">        return config;</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">        return Promise.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">// http response 拦截器</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">    response =&gt; &#123;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;,</span><br><span class="line">    error =&gt; &#123;</span><br><span class="line">        if (error.response) &#123;</span><br><span class="line">            switch (error.response.status) &#123;</span><br><span class="line">                case 401:</span><br><span class="line">                    // 401 清除token信息并跳转到登录页面</span><br><span class="line">                    store.commit(types.LOGOUT);</span><br><span class="line">                    router.replace(&#123;</span><br><span class="line">                        path: &apos;login&apos;,</span><br><span class="line">                        query: &#123;redirect: router.currentRoute.fullPath&#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // console.log(JSON.stringify(error));//console : Error: Request failed with status code 402</span><br><span class="line">        return Promise.reject(error.response.data)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">export default axios;</span><br></pre></td></tr></table></figure><h3 id="VueRouter"><a href="#VueRouter" class="headerlink" title="VueRouter"></a>VueRouter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    if (to.path == &apos;/login&apos;) &#123;</span><br><span class="line">         //清除token</span><br><span class="line">         ...</span><br><span class="line">    &#125;</span><br><span class="line">    let token = get(&apos;token&apos;);   //获取token</span><br><span class="line">    if (!token &amp;&amp; to.path != &apos;/login&apos;) &#123;</span><br><span class="line">        next(&#123; path: &apos;/login&apos; &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="但上面的只能对登录拦截-跳转拦截，不能控制user权限，最好的方式是动态注入路由addRoutes"><a href="#但上面的只能对登录拦截-跳转拦截，不能控制user权限，最好的方式是动态注入路由addRoutes" class="headerlink" title="但上面的只能对登录拦截,跳转拦截，不能控制user权限，最好的方式是动态注入路由addRoutes"></a>但上面的只能对登录拦截,跳转拦截，不能控制user权限，最好的方式是动态注入路由<strong><font color="#dd0000">addRoutes</font></strong></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import router from &apos;./router&apos;</span><br><span class="line">router.addRoutes(routes)</span><br><span class="line">或者</span><br><span class="line">this.$router.addRoutes(routers)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模拟实现call和apply</title>
      <link href="/2018/10/01/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E5%92%8Capply/"/>
      <url>/2018/10/01/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E5%92%8Capply/</url>
      
        <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>JS 函数 call 和 apply 用来手动改变 this 的指向，call 和 apply  唯一的区别就在于函数参数的传递方式不同，call 是以逗号的形式，apply 是以数组的形式：</p><pre><code>let person1 = {    name: &quot;person1&quot;,    say: function(age, sex) {        console.log(this.name + &apos; age: &apos; + age + &apos; sex: &apos; + sex);    }}let person2 = {    name: &quot;person&quot;}person1.say.call(person2, 20, &quot;男&quot;);person1.say.apply(person2, [20, &quot;男&quot;]);</code></pre><p>本文就尝试用其他方式来模拟实现 call 和 apply。</p><p>首先观察 call 和 apply 有什么特点？</p><ol><li>被函数调用（函数也是对象），相当于 call 和 apply 是函数的属性</li><li>如果没有传入需要 this 指向对象，那么 this 指向全局对象</li><li>函数执行了</li><li>最后都改变了 this 的指向</li></ol><h4 id="一、初步实现"><a href="#一、初步实现" class="headerlink" title="一、初步实现"></a>一、初步实现</h4><p>基于 call 函数是调用函数的属性的特点，call 的 this 指向调用函数，我们可以尝试把调用函数的作为传入的新对象的一个属性，执行后，再删除这个属性就好了。</p><pre><code>Function.prototype.newCall = function (context) {    context.fn = this;  // this 指的是 say 函数    context.fn();    delete context.fn;}var person = {    name: &quot;jayChou&quot;};var say = function() {    console.log(this.name);}say.newCall(person);  // jayChou</code></pre><p>是不是就初步模拟实现了 call 函数呢，由于 call 还涉及到传参的问题，所以我们进入到下一环节。</p><h4 id="二、eval-方式"><a href="#二、eval-方式" class="headerlink" title="二、eval 方式"></a>二、eval 方式</h4><p>在给对象临时一个函数，并执行时，传入的参数是除了 context 其余的参数。那么我们可以截取 arguments 参数数组的第一个后，将剩余的参数传入临时数组。</p><p>在前面我有讲过函数 arguments 类数组对象的特点，arguments 是不支持数组的大多数方法, 但是支持for 循环来遍历数组。</p><pre><code>Function.prototype.newCall = function (context) {    context.fn = this;    let args = [];    for(let i=1; i&lt; arguments.length; i++) {        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);    }    // args =&gt; [arguments[1], arguments[2], arguments[3], ...]    context.fn(args.join(&apos;,&apos;));  // ？？？delete context.fn;}var person = {    name: &quot;jayChou&quot;};var say = function(age, sex) {    console.log(`name: ${this.name},age: ${age}, sex: ${sex}`);}say.newCall(person);</code></pre><p>上面传递参数的方式最后肯定是失败的，我们可以尝试 eval 的方式，将参数添加子函数的作用域中。</p><blockquote><p>eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码</p></blockquote><pre><code>Function.prototype.newCall = function (context) {    context.fn = this;    let args = [];    for(var i=1; i&lt; arguments.length; i++) {        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);    }    // args =&gt; [arguments[1], arguments[2], arguments[3], ...]eval(&apos;context.fn(&apos; + args + &apos;)&apos;);    delete context.fn;}var person = {    name: &quot;jayChou&quot;};functionsay(age, sex) {    console.log(`name: ${this.name},age: ${age}, sex: ${sex}`);}say.newCall(person, 18, &apos;男&apos;);  // name: jayChou,age: 18, sex: 男</code></pre><p>成功啦！</p><p>实现了函数参数的传递，那么函数返回值怎么处理呢。而且，如果传入的对象是 null，又该如何处理？所以还需要再做一些工作：</p><pre><code>Function.prototype.newCall = function (context) {    if (typeof context === &apos;object&apos;) {        context = context || window    } else {        context = Object.create(null);    }    context.fn = this;    let args = [];    for(var i=1; i&lt; arguments.length; i++) {        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);    }    // args =&gt; [arguments[1], arguments[2], arguments[3], ...]var result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;);  // 处理返回值delete context.fn;    return result;  // 返回返回值}var person = {    name: &quot;jayChou&quot;};functionsay(age, sex) {    console.log(`name: ${this.name},age: ${age}, sex: ${sex}`);    return age + sex;}var check = say.newCall(person, 18, &apos;男&apos;);console.log(check); // 18男</code></pre><p>判断传入对象的类型，如果为 null 就指向 window 对象。利用 eval 来执行字符串代码，并返回字符串代码执行的结果，就完成了模拟 call。<br>大功告成！</p><h4 id="三、ES-6-实现"><a href="#三、ES-6-实现" class="headerlink" title="三、ES 6 实现"></a>三、ES 6 实现</h4><p>前面我们用的 eval 方式可以用 ES6 的解决还存在的一些问题，有没有注意到，这段代码是有问题的。</p><pre><code>context.fn = this;</code></pre><p>假如对象在被 call 调用前，已经有 fn 属性怎么办？</p><p>ES6 中提供了一种新的基本数据类型，Symbol，表示独一无二的值，另外，Symbol 作为属性的时候，不能使用点运算符。所以再加上 ES 的 rest 剩余参数替代 arguments 遍历的工作就有：</p><pre><code>Function.prototype.newCall = function (context,...params) {    if (typeof context === &apos;object&apos;) {        context = context || window    } else {        context = Object.create(null);    }    let fn = Symbol();    context[fn] = thisvar result = context[fn](...params);    delete context.fn;    return result;}var person = {    name: &quot;jayChou&quot;};functionsay(age, sex) {    console.log(`name: ${this.name},age: ${age}, sex: ${sex}`);    return age + sex;}var check = say.newCall(person, 18, &apos;男&apos;);console.log(check); // 18男</code></pre><h4 id="四、apply"><a href="#四、apply" class="headerlink" title="四、apply"></a>四、apply</h4><p>apply 和 call 的实现原理，基本类似，区别在于 apply 的参数是以数组的形式传入。</p><pre><code>Function.prototype.newApply = function (context, arr) {    if (typeof context === &apos;object&apos;) {        context = context || window    } else {        context = Object.create(null);    }    context.fn = this;    var result;    if (!arr) {  // 判断函数参数是否为空        result = context.fn();    }    else {        var args = [];        for (var i = 0; i &lt; arr.length; i++) {            args.push(&apos;arr[&apos; + i + &apos;]&apos;);        }        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;);    }    delete context.fn;    return result;}</code></pre><p><strong>es6 实现</strong></p><pre><code>Function.prototype.newApply = function(context, parameter) {  if (typeof context === &apos;object&apos;) {    context = context || window  } else {    context = Object.create(null)  }  let fn = Symbol()  context[fn] = this;  var result = context[fn](...parameter);  delete context[fn];  return result;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Koa2 compose-串联中间件实现(洋葱模型)</title>
      <link href="/2018/09/30/compose-%E4%B8%B2%E8%81%94%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/09/30/compose-%E4%B8%B2%E8%81%94%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E7%8E%B0-%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="koa2-一网打尽（基本使用，洋葱圈，中间件机制和模拟，源码分析，核心点，生态）"><a href="#koa2-一网打尽（基本使用，洋葱圈，中间件机制和模拟，源码分析，核心点，生态）" class="headerlink" title="koa2 一网打尽（基本使用，洋葱圈，中间件机制和模拟，源码分析，核心点，生态）"></a><a href="https://github.com/HCThink/h-blog/blob/master/source/koa2/readme.md" target="_blank" rel="noopener">koa2 一网打尽（基本使用，洋葱圈，中间件机制和模拟，源码分析，核心点，生态）</a></h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Koa</code> 是当下主流 NodeJS 框架，以轻量见长，而它中间件机制与相对传统的 <code>Express</code> 支持了异步，所以编码时经常使用 <code>async/await</code>，提高了可读性，使代码变得更优雅，上一篇文章 <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.pandashen.com%2F2018%2F09%2F02%2F20180902141819%2F" target="_blank" rel="noopener">NodeJS 进阶 —— Koa 源码分析</a>，也对 “洋葱模型” 和实现它的 <code>compose</code> 进行分析，由于个人觉得 <code>compose</code> 的编程思想比较重要，应用广泛，所以本篇借着 “洋葱模型” 的话题，打算用四种方式来实现 <code>compose</code>。</p><h2 id="洋葱模型案例"><a href="#洋葱模型案例" class="headerlink" title="洋葱模型案例"></a>洋葱模型案例</h2><p>如果你已经使用 <code>Koa</code> 对 “洋葱模型” 这个词一定不陌生，它就是 <code>Koa</code> 中间件的一种串行机制，并且是支持异步的，下面是一个表达 “洋葱模型” 的经典案例。</p><pre><code>const Koa = require(&quot;koa&quot;);const app = new Koa();app.use(asycn (ctx, next) =&gt; {    console.log(1);    await next();    console.log(2);});app.use(asycn (ctx, next) =&gt; {    console.log(3);    await next();    console.log(4);});app.use(asycn (ctx, next) =&gt; {    console.log(5);    await next();    console.log(6);});app.listen(3000);// 1// 3// 5// 6// 4// 2</code></pre><p>上面的写法我们按照官方推荐，使用了 <code>async/await</code>，但如果是同步代码不使用也没有关系，这里简单的分析一下执行机制，第一个中间件函数中如果执行了 <code>next</code>，则下一个中间件会被执行，依次类推，就有了我们上面的结果，而在 <code>Koa</code> 源码中，这一功能是靠一个 <code>compose</code> 方法实现的，我们本文四种实现 <code>compose</code> 的方式中实现同步和异步，并附带对应的案例来验证。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在真正创建 <code>compose</code> 方法之前应该先做些准备工作，比如创建一个 <code>app</code> 对象来顶替 <code>Koa</code> 创建出的实例对象，并添加 <code>use</code> 方法和管理中间件的数组 <code>middlewares</code>。</p><p>文件：app.js</p><pre><code>// 模拟 Koa 创建的实例const app = {    middlewares: []};// 创建 use 方法app.use = function(fn) {    app.middlewares.push(fn);};// app.compose.....module.exports = app;</code></pre><p>上面的模块中导出了 <code>app</code> 对象，并创建了存储中间件函数的 <code>middlewares</code> 和添加中间件的 <code>use</code> 方法，因为无论用哪种方式实现 <code>compose</code> 这些都是需要的，只是 <code>compose</code> 逻辑的不同，所以后面的代码块中会只写 <code>compose</code> 方法。</p><h2 id="Koa-中-compose-的实现方式"><a href="#Koa-中-compose-的实现方式" class="headerlink" title="Koa 中 compose 的实现方式"></a>Koa 中 compose 的实现方式</h2><p>首先介绍的是 <code>Koa</code> 源码中的实现方式，在 <code>Koa</code> 源码中其实是通过 <code>koa-compose</code> 中间件来实现的，我们在这里将这个模块的核心逻辑抽取出来，用我们自己的方式实现，由于重点在于分析 <code>compose</code> 的原理，所以 <code>ctx</code> 参数就被去掉了，因为我们不会使用它，重点是 <code>next</code> 参数。</p><h3 id="1、同步的实现"><a href="#1、同步的实现" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p><pre><code>app.compose = function() {    // 递归函数    function dispatch(index) {        // 如果所有中间件都执行完跳出        if (index === app.middlewares.length) return;        // 取出第 index 个中间件并执行        const route = app.middlewares[index];        return route(() =&gt; dispatch(index + 1));    }    // 取出第一个中间件函数执行    dispatch(0);};</code></pre><p>上面是同步的实现，通过递归函数 <code>dispatch</code> 的执行取出了数组中的第一个中间件函数并执行，在执行时传入了一个函数，并递归执行了 <code>dispatch</code>，传入的参数 <code>+1</code>，这样就执行了下一个中间件函数，依次类推，直到所有中间件都执行完毕，不满足中间件执行条件时，会跳出，这样就按照上面案例中 <code>1 3 5 6 4 2</code> 的情况执行，测试例子如下（同步上、异步下）。</p><p>文件：sync-test.js</p><pre><code>const app = require(&quot;./app&quot;);app.use(next =&gt; {    console.log(1);    next();    console.log(2);});app.use(next =&gt; {    console.log(3);    next();    console.log(4);});app.use(next =&gt; {    console.log(5);    next();    console.log(6);});app.compose();// 1// 3// 5// 6// 4// 2</code></pre><p>文件：async-test.js</p><pre><code>const app = require(&quot;./app&quot;);// 异步函数functionfn() {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            resolve();            console.log(&quot;hello&quot;);        }, 3000);    });}app.use(async next =&gt; {    console.log(1);    await next();    console.log(2);});app.use(async next =&gt; {    console.log(3);    await fn(); // 调用异步函数    await next();    console.log(4);});app.use(async next =&gt; {    console.log(5);    await next();    console.log(6);});app.compose();</code></pre><p>我们发现如果案例中按照 <code>Koa</code> 的推荐写法，即使用 <code>async</code> 函数，都会通过，但是在给 <code>use</code> 传参时可能会传入普通函数或 <code>async</code> 函数，我们要将所有中间件的返回值都包装成 Promise 来兼容两种情况，其实在 <code>Koa</code> 中 <code>compose</code> 最后返回的也是 Promise，是为了后续的逻辑的编写，但是现在并不支持，下面来解决这两个问题。</p><p>注意：后面 <code>compose</code> 的其他实现方式中，都是使用 <code>sync-test.js</code> 和 <code>async-test.js</code> 验证，所以后面就不再重复了。</p><h3 id="2、升级为支持异步"><a href="#2、升级为支持异步" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>文件：app.js</p><pre><code>app.compose = function() {    // 递归函数    function dispatch(index) {        // 如果所有中间件都执行完跳出，并返回一个 Promise        if (index === app.middlewares.length) return Promise.resolve();        // 取出第 index 个中间件并执行        const route = app.middlewares[index];        // 执行后返回成功态的 Promise        return Promise.resolve(route(() =&gt; dispatch(index + 1)));    }    // 取出第一个中间件函数执行    dispatch(0);};</code></pre><p>我们知道 <code>async</code> 函数中 <code>await</code> 后面执行的异步代码要实现等待，带异步执行后继续向下执行，需要等待 Promise，所以我们将每一个中间件函数在调用时最后都返回了一个成功态的 Promise，使用 <code>async-test.js</code>进行测试，发现结果为 <code>1 3 hello(3s后) 5 6 4 2</code>。</p><h2 id="Redux-旧版本-compose-的实现方式"><a href="#Redux-旧版本-compose-的实现方式" class="headerlink" title="Redux 旧版本 compose 的实现方式"></a>Redux 旧版本 compose 的实现方式</h2><h3 id="1、同步的实现-1"><a href="#1、同步的实现-1" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p><pre><code>app.compose = function() {    return app.middlewares.reduceRight((a, b) =&gt; () =&gt; b(a), () =&gt; {})();};</code></pre><p>上面的代码看起来不太好理解，我们不妨根据案例把这段代码拆解开，假设 <code>middlewares</code> 中存储的三个中间件函数分别为 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于使用的是 <code>reduceRight</code> 方法，所以是逆序归并，第一次 <code>a</code> 代表初始值（空函数），<code>b</code> 代表 <code>fn3</code>，而执行 <code>fn3</code> 返回了一个函数，这个函数再作为下一次归并的 <code>a</code>，而 <code>fn2</code> 作为 <code>b</code>，依次类推，过程如下。</p><pre><code>// 第 1 次 reduceRight 的返回值，下一次将作为 a() =&gt; fn3(() =&gt; {});// 第 2 次 reduceRight 的返回值，下一次将作为 a() =&gt; fn2(() =&gt; fn3(() =&gt; {}));// 第 3 次 reduceRight 的返回值，下一次将作为 a() =&gt; fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {})));</code></pre><p>由上面的拆解过程可以看出，如果我们调用了这个函数会先执行 <code>fn1</code>，如果调用 <code>next</code> 则会执行 <code>fn2</code>，如果同样调用 <code>next</code> 则会执行 <code>fn3</code>，<code>fn3</code> 已经是最后一个中间件函数了，再次调 <code>next</code> 会执行我们最初传入的空函数，这也是为什么要将 <code>reduceRight</code> 的初始值设置成一个空函数，就是防止最后一个中间件调用 <code>next</code> 而报错。</p><p>经过测试上面的代码不会出现顺序错乱的情况，但是在 <code>compose</code> 执行后，我们希望进行一些后续的操作，所以希望返回的是 Promise，而我们又希望传入给 <code>use</code> 的中间件函数既可以是普通函数，又可以是 <code>async</code> 函数，这就要我们的 <code>compose</code> 完全支持异步。</p><h3 id="2、升级为支持异步-1"><a href="#2、升级为支持异步-1" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>文件：app.js</p><pre><code>app.compose = function() {    return Promise.resolve(        app.middlewares.reduceRight(            (a, b) =&gt; () =&gt; Promise.resolve(b(a)),            () =&gt; Promise.resolve();        )()    );};</code></pre><p>参考同步的分析过程，由于最后一个中间件执行后执行的空函数内一定没有任何逻辑，但为遇到异步代码可以继续执行（比如执行 <code>next</code> 后又调用了 <code>then</code>），都处理成了 Promise，保证了 <code>reduceRight</code> 每一次归并的时候返回的函数内都返回了一个 Promise，这样就完全兼容了 <code>async</code> 和普通函数，当所有中间件执行完毕，也返回了一个 Promise，这样 <code>compose</code> 就可以调用 <code>then</code> 方法执行后续逻辑。</p><h2 id="Redux-新版本-compose-的实现方式"><a href="#Redux-新版本-compose-的实现方式" class="headerlink" title="Redux 新版本 compose 的实现方式"></a>Redux 新版本 compose 的实现方式</h2><h3 id="1、同步的实现-2"><a href="#1、同步的实现-2" class="headerlink" title="1、同步的实现"></a>1、同步的实现</h3><p>文件：app.js</p><pre><code>app.compose = function() {    return app.middlewares.reduce((a, b) =&gt; arg =&gt; a(() =&gt; b(arg)))(() =&gt; {});};</code></pre><p><code>Redux</code> 新版本中将 <code>compose</code> 的逻辑做了些改动，将原本的 <code>reduceRight</code> 换成 <code>reduce</code>，也就是说将逆序归并改为了正序，我们不一定和 <code>Redux</code> 源码完全相同，是根据相同的思路来实现串行中间件的需求。</p><p>个人觉得改成正序归并后更难理解，所以还是将上面代码结合案例进行拆分，中间件依然是 <code>fn1</code>、<code>fn2</code> 和 <code>fn3</code>，由于 <code>reduce</code> 并没有传入初始值，所以此时 <code>a</code> 为 <code>fn1</code>，<code>b</code> 为 <code>fn2</code>。</p><pre><code>// 第 1 次 reduce 的返回值，下一次将作为 aarg =&gt; fn1(() =&gt; fn2(arg));// 第 2 次 reduce 的返回值，下一次将作为 aarg =&gt; (arg =&gt; fn1(() =&gt; fn2(arg)))(() =&gt; fn3(arg));// 等价于...arg =&gt; fn1(() =&gt; fn2(() =&gt; fn3(arg)));// 执行最后返回的函数连接中间件，返回值等价于...fn1(() =&gt; fn2(() =&gt; fn3(() =&gt; {})));</code></pre><p>所以在调用 <code>reduce</code> 最后返回的函数时，传入了一个空函数作为参数，其实这个参数最后传递给了 <code>fn3</code>，也就是第三个中间件，这样保证了在最后一个中间件调用 <code>next</code> 时不会报错。</p><h3 id="2、升级为支持异步-2"><a href="#2、升级为支持异步-2" class="headerlink" title="2、升级为支持异步"></a>2、升级为支持异步</h3><p>下面有个更艰巨的任务，就是将上面的代码更改为支持异步，实现如下。</p><p>文件：app.js</p><pre><code>app.compose = function() {    return Promise.resolve(        app.middlewares.reduce((a, b) =&gt; arg =&gt;            Promise.resolve(a(() =&gt; b(arg)))        )(() =&gt; Promise.resolve())    );};</code></pre><p>实现异步其实与逆序归并是一个套路，就是让每一个中间件函数的返回值都是 Promise，并让 <code>compose</code> 也返回 Promise。</p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function originDispatch(...args) &#123;</span><br><span class="line">console.log(...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function middleware1(dispatch) &#123;</span><br><span class="line">return (...args) =&gt; &#123;</span><br><span class="line">console.log(&apos;middleware1 before dispatch&apos;)</span><br><span class="line">dispatch(...args)</span><br><span class="line">console.log(&apos;middleware1 after dispatch&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function middleware2(dispatch) &#123;</span><br><span class="line">return (...args) =&gt; &#123;</span><br><span class="line">console.log(&apos;middleware2 before dispatch&apos;)</span><br><span class="line">dispatch(...args)</span><br><span class="line">console.log(&apos;middleware2 after dispatch&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function middleware3(dispatch) &#123;</span><br><span class="line">return (...args) =&gt; &#123;</span><br><span class="line">console.log(&apos;middleware3 before dispatch&apos;)</span><br><span class="line">dispatch(...args)</span><br><span class="line">console.log(&apos;middleware3 after dispatch&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//originDispatch = middleware2(middleware1(originDispatch))</span><br><span class="line">//originDispatch(&apos;redux&apos;, &apos;is&apos;, &apos;cool&apos;);</span><br><span class="line"></span><br><span class="line">function compose(...funcs) &#123;</span><br><span class="line">return funcs.reduce((a, b) =&gt; (args) =&gt; a(b(args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            //console.log(compose(middleware2, middleware1))</span><br><span class="line">               //(args) =&gt; middleware2(middleware1(args))  </span><br><span class="line">               //(originDispatch)=&gt;middleware2(middleware1(originDispatch))  </span><br><span class="line">               </span><br><span class="line">compose(middleware2, middleware1)(originDispatch)(&apos;redux&apos;, &apos;is&apos;, &apos;cool&apos;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-async-函数实现"><a href="#使用-async-函数实现" class="headerlink" title="使用 async 函数实现"></a>使用 async 函数实现</h2><p>这个版本是我在之前在学习 <code>Koa</code> 源码时偶然在一位大佬的一篇分析 <code>Koa</code> 原理的文章中看到的（翻了半天实在没找到链接），在这里也拿出来和大家分享一下，由于是利用 <code>async</code> 函数实现的，所以默认就是支持异步的，因为 <code>async</code> 函数会返回一个 Promise。</p><p>文件：app.js</p><pre><code>app.compose = function() {    // 自执行 async 函数返回 Promise    return (async function () {        // 定义默认的 next，最后一个中间件内执行的 next        let next = async () =&gt; Promise.resolve();        // middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next        // 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题        function createNext(middleware, oldNext) {            return async () =&gt; {                await middleware(oldNext);            }        }        // 反向遍历中间件数组，先把 next 传给最后一个中间件函数        // 将新的中间件函数存入 next 变量        // 调用下一个中间件函数，将新生成的 next 传入        for (let i = app.middlewares.length - 1; i &gt;= 0; i--) {            next = createNext(app.middlewares[i], next);        }        await next();    })();};</code></pre><p>上面代码中的 <code>next</code> 是一个只返回成功态 Promise 的函数，可以理解为其他实现方式中最后一个中间件调用的 <code>next</code>，而数组 <code>middlewares</code> 刚好是反向遍历的，取到的第一个值就是最后一个中间件，而调用 <code>createNext</code>作用是返回一个新的可以执行数组中最后一个中间件的 <code>async</code> 函数，并传入了初始的 <code>next</code>，这个返回的 <code>async</code> 函数作为新的 <code>next</code>，再取到倒数第二个中间件，调用 <code>createNext</code>，又返回了一个 <code>async</code> 函数，函数内依然是倒数第二个中间件的执行，传入的 <code>next</code> 就是上次新生成的 <code>next</code>，这样依次类推到第一个中间件。</p><p>因此执行第一个中间件返回的 <code>next</code> 则会执行传入的上一个生成的 <code>next</code> 函数，就会执行第二个中间件，就会执行第二个中间件中的 <code>next</code>，就这样直到执行完最初定义的的 <code>next</code>，通过案例的验证，执行结果与洋葱模型完全相同。</p><p>至于异步的问题，每次执行的 <code>next</code> 都是 <code>async</code> 函数，执行后返回的都是 Promise，而最外层的自执行 <code>async</code> 函数返回的也是 Promise，也就是说 <code>compose</code> 最后返回的是 Promise，因此完全支持异步。</p><p>这个方式之所放在最后，是因为个人觉得不好理解，我是按照自己对这几种方式理解的难易程度由上至下排序的。</p><h2 id="Koa第一版"><a href="#Koa第一版" class="headerlink" title="Koa第一版"></a>Koa第一版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">// 模拟 Koa 创建的实例</span><br><span class="line">const app = &#123;</span><br><span class="line">middlewares: []</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建 use 方法</span><br><span class="line">app.use = function(fn) &#123;</span><br><span class="line">app.middlewares.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line">app.use(next =&gt; &#123;</span><br><span class="line">console.log(1);</span><br><span class="line">next();</span><br><span class="line">console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(next =&gt; &#123;</span><br><span class="line">console.log(3);</span><br><span class="line">next();</span><br><span class="line">console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(next =&gt; &#123;</span><br><span class="line">console.log(5);</span><br><span class="line">next();</span><br><span class="line">console.log(6);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose = function() &#123;</span><br><span class="line">// 递归函数</span><br><span class="line">function dispatch(index) &#123;</span><br><span class="line">// 如果所有中间件都执行完跳出</span><br><span class="line">if(index === app.middlewares.length) return;</span><br><span class="line"></span><br><span class="line">// 取出第 index 个中间件并执行</span><br><span class="line">const route = app.middlewares[index];</span><br><span class="line">return route(() =&gt; dispatch(index + 1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取出第一个中间件函数执行</span><br><span class="line">dispatch(0);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.compose();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="Koa第二版"><a href="#Koa第二版" class="headerlink" title="Koa第二版"></a>Koa第二版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">// 模拟 Koa 创建的实例</span><br><span class="line">const app = &#123;</span><br><span class="line">middlewares: []</span><br><span class="line">&#125;;</span><br><span class="line">// 异步函数</span><br><span class="line">function fn() &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">resolve();</span><br><span class="line">console.log(&quot;hello&quot;);</span><br><span class="line">&#125;, 3000);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 创建 use 方法</span><br><span class="line">app.use = function(fn) &#123;</span><br><span class="line">app.middlewares.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line">app.use(async next =&gt; &#123;</span><br><span class="line">console.log(1);</span><br><span class="line">await next();</span><br><span class="line">console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async next =&gt; &#123;</span><br><span class="line">console.log(3);</span><br><span class="line">await fn(); // 调用异步函数</span><br><span class="line">await next();</span><br><span class="line">console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async next =&gt; &#123;</span><br><span class="line">console.log(5);</span><br><span class="line">await next();</span><br><span class="line">console.log(6);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose = function() &#123;</span><br><span class="line">// 递归函数</span><br><span class="line">function dispatch(index) &#123;</span><br><span class="line">// 如果所有中间件都执行完跳出，并返回一个 Promise</span><br><span class="line">if(index === app.middlewares.length) return Promise.resolve();</span><br><span class="line"></span><br><span class="line">// 取出第 index 个中间件并执行</span><br><span class="line">const route = app.middlewares[index];</span><br><span class="line"></span><br><span class="line">// 执行后返回成功态的 Promise</span><br><span class="line">return Promise.resolve(route(() =&gt; dispatch(index + 1)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取出第一个中间件函数执行</span><br><span class="line">dispatch(0);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.compose();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="Koa第三版"><a href="#Koa第三版" class="headerlink" title="Koa第三版"></a>Koa第三版</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">// 模拟 Koa 创建的实例</span><br><span class="line">const app = &#123;</span><br><span class="line">middlewares: []</span><br><span class="line">&#125;;</span><br><span class="line">// 异步函数</span><br><span class="line">function fn() &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">resolve();</span><br><span class="line">console.log(&quot;hello&quot;);</span><br><span class="line">&#125;, 3000);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 创建 use 方法</span><br><span class="line">app.use = function(fn) &#123;</span><br><span class="line">app.middlewares.push(fn);</span><br><span class="line">&#125;;</span><br><span class="line">app.use(async next =&gt; &#123;</span><br><span class="line">console.log(1);</span><br><span class="line">await next();</span><br><span class="line">console.log(2);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async next =&gt; &#123;</span><br><span class="line">console.log(3);</span><br><span class="line">await fn(); // 调用异步函数</span><br><span class="line">await next();</span><br><span class="line">console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async next =&gt; &#123;</span><br><span class="line">console.log(5);</span><br><span class="line">await next();</span><br><span class="line">console.log(6);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.compose = function() &#123;</span><br><span class="line">// 自执行 async 函数返回 Promise</span><br><span class="line">return(async function() &#123;</span><br><span class="line">// 定义默认的 next，最后一个中间件内执行的 next</span><br><span class="line">let next = async() =&gt; Promise.resolve();</span><br><span class="line"></span><br><span class="line">// middleware 为每一个中间件函数，oldNext 为每个中间件函数中的 next</span><br><span class="line">// 函数返回一个 async 作为新的 next，async 执行返回 Promise，解决异步问题</span><br><span class="line">function createNext(middleware, oldNext) &#123;</span><br><span class="line">return async() =&gt; &#123;</span><br><span class="line">await middleware(oldNext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 反向遍历中间件数组，先把 next 传给最后一个中间件函数</span><br><span class="line">// 将新的中间件函数存入 next 变量</span><br><span class="line">// 调用下一个中间件函数，将新生成的 next 传入</span><br><span class="line">for(let i = app.middlewares.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">next = createNext(app.middlewares[i], next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await next();</span><br><span class="line">&#125;)();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">app.compose();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="Log中间件"><a href="#Log中间件" class="headerlink" title="Log中间件"></a>Log中间件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function log(ctx) &#123;</span><br><span class="line">    console.log(ctx.method, ctx.header.host + ctx.url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = function() &#123;</span><br><span class="line">return async function(ctx, next) &#123;</span><br><span class="line">log(ctx);</span><br><span class="line">await next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;) // koa v2</span><br><span class="line">const loggerAsync = require(&apos;./log&apos;)</span><br><span class="line">const app = new Koa()</span><br><span class="line"></span><br><span class="line">app.use(loggerAsync())</span><br><span class="line"></span><br><span class="line">app.use(async(ctx) =&gt; &#123;</span><br><span class="line">let url = ctx.url</span><br><span class="line">// 从上下文的request对象中获取</span><br><span class="line">let request = ctx.request</span><br><span class="line">let req_query = request.query</span><br><span class="line">let req_querystring = request.querystring</span><br><span class="line"></span><br><span class="line">// 从上下文中直接获取</span><br><span class="line">let ctx_query = ctx.query</span><br><span class="line">let ctx_querystring = ctx.querystring</span><br><span class="line"></span><br><span class="line">ctx.body = &#123;</span><br><span class="line">url,</span><br><span class="line">req_query,</span><br><span class="line">req_querystring,</span><br><span class="line">ctx_query,</span><br><span class="line">ctx_querystring</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br><span class="line">console.log(&apos;the server is starting at port 3000&apos;)</span><br></pre></td></tr></table></figure><h2 id="精简版-koa-简单封装"><a href="#精简版-koa-简单封装" class="headerlink" title="精简版 koa 简单封装"></a>精简版 koa 简单封装</h2><h3 id="Application-模块的简单封装"><a href="#Application-模块的简单封装" class="headerlink" title="Application 模块的简单封装"></a>Application 模块的简单封装</h3><blockquote><p>首先我们先简单封装一个模块 Application 保证服务的正常运行；</p></blockquote><ul><li>初始化一个项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm init -y</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>创建文件 application.js 并并编写如下代码;</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">classApplication&#123;</span><br><span class="line">  // 初始化constructor()&#123;</span><br><span class="line">    this.callback = () =&gt; &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 设置回调函数</span><br><span class="line">  use(callback)&#123;</span><br><span class="line">    this.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // listen 创建服务并对服务进行监听</span><br><span class="line">  listen(...args)&#123;</span><br><span class="line">    const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">      this.callback(req, res);</span><br><span class="line">    &#125;);</span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Application;</span><br></pre></td></tr></table></figure><ul><li>创建 server.js 文件，调用 Application 模块起一个服务：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const Application = require(&apos;./application.js&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Application();</span><br><span class="line"></span><br><span class="line">app.use((req, res) =&gt; &#123;</span><br><span class="line">  res.writeHead(200);</span><br><span class="line">  res.end(&apos;hello world&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;监听端口：3000&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Application-模块挂载-context"><a href="#Application-模块挂载-context" class="headerlink" title="Application 模块挂载 context"></a>Application 模块挂载 context</h3><blockquote><p>首先我们假设我们的 context 是这么一个数据结构:</p></blockquote><ul><li>context 中挂载了 request response req res, 同时还有抽离的额外属性 url body</li><li>request 中挂载了 req, 同时还有抽离的额外属性 url</li><li>response 中挂载了 res, 同时还有抽离的额外属性 body</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">context: &#123;</span><br><span class="line">  url: String,</span><br><span class="line">  body: String,</span><br><span class="line">  request: &#123;</span><br><span class="line">    url: String,</span><br><span class="line">    req: Object</span><br><span class="line">  &#125;,</span><br><span class="line">  response: &#123;</span><br><span class="line">    body: String,</span><br><span class="line">    res: Object</span><br><span class="line">  &#125;,</span><br><span class="line">  req: Object,</span><br><span class="line">  res: Object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>改写  Application</p></blockquote><ul><li>设计 context request response 原型数据结构；</li><li>将 context request response 原型数据结构挂载到 Application</li><li>编写函数创建 context</li><li>改写回调函数的调用方式；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">// [1]构建数据结构（作为原型使用）</span><br><span class="line">const request = &#123;</span><br><span class="line">  // 因为后期 request 将会挂载上 req 所以存在 this.req</span><br><span class="line">  get url()&#123;</span><br><span class="line">    returnthis.req.url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const response = &#123;</span><br><span class="line">  get body()&#123;</span><br><span class="line">    returnthis._body;</span><br><span class="line">  &#125;,</span><br><span class="line">  set body(val)&#123;</span><br><span class="line">    this._body = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const context = &#123;</span><br><span class="line">  // 因为后期 context 将会挂载上 request response 所以存在 this.request 和  this.response</span><br><span class="line">  get url()&#123;</span><br><span class="line">    returnthis.request.url;</span><br><span class="line">  &#125;,</span><br><span class="line">  get body()&#123;</span><br><span class="line">    returnthis.response.body;</span><br><span class="line">  &#125;,</span><br><span class="line">  set body(val)&#123;</span><br><span class="line">    this.response.body = val; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">classApplication&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.callback = () =&gt; &#123;&#125;,</span><br><span class="line">    // [2]将原型挂载到 Application</span><br><span class="line">    this.context = context;</span><br><span class="line">    this.request = request;</span><br><span class="line">    this.response = response;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  use(callback)&#123;</span><br><span class="line">    this.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line">  // [3]创建 context 函数，挂载上 request response req res </span><br><span class="line">  createCtx(req, res)&#123;</span><br><span class="line">    const ctx = Object.create(this.context);</span><br><span class="line">    ctx.request = Object.create(this.request);</span><br><span class="line">    ctx.response = Object.create(this.response);</span><br><span class="line">    ctx.req = ctx.request = req;</span><br><span class="line">    ctx.res = ctx.response = res;</span><br><span class="line">    return ctx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listen(...args)&#123;</span><br><span class="line">    const server = http.createServer((req, res) =&gt; &#123;</span><br><span class="line">      // [4]创建 context, 并进行简单修改</span><br><span class="line">      const ctx = this.createCtx(req, res);</span><br><span class="line">      this.callback(ctx);</span><br><span class="line">      ctx.res.end(ctx.body);</span><br><span class="line">    &#125;);</span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Application;</span><br></pre></td></tr></table></figure><blockquote><p>修改 server.js 中 Application 的引用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Application = require(&apos;./application.js&apos;);</span><br><span class="line"></span><br><span class="line">const app = new Application();</span><br><span class="line"></span><br><span class="line">app.use( ctx =&gt; &#123;</span><br><span class="line">  ctx.body = &apos;hello world&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;监听端口：3000&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="中间件的实现"><a href="#中间件的实现" class="headerlink" title="中间件的实现"></a>中间件的实现</h3><h4 id="洋葱模型实现"><a href="#洋葱模型实现" class="headerlink" title="洋葱模型实现"></a>洋葱模型实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 场景模拟// 异步 promise 模拟</span><br><span class="line">const delay = async () =&gt; &#123;</span><br><span class="line">  returnnewPromise((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 中间间模拟const fn1 = async (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  await next();</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">const fn2 = async (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">  await delay();</span><br><span class="line">  await next();</span><br><span class="line">  console.log(4);</span><br><span class="line">&#125;</span><br><span class="line">const fn3 = async (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const middlewares = [fn1, fn2, fn3];</span><br><span class="line"></span><br><span class="line">// compose 实现洋葱模型</span><br><span class="line">const compose = (middlewares, ctx) =&gt; &#123;</span><br><span class="line">  const dispatch = (i) =&gt; &#123;</span><br><span class="line">    let fn = middlewares[i];</span><br><span class="line">    if(!fn)&#123; return Promise.resolve() &#125;</span><br><span class="line">    return Promise.resolve(fn(ctx, () =&gt; &#123;</span><br><span class="line">      return dispatch(i+1);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  return dispatch(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">compose(middlewares, 1);</span><br></pre></td></tr></table></figure><h4 id="compose-函数在-Application-模块中的使用："><a href="#compose-函数在-Application-模块中的使用：" class="headerlink" title="compose 函数在 Application 模块中的使用："></a>compose 函数在 Application 模块中的使用：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">const request = &#123;</span><br><span class="line">  get url()&#123;</span><br><span class="line">    returnthis.req.url;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const response = &#123;</span><br><span class="line">  get body()&#123;</span><br><span class="line">    returnthis._body;</span><br><span class="line">  &#125;,</span><br><span class="line">  set body(val)&#123;</span><br><span class="line">    this._body = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">const context = &#123;</span><br><span class="line">  get url()&#123;</span><br><span class="line">    returnthis.request.url;</span><br><span class="line">  &#125;,</span><br><span class="line">  get body()&#123;</span><br><span class="line">    returnthis.response.body;</span><br><span class="line">  &#125;,</span><br><span class="line">  set body(val)&#123;</span><br><span class="line">    this.response.body = val; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Application&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    this.context = context;</span><br><span class="line">    this.request = request;</span><br><span class="line">    this.response = response;</span><br><span class="line">    // 初始化中间件数组</span><br><span class="line">    this.middlewares = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 通过push的方式进行添加中间件</span><br><span class="line">  use(middleware)&#123;</span><br><span class="line">    this.middlewares.push(middleware);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  create Ctx(req, res)&#123;</span><br><span class="line">    const ctx = Object.create(this.context);</span><br><span class="line">    ctx.request = Object.create(this.request);</span><br><span class="line">    ctx.response = Object.create(this.response);</span><br><span class="line">    ctx.req = ctx.request = req;</span><br><span class="line">    ctx.res = ctx.response = res;</span><br><span class="line">    return ctx;</span><br><span class="line">  &#125;</span><br><span class="line">  // compose 函数</span><br><span class="line">  compose(middlewares, ctx)&#123;</span><br><span class="line">    const dispatch = (i) =&gt; &#123;</span><br><span class="line">      const fn = middlewares[i];</span><br><span class="line">      if(!fn)&#123;</span><br><span class="line">        return Promise.resolve();</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        return Promise.resolve(fn(ctx, () =&gt; &#123;</span><br><span class="line">          dispatch(i +1 );</span><br><span class="line">        &#125;));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dispatch(0);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listen(...args)&#123;</span><br><span class="line">    // 改用 async await 并调用 compose</span><br><span class="line">    const server = http.createServer(async (req, res) =&gt; &#123;</span><br><span class="line">      const ctx = this.createCtx(req, res);</span><br><span class="line">      await this.compose(this.middlewares, ctx);</span><br><span class="line">      ctx.res.end(ctx.body);</span><br><span class="line">    &#125;);</span><br><span class="line">    server.listen(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports = Application;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>或许你看完这几种方式会觉得，还是 <code>Koa</code> 对于 <code>compose</code> 的实现方式最容易理解，你也可能和我一样在感慨 <code>Redux</code> 的两种实现方式和 <code>async</code> 函数实现方式是如此的巧妙，恰恰 JavaScript 在被别人诟病 “弱类型”、“不严谨” 的同时，就是如此的具有灵活性和创造性，我们无法判断这是优点还是缺点（仁者见仁，智者见智），但有一点是肯定的，学习 JavaScript 不要被强类型语言的 “墨守成规” 所束缚（个人观点，强类型语言开发者勿喷），就是要吸收这样巧妙的编程思想，写出 <code>compose</code> 这种优雅又高逼格的代码，路漫漫其修远兮，愿你在技术的路上 “一去不复返”。</p>]]></content>
      
      
      
        <tags>
            
            <tag> koa </tag>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue超简洁双日历组件</title>
      <link href="/2018/09/24/vue%E8%B6%85%E7%AE%80%E6%B4%81%E5%8F%8C%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/09/24/vue%E8%B6%85%E7%AE%80%E6%B4%81%E5%8F%8C%E6%97%A5%E5%8E%86%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="看了那么多的日历组件，没有一个满意的"><a href="#看了那么多的日历组件，没有一个满意的" class="headerlink" title=" 看了那么多的日历组件，没有一个满意的"></a><center> 看了那么多的日历组件，没有一个满意的</center></h3><p><img src="https://raw.githubusercontent.com/libin1991/my-calendar/master/1.jpg" alt="vue超简洁双日历组件"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;!--&lt;div class=&quot;hide&quot;&gt;</span><br><span class="line">&lt;mcalendar :child=&quot;date0&quot;&gt;&lt;/mcalendar&gt;</span><br><span class="line">&lt;mcalendar :child=&quot;date1&quot;&gt;&lt;/mcalendar&gt;</span><br><span class="line">&lt;/div&gt;--&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;mdatapick :child=&apos;mdatapickdata&apos; @cllback=&quot;callback&quot;&gt;&lt;/mdatapick&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &apos;@/assets/css/reset.less&apos;</span><br><span class="line">import mcalendar from &apos;./mdata&apos;</span><br><span class="line">import mdatapick from &apos;./mdatapick&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">//date0: &#123;</span><br><span class="line">//now: &quot;2018-09-05&quot;,</span><br><span class="line">//end: &quot;2018-09-28&quot;,</span><br><span class="line">//callback: function(d) &#123;</span><br><span class="line">//console.log(d);</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;,</span><br><span class="line">//date1: &#123;</span><br><span class="line">//now: &quot;2018-11-25&quot;,</span><br><span class="line">//start: &quot;2018-11-05&quot;,</span><br><span class="line">//callback: function(d) &#123;</span><br><span class="line">//console.log(d);</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;,</span><br><span class="line">mdatapickdata: &#123;</span><br><span class="line">start: &quot;2018-09-29&quot;,</span><br><span class="line">end: &quot;2018-10-18&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">callback(startDate, endDate) &#123;</span><br><span class="line">this.mdatapickdata.start=startDate;</span><br><span class="line">this.mdatapickdata.end=endDate;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">components: &#123;</span><br><span class="line">mcalendar,</span><br><span class="line">mdatapick</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;m_calender&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; class=&quot;date_input&quot; readonly=&quot;readonly&quot; v-model=&quot;dataMsg&quot; @click=&quot;toggleShow&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;datamain&quot; v-if=&quot;open&quot;&gt;</span><br><span class="line">&lt;div class=&quot;datacon&quot;&gt;</span><br><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line">&lt;div class=&quot;date_main&quot;&gt;</span><br><span class="line">&lt;div class=&quot;title&quot;&gt;</span><br><span class="line">&lt;div class=&quot;time&quot;&gt;开始日期&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;timenum&quot;&gt;&#123;&#123;start&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;date_top&quot;&gt;</span><br><span class="line">&lt;em class=&quot;prev_month hoverhands&quot; @click=&quot;prev(&apos;start&apos;)&quot;&gt;&lt;/em&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;span class=&quot;top_month&quot;&gt;&#123;&#123;getMonthText(startMonth)&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;top_year&quot;&gt;&#123;&#123;startYear&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;em v-if=&quot;startNext&quot; class=&quot;next_month hoverhands&quot; @click=&quot;next(&apos;start&apos;)&quot;&gt;&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;date_week&quot;&gt;</span><br><span class="line">&lt;em&gt;周日&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周一&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周二&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周三&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周四&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周五&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周六&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;date_day&quot;&gt;</span><br><span class="line">&lt;em v-for=&quot;s in startlist&quot; :class=&quot;s.className&quot; @click=&quot;clickDate(s,&apos;start&apos;)&quot;&gt;&#123;&#123; s.num &#125;&#125;&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line">&lt;div class=&quot;date_main&quot;&gt;</span><br><span class="line">&lt;div class=&quot;title&quot;&gt;</span><br><span class="line">&lt;div class=&quot;time&quot;&gt;结束日期&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;timenum&quot;&gt;&#123;&#123;end&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;date_top&quot;&gt;</span><br><span class="line">&lt;em v-if=&quot;endPrev&quot; class=&quot;prev_month hoverhands&quot; @click=&quot;prev(&apos;end&apos;)&quot;&gt;&lt;/em&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;span class=&quot;top_month&quot;&gt;&#123;&#123;getMonthText(endMonth)&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;top_year&quot;&gt;&#123;&#123;endYear&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;em class=&quot;next_month hoverhands&quot; @click=&quot;next(&apos;end&apos;)&quot;&gt;&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;date_week&quot;&gt;</span><br><span class="line">&lt;em&gt;周日&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周一&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周二&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周三&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周四&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周五&lt;/em&gt;</span><br><span class="line">&lt;em&gt;周六&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;date_day&quot;&gt;</span><br><span class="line">&lt;em v-for=&quot;s in endlist&quot; :class=&quot;s.className&quot; @click=&quot;clickDate(s,&apos;end&apos;)&quot;&gt;&#123;&#123; s.num &#125;&#125;&lt;/em&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;databtn&quot;&gt;</span><br><span class="line">&lt;div class=&quot;btn hoverhands&quot; @click=&quot;toggleShow&quot;&gt;取消&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;btn active hoverhands&quot; @click=&quot;Determine&quot;&gt;确定&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">props: [&quot;child&quot;],</span><br><span class="line">data: function() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">open: false,</span><br><span class="line">start: this.child.start,</span><br><span class="line">startYear: &apos;&apos;,</span><br><span class="line">startMonth: &apos;&apos;,</span><br><span class="line">startFirstWeek: &apos;&apos;,</span><br><span class="line">startDaySum: &apos;&apos;,</span><br><span class="line">startlist: [],</span><br><span class="line">startNext:true,</span><br><span class="line">end: this.child.end,</span><br><span class="line">endYear: &apos;&apos;,</span><br><span class="line">endMonth: &apos;&apos;,</span><br><span class="line">endFirstWeek: &apos;&apos;,</span><br><span class="line">endDaySum: &apos;&apos;,</span><br><span class="line">endlist: [],</span><br><span class="line">endPrev:true</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">activeStartData() &#123;</span><br><span class="line">return new Date(this.start).getTime();</span><br><span class="line">&#125;,</span><br><span class="line">activeEndData() &#123;</span><br><span class="line">return new Date(this.end).getTime();</span><br><span class="line">&#125;,</span><br><span class="line">dataMsg() &#123;</span><br><span class="line">if(this.child) &#123;</span><br><span class="line">return `$&#123;this.child.start&#125; ~ $&#123;this.child.end&#125;`</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">check(tag) &#123;</span><br><span class="line">var startTime = new Date(`$&#123;this.startYear&#125;-$&#123;this.checkVal(this.startMonth)&#125;-01`).getTime();</span><br><span class="line">var endTime = new Date(`$&#123;this.endYear&#125;-$&#123;this.checkVal(this.endMonth)&#125;-01`).getTime();</span><br><span class="line">if(endTime &lt;= startTime) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">var startDate = new Date(this.start);</span><br><span class="line">this.startYear = startDate.getFullYear();</span><br><span class="line">this.startMonth = startDate.getMonth() + 1;</span><br><span class="line">var endDate = new Date(this.end);</span><br><span class="line">this.endYear = endDate.getFullYear();</span><br><span class="line">this.endMonth = endDate.getMonth() + 1;</span><br><span class="line">this.init();</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">toggleShow() &#123;</span><br><span class="line">this.open = !this.open;</span><br><span class="line">&#125;,</span><br><span class="line">init() &#123;</span><br><span class="line">this.startFirstWeek = new Date(`$&#123;this.startYear&#125;-$&#123;this.checkVal(this.startMonth)&#125;-01`).getDay();</span><br><span class="line">this.startDaySum = this.getMonthDaySum(`$&#123;this.startYear&#125;-$&#123;this.checkVal(this.startMonth)&#125;-01`);</span><br><span class="line">this.startlist = this.initDate(this.startFirstWeek, this.startDaySum, this.startYear, this.startMonth, this.activeStartData);</span><br><span class="line">this.endFirstWeek = new Date(`$&#123;this.endYear&#125;-$&#123;this.checkVal(this.endMonth)&#125;-01`).getDay();</span><br><span class="line">this.endDaySum = this.getMonthDaySum(`$&#123;this.endYear&#125;-$&#123;this.checkVal(this.endMonth)&#125;-1`);</span><br><span class="line">this.endlist = this.initDate(this.endFirstWeek, this.endDaySum, this.endYear, this.endMonth, this.activeEndData)</span><br><span class="line">&#125;,</span><br><span class="line">prev(tag) &#123;</span><br><span class="line">if(tag == &apos;end&apos;) &#123;</span><br><span class="line">if(!this.check) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this[tag + &apos;Month&apos;]--;</span><br><span class="line">if(!this[tag + &apos;Month&apos;]) &#123;</span><br><span class="line">this[tag + &apos;Month&apos;] = 12;</span><br><span class="line">this[tag + &apos;Year&apos;]--;</span><br><span class="line">&#125;</span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">this.init();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">next(tag) &#123;</span><br><span class="line">if(tag == &apos;start&apos;) &#123;</span><br><span class="line">if(!this.check) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">this[tag + &apos;Month&apos;]++;</span><br><span class="line">if(this[tag + &apos;Month&apos;] &gt; 12) &#123;</span><br><span class="line">this[tag + &apos;Month&apos;] = 1;</span><br><span class="line">this[tag + &apos;Year&apos;]++;</span><br><span class="line">&#125;</span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">this.init();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;,</span><br><span class="line">getMonthDaySum(val) &#123; //获取当前月有多少天</span><br><span class="line">var curDate = new Date(val);</span><br><span class="line">var curMonth = curDate.getMonth();</span><br><span class="line">curDate.setMonth(curMonth + 1);</span><br><span class="line">curDate.setDate(0);</span><br><span class="line">return curDate.getDate();</span><br><span class="line">&#125;,</span><br><span class="line">initDate(FirstWeek, DaySum, Year, Month, activeData) &#123;</span><br><span class="line">var list = [];</span><br><span class="line">for(var i = 1; i &lt;= FirstWeek; i++) &#123;</span><br><span class="line">var Dates = new Date(`$&#123;Year&#125;-$&#123;this.checkVal(Month)&#125;-01`);</span><br><span class="line">Dates.setDate(i - FirstWeek);</span><br><span class="line">list.push(&#123;</span><br><span class="line">&quot;className&quot;: &quot;disabled&quot;,</span><br><span class="line">&quot;num&quot;: Dates.getDate(),</span><br><span class="line">&quot;date&quot;: `$&#123;Year&#125;-$&#123;this.checkVal(Month-1)&#125;-$&#123;Dates.getDate()&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">for(var i = 1; i &lt;= DaySum; i++) &#123;</span><br><span class="line">var isActive = new Date(`$&#123;Year&#125;-$&#123;this.checkVal(Month)&#125;-$&#123;this.checkVal(i)&#125;`).getTime() == activeData;</span><br><span class="line">list.push(&#123;</span><br><span class="line">&quot;className&quot;: isActive ? &apos;on&apos; : &apos;&apos;,</span><br><span class="line">&quot;num&quot;: i,</span><br><span class="line">&quot;date&quot;: `$&#123;Year&#125;-$&#123;this.checkVal(Month)&#125;-$&#123;this.checkVal(i)&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">var nextData = new Date(`$&#123;Year&#125;-$&#123;this.checkVal(Month)&#125;-$&#123;DaySum&#125;`).getDay();</span><br><span class="line">for(var i = 1; i &lt;= 6 - nextData; i++) &#123;</span><br><span class="line">list.push(&#123;</span><br><span class="line">&quot;className&quot;: &quot;disabled&quot;,</span><br><span class="line">&quot;num&quot;: i,</span><br><span class="line">&quot;date&quot;: `$&#123;Year&#125;-$&#123;this.checkVal(Month+1)&#125;-$&#123;this.checkVal(i)&#125;`</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;,</span><br><span class="line">checkVal(num) &#123;</span><br><span class="line">num = +num;</span><br><span class="line">return +num &lt; 10 ? &quot;0&quot; + num : &apos;&apos; + num;</span><br><span class="line">&#125;,</span><br><span class="line">clickDate(val, tag) &#123;</span><br><span class="line">if(val.className !== &apos;disabled&apos;) &#123;</span><br><span class="line">this[tag] = val.date;</span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">this.init();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">Determine() &#123;</span><br><span class="line">this.toggleShow();</span><br><span class="line">this.$emit(&quot;cllback&quot;, this.start, this.end)</span><br><span class="line">&#125;,</span><br><span class="line">getMonthText(m) &#123;</span><br><span class="line">return [&apos;&apos;, &apos;一月&apos;, &apos;二月&apos;, &apos;三月&apos;, &apos;四月&apos;, &apos;五月&apos;, &apos;六月&apos;, &apos;七月&apos;, &apos;八月&apos;, &apos;九月&apos;, &apos;十月&apos;, &apos;十一月&apos;, &apos;十二月&apos;][m]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">.m_calender &#123;</span><br><span class="line">position: relative;</span><br><span class="line">display: block;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">.date_input &#123;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">width: 200px;</span><br><span class="line">border: 1px solid red;</span><br><span class="line">text-align: center;</span><br><span class="line">height: 20px;</span><br><span class="line">line-height: 20px;</span><br><span class="line">cursor: pointer;</span><br><span class="line">display: block;</span><br><span class="line">color: #484848;</span><br><span class="line">font-size: 12px;</span><br><span class="line">&#125;</span><br><span class="line">.datamain &#123;</span><br><span class="line">border: 1px solid #E6E6E6;</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 30px;</span><br><span class="line">transform: translateX(-50%);</span><br><span class="line">&amp;::before &#123;</span><br><span class="line">content: &apos;&apos;;</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translateX(-50%);</span><br><span class="line">top: -18px;</span><br><span class="line">width: 0;</span><br><span class="line">height: 0;</span><br><span class="line">border-top: 9px solid rgba(0, 0, 0, 0);</span><br><span class="line">border-right: 9px solid rgba(0, 0, 0, 0);</span><br><span class="line">border-bottom: 9px solid #E6E6E6;</span><br><span class="line">border-left: 9px solid rgba(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">&amp;::after &#123;</span><br><span class="line">content: &apos;&apos;;</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translateX(-50%);</span><br><span class="line">top: -15px;</span><br><span class="line">width: 0;</span><br><span class="line">height: 0;</span><br><span class="line">border-top: 8px solid rgba(0, 0, 0, 0);</span><br><span class="line">border-right: 8px solid rgba(0, 0, 0, 0);</span><br><span class="line">border-bottom: 8px solid white;</span><br><span class="line">border-left: 8px solid rgba(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">.datacon &#123;</span><br><span class="line">display: flex;</span><br><span class="line">.con &#123;</span><br><span class="line">margin: 5px 10px;</span><br><span class="line">.date_main &#123;</span><br><span class="line">width: 232px;</span><br><span class="line">background: #FFFFFF;</span><br><span class="line">z-index: 20;</span><br><span class="line">.title &#123;</span><br><span class="line">padding: 8px 4px;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: space-between;</span><br><span class="line">align-items: center;</span><br><span class="line">font-size: 14px;</span><br><span class="line">.time &#123;</span><br><span class="line">color: #939393;</span><br><span class="line">&#125;</span><br><span class="line">.timenum &#123;</span><br><span class="line">color: #333333;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.date_top &#123;</span><br><span class="line">height: 28px;</span><br><span class="line">line-height: 28px;</span><br><span class="line">padding: 0 6px;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: space-around;</span><br><span class="line">align-items: center;</span><br><span class="line">em &#123;</span><br><span class="line">width: 14px;</span><br><span class="line">font-style: normal;</span><br><span class="line">margin: 9px 4px;</span><br><span class="line">&amp;.prev_month &#123;</span><br><span class="line">width: 0px;</span><br><span class="line">height: 0px;</span><br><span class="line">border-top: 7px solid rgba(0, 0, 0, 0);</span><br><span class="line">border-bottom: 7px solid rgba(0, 0, 0, 0);</span><br><span class="line">border-right: 7px solid #A1A1A1;</span><br><span class="line">border-left: 7px solid rgba(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">&amp;.next_month &#123;</span><br><span class="line">width: 0px;</span><br><span class="line">height: 0px;</span><br><span class="line">border-top: 7px solid rgba(0, 0, 0, 0);</span><br><span class="line">border-bottom: 7px solid rgba(0, 0, 0, 0);</span><br><span class="line">border-left: 7px solid #A1A1A1;</span><br><span class="line">border-right: 7px solid rgba(0, 0, 0, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p &#123;</span><br><span class="line">width: 100px;</span><br><span class="line">flex: 1;</span><br><span class="line">font-size: 12px;</span><br><span class="line">font-weight: 700;</span><br><span class="line">text-align: center;</span><br><span class="line">span &#123;</span><br><span class="line">width: 40px;</span><br><span class="line">display: inline-block;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.date_week &#123;</span><br><span class="line">height: 24px;</span><br><span class="line">em &#123;</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">font-style: normal;</span><br><span class="line">width: 33px;</span><br><span class="line">height: 24px;</span><br><span class="line">line-height: 24px;</span><br><span class="line">display: block;</span><br><span class="line">float: left;</span><br><span class="line">color: #484848;</span><br><span class="line">font-size: 12px;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.date_day &#123;</span><br><span class="line">overflow: hidden;</span><br><span class="line">border: 1px solid #E6E6E6;</span><br><span class="line">em &#123;</span><br><span class="line">font-style: normal;</span><br><span class="line">width: 32px;</span><br><span class="line">height: 20px;</span><br><span class="line">line-height: 20px;</span><br><span class="line">display: block;</span><br><span class="line">float: left;</span><br><span class="line">color: #484848;</span><br><span class="line">font-size: 12px;</span><br><span class="line">text-align: center;</span><br><span class="line">border-right: 1px solid #E6E6E6;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&amp;:nth-child(7n) &#123;</span><br><span class="line">border-right: 0px solid #E6E6E6;</span><br><span class="line">&#125;</span><br><span class="line">&amp;.on &#123;</span><br><span class="line">color: #FFFFFF;</span><br><span class="line">background-color: #E76E00;</span><br><span class="line">&#125;</span><br><span class="line">&amp;.disabled &#123;</span><br><span class="line">color: #CCCCCC;</span><br><span class="line">background-color: #FFFFFF;</span><br><span class="line">cursor: default;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.databtn &#123;</span><br><span class="line">text-align: right;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: flex-end;</span><br><span class="line">align-items: center;</span><br><span class="line">padding: 5px 0px 11px;</span><br><span class="line">.btn &#123;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">width: 56px;</span><br><span class="line">height: 24px;</span><br><span class="line">border: 1px solid red;</span><br><span class="line">font-size: 12px;</span><br><span class="line">border: 1px solid #E6E6E6;</span><br><span class="line">border-radius: 2px;</span><br><span class="line">&amp;.active &#123;</span><br><span class="line">color: wheat;</span><br><span class="line">margin: 0px 8px;</span><br><span class="line">background: #EE6E25;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Server-Sent Events:服务器推送事件,使用长链接进行通讯</title>
      <link href="/2018/09/11/Server-Sent-Events-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E4%BA%8B%E4%BB%B6-%E4%BD%BF%E7%94%A8%E9%95%BF%E9%93%BE%E6%8E%A5%E8%BF%9B%E8%A1%8C%E9%80%9A%E8%AE%AF/"/>
      <url>/2018/09/11/Server-Sent-Events-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81%E4%BA%8B%E4%BB%B6-%E4%BD%BF%E7%94%A8%E9%95%BF%E9%93%BE%E6%8E%A5%E8%BF%9B%E8%A1%8C%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>传统的网页都是浏览器向服务器“查询”数据，但是很多场合，最有效的方式是服务器向浏览器“发送”数据。比如，webpack的HRM，每当收到新的电子邮件，服务器就向浏览器发送一个“通知”，这要比浏览器按时向服务器查询（polling）更有效率。</p><p>服务器发送事件（Server-Sent Events，简称SSE）就是为了解决这个问题，而提出的一种新API，部署在EventSource对象上。目前，除了IE，其他主流浏览器都支持。</p><p>简单说，所谓SSE，就是浏览器向服务器发送一个HTTP请求，然后服务器不断单向地向浏览器推送“信息”（message）。这种信息在格式上很简单，就是“信息”加上前缀“data: ”，然后以“\n\n”结尾。</p><pre><code>$ curl http://example.com/datesdata: 1394572346452data: 1394572347457data: 1394572348463</code></pre><p>SSE与WebSocket有相似功能，都是用来建立浏览器与服务器之间的通信渠道。两者的区别在于：</p><ul><li><p>WebSocket是全双工通道，可以双向通信，功能更强；SSE是单向通道，只能服务器向浏览器端发送。</p></li><li><p>WebSocket是一个新的协议，需要服务器端支持；SSE则是部署在HTTP协议之上的，现有的服务器软件都支持。</p></li><li><p>SSE是一个轻量级协议，相对简单；WebSocket是一种较重的协议，相对复杂。</p></li><li><p>SSE默认支持断线重连，WebSocket则需要额外部署。</p></li><li><p>SSE支持自定义发送的数据类型。</p></li></ul><p>从上面的比较可以看出，两者各有特点，适合不同的场合。</p><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>首先，使用下面的代码，检测浏览器是否支持SSE。</p><pre><code>if (!!window.EventSource) {  // ...}</code></pre><p>然后，部署SSE大概如下。</p><pre><code>var source = new EventSource(&apos;/dates&apos;);source.onmessage = function(e){  console.log(e.data);};// 或者source.addEventListener(&apos;message&apos;, function(e){})</code></pre><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>首先，浏览器向服务器发起连接，生成一个EventSource的实例对象。</p><pre><code>var source = new EventSource(url);</code></pre><p>参数url就是服务器网址，必须与当前网页的网址在同一个网域（domain），而且协议和端口都必须相同。</p><p>下面是一个建立连接的实例。</p><pre><code>if (!!window.EventSource) {  var source = new EventSource(&apos;http://127.0.0.1/sses/&apos;);}</code></pre><p>新生成的EventSource实例对象，有一个readyState属性，表明连接所处的状态。</p><pre><code>source.readyState</code></pre><p>它可以取以下值：</p><blockquote><p>0，相当于常量EventSource.CONNECTING，表示连接还未建立，或者连接断线。</p></blockquote><blockquote><p>1，相当于常量EventSource.OPEN，表示连接已经建立，可以接受数据。</p></blockquote><blockquote><p>2，相当于常量EventSource.CLOSED，表示连接已断，且不会重连。</p></blockquote><h3 id="open事件"><a href="#open事件" class="headerlink" title="open事件"></a>open事件</h3><p>连接一旦建立，就会触发open事件，可以定义相应的回调函数。</p><pre><code>source.onopen = function(event) {  // handle open event};// 或者source.addEventListener(&quot;open&quot;, function(event) {  // handle open event}, false);</code></pre><h3 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h3><p>收到数据就会触发message事件。</p><pre><code>source.onmessage = function(event) {  var data = event.data;  var origin = event.origin;  var lastEventId = event.lastEventId;  // handle message};// 或者source.addEventListener(&quot;message&quot;, function(event) {  var data = event.data;  var origin = event.origin;  var lastEventId = event.lastEventId;  // handle message}, false);</code></pre><p>参数对象event有如下属性：</p><ul><li><p>data：服务器端传回的数据（文本格式）。</p></li><li><p>origin： 服务器端URL的域名部分，即协议、域名和端口。</p></li><li><p>lastEventId：数据的编号，由服务器端发送。如果没有编号，这个属性为空。</p></li></ul><h3 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h3><p>如果发生通信错误（比如连接中断），就会触发error事件。</p><pre><code>source.onerror = function(event) {  // handle error event};// 或者source.addEventListener(&quot;error&quot;, function(event) {  // handle error event}, false);</code></pre><h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>服务器可以与浏览器约定自定义事件。这种情况下，发送回来的数据不会触发message事件。</p><pre><code>source.addEventListener(&quot;foo&quot;, function(event) {  var data = event.data;  var origin = event.origin;  var lastEventId = event.lastEventId;  // handle message}, false);</code></pre><p>上面代码表示，浏览器对foo事件进行监听。</p><h3 id="close方法"><a href="#close方法" class="headerlink" title="close方法"></a>close方法</h3><p>close方法用于关闭连接。</p><pre><code>source.close();</code></pre><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>服务器端发送的数据的HTTP头信息如下：</p><pre><code>Content-Type: text/event-streamCache-Control: no-cacheConnection: keep-alive</code></pre><p>后面的行都是如下格式：</p><pre><code>field: value\n</code></pre><p>field可以取四个值：“data”, “event”, “id”, or “retry”，也就是说有四类头信息。每次HTTP通信可以包含这四类头信息中的一类或多类。\n代表换行符。</p><p>以冒号开头的行，表示注释。通常，服务器每隔一段时间就会向浏览器发送一个注释，保持连接不中断。</p><pre><code>: This is a comment</code></pre><p>下面是一些例子。</p><pre><code>: this is a test stream\n\ndata: some text\n\ndata: another message\ndata: with two lines \n\n</code></pre><h3 id="data：数据栏"><a href="#data：数据栏" class="headerlink" title="data：数据栏"></a>data：数据栏</h3><p>数据内容用data表示，可以占用一行或多行。如果数据只有一行，则像下面这样，以“\n\n”结尾。</p><pre><code>data:  message\n\n</code></pre><p>如果数据有多行，则最后一行用“\n\n”结尾，前面行都用“\n”结尾。</p><pre><code>data: begin message\ndata: continue message\n\n</code></pre><p>总之，最后一行的data，结尾要用两个换行符号，表示数据结束。</p><p>以发送JSON格式的数据为例。</p><pre><code>data: {\ndata: &quot;foo&quot;: &quot;bar&quot;,\ndata: &quot;baz&quot;, 555\ndata: }\n\n</code></pre><h3 id="id：数据标识符"><a href="#id：数据标识符" class="headerlink" title="id：数据标识符"></a>id：数据标识符</h3><p>数据标识符用id表示，相当于每一条数据的编号。</p><pre><code>id: msg1\ndata: message\n\n</code></pre><p>浏览器用lastEventId属性读取这个值。一旦连接断线，浏览器会发送一个HTTP头，里面包含一个特殊的“Last-Event-ID”头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</p><h3 id="event栏：自定义信息类型"><a href="#event栏：自定义信息类型" class="headerlink" title="event栏：自定义信息类型"></a>event栏：自定义信息类型</h3><p>event头信息表示自定义的数据类型，或者说数据的名字。</p><pre><code>event: foo\ndata: a foo event\n\ndata: an unnamed event\n\nevent: bar\ndata: a bar event\n\n</code></pre><p>上面的代码创造了三条信息。第一条是foo，触发浏览器端的foo事件；第二条未取名，表示默认类型，触发浏览器端的message事件；第三条是bar，触发浏览器端的bar事件。</p><h3 id="retry：最大间隔时间"><a href="#retry：最大间隔时间" class="headerlink" title="retry：最大间隔时间"></a>retry：最大间隔时间</h3><p>浏览器默认的是，如果服务器端三秒内没有发送任何信息，则开始重连。服务器端可以用retry头信息，指定通信的最大间隔时间。</p><pre><code>retry: 10000\n</code></pre><h2 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h2><p>服务器端发送事件，要求服务器与浏览器保持连接。对于不同的服务器软件来说，所消耗的资源是不一样的。Apache服务器，每个连接就是一个线程，如果要维持大量连接，势必要消耗大量资源。Node.js则是所有连接都使用同一个线程，因此消耗的资源会小得多，但是这要求每个连接不能包含很耗时的操作，比如磁盘的IO读写。</p><p>下面是Node.js的服务器发送事件的<a href="http://cjihrig.com/blog/server-sent-events-in-node-js/" target="_blank" rel="noopener">代码实例</a>。</p><pre><code>var http = require(&quot;http&quot;);http.createServer(function (req, res) {    var fileName = &quot;.&quot; + req.url;    if (fileName === &quot;./stream&quot;) {        res.writeHead(200, {&quot;Content-Type&quot;:&quot;text/event-stream&quot;,                             &quot;Cache-Control&quot;:&quot;no-cache&quot;,                             &quot;Connection&quot;:&quot;keep-alive&quot;});        res.write(&quot;retry: 10000\n&quot;);        res.write(&quot;event: connecttime\n&quot;);        res.write(&quot;data: &quot; + (new Date()) + &quot;\n\n&quot;);        res.write(&quot;data: &quot; + (new Date()) + &quot;\n\n&quot;);        interval = setInterval(function() {            res.write(&quot;data: &quot; + (new Date()) + &quot;\n\n&quot;);        }, 1000);        req.connection.addListener(&quot;close&quot;, function () {            clearInterval(interval);        }, false);  }}).listen(80, &quot;127.0.0.1&quot;);</code></pre><hr><h2 id="利用WebSocket和EventSource实现服务端推送"><a href="#利用WebSocket和EventSource实现服务端推送" class="headerlink" title="利用WebSocket和EventSource实现服务端推送"></a><a href="https://juejin.im/post/5c121c77f265da614a3a5e07" target="_blank" rel="noopener">利用WebSocket和EventSource实现服务端推送</a></h2><p>可能有很多的同学有用 setInterval 控制 ajax 不断向服务端请求最新数据的经历(轮询)看下面的代码：</p><pre><code>setInterval(function() {    $.get(&apos;/get/data-list&apos;, function(data, status) {        console.log(data)    })}, 5000)</code></pre><p>这样每隔5秒前端会向后台请求一次数据，实现上看起来很简单但是有个很重要的问题，就是我们没办法控制网速的稳定，不能保证在下次发请求的时候上一次的请求结果已经顺利返回，这样势必会有隐患，有聪明的同学马上会想到用 setTimeout 配合递归看下面的代码：</p><pre><code>functionpoll() {    setTimeout(function() {        $.get(&apos;/get/data-list&apos;, function(data, status) {            console.log(data)            poll()        })    }, 5000)}</code></pre><p>当结果返回之后再延时触发下一次的请求，这样虽然没办法保证两次请求之间的间隔时间完全一致但是至少可以保证数据返回的节奏是稳定的，看似已经实现了需求但是这么搞我们先不去管他的性能就代码结构也算不上优雅，为了解决这个问题可以让服务端长时间和客户端保持连接进行数据互通h5新增了 WebSocket 和 EventSource 用来实现长轮询，下面我们来分析一下这两者的特点以及使用场景。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>是什么：</strong> WebSocket是一种通讯手段，基于TCP协议，默认端口也是80和443，协议标识符是ws（加密为wss），它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据，不受跨域的限制。</p><p><strong>有什么用：</strong> WebSocket用来解决http不能持久连接的问题，因为可以双向通信所以可以用来实现聊天室，以及其他由服务端主动推送的功能例如 实时天气、股票报价、余票显示、消息通知等。</p><h2 id="EventSource"><a href="#EventSource" class="headerlink" title="EventSource"></a>EventSource</h2><p><strong>是什么：</strong> EventSource的官方名称应该是 Server-sent events（缩写SSE）服务端派发事件，EventSource 基于http协议只是简单的单项通信，实现了服务端推的过程客户端无法通过EventSource向服务端发送数据。喜闻乐见的是ie并没有良好的兼容当然也有解决的办法比如 <code>npm install event-source-polyfill</code>。虽然不能实现双向通信但是在功能设计上他也有一些优点比如可以自动重连接,event IDs,以及发送随机事件的能力（WebSocket要借助第三方库比如socket.io可以实现重连。）</p><p><strong>有什么用：</strong> 因为受单项通信的限制EventSource只能用来实现像股票报价、新闻推送、实时天气这些只需要服务器发送消息给客户端场景中。EventSource的使用更加便捷这也是他的优点。</p><h2 id="WebSocket-amp-EventSource-的区别"><a href="#WebSocket-amp-EventSource-的区别" class="headerlink" title="WebSocket &amp; EventSource 的区别"></a>WebSocket &amp; EventSource 的区别</h2><ol><li>WebSocket基于TCP协议，EventSource基于http协议。</li><li>EventSource是单向通信，而websocket是双向通信。</li><li>EventSource只能发送文本，而websocket支持发送二进制数据。</li><li>在实现上EventSource比websocket更简单。</li><li>EventSource有自动重连接（不借助第三方）以及发送随机事件的能力。</li><li>websocket的资源占用过大EventSource更轻量。</li><li>websocket可以跨域，EventSource基于http跨域需要服务端设置请求头。</li></ol><h2 id="EventSource的实现案例"><a href="#EventSource的实现案例" class="headerlink" title="EventSource的实现案例"></a>EventSource的实现案例</h2><p>客户端代码</p><pre><code>// 实例化 EventSource 参数是服务端监听的路由var source = new EventSource(&apos;/EventSource-test&apos;)source.onopen = function (event) { // 与服务器连接成功回调  console.log(&apos;成功与服务器连接&apos;)}// 监听从服务器发送来的所有没有指定事件类型的消息(没有event字段的消息)source.onmessage = function (event) { // 监听未命名事件  console.log(&apos;未命名事件&apos;, event.data)}source.onerror = function (error) { // 监听错误  console.log(&apos;错误&apos;)}// 监听指定类型的事件（可以监听多个）source.addEventListener(&quot;myEve&quot;, function (event) {  console.log(&quot;myEve&quot;, event.data)})</code></pre><p>服务端代码（node.js）</p><pre><code>const fs = require(&apos;fs&apos;)const express = require(&apos;express&apos;) // npm install expressconst app = express()// 启动一个简易的本地server返回index.htmlapp.get(&apos;/&apos;, (req, res) =&gt; {  fs.stat(&apos;./index.html&apos;, (err, stats) =&gt; {    if (!err &amp;&amp; stats.isFile()) {      res.writeHead(200)      fs.createReadStream(&apos;./index.html&apos;).pipe(res)    } else {      res.writeHead(404)      res.end(&apos;404 Not Found&apos;)    }  })})// 监听EventSource-test路由服务端返回事件流app.get(&apos;/EventSource-test&apos;, (ewq, res) =&gt; {  // 根据 EventSource 规范设置报头  res.writeHead(200, {    &quot;Content-Type&quot;: &quot;text/event-stream&quot;, // 规定把报头设置为 text/event-stream    &quot;Cache-Control&quot;: &quot;no-cache&quot; // 设置不对页面进行缓存  })  // 用write返回事件流，事件流仅仅是一个简单的文本数据流，每条消息以一个空行(\n)作为分割。  res.write(&apos;:注释&apos; + &apos;\n\n&apos;)  // 注释行  res.write(&apos;data:&apos; + &apos;消息内容1&apos; + &apos;\n\n&apos;) // 未命名事件  res.write(  // 命名事件    &apos;event: myEve&apos; + &apos;\n&apos; +    &apos;data:&apos; + &apos;消息内容2&apos; + &apos;\n&apos; +    &apos;retry:&apos; + &apos;2000&apos; + &apos;\n&apos; +    &apos;id:&apos; + &apos;12345&apos; + &apos;\n\n&apos;  )  setInterval(() =&gt; { // 定时事件    res.write(&apos;data:&apos; + &apos;定时消息&apos; + &apos;\n\n&apos;)  }, 2000)})// 监听 6788app.listen(6788, () =&gt; {  console.log(`server runing on port 6788 ...`)})</code></pre><p>客户端访问 <code>http://127.0.0.1:6788/</code> 会看到如下的输出：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/13/167a6bf535ecd347?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>来总结一下相关的api，客户端的api很简单都在注释里了，服务端有一些要注意的地方：</p><h4 id="事件流格式？"><a href="#事件流格式？" class="headerlink" title="事件流格式？"></a>事件流格式？</h4><p>事件流仅仅是一个简单的文本数据流，文本应该使用UTF-8格式的编码。每条消息后面都由一个空行作为分隔符。以冒号开头的行为注释行，会被忽略。</p><h4 id="注释有何用？"><a href="#注释有何用？" class="headerlink" title="注释有何用？"></a>注释有何用？</h4><p>注释行可以用来防止连接超时，服务器可以定期发送一条消息注释行，以保持连接不断。</p><h4 id="EventSource规范中规定了那些字段？"><a href="#EventSource规范中规定了那些字段？" class="headerlink" title="EventSource规范中规定了那些字段？"></a>EventSource规范中规定了那些字段？</h4><p><code>event：</code> 事件类型，如果指定了该字段，则在客户端接收到该条消息时，会在当前的EventSource对象上触发一个事件，事件类型就是该字段的字段值，你可以使用addEventListener()方法在当前EventSource对象上监听任意类型的命名事件，如果该条消息没有event字段，则会触发onmessage属性上的事件处理函数。<br><code>data：</code> 消息的数据字段，如果该条消息包含多个data字段,则客户端会用换行符把它们连接成一个字符串来作为字段值。<br><code>id：</code> 事件ID，会成为当前EventSource对象的内部属性”最后一个事件ID”的属性值。<br><code>retry：</code> 一个整数值，指定了重新连接的时间(单位为毫秒)，如果该字段值不是整数，则会被忽略。</p><h4 id="重连是干什么的？"><a href="#重连是干什么的？" class="headerlink" title="重连是干什么的？"></a>重连是干什么的？</h4><p>上文提过retry字段是用来指定重连时间的，那为什么要重连呢，我们拿node来说，大家知道node的特点是单线程异步io，单线程就意味着如果server端报错那么服务就会停掉，当然在node开发的过程中会处理这些异常，但是一旦服务停掉了这时就需要用pm2之类的工具去做重启操作，这时候server虽然正常了，但是客户端的EventSource链接还是断开的这时候就用到了重连。</p><h4 id="为什么案例中消息要用-n结尾？"><a href="#为什么案例中消息要用-n结尾？" class="headerlink" title="为什么案例中消息要用\n结尾？"></a>为什么案例中消息要用\n结尾？</h4><p>\n是换行的转义字符，EventSource规范规定每条消息后面都由一个空行作为分隔符，结尾加一个\n表示一个字段结束，加两个\n表示一条消息结束。(两个\n表示换行之后又加了一个空行)</p><p><em>注: 如果一行文本中不包含冒号，则整行文本会被解析成为字段名，其字段值为空。</em></p><h2 id="WebSocket的实现案例"><a href="#WebSocket的实现案例" class="headerlink" title="WebSocket的实现案例"></a>WebSocket的实现案例</h2><h4 id="WebSocket的客户端原生api"><a href="#WebSocket的客户端原生api" class="headerlink" title="WebSocket的客户端原生api"></a>WebSocket的客户端原生api</h4><p><code>var ws = new WebSocket(&#39;ws://localhost:8080&#39;)</code><br>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p><p><code>ws.onopen = function(){}</code><br>用于指定连接成功后的回调函数。</p><p><code>ws.onclose = function(){}</code><br>用于指定连接关闭后的回调函数</p><p><code>ws.onmessage = function(){}</code><br>用于指定收到服务器数据后的回调函数</p><p><code>ws.send(&#39;data&#39;)</code><br>实例对象的send()方法用于向服务器发送数据</p><p><code>socket.onerror = function(){}</code><br>用于指定报错时的回调函数</p><h4 id="服务端的WebSocket如何实现"><a href="#服务端的WebSocket如何实现" class="headerlink" title="服务端的WebSocket如何实现"></a>服务端的WebSocket如何实现</h4><p>npm上有很多包对websocket做了实现比如 <a href="https://link.juejin.im?target=http%3A%2F%2Fsocket.io" target="_blank" rel="noopener">socket.io</a>、WebSocket-Node、ws、还有很多，本文只对 socket.io以及ws 做简单的分析，细节还请查看官方文档。</p><h4 id="socket-io和ws有什么不同"><a href="#socket-io和ws有什么不同" class="headerlink" title="socket.io和ws有什么不同"></a>socket.io和ws有什么不同</h4><p><code>Socket.io：</code> Socket.io是一个WebSocket库，包括了客户端的js和服务器端的nodejs，它会自动根据浏览器从WebSocket、AJAX长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用（不支持WebSocket的情况会降级到AJAX轮询），非常方便和人性化，兼容性非常好，支持的浏览器最低达IE5.5。屏蔽了细节差异和兼容性问题，实现了跨浏览器/跨设备进行双向数据通信。</p><p><code>ws：</code> 不像 <a href="https://link.juejin.im?target=http%3A%2F%2Fsocket.io" target="_blank" rel="noopener">socket.io</a> 模块， ws 是一个单纯的websocket模块，不提供向上兼容，不需要在客户端挂额外的js文件。在客户端不需要使用二次封装的api使用浏览器的原生Websocket API即可通信。</p><h4 id="基于socket-io实现WebSocket双向通信"><a href="#基于socket-io实现WebSocket双向通信" class="headerlink" title="基于socket.io实现WebSocket双向通信"></a>基于socket.io实现WebSocket双向通信</h4><p>客户端代码</p><pre><code>&lt;button id=&quot;closeSocket&quot;&gt;断开连接&lt;/button&gt;&lt;button id=&quot;openSocket&quot;&gt;恢复连接&lt;/button&gt;&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;// 建立连接 默认指向 window.locationlet socket = io(&apos;http://127.0.0.1:6788&apos;)openSocket.onclick = () =&gt; {  socket.open()  // 手动打开socket 也可以重新连接}closeSocket.onclick = () =&gt; {  socket.close() // 手动关闭客户端对服务器的链接}socket.on(&apos;connect&apos;, () =&gt; { // 连接成功  // socket.id是唯一标识，在客户端连接到服务器后被设置。  console.log(socket.id)})socket.on(&apos;connect_error&apos;, (error) =&gt; {  console.log(&apos;连接错误&apos;)})socket.on(&apos;disconnect&apos;, (timeout) =&gt; {  console.log(&apos;断开连接&apos;)})socket.on(&apos;reconnect&apos;, (timeout) =&gt; {  console.log(&apos;成功重连&apos;)})socket.on(&apos;reconnecting&apos;, (timeout) =&gt; {  console.log(&apos;开始重连&apos;)})socket.on(&apos;reconnect_error&apos;, (timeout) =&gt; {  console.log(&apos;重连错误&apos;)})// 监听服务端返回事件socket.on(&apos;serverEve&apos;, (data) =&gt; {  console.log(&apos;serverEve&apos;, data)})let num = 0setInterval(() =&gt; {  // 向服务端发送事件  socket.emit(&apos;feEve&apos;, ++num)}, 1000)</code></pre><p>服务端代码（node.js）</p><pre><code>const app = require(&apos;express&apos;)()const server = require(&apos;http&apos;).Server(app)const io = require(&apos;socket.io&apos;)(server, {})// 启动一个简易的本地server返回index.htmlapp.get(&apos;/&apos;, (req, res) =&gt; {  res.sendfile(__dirname + &apos;/index.html&apos;)})// 监听 6788server.listen(6788, () =&gt; {  console.log(`server runing on port 6788 ...`)})// 服务器监听所有客户端 并返回该新连接对象// 每个客户端socket连接时都会触发 connection 事件let num = 0io.on(&apos;connection&apos;, (socket) =&gt; {  socket.on(&apos;disconnect&apos;, (reason) =&gt; {    console.log(&apos;断开连接&apos;)  })  socket.on(&apos;error&apos;, (error) =&gt; {    console.log(&apos;发生错误&apos;)  })  socket.on(&apos;disconnecting&apos;, (reason) =&gt; {    console.log(&apos;客户端断开连接但尚未离开&apos;)  })  console.log(socket.id) // 获取当前连接进入的客户端的id  io.clients((error, ids) =&gt; {    console.log(ids)  // 获取已连接的全部客户机的ID  })  // 监听客户端发送的事件  socket.on(&apos;feEve&apos;, (data) =&gt; {    console.log(&apos;feEve&apos;, data)  })  // 给客户端发送事件  setInterval(() =&gt; {    socket.emit(&apos;serverEve&apos;, ++num)  }, 1000)})/*  io.close()  // 关闭所有连接*/</code></pre><p><code>const io = require(&#39;socket.io&#39;)(server, {})</code> 第二个参数是配置项，可以传入如下参数：</p><ul><li>path: ‘/socket.io’   捕获路径的名称</li><li>serveClient: false   是否提供客户端文件</li><li>pingInterval: 10000  发送消息的时间间隔</li><li>pingTimeout: 5000    在该时间下没有数据传输连接断开</li><li>origins: ‘*’         允许跨域</li><li>…</li></ul><p>上面基于socket.io的实现中 <code>express</code> 做为socket通信的依赖服务基础<br><code>socket.io</code> 作为socket通信模块，实现了双向数据传输。最后，需要注意的是，在服务器端 <code>emit</code> 区分以下三种情况：</p><ul><li><code>socket.emit()</code> ：向建立该连接的客户端发送</li><li><code>socket.broadcast.emit()</code> ：向除去建立该连接的客户端的所有客户端发送</li><li><code>io.sockets.emit()</code> ：向所有客户端发送 等同于上面两个的和</li><li><code>io.to(id).emit()</code> :  向指定id的客户端发送事件</li></ul><h4 id="基于ws实现WebSocket双向通信"><a href="#基于ws实现WebSocket双向通信" class="headerlink" title="基于ws实现WebSocket双向通信"></a>基于ws实现WebSocket双向通信</h4><p>客户端代码</p><pre><code>let num = 0let ws = new WebSocket(&apos;ws://127.0.0.1:6788&apos;)ws.onopen = (evt) =&gt; {  console.log(&apos;连接成功&apos;)  setInterval(() =&gt; {    ws.send(++ num)  // 向服务器发送数据  }, 1000)}ws.onmessage = (evt) =&gt; {  console.log(&apos;收到服务端数据&apos;, evt.data)}ws.onclose = (evt) =&gt; {  console.log(&apos;关闭&apos;)}ws.onerror = (evt) =&gt; {  console.log(&apos;错误&apos;)}closeSocket.onclick = () =&gt; {  ws.close()  // 断开连接}</code></pre><p>服务端代码（node.js）</p><pre><code>const fs = require(&apos;fs&apos;)const express = require(&apos;express&apos;)const app = express()// 启动一个简易的本地server返回index.htmlconst httpServer = app.get(&apos;/&apos;, (req, res) =&gt; {  res.writeHead(200)  fs.createReadStream(&apos;./index.html&apos;).pipe(res)}).listen(6788, () =&gt; {  console.log(`server runing on port 6788 ...`)})// wsconst WebSocketServer = require(&apos;ws&apos;).Serverconst wssOptions = {    server: httpServer,  // port: 6789,  // path: &apos;/test&apos;}const wss = new WebSocketServer(wssOptions, () =&gt; {  console.log(`server runing on port ws 6789 ...`)})let num = 1wss.on(&apos;connection&apos;, (wsocket) =&gt; {  console.log(&apos;连接成功&apos;)  wsocket.on(&apos;message&apos;, (message) =&gt; {    console.log(&apos;收到消息&apos;, message)  })  wsocket.on(&apos;close&apos;, (message) =&gt; {    console.log(&apos;断开了&apos;)  })  wsocket.on(&apos;error&apos;, (message) =&gt; {    console.log(&apos;发生错误&apos;)  })  wsocket.on(&apos;open&apos;, (message) =&gt; {    console.log(&apos;建立连接&apos;)  })  setInterval(() =&gt; {    wsocket.send( ++num )  }, 1000)})</code></pre><h3 id="上面代码中在-new-WebSocketServer-的时候传入了-server-httpServer-目的是统一端口，虽然-WebSocketServer-可以使用别的端口，但是统一端口还是更优的选择，其实express并没有直接占用6788端口而是express调用了内置http模块创建了http-Server监听了6788。express只是把响应函数注册到该http-Server里面。类似的，WebSocketServer也可以把自己的响应函数注册到-http-Server中，这样同一个端口，根据协议，可以分别由express和ws处理。我们拿到express创建的http-Server的引用，再配置到-wssOptions-server-里让WebSocketServer根据我们传入的http服务来启动，就实现了统一端口的目的。"><a href="#上面代码中在-new-WebSocketServer-的时候传入了-server-httpServer-目的是统一端口，虽然-WebSocketServer-可以使用别的端口，但是统一端口还是更优的选择，其实express并没有直接占用6788端口而是express调用了内置http模块创建了http-Server监听了6788。express只是把响应函数注册到该http-Server里面。类似的，WebSocketServer也可以把自己的响应函数注册到-http-Server中，这样同一个端口，根据协议，可以分别由express和ws处理。我们拿到express创建的http-Server的引用，再配置到-wssOptions-server-里让WebSocketServer根据我们传入的http服务来启动，就实现了统一端口的目的。" class="headerlink" title="上面代码中在 new WebSocketServer 的时候传入了 server: httpServer 目的是统一端口，虽然 WebSocketServer 可以使用别的端口，但是统一端口还是更优的选择，其实express并没有直接占用6788端口而是express调用了内置http模块创建了http.Server监听了6788。express只是把响应函数注册到该http.Server里面。类似的，WebSocketServer也可以把自己的响应函数注册到 http.Server中，这样同一个端口，根据协议，可以分别由express和ws处理。我们拿到express创建的http.Server的引用，再配置到 wssOptions.server 里让WebSocketServer根据我们传入的http服务来启动，就实现了统一端口的目的。"></a>上面代码中在 <code>new WebSocketServer</code> 的时候传入了 <code>server: httpServer</code> 目的是统一端口，虽然 WebSocketServer 可以使用别的端口，但是统一端口还是更优的选择，其实express并没有直接占用6788端口而是express调用了内置http模块创建了http.Server监听了6788。express只是把响应函数注册到该http.Server里面。类似的，WebSocketServer也可以把自己的响应函数注册到 http.Server中，这样同一个端口，根据协议，可以分别由express和ws处理。我们拿到express创建的http.Server的引用，再配置到 wssOptions.server 里让WebSocketServer根据我们传入的http服务来启动，就实现了统一端口的目的。</h3><h3 id="要始终注意，浏览器创建WebSocket时发送的仍然是标准的HTTP请求。无论是WebSocket请求，还是普通HTTP请求，都会被http-Server处理。具体的处理方式则是由express和WebSocketServer注入的回调函数实现的。WebSocketServer会首先判断请求是不是WS请求，如果是，它将处理该请求，如果不是，该请求仍由express处理。所以，WS请求会直接由WebSocketServer处理，它根本不会经过express。"><a href="#要始终注意，浏览器创建WebSocket时发送的仍然是标准的HTTP请求。无论是WebSocket请求，还是普通HTTP请求，都会被http-Server处理。具体的处理方式则是由express和WebSocketServer注入的回调函数实现的。WebSocketServer会首先判断请求是不是WS请求，如果是，它将处理该请求，如果不是，该请求仍由express处理。所以，WS请求会直接由WebSocketServer处理，它根本不会经过express。" class="headerlink" title="要始终注意，浏览器创建WebSocket时发送的仍然是标准的HTTP请求。无论是WebSocket请求，还是普通HTTP请求，都会被http.Server处理。具体的处理方式则是由express和WebSocketServer注入的回调函数实现的。WebSocketServer会首先判断请求是不是WS请求，如果是，它将处理该请求，如果不是，该请求仍由express处理。所以，WS请求会直接由WebSocketServer处理，它根本不会经过express。"></a>要始终注意，浏览器创建WebSocket时发送的仍然是标准的HTTP请求。无论是WebSocket请求，还是普通HTTP请求，都会被http.Server处理。具体的处理方式则是由express和WebSocketServer注入的回调函数实现的。WebSocketServer会首先判断请求是不是WS请求，如果是，它将处理该请求，如果不是，该请求仍由express处理。所以，WS请求会直接由WebSocketServer处理，它根本不会经过express。</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Server-Sent Events </tag>
            
            <tag> 服务器推送 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue手势库</title>
      <link href="/2018/09/03/Vue%E6%89%8B%E5%8A%BF%E5%BA%93/"/>
      <url>/2018/09/03/Vue%E6%89%8B%E5%8A%BF%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">function vueTouch(el, binding, type) &#123;</span><br><span class="line">var _this = this;</span><br><span class="line">this.obj = el;</span><br><span class="line">this.binding = binding;</span><br><span class="line">this.touchType = type;</span><br><span class="line">this.vueTouches = &#123;</span><br><span class="line">x: 0,</span><br><span class="line">y: 0</span><br><span class="line">&#125;;</span><br><span class="line">this.vueMoves = true;</span><br><span class="line">this.vueLeave = true;</span><br><span class="line">this.longTouch = true;</span><br><span class="line"></span><br><span class="line">this.vueCallBack = typeof(binding.value) == &quot;object&quot; ? binding.value.fn : binding.value;</span><br><span class="line"></span><br><span class="line">this.obj.addEventListener(&quot;touchstart&quot;, function(e) &#123;</span><br><span class="line">_this.start(e);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">this.obj.addEventListener(&quot;touchmove&quot;, function(e) &#123;</span><br><span class="line">_this.move(e);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">this.obj.addEventListener(&quot;touchend&quot;, function(e) &#123;</span><br><span class="line">_this.end(e);</span><br><span class="line">&#125;, false);</span><br><span class="line">&#125;;</span><br><span class="line">vueTouch.prototype = &#123;</span><br><span class="line">start(e) &#123;</span><br><span class="line">this.vueMoves = true;</span><br><span class="line">this.vueLeave = true;</span><br><span class="line">this.longTouch = true;</span><br><span class="line">this.vueTouches = &#123;</span><br><span class="line">x: e.changedTouches[0].pageX,</span><br><span class="line">y: e.changedTouches[0].pageY</span><br><span class="line">&#125;;</span><br><span class="line">this.time = setTimeout(function() &#123;</span><br><span class="line">if(this.vueLeave &amp;&amp; this.vueMoves) &#123;</span><br><span class="line">this.touchType == &quot;longtap&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">this.longTouch = false;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;.bind(this), 1000);</span><br><span class="line">&#125;,</span><br><span class="line">end(e) &#123;</span><br><span class="line">var disX = e.changedTouches[0].pageX - this.vueTouches.x;</span><br><span class="line">var disY = e.changedTouches[0].pageY - this.vueTouches.y;</span><br><span class="line">clearTimeout(this.time);</span><br><span class="line">if(Math.abs(disX) &gt; 10 || Math.abs(disY) &gt; 100) &#123;</span><br><span class="line">this.touchType == &quot;swipe&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">if(Math.abs(disX) &gt; Math.abs(disY)) &#123;</span><br><span class="line">if(disX &gt; 10) &#123;</span><br><span class="line">this.touchType == &quot;swiperight&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">&#125;;</span><br><span class="line">if(disX &lt; -10) &#123;</span><br><span class="line">this.touchType == &quot;swipeleft&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">&#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(disY &gt; 10) &#123;</span><br><span class="line">this.touchType == &quot;swipedown&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">&#125;;</span><br><span class="line">if(disY &lt; -10) &#123;</span><br><span class="line">this.touchType == &quot;swipeup&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if(this.longTouch &amp;&amp; this.vueMoves) &#123;</span><br><span class="line">this.touchType == &quot;tap&quot; &amp;&amp; this.vueCallBack(this.binding.value, e);</span><br><span class="line">this.vueLeave = false</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;,</span><br><span class="line">move(e) &#123;</span><br><span class="line">this.vueMoves = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vue.directive(&quot;tap&quot;, &#123;</span><br><span class="line">bind: function(el, binding) &#123;</span><br><span class="line">new vueTouch(el, binding, &quot;tap&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swipe&quot;, &#123;</span><br><span class="line">bind: function(el, binding) &#123;</span><br><span class="line">new vueTouch(el, binding, &quot;swipe&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swipeleft&quot;, &#123;</span><br><span class="line">bind: function(el, binding) &#123;</span><br><span class="line">new vueTouch(el, binding, &quot;swipeleft&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swiperight&quot;, &#123;</span><br><span class="line">bind: function(el, binding) &#123;</span><br><span class="line">new vueTouch(el, binding, &quot;swiperight&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swipedown&quot;, &#123;</span><br><span class="line">bind: function(el, binding) &#123;</span><br><span class="line">new vueTouch(el, binding, &quot;swipedown&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;swipeup&quot;, &#123;</span><br><span class="line">bind: function(el, binding) &#123;</span><br><span class="line">new vueTouch(el, binding, &quot;swipeup&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">Vue.directive(&quot;longtap&quot;, &#123;</span><br><span class="line">bind: function(el, binding) &#123;</span><br><span class="line">new vueTouch(el, binding, &quot;longtap&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html id=&quot;html&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">.box &#123;</span><br><span class="line">width: 250px;</span><br><span class="line">height: 250px;</span><br><span class="line">background-color: red;</span><br><span class="line">color: #FFFFFF;</span><br><span class="line">text-align: center;</span><br><span class="line">line-height: 250px;</span><br><span class="line">font-size: 30px;</span><br><span class="line">position: absolute;</span><br><span class="line">margin: auto;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue-touch.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;app&quot; class=&quot;box&quot; v-tap=&quot;&#123;fn:vuetap,name:&apos;点击&apos;&#125;&quot; v-longtap=&quot;&#123;fn:vuetap,name:&apos;长按&apos;&#125;&quot; v-swipeleft=&quot;&#123;fn:vuetap,name:&apos;左滑&apos;&#125;&quot; v-swiperight=&quot;&#123;fn:vuetap,name:&apos;右滑&apos;&#125;&quot; v-swipeup=&quot;&#123;fn:vuetap,name:&apos;上滑&apos;&#125;&quot; v-swipedown=&quot;&#123;fn:vuetap,name:&apos;下滑&apos;&#125;&quot;&gt;</span><br><span class="line">&#123;&#123; name &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">vuetouch为函数名，如没有参数，可直接写函数名,比如：v-tap=&quot;vuetap&quot;</span><br><span class="line">如果有参数以对象形式传，fn 为函数名</span><br><span class="line">--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">kim = new Vue(&#123;</span><br><span class="line">el: &quot;#app&quot;,</span><br><span class="line">data: &#123;</span><br><span class="line">name: &quot;开始&quot;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">vuetap: function(s, e) &#123;</span><br><span class="line">console.log(e)</span><br><span class="line">this.name = s.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解 HTTPS</title>
      <link href="/2018/09/02/%E7%90%86%E8%A7%A3-HTTPS/"/>
      <url>/2018/09/02/%E7%90%86%E8%A7%A3-HTTPS/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><h4 id="关于TLS-SSL协议"><a href="#关于TLS-SSL协议" class="headerlink" title="关于TLS/SSL协议"></a><a href="https://juejin.im/post/5c1a02a06fb9a049db7313c9" target="_blank" rel="noopener">关于TLS/SSL协议</a></h4><h4 id="面试官问：你了解HTTP2-0吗？"><a href="#面试官问：你了解HTTP2-0吗？" class="headerlink" title="面试官问：你了解HTTP2.0吗？"></a><a href="https://juejin.im/post/5c0ce870f265da61171c8c66" target="_blank" rel="noopener">面试官问：你了解HTTP2.0吗？</a></h4><blockquote><p>SSL，是利用数据加密技术，用以保障在Internet上数据传输安全的协议，ssl证书就是遵守SSL协议的一种数字证书，验证网站主体身份和数据传输加密。<br>TLS，安全传输层协议，用于在两个通信应用程序之间提供保密性和数据完整性。TLS加密于TLS加密区别在于，加密算法不同。现在还是SSL加密比较多，GDCA的SSL证书比较常见！</p></blockquote><p><img src="/2018/09/02/理解-HTTPS/1.webp" alt=""><br>http2 的前身是由 google 领导开发的 SPDY，后来 google 把整个成果交给 IETF，IETF 把 SPDY 标准化之后变成 http2。google 也很大方的废弃掉 SPDY，转向支持 http2。http2 是完全兼容 http/1.x 的，在此基础上添加了 4 个主要新特性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二进制分帧</span><br><span class="line">头部压缩</span><br><span class="line">服务端推送</span><br><span class="line">多路复用</span><br><span class="line">优化手段</span><br></pre></td></tr></table></figure></p><p><a href="https://juejin.im/post/5aaccf8f51882555784dbabc" target="_blank" rel="noopener">http2 简介</a></p><h3 id="存在即合理"><a href="#存在即合理" class="headerlink" title="存在即合理"></a>存在即合理</h3><p><font color="#ff0000">http是非常常见的应用层协议，是超文本传输协议的简称，其传输的内容都是明文的。</font> 在这个混乱的世界，明文传输信息想想就可怕，网络“小混混”的手段远比我们这些凡人高明得多，他们有一万种方式劫持，篡改我们的数据。对于一个网站或者服务，如果你给你的用户两个选择：</p><ul><li>通讯数据明文传输，速度快；</li><li>通讯数据加密传输，但是速度可能会稍微慢一点.<br>我想，只要脑袋没有长歪的用户都宁愿牺牲一点速度去换取数据传输的安全。</li></ul><p>这样，https的存在就具备了合理性，https中的s表示SSL或者TLS，就是在原http的基础上加上一层用于<font color="#ff0000">数据加密、解密、身份认证</font>的安全层。</p><h3 id="HTTP协议的缺点"><a href="#HTTP协议的缺点" class="headerlink" title="HTTP协议的缺点"></a>HTTP协议的缺点</h3><ul><li>通信使用明文；</li><li>不验证通信方的身份；</li><li>无法验证报文的完整性；</li></ul><p><strong>通信使用明文:</strong> 通信使用明文意味着安全性大大降低，当通信过程被窃听后，无需花费额外的投入就可看到传输的数据。例如使用抓包工具，无需任何配置就可查看任何使用HTTP协议的通信数据；<br><strong>不验证通信方身份 :</strong>不验证通信方的身份，将导致通信过程被窃听后，可能会遭遇伪装，例如使用抓包工具抓取数据后，就可按照数据包的格式构造HTTP请求；<br><strong>无法验证报文的完整性:</strong>不验证报文的完整性，数据在传输过程中就可能被篡改，本来想看喜洋洋呢，结果数据在传输过程中被换成了光头强。</p><p>为解决了HTTP的以上问题，HTTPS协议就诞生了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Https = Http + 加密 + 认证 + 完整性验证</span><br><span class="line">        ||</span><br><span class="line">Https = Http + SSL</span><br><span class="line">        ||</span><br><span class="line">HTTPS=数据加密+网站认证+完整性验证+HTTP</span><br></pre></td></tr></table></figure></p><h3 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h3><ul><li>HTTP 是明文传输，HTTPS 通过 SSL\TLS 进行了加密</li><li>HTTP 的端口号是 80，HTTPS 是 443</li><li>HTTPS 需要到 CA 申请证书，一般免费证书很少，需要交费</li><li>HTTPS 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li></ul><h3 id="HTTPS主要缺点："><a href="#HTTPS主要缺点：" class="headerlink" title="HTTPS主要缺点："></a>HTTPS主要缺点：</h3><ul><li>网络耗时（比HTTP多了交互次数）。</li><li>加解密耗时。</li><li>比HTTP慢几百毫秒以上，页面加载时间增加了50%，增加10%到20%的耗电</li></ul><h3 id="HTTPS工作流程："><a href="#HTTPS工作流程：" class="headerlink" title="HTTPS工作流程："></a>HTTPS工作流程：</h3><p><img src="/2018/09/02/理解-HTTPS/20170113193549689.png" alt=""><br>1.客户端向服务器发送请求，并告诉服务器支持的算法列表；<br>2.服务器选择一种算法，并将自己的证书返回给客户端，证书包含服务器域名和公钥等信息；<br>3.客户端得到证书后进行验证，验证通过的话就生成一个随机值，并用证书中的公钥进行加密<br>4.传递加密信息，目的就是让服务器得到这个随机值，以后客户端与服务器的通信就可以通过这个随机值来进行加密解密；<br>5.服务器用自己的私钥解密客户端传过来的随机值，然后把内容进行对称加密，即将信息和私钥通过加密算法混在一起，这样除非知道私钥，不然无法获取到内容，而客户端与服务器都知道这个私钥，所以只要加密算法够强大，私钥够复杂，数据就很安全了；<br>6.将加密后的信息发给客户端，客户端还原信息<br>7.客户端用之前生成的私钥解密服务器发过来的信息，便获取到了解密后的内容；</p><p>那么加密的信息通道又加密了哪些信息呢？</p><p>签发证书的 CA 中心会发布一种权威性的电子文档——数字证书，它可以通过加密技术（对称加密与非对称加密）对我们在网上传输的信息进行加密，比如我在 Pornhub 上输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：cbssfaw</span><br><span class="line">密码：123djaosid</span><br></pre></td></tr></table></figure></p><p>可是这个数据被黑客拦截盗窃了，那么加密后，黑客得到的数据可能就是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">账号：çµø…≤¥ƒ∂ø†®∂˙∆¬</span><br><span class="line">密码：∆ø¥§®†ƒ©®†©˚¬</span><br></pre></td></tr></table></figure></p><hr><p>想要理解 HTTPS 加密。需要理解几个概念：</p><ul><li>对称加密算法</li><li>非对称加密算法</li><li>CA(Certificate Authority)</li><li>数字证书</li><li>摘要算法</li></ul><blockquote><p>常用的加密方式分为两种：</p></blockquote><ul><li>对称加密：<strong> <font color="#dd0000">加密和解密使用的是相同的密钥。</font></strong></li><li>非对称加密：<strong> <font color="#dd0000">加密和解密使用的不是相同的密钥，而是一对密钥对，分别称为公钥和私钥。 </font></strong></li></ul><blockquote><p>HTTPS 用了哪种加密方法？</p></blockquote><p>在 HTTPS 中，对称加密和非对称加密都用到了。非对称加密可以在不安全的信道上传递秘密内容，但是由于通常使用的非对称加密方法相较于对称加密算法慢很多，因此在 HTTPS 中仅使用非对称加密算法交换对称密钥，交换密钥之后的通信内容均使用对称加密算法加密和解密，这样既可以保证密钥的安全也可以保证内容的加解密速度，这对于移动端设备来说至关重要。</p><p>现在的问题是，如何在实现 HTTP 协议的情况下，对传输的信息进行加密解密？最开始使用到的是最简单的对称加密算法。 </p><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密算法非常简单，只要加密方和解密方都拥有同一密钥（可为128，192，256 bit 大小的密钥，密钥越长，加密解密时间越长，解密难度也越高），即可完成加密解密过程，且假设无法强制对加密过的明文进行解密。</p><p><strong> 问题：对于需要传递加密信息的双方而言，对称加密算法用于加密解密没有什么问题，但是密钥的传输就成了另外一个问题。因为密钥也需要传输才能使双方通信，密钥明文传输出去，被人轻易截取，就能利用密钥破解加密的密文。 </strong></p><p>所以引出了下面的非对称加密算法来传输密钥。</p><h3 id="公开密钥加密-Public-Key-Cryptography-的非对称加密算法"><a href="#公开密钥加密-Public-Key-Cryptography-的非对称加密算法" class="headerlink" title="公开密钥加密(Public-Key Cryptography)的非对称加密算法"></a>公开密钥加密(Public-Key Cryptography)的非对称加密算法</h3><p>对于使用最广泛的非对称加密算法——RSA，RSA 算法基于一个简单的数论理论：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p><p>RSA 算法得出了下面的规则：通讯两方 A, B 分别都有各自的一套公钥和私钥。同一套公钥私钥当中，公钥的加密需要私钥才能解密，私钥的加密需要公钥才能解密。</p><p>假设 A 把自己的公钥公开出去，B 得到了 A 的公钥，然后 B 用 A 的公钥加密了明文，传给 A，A 用私钥解密，即可获得明文。所以，过程中公开的信息任何第三方得到都不可以破解 A 和 B 要传递的信息。有了这个算法之后，对称加密算法所用到的密钥传输安全性就没问题了。但是因为加密解密过程时间比较长，非对称加密算法不适合应用于数据量大的信息传递，只适用于密钥的传递。（这个问题解释了对于数字签名的摘要算法的必要性）</p><h4 id="问题：虽然-RSA-算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是中间人攻击。"><a href="#问题：虽然-RSA-算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是中间人攻击。" class="headerlink" title="问题：虽然 RSA 算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是中间人攻击。"></a>问题：虽然 RSA 算法也没有什么问题，但是却有人想出更绝的方法破解加解密的过程。这个方法就是<strong>中间人攻击</strong>。</h4><p>在用非对称加密算法传递密钥的过程中，因为公钥都是公开的，并没有任何东西可以认证这个公钥是 A 的还是 B 的。现在出现了中间人 M，M 采取某种手段在 A 和 B 的通讯过程成为中间人。在 B 想要得到 A 的公钥的时候，M 向 B 谎称自己的这个公钥是 A 的公钥，B 拿到用 M 的公钥加密信息后，传出 M 手中，然后 M 拿加密过的信息，然后用自己的私钥把这个信息解密，得到明文。既然已经知道了明文，还是用 A 的公钥加密这个信息，继续给 A，这样 A 还是以为这个信息是安全的，继续用私钥解开。而在这个过程中，M 既获得了信息，又没有让 A，B 双方知道。至于这个 M 是怎么欺骗 A，B 的，又是另外一个安全的问题。总之，假如 M 只要让 B 相信这个公钥是 A 的，就可以作中间人攻击。</p><p>假如上面的 A 是服务器，B 是用户，那么中间人就很容易获取和修改 A，B 需要传输的信息。所以为了让 M 不再得逞，出现一个具有公信力的第三方——CA。</p><h3 id="CA-Certificate-Authority-第三方认证机构"><a href="#CA-Certificate-Authority-第三方认证机构" class="headerlink" title="CA(Certificate Authority) 第三方认证机构"></a>CA(Certificate Authority) 第三方认证机构</h3><p>简单来说，CA 要做的就是，让 B 相信拿到的 A 的公钥真正属于 A，而不是其他中间人 M 伪造。</p><p>而在 CA 在做这件事的过程中如何才能让 B 认证这个公钥是 A 的呢？</p><p>这里需要另外一个概念：数字证书。</p><p>普通证书产生的过程就是：将个人提交的信息进行第三方具有权威性部门的认证，然后第三方权威部门确认个人信息<strong>合法无误</strong>后在自己的系统中登记，再把认证证书盖章签名给到个人手上，然后个人就可以用证书从事各类证明活动。现实世界中的做法是在个人提交的信息上盖章，例如4，6级的证书认证。假设你的成绩申请无误而合法，教育局就会将你的成绩记录，然后给你一张盖过章的证书。</p><p>数字证书同理。不过，与现实不一样，在互联网上完成一个完整的验证过程，需要兼顾到很多过程中的纰漏。</p><p>例如：</p><h4 id="问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？"><a href="#问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？" class="headerlink" title="问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？"></a>问题：证书上的章是一个不可信任的机构的，该如何认证哪些机构才是可信任机构？</h4><p>现实中就是向政府部门认证哪些是登记过的可信任的部门，像4，6级证书颁发的部门——全国大学英语四六级考试委员会，是全国的教育局的下级和内部部门，是认证过的。而在互联网中，就需要顶级的最具有公信力的 CA，这个 CA 颁发的证书是最受信任的，这个就是<strong>根证书</strong>。为了不让所有鸡蛋都放在一个篮子里，其他的 CA 机构可以向上一级的 CA 机构申请成为中间 CA，获取自己的<strong>中间证书</strong>，最终个人像 A 向某一个中间 CA 申请的证书就是最终的<strong>终端普通数字证书</strong>。这个过程的签发关系就是<strong>证书链</strong>。当 B 得到 A 的数字证书之后，会在证书的信息中找到 A 申请的 CA，而这个 CA 则会根据自己中间证书找到的自己申请的 CA，就这样沿着证书链找证书，假如某个中间证书或者根证书在本机中安装有，则认证的时候会将 A 的证书设置为可被信任的。</p><p>如何识别可信任机构的这个问题就解决了。</p><h4 id="问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？"><a href="#问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？" class="headerlink" title="问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？"></a>问题：可以轻易做到用与政府同样的章在证书上盖章伪造，该如何认证这个证书不是个人盖章签名伪造的？</h4><p>现实中可以在这个已经被认证的第三方机构系统中查询，像4，6级，可以到教育局的网上公开系统中查询。而在互联网中，则需要一个类似的查询验证过程——数字签名。为了对这个证书的验证，确保这个签名是来自可信任的 CA，而不是其他不可信的 CA。CA 在给 A 的数字证书中有一个数字签名。该签名是 CA 用自己的私钥对 A 的个人信息进行非对称加密得到的加密信息。当 B 得到 A 提供的数字证书，会拿到其中的数字签名和 A 的个人信息，然后用 CA 的公钥对这个数字签名进行非对称解密，得出的信息假如和 A 的数字证书中 A 的个人信息一样的话，就相信这个数字证书确实是 CA 认证过的。</p><p>如何认证这个签名是不是伪造的这个问题也解决了。但是这个问题又引出了另外一个问题：数字证书中 A 的个人信息数据比较大，而非对成加密算法的加密解密速度非常慢，使得认证过程中对个人信息的非对称加密解密非常耗占时间。所以需要用到另外一种算法来加快这个验证过程，这个算法就是摘要算法。（一直很疑惑为什么需要到摘要算法，总算找到了一个原因）</p><p>摘要算法可以将任意大小的原文消息加密并摘要成固定长度的简短密文。对于不同的原文消息，用同一种摘要算法，都可以得到不同但是固定长度的密文，而相同的原文消息，用同一种摘要算法，则可以得到相同固定长度的密文。这就解决了数字签名过程中，对数据大的个人信息文件的非对称加密解密的时间慢的问题。CA 用 A 个人信息进行摘要算法的处理，然后继续用私钥加密，作为数字证书的数字签名给到 A。B 拿到 A 提供的数字签名和 A 的个人信息，然后用 CA 的公钥解密 A 的数字签名，得到 A 个人信息的摘要。再用同一种摘要算法对 A 的个人信息进行处理，得到 A 个人信息的摘要，再与解密得到的 A 个人信息摘要对比，就可以确认改数字签名和个人信息是匹配的。 </p><p>到这一步，中间人攻击已经很难可以发生了，假设 M 想要在 A 和 B 之间充当中间人，有三种手段：</p><ul><li>需要从 A 服务器中直接获取域名数字证书；</li><li>得到 A 的域名管理，向 CA 申请证书</li><li>自己签发证书，然后要求 B 安装自己的证书。</li></ul><p>对于第一第二个问题的防范，在服务器端，只要要保护好私钥和服务器和域名的安全，就不会出现大问题。</p><p>对于第三个问题，在客户端，有一个很好的例子：12306。12306 的证书就是中铁局自己搞的认证机构颁发的。当你浏览 12306 的时候，虽然请求是带 HTTPS，但是浏览器检查的时候发现这个中铁局的认证机构没有在证书链当中，会提示“可能会被攻击”，当然 12306 会要求你直接安装他们的证书。这就要求你自己的明察秋毫了，你是选择相信 ZF 的证书，然后可能以后 ZF 的某些网站可能会在中铁局的认证机构认证证书，然后假装是 HTTPS，并且可能会伪装窃取你的个人信息。所以在客户端，安装证书需要谨慎，不要随意安装不信任的证书。</p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP三种缓存方式</title>
      <link href="/2018/09/01/HTTP%E4%B8%89%E7%A7%8D%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/09/01/HTTP%E4%B8%89%E7%A7%8D%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>依然在学习node的艰辛过程中，最近学习了http相关的知识，学到了东西当然第一时间就来和大家分享分享，今天呢就教大家来看看利用node中的http模块去实现不同的缓存策略！！！</p><p>我们都知道，对于我们前端开发来说，缓存是一个十分重要的东西，即希望用户不能每次请求过来都要重复下载我们的页面内容，希望为用户节省流量，并且能提高我们页面的浏览流畅度，但是同时当我们修改了一个bug后，又希望线上能够及时更新，这时候就要求爷爷告奶奶让运维小哥哥帮我们刷新一下缓存了，那么有没有一些比较好的缓存策略可以针对我们修改bug又能不麻烦运维及时更新呢，今天我们就利用node来看一下后端中的缓存策略是如何设置的。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>通常我们对于强制缓存的设置是服务端告诉客户端你刚刚已经请求过一次了，我们约定好十分钟内你再过来请求都直接读取缓存吧，意思也就是当客户端在十分钟内多次请求的话只有第一次会下载页面内容，其他的请求都是直接走缓存，不管我们页面在这期间有没有变化都不会影响客户端读取缓存。<br>那我们来看一下代码的实现</p><pre><code>let http = require(&apos;http&apos;);let path = require(&apos;path&apos;);let fs = require(&apos;fs&apos;);let url = require(&apos;url&apos;);// 创建一个服务let server = http.createServer();// 监听请求server.on(&apos;request&apos;,(req,res)=&gt;{    // 获取到请求的路径    let {pathname,query} = url.parse(req.url,true);    // 将路径拼接成服务器上对应得文件路径    let readPath = path.join(__dirname, &apos;public&apos;,pathname);    console.log(readPath)    try {        // 获取路径状态        let statObj = fs.statSync(readPath);        // 服务端设置响应头 Cache-Control 也就是缓存多久以秒为单位        res.setHeader(&apos;Cache-Control&apos;,&apos;max-age=10&apos;);        // 服务器设置响应头Expires 过期时间 获取当前时间加上刚刚设置的缓存秒数        res.setHeader(&apos;Expires&apos;,new Date(Date.now()+10*1000).toGMTString());        //判断如果路径是一件文件夹 就默认查找该文件下的index.html        if(statObj.isDirectory()){            let p = path.join(readPath,&apos;index.html&apos;);            console.log(p);            // 判断是否有index.html 没有就返回404            fs.statSync(p);            // 创建文件可读流 并且pipe到响应res可写流中            fs.createReadStream(p).pipe(res)        }else{            // 如果请求的就是一个文件 那么久直接返回            fs.createReadStream(readPath).pipe(res)        }    } catch (error) {        // 读取不到 返回404         console.log(error)        res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;)        res.statusCode = 404;        res.end(`未发现文件`)    }})// 监听3000端口server.listen(3000)复制代码</code></pre><p><a href="https://camo.githubusercontent.com/3ca59134ca5ee58d2a4c0b139c8c829bc81d1965/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396633646236643965613131323f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3ca59134ca5ee58d2a4c0b139c8c829bc81d1965/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396633646236643965613131323f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></a><br>通过上面代码测试我们会发现当我们在10秒内进行对同一文件的请求，那么我们浏览器就会直接走缓存 通过上图可以看到我们重复请求的时候我们会看到css变成from memory cache，我们也看到我们刚刚的响应头也被设置上了</p><p><a href="https://camo.githubusercontent.com/efed3949630e898e6f5351b5b47d23e536ae6be8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396633663737303637353231353f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/efed3949630e898e6f5351b5b47d23e536ae6be8/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396633663737303637353231353f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></a></p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>上面的强制缓存我们就发现了 就是我们平时改完bug上线要苦苦等待的一个原因了，那么有没有其他的好的缓存处理方法呢，我们设想一下 假如我们能够知道我们文件有没有修改，假如我们修改了服务器就返回最新的内容假如没有修改 就一直默认缓存 ，这样是不是听起来十分的棒！那我们就想如果我们能够知道文件的最后修改时间是不是就可以实现了！</p><h3 id="通过文件最后修改时间来缓存"><a href="#通过文件最后修改时间来缓存" class="headerlink" title="通过文件最后修改时间来缓存"></a>通过文件最后修改时间来缓存</h3><pre><code>let http = require(&apos;http&apos;);let path = require(&apos;path&apos;);let fs = require(&apos;fs&apos;);let url = require(&apos;url&apos;);let server = http.createServer();server.on(&apos;request&apos;,(req,res)=&gt;{    // 获取到请求的路径    let {pathname,query} = url.parse(req.url,true);    // 将路径拼接成服务器上对应得文件路径    let readPath = path.join(__dirname, &apos;public&apos;,pathname);    try {        // 获取路径状态        let statObj = fs.statSync(readPath);        // 为了方便测试 我们告诉客户端不要走强制缓存了        res.setHeader(&apos;Cache-Control&apos;,&apos;no-cache&apos;);        if(statObj.isDirectory()){            let p = path.join(readPath,&apos;index.html&apos;);            let statObj = fs.statSync(p);            // 我们通过获取到文件状态来拿到文件的最后修改时间 也就是ctime 我们把这个时间通过响应头Last-Modified来告诉客户端，客户端再下一次请求的时候会通过请求头If-Modified-Since把这个值带给服务端，我们只要判断这两个值是否相等，假如相等那么也就是说 文件没有被修改那么我们就告诉客户端304 你直接读缓存吧            res.setHeader(&apos;Last-Modified&apos;,statObj.ctime.toGMTString());            if(req.headers[&apos;if-modified-since&apos;] === statObj.ctime.toGMTString()){                res.statusCode = 304;                res.end();                return            }            // 修改了那么我们就直接返回新的内容            fs.createReadStream(p).pipe(res)        }else{            res.setHeader(&apos;Last-Modified&apos;,statObj.ctime.toGMTString());            if(req.headers[&apos;if-modified-since&apos;] === statObj.ctime.toGMTString()){                res.statusCode = 304;                res.end();                return            }            fs.createReadStream(readPath).pipe(res)        }    } catch (error) {        console.log(error)        res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;)        res.statusCode = 404;        res.end(`未发现文件`)    }})server.listen(3000)复制代码</code></pre><p><a href="https://camo.githubusercontent.com/2c5d1c2ea01db5d6f83ffda15dd41afcdfc0ed61/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396634386366343637626232303f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/2c5d1c2ea01db5d6f83ffda15dd41afcdfc0ed61/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396634386366343637626232303f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></a></p><p>我们通过请求可以看到，当我们第一次请求过后，无论怎么刷新请求都是304 直接读取的缓存，假如我们在服务端把这个文件修改了 那么我们就能看到又能请求到最新的内容了，这就是我们通过协商缓存来处理的，我们通过获取到文件状态来拿到文件的最后修改时间 也就是ctime 我们把这个时间通过响应头Last-Modified来告诉客户端，客户端再下一次请求的时候会通过请求头If-Modified-Since把这个值带给服务端，我们只要判断这两个值是否相等，假如相等那么也就是说 文件没有被修改那么我们就告诉客户端304 你直接读缓存吧</p><h3 id="通过文件内容来缓存"><a href="#通过文件内容来缓存" class="headerlink" title="通过文件内容来缓存"></a>通过文件内容来缓存</h3><p>再再再再再假如我们在文件中删除了字符a然后又还原了，那么这时候保存我们的文件的修改时间其实也发生了变化，但是其实我们文件的真正内容并没有发生变化，所以这时候其实客户端继续走缓存也是可以的 ，我们来看看这样的缓存策略如何实现。</p><pre><code>let http = require(&apos;http&apos;);let path = require(&apos;path&apos;);let fs = require(&apos;fs&apos;);let url = require(&apos;url&apos;);let crypto = require(&apos;crypto&apos;);let server = http.createServer();server.on(&apos;request&apos;,(req,res)=&gt;{    // 获取到请求的路径    let {pathname,query} = url.parse(req.url,true);    // 将路径拼接成服务器上对应得文件路径    let readPath = path.join(__dirname, &apos;public&apos;,pathname);    try {        // 获取路径状态        let statObj = fs.statSync(readPath);        // 为了方便测试 我们告诉客户端不要走强制缓存了        res.setHeader(&apos;Cache-Control&apos;,&apos;no-cache&apos;);        if(statObj.isDirectory()){            let p = path.join(readPath,&apos;index.html&apos;);            let statObj = fs.statSync(p);            // 我们通过流把文件读取出来 然后对读取问来的内容进行md5加密 得到一个base64加密hash值            let rs = fs.createReadStream(p);            let md5 = crypto.createHash(&apos;md5&apos;);            let arr = [];            rs.on(&apos;data&apos;,(data)=&gt;{                arr.push(data);                md5.update(data);            })            rs.on(&apos;end&apos;,(data)=&gt;{                let r = md5.digest(&apos;base64&apos;);                // 然后我们将这个hash值通过响应头Etag传给客户端，客户端再下一次请求的时候会把上一次的Etag值通过请求头if-none-match带过来，然后我们就可以继续比对文件生成的hash值和上次产生的hash是否一样 如果一样说明文件内容没有发生变化 就告诉客户端304 读取缓存                res.setHeader(&apos;Etag&apos;,r);                if(req.headers[&apos;if-none-match&apos;]===r){                    res.statusCode=304;                    res.end();                    return;                }                res.end(Buffer.concat(arr))            })        }else{            let rs = fs.createReadStream(readPath);            let md5 = crypto.createHash(&apos;md5&apos;);            let arr = [];            rs.on(&apos;data&apos;,(data)=&gt;{                arr.push(data);                md5.update(data);            })            rs.on(&apos;end&apos;,(data)=&gt;{                let r = md5.digest(&apos;base64&apos;);                res.setHeader(&apos;Etag&apos;,r);                if(req.headers[&apos;if-none-match&apos;]===r){                    res.statusCode=304;                    res.end();                    return;                }                res.end(Buffer.concat(arr))            })        }    } catch (error) {        console.log(error)        res.setHeader(&apos;Content-Type&apos;,&apos;text/html;charset=utf8&apos;)        res.statusCode = 404;        res.end(`未发现文件`)    }})server.listen(3000)复制代码</code></pre><p><a href="https://camo.githubusercontent.com/2f8b1e0fdea5971d22f52b82ebae608cf2f8d73b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396665623530666363373334393f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/2f8b1e0fdea5971d22f52b82ebae608cf2f8d73b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396665623530666363373334393f696d61676556696577322f302f772f313238302f682f3936302f666f726d61742f776562702f69676e6f72652d6572726f722f31" alt=""></a><br>通过控制台我们可以看出来 请求头和响应头中都有我们上面所说的对应的值，但是从代码里我们也能看出来，我们每次在请求到来的时候都会把文件全部读取出来并且进行加密生产hash然后再做对比，这样其实十分的消耗性能，因此这种缓存方式也有他自己的缺点</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们通过node来亲自实现了三种缓存方式，我们可以总结出每种缓存方式对应的实现：</p><ul><li>强制缓存 服务端设置响应头Cache-Control:max-age=xxx，并且设置Expires响应头过期时间，客户端自行判断是否读取缓存</li><li><p>协商缓存 通过状态码304告诉客户端该走缓存</p></li><li><p>修改时间：通过文件的最后修改时间判断该不该读取缓存，服务端设置响应头Last-Modified,客户端把上次服务端响应头中的Last-modified值通过if-modified-since 传递给服务端 ， 服务端通过比较当前文件的修改时间和上次修改时间(上次传给客户端的值),如果相等那么说明文件修改时间没变也就是没变化</p></li><li>文件内容：通过文件的内容来判断该不该读取缓存，服务端通过把文件内容读取出来，通过md5进行base64加密得出hash值，把这个值设置响应头Etag，客户端下一次请求通过if-none-match带过来，服务端再比对当前文件内容加密得出的hash值和上次是否一样，如果一样说明文件内容没有发生改变，这种方式是最准确的方式，但是也是最耗性能</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JSBridge的原理</title>
      <link href="/2018/08/28/JSBridge%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2018/08/28/JSBridge%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>关于 JSBridge，绝大多数同学最早遇到的是微信的 WeiXinJSBridge（现在被封装成 JSSDK），各种 Web 页面可以通过 Bridge 调用微信提供的一些原生功能，为用户提供相关的功能。其实，JSBridge 很早就出现在软件开发中，在一些桌面软件中很早就运用了这样的形式，多用在通知、产品详情、广告等模块中，然后这些模块中，使用的是 Web UI，而相关按钮点击后，调用的是 Native 功能。现在移动端盛行，不管是 Hybrid 应用，还是 React-Native 都离不开 JSBridge，当然也包括在国内举足轻重的微信小程序。那么，JSBridge 到底是什么？它的出现是为了什么？它究竟是怎么实现的？在这篇文章中，会在移动混合开发的范畴内，将给大家带来 JSBridge 的深入剖析。</p><p>当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。<br><img src="/2018/08/28/JSBridge的原理/1.webp" alt=""><br><img src="/2018/08/28/JSBridge的原理/2.webp" alt=""></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a><strong>1 前言</strong></h1><p>有些童鞋听到 JSBridge 这个名词，就是觉得非常高上大，有了它 Web 和 Native 可以进行交互，就像『进化药水』，让 Web 摇身一变，成为移动战场的『上将一名』。其实并非如此，JSBridge 其实真是一个很简单的东西，更多的是一种形式、一种思想。</p><h1 id="2-JSBridge-的起源"><a href="#2-JSBridge-的起源" class="headerlink" title="2 JSBridge 的起源"></a><strong>2 JSBridge 的起源</strong></h1><p>为什么是 JSBridge ？而不是 PythonBridge 或是 RubyBridge ？</p><p>当然不是因为 JavaScript 语言高人一等（虽然斯坦福大学已经把算法导论的语言从 Java 改成 JavaScript，小得意一下，嘻嘻），主要的原因还是因为 JavaScript 主要载体 Web 是当前世界上的 <strong>最易编写</strong> 、 <strong>最易维护</strong> 、<strong>最易部署</strong> 的 UI 构建方式。工程师可以用很简单的 HTML 标签和 CSS 样式快速的构建出一个页面，并且在服务端部署后，用户不需要主动更新，就能看到最新的 UI 展现。</p><p>因此，<strong>开发维护成本</strong> 和 <strong>更新成本</strong> 较低的 Web 技术成为混合开发中几乎不二的选择，而作为 Web 技术逻辑核心的 JavaScript 也理所应当肩负起与其他技术『桥接』的职责，并且作为移动不可缺少的一部分，任何一个移动操作系统中都包含可运行 JavaScript 的容器，例如 WebView 和 JSCore。所以，运行 JavaScript 不用像运行其他语言时，要额外添加运行环境。因此，基于上面种种原因，JSBridge 应运而生。</p><p>PhoneGap（Codova 的前身）作为 Hybrid 鼻祖框架，应该是最先被开发者广泛认知的 JSBridge 的应用场景；而对于 JSBridge 的应用在国内真正兴盛起来，则是因为杀手级应用微信的出现，主要用途是在网页中通过 JSBridge 设置分享内容。</p><p>移动端混合开发中的 JSBridge，主要被应用在两种形式的技术方案上：</p><p>基于 Web 的 Hybrid 解决方案：例如微信浏览器、各公司的 Hybrid 方案</p><p>非基于 Web UI 但业务逻辑基于 JavaScript 的解决方案：例如 React-Native</p><p>【注】：微信小程序基于 Web UI，但是为了追求运行效率，对 UI 展现逻辑和业务逻辑的 JavaScript 进行了隔离。因此小程序的技术方案介于上面描述的两种方式之间。</p><h1 id="3-JSBridge-的用途"><a href="#3-JSBridge-的用途" class="headerlink" title="3 JSBridge 的用途"></a><strong>3 JSBridge 的用途</strong></h1><p>JSBridge 简单来讲，主要是 <strong>给 JavaScript 提供调用 Native 功能的接口</strong>，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。</p><p>既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 <strong>构建 Native 和非 Native 间消息通信的通道</strong>，而且是 <strong>双向通信的通道</strong>。<br><img src="/2018/08/28/JSBridge的原理/3.webp" alt=""><br>所谓 <strong>双向通信的通道</strong>:</p><ul><li>JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。</li><li>Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</li></ul><p>这里有些同学有疑问了：<em>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</em><br>对于这个问题，在下一节里会给出解释。</p><h1 id="4-JSBridge-的实现原理"><a href="#4-JSBridge-的实现原理" class="headerlink" title="4 JSBridge 的实现原理"></a><strong>4 JSBridge 的实现原理</strong></h1><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。</p><p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：<strong>通信调用（Native 与 JS 通信）</strong> 和 <strong>句柄解析调用</strong>。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）</p><p>通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 <strong>Hybrid 方案</strong> 为案例从这几点来剖析 JSBridge 的实现原理。</p><h2 id="4-1-JSBridge-的通信原理"><a href="#4-1-JSBridge-的通信原理" class="headerlink" title="4.1 JSBridge 的通信原理"></a><strong>4.1 JSBridge 的通信原理</strong></h2><p>Hybrid 方案是基于 WebView 的，JavaScript 执行在 WebView 的 Webkit 引擎中。因此，Hybrid 方案中 JSBridge 的通信原理会具有一些 Web 特性。</p><h3 id="4-1-1-JavaScript-调用-Native"><a href="#4-1-1-JavaScript-调用-Native" class="headerlink" title="4.1.1 JavaScript 调用 Native"></a><strong>4.1.1 JavaScript 调用 Native</strong></h3><p>JavaScript 调用 Native 的方式，主要有两种：<font color="#ff0000"><strong>注入 API</strong> </font> 和 <font color="#ff0000"> <strong>拦截 URL SCHEME</strong> </font>。</p><h4 id="4-1-1-1-注入API"><a href="#4-1-1-1-注入API" class="headerlink" title="4.1.1.1 注入API"></a><strong>4.1.1.1 注入API</strong></h4><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p><p>对于 iOS 的 UIWebView，实例如下：</p><pre><code>JSContext *context = [uiWebView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];context[@&quot;postBridgeMessage&quot;] = ^(NSArray&lt;NSArray *&gt; *calls) {    // Native 逻辑};</code></pre><p>前端调用方式：</p><pre><code>window.postBridgeMessage(message);</code></pre><p>对于 iOS 的 WKWebView 可以用以下方式：</p><pre><code>@interface WKWebVIewVC ()&lt;WKScriptMessageHandler&gt;@implementation WKWebVIewVC- (void)viewDidLoad {    [super viewDidLoad];    WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];    configuration.userContentController = [[WKUserContentController alloc] init];    WKUserContentController *userCC = configuration.userContentController;    // 注入对象，前端调用其方法时，Native 可以捕获到    [userCC addScriptMessageHandler:self name:@&quot;nativeBridge&quot;];    WKWebView wkWebView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration];    // TODO 显示 WebView}- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {    if ([message.name isEqualToString:@&quot;nativeBridge&quot;]) {        NSLog(@&quot;前端传递的数据 %@: &quot;,message.body);        // Native 逻辑    }}</code></pre><p>前端调用方式：</p><pre><code>window.webkit.messageHandlers.nativeBridge.postMessage(message);</code></pre><p>对于 Android 可以采用下面的方式：</p><pre><code>publicclassJavaScriptInterfaceDemoActivityextendsActivity{private WebView Wv;    @Override    publicvoidonCreate(Bundle savedInstanceState){        super.onCreate(savedInstanceState);        Wv = (WebView)findViewById(R.id.webView);             final JavaScriptInterface myJavaScriptInterface = new JavaScriptInterface(this);                 Wv.getSettings().setJavaScriptEnabled(true);        Wv.addJavascriptInterface(myJavaScriptInterface, &quot;nativeBridge&quot;);        // TODO 显示 WebView    }    publicclassJavaScriptInterface{         Context mContext;         JavaScriptInterface(Context c) {             mContext = c;         }         publicvoidpostMessage(String webMessage){                         // Native 逻辑         }     }}</code></pre><p>前端调用方式：</p><pre><code>window.nativeBridge.postMessage(message);</code></pre><p>在 4.2 之前，Android 注入 JavaScript 对象的接口是 addJavascriptInterface，但是这个接口有漏洞，可以被不法分子利用，危害用户的安全，因此在 4.2 中引入新的接口 @JavascriptInterface（上面代码中使用的）来替代这个接口，解决安全问题。所以 Android 注入对对象的方式是 <strong>有兼容性问题的</strong>。（4.2 之前很多方案都采用拦截 prompt 的方式来实现，因为篇幅有限，这里就不展开了。）</p><h4 id="4-1-1-2-拦截-URL-SCHEME"><a href="#4-1-1-2-拦截-URL-SCHEME" class="headerlink" title="4.1.1.2 拦截 URL SCHEME"></a><strong>4.1.1.2 拦截 URL SCHEME</strong></h4><p>先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=<a href="https://link.juejin.im?target=http%3A%2F%2Fymfe.tech" target="_blank" rel="noopener">ymfe.tech</a>，protocol 是 qunarhy，host 则是 hy。</p><p>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p><p>在时间过程中，这种方式有一定的 <strong>缺陷</strong>：</p><ul><li><font color="#dd0000"><strong> 使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</strong></font></li><li><font color="#dd0000"><strong>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</strong></font></li></ul><p>但是之前为什么很多方案使用这种方式呢？因为它 <strong>支持 iOS6</strong>。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 <strong>并不优雅</strong> 的方式。</p><p>【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。</p><p>【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。</p><h3 id="4-1-2-Native-调用-JavaScript"><a href="#4-1-2-Native-调用-JavaScript" class="headerlink" title="4.1.2 Native 调用 JavaScript"></a><strong>4.1.2 Native 调用 JavaScript</strong></h3><p>相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。</p><p>Native 调用 JavaScript，其实就是执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法，因此 JavaScript 的方法必须在全局的 window 上。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）</p><p>对于 iOS 的 UIWebView，示例如下：</p><pre><code>result = [uiWebview stringByEvaluatingJavaScriptFromString:javaScriptString];</code></pre><p>对于 iOS 的 WKWebView，示例如下：</p><pre><code>[wkWebView evaluateJavaScript:javaScriptString completionHandler:completionHandler];</code></pre><p>对于 Android，在 Kitkat（4.4）之前并没有提供 iOS 类似的调用方式，只能用 loadUrl 一段 JavaScript 代码，来实现：</p><pre><code>webView.loadUrl(&quot;javascript:&quot; + javaScriptString);</code></pre><p>而 Kitkat 之后的版本，也可以用 evaluateJavascript 方法实现：</p><pre><code>webView.evaluateJavascript(javaScriptString, new ValueCallback&lt;String&gt;() {    @Override    publicvoidonReceiveValue(String value){    }});</code></pre><p>【注】：使用 loadUrl 的方式，并不能获取 JavaScript 执行后的结果。</p><h3 id="4-1-3-通信原理小总结"><a href="#4-1-3-通信原理小总结" class="headerlink" title="4.1.3 通信原理小总结"></a><strong>4.1.3 通信原理小总结</strong></h3><p>通信原理是 JSBridge 实现的核心，实现方式可以各种各样，但是万变不离其宗。这里，笔者推荐的实现方式如下：</p><ul><li><p>JavaScript 调用 Native 推荐使用 <strong>注入 API</strong> 的方式（iOS6 忽略，Android 4.2以下使用 WebViewClient 的 onJsPrompt 方式）。</p></li><li><p>Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。</p></li></ul><p>对于其他方式，诸如 React Native、微信小程序 的通信方式都与上描述的近似，并根据实际情况进行优化。</p><p>以 React Native 的 iOS 端举例：JavaScript 运行在 JSCore 中，实际上可以与上面的方式一样，利用注入 API 来实现 JavaScript 调用 Native 功能。不过 React Native 并没有设计成 JavaScript 直接调用 Object-C，而是 <strong>为了与 Native 开发里事件响应机制一致</strong>，设计成 <strong>需要在 Object-C 去调 JavaScript 时才通过返回值触发调用</strong>。原理基本一样，只是实现方式不同。</p><p>当然不仅仅 iOS 和 Android，其他手机操作系统也用相应的 API，例如 WMP（Win 10）下可以用 window.external.notify 和 WebView.InvokeScript/InvokeScriptAsync 进行双向通信。其他系统也类似。</p><h2 id="4-2-JSBridge-接口实现"><a href="#4-2-JSBridge-接口实现" class="headerlink" title="4.2 JSBridge 接口实现"></a><strong>4.2 JSBridge 接口实现</strong></h2><p>从上面的剖析中，可以得知，JSBridge 的接口主要功能有两个：<strong>调用 Native（给 Native 发消息）</strong> 和 <strong>接被 Native 调用（接收 Native 消息）</strong>。因此，JSBridge 可以设计如下：</p><pre><code>window.JSBridge = {    // 调用 Native    invoke: function(msg) {        // 判断环境，获取不同的 nativeBridge        nativeBridge.postMessage(msg);    },    receiveMessage: function(msg) {        // 处理 msg    }};</code></pre><p>在上面的文章中，提到过 RPC 中有一个非常重要的环节是 <strong>句柄解析调用</strong> ，这点在 JSBridge 中体现为 <strong>句柄与功能对应关系</strong>。同时，我们将句柄抽象为 <strong>桥名（BridgeName）</strong>，最终演化为 <strong>一个 BridgeName 对应一个 Native 功能或者一类 Native 消息</strong>。 基于此点，JSBridge 的实现可以优化为如下：</p><pre><code>window.JSBridge = {    // 调用 Native    invoke: function(bridgeName, data) {        // 判断环境，获取不同的 nativeBridge        nativeBridge.postMessage({            bridgeName: bridgeName,            data: data || {}        });    },    receiveMessage: function(msg) {        var bridgeName = msg.bridgeName,            data = msg.data || {};        // 具体逻辑    }};</code></pre><p>JSBridge 大概的雏形出现了。现在终于可以着手解决这个问题了：<strong>消息都是单向的，那么调用 Native 功能时 Callback 怎么实现的？</strong></p><p>对于 JSBridge 的 Callback ，其实就是 RPC 框架的回调机制。当然也可以用更简单的 JSONP 机制解释：</p><blockquote><p>当发送 JSONP 请求时，url 参数里会有 callback 参数，其值是 <strong>当前页面唯一</strong> 的，而同时以此参数值为 key 将回调函数存到 window 上，随后，服务器返回 script 中，也会以此参数值作为句柄，调用相应的回调函数。</p></blockquote><p>由此可见，callback 参数这个 <strong>唯一标识</strong> 是这个回调逻辑的关键。这样，我们可以参照这个逻辑来实现 JSBridge：用一个自增的唯一 id，来标识并存储回调函数，并把此 id 以参数形式传递给 Native，而 Native 也以此 id 作为回溯的标识。这样，即可实现 Callback 回调逻辑。</p><pre><code>(function () {    var id = 0,        callbacks = {};    window.JSBridge = {        // 调用 Native        invoke: function(bridgeName, callback, data) {            // 判断环境，获取不同的 nativeBridge            var thisId = id ++; // 获取唯一 id            callbacks[thisId] = callback; // 存储 Callback            nativeBridge.postMessage({                bridgeName: bridgeName,                data: data || {},                callbackId: thisId // 传到 Native 端            });        },        receiveMessage: function(msg) {            var bridgeName = msg.bridgeName,                data = msg.data || {},                callbackId = msg.callbackId; // Native 将 callbackId 原封不动传回            // 具体逻辑            // bridgeName 和 callbackId 不会同时存在            if (callbackId) {                if (callbacks[callbackId]) { // 找到相应句柄                    callbacks[callbackId](msg.data); // 执行调用                }            } elseif (bridgeName) {            }        }    };})();</code></pre><p>最后用同样的方式加上 Native 调用的回调逻辑，同时对代码进行一些优化，就大概实现了一个功能比较完整的 JSBridge。其代码如下：</p><pre><code>(function () {    var id = 0,        callbacks = {},        registerFuncs = {};    window.JSBridge = {        // 调用 Native        invoke: function(bridgeName, callback, data) {            // 判断环境，获取不同的 nativeBridge            var thisId = id ++; // 获取唯一 id            callbacks[thisId] = callback; // 存储 Callback            nativeBridge.postMessage({                bridgeName: bridgeName,                data: data || {},                callbackId: thisId // 传到 Native 端            });        },        receiveMessage: function(msg) {            var bridgeName = msg.bridgeName,                data = msg.data || {},                callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回                responstId = msg.responstId;            // 具体逻辑            // bridgeName 和 callbackId 不会同时存在            if (callbackId) {                if (callbacks[callbackId]) { // 找到相应句柄                    callbacks[callbackId](msg.data); // 执行调用                }            } elseif (bridgeName) {                if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄                    var ret = {},                        flag = false;                    registerFuncs[bridgeName].forEach(function(callback) =&gt; {                        callback(data, function(r) {                            flag = true;                            ret = Object.assign(ret, r);                        });                    });                    if (flag) {                        nativeBridge.postMessage({ // 回调 Native                            responstId: responstId,                            ret: ret                        });                    }                }            }        },        register: function(bridgeName, callback) {            if (!registerFuncs[bridgeName])  {                registerFuncs[bridgeName] = [];            }            registerFuncs[bridgeName].push(callback); // 存储回调        }    };})();</code></pre><p>当然，这段代码片段只是一个示例，主要用于剖析 JSBridge 的原理和流程，里面存在诸多省略和不完善的代码逻辑，读者们可以自行完善。</p><p>【注】：这一节主要讲的是，JavaScript 端的 JSBridge 的实现，对于 Native 端涉及的并不多。在 Native 端配合实现 JSBridge 的 JavaScript 调用 Native 逻辑也很简单，主要的代码逻辑是：接收到 JavaScript 消息 =&gt; 解析参数，拿到 bridgeName、data 和 callbackId =&gt; 根据 bridgeName 找到功能方法，以 data 为参数执行 =&gt; 执行返回值和 callbackId 一起回传前端。 Native 调用 JavaScript 也同样简单，直接自动生成一个唯一的 ResponseId，并存储句柄，然后和 data 一起发送给前端即可。</p><h1 id="5-JSBridge-如何引用"><a href="#5-JSBridge-如何引用" class="headerlink" title="5 JSBridge 如何引用"></a><strong>5 JSBridge 如何引用</strong></h1><p>对于 JSBridge 的引用，常用有两种方式，各有利弊。</p><h2 id="5-1-由-Native-端进行注入"><a href="#5-1-由-Native-端进行注入" class="headerlink" title="5.1 由 Native 端进行注入"></a><strong>5.1 由 Native 端进行注入</strong></h2><p>注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码。</p><p>它的优点在于：桥的版本很容易与 Native 保持一致，Native 端不用对不同版本的 JSBridge 进行兼容；与此同时，它的缺点是：注入时机不确定，需要实现注入失败后重试的机制，保证注入的成功率，同时 JavaScript 端在调用接口时，需要优先判断 JSBridge 是否已经注入成功。</p><h2 id="5-2-由-JavaScript-端引用"><a href="#5-2-由-JavaScript-端引用" class="headerlink" title="5.2 由 JavaScript 端引用"></a><strong>5.2 由 JavaScript 端引用</strong></h2><p>直接与 JavaScript 一起执行。</p><p>与由 Native 端注入正好相反，它的优点在于：JavaScript 端可以确定 JSBridge 的存在，直接调用即可；缺点是：如果桥的实现方式有更改，JSBridge 需要兼容多版本的 Native Bridge 或者 Native Bridge 兼容多版本的 JSBridge。</p><h1 id="如何调用三种唤端媒介"><a href="#如何调用三种唤端媒介" class="headerlink" title="如何调用三种唤端媒介"></a><strong>如何调用三种唤端媒介</strong></h1><p>无论是 URL Scheme 还是 Intent 或者 Universal Link ，他们都算是 URL ，只是 URL Scheme 和 Intent 算是特殊的 URL。所以我们可以拿使用 URL 的方法来使用它们。</p><blockquote><p>iframe</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;sinaweibo://qrcode&quot;&gt;</span><br></pre></td></tr></table></figure><p>在只有 URL Scheme 的日子里，iframe 是使用最多的了。因为在未安装 app 的情况下，不会去跳转错误页面。但是 iframe 在各个系统以及各个应用中的兼容问题还是挺多的，不能全部使用 URL Scheme。</p><blockquote><p>a 标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;intent://scan/#Intent;scheme=zxing;package=com.google.zxing.client.android;end&quot;&quot;&gt;扫一扫&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>对于动态生成的 a 标签，使用 dispatch 来模拟触发点击事件，发现很多种 event 传递过去都无效；使用 click() 来模拟触发，部分场景下存在这样的情况，第一次点击过后，回到原先页面，再次点击，点击位置和页面所识别位置有不小的偏移，所以 Intent 协议从 a 标签换成了 window.location。</p><blockquote><p>window.location</p></blockquote><p>URL Scheme 在 ios 9+ 上诸如 safari、UC、QQ浏览器中， iframe 均无法成功唤起 APP，只能通过 window.location 才能成功唤端。<br>当然，如果我们的 app 支持 Universal Link，ios 9+ 就用不到 URL Scheme 了。而 Universal Link 在使用过程中，我发现在 qq 中，无论是 iframe 导航 还是 a 标签打开 又或者 window.location 都无法成功唤端，一开始我以为是 qq 和微信一样禁止了 Universal Link 唤端的功能，其实不然，百般试验下，通过 top.location 唤端成功了。</p><h3 id="判断唤端是否成功"><a href="#判断唤端是否成功" class="headerlink" title="判断唤端是否成功"></a>判断唤端是否成功</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const initialTime = new Date();</span><br><span class="line">let counter = 0;</span><br><span class="line">let waitTime = 0;</span><br><span class="line"></span><br><span class="line">const checkOpen = setInterval(() =&gt; &#123;</span><br><span class="line">   count++;</span><br><span class="line">   waitTime = new Date() - initialTime;</span><br><span class="line"></span><br><span class="line">   if (waitTime &gt; 2500) &#123;</span><br><span class="line">      clearInterval(checkOpen);</span><br><span class="line">      cb();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   if (counter &lt; 100) return;</span><br><span class="line"></span><br><span class="line">   clearInterval(checkOpen);</span><br><span class="line"></span><br><span class="line">   const hide = document.hidden || document.webkitHidden;</span><br><span class="line"></span><br><span class="line">   if (!hide) &#123;</span><br><span class="line">      cb(); // 唤端失败的回调函数</span><br><span class="line">   &#125;</span><br><span class="line">&#125;, 20);</span><br></pre></td></tr></table></figure><p>APP 如果被唤起的话，页面就会进入后台运行，setInterval 在 ios 中不会停止运行，在 android 中停止运行。<br>每 20ms 执行一次，执行 100次 在页面中实际耗费与 2000 ms 不会相差多少。<br>我们的判断条件比预期时间多设置了 500ms，所以如果安卓中 setInterval 内的函数执行 100 次以内所费时间超过 2500ms，则说明 APP 唤起成功，反之则代表失败。<br>我们通过 document.hidden 和 document.webkitHidden 属性来判断 APP 在 ios 中是否被正常唤起，2000ms 内，页面转入后台运行，document.hidden 会返回 true，代表唤端成功，反之则代表失败。</p><h1 id="判断是否安装app并打开-否则跳转下载的方法"><a href="#判断是否安装app并打开-否则跳转下载的方法" class="headerlink" title="判断是否安装app并打开,否则跳转下载的方法"></a><strong>判断是否安装app并打开,否则跳转下载的方法</strong></h1><blockquote><p>应用场景</p></blockquote><p>App产品在运营推广上有一个需求，就是要求可以让用户在访问我们的推广网页时，就可以判断出这个用户手机上是否安装了我们的App，如果安装了则可以直接在网页上打开，否则就引导用户前往下载。从而形成一个推广上的闭环。</p><blockquote><p>解决办法</p></blockquote><p>而对于点击链接后，能否直接打开，可以通过下面的代码来实现。前提条件：你得知道你的APP对应的打开协议，如贴吧APP，协议为：com.baidu.tieba:// ，微信的：weixin:// ，等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- a标签点击打开的动作，在click事件中注册 --&gt;</span><br><span class="line">&lt;a href=&quot;javascript:;&quot; id=&quot;openApp&quot;&gt;贴吧客户端&lt;/a&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">        // 通过iframe的方式试图打开APP，如果能正常打开，会直接切换到APP，并自动阻止js其他行为</span><br><span class="line">        </span><br><span class="line">        var ifr = document.createElement(&apos;iframe&apos;);</span><br><span class="line">        ifr.src = &apos;com.baidu.tieba://&apos;;//打开app的协议，有app同事提供</span><br><span class="line">        ifr.style.display = &apos;none&apos;;</span><br><span class="line">        document.body.appendChild(ifr);</span><br><span class="line">        window.setTimeout(function()&#123;</span><br><span class="line">            document.body.removeChild(ifr);</span><br><span class="line">　　　　　　　window.location.href = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;//打开app下载地址，有app同事提供</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>此方法有些浏览器不兼容iframe，可以window.location的方法解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;javascript:;&quot; id=&quot;openApp&quot;&gt;贴吧客户端&lt;/a&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">        window.location.href = &quot;com.baidu.tieba://&quot;;</span><br><span class="line">        window.setTimeout(function()&#123;</span><br><span class="line">            window.location.href = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;//打开app下载地址，有app同事提供</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h1 id="js判断本地是否安装app"><a href="#js判断本地是否安装app" class="headerlink" title="js判断本地是否安装app"></a><strong>js判断本地是否安装app</strong></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">             document.getElementById(&apos;openApp&apos;).onclick = function(e)&#123;</span><br><span class="line">                if(navigator.userAgent.match(/(iPhone|iPod|iPad);?/i)) &#123;</span><br><span class="line">                var loadDateTime = new Date();</span><br><span class="line">                window.setTimeout(function() &#123;</span><br><span class="line">                        var timeOutDateTime = new Date();</span><br><span class="line">                        if(timeOutDateTime - loadDateTime &lt; 5000) &#123;</span><br><span class="line">                            window.location = &quot;https://itunes.apple.com/cn/app/id477927812&quot;;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            window.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    25);</span><br><span class="line">                window.location = &quot;weixin:// &quot;;</span><br><span class="line">            &#125; else if(navigator.userAgent.match(/android/i)) &#123;</span><br><span class="line">                var state = null;</span><br><span class="line">                try &#123;</span><br><span class="line">                    state = window.open(&quot;weixin://&quot;);</span><br><span class="line">                &#125; catch(e) &#123;&#125;</span><br><span class="line">                if(state) &#123;</span><br><span class="line">                    window.close();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    window.location = &quot;http://dldir1.qq.com/weixin/android/weixin656android1020.apk&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果本地安装了app那么直接打开，否则苹果要跳转到app-store，安卓则要跳到对应的市场</p><blockquote><p>解决方案 一</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//html代码中 的 a 标签，以微信为例，默认的是调用weixin scheme，去打开本机的微信，如果没有则跳转到相应连接</span><br><span class="line">　　　　&lt;a href=&quot;weixin://&quot; class=&quot;btn-download&quot;&gt;立即打开&lt;/a&gt;</span><br><span class="line">　　</span><br><span class="line">　　　　// 为btn-download 绑定事件，如果在500ms内，没有解析到协议，那么就会跳转到下载链接 </span><br><span class="line">　　　　 var appstore, ua = navigator.userAgent;</span><br><span class="line">        if(ua.match(/Android/i))&#123; </span><br><span class="line">            appstore = &apos;market://search?q=com.singtel.travelbuddy.android&apos;;</span><br><span class="line">        &#125;</span><br><span class="line">        if(ua.match(/iphone|ipod|ipad/))&#123;</span><br><span class="line">            appstore = &quot;https://itunes.apple.com/cn/app/wei-xin/id414478124?mt=8&amp;ign-mpt=uo%3D4&quot;; </span><br><span class="line">        &#125;</span><br><span class="line">        function applink(fail)&#123;  </span><br><span class="line">            return function()&#123;  </span><br><span class="line">                var clickedAt = +new Date;  </span><br><span class="line">                // During tests on 3g/3gs this timeout fires immediately if less than 500ms.  </span><br><span class="line">                setTimeout(function()&#123;  </span><br><span class="line">                     // To avoid failing on return to MobileSafari, ensure freshness!  </span><br><span class="line">                      if (+new Date - clickedAt &lt; 2000)&#123;  </span><br><span class="line">                          window.location = fail;  </span><br><span class="line">                      &#125;  </span><br><span class="line">                &#125;, 500);      </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;  </span><br><span class="line">        $(&apos;.icon-download, .btn-download&apos;)[0].onclick = applink(appstore);</span><br></pre></td></tr></table></figure><blockquote><p>解决方案二 </p></blockquote><p>通过在页面中生成一个隐藏的iframe，iframe的src指向 app 协议，例如 weixin scheme，并监听onerror事件，意思是如果无法解析协议，就会触发onerror事件，但是我尝试了一下，未果。代码如下，可参考一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 页面中有div#iframe-box 用来插入生成的iframe，还是以微信为例</span><br><span class="line">　　　　 var ifm = document.createElement(&apos;iframe&apos;), isInstalled;</span><br><span class="line">        ifm.style.display = &apos;none&apos;;</span><br><span class="line">        ifm.src = &apos;wixin://&apos;;</span><br><span class="line">        ifm.onload = function(e)&#123;</span><br><span class="line">            var e = e || window.event;</span><br><span class="line">            e.preventDefault();</span><br><span class="line">        &#125;</span><br><span class="line">        ifm.onerror = function()&#123;</span><br><span class="line">            //isInstalled = false;</span><br><span class="line">            alert(1);</span><br><span class="line">        &#125;</span><br><span class="line">        document.getElementById(&apos;iframe-box&apos;).appendChild(ifm);</span><br><span class="line"></span><br><span class="line">　　　　// 但这时的问题是，iframe的src成功解析到了协议，则会直接跳转，但是解析不到的话，也不会触发error事件，这个还要继续研究</span><br><span class="line">　　　　// 可以把上面的代码，放到函数中，然后作为某个按钮的响应函数。</span><br></pre></td></tr></table></figure><blockquote><p>解决方案三</p></blockquote><p>对于ios手机，会有如下写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;apple-itunes-app&quot; content=&quot;app-id=414478124&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>将上面代码放到head中，根据name也会知道意思，app-id是微信的app-id，用ios手机看会看到提示，andriod比可以，结果自行实验。（ios就是强大）</p><h1 id="H5唤起客户端通用机方案"><a href="#H5唤起客户端通用机方案" class="headerlink" title="H5唤起客户端通用机方案"></a><strong>H5唤起客户端通用机方案</strong></h1><h4 id="H5唤起客户端"><a href="#H5唤起客户端" class="headerlink" title="H5唤起客户端"></a><a href="https://github.com/suanmei/callapp-lib" target="_blank" rel="noopener">H5唤起客户端</a></h4><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a><strong>6 总结</strong></h1><p>这篇文章主要剖析的 JSBridge 的实现及应用，包括 <strong>JavaScript 与 Native 间的通信原理</strong>，<strong>JSBridge 的 JavaScript 端实现</strong> 以及 <strong>引用方式</strong>，并给出了一些示例代码，希望对读者有一定的帮助。</p><h3 id="JSBridge实战"><a href="#JSBridge实战" class="headerlink" title="JSBridge实战"></a><a href="https://juejin.im/post/5bda6f276fb9a0226d18931f" target="_blank" rel="noopener">JSBridge实战</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> JSBridge </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Koa session和cookie</title>
      <link href="/2018/08/25/Koa-session%E5%92%8Ccookie/"/>
      <url>/2018/08/25/Koa-session%E5%92%8Ccookie/</url>
      
        <content type="html"><![CDATA[<h2 id="从http协议的无状态性说起"><a href="#从http协议的无状态性说起" class="headerlink" title="从http协议的无状态性说起"></a>从http协议的无状态性说起</h2><p>HTTP是一种无状态协议。关于这个无状态之前我也不太理解，因为HTTP底层是TCP，既然是TCP，就是长连接，这个过程是保持连接状态的，又为什么说http是无状态的呢？先来搞清楚这两个概念：</p><h3 id="无连接和无状态"><a href="#无连接和无状态" class="headerlink" title="无连接和无状态"></a>无连接和无状态</h3><blockquote><p>无连接</p></blockquote><p>每次连接只处理一个请求，服务端处理完客户端一次请求，等到客户端作出回应之后便断开连接；</p><blockquote><p>无状态</p></blockquote><p>是指服务端对于客户端每次发送的请求都认为它是一个新的请求，上一次会话和下一次会话没有联系；</p><p>无连接的维度是连接，无状态的维度是请求；http是基于tcp的，而从http1.1开始默认使用持久连接；在这个连接过程中，客户端可以向服务端发送多次请求，但是各个请求之间的并没有什么联系；这样来考虑，就很好理解无状态这个概念了。</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><blockquote><p>持久连接，本质上是客户端与服务器通信的时候，建立一个持久化的TCP连接，这个连接不会随着请求结束而关闭，通常会保持连接一段时间。`</p></blockquote><p>现有的持久连接类型有两种：HTTP/1.0+的 <strong> keep-alive </strong>和HTTP/1.1的<strong> persistent </strong>。</p><ul><li>HTTP/1.0+的keep-alive</li></ul><p>先来开一张图：<br><img src="/2018/08/25/Koa-session和cookie/1.webp" alt=""><br>这张图是请求<a href="http://www.baidu.com时的请求头信息。这里面我们需要注意的是：" target="_blank" rel="noopener">www.baidu.com时的请求头信息。这里面我们需要注意的是：</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection: keep-alive</span><br></pre></td></tr></table></figure></p><p>我们每次发送一个HTTP请求，会附带一个connection:keep-alive，这个参数就是声明一个持久连接。</p><ul><li>HTTP/1.1的persistent</li></ul><p>HTTP/1.1的持久连接默认是开启的，只有首部中包含connection：close，才会事务结束之后关闭连接。当然服务器和客户端仍可以随时关闭持久连接。</p><p>当发送了connection：close首部之后客户端就没有办法在那条连接上发送更多的请求了。当然根据持久连接的特性，一定要传输正确的content-length。</p><p>还有根据HTTP/1.1的特性，是不应该和HTTP/1.0客户端建立持久连接的。最后，一定要做好重发的准备。</p><h3 id="http无状态"><a href="#http无状态" class="headerlink" title="http无状态"></a>http无状态</h3><p>OK，首先来明确下，这个状态的主体指的是什么？应该是信息，这些信息是由服务端所维护的与客户端交互的信息（也称为状态信息）；<br>因为HTTP本身是不保存任何用户的状态信息的，所以HTTP是无状态的协议。</p><h3 id="如何保持状态信息"><a href="#如何保持状态信息" class="headerlink" title="如何保持状态信息"></a>如何保持状态信息</h3><p>在聊这个这个问题之前，我们来考虑下为什么http自己不来做这个事情：也就是让http变成有状态的。</p><blockquote><p>http本身来实现状态维护</p></blockquote><p>从上面关于无状态的理解，如果现在需要让http自己变成有状态的，就意味着http协议需要保存交互的状态信息；暂且不说这种方式是否合适，但从维护状态信息这一点来说，代价就很高，因为既然保存了状态信息，那后续的一些行为必定也会受到状态信息的影响。</p><p>从历史角度来说，最初的http协议只是用来浏览静态文件的，无状态协议已经足够，这样实现的负担也很轻。但是随着web技术的不断发展，越来越多的场景需要状态信息能够得以保存；一方面是http本身不会去改变它的这种无状态的特性（至少目前是这样的），另一方面业务场景又迫切的需要保持状态；那么这个时候就需要来“装饰”一下http，引入一些其他机制来实现有状态。</p><blockquote><p>cookie和session体系</p></blockquote><p>通过引入cookie和session体系机制来维护状态信息。即用户第一次访问服务器的时候，服务器响应报头通常会出现一个Set-Cookie响应头，这里其实就是在本地设置一个cookie，当用户再次访问服务器的时候，http会附带这个cookie过去，cookie中存有sessionId这样的信息来到服务器这边确认是否属于同一次会话。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie是由服务器发送给客户端（浏览器）的小量信息，以{key：value}的形式存在。</p><h3 id="Cookie机制原理"><a href="#Cookie机制原理" class="headerlink" title="Cookie机制原理"></a>Cookie机制原理</h3><p>客户端请求服务器时，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。而客户端浏览器会把Cookie保存起来。当浏览器再请求 服务器时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器通过检查该Cookie来获取用户状态。</p><blockquote><p>cookie 是存储于访问者的计算机中的变量。可以让我们用同一个浏览器访问同一个域名的时候共享数据。</p></blockquote><blockquote><p>HTTP 是无状态协议。简单地说，当你浏览了一个页面，然后转到同一个网站的另一个页面，服务器无法认识到这是同一个浏览器在访问同一个网站。每一次的访问，都是没有任何   关系的。</p></blockquote><h4 id="Koa-Cookie-的使用"><a href="#Koa-Cookie-的使用" class="headerlink" title="Koa Cookie 的使用"></a>Koa Cookie 的使用</h4><p>1、Koa 中设置 Cookie 的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.set(name, value, [options])</span><br></pre></td></tr></table></figure></p><p>通过options 设置 cookie name 的value :</p><table><thead><tr><th>options 名称</th><th style="text-align:left">options 值</th></tr></thead><tbody><tr><td>maxAge</td><td style="text-align:left">一个数字表示从 Date.now() 得到的毫秒数</td></tr><tr><td>expires</td><td style="text-align:left">cookie 过期的Date</td></tr><tr><td>path</td><td style="text-align:left">cookie 路径, 默认是’/‘</td></tr><tr><td>domain</td><td style="text-align:left">cookie 域名,可以访问该Cookie的域名。如果设置为“.baidu.com”，则所有以“baidu.com”结尾的域名都可以访问该Cookie；第一个字符必须为“.”</td></tr><tr><td>secure</td><td style="text-align:left">安全 cookie    默认 false，设置成 true 表示只有 https 可以访问</td></tr><tr><td>httpOnly</td><td style="text-align:left">是否只是服务器可访问 cookie, 默认是true</td></tr><tr><td>overwrite</td><td style="text-align:left">一个布尔值，表示是否覆盖以前设置的同名的 cookie (默认是 false). 如果是 true, 在同一个请求中设置相同名称的所有 Cookie（不管路径或域） 是否在设置此 Cookie 时从Set-Cookie 标头中过滤掉。</td></tr></tbody></table><h3 id="Cookie属性"><a href="#Cookie属性" class="headerlink" title="Cookie属性"></a>Cookie属性</h3><blockquote><p>name</p></blockquote><p>cookie的名字，Cookie一旦创建，名称便不可更改</p><blockquote><p>value</p></blockquote><p>cookie值</p><blockquote><p>comment</p></blockquote><p>该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明</p><blockquote><p>maxAge</p></blockquote><p>Cookie失效的时间，单位秒。</p><ul><li><p>正数，则超过maxAge秒之后失效。</p></li><li><p>负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。</p></li><li><p>为0，表示删除该Cookie。</p></li></ul><blockquote><p>path</p></blockquote><p>该Cookie的使用路径。例如：</p><ul><li>path=/，说明本域名下contextPath都可以访问该Cookie。</li><li>path=/app/，则只有contextPath为“/app”的程序可以访问该Cookie</li></ul><p>path设置时，其以“/”结尾.</p><blockquote><p>secure</p></blockquote><p>该Cookie是否仅被使用安全协议传输。这里的安全协议包括HTTPS，SSL等。默认为false。</p><h3 id="从请求中获取Cookie"><a href="#从请求中获取Cookie" class="headerlink" title="从请求中获取Cookie"></a>从请求中获取Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.get(&apos;name&apos;);</span><br></pre></td></tr></table></figure><h3 id="Cookie同源与跨域"><a href="#Cookie同源与跨域" class="headerlink" title="Cookie同源与跨域"></a>Cookie同源与跨域</h3><p>我们知道浏览器的同源策略：</p><blockquote><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。</p></blockquote><p>对于Cookie来说，Cookie的同源只关注域名，是忽略协议和端口的。所以一般情况下，<a href="https://localhost:80/和http://localhost:8080/的Cookie是共享的。" target="_blank" rel="noopener">https://localhost:80/和http://localhost:8080/的Cookie是共享的。</a></p><p>Cookie是不可跨域的；在没有经过任何处理的情况下，二级域名不同也是不行的。(wenku.baidu.com和baike.baidu.com)。</p><h3 id="Cookie数量-amp-大小限制及处理策略"><a href="#Cookie数量-amp-大小限制及处理策略" class="headerlink" title="Cookie数量&amp;大小限制及处理策略"></a>Cookie数量&amp;大小限制及处理策略</h3><table><thead><tr><th>–</th><th>IE6.0</th><th>IE7.0/8.0</th><th>Opera</th><th>FF</th><th>Safari</th><th>Chrome</th></tr></thead><tbody><tr><td>个数/个</td><td>20/域</td><td>50/域</td><td>30/域</td><td>50/域</td><td>无限制</td><td>53/域</td></tr><tr><td>大小/Byte</td><td>4095</td><td>4095</td><td>4096</td><td>4097</td><td>4097</td><td>4097</td></tr></tbody></table><h3 id="Koa-中设置中文-Cookie"><a href="#Koa-中设置中文-Cookie" class="headerlink" title="Koa 中设置中文 Cookie"></a>Koa 中设置中文 Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 转换成 base64 字符串：aGVsbG8sIHdvcmxkIQ==</span><br><span class="line">console.log(new Buffer(&apos;hello, world!&apos;).toString(&apos;base64&apos;));</span><br><span class="line"></span><br><span class="line">// 还原 base64 字符串：hello, world!</span><br><span class="line">console.log(new Buffer(&apos;aGVsbG8sIHdvcmxkIQ==&apos;, &apos;base64&apos;).toString());</span><br></pre></td></tr></table></figure><h3 id="eg"><a href="#eg" class="headerlink" title="eg"></a>eg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">var Koa=require(&apos;koa&apos;),</span><br><span class="line">    router = require(&apos;koa-router&apos;)(),</span><br><span class="line">    render = require(&apos;koa-art-template&apos;),</span><br><span class="line">    path=require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">var app=new Koa();</span><br><span class="line"></span><br><span class="line">//配置 koa-art-template模板引擎</span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, &apos;views&apos;),   // 视图的位置</span><br><span class="line">    extname: &apos;.html&apos;,  // 后缀名</span><br><span class="line">    debug: process.env.NODE_ENV !== &apos;production&apos;  //是否开启调试模式</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">router.get(&apos;/&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //正常就这样配置就可以使用了</span><br><span class="line">    /*</span><br><span class="line">     ctx.cookies.set(&apos;userinfo&apos;,&apos;zhangsan&apos;,&#123;</span><br><span class="line">        maxAge:60*1000*60</span><br><span class="line">     &#125;);</span><br><span class="line">    * */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ctx.cookies.set(&apos;userinfo&apos;,&apos;zhangsan2222&apos;,&#123;</span><br><span class="line">        maxAge:60*1000*60,</span><br><span class="line"></span><br><span class="line">       // path:&apos;/news&apos;,  /*配置可以访问的页面*/</span><br><span class="line">        //domain:&apos;.baidu.com&apos;  /*正常情况不要设置 默认就是当前域下面的所有页面都可以方法*/</span><br><span class="line"></span><br><span class="line">        httpOnly:false,  //true表示这个cookie只有服务器端可以访问，false表示客户端（js），服务器端都可以访问</span><br><span class="line">        /*</span><br><span class="line">            a.baidu.com</span><br><span class="line">            b.baidu.com  共享cookie的数据</span><br><span class="line">            express基础教程</span><br><span class="line">        * */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    let list=&#123;</span><br><span class="line">        name:&apos;张三&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    await ctx.render(&apos;index&apos;,&#123;</span><br><span class="line">        list:list</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(&apos;/about&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    ctx.cookies.set(&apos;userinfo&apos;,&apos;zhangsan33333&apos;,&#123;</span><br><span class="line">        maxAge:60*1000*60,</span><br><span class="line">        path:&apos;/news&apos;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ctx.body=&quot;这是关于我们&quot;;</span><br><span class="line">&#125;)</span><br><span class="line">//接收post提交的数据</span><br><span class="line">router.get(&apos;/news&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    var userinfo=ctx.cookies.get(&apos;userinfo&apos;);</span><br><span class="line"></span><br><span class="line">    console.log(userinfo);</span><br><span class="line">    let app=&#123;</span><br><span class="line">        name:&apos;张三11&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">    await ctx.render(&apos;news&apos;,&#123;</span><br><span class="line">        list:app</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(&apos;/shop&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    var userinfo=ctx.cookies.get(&apos;userinfo&apos;);</span><br><span class="line"></span><br><span class="line">    console.log(userinfo);</span><br><span class="line">   ctx.body=&apos;这是一个商品页面&apos;+userinfo;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(router.routes());   /*启动路由*/</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><hr><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>session 是另一种记录客户状态的机制，不同的是 Cookie 保存在客户端浏览器中，而session 保存在服务器上。</p><p>Cookie机制弥补了HTTP协议无状态的不足。在Session出现之前，基本上所有的网站都采用Cookie来跟踪会话。</p><p>与Cookie不同的是，session是以服务端保存状态的。</p><h3 id="session机制原理"><a href="#session机制原理" class="headerlink" title="session机制原理"></a>session机制原理</h3><p>当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session 对象，生成一个类似于key,value 的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带 key(cookie)，找到对应的 session(value)。 客户的信息都保存在session 中</p><p>当客户端请求创建一个session的时候，服务器会先检查这个客户端的请求里是否已包含了一个session标识 - sessionId，</p><ul><li>如果已包含这个sessionId，则说明以前已经为此客户端创建过session，服务器就按照sessionId把这个session检索出来使用（如果检索不到，可能会新建一个）</li><li>如果客户端请求不包含sessionId，则为此客户端创建一个session并且生成一个与此session相关联的sessionId</li></ul><p>sessionId的值一般是一个既不会重复，又不容易被仿造的字符串，这个sessionId将被在本次响应中返回给客户端保存。保存sessionId的方式大多情况下用的是cookie。</p><h3 id="koa-session-的使用"><a href="#koa-session-的使用" class="headerlink" title="koa-session 的使用:"></a>koa-session 的使用:</h3><blockquote><p>安装    express-session</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npminstallkoa-session --save</span><br></pre></td></tr></table></figure><blockquote><p>引入express-session</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const session = require(&apos;koa-session&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>设置官方文档提供的中间件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app.keys = [&apos;some secret hurr&apos;];   /*cookie的签名*/</span><br><span class="line">const CONFIG = &#123;</span><br><span class="line">    key: &apos;koa:sess&apos;, /** 默认 */</span><br><span class="line">    maxAge: 10000,  /*  cookie的过期时间        【需要修改】  */</span><br><span class="line">    overwrite: true, /** (boolean) can overwrite or not (default true)    没有效果，默认 */</span><br><span class="line">    httpOnly: true, /**  true表示只有服务器端可以获取cookie */</span><br><span class="line">    signed: true, /** 默认 签名 */</span><br><span class="line">    rolling: true, /** 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） 【需要修改】 */</span><br><span class="line">    renew: false, /** 快要过期的时候重新设置      【需要修改】*/</span><br><span class="line">&#125;;</span><br><span class="line">app.use(session(CONFIG, app));</span><br></pre></td></tr></table></figure><blockquote><p>使用</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//设置值 </span><br><span class="line">ctx.session.username = &quot;张三&quot;;</span><br><span class="line"></span><br><span class="line">//获取值 </span><br><span class="line">ctx.session.username</span><br></pre></td></tr></table></figure><h3 id="eg-1"><a href="#eg-1" class="headerlink" title="eg"></a>eg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var Koa=require(&apos;koa&apos;),</span><br><span class="line">    router = require(&apos;koa-router&apos;)(),</span><br><span class="line">    render = require(&apos;koa-art-template&apos;),</span><br><span class="line">    path=require(&apos;path&apos;),</span><br><span class="line">    session = require(&apos;koa-session&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app=new Koa();</span><br><span class="line"></span><br><span class="line">//配置 koa-art-template模板引擎</span><br><span class="line">render(app, &#123;</span><br><span class="line">    root: path.join(__dirname, &apos;views&apos;),   // 视图的位置</span><br><span class="line">    extname: &apos;.html&apos;,  // 后缀名</span><br><span class="line">    debug: process.env.NODE_ENV !== &apos;production&apos;  //是否开启调试模式</span><br><span class="line">&#125;);</span><br><span class="line">//配置session的中间件</span><br><span class="line">app.keys = [&apos;some secret hurr&apos;];   /*cookie的签名*/</span><br><span class="line">const CONFIG = &#123;</span><br><span class="line">    key: &apos;koa:sess&apos;, /** 默认 */</span><br><span class="line">    maxAge: 10000,  /*  cookie的过期时间        【需要修改】  */</span><br><span class="line">    overwrite: true, /** (boolean) can overwrite or not (default true)    没有效果，默认 */</span><br><span class="line">    httpOnly: true, /**  true表示只有服务器端可以获取cookie */</span><br><span class="line">    signed: true, /** 默认 签名 */</span><br><span class="line">    rolling: true, /** 在每次请求时强行设置 cookie，这将重置 cookie 过期时间（默认：false） 【需要修改】 */</span><br><span class="line">    renew: false, /** (boolean) renew session when session is nearly expired      【需要修改】*/</span><br><span class="line">&#125;;</span><br><span class="line">app.use(session(CONFIG, app));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(&apos;/&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //获取session</span><br><span class="line">    console.log(ctx.session.userinfo);</span><br><span class="line">    await ctx.render(&apos;index&apos;,&#123;</span><br><span class="line">        list:&#123;</span><br><span class="line">            name:&apos;张三&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.get(&apos;/news&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //获取session</span><br><span class="line">    console.log(ctx.session.userinfo);</span><br><span class="line">    ctx.body=&quot;登录成功&quot;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router.get(&apos;/login&apos;,async (ctx)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    //设置session</span><br><span class="line">    ctx.session.userinfo=&apos;张三&apos;;</span><br><span class="line">    ctx.body=&quot;登录成功&quot;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(router.routes());   /*启动路由*/</span><br><span class="line">app.use(router.allowedMethods());</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><h3 id="Cookie-和-Session-区别"><a href="#Cookie-和-Session-区别" class="headerlink" title="Cookie 和 Session 区别"></a>Cookie 和 Session 区别</h3><p>1、cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</p><p>2、cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗考虑到安全应当使用 session。</p><p>3、session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE。</p><p>4、单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。    </p><p>这两种是一样的；如果session不存在，就新建一个；如果是false的话，标识如果不存在就返回null；</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>session的生命周期指的是创建session对象到销毁的过程。会依据session对象设置的存活时间，在达到session时间后将session对象销毁。session生成后，只要用户继续访问，服务器就会更新session的最后访问时间，并维护该session。</p><p>之前在单进程应用中，session我一般是存在内存中的，不会做持久化操作或者说使用三方的服务来存session信息，如<strong>redis</strong>。但是在分布式场景下，这种存在本机内存中的方式显然是不适用的，因为session无法共享。这个后面说。</p><h3 id="session的有效期"><a href="#session的有效期" class="headerlink" title="session的有效期"></a>session的有效期</h3><p>session一般在内存中存放，内存空间本身大小就有一定的局限性，因此session需要采用一种过期删除的机制来确保session信息不会一直累积，来防止内存溢出的发生。</p><p>session的超时时间可以通过maxInactiveInterval属性来设置。</p><p>如果我们想让session失效的话，也可以当通过调用session的invalidate()来完成。</p><h3 id="分布式session"><a href="#分布式session" class="headerlink" title="分布式session"></a>分布式session</h3><p>首先是为什么会有这样的概念出现？</p><p>先考虑这样一个问题，现在我的应用需要部署在3台机器上。是不是出现这样一种情况，我第一次登陆，请求去了机器1，然后再机器1上创建了一个session；但是我第二次访问时，请求被路由到机器2了，但是机器2上并没有我的session信息，所以得重新登录。当然这种可以通过nginx的IP HASH负载策略来解决。对于同一个IP请求都会去同一个机器。</p><p>但是业务发展的越来越大，拆分的越来越多，机器数不断增加；很显然那种方案就不行了。那么这个时候就需要考虑是不是应该将session信息放在一个独立的机器上，所以分布式session要解决的问题其实就是分布式环境下的session共享的问题。<br> <img src="/2018/08/25/Koa-session和cookie/2.webp" alt=""><br>上图中的关于session独立部署的方式有很多种，可以是一个独立的数据库服务，也可以是一个缓存服务(redis，目前比较常用的一种方式，即使用Redis来作为session缓存服务器)。</p>]]></content>
      
      
      
        <tags>
            
            <tag> koa </tag>
            
            <tag> session </tag>
            
            <tag> cookie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>async 并发执行和继发执行</title>
      <link href="/2018/08/24/async-%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BB%A7%E5%8F%91%E6%89%A7%E8%A1%8C/"/>
      <url>/2018/08/24/async-%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E5%92%8C%E7%BB%A7%E5%8F%91%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p><strong> 面试题继发执行 : 1s后执行10，等1s后输出20，再等1s后输出30 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function Pro(val) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">resolve(val)</span><br><span class="line">&#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function log(arrs) &#123;</span><br><span class="line">for(const item of arrs) &#123;</span><br><span class="line">var response = await Pro(item);</span><br><span class="line">console.log(response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log([10, 20, 30])</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><hr><p><strong>问题：给定一个 URL 数组，如何实现接口的继发和并发？</strong></p><h3 id="async-继发实现："><a href="#async-继发实现：" class="headerlink" title="async 继发实现："></a>async 继发实现：</h3><h4 id="继发一"><a href="#继发一" class="headerlink" title="继发一"></a>继发一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function loadData() &#123;</span><br><span class="line">  var res1 = await fetch(url1);</span><br><span class="line">  var res2 = await fetch(url2);</span><br><span class="line">  var res3 = await fetch(url3);</span><br><span class="line">  return&quot;whew all done&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继发二"><a href="#继发二" class="headerlink" title="继发二"></a>继发二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async function loadData(urls) &#123;</span><br><span class="line">  for (const url of urls) &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    console.log(await response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async-并发实现："><a href="#async-并发实现：" class="headerlink" title="async 并发实现："></a>async 并发实现：</h3><h4 id="并发一"><a href="#并发一" class="headerlink" title="并发一"></a>并发一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function loadData() &#123;</span><br><span class="line">  var res = awaitPromise.all([fetch(url1), fetch(url2), fetch(url3)]);</span><br><span class="line">  return&quot;whew all done&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="并发二"><a href="#并发二" class="headerlink" title="并发二"></a>并发二</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function loadData(urls) &#123;</span><br><span class="line">  // 并发读取 url</span><br><span class="line">  const textPromises = urls.map(async url =&gt; &#123;</span><br><span class="line">    const response = await fetch(url);</span><br><span class="line">    return response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 按次序输出</span><br><span class="line">  for (const textPromise of textPromises) &#123;</span><br><span class="line">    console.log(await textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> async </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue批量异步更新与nextTick原理</title>
      <link href="/2018/08/20/Vue%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%8EnextTick%E5%8E%9F%E7%90%86/"/>
      <url>/2018/08/20/Vue%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E4%B8%8EnextTick%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ol><li>异步更新</li></ol><p>我们在依赖收集原理的响应式化方法 defineReactive 中的 setter 访问器中有派发更新 dep.notify() 方法。</p><p>这个方法会挨个通知在 dep 的 subs 中收集的订阅自己变动的watchers执行update。</p><p>一起来看看 update 方法的实现：</p><pre><code>// src/core/observer/watcher.js/* Subscriber接口，当依赖发生改变的时候进行回调 */update() {  if (this.computed) {    // 一个computed watcher有两种模式：activated lazy(默认)    // 只有当它被至少一个订阅者依赖时才置activated，这通常是另一个计算属性或组件的render function    if (this.dep.subs.length === 0) {       // 如果没人订阅这个计算属性的变化      // lazy时，我们希望它只在必要时执行计算，所以我们只是简单地将观察者标记为dirty      // 当计算属性被访问时，实际的计算在this.evaluate()中执行      this.dirty = true    } else {      // activated模式下，我们希望主动执行计算，但只有当值确实发生变化时才通知我们的订阅者      this.getAndInvoke(() =&gt; {        this.dep.notify()     // 通知渲染watcher重新渲染，通知依赖自己的所有watcher执行update      })    }  } else if (this.sync) {      // 同步    this.run()  } else {    queueWatcher(this)        // 异步推送到调度者观察者队列中，下一个tick时调用  }}</code></pre><p>如果不是 computed watcher 也非 sync 会把调用update的当前watcher推送到调度者队列中，下一个tick时调用，看看 queueWatcher ：</p><pre><code>// src/core/observer/scheduler.js/* 将一个观察者对象push进观察者队列，在队列中已经存在相同的id则 * 该watcher将被跳过，除非它是在队列正被flush时推送 */export function queueWatcher (watcher: Watcher) {  const id = watcher.id  if (has[id] == null) {     // 检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验    has[id] = true    queue.push(watcher)      // 如果没有正在flush，直接push到队列中    if (!waiting) {          // 标记是否已传给nextTick      waiting = true      nextTick(flushSchedulerQueue)    }  }}/* 重置调度者状态 */function resetSchedulerState () {  queue.length = 0  has = {}  waiting = false}</code></pre><p>这里使用了一个 has 的哈希map用来检查是否当前watcher的id是否存在，若已存在则跳过。</p><p>不存在则就push到 queue 队列中并标记哈希表has，用于下次检验，防止重复添加。</p><p>这就是一个去重的过程，比每次查重都要去queue中找要文明，在渲染的时候就不会重复 patch 相同watcher的变化。</p><p>这样就算同步修改了一百次视图中用到的data，异步 patch 的时候也只会更新最后一次修改。</p><p>这里的 waiting 方法是用来标记 flushSchedulerQueue 是否已经传递给 nextTick 的标记位。</p><p>如果已经传递则只push到队列中不传递 flushSchedulerQueue 给 nextTick。</p><p>等到 resetSchedulerState 重置调度者状态的时候 waiting 会被置回 false 允许 flushSchedulerQueue 被传递给下一个tick的回调。</p><p>总之保证了 flushSchedulerQueue 回调在一个tick内只允许被传入一次。</p><p>来看看被传递给 nextTick 的回调 flushSchedulerQueue 做了什么：</p><pre><code>// src/core/observer/scheduler.js/* nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers */function flushSchedulerQueue () {  flushing = true  let watcher, id  queue.sort((a, b) =&gt; a.id - b.id)                    // 排序  for (index = 0; index &lt; queue.length; index++) {     // 不要将length进行缓存    watcher = queue[index]    if (watcher.before) {         // 如果watcher有before则执行      watcher.before()    }    id = watcher.id    has[id] = null                // 将has的标记删除    watcher.run()                 // 执行watcher    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) {  // 在dev环境下检查是否进入死循环      circular[id] = (circular[id] || 0) + 1     // 比如user watcher订阅自己的情况      if (circular[id] &gt; MAX_UPDATE_COUNT) {     // 持续执行了一百次watch代表可能存在死循环        warn()                                  // 进入死循环的警告        break      }    }  }  resetSchedulerState()           // 重置调度者状态  callActivatedHooks()            // 使子组件状态都置成active同时调用activated钩子  callUpdatedHooks()              // 调用updated钩子}</code></pre><p>在 nextTick 方法中执行 flushSchedulerQueue 方法，这个方法挨个执行 queue 中的watcher的 run 方法。</p><p>我们看到在首先有个 queue.sort() 方法把队列中的watcher按id从小到大排了个序，这样做可以保证：</p><ol><li><p>组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。</p></li><li><p>一个组件的user watchers(侦听器watcher)比render watcher先运行，因为user watchers往往比render watcher更早创建</p></li><li><p>如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过</p></li></ol><p>在挨个执行队列中的for循环中，index &lt; queue.length 这里没有将length进行缓存。</p><p>因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue。</p><p>那么数据的修改从model层反映到view的过程：数据更改 -&gt; setter -&gt; Dep -&gt; Watcher -&gt; nextTick -&gt; patch -&gt; 更新视图</p><ol start="2"><li>nextTick原理</li></ol><p><strong>2.1 宏任务/微任务</strong></p><p>这里就来看看包含着每个watcher执行的方法被作为回调传入 nextTick 之后，nextTick 对这个方法做了什么。</p><p>不过首先要了解一下浏览器中的 EventLoop、macro task、micro task几个概念。</p><p>不了解可以参考一下 JS与Node.js中的事件循环 这篇文章，这里就用一张图来表明一下后两者在主线程中的执行关系：</p><p><img src="/2018/08/20/Vue批量异步更新与nextTick原理/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt=""></p><p>解释一下，当主线程执行完同步任务后：</p><ol><li><p>引擎首先从macrotask queue中取出第一个任务，执行完毕后，将microtask queue中的所有任务取出，按顺序全部执行；</p></li><li><p>然后再从macrotask queue中取下一个，执行完毕后，再次将microtask queue中的全部取出；</p></li><li><p>循环往复，直到两个queue中的任务都取完。</p></li></ol><p>浏览器环境中常见的异步任务种类，按照优先级：</p><ul><li>macro task ：</li></ul><p>同步代码、setImmediate、MessageChannel、setTimeout/setInterval</p><ul><li>micro task：</li></ul><p>Promise.then、MutationObserver</p><p>有的文章把 micro task 叫微任务，macro task 叫宏任务，因为这两个单词拼写太像了 -。- ，所以后面的注释多用中文表示~</p><p>先来看看源码中对micro task与macro task 的实现： macroTimerFunc、microTimerFunc</p><pre><code>// src/core/util/next-tick.jsconst callbacks = []     // 存放异步执行的回调let pending = false      // 一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送/* 挨个同步执行callbacks中回调 */function flushCallbacks() {  pending = false  const copies = callbacks.slice(0)  callbacks.length = 0  for (let i = 0; i &lt; copies.length; i++) {    copies[i]()  }}let microTimerFunc        // 微任务执行方法let macroTimerFunc        // 宏任务执行方法let useMacroTask = false  // 是否强制为宏任务，默认使用微任务// 宏任务if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) {  macroTimerFunc = () =&gt; {    setImmediate(flushCallbacks)  }} else if (typeof MessageChannel !== &apos;undefined&apos; &amp;&amp; (  isNative(MessageChannel) ||  MessageChannel.toString() === &apos;[object MessageChannelConstructor]&apos;  // PhantomJS)) {  const channel = new MessageChannel()  const port = channel.port2  channel.port1.onmessage = flushCallbacks  macroTimerFunc = () =&gt; {    port.postMessage(1)  }} else {  macroTimerFunc = () =&gt; {    setTimeout(flushCallbacks, 0)  }}// 微任务if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) {  const p = Promise.resolve()  microTimerFunc = () =&gt; {    p.then(flushCallbacks)  }} else {  microTimerFunc = macroTimerFunc      // fallback to macro}</code></pre><p>flushCallbacks 这个方法就是挨个同步的去执行callbacks中的回调函数们，callbacks中的回调函数是在调用 nextTick 的时候添加进去的；</p><p>那么怎么去使用 micro task 与 macro task 去执行 flushCallbacks 呢。</p><p>这里他们的实现 macroTimerFunc、microTimerFunc 使用浏览器中宏任务/微任务的API对flushCallbacks 方法进行了一层包装。</p><p>比如宏任务方法 macroTimerFunc=()=&gt;{ setImmediate(flushCallbacks) }，这样在触发宏任务执行的时候 macroTimerFunc() 就可以在浏览器中的下一个宏任务loop的时候消费这些保存在callbacks数组中的回调了，微任务同理。</p><p>同时也可以看出传给 nextTick 的异步回调函数是被压成了一个同步任务在一个tick执行完的，而不是开启多个异步任务。</p><p>注意这里有个比较难理解的地方，第一次调用 nextTick 的时候 pending 为false。</p><p>此时已经push到浏览器event loop中一个宏任务或微任务的task，如果在没有flush掉的情况下继续往callbacks里面添加。</p><p>那么在执行这个占位queue的时候会执行之后添加的回调，所以 macroTimerFunc、microTimerFunc 相当于task queue的占位。</p><p>以后 pending 为true则继续往占位queue里面添加，event loop轮到这个task queue的时候将一并执行。</p><p>执行 flushCallbacks 时 pending 置false，允许下一轮执行 nextTick 时往event loop占位。</p><p>可以看到上面 macroTimerFunc 与 microTimerFunc 进行了在不同浏览器兼容性下的平稳退化，或者说降级策略：</p><p>1、macroTimerFunc ：</p><p>setImmediate -&gt; MessageChannel -&gt; setTimeout。</p><p>首先检测是否原生支持 setImmediate，这个方法只在 IE、Edge 浏览器中原生实现。</p><p>然后检测是否支持 MessageChannel，如果对 MessageChannel 不了解可以参考一下这篇文章。还不支持的话最后使用setTimeout；</p><p>为什么优先使用 setImmediate 与 MessageChannel 而不直接使用 setTimeout 呢。</p><p>是因为HTML5规定setTimeout执行的最小延时为4ms，而嵌套的timeout表现为10ms。</p><p>为了尽可能快的让回调执行，没有最小延时限制的前两者显然要优于 setTimeout。</p><p>2、microTimerFunc：</p><p>Promise.then -&gt; macroTimerFunc 。</p><p>首先检查是否支持 Promise，如果支持的话通过 Promise.then 来调用 flushCallbacks 方法。</p><p>否则退化为 macroTimerFunc ；</p><p>vue2.5之后 nextTick 中因为兼容性原因删除了微任务平稳退化的 MutationObserver 的方式。</p><p><strong>2.2 nextTick实现</strong></p><p>最后来看看我们平常用到的 nextTick 方法到底是如何实现的：</p><pre><code>// src/core/util/next-tick.jsexport function nextTick(cb?: Function, ctx?: Object) {  let _resolve  callbacks.push(() =&gt; {    if (cb) {      try {        cb.call(ctx)      } catch (e) {        handleError(e, ctx, &apos;nextTick&apos;)      }    } else if (_resolve) {      _resolve(ctx)    }  })  if (!pending) {    pending = true    if (useMacroTask) {      macroTimerFunc()    } else {      microTimerFunc()    }  }  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) {    return new Promise(resolve =&gt; {      _resolve = resolve    })  }}/* 强制使用macrotask的方法 */export function withMacroTask(fn: Function): Function {  return fn._withTask || (fn._withTask = function() {    useMacroTask = true    const res = fn.apply(null, arguments)    useMacroTask = false    return res  })}</code></pre><p>nextTick 在这里分为三个部分，我们一起来看一下；</p><p>1、首先 nextTick 把传入的 cb 回调函数用 try-catch 包裹后放在一个匿名函数中推入callbacks数组中。</p><p>这么做是因为防止单个 cb 如果执行错误不至于让整个JS线程挂掉。</p><p>每个 cb 都包裹是防止这些回调函数如果执行错误不会相互影响，比如前一个抛错了后一个仍然可以执行。</p><p>2、然后检查 pending 状态，这个跟之前介绍的 queueWatcher 中的 waiting 是一个意思。</p><p>它是一个标记位，一开始是 false 在进入</p><p>macroTimerFunc、microTimerFunc方法前被置为 true。</p><p>因此下次调用 nextTick 就不会进入</p><p>macroTimerFunc、microTimerFunc方法。</p><p>这两个方法中会在下一个 macro/micro tick 时候 flushCallbacks 异步的去执行callbacks队列中收集的任务，而 flushCallbacks 方法在执行一开始会把 pending 置 false。</p><p>因此下一次调用 nextTick 时候又能开启新一轮的 macroTimerFunc、microTimerFunc，这样就形成了vue中的 event loop。</p><p>3、最后检查是否传入了 cb。</p><p>因为 nextTick 还支持Promise化的调用：nextTick().then(() =&gt; {})。</p><p>所以如果没有传入 cb 就直接return了一个Promise实例，并且把resolve传递给_resolve。</p><p>这样后者执行的时候就跳到我们调用的时候传递进 then 的方法中。</p><p>Vue源码中 next-tick.js 文件还有一段重要的注释，这里就翻译一下：</p><p>在vue2.5之前的版本中，nextTick基本上基于 micro task 来实现的。</p><p>但是在某些情况下 micro task 具有太高的优先级，并且可能在连续顺序事件之间（例如＃4521，＃6690）或者甚至在同一事件的事件冒泡过程中之间触发（＃6566）。</p><p>但是如果全部都改成 macro task，对一些有重绘和动画的场景也会有性能影响，如 issue #6813。</p><p>vue2.5之后版本提供的解决办法是默认使用 micro task，但在需要时（例如在v-on附加的事件处理程序中）强制使用 macro task。</p><p>为什么默认优先使用 micro task 呢。</p><p>是利用其高优先级的特性，保证队列中的微任务在一次循环全部执行完毕。</p><p>强制 macro task 的方法是在绑定 DOM 事件的时候。</p><p>默认会给回调的 handler 函数调用 withMacroTask 方法做一层包装 handler = withMacroTask(handler)。</p><p>它保证整个回调函数执行过程中，遇到数据状态的改变，这些改变都会被推到 macro task 中。</p><p>以上实现在src/platforms/web/runtime/modules/events.js</p><p>的 add 方法中，可以自己看一看具体代码。</p><p>刚好在写这篇文章的时候思否上有人问了个问题 vue 2.4 和2.5 版本的@input事件不一样。</p><p>这个问题的原因也是因为2.5之前版本的DOM事件采用 micro task ，而之后采用 macro task。</p><p>解决的途径参考 &lt; Vue.js 升级踩坑小记&gt; 中介绍的几个办法。</p><p>这里就提供一个在mounted钩子中用 addEventListener 添加原生事件的方法来实现。</p><p>参见 CodePen</p><p>（<a href="https://codepen.io/SHERlocked93/pen/WKGNKJ）。" target="_blank" rel="noopener">https://codepen.io/SHERlocked93/pen/WKGNKJ）。</a></p><ol start="3"><li>一个例子</li></ol><p>说这么多，不如来个例子，执行参见 CodePen</p><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;span id=&apos;name&apos; ref=&apos;name&apos;&gt;{{ name }}&lt;/span&gt;  &lt;button @click=&apos;change&apos;&gt;change name&lt;/button&gt;  &lt;div id=&apos;content&apos;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;  new Vue({    el: &apos;#app&apos;,    data() {      return {        name: &apos;SHERlocked93&apos;      }    },    methods: {      change() {        const $name = this.$refs.name        this.$nextTick(() =&gt; console.log(&apos;setter前：&apos; + $name.innerHTML))        this.name = &apos; name改喽 &apos;        console.log(&apos;同步方式：&apos; + this.$refs.name.innerHTML)        setTimeout(() =&gt; this.console(&quot;setTimeout方式：&quot; + this.$refs.name.innerHTML))        this.$nextTick(() =&gt; console.log(&apos;setter后：&apos; + $name.innerHTML))        this.$nextTick().then(() =&gt; console.log(&apos;Promise方式：&apos; + $name.innerHTML))      }    }  })&lt;/script&gt;</code></pre><p>执行以下看看结果：</p><pre><code>同步方式：SHERlocked93 setter前：SHERlocked93 setter后：name改喽 Promise方式：name改喽 setTimeout方式：name改喽</code></pre><p>为什么是这样的结果呢，解释一下：</p><ol><li><p>同步方式： 当把data中的name修改之后，此时会触发name的 setter 中的 dep.notify 通知依赖本data的render watcher去 update，update 会把 flushSchedulerQueue 函数传递给 nextTick，render watcher在 flushSchedulerQueue 函数运行时 watcher.run 再走 diff -&gt; patch 那一套重渲染 re-render 视图，这个过程中会重新依赖收集，这个过程是异步的；所以当我们直接修改了name之后打印，这时异步的改动还没有被 patch 到视图上，所以获取视图上的DOM元素还是原来的内容。</p></li><li><p>setter前： setter前为什么还打印原来的是原来内容呢，是因为 nextTick 在被调用的时候把回调挨个push进callbacks数组，之后执行的时候也是 for 循环出来挨个执行，所以是类似于队列这样一个概念，先入先出；在修改name之后，触发把render watcher填入 schedulerQueue 队列并把他的执行函数 flushSchedulerQueue 传递给 nextTick ，此时callbacks队列中已经有了 setter前函数 了，因为这个 cb 是在 setter前函数 之后被push进callbacks队列的，那么先入先出的执行callbacks中回调的时候先执行 setter前函数，这时并未执行render watcher的 watcher.run，所以打印DOM元素仍然是原来的内容。</p></li><li><p>setter后： setter后这时已经执行完 flushSchedulerQueue，这时render watcher已经把改动 patch 到视图上，所以此时获取DOM是改过之后的内容。</p></li><li><p>Promise方式： 相当于 Promise.then 的方式执行这个函数，此时DOM已经更改。</p></li><li><p>setTimeout方式： 最后执行macro task的任务，此时DOM已经更改。</p></li></ol><p>注意，在执行 setter前函数 这个异步任务之前，同步的代码已经执行完毕。</p><p>异步的任务都还未执行，所有的 $nextTick 函数也执行完毕。</p><p>所有回调都被push进了callbacks队列中等待执行，所以在setter前函数执行的时候。</p><p>此时callbacks队列是这样的：</p><p>[setter前函数，</p><p>flushSchedulerQueue，</p><p>setter后函数，</p><p>Promise方式函数]。</p><p>它是一个micro task队列，执行完毕之后执行macro task setTimeout，所以打印出上面的结果。</p><p>另外，如果浏览器的宏任务队列里面有setImmediate、MessageChannel、setTimeout/setInterval 各种类型的任务。</p><p>那么会按照上面的顺序挨个按照添加进event loop中的顺序执行，所以如果浏览器支持MessageChannel。</p><p>nextTick执行的是macroTimerFunc。</p><p>那么如果 macrotask queue 中同时有 nextTick 添加的任务和用户自己添加的 setTimeout 类型的任务。</p><p>会优先执行 nextTick 中的任务，因为MessageChannel 的优先级比 setTimeout的高，setImmediate 同理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 事件循环 </tag>
            
            <tag> vue </tag>
            
            <tag> nextTick </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6之promise、generator+co、async+await手写promise</title>
      <link href="/2018/08/20/ES6%E4%B9%8Bpromise%E3%80%81generator-co%E3%80%81async-await%E6%89%8B%E5%86%99promise/"/>
      <url>/2018/08/20/ES6%E4%B9%8Bpromise%E3%80%81generator-co%E3%80%81async-await%E6%89%8B%E5%86%99promise/</url>
      
        <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>传统的解决代码单线程执行的方案是<code>回调函数和事件</code>。这是个解决问题的方案，但是会造成回调地狱。</p><p>异步编程是优化代码逻辑提高代码易读性的关键。</p><p>目前通用的异步编程方法有三种：</p><ol><li>Promise</li><li>generator+co</li><li>async+await</li></ol><p>这三种方法我都经常在用，但是对它们的原理却一知半解。于是想炒个冷饭从头到尾理一遍，梳理一下它们之间的关系。</p><h4 id="二、Promise"><a href="#二、Promise" class="headerlink" title="二、Promise"></a>二、Promise</h4><h5 id="2-1-原理"><a href="#2-1-原理" class="headerlink" title="2.1 原理"></a>2.1 原理</h5><p>Promise对象是一个构造函数，用来生成Promise实例。<br>Promise对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。<br>Promise函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是Promise中定义的两个函数，在运行自定义函数时返回。<br><code>resolve</code>函数将Promise对象的状态从 <code>pending</code> 变为<code>resolved</code>,<code>reject</code>将Promise对象的状态从 <code>pending</code> 变为<code>rejected</code><br>Promise的原型链上定义了then方法，提供两个回调函数分别捕获resolve、reject返回的值。</p><h5 id="2-2-静态方法"><a href="#2-2-静态方法" class="headerlink" title="2.2 静态方法"></a>2.2 静态方法</h5><p>方法描述<code>Promise.resolve(promise)</code>;返回 <code>promise</code>（仅当 <code>promise.constructor == Promise</code> 时）<code>Promise.resolve(thenable)</code>;<br>从<code>thenable</code> 中生成一个新<code>promise</code>。<code>thenable</code> 是具有 <code>then()</code> 方法的类似于 <code>promise</code> 的对象。<code>Promise.resolve(obj)</code>;<br>在此情况下，生成一个<code>promise</code> 并在执行时返回 <code>obj。Promise.reject(obj)</code>;生成一个<code>promise</code> 并在拒绝时返回 obj。<br>为保持一致和调试之目的（例如堆叠追踪）， obj 应为 <code>instanceof Error</code>。<br><code>Promise.all(array)</code>;生成一个<code>promise</code>，<br>该 promise 在数组中各项执行时执行，在任意一项拒绝时拒绝。<code>Promise.race(array)</code>;<br>生成一个 Promise，该 Promise 在任意项执行时执行，或在任意项拒绝时拒绝，以最先发生的为准。<br>sample 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">    console.log(&apos;hello&apos;)</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        reject(&apos;1212&apos;)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(data=&gt; &#123;</span><br><span class="line">    console.log(&apos;success&apos;+data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    console.log(&apos;err&apos;+err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(data=&gt; &#123;</span><br><span class="line">    console.log(&apos;success&apos;+data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    console.log(&apos;err&apos;+err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>terminal:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">err1212</span><br><span class="line">err1212</span><br></pre></td></tr></table></figure></p><p>sample 1 中新建了一个Promise实例，定时1S后使用reject方法，将Promise实例的状态从pending变成rejected，触发then的err捕捉回调函数。</p><p>在sample 1 中调用then方法，并不会马上执行回调。是等待实例中状态改变后才会执行。这一点和<code>发布订阅</code>模式很类似。</p><p>sample 2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">let event = &#123;</span><br><span class="line">    arr:[],</span><br><span class="line">    result:[],</span><br><span class="line">    on(fn)&#123;</span><br><span class="line">        this.arr.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    emit(data)&#123;</span><br><span class="line">        this.result.push(data)</span><br><span class="line">        this.arr.forEach(fn=&gt;fn(this.result))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event.on(function (data) &#123;</span><br><span class="line">    if(data.length === 2)&#123;</span><br><span class="line">        console.log(data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(&apos;1.txt&apos;,&apos;utf8&apos;,function (err,data) &#123;</span><br><span class="line">    event.emit(data)</span><br><span class="line">&#125;)</span><br><span class="line">fs.readFile(&apos;2.txt&apos;,&apos;utf8&apos;,function (err,data) &#123;</span><br><span class="line">    event.emit(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>smaple2 中将结果data放入暂存数组中，在执行接听函数的时候返回。</p><h5 id="2-3-简写Promise源码"><a href="#2-3-简写Promise源码" class="headerlink" title="2.3 简写Promise源码"></a>2.3 简写Promise源码</h5><p>通过之前的例子和对发布订阅模式的理解，我们可以大概写出Promise实例的基本功能：</p><p>code 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos;</span><br><span class="line">    self.onResovedCallbacks = []</span><br><span class="line">    self.onRejectedCallbacks = []</span><br><span class="line">    function resolve(data) &#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">            self.value = data</span><br><span class="line">            self.status = &apos;resolved&apos;</span><br><span class="line">            self.onResovedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function reject(reason) &#123;</span><br><span class="line">        if(self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = &apos;reject&apos;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //如果函数执行时发生异常</span><br><span class="line">    try&#123;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;catch (e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.then = function (onFulfilled,onRejected) &#123;</span><br><span class="line">    let self = this</span><br><span class="line">    if(self.status === &apos;pending&apos;)&#123;</span><br><span class="line">        self.onResovedCallbacks.push(()=&gt;&#123;</span><br><span class="line">            onFulfilled(self.value)</span><br><span class="line">        &#125;)</span><br><span class="line">        self.onRejectedCallbacks.push(()=&gt;&#123;</span><br><span class="line">            onRejected(self.reason)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;elseif(self.status === &apos;resolved&apos;)&#123;</span><br><span class="line">        onFulfilled(self.value)</span><br><span class="line">    &#125;elseif(self.status === &apos;reject&apos;)&#123;</span><br><span class="line">        onRejected(self.reason)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure></p><ul><li><p>函数内部变量</p></li><li><p>status：储存Promise的状态</p></li><li>onResovedCallbacks：储存Promise pending状态下成功回调函数</li><li>onRejectedCallbacks：储存Promise pending状态下失败回调函数</li><li>resolve函数</li><li><p>reject函数</p></li><li><p>Promise.prototype.then</p></li><li><p>根据实例状态执行响应的回调</p></li><li>status == pending使用发布订阅模式储存回调函数。</li></ul><h5 id="2-4-Promise用法简述"><a href="#2-4-Promise用法简述" class="headerlink" title="2.4 Promise用法简述"></a>2.4 Promise用法简述</h5><ol><li><p>如果一个promise执行完后,返回的还是一个Promise对象,会把这个promise的执行结果,传递给下一个then中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">functionread(filePath,encoding) &#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        fs.readFile(filePath,encoding,(err,data)=&gt; &#123;</span><br><span class="line">            if(err) reject(err)</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;1.txt&apos;,&apos;utf8&apos;).then(</span><br><span class="line">    f1=&gt;read(f1,&apos;utf8&apos;) // 1</span><br><span class="line">).then(</span><br><span class="line">    data=&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class="line">    err=&gt; console.log(&apos;rejected: &apos;,err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>如果then中返回的不是promise，是一个普通值,会将这个普通值作为下一个then的返回结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> ......</span><br><span class="line"> </span><br><span class="line">read(&apos;1.txt&apos;,&apos;utf8&apos;).then(</span><br><span class="line">    f1=&gt;read(f1,&apos;utf8&apos;)</span><br><span class="line">).then(</span><br><span class="line">    return 123 //2</span><br><span class="line">).then(</span><br><span class="line">    data=&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class="line">    err=&gt; console.log(&apos;rejected: &apos;,err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>如果当前then中失败了会走下一个then的失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> ......</span><br><span class="line"> </span><br><span class="line">read(&apos;1.txt&apos;,&apos;utf8&apos;).then(</span><br><span class="line">    f1=&gt;read(f1,&apos;utf8&apos;)</span><br><span class="line">).then(</span><br><span class="line">    return 123</span><br><span class="line">).then(</span><br><span class="line">    throw new Error(&apos;出错&apos;) //3</span><br><span class="line">).then(</span><br><span class="line">    data=&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class="line">    err=&gt; console.log(&apos;rejected: &apos;,err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>如果返回的是undefined不管当前是失败还是成功，都会走下一次成功。</p></li><li>catch是错误没有处理的情况下会走。</li><li>then中可以不写。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> ......</span><br><span class="line"> </span><br><span class="line">read(&apos;1.txt&apos;,&apos;utf8&apos;).then(</span><br><span class="line">    f1=&gt;read(f1,&apos;utf8&apos;)</span><br><span class="line">).then(</span><br><span class="line">    return 123</span><br><span class="line">).then(</span><br><span class="line">    throw new Error(&apos;出错&apos;) </span><br><span class="line">).then() //6</span><br><span class="line"> .then(</span><br><span class="line">    data=&gt; console.log(&apos;resolved:&apos;,comments)</span><br><span class="line">    err=&gt; console.log(&apos;rejected: &apos;,err)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><p>这些用法中最重要的是promise的then链式调用。<br>可以大致猜到，旧Promise的then方法返回的是一个新的Promise对象。</p><p>参考<a href="https://link.juejin.im?target=https%3A%2F%2Fpromisesaplus.com%2F" target="_blank" rel="noopener">Promises/A+规范</a>，可以完善手写的Promise源码使其支持promise的静态方法和调用规则。</p><p>code 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor) &#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.value = undefined</span><br><span class="line">    self.reason = undefined</span><br><span class="line">    self.status = &apos;pending&apos;</span><br><span class="line">    self.onResovedCallbacks = []</span><br><span class="line">    self.onRejectedCallbacks = []</span><br><span class="line">    function resolve(value) &#123;</span><br><span class="line">        if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.value = value</span><br><span class="line">            self.status = &apos;resolved&apos;</span><br><span class="line">            self.onResovedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reject(reason) &#123;</span><br><span class="line">        if (self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.reason = reason</span><br><span class="line">            self.status = &apos;rejected&apos;</span><br><span class="line">            self.onRejectedCallbacks.forEach(fn=&gt;fn())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果函数执行时发生异常</span><br><span class="line">    try &#123;</span><br><span class="line">        executor(resolve, reject)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">    //If promise and x refer to the same object, reject promise with a TypeError as the reason.</span><br><span class="line">    if (promise2 === x) &#123;</span><br><span class="line">        return reject(new TypeError(&apos;chaining cycle&apos;))</span><br><span class="line">    &#125;</span><br><span class="line">    let called</span><br><span class="line">    //2.3.3.Otherwise, if x is an object or function,</span><br><span class="line">    if (x !== null &amp;&amp; (typeof x == &apos;object&apos; || typeof x === &apos;function&apos;)) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            letthen = x.then</span><br><span class="line">            //2.3.3.3.If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:</span><br><span class="line">            //2.3.3.3.3.If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</span><br><span class="line">            if (typeof then === &apos;function&apos;) &#123;</span><br><span class="line">                then.call(x, y=&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    //递归直到解析成普通值为止</span><br><span class="line">                    //2.3.3.1.If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject)</span><br><span class="line">                &#125;, err=&gt; &#123;</span><br><span class="line">                    if (called) return;</span><br><span class="line">                    called = true;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called = true;</span><br><span class="line">            //2.3.3.3.If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //If x is not an object or function, fulfill promise with x.</span><br><span class="line">        resolve(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//then调用的时候 都是异步调用 (原生的then的成功或者失败 是一个微任务)</span><br><span class="line">Promise.prototype.then = function (onFulfilled, onRejected) &#123;</span><br><span class="line">    //成功和失败的函数 是可选参数</span><br><span class="line">    onFulfilled = typeof onFulfilled === &apos;function&apos; ? onFulfilled : val=&gt;val;</span><br><span class="line">    onRejected = typeof onRejected === &apos;function&apos; ? onRejected : (e)=&gt; &#123;throw e&#125;;</span><br><span class="line">    let self = this</span><br><span class="line">    let promise2;</span><br><span class="line">    promise2 = new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">        if (self.status === &apos;resolved&apos;) &#123;</span><br><span class="line">            setTimeout(()=&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x = onFulfilled(self.value)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 0)</span><br><span class="line">        &#125; elseif (self.status === &apos;rejected&apos;) &#123;</span><br><span class="line">            setTimeout(()=&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    let x = onRejected(self.reason)</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    reject(e)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 0)</span><br><span class="line">        &#125; elseif (self.status === &apos;pending&apos;) &#123;</span><br><span class="line">            self.onResovedCallbacks.push(()=&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onFulfilled(self.value)</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        //当执行成功回调的时候,可能会出现异常,那就用这个异常作为promise2的错误结果</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 0)</span><br><span class="line">            &#125;)</span><br><span class="line">            self.onRejectedCallbacks.push(()=&gt; &#123;</span><br><span class="line">                setTimeout(()=&gt; &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        let x = onRejected(self.reason)</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject)</span><br><span class="line">                    &#125; catch (e) &#123;</span><br><span class="line">                        reject(e)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, 0)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise2</span><br><span class="line">&#125;</span><br><span class="line">//setTimeout (规范要求)</span><br><span class="line"></span><br><span class="line">Promise.reject = function (reason) &#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.resolve = function (value) &#123;</span><br><span class="line">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.prototype.catch = function (onReject) &#123;</span><br><span class="line">    return this.then(null,onReject)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.defer = Promise.deferred = function () &#123;</span><br><span class="line">    let dfd = &#123;&#125;</span><br><span class="line">    dfd.promise = new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">        dfd.resolve = resolve</span><br><span class="line">        dfd.reject = reject</span><br><span class="line">    &#125;)</span><br><span class="line">    return dfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = Promise</span><br></pre></td></tr></table></figure></p><ol><li>为了支持then的链式调用，Promise.then.prototype中返回一个新的Promise对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return p2 = new Promise()</span><br></pre></td></tr></table></figure></li></ol><p>2.增加resolvePromise方法，处理旧Promise的回调函数的结果x，根据x的类型，分别调用新promise对象的resolve/reject方法。</p><ul><li>是普通值用resolve方法返回</li><li>是函数或者对象就继续用resolvePromise方法迭代（解决回调函数是Promise对象）</li><li>出错就用reject方法返回</li></ul><h4 id="三、bluebird"><a href="#三、bluebird" class="headerlink" title="三、bluebird"></a>三、bluebird</h4><p>1: NodeJS 中的 fs.readFile 方法的基本使用方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;),path = require(&apos;path&apos;);</span><br><span class="line"> </span><br><span class="line">fs.readFile(path.join(__dirname, &apos;1.txt&apos;), &apos;utf-8&apos;, (err, data) =&gt; &#123;</span><br><span class="line"> if (err) &#123;</span><br><span class="line">   console.error(err);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">   console.log(data);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>2：使用Promise封装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">functionread(filePath, encoding) &#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">        fs.readFile(filePath, encoding, (err, data)=&gt; &#123;</span><br><span class="line">            if (err) reject(err)</span><br><span class="line">            resolve(data)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(&apos;1.txt&apos;, &apos;utf8&apos;).then( data=&gt; data)</span><br></pre></td></tr></table></figure></p><p>把fs.readFile方法用Promise封装一下就能使用Promise api。但是每次手动封装比较麻烦，bluebird可以帮我们简化这个步骤。</p><p>3：在 NodeJS 环境中，通过 const bluebird = require(‘bluebird’) 就可以开始使用 Bluebird 提供的 Promise 对象。</p><p>Promise.promisify 将单个方法转换成Promise对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const bluebird = require(&apos;bluebird&apos;) </span><br><span class="line">letread = bluebird.promisify(fs.readFile)</span><br><span class="line">read(&apos;1.txt&apos;, &apos;utf-8&apos;).then(data=&gt; &#123;</span><br><span class="line">    console.log(&apos;data promisify&apos;, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>使用<code>bluebird.promisify</code>方法，就能将fs.readFile直接封装成一个promise对象，它的原理很简单，return new Promise<br>是它的核心：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function promisify(fn) &#123;</span><br><span class="line">    return function () &#123;</span><br><span class="line">        return new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">            fn(...arguments, function (err, data) &#123;</span><br><span class="line">                if (err) reject(err)</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.使用 Promise.promisifyAll 把一个对象的所有方法都自动转换成使用 Promise。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const bluebird = require(&apos;bluebird&apos;),</span><br><span class="line">  fs = require(&apos;fs&apos;),</span><br><span class="line">  path = require(&apos;path&apos;);</span><br><span class="line">Promise.promisifyAll(fs);</span><br><span class="line"> </span><br><span class="line">fs.readFileAsync(path.join(__dirname, &apos;sample.txt&apos;), &apos;utf-8&apos;)</span><br><span class="line">  .then(data =&gt; console.log(data))</span><br><span class="line">  .catch(err =&gt; console.error(err));</span><br></pre></td></tr></table></figure></p><p>promisifyAll核心是遍历对象，生成些新创建方法的名称在已有方法的名称后加上”Async”后缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function promisifyAll(obj) &#123;</span><br><span class="line">    Object.keys(obj).forEach(key=&gt;&#123;</span><br><span class="line">        if(typeof obj[key] === &apos;function&apos;)&#123;</span><br><span class="line">            obj[key+&apos;Async&apos;] = promisify(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="四、generator-co"><a href="#四、generator-co" class="headerlink" title="四、generator+co"></a>四、generator+co</h4><h5 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h5><p>generator函数最大的特点是可以用<code>yield</code>暂停执行，为了区别普通函数在函数名前加*号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function *say() &#123;</span><br><span class="line">    let a = yield &quot;test1&quot;let b = yield &quot;test2&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let it = say();</span><br><span class="line"></span><br><span class="line">console.log(1, it.next()) //1 &#123; value: &apos;test1&apos;, done: false &#125;</span><br><span class="line">console.log(2, it.next()) //2 &#123; value: &apos;test2&apos;, done: false &#125;</span><br><span class="line">console.log(3, it.next()) //3 &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><p>执行say()方法返回的是指针对象，不会返回函数执行结果。it 就是iterator 迭代器</p><p>需要调用指针对象的next()方法，让函数指针不断移动并返回一个对象。（{value:xxx,done:xxx}）</p><p>value是yield后面的值，done表示函数是否执行完成。</p><p>我们可以用generator函数实现结果的产出，但是也需要它支持输入。</p><p>generator函数的运行顺序如下：<br>使用it.next()执行函数，结果并不会返回给定义的变量a。next方法可以接受参数，这是向 Generator 函数体内输入数据。<br>第二个next的时候传入参数，就能被变量a接收到。</p><p>terminal 返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 &#123; value: &apos;test1&apos;, done: false &#125;</span><br><span class="line">aaa</span><br><span class="line">2 &#123; value: &apos;test2&apos;, done: false &#125;</span><br><span class="line">bbb</span><br><span class="line">3 &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure></p><p>4.2 使用</p><p>example：使用generator异步执行函数，使函数的返回作为下一个函数的入参执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let bluebird = require(&apos;bluebird&apos;)</span><br><span class="line">let fs = require(&apos;fs&apos;)</span><br><span class="line">letread = bluebird.promisify(fs.readFile)</span><br><span class="line"></span><br><span class="line">function *r() &#123;</span><br><span class="line">    let r1 = yield read(&apos;1.txt&apos;, &apos;utf-8&apos;)</span><br><span class="line">    console.log(&apos;r1&apos;,r1); // r1 2.txt</span><br><span class="line">    let r2 = yield read(r1, &apos;utf-8&apos;)</span><br><span class="line">    console.log(&apos;r2&apos;,r2); // r2 3.txt</span><br><span class="line">    let r3 = yield read(r2, &apos;utf-8&apos;)</span><br><span class="line">    console.log(&apos;r3&apos;,r3); // r3 hello</span><br><span class="line">    return r3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拿读取文件的例子：使用bluebird将fs.readFile变成promise对象，将读取到的文件内容作为入参传入下一个要执行的函数。</p><p>突然发现，要拿到结果会是个复杂的过程，但还是硬着头皮下下去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const it_r = r()</span><br><span class="line">it_r.next().value.then(d1=&gt;&#123;</span><br><span class="line">    return it_r.next(d1).value</span><br><span class="line">&#125;).then(d2=&gt;&#123;</span><br><span class="line">    return it_r.next(d2).value</span><br><span class="line">&#125;).then(d3=&gt;&#123;</span><br><span class="line">    return it_r.next(d3).value</span><br><span class="line">&#125;).then(data=&gt;&#123;</span><br><span class="line">    console.log(data) // hello</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>it.next().value 返回的是一个promise，使用then方法，拿到它成功回调的值，并传入下一个next。</p><p>这样能成功拿到我们要的值，但是太麻烦了。于是就有了generator+co的组合！</p><p>安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install co</span><br></pre></td></tr></table></figure></p><p>使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(r()).then(data=&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>co会迭代执行it.next()方法，直到done的布尔值为true就返回generator函数的运行结果。</p><p>大致执行代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function co(it) &#123;</span><br><span class="line">    return new Promise((resolve, reject)=&gt; &#123;</span><br><span class="line">        function next(data) &#123;</span><br><span class="line">            let &#123;value, done&#125; = it.next(data)</span><br><span class="line">            if(done)&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                value.then(data=&gt; &#123;</span><br><span class="line">                    next(data)</span><br><span class="line">                &#125;,reject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="五、async-await"><a href="#五、async-await" class="headerlink" title="五、async+await"></a>五、async+await</h4><p>async 函数是Generator 函数的语法糖。</p><p>比Generator函数用起来简单</p><ol><li>可以让代码像同步</li><li>可以try+catch</li><li>可以使用promise api<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">async functionr() &#123;</span><br><span class="line">   try&#123;</span><br><span class="line">        let r1 = await read(&apos;1.txt&apos;,&apos;utf8&apos;)</span><br><span class="line">        let r2 = await read(r1,&apos;utf8&apos;)</span><br><span class="line">        let r3 = await read(r2,&apos;utf8&apos;)</span><br><span class="line">        return r3</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        console.log(&apos;e&apos;,e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r().then(data=&gt; &#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;,err=&gt;&#123;</span><br><span class="line">    console.log(&apos;err&apos;,err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。遇到await就会先返回，等待函数执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> async </tag>
            
            <tag> es6 </tag>
            
            <tag> Generator </tag>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交叉观察器(intersectionObserver) Vue实战</title>
      <link href="/2018/08/13/%E4%BA%A4%E5%8F%89%E8%A7%82%E5%AF%9F%E5%99%A8-intersectionObserver-Vue%E5%AE%9E%E6%88%98/"/>
      <url>/2018/08/13/%E4%BA%A4%E5%8F%89%E8%A7%82%E5%AF%9F%E5%99%A8-intersectionObserver-Vue%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="参考文章：IntersectionObserver-API-使用教程"><a href="#参考文章：IntersectionObserver-API-使用教程" class="headerlink" title="参考文章：IntersectionObserver API 使用教程"></a>参考文章：<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">IntersectionObserver API 使用教程</a></h2><h2 id="Intersection-Observer"><a href="#Intersection-Observer" class="headerlink" title="Intersection Observer"></a><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver" target="_blank" rel="noopener">Intersection Observer</a></h2><h2 id="【译】使用-Intersection-Observer-实现图片延迟加载"><a href="#【译】使用-Intersection-Observer-实现图片延迟加载" class="headerlink" title="【译】使用 Intersection Observer 实现图片延迟加载"></a><a href="https://link.zhihu.com/?target=https%3A//c7sky.com/lazy-loading-images-using-intersection-observer.html" target="_blank" rel="noopener">【译】使用 Intersection Observer 实现图片延迟加载</a></h2><p>intersectionObserver解决什么问题？</p><p>intersectionObserver解决目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”，</p><p>比如在web网页开发中，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。</p><p>传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="noopener">getBoundingClientRect()</a>方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">性能问题</a>。</p><p>目前有一个新的 <a href="https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/" target="_blank" rel="noopener">IntersectionObserver API</a>，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p><blockquote><p>IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，<code>IntersectionObserver</code>的实现，应该采用<code>requestIdleCallback()</code>，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p></blockquote><p>IntersectionObserverEntry 对象</p><p><code>IntersectionObserverEntry</code>对象提供目标元素的信息，一共有六个属性。</p><pre><code>{  time: 3893.92,  rootBounds: ClientRect {    bottom: 920,    height: 1024,    left: 0,    right: 1024,    top: 0,    width: 920 },  boundingClientRect: ClientRect {  // ... },  intersectionRect: ClientRect {  // ... },  intersectionRatio: 0.54,  target: element} </code></pre><p>每个属性的含义如下。</p><ul><li><code>time</code>：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li><li><code>target</code>：被观察的目标元素，是一个 DOM 节点对象</li><li><code>rootBounds</code>：根元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回<code>null</code></li><li><code>boundingClientRect</code>：目标元素的矩形区域的信息</li><li><code>intersectionRect</code>：目标元素与视口（或根元素）的交叉区域的信息</li><li><code>intersectionRatio</code>：目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全可见时为<code>1</code>，完全不可见时小于等于<code>0</code></li></ul><p>现在我们已经创建了一个 Intersection Observer 并且正在观察页面上的图片，我们现在来了解 intersection 事件，它将在元素进入视区时触发。</p><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>此时此刻，你也许想知道关于这项特性的浏览器支持情况。Intersection Observer 现在已被 <a href="https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dintersectionobserver" target="_blank" rel="noopener">Edge、Firefox、Chrome 和 Opera</a> 支持，这是一个好消息。</p><p>然而，为了确保我们的代码不会在不支持它的浏览器中造成破坏，我们可以使用特性检测来确定我们应该如何来加载图片。让我们看看下面的代码。</p><pre><code>// If we don&apos;t have support for intersection observer, load the images immediatelyif (!(&apos;IntersectionObserver&apos; in window)) {  Array.from(images).forEach(image =&gt; preloadImage(image));} else {  // It is supported, load the images  observer = new IntersectionObserver(onIntersection, config);  images.forEach(image =&gt; {   observer.observe(image);  });}view raw</code></pre><p>Vue:</p><pre><code>&lt;template&gt;    &lt;img :src=&quot;lazysrc&quot; /&gt;&lt;/template&gt;&lt;script&gt;    import Bus from &apos;../bus&apos;;    import nonepng from &apos;../../assets/img/none.png&apos;;    export default {        name: &apos;lazyimg&apos;,        data: function() {            return {                isShow: false,                lazysrc: nonepng            }        },        mounted() {            if(!this.needlazy) {                this.lazysrc = this.src;            } else {                if(!(&apos;IntersectionObserver&apos; in window)) {                    //TODO                } else {                    var io = new IntersectionObserver(                        entries =&gt; {                            entries.forEach(i =&gt; {                                if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发                                    i.target.setAttribute(&quot;src&quot;, this.src)                                }                            });                        }, {                            threshold: [0, 0.25, 0.5, 0.75, 1],                        }                    );                    io.observe(this.$el);                }            }        },        props: {            needlazy: {                type: Boolean,                default: false,            },            src: {                type: String,                default: &apos;&apos;,            },        }    };&lt;/script&gt;</code></pre><blockquote><p>通常都是通过判断intersectionRatio来做某些事，比如当intersectionRatio大于多少的时候做什么事，加载图片等！</p></blockquote><p><img src="https://pic4.zhimg.com/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-8e8d0a7aa6b83f2150c8916a0ec90b43_hd.jpg" alt=""><br>   灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的<code>intersectionRatio</code>图中都已经注明。</p><p>DEMO：  <a href="https://zhuanlan.zhihu.com/p/25455672" target="_blank" rel="noopener">延迟加载(Lazyload)三种实现方式</a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;        &lt;title&gt; &lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            * {                padding: 0px;                margin: 0px;                outline: none;            }            body {}            #main {                margin: 0 auto;                width: 600px;                height: 300px;                overflow: scroll;            }            #con {                width: 1200px;                height: 300px;            }            .cc {                width: 300px;                height: 300px;                float: left;                background-size: cover;            }            #a {                background-color: red;            }            #b {                background-color: black;            }            #c {                background-color: blue;            }            #d {                background-color: green;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;main&quot;&gt;            &lt;div id=&quot;con&quot;&gt;                &lt;div id=&quot;a&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;                &lt;div id=&quot;b&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;                &lt;div id=&quot;c&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;                &lt;div id=&quot;d&quot; class=&quot;cc&quot;&gt;&lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var io = new IntersectionObserver(            entries =&gt; {                console.log(&apos;********************************&apos;);                console.log(entries);                console.log(&apos;********************************&apos;);                entries.forEach(i =&gt; {                    console.log(&apos;================================&apos;);                    console.log(&apos;Time: &apos; + i.time);                    console.log(&apos;Target: &apos; + i.target.nodeName);                    console.log(&apos;IntersectionRatio: &apos; + i.intersectionRatio);                    console.log(&apos;rootBounds: &apos; + i.rootBounds);                    console.log(i.boundingClientRect);                    console.log(i.intersectionRect);                    console.log(&apos;================================&apos;);                    if(i.intersectionRatio &gt;= 0.25) { //可见元素占视窗的25%触发                        console.log(&apos;^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^&apos;);                        i.target.style.backgroundImage = &quot;url(&quot; + &apos;http://pic35.photophoto.cn/20150528/0020032932102307_b.jpg&apos; + &quot;)&quot;                    }                });            }, {                /* Using default options. Details below */                threshold: [0, 0.25, 0.5, 0.75, 1],   //会执行5次            }        );        // Start observing an element        io.observe(document.querySelector(&apos;#d&apos;));        io.observe(document.querySelector(&apos;#c&apos;));    &lt;/script&gt;&lt;/html&gt;</code></pre><p><img src="https://pic1.zhimg.com/v2-83bcd2ce4df13a07da99e0c051e9fcaa_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-83bcd2ce4df13a07da99e0c051e9fcaa_hd.jpg" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Lazyload 3&lt;/title&gt;    &lt;style&gt;        img {        display: block;        margin-bottom: 50px;        width: 800px;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/1.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/2.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/3.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/4.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/5.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/6.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/7.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/8.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/9.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/10.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/11.png&quot;&gt;    &lt;img src=&quot;images/loading.gif&quot; data-src=&quot;images/12.png&quot;&gt;    &lt;script&gt;    function query(selector) {        return Array.from(document.querySelectorAll(selector));    }    var io = new IntersectionObserver(function(items) {        items.forEach(function(item) {        var target = item.target;        if(target.getAttribute(&apos;src&apos;) == &apos;images/loading.gif&apos;) {            target.src = target.getAttribute(&apos;data-src&apos;);        }        })    });    query(&apos;img&apos;).forEach(function(item) {        io.observe(item);    });    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol><li>IntersectionObserver 传入一个回调函数，当其观察到元素集合出现时候，则会执行该函数。</li><li>io.observe 即要观察的元素，要一个个添加才可以。</li><li>io 管理的是一个数组，当元素出现或消失的时候，数组添加或删除该元素，并且执行该回调函数。</li></ol><h2 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h2><p>它的用法非常简单。</p><pre><code>var io = new IntersectionObserver(callback, option); </code></pre><p>上面代码中，<code>IntersectionObserver</code>是浏览器原生提供的构造函数，接受两个参数：<code>callback</code>是可见性变化时的回调函数，<code>option</code>是配置对象（该参数可选）。</p><p>构造函数的返回值是一个观察器实例。实例的<code>observe</code>方法可以指定观察哪个 DOM 节点。</p><pre><code>// 开始观察io.observe(document.getElementById(&apos;example&apos;)); // 停止观察io.unobserve(element); // 关闭观察器io.disconnect(); </code></pre><p>上面代码中，<code>observe</code>的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p><pre><code>io.observe(elementA);io.observe(elementB); </code></pre><h2 id="二、callback-参数"><a href="#二、callback-参数" class="headerlink" title="二、callback 参数"></a>二、callback 参数</h2><p>目标元素的可见性变化时，就会调用观察器的回调函数<code>callback</code>。</p><p><code>callback</code>一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p><pre><code>var io = new IntersectionObserver(  entries =&gt; {    console.log(entries); } ); </code></pre><p>上面代码中，回调函数采用的是<a href="https://link.zhihu.com/?target=http%3A//es6.ruanyifeng.com/%23docs/function%23%25E7%25AE%25AD%25E5%25A4%25B4%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">箭头函数</a>的写法。<code>callback</code>函数的参数（<code>entries</code>）是一个数组，每个成员都是一个<code>[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)</code>对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code>数组就会有两个成员。</p><h2 id="三、Option-对象"><a href="#三、Option-对象" class="headerlink" title="三、Option 对象"></a>三、Option 对象</h2><p>IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p><p><code>[IntersectionObserver.root](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/root)</code> 只读所监听对象的具体祖先元素(<code>[element](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Element)</code>)。如果未传入任何值或值为null，则默认使用viewport。</p><p><code>[IntersectionObserver.rootMargin](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/rootMargin)</code> 只读计算交叉时添加到根(root)边界盒<a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Glossary/bounding_box" target="_blank" rel="noopener">bounding box</a>的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要。此属性返回的值可能与调用构造函数时指定的值不同，因此可能需要更改该值，以匹配内部要求。所有的偏移量均可用像素(pixel)(px)或百分比(percentage)(%)来表达, 默认值为”0px 0px 0px 0px”。</p><p><code>[IntersectionObserver.thresholds](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/thresholds)</code> 只读一个包含阈值的list, 升序排列, list中的每个阈值都是监听对象的交叉区域与边界区域的比率。当监听对象的任何阈值被越过时，都会生成一个通知(Notification)。如果构造器未传入值, 则默认值为0.</p><p>threshold 属性</p><p><code>threshold</code>属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为<code>[0]</code>，即交叉比例（<code>intersectionRatio</code>）达到<code>0</code>时触发回调函数。</p><pre><code>new IntersectionObserver(  entries =&gt; {/* ... */}, {    threshold: [0, 0.25, 0.5, 0.75, 1] } ); </code></pre><p>用户可以自定义这个数组。比如，<code>[0, 0.25, 0.5, 0.75, 1]</code>就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p><p>root 属性，rootMargin 属性</p><p>很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在<code>iframe</code>窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。</p><p>IntersectionObserver API 支持容器内滚动。<code>root</code>属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p><pre><code>var opts = {   root: document.querySelector(&apos;.container&apos;),  rootMargin: &quot;500px 0px&quot; }; var observer = new IntersectionObserver(  callback,  opts); </code></pre><p>上面代码中，除了<code>root</code>属性，还有<code>[rootMargin](https://link.zhihu.com/?target=https%3A//wicg.github.io/IntersectionObserver/%23dom-intersectionobserverinit-rootmargin)</code>属性。后者定义根元素的<code>margin</code>，用来扩展或缩小<code>rootBounds</code>这个矩形的大小，从而影响<code>intersectionRect</code>交叉区域的大小。它使用CSS的定义方法，比如<code>10px 20px 30px 40px</code>，表示 top、right、bottom 和 left 四个方向的值。</p><pre><code>//离视窗还有top=500px 或者 bottom=500 触发加载rootMargin = `500px 0px`  //离视窗还有top=-500px 或者 bottom=-500 触发加载 （惰性加载）rootMargin = `-500px 0px` </code></pre><p>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p><h2 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h2><p><code>[IntersectionObserver.disconnect](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/disconnect)</code>使IntersectionObserver对象停止监听工作。</p><p><code>[IntersectionObserver.observe](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/observe)使IntersectionObserver开始监听一个目标元素。</code></p><p><code>[IntersectionObserver.takeRecords](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/takeRecords)</code>为所有监听目标返回一个<code>[IntersectionObserverEntry](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserverEntry)</code>对象数组并且停止监听这些目标。</p><p><code>[IntersectionObserver.unobserve](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver/unobserve)使IntersectionObserver停止监听特定目标元素。</code></p><h2 id="五、Vue（xunleif2e-vue-lazy-component）"><a href="#五、Vue（xunleif2e-vue-lazy-component）" class="headerlink" title="五、Vue（xunleif2e/vue-lazy-component）"></a>五、Vue（<a href="https://link.zhihu.com/?target=https%3A//github.com/xunleif2e/vue-lazy-component" target="_blank" rel="noopener">xunleif2e/vue-lazy-component</a>）</h2><p>核心 VueLazyComponent.vue</p><pre><code>&lt;template&gt;  &lt;transition-group :tag=&quot;tagName&quot; name=&quot;lazy-component&quot; style=&quot;position: relative;&quot;    @before-enter=&quot;(el) =&gt; $emit(&apos;before-enter&apos;, el)&quot;    @before-leave=&quot;(el) =&gt; $emit(&apos;before-leave&apos;, el)&quot;    @after-enter=&quot;(el) =&gt; $emit(&apos;after-enter&apos;, el)&quot;    @after-leave=&quot;(el) =&gt; $emit(&apos;after-leave&apos;, el)&quot;  &gt;    &lt;div v-if=&quot;isInit&quot; key=&quot;component&quot;&gt;      &lt;slot :loading=&quot;loading&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div v-else-if=&quot;$slots.skeleton&quot; key=&quot;skeleton&quot;&gt;      &lt;slot name=&quot;skeleton&quot;&gt;&lt;/slot&gt;    &lt;/div&gt;    &lt;div v-else key=&quot;loading&quot;&gt;    &lt;/div&gt;  &lt;/transition-group&gt;&lt;/template&gt;&lt;script&gt;  export default {    name: &apos;VueLazyComponent&apos;,    props: {      timeout: {        type: Number      },      tagName: {        type: String,        default: &apos;div&apos;      },      viewport: {        type: typeof window !== &apos;undefined&apos; ? window.HTMLElement : Object,        default: () =&gt; null      },      threshold: {        type: String,        default: &apos;0px&apos;      },      direction: {        type: String,        default: &apos;vertical&apos;      },      maxWaitingTime: {        type: Number,        default: 50      }    },    data () {      return {        isInit: false,        timer: null,        io: null,        loading: false      }    },    created () {      // 如果指定timeout则无论可见与否都是在timeout之后初始化      if (this.timeout) {        this.timer = setTimeout(() =&gt; {          this.init()        }, this.timeout)      }    },    mounted () {      if (!this.timeout) {        // 根据滚动方向来构造视口外边距，用于提前加载        let rootMargin        switch (this.direction) {          case &apos;vertical&apos;:            rootMargin = `${this.threshold} 0px`            break          case &apos;horizontal&apos;:            rootMargin = `0px ${this.threshold}`            break        }        // 观察视口与组件容器的交叉情况        this.io = new window.IntersectionObserver(this.intersectionHandler, {          rootMargin,          root: this.viewport,          threshold: [ 0, Number.MIN_VALUE, 0.01]        })        this.io.observe(this.$el)      }    },    beforeDestroy () {      // 在组件销毁前取消观察      if (this.io) {        this.io.unobserve(this.$el)      }    },    methods: {      // 交叉情况变化处理函数      intersectionHandler (entries) {        if (          // 正在交叉          entries[0].isIntersecting ||          // 交叉率大于0          entries[0].intersectionRatio        ) {          this.init()          this.io.unobserve(this.$el)        }      },      // 处理组件和骨架组件的切换      init () {        // 此时说明骨架组件即将被切换        this.$emit(&apos;beforeInit&apos;)        this.$emit(&apos;before-init&apos;)        // 此时可以准备加载懒加载组件的资源        this.loading = true        // 由于函数会在主线程中执行，加载懒加载组件非常耗时，容易卡顿        // 所以在requestAnimationFrame回调中延后执行        this.requestAnimationFrame(() =&gt; {          this.isInit = true          this.$emit(&apos;init&apos;)        })      },      requestAnimationFrame (callback) {        // 防止等待太久没有执行回调        // 设置最大等待时间        setTimeout(() =&gt; {          if (this.isInit) return          callback()        }, this.maxWaitingTime)        // 兼容不支持requestAnimationFrame 的浏览器        return (window.requestAnimationFrame || ((callback) =&gt; setTimeout(callback, 1000 / 60)))(callback)      }    }  }&lt;/script&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> intersectionObserver </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React 异步加载组件</title>
      <link href="/2018/08/11/Raect-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6/"/>
      <url>/2018/08/11/Raect-%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>首先需要知道的是dynamic import通过返回Promise的方式实现异步加载功能。</p><pre><code>import(&apos;./component.js&apos;)      .then((m) =&gt; {        // 处理异步加载到的模块m    })    .catch((err) =&gt; {        // 错误处理    });</code></pre><p>要注意的是import的参数不能使用变量，简单原则是至少要让Webpack知晓应该预先加载哪些内容。这里的参数除了使用常量之外，还可以使用模板字符串<code>componentDir/${name}.js</code>。</p><p>其实到这里基本完成代码切割了，接下来做得就是结合react-router实现按模块异步加载。这是跟业务代码相关的，因此每个人的做法都是不一样的。所以以下代码仅供参考。</p><p>异步加载</p><p>我参考react-router的例子写了个简单的异步加载组件AsyncLoader.js，内容：</p><pre><code>import React from &apos;react&apos;;export default class AsyncLoader extends React.Component {  static propTypes = {    path: React.PropTypes.string.isRequired,    loading: React.PropTypes.element,  };  static defaultProps = {    path: &apos;&apos;,    loading: &lt;p&gt;Loading...&lt;/p&gt;,    error: &lt;p&gt;Error&lt;/p&gt;  };  constructor(props) {    super(props);    this.state = {      module: null    };  }  componentWillMount() {    this.load(this.props);  }  componentWillReceiveProps(nextProps) {    if (nextProps.path !== this.props.path      || nextProps.error !== this.props.error      || nextProps.loading !== this.props.loading) {      this.load(nextProps);    }  }  load(props) {    this.setState({module: props.loading});    // TODO：异步代码的路径希望做成可以配置的方式    import(`./path/${props.path}`)      .then((m) =&gt; {        let Module = m.default ? m.default : m;        console.log(&quot;module: &quot;, Module);        this.setState({module: &lt;Module/&gt;});      }).catch(() =&gt; {        this.setState({module: props.error});      });  }  render() {    return this.state.module;  }}</code></pre><p>使用方法</p><pre><code>&lt;Route      exact path=&apos;/book&apos;     render={()=&gt;&lt;AsyncLoader path={&apos;./components/Book.js&apos;}/&gt;} /&gt;</code></pre><p>Webpack打包的时候会根据import的参数生成相应的js文件，默认使用id（webpack生成的，从0开始）命名这个文件。</p><pre><code>const Search = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;search&quot; */ &quot;./containers/Search/SearchContainer&quot;))const BookList = asyncComponent(() =&gt; import(/* webpackChunkName: &quot;bookList&quot; */ &quot;./containers/BookList/BookListContainer&quot;))import React from &apos;react&apos;export const asyncComponent = loadComponent =&gt; (    class AsyncComponent extends React.Component {        state = {            Component: null,        }        componentWillMount() {            if (this.hasLoadedComponent()) {                return;            }            loadComponent()                .then(module =&gt; module.default) ////兼容 module.default ? module.default : module                .then((Component) =&gt; {                    this.setState({ Component });                })                .catch((err) =&gt; {                    console.error(`Cannot load component in &lt;AsyncComponent /&gt;`);                    throw err;                });        }        hasLoadedComponent() {            return this.state.Component !== null;        }        render() {            const { Component } = this.state;            return (Component) ? &lt;Component {...this.props} /&gt; : null;        }    }); </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Raect </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS面试之数组对象解构</title>
      <link href="/2018/08/04/JS%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84/"/>
      <url>/2018/08/04/JS%E9%9D%A2%E8%AF%95%E4%B9%8B%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构:"></a>数组解构:</h3><blockquote><p>将 destructuringArray([1, [2, 3], 4], “[a, [b], c]”) =&gt; {a: 1, b: 2, c: 4}</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 将 destructuringArray([1, [2, 3], 4], &quot;[a, [b], c]&quot;) =&gt; &#123;a: 1, b: 2, c: 4&#125;</span><br><span class="line">const targetArray = [1, [2, 3], 4];</span><br><span class="line">const formater = &quot;[a, [b], c]&quot;;</span><br><span class="line"></span><br><span class="line">const destructuringArray = (values, keys) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const obj = &#123;&#125;;</span><br><span class="line">    if (typeof keys === &apos;string&apos;) &#123;</span><br><span class="line">      keys = JSON.parse(keys.replace(/\w+/g, &apos;&quot;$&amp;&quot;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const iterate = (values, keys) =&gt;</span><br><span class="line">      keys.forEach((key, i) =&gt; &#123;</span><br><span class="line">        if(Array.isArray(key)) iterate(values[i], key)</span><br><span class="line">        else obj[key] = values[i]</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    iterate(values, keys)</span><br><span class="line">    </span><br><span class="line">    return obj;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><blockquote><p>实现一个get函数，使得下面的调用可以输出正确的结果</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;);</span><br><span class="line">// [ &apos;FE Coder&apos;, 1, &apos;byted&apos;]</span><br></pre></td></tr></table></figure><p>乍眼一看，这不就是实现一个lodash.get方法吗？看上去好像很简单。所以我就开始写了第一个版本。思想其实很简单，遍历传进来的参数，使用split将每一个参数分隔开，然后遍历取值，最终返回结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">return args.map((item) =&gt; &#123;</span><br><span class="line">const paths = item.split(&apos;.&apos;);</span><br><span class="line">let res = data;</span><br><span class="line">paths.map(path =&gt; res = res[path]);</span><br><span class="line">return res;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">selector: &#123;</span><br><span class="line">to: &#123;</span><br><span class="line">toutiao: &quot;FE Coder&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">target: [1, 2, &#123;</span><br><span class="line">name: &apos;byted&apos;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get(obj, ...list) &#123;</span><br><span class="line">return list.map((item) =&gt; &#123;</span><br><span class="line">return item.split(&quot;.&quot;).reduce((a = &#123;&#125;, b) =&gt; &#123;</span><br><span class="line">if(/\[([0-9])\]/g.test(b))&#123;</span><br><span class="line">var c=/(\w+)\[([0-9])\]/g.exec(b)</span><br><span class="line">return a[c[1]]&amp;&amp;a[c[1]][c[2]]</span><br><span class="line">&#125;</span><br><span class="line">return a[b]</span><br><span class="line">&#125;, obj)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;)</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;));</span><br></pre></td></tr></table></figure><p>一运行，果不其然，报错了。<br>后来仔细看了一下提供的测试代码，发现居然有target[0]这种东西。。居然还带了个数组索引。<br> 冷静分析一下，对于后面带了个索引的类型，比如’target[0]’,我们肯定是要特殊对待的。所以，我们首先得先识别到这种特殊的类型，然后再对它进行额外处理。</p><p>这个时候，很快的就可以想到使用正则表达式来做这个事情。为什么呢？因为像这种带有索引的类型，他们都有一个特色，就是有固定的格式：[num]，那么我们只需要能构造出可以匹配这种固定格式的正则，就可以解决这个问题。</p><p>对于这种格式，不难想到可以用这个正则表达式来做判断：/[[0-9]+]/gi，可是我们还需要将匹配值取出来。这个时候查了下正则表达式的文档(<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString%2Fmatch" target="_blank" rel="noopener">文档点击这里</a>)，发现有一个match方法，可以返回匹配成功的结果。那么就让我们来做个测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const reg = /\[[0-9]+\]/gi;</span><br><span class="line">const str = &quot;target[123123]&quot;;</span><br><span class="line">const str1 = &quot;target[]&quot;</span><br><span class="line">if (reg.test(str)) &#123;</span><br><span class="line">    console.log(&apos;test success&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!reg.test(str1)) &#123;</span><br><span class="line">    console.log(&apos;test fail&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const matchResult = str.match(reg);</span><br><span class="line">console.log(matchResult); // [&quot;[123123]&quot;]</span><br></pre></td></tr></table></figure></p><p>诶，我们现在已经找到了解决这种问题的方法，那让我们赶紧来继续改进下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">const reg = /\[[0-9]+\]/gi;</span><br><span class="line">return args.map((item) =&gt; &#123;</span><br><span class="line">const paths = item.split(&apos;.&apos;);</span><br><span class="line">let res = data;</span><br><span class="line">paths.map((path) =&gt; &#123;</span><br><span class="line">                  if (reg.test(path)) &#123;</span><br><span class="line">                    const match = path.match(reg)[0];</span><br><span class="line">                    // 将target[0]里的target储存到cmd里</span><br><span class="line">                    const cmd = path.replace(match, &apos;&apos;);</span><br><span class="line">                    // 获取数组索引</span><br><span class="line">                    const arrIndex = match.replace(/[\[\]]/gi, &apos;&apos;);</span><br><span class="line">                    res = res[cmd][arrIndex];</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                    res = res[path];</span><br><span class="line">                  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">return res;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;));</span><br></pre></td></tr></table></figure></p><p>写完赶紧运行一下，完美，输出了正确的结果了。那么到这里就结束了?</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>可是总感觉有点不妥，感觉事情没有那么简单。一般来说，面试题除了考验你解决问题的能力之外，可能还考验着你思考问题的全面性、严谨性。像上面那种写法，<br>如果用户传入了一个不存在的path链或者一些其他特殊情况，就可能导致整个程序crash掉。想下lodash.get调用方式，<br>即使你传入了错误的path，他也可以帮你做处理，并且返回一个undefined。因此，我们还需要完善这个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">const reg = /\[[0-9]+\]/gi;</span><br><span class="line">return args.map((item) =&gt; &#123;</span><br><span class="line">const paths = item.split(&apos;.&apos;);</span><br><span class="line">let res = data;</span><br><span class="line">paths.map(path =&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">if (reg.test(path)) &#123;</span><br><span class="line">const match = path.match(reg)[0];</span><br><span class="line">const cmd = path.replace(match, &apos;&apos;);</span><br><span class="line">const arrIndex = match.replace(/[\[\]]/gi, &apos;&apos;);</span><br><span class="line">res = res[cmd][arrIndex];</span><br><span class="line">&#125; else &#123;</span><br><span class="line">res = res[path];</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">console.error(err);</span><br><span class="line">res = undefined;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">return res;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，我们对每一个path的处理进行了try catch处理。若出错了，则返回undefined。哇，这样看起来就比较稳了。</p><p><strong>那么，有没有别的解决方法呢？</strong></p><p>群里有一个大佬提出了一种更简单也很取巧的解决方案，就是通过构建一个Function解决这个问题(Function的详细介绍点击<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction" target="_blank" rel="noopener">这里</a>)。由于代码很简单，我就直接贴出来了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">const res = JSON.stringify(data);</span><br><span class="line">return args.map((item) =&gt; (new Function(`try &#123;return $&#123;res&#125;.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;, &apos;asd&apos;));</span><br></pre></td></tr></table></figure></p><p>看完之后，就两个字，牛逼。<br> 这种方法我承认一开始我确实没想到，确实是很奇技淫巧。不过仔细思考了下，其实很多框架都用到了这个奇技淫巧。比如说vue里，就使用new Function的方式来动态创建函数，解决执行动态生成的代码的问题。<br><img src="/2018/08/04/JS面试之数组对象解构/1.webp" alt=""><br>再比如说，Function.prototype.bind方法里(我写了个类似的bind方法:<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fchenjigeng%2Fsomething%2Fblob%2Fmaster%2Fbind%2Fbind.js" target="_blank" rel="noopener">仓库</a>)，也使用了Function来解决一些问题(fn.length丢失问题)。说明这个东西还是挺有用的，得学习了解一波，说不定哪天就用到了。<br><img src="/2018/08/04/JS面试之数组对象解构/2.webp" alt=""><br><strong>更新</strong></p><p>有人提到了那种Function的方式没办法处理以下的处理:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;time : new Date(), a : &quot;this is a&quot;, b : 30&#125;;</span><br></pre></td></tr></table></figure></p><p>因为JSON.stringfy后，Date、Function和RegExp类型的变量都会失效。对于这种情况，评论区有个大佬(<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fu%2Ffenghengzhi%2Fabout" target="_blank" rel="noopener">冯恒智</a>)也提到了一种很好的解决方案:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; (new Function(&apos;data&apos;,`try &#123;return data.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，另一种解决方案，就是将”target[0]”分为两个key，也很简单粗暴，就是将在split之前，将字符串里的’[‘替换为’.’,将’]’直接去掉。这样就可以将”target[0]”变为”target.0”。具体代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; &#123;</span><br><span class="line">let res = data;</span><br><span class="line">item</span><br><span class="line">.replace(/\[/g, &quot;.&quot;)</span><br><span class="line">.replace(/\]/g, &quot;&quot;)</span><br><span class="line">.split(&apos;.&apos;)</span><br><span class="line">.map(path =&gt; res = res &amp;&amp; res[path]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而且这两种方式的好处在于，它也可以处理多维数组的情况。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>学习完之后，最重要就是要总结，只有总结下来了，知识才是你自己的。那么我来总结下文章想表达的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">function get(data, ...args) &#123;</span><br><span class="line">const res = JSON.stringify(data);</span><br><span class="line">return args.map((item) =&gt; (new Function(`try &#123;return $&#123;res&#125;.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123; selector: &#123; to: &#123; toutiao: &quot;FE Coder&quot;&#125; &#125;, target: [1, 2, &#123; name: &apos;byted&apos;&#125;]&#125;;</span><br><span class="line"></span><br><span class="line">console.log(get(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;, &apos;asd&apos;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get1(data, ...args) &#123;</span><br><span class="line">    return args.map((item) =&gt; (new Function(&apos;data&apos;,`try &#123;return data.$&#123;item&#125; &#125; catch(e) &#123;&#125;`))(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get2(data, ...args) &#123;</span><br><span class="line">  return args.map(item =&gt; &#123;</span><br><span class="line">    const reg = /\[([0-9])\]/g;</span><br><span class="line">    if (reg.test(item)) &#123;</span><br><span class="line">      item = item.replace(reg, &apos;.$1&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    const paths = item.split(&apos;.&apos;);</span><br><span class="line">    return paths.reduce((result, current) =&gt; &#123;</span><br><span class="line">      return result[current];</span><br><span class="line">    &#125;, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const get3 = (obj, ...args) =&gt; args.map(key =&gt; eval(`obj.$&#123;key&#125;`));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function get4(obj, ...list) &#123;   //自己实现</span><br><span class="line">return list.map((item) =&gt; &#123;</span><br><span class="line">return item.split(&quot;.&quot;).reduce((a = &#123;&#125;, b) =&gt; &#123;</span><br><span class="line">if(/\[([0-9])\]/g.test(b))&#123;</span><br><span class="line">var c=/(\w+)\[([0-9])\]/g.exec(b)</span><br><span class="line">return a[c[1]]&amp;&amp;a[c[1]][c[2]]</span><br><span class="line">&#125;</span><br><span class="line">return a[b]</span><br><span class="line">&#125;, obj)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get4(obj, &apos;selector.to.toutiao&apos;, &apos;target[0]&apos;, &apos;target[2].name&apos;,&apos;zhangsan.lisi[3].name&apos;)</span><br></pre></td></tr></table></figure></p><ol><li>对于具有固定格式的字符串，可以考虑使用正则表达式来识别和匹配。</li><li>实现一个功能的时候，不要只考虑正常情况，要多考虑一些非正常情况，比如输入格式不对、用户不按套路来或者因为一些奇奇怪怪的事情报错。并且能对可预见的非正常情况做一个容错处理。</li><li>有时候还是可以多学习了解一下一些黑科技(比如Function)，说不定哪天就可以用它来解决问题。</li></ol><h3 id="一道面试题引起的思考"><a href="#一道面试题引起的思考" class="headerlink" title="一道面试题引起的思考"></a><a href="https://juejin.im/post/5bf769e0518825773a2ebfe5" target="_blank" rel="noopener">一道面试题引起的思考</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 面试，解构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js获取深层次属性,一道很经典的面试题</title>
      <link href="/2018/08/03/JS%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%B1%9E%E6%80%A7-%E4%B8%80%E9%81%93%E5%BE%88%E7%BB%8F%E5%85%B8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/08/03/JS%E8%8E%B7%E5%8F%96%E6%B7%B1%E5%B1%82%E6%AC%A1%E5%B1%9E%E6%80%A7-%E4%B8%80%E9%81%93%E5%BE%88%E7%BB%8F%E5%85%B8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："><a href="#题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：" class="headerlink" title="题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如："></a>题目：有时候我们需要访问一个对象较深的层次，但是如果这个对象某个属性不存在的话就会报错，例如：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="string">'ScriptOJ'</span> &#125; &#125; &#125;</span><br><span class="line">data.a.b.c <span class="comment">// = scriptoj</span></span><br><span class="line">data.a.b.c.d <span class="comment">// = 报错，代码停止执行console.log('ScriptOJ') // = 不会被执行</span></span><br></pre></td></tr></table></figure><p>请你完成一个 safeGet 函数，可以安全的获取无限多层次的数据，一旦数据不存在不会报错，会返回 undefined，<br>例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="string">'ScriptOJ'</span> &#125; &#125; &#125;</span><br><span class="line">safeGet(data, <span class="string">'a.b.c'</span>) <span class="comment">// = scriptoj</span></span><br><span class="line">safeGet(data, <span class="string">'a.b.c.d'</span>) <span class="comment">// = 返回 undefined</span></span><br><span class="line">safeGet(data, <span class="string">'a.b.c.d.e.f.g'</span>) <span class="comment">// = 返回 undefined</span></span><br></pre></td></tr></table></figure></p><p> 答案1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> safeGet = (o, path) = &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.split(<span class="string">'.'</span>).reduce((o, k) = o[k], o)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">666</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 答案2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeGet</span>(<span class="params">o, path</span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> path.split(<span class="string">'.'</span>).reduce((o=&#123;&#125;,b)=&#123;   <span class="comment">//用到参数默认值</span></span><br><span class="line">     </span><br><span class="line">      <span class="keyword">return</span> o[b]  </span><br><span class="line">   &#125;,o)</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目如下："><a href="#题目如下：" class="headerlink" title="题目如下："></a>题目如下：</h3> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.b = [<span class="number">1</span>, <span class="number">2</span>, <span class="keyword">this</span>.a];</span><br><span class="line"><span class="keyword">this</span>.c = &#123; <span class="attr">demo</span>: <span class="number">8</span> &#125;;</span><br><span class="line"><span class="keyword">this</span>.show = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a , <span class="keyword">this</span>.b , <span class="keyword">this</span>.c.demo );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.b.push(<span class="keyword">this</span>.a);</span><br><span class="line"><span class="keyword">this</span>.a = <span class="keyword">this</span>.b.length;</span><br><span class="line"><span class="keyword">this</span>.c.demo = <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent(); </span><br><span class="line"><span class="keyword">var</span> parent = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child();</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child();</span><br><span class="line">child1.a = <span class="number">11</span>;</span><br><span class="line">child2.a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">parent.show();<span class="comment">//Q1</span></span><br><span class="line">child1.show();<span class="comment">//Q2</span></span><br><span class="line">child2.show();<span class="comment">//Q3</span></span><br><span class="line"></span><br><span class="line">child1.change();</span><br><span class="line">child2.change();</span><br><span class="line"></span><br><span class="line">parent.show();<span class="comment">//Q4</span></span><br><span class="line">child1.show();<span class="comment">//Q5</span></span><br><span class="line">child2.show();<span class="comment">//Q6</span></span><br></pre></td></tr></table></figure><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ul><li><p>原型链的查找规则</p><ul><li>当实例上存在属性时， 用实例上的</li><li>如果实例不存在，顺在原型链，往上查找，如果存在，就使用原型链的</li><li>如果原型链都不存在，就用Object原型对象上的</li><li>如果Object原型对象都不存在， 就是undefined</li></ul></li><li>数组和字面量对象都是引用</li><li><p>this指向在引用时确认而不是定义时</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>下面分别模拟Q1-Q6的执行情况</p><h5 id="Q1："><a href="#Q1：" class="headerlink" title="Q1："></a>Q1：</h5><p>直接调用<code>parent.show()</code>,此时this指向parent,语句中的三条语句相当于分别在给window对象上赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parent.a = <span class="number">1</span>;</span><br><span class="line">parent.b = [<span class="number">1</span>, <span class="number">2</span>, parent.a];</span><br><span class="line">parent.c = &#123; <span class="attr">demo</span>: <span class="number">8</span> &#125;;</span><br></pre></td></tr></table></figure></li></ul><p> 此时，parent对象应为：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">a:<span class="number">1</span>,</span><br><span class="line">b:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],</span><br><span class="line">c:&#123;</span><br><span class="line">demo:<span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Q2"><a href="#Q2" class="headerlink" title="Q2:"></a>Q2:</h5><p> 在执行<code>var child1 = new Child();</code>语句时，child对象的a值为2，而因为后被手动赋值为11，所以child实例上的a被改为11，这时调用原型链上的<code>show()</code>方法，依次打印,</p><p> 这里<code>this.a</code>根据原型链的查找规则，在实例上有a的赋值，所以直接使用实例上的值也就是11，其他值实例上没有，需要在原型上寻找，所以输出b为<code>[1,2,this.a]</code>,</p><p> 而这里的this.b因为是数组，为引用类型，在执行<code>var parent = new Parent();</code>时被定义在parent实例上，所有this.a的指针指向共同的引用地址，所以为1 ,</p><p> this.c因为也是引用类型，指针也被指向共同的引用对象地址。</p><h5 id="Q3："><a href="#Q3：" class="headerlink" title="Q3："></a>Q3：</h5><p> 实例上的a被重新赋值，所以<code>this.a</code>的输出被改为12，其余执行步骤同Q2。</p><h5 id="Q4："><a href="#Q4：" class="headerlink" title="Q4："></a>Q4：</h5><p> 相当于再次调用parent实例上的show方法，因为数据没有发生变动，所以输出值同Q1。</p><h5 id="Q5："><a href="#Q5：" class="headerlink" title="Q5："></a>Q5：</h5><p> 因为在调用<code>this.change</code>时，this.a的值被赋值为this.b数组的长度，所有这里的a输出为4，this.b的值使用引用地址b数组，因为在下一步中又执行了一次对this.b数组的push，所以这里打印this.b是被push两次后的数组，而this.c也是被push两次后的数组的长度，注意因为this.a和this.c的数据类型不同，所以this.a是单独的内存，而this.c则是使用相同一块内存。</p><h5 id="Q6"><a href="#Q6" class="headerlink" title="Q6:"></a>Q6:</h5><p> 又对this.b数组执行了一次push，所以这次this.a的输出应为数组的当前长度也就是5，this.c的值也是数组长度也就是5。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p> 在chrome控制台中运行代码得到结果如下：</p><p> <img src="https://user-images.githubusercontent.com/29997411/50052858-bca89400-0165-11e9-866f-baa5371500b6.jpg" alt="jietu20181216-183105"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redux中间件</title>
      <link href="/2018/08/03/Redux%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2018/08/03/Redux%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提到中间件，你可能会想到<code>Express</code>和<code>Koa</code>等服务端框架，没想到也没关系，这句话是我装逼用的。</p><p>那么redux中的中间件到底干嘛用的？</p><p>有这样一个问题？我们之前用的<code>Redux</code>都是在<code>Action</code>发出之后立即执行<code>Reducer</code>,计算出<code>state</code>,这是同步操作。如果想异步操作呢？即过一段时间再执行<code>Reducer</code>怎么办？这里就需要用到中间件<code>middleware</code>。</p><p>先放一张图看看：<br><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dcb142c194bfb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="一、中间件的概念"><a href="#一、中间件的概念" class="headerlink" title="一、中间件的概念"></a>一、中间件的概念</h2><p><code>redux</code>是有流程的，那么，我们该把这个异步操作放在哪个环节比较合适呢？</p><ul><li><code>Reducer</code>?纯函数只承担计算<code>State</code>功能，不适合其它功能。</li><li><code>View</code>?与<code>State</code>一一对应，可以看做是<code>State</code>的视觉层，也不适合承担其它功能。</li><li><code>Action</code>？它是一个对象，即存储动作的载体，只能被操作。</li></ul><p>其实，也只有<code>dispatch</code>能胜任此重任了。那么怎么在<code>dispatch</code>中添加其它操作呢？</p><pre><code>let next = store.dispatch;store.dispatch = function(action){   console.log(&apos;老状态 &apos;,store.getState());   next(action);   console.log(&apos;新状态 &apos;,store.getState());}</code></pre><p>示例中可以看出，我们对<code>store.dispatch</code>重新进行了定义，在发送<code>action</code>的前后，做了打印。</p><p>这是中间件的大致雏形，真实的中间件要比这么复杂多了</p><h2 id="二、中间件的用法"><a href="#二、中间件的用法" class="headerlink" title="二、中间件的用法"></a>二、中间件的用法</h2><p>我们在这里先看看中间件是怎么使用，下面我们一步步剖析每个细节。</p><pre><code>import {applyMiddleware,createStore} from &apos;redux&apos;;import reduxLogger form &apos;redux-logger&apos;;const store = createStore(reducer,inital_state,applyMiddleware(thunk, promise,reduxLogger));</code></pre><p>代码中有两点需要注意：</p><ul><li><p>1、<code>createStore</code>方法可以整个应用的初始状态作为参数<br>内部是这么处理的</p><p>  let state = inital_state;</p></li></ul><ul><li>2、中间件的参数次序有讲究。下面我会把这个问题讲明白。</li></ul><h2 id="三、applyMiddleware"><a href="#三、applyMiddleware" class="headerlink" title="三、applyMiddleware"></a>三、applyMiddleware</h2><p>Middleware可以让你包装<code>store</code>的<code>dispatch</code>方法来达到你想要的目的。同时，<code>middleWare</code>还拥有“可组合”这一关键特性。多个<code>middleWare</code>可以被组合到一起使用，形成<code>middleWare</code>链，依次执行。其中每个<code>middleware</code>不需要关心链前后的的<code>middleWare</code>的任何信息。</p><pre><code>function applyMiddleware(...middlewares){    returnfunction(createStore){        returnfunction(reducer){            //引入store            let store = createStore(reducer);            let dispatch = store.dispatch;            let middlewareAPI = {                getState:store.getState,                // 对dispatch进行包装                dispatch:action=&gt;dispatch(action)            }            //每个中间件都是这种模型  ({ getState, dispatch }) =&gt; next =&gt; action            chain = middlewares.map(middleware=&gt;middleware(middleAPI));            dispatch = compose(...chain)(store.dispatch);            // dispatch被改装后，返回store            return{...store,dispatch};        }    }}</code></pre><p>上面代码中，所有中间件都被放进了一个数组<code>chain</code>,然后嵌套执行，最后执行<code>store.dispatch</code>。中间件内部<code>middlewaAPI</code>可以拿到<code>getState</code>和<code>dispatch</code>这两个方法。</p><p><code>...middleware</code>：遵循<code>Redux middleware API</code>的函数。每个<code>middleware</code>接受<code>Store</code>的<code>dispatch</code>和<code>getState</code>函数作为命名参数，并返回一个函数。该函数会被传入成为<code>next</code>的下一个middleWare 的dispatch方法，并返回一个接收action的新函数，这个函数可以直接调用next(action)，或者在其他需要的时刻调用，甚至根本不去调用它。</p><p>所以，接下来，我们就能看到middleware的函数签名是<code>({ getState, dispatch }) =&gt; next =&gt; action</code></p><p>其实，它的本质就是包装sotre中的<code>dispatch</code>。</p><p>上面代码中，还用到了<code>compose</code>方法，我们来看看compose是怎么是实现的？</p><h3 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h3><p>先看下面一个栗子：</p><pre><code>function add1(str){   return str+1;}function add2(str){    return str+2; } function add3(str){    return str+3; } let result = add3(add2(add1(&apos;好吃&apos;)));// 好吃123;</code></pre><p>这中写法调用起来，一层套一层，是不是看着很不爽，我们简化一下：</p><pre><code>function compose(...fns){    if(fns.length==1)     return fns[0];   returnfunction(...args){    let last = fns.pop();    return fns.reduceRight((prev,next)=&gt;{         return  next(prev);      },last(...args));   } } let add = compose(add3,add2,add1);// let result = add(&apos;好吃&apos;);// 好吃123 // 上面的代码其实就是redux3.6.0版本中compose的实现方式</code></pre><p>看看这个代码是不是用起来，很干练一些。其实还可以简化</p><pre><code>function compose(...fns){  if(fns.length==1)     return fns[0];   return fns.reduce((a,b)=&gt;(...args)=&gt;a(b(...args)));//add3(add2(add1(&apos;好吃&apos;))) } let add = compose(add3,add2,add1);// let result = add(&apos;好吃&apos;);// 好吃123 // 这是redux3.6.0版本之后的compose实现方式，一直沿用至今。</code></pre><p>至于为什么<code>applyMiddleWare</code>的参数有顺序，这里给出了答案。</p><h2 id="四、Applymiddleware的三个常用参数"><a href="#四、Applymiddleware的三个常用参数" class="headerlink" title="四、Applymiddleware的三个常用参数"></a>四、Applymiddleware的三个常用参数</h2><h3 id="4-1、日志记录"><a href="#4-1、日志记录" class="headerlink" title="4.1、日志记录"></a>4.1、日志记录</h3><p>使用 Redux 的一个益处就是它让 state 的变化过程变的可预知和透明。每当一个 action 发起完成后，新的 state 就会被计算并保存下来。State 不能被自身修改，只能由特定的 action 引起变化。</p><p>试想一下，当我们的应用中每一个 action 被发起以及每次新的 state 被计算完成时都将它们记录下来，岂不是很好？当程序出现问题时，我们可以通过查阅日志找出是哪个 action 导致了 state 不正确。<br><img src="https://user-gold-cdn.xitu.io/2018/4/19/162dd052d2e07b77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>图片的效果是不是很期待啊！！！</p><p>我们先来手动实现一版。</p><pre><code>// 记录所有被发起的action和新的statelet next = store.dispatch;store.dispatch = function(action){   console.log(&apos;老状态 &apos;,store.getState());   next(action);   console.log(&apos;新状态 &apos;,store.getState());}</code></pre><p>还是上面的示例，我们来做个修改</p><pre><code>let logger = function({ getState, dispatch }){   returnfunction(next){// 这里的next可以理解为store.dispath,本质上就是调用 middleware 链中下一个 middleware 的 dispatch。returnfunction(action){        console.log(&apos;老状态1 &apos;,getState());        next(action);//派发动作console.log(&apos;新状态1 &apos;,getState());    }    }}// 高逼格写法let logger = ({ getState, dispatch }) =&gt; next =&gt; action =&gt; {  console.log(&apos;老状态1 &apos;,getState());  next(action)  console.log(&apos;新状态1 &apos;,getState());}</code></pre><h3 id="4-2、redux-thunk-中间件"><a href="#4-2、redux-thunk-中间件" class="headerlink" title="4.2、redux-thunk 中间件"></a>4.2、redux-thunk 中间件</h3><p><code>redux-thunk</code> 是<code>redux</code>官方文档中用到的异步组件，实质就是一个<code>redux</code>中间件，一个封装表达式的函数，封装的目的就是延迟执行表达式。</p><p><code>redux-thunk</code>是一个通用的解决方案，其核心思想是让<code>action</code>可以变成一个<code>thunk</code>，这样的话，同步情况：<code>dispatch(action)</code>,异步情况：<code>dispatch(thunk)</code>。</p><p>下面是<code>redux-thunk</code>的实现：</p><pre><code>let thunk = ({dispatch,getState})=&gt;next=&gt;action=&gt;{    if(typeof action == &apos;function&apos;){        action(dispatch,getState);    }else{        next(action);//这里可以理解为dispatch(action),本质上就是调用 middleware 链中下一个 middleware 的 dispatch。    }}</code></pre><p>使用redux-thunk</p><pre><code>const store = createStore(    reducer,  applyMiddleware(thunk));</code></pre><p>然后我们实现一个thunkActionCreator</p><pre><code>//过一秒加1exportfunction thunkActionCreator(payload){    returnfunction(dispatch,getState){        setTimeout(function(){            dispatch({type:types.INCREMENT,payload:payload});        },1000);    }},</code></pre><p>最后，在组件中dispatch thunk</p><pre><code>this.dispatch(thunkActionCreator(payload));</code></pre><h3 id="4-3、redux-promise"><a href="#4-3、redux-promise" class="headerlink" title="4.3、redux-promise"></a>4.3、redux-promise</h3><p><code>redux-promise</code>也是延迟执行的表达式，它是解决异步的另外一种方案。</p><p><code>redux-thunk</code>和核心思想是把<code>action</code>变成<code>thunk</code>，而<code>redux-promise</code>的核心思想是让<code>action</code>返回一个promise对象。</p><p>这个中间件使得<code>store.dispatch</code>方法可以接收Promise对象作为参数。这时 ，action 有两种写法:</p><p>写法一、返回值是一个Promise对象。</p><pre><code>functionpromiseIncrement(payload){ //  return {type:types.INCREMENT,payload:payload}  以前是这种写法returnnewPromise(function(resolve,reject){      setTimeout(function(){        resolve({type:types.INCREMENT,payload:payload});      },1000);    }); },</code></pre><p>写法二，action 对象的payload属性是一个Promise对象，这需要从</p><pre><code>functionpayloadIncrement(){    return {        type:types.INCREMENT,        payload: newPromise(function(resolve,reject){            setTimeout(function(){                if(Math.random()&gt;.5){                    resolve(100);                }else{                    reject(-100);                }            },1000)        })    }}</code></pre><p>下面我们来看看 <code>redux-promise</code>是怎么实现的，就会明白它内部是怎么操作的.</p><pre><code>let promise = ({dispatch,getState})=&gt;next=&gt;action=&gt;{    if(action.then &amp;&amp; typeof action.then == &apos;function&apos;){        action.then(dispatch);        // 这里的dispatch就是一个函数，dispatch(action){state:reducer(state,action)};    }elseif(action.payload&amp;&amp; action.payload.then&amp;&amp; typeof action.payload.then == &apos;function&apos;){        action.payload.then(payload=&gt;dispatch({...action,payload}),payload=&gt;dispatch({...action,payload}));    }else{        next(action);    }}</code></pre><p>上面的代码可以看出，如果Action本身就是一个Promise，它resolve以后的值应该是一个Action对象，会被dispatch方法送出action.then(dispatch)；如果<code>Action</code>对象的 <code>payload</code>属性是一个<code>Promise</code>对象，那么无论<code>resolve</code>和<code>reject</code>,dispatch 方法都会发出<code>Action</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 ES6 中 Promise 的面试题</title>
      <link href="/2018/07/30/%E5%85%B3%E4%BA%8E-ES6-%E4%B8%AD-Promise-%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/07/30/%E5%85%B3%E4%BA%8E-ES6-%E4%B8%AD-Promise-%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>最近在复习 Promise 的知识，所以就做了一些题，这里挑出几道题，大家一起看看吧。</p><h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><pre><code>const promise = newPromise((resolve, reject) =&gt; {    console.log(1);    resolve();    console.log(2);})promise.then(() =&gt; {    console.log(3);})console.log(4);</code></pre><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>首先 Promise 新建后立即执行，所以会先输出 1，2，而 <code>Promise.then()</code> 内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><pre><code>1243</code></pre><h3 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h3><pre><code>const promise = newPromise((resolve, reject) =&gt; {    resolve(&apos;success1&apos;);    reject(&apos;error&apos;);    resolve(&apos;success2&apos;);});promise.then((res) =&gt; {    console.log(&apos;then:&apos;, res);}).catch((err) =&gt; {    console.log(&apos;catch:&apos;, err);})</code></pre><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p><code>resolve 函数</code>将 Promise 对象的状态从<code>“未完成”变为“成功”</code>（即从 <code>pending 变为 resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</p><p><code>reject 函数</code>将 Promise 对象的状态从<code>“未完成”变为“失败”</code>（即从 <code>pending 变为 rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p>而一旦状态改变，就不会再变。<br>所以 代码中的<code>reject(&#39;error&#39;);</code> 不会有作用。</p><p>Promise 只能 resolve 一次，剩下的调用都会被忽略。<br>所以 第二次的 <code>resolve(&#39;success2&#39;);</code> 也不会有作用。</p><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><pre><code>then: success1</code></pre><h3 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h3><pre><code>Promise.resolve(1)  .then(2)  .then(Promise.resolve(3))  .then(console.log)</code></pre><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p><code>Promise.resolve</code> 方法的参数如果是一个原始值，或者是一个不具有 <code>then</code> 方法的对象，则 <code>Promise.resolve</code> 方法返回一个新的 <code>Promise</code> 对象，状态为<code>resolved</code>，<code>Promise.resolve</code> 方法的参数，会同时传给回调函数。</p><p><code>then</code> 方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为 <code>then(null)</code>，这就会导致前一个 <code>Promise</code> 的结果会穿透下面。</p><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><pre><code>1</code></pre><h3 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h3><p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用Promse实现）三个亮灯函数已经存在：</p><pre><code>functionred() {    console.log(&apos;red&apos;);}functiongreen() {    console.log(&apos;green&apos;);}functionyellow() {    console.log(&apos;yellow&apos;);}</code></pre><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次，意思就是3秒，执行一次 red 函数，2秒执行一次 green 函数，1秒执行一次 yellow 函数，不断交替重复亮灯，意思就是按照这个顺序一直执行这3个函数，这步可以就利用递归来实现。</p><h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><pre><code>functionred() {    console.log(&apos;red&apos;);}functiongreen() {    console.log(&apos;green&apos;);}functionyellow() {    console.log(&apos;yellow&apos;);}var light = function (timmer, cb) {    returnnewPromise(function (resolve, reject) {        setTimeout(function () {            cb();            resolve();        }, timmer);    });};var step = function () {    Promise.resolve().then(function () {        return light(3000, red);    }).then(function () {        return light(2000, green);    }).then(function () {        return light(1000, yellow);    }).then(function () {        step();    });}step();</code></pre><p>这个答案，看上去已经很不错了，不过经小伙伴提醒，如果一直这么递归下去，会有栈溢出的问题，对于这个问题，其他小伙伴有什么优化建议的话，可以在评论区展示出来。</p><h3 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h3><p>实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中。</p><pre><code>const timeout = ms =&gt;newPromise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        resolve();    }, ms);});const ajax1 = () =&gt; timeout(2000).then(() =&gt; {    console.log(&apos;1&apos;);    return1;});const ajax2 = () =&gt; timeout(1000).then(() =&gt; {    console.log(&apos;2&apos;);    return2;});const ajax3 = () =&gt; timeout(2000).then(() =&gt; {    console.log(&apos;3&apos;);    return3;});const mergePromise = ajaxArray =&gt; {    // 在这里实现你的代码};mergePromise([ajax1, ajax2, ajax3]).then(data =&gt; {    console.log(&apos;done&apos;);    console.log(data); // data 为 [1, 2, 3]});// 要求分别输出// 1// 2// 3// done// [1, 2, 3]</code></pre><h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><p>首先 <code>ajax1 、ajax2、ajax3</code> 都是函数，只是这些函数执行后会返回一个 <code>Promise</code>，按题目的要求我们只要顺序执行这三个函数就好了，然后把结果放到 <code>data</code> 中，但是这些函数里都是异步操作，想要按顺序执行，然后输出 1，2，3并没有那么简单，看个例子。</p><pre><code>functionA() {    setTimeout(function () {        console.log(&apos;a&apos;);    }, 3000);}functionB() {    setTimeout(function () {        console.log(&apos;b&apos;);    }, 1000);}A();B();// b// a</code></pre><p>例子中我们是按顺序执行的 <code>A</code>，<code>B</code> 但是输出的结果却是 <code>b</code>，<code>a</code> 对于这些异步函数来说，并不会按顺序执行完一个，再执行后一个。<br>这道题就是考用 <code>Promise</code> 控制异步流程，我们要想办法，让这些函数，一个执行完之后，再执行下一个，看答案吧。</p><h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><pre><code>// 保存数组中的函数执行后的结果var data = [];// Promise.resolve方法调用时不带参数，直接返回一个resolved状态的 Promise 对象。var sequence = Promise.resolve();ajaxArray.forEach(function (item) {    // 第一次的 then 方法用来执行数组中的每个函数，// 第二次的 then 方法接受数组中的函数执行后返回的结果，// 并把结果添加到 data 中，然后把 data 返回。    sequence = sequence.then(item).then(function (res) {        data.push(res);        return data;    });})// 遍历结束后，返回一个 Promise，也就是 sequence， 他的 [[PromiseValue]] 值就是 data，// 而 data（保存数组中的函数执行后的结果） 也会作为参数，传入下次调用的 then 方法中。return sequence;</code></pre><h3 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h3><p>以下代码最后输出什么？</p><pre><code>const first = () =&gt; (newPromise((resolve, reject) =&gt; {    console.log(3);    let p = newPromise((resolve, reject) =&gt; {        console.log(7);        setTimeout(() =&gt; {            console.log(5);            resolve(6);        }, 0)        resolve(1);    });    resolve(2);    p.then((arg) =&gt; {        console.log(arg);    });}));first().then((arg) =&gt; {    console.log(arg);});console.log(4);</code></pre><h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><p>这道题就其实和 <code>Promise</code> 的关系不太大，主要是需要理解 JS执行机制，才能很好的解决这道题，对于 JS 执行机制不了解的朋友推荐看看这篇文章</p><p><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F59e85eebf265da430d571f89" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></p><h4 id="第一轮事件循环"><a href="#第一轮事件循环" class="headerlink" title="第一轮事件循环"></a>第一轮事件循环</h4><p>先执行宏任务，主script ，new Promise立即执行，输出【3】，</p><p>执行 p 这个new Promise 操作，输出【7】，</p><p>发现 setTimeout，将回调放入下一轮任务队列（Event Queue），p 的 then，姑且叫做 then1，放入微任务队列，发现 first 的 then，叫 then2，放入微任务队列。执行<code>console.log(4)</code>，输出【4】，宏任务执行结束。</p><p>再执行微任务，执行 then1，输出【1】，</p><p>执行 then2，输出【2】。</p><p>到此为止，第一轮事件循环结束。开始执行第二轮。</p><h4 id="第二轮事件循环"><a href="#第二轮事件循环" class="headerlink" title="第二轮事件循环"></a>第二轮事件循环</h4><p>先执行宏任务里面的，也就是 setTimeout 的回调，输出【5】。<br><code>resolve(6)</code> 不会生效，因为 p 这个 Promise 的状态一旦改变就不会在改变了。</p><h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><pre><code>374125</code></pre><h3 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h3><p>有 8 个图片资源的 url，已经存储在数组 <code>urls</code> 中（即<code>urls = [&#39;http://example.com/1.jpg&#39;, ...., &#39;http://example.com/8.jpg&#39;]）</code>，而且已经有一个函数 <code>function loadImg</code>，输入一个 url 链接，返回一个 Promise，该 Promise 在图片下载完成的时候 resolve，下载失败则 reject。<br>但是我们要求，任意时刻，同时下载的链接数量不可以超过 3 个。<br>请写一段代码实现这个需求，要求尽可能快速地将所有图片下载完成。</p><pre><code>var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;];functionloadImg(url) {    returnnewPromise((resolve, reject) =&gt; {        const img = new Image()        img.onload = function () {            console.log(&apos;一张图片加载完成&apos;);            resolve();        }        img.onerror = reject        img.src = url    })};</code></pre><h3 id="解析-6"><a href="#解析-6" class="headerlink" title="解析"></a>解析</h3><p>题目的意思是需要我们这么做，先并发请求 3 张图片，当一张图片加载完成后，又会继续发起一张图片的请求，让并发数保持在 3 个，直到需要加载的图片都全部发起请求。</p><p>用 Promise 来实现就是，先并发请求3个图片资源，这样可以得到 3 个 Promise，组成一个数组，就叫<code>promises</code> 吧，然后不断的调用 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise%23Promise-race" target="_blank" rel="noopener">Promise.race</a> 来返回最快改变状态的 Promise，然后从数组（<code>promises</code>）中删掉这个 Promise 对象，再加入一个新的 Promise，直到全部的 url 被取完，最后再使用 <a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fpromise%23Promise-all" target="_blank" rel="noopener">Promise.all</a> 来处理一遍数组（<code>promises</code>）中没有改变状态的 Promise。</p><h3 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h3><pre><code>var urls = [&apos;https://www.kkkk1000.com/images/getImgData/getImgDatadata.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/gray.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/Particle.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.png&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic2.gif&apos;, &apos;https://www.kkkk1000.com/images/getImgData/getImgDataError.jpg&apos;, &apos;https://www.kkkk1000.com/images/getImgData/arithmetic.gif&apos;, &apos;https://user-gold-cdn.xitu.io/2018/10/29/166be40ccc434be0?w=600&amp;h=342&amp;f=png&amp;s=122185&apos;];functionloadImg(url) {    returnnewPromise((resolve, reject) =&gt; {        const img = new Image()        img.onload = function () {            console.log(&apos;一张图片加载完成&apos;);            resolve();        }        img.onerror = reject        img.src = url    })};functionlimitLoad(urls, handler, limit) {    // 对数组做一个拷贝const sequence = [].concat(urls)    let promises = [];    //并发请求到最大数    promises = sequence.splice(0, limit).map((url, index) =&gt; {        // 这里返回的 index 是任务在 promises 的脚标，用于在 Promise.race 之后找到完成的任务脚标return handler(url).then(() =&gt; {            return index        });     });    // 利用数组的 reduce 方法来以队列的形式执行return sequence.reduce((last, url, currentIndex) =&gt; {        return last.then(() =&gt; {            // 返回最快改变状态的 PromisereturnPromise.race(promises)        }).catch(err =&gt; {            // 这里的 catch 不仅用来捕获 前面 then 方法抛出的错误// 更重要的是防止中断整个链式调用console.error(err)        }).then((res) =&gt; {            // 用新的 Promise 替换掉最快改变状态的 Promise            promises[res] = handler(sequence[currentIndex]).then(() =&gt; { return res });        })    }, Promise.resolve()).then(() =&gt; {        returnPromise.all(promises)    })}limitLoad(urls, loadImg, 3)/*因为 limitLoad 函数也返回一个 Promise，所以当 所有图片加载完成后，可以继续链式调用limitLoad(urls, loadImg, 3).then(() =&gt; {    console.log(&apos;所有图片加载完成&apos;);}).catch(err =&gt; {    console.error(err);})*/</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue安全权限控制axios拦截</title>
      <link href="/2018/07/02/Vue%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6axios%E6%8B%A6%E6%88%AA/"/>
      <url>/2018/07/02/Vue%E5%AE%89%E5%85%A8%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6axios%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<p>何为权限控制</p><pre><code>//请求失败后的统一拦截，以及ajax的基本设置import axios from &apos;axios&apos;;import qs from &apos;qs&apos;;function cleanRequest(req) {  for (const i in req) {    /* eslint guard-for-in: 0 */    if (req[i] !== 0 &amp;&amp; !req[i]) {      delete req[i];    }  }}axios.defaults.withCredentials = true;axios.defaults.xsrfCookieName = null;axios.defaults.headers.common[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos;;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;//系统弹层import Toast from &apos;mint-ui/lib/toast&apos;;import &apos;mint-ui/lib/toast/style.css&apos;;module.exports.install = function (Vue) {  axios.defaults.baseURL=&quot;/&quot;;  Vue.prototype.$http = axios;  Vue.http = axios;  axios.interceptors.request.use(    function (request) {      const params = request.params;      if (params) {        cleanRequest(params);      }      if (request.data) {        cleanRequest(request.data);        request.data=qs.stringify(Object.assign(request.data,Bus.movieConfig))      }else{        request.data=qs.stringify(Bus.movieConfig)      }      return request;    },    function (error) {      return Promise.reject(error);    }  );  // Add a response interceptor  axios.interceptors.response.use(    function (response) {      return response;    },    function (error) {      Toast(&apos;系统繁忙，请稍后重试!&apos;);      // Do something with response error      return Promise.reject(error);    }  );};</code></pre><p>权限控制大致分为两个维度:</p><ul><li>垂直维度: 控制用户可以访问哪些url的权限</li><li>水平维度: 控制用户访问特定url，获取哪些数据的权限（e.g. 普通用户、管理员、超级管理员访问同一url，获取的数据是不同的）</li></ul><p>Web权限控制方案List</p><ul><li>前后端不分离：以Java为例，后端通过jsp、freemark、thmeleaf等模板来渲染相应权限的数据，渲染完呈现在浏览器端</li><li>前后端分离：<br>▫SPA单页面应用，路由由前端控制，前端通过js控制hash路由的权限<br>▫SSR服务端渲染，Node中间层做代理路由，判断权限渲染特定的路由至浏览器端</li></ul><p>SPA前端权限控制方案</p><p>SPA: 单页Web应用（single page web application）将所有web活动局限于一个html页面中，利用js通过hash或者浏览器history api来实现无刷新路由跳转，前后端通过ajax数据通信，避免了浏览器的刷新重新加载，为用户提供流程的操作体验。这意味着前端接管了路由层，需要通过调用前端自身的MVC模块，来渲染不同的页面。</p><blockquote><p>Base on：</p></blockquote><ul><li>Vue 前端MVVM框架</li><li>Vuex 状态管理机</li><li>Vue-router 路由</li><li>Axios HTTP请求库</li></ul><p>1.登陆事件Login</p><pre><code>// 1.触发登陆事件dispatch(&apos;login&apos;)// actionscommit(types.LOGIN_SUCCESS, res.data.data)...</code></pre><p>2.获取Token，经Base64编码后存至sessionStorage</p><pre><code>// mutationsconst mutations = {    [types.LOGIN_SUCCESS] (state, data) {        state.authlock = false    // 2.登陆成功回调拿到token,经Base64 编码后存入本地sessionStorage        let token = Base64.encode(data + &apos;:HIKDATAE&apos;)        sessionStorage.setItem(&apos;userToken&apos;, token)    // 路由跳转至目标页面        router.push({name: &apos;xxx&apos;})    },    [types.LOGOUT_SUCCESS] (state) {        state.authlock = true    // 登出成功回调,移除本地token        sessionStorage.removeItem(&apos;userToken&apos;)        router.push({name: &apos;Login&apos;})    }}</code></pre><p>3.所有HTTP Header Authorization 加上编码后的token(前后端可约定规则)</p><pre><code>// Axios 请求钩子（request）axios.interceptors.request.use(req =&gt; {    let token = sessionStorage.getItem(&apos;user&apos;)         if (token) {                 // 3.token 存在,则在之后所有请求的http请求头 Authorization 带上base64编码后的token,后台拿到token后进行验证权限                 req.headers.Authorization = `Basic ${token}`         }    req.data = qs.stringify(req.data)         return req }, error =&gt; {    return Promise.reject(error) })</code></pre><p>浏览器http header<br><img src="https://pic4.zhimg.com/v2-48ee52913451d66397f33a47f6af3374_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-48ee52913451d66397f33a47f6af3374_hd.jpg" alt=""></p><p>4.请求拦截：后台拿到token后对每个请求进行校验，若校验失败返回401，前端response钩子里统一catch error 跳转至登陆页面。</p><pre><code>// Axios 请求钩子（response）axios.interceptors.response.use(res =&gt; {    return res}, error =&gt; {    if (error.response) {        switch (error.response.status) {        // 4.所有接口response校验钩子,若token检验失败,后台返回 401 error code, 清除token信息并跳转到登录页面            case 401:                store.commit(types.LOGOUT)                router.replace({                    path: &apos;/login&apos;        })    }    }    return Promise.reject(error)})</code></pre><p>5.路由跳转拦截：任意路由跳转时，在路由beforeEach钩子里校验本地是否存在token，若没有，则跳转至登陆页面</p><pre><code>// 路由钩子(每个路由跳转前调起beforeEach钩子)router.beforeEach((to, from, next) =&gt; {  if (to.path === &apos;/login&apos;) {    sessionStorage.removeItem(&apos;userToken&apos;)  }  let user = sessionStorage.getItem(&apos;userToken&apos;)  if (!user &amp;&amp; to.path !== &apos;/login&apos;) {    // 若本地token不存在,则任意路由跳转的时候,重定向至login 登陆页面    next({ path: &apos;/login&apos; })  } else {    next()  }})</code></pre><p>6.登出Logout：清楚本地sessionStorage的token信息</p><pre><code>// mutationsconst mutations = {    ...    [types.LOGOUT_SUCCESS] (state) {        state.authlock = true    // 登出成功回调,移除本地token        sessionStorage.removeItem(&apos;userToken&apos;)    router.push({name: &apos;Login&apos;})    }}</code></pre><p>流程示意图如下:<br><img src="https://pic2.zhimg.com/v2-064f7b05f15399ac9ff6aa03ee1cb710_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-064f7b05f15399ac9ff6aa03ee1cb710_hd.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端设置了overflow:hidden和border-radius，子元素超出部分不隐藏问题？</title>
      <link href="/2018/06/21/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BA%86overflow-hidden%E5%92%8Cborder-radius%EF%BC%8C%E5%AD%90%E5%85%83%E7%B4%A0%E8%B6%85%E5%87%BA%E9%83%A8%E5%88%86%E4%B8%8D%E9%9A%90%E8%97%8F%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
      <url>/2018/06/21/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BA%86overflow-hidden%E5%92%8Cborder-radius%EF%BC%8C%E5%AD%90%E5%85%83%E7%B4%A0%E8%B6%85%E5%87%BA%E9%83%A8%E5%88%86%E4%B8%8D%E9%9A%90%E8%97%8F%E9%97%AE%E9%A2%98%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;        &lt;link rel=&quot;stylesheet&quot;type=&quot;text/css&quot; href=&quot;css/SB.css&quot; /&gt;        &lt;style type=&quot;text/css&quot;&gt;            .main {                width: 300px;                height: 100px;                border: 1px solid red;                border-radius: 15px;                overflow: hidden;                /*transform:rotate(0deg); */            }            .con {                display: block;                overflow: scroll;                overflow-y: hidden;                -webkit-overflow-scrolling: touch;                white-space: nowrap;                font-size: 0px;            }            .item {                width: 100px;                height: 100px;                background: green;                display: inline-block;                position: relative;            }            .item:nth-child(2n) {                background: red;            }            .item p{                width: 50px;                height: 20px;                color: white;                text-align: center;                position: absolute;                left: 50%;                transform: translateX(-50%);                top: 0px;                background: blue;                font-size: 12px;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;main&quot;&gt;            &lt;div class=&quot;con&quot;&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;p&gt;快点&lt;/p&gt;                &lt;/div&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;p&gt;快点&lt;/p&gt;                &lt;/div&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;p&gt;快点&lt;/p&gt;                &lt;/div&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;p&gt;快点&lt;/p&gt;                &lt;/div&gt;                &lt;div class=&quot;item&quot;&gt;                    &lt;p&gt;快点&lt;/p&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;复制代码</code></pre><h3 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d69655dafdb2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d6a28737a214?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>解决办法：</p><pre><code>.main {                width: 300px;                height: 100px;                border: 1px solid red;                border-radius: 15px;                overflow: hidden;                transform:rotate(0deg);  /*transform: scale(1);也可以*/            }复制代码</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/5/14/1635d6b547a6dd86?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript的事件循环</title>
      <link href="/2018/06/03/JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
      <url>/2018/06/03/JavaScript%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-js-事件循环一-浅析"><a href="#Node-js-事件循环一-浅析" class="headerlink" title="Node.js 事件循环一: 浅析"></a>Node.js 事件循环一: 浅析</h2><blockquote><p>理解事件循环系列第一步 浅析和总览</p></blockquote><p>多数的网站不需要大量计算，程序花费的时间主要集中在磁盘 I/O 和网络 I/O 上面</p><p>SSD读取很快，但和CPU处理指令的速度比起来也不在一个数量级上，而且网络上一个数据包来回的时间更慢：</p><p><img src="https://pic1.zhimg.com/v2-67a42368c7dffa3348730760c9c0b907_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-67a42368c7dffa3348730760c9c0b907_hd.jpg" alt=""></p><p>一个数据包来回的延迟平均320ms(我网速慢，ping国内网站会更快)，这段时间内一个普通 cpu 执行几千万个周期应该没问题</p><p>因此异步IO就要发挥作用了，比如用多线程，如果用 Java 去读一个文件，这是一个阻塞的操作，在等待数据返回的过程中什么也干不了，因此就开一个新的线程来处理文件读取，读取操作结束后再去通知主线程。</p><p>这样虽然行得通，但是代码写起来比较麻烦。像 Node.js V8 这种无法开一个线程的怎么办？</p><p>先看下面函数执行过程</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>当我们调用一个函数，它的地址、参数、局部变量都会压入到一个 stack 中</p><pre><code>function fire() {    const result = sumSqrt(3, 4)    console.log(result);}function sumSqrt(x, y) {    const s1 = square(x)    const s2 = square(y)    const sum = s1 + s2;    return Math.sqrt(sum)}function square(x) {    return x * x;}fire()</code></pre><blockquote><p>下面的图都是用 keynote 做的 <a href="https://link.zhihu.com/?target=https%3A//github.com/ccforward/cc/blob/master/Blog/pic/event-loop.key" target="_blank" rel="noopener">keynote地址</a></p></blockquote><p>函数 <code>fire</code> 首先被调用</p><p><img src="https://pic3.zhimg.com/v2-a3840ed51ad7ccaedb915e05b087e1e4_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-a3840ed51ad7ccaedb915e05b087e1e4_hd.jpg" alt=""></p><p><code>fire</code> 调用 <code>sumSqrt</code> 函数 参数为3和4</p><p><img src="https://pic4.zhimg.com/v2-5871549477044a0e7a657f9a16e9367c_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-5871549477044a0e7a657f9a16e9367c_hd.jpg" alt=""></p><p>之后调用 <code>square</code> 参数为 x, x==3</p><p><img src="https://pic2.zhimg.com/v2-ced7e64c06861509c593cdb0cfbc594e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-ced7e64c06861509c593cdb0cfbc594e_hd.jpg" alt=""></p><p>当 <code>square</code> 执行结束返回时，从 stack 中弹出，并将返回值赋值给 s1<br>s1加入到 sumSqrt 的 stack frame 中</p><p><img src="https://pic2.zhimg.com/v2-0f214a42ee6c2226c343edb7431116be_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-0f214a42ee6c2226c343edb7431116be_hd.jpg" alt=""></p><p>以同样的方式调用下一个 <code>square</code> 函数</p><p><img src="https://pic4.zhimg.com/v2-6488db685f7ba396d9bb72b80daf0465_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6488db685f7ba396d9bb72b80daf0465_hd.jpg" alt=""></p><p><img src="https://pic1.zhimg.com/v2-4900e4ce2e398d085ceb6f2ea31ad6d9_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-4900e4ce2e398d085ceb6f2ea31ad6d9_hd.jpg" alt=""></p><p>在下一行的表达式中计算出 s1+s2 并赋值给 sum</p><p><img src="https://pic3.zhimg.com/v2-0045b1427a3fd41aa31cbac4271b6200_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-0045b1427a3fd41aa31cbac4271b6200_hd.jpg" alt=""></p><p>之后调用 <code>Math.sqrt</code> 参数为sum</p><p><img src="https://pic4.zhimg.com/v2-89dc079ce6308a32fbf78c29b67c4985_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-89dc079ce6308a32fbf78c29b67c4985_hd.jpg" alt=""></p><p>现在就剩下 <code>sumSqrt</code> 函数返回计算结果了</p><p><img src="https://pic2.zhimg.com/v2-3fe1e6705f665c11f3c350bdd4f643c9_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3fe1e6705f665c11f3c350bdd4f643c9_hd.jpg" alt=""></p><p>返回值赋值给 result</p><p><img src="https://pic4.zhimg.com/v2-d55914f97f05518c2f31b10909efb4f4_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-d55914f97f05518c2f31b10909efb4f4_hd.jpg" alt=""></p><p>在 console 中打印出 result</p><p><img src="https://pic3.zhimg.com/v2-99d7b0ece63e888549b258944fe0e1e4_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-99d7b0ece63e888549b258944fe0e1e4_hd.jpg" alt=""></p><p>最终 <code>fire</code> 没有任何返回值 从stack中弹出 stack也清空了</p><p><img src="https://pic4.zhimg.com/v2-bd4e4983cbba11fe080913f2a1d0ef43_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-bd4e4983cbba11fe080913f2a1d0ef43_hd.jpg" alt=""></p><p>当函数执行完毕后本地变量会从 stack 中弹出，这只有在使用 numbers string boolean 这种基本数据类型时才会发生。而对象、数组的值是存在于 heap(堆) 中的，stack 只存放了他们对应的指针。</p><p>当函数之行结束从 stack 中弹出来时，只有对象的指针被弹出，而真正的值依然存在 heap 中，然后由垃圾回收器自动的清理回收。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>通过一个例子来了解函数的执行顺序</p><pre><code>&apos;use strict&apos;const express = require(&apos;express&apos;)const superagent = require(&apos;superagent&apos;)const app = express()app.get(&apos;/&apos;, getArticle)function getArticle(req, res) {    fetchArticle(req, res)    print()}const aids = [4564824, 4506868, 4767667, 4856099, 7456996];function fetchArticle(req, res) {    const aid = aids[Math.floor(Math.random() * aids.length)]    superagent.get(`http://news-at.zhihu.com/api/4/news/${aid}`)        .end((err, res) =&gt; {            if(err) {                console.log(&apos;error ......&apos;);                return res.status(500).send(&apos;an error ......&apos;)            }            const article = res.body            res.send(article)            console.log(&apos;Got an article&apos;)        })    console.log(&apos;Now is fetching an article&apos;)}function print(){    console.log(&apos;Print something&apos;)}app.listen(&apos;5000&apos;)</code></pre><p>请求 <code>http://localhost:5000/</code> 后打印出</p><pre><code>Now is fetching an articlePrint somethingGot an article</code></pre><p>虽然 V8 是单线程的，但底层的 C++ API 却不是。这意味着当我们执行一些非阻塞的操作，Node会调用一些代码，与引擎里的js代码同时执行。一旦这个隐藏的线程收到了等待的返回值或者抛出一个异常，之前提供的回调函数就会执行。</p><p>上面的说的Node调用的一些代码其实就是 <a href="https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>，一个开源的跨平台的异步 I/O 。最初就是为 Node.js 开发的，现在<a href="https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv/wiki/Projects-that-use-libuv" target="_blank" rel="noopener">很多项目</a>都在用</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>javascript 是单线程事件驱动的语言，那我们可以给时间添加监听器，当事件触发时，监听器就能执行回调函数。</p><p>当我们去调用 <code>setTimeout`</code>http.get<code></code>fs.readFile`, Node.js 会把这些定时器、http、IO操作发送给另一个线程以保证V8继续执行我们的代码。</p><p>然而我们只有一个主线程和一个 call-stack ，这样当一个读取文件的操作还在执行时，有一个网络请求request过来，那这时他的回调就需要等stack变空才能执行。</p><p>回调函数正在等待轮到自己执行所排的队就被称为任务队列(或者事件队列、消息队列)。每当主线程完成前一个任务，回调函数就会在一个无限循环圈里被调用，因此这个圈被称为事件循环。</p><p>我们前面那个获取文章的例子的执行顺序就会如下：</p><ol><li>express 给 request 事件注册了一个 handler，并且当请求到达路径 ‘/‘ 时来触发handler</li><li>调过各个函数并且在端口 5000 上启动监听</li><li>stack 为空，等待 <code>request</code> 事件触发</li><li>根据传入的请求，事件触发，express 调用之前提供的函数 <code>getArticle</code></li><li><code>getArticle</code> 压入(push) stack</li><li><code>fetchArticle</code> 被调用 同时压入 stack</li><li><code>Math.floor</code> 和 <code>Math.random</code> 被调用压入 stack 然后再 弹出(pop), 从 aids 里面取出的一个值被赋值给变量 aid</li><li><code>superagent.get</code> 被执行，参数为 <code>&#39;http://news-at.zhihu.com/api/4/news/${aid}&#39;</code> ,并且回调函数注册给了 <code>end</code> 事件</li><li>到 <code>http://news-at.zhihu.com/api/4/news/${aid}</code> 的HTTP请求被发送到后台线程，然后函数继续往下执行</li><li><code>&#39;Now is fetching an article&#39;</code> 打印在 console 中。 函数 <code>fetchArticle</code> 返回</li><li><code>print</code> 函数被调用, <code>&#39;Print something&#39;</code> 打印在 console 中</li><li>函数 <code>getArticle</code> 返回，并从 stack 中弹出， stack 为空</li><li>等待 <code>http://news-at.zhihu.com/api/4/news/${aid}</code> 发送相应信息</li><li>响应信息到达，<code>end</code> 事件被触发</li><li>注册给 <code>end</code> 事件的匿名回调函数被执行，这个匿名函数和他闭包中的所有变量压入 stack，这意味着这个匿名函数可以访问并修改 <code>express</code>, <code>superagent</code>, <code>app</code>, <code>aids</code>, <code>req</code>, <code>res</code>, <code>aid</code> 的值以及之前所有已经定义的函数</li><li>函数 <code>res.send()</code> 伴随着 200 或 500 的状态码被执行，但同时又被放入到后台线程中，因此 响应流 不会阻塞我们函数的执行。匿名函数也被 pop 出 stack。</li></ol><h2 id="Microtasks-Macrotasks"><a href="#Microtasks-Macrotasks" class="headerlink" title="Microtasks Macrotasks"></a>Microtasks Macrotasks</h2><p>任务队列不止一个，还有 microtasks 和 macrotasks</p><p>microtasks:</p><ul><li>process.nextTick</li><li>promise</li><li>Object.observe</li></ul><p>macrotasks:</p><ul><li>setTimeout</li><li>setInterval</li><li>setImmediate</li><li>I/O</li></ul><p>这两个的详细区别下一篇再写，先看一段代码</p><pre><code>console.log(&apos;start&apos;)const interval = setInterval(() =&gt; {    console.log(&apos;setInterval&apos;)}, 0)setTimeout(() =&gt; {    console.log(&apos;setTimeout 1&apos;)  Promise.resolve()      .then(() =&gt; {        console.log(&apos;promise 3&apos;)      })      .then(() =&gt; {        console.log(&apos;promise 4&apos;)      })      .then(() =&gt; {        setTimeout(() =&gt; {          console.log(&apos;setTimeout 2&apos;)          Promise.resolve()              .then(() =&gt; {                console.log(&apos;promise 5&apos;)              })              .then(() =&gt; {                console.log(&apos;promise 6&apos;)              })              .then(() =&gt; {                clearInterval(interval)              })        }, 0)      })}, 0)Promise.resolve()    .then(() =&gt; {          console.log(&apos;promise 1&apos;)    })    .then(() =&gt; {        console.log(&apos;promise 2&apos;)    })</code></pre><p>理解了node的事件循环还是比较容易得出答案的：</p><pre><code>startpromise 1promise 2setIntervalsetTimeout 1promise 3promise 4setIntervalsetTimeout 2promise 5promise 6</code></pre><p>根据 <a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">WHATVG</a> 的说明，在一个事件循环的周期(cycle)中一个 (macro)task 应该从 macrotask 队列开始执行。当这个 macrotask 结束后，所有的 microtasks 将在同一个 cycle 中执行。在 microtasks 执行时还可以加入更多的 microtask，然后一个一个的执行，直到 microtask 队列清空。</p><p>规范理解起来有点晦涩，来看下上面的例子</p><h2 id="Cycle-1"><a href="#Cycle-1" class="headerlink" title="Cycle 1"></a>Cycle 1</h2><p>1)<code>setInterval</code> 被列为 task</p><p>2)<code>setTimeout 1</code> 被列为 task</p><p>3)<code>Promise.resolve 1</code> 中两个 <code>then</code> 被列为 microtask</p><p>4) stack 清空 microtasks 执行</p><p>任务队列： <code>setInterval`</code>setTimeout 1`</p><h2 id="Cycle-2"><a href="#Cycle-2" class="headerlink" title="Cycle 2"></a>Cycle 2</h2><p>5) microtasks 队列清空 <code>setInteval</code> 的回调可以执行。另一个 <code>setInterval</code> 被列为 task , 位于 <code>setTimeout 1</code>后面</p><p>任务队列： <code>setTimeout 1`</code>setInterval`</p><h2 id="Cycle-3"><a href="#Cycle-3" class="headerlink" title="Cycle 3"></a>Cycle 3</h2><p>6) microtask 队列清空，<code>setTimeout 1</code> 的回调可以执行，<code>promise 3</code> 和 <code>promise 4</code> 被列为 microtasks</p><p>7)<code>promise 3</code> 和 <code>promise 4</code> 执行。 <code>setTimeout 2</code> 被列为 task</p><p>任务队列 <code>setInterval`</code>setTimeout 2`</p><h2 id="Cycle-4"><a href="#Cycle-4" class="headerlink" title="Cycle 4"></a>Cycle 4</h2><p>8) microtask 队列清空 <code>setInteval</code> 的回调可以执行。然后另一个 <code>setInterval</code> 被列为 task ，位于 <code>setTimeout 2</code> 后面</p><p>任务队列： <code>setTimeout 2`</code>setInterval`</p><p>9)<code>setTimeout 2</code> 的回调执行， <code>promise 5</code> 和 <code>promise 6</code> 被列为 microtasks</p><p>现在 <code>promise 5</code> 和 <code>promise 6</code> 的回调应该执行，并且 clear 掉 <code>interval</code>。 但有的时候不知道为什么 <code>setInterval</code> 还会在执行一遍，变成下面结果</p><pre><code>...setTimeout 2setIntervalpromise 5promise 6</code></pre><p>但是把上面的代码放入 chrome console 中执行却没有问题。这一点还要再根据不同的 node版本 查一下。</p><h2 id="关于-macrotask-和-microtask"><a href="#关于-macrotask-和-microtask" class="headerlink" title="关于 macrotask 和 microtask"></a>关于 macrotask 和 microtask</h2><p>用例子简单理解了下 macrotask 和 microtask</p><p>这里再详细的总结下两者的区别和使用</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个事件循环(EventLoop)中会有一个正在执行的任务(Task)，而这个任务就是从 macrotask 队列中来的。在<a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">whatwg规范</a>中有 queue 就是任务队列。当这个 macrotask 执行结束后所有可用的 microtask 将会在同一个事件循环中执行，当这些 microtask 执行结束后还能继续添加 microtask 一直到真个 microtask 队列执行结束。</p><h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p>基本来说，当我们想以同步的方式来处理异步任务时候就用 microtask（比如我们需要直接在某段代码后就去执行某个任务，就像Promise一样）。</p><p>其他情况就直接用 macrotask。</p><h2 id="两者的具体实现"><a href="#两者的具体实现" class="headerlink" title="两者的具体实现"></a>两者的具体实现</h2><ul><li>macrotasks: setTimeout setInterval setImmediate I/O UI渲染</li><li>microtasks: Promise process.nextTick Object.observe MutationObserver</li></ul><h2 id="从规范中理解"><a href="#从规范中理解" class="headerlink" title="从规范中理解"></a>从规范中理解</h2><p>whatwg规范：<a href="https://link.zhihu.com/?target=https%3A//html.spec.whatwg.org/multipage/webappapis.html%23task-queue" target="_blank" rel="noopener">https://html.spec.whatwg.org/multipage/webappapis.html#task-queue</a></p><ul><li>一个事件循环(event loop)会有一个或多个任务队列(task queue) task queue 就是 macrotask queue</li><li>每一个 event loop 都有一个 microtask queue</li><li>task queue == macrotask queue != microtask queue</li><li>一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中</li><li>当一个 task 被放入队列 queue(macro或micro) 那这个 task 就可以被立即执行了</li></ul><p>再来回顾下事件循环如何执行一个任务的流程</p><p>当执行栈(call stack)为空的时候，开始依次执行：</p><ol><li>把最早的任务(task A)放入任务队列</li><li>如果 task A 为null (那任务队列就是空)，直接跳到第6步</li><li>将 currently running task 设置为 task A</li><li>执行 task A (也就是执行回调函数)</li><li>将 currently running task 设置为 null 并移出 task A</li><li>执行 microtask 队列</li></ol><ul><li>a: 在 microtask 中选出最早的任务 task X</li><li>b: 如果 task X 为null (那 microtask 队列就是空)，直接跳到 g</li><li>c: 将 currently running task 设置为 task X</li><li>d: 执行 task X</li><li>e: 将 currently running task 设置为 null 并移出 task X</li><li>f: 在 microtask 中选出最早的任务 , 跳到 b</li><li>g: 结束 microtask 队列</li></ul><ol><li>跳到第一步</li></ol><p>上面就算是一个简单的 event-loop 执行模型</p><p>再简单点可以总结为：</p><ol><li>在 macrotask 队列中执行最早的那个 task ，然后移出</li><li>执行 microtask 队列中所有可用的任务，然后移出</li><li>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>当一个task(在 macrotask 队列中)正处于执行状态，也可能会有新的事件被注册，那就会有新的 task 被创建。比如下面两个</li></ul><ol><li>promiseA.then() 的回调就是一个 task</li></ol><ul><li>promiseA 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li><li>promiseA 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li><li><p>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</p></li><li><p>microtask queue 中的 task 会在事件循环的当前回合中执行，因此 macrotask queue 中的 task 就只能等到事件循环的下一个回合中执行了</p></li><li>click ajax setTimeout 的回调是都是 task, 同时，包裹在一个 script 标签中的js代码也是一个 task 确切说是 macrotask。</li></ul><p>两者的具体实现</p><ul><li>macrotasks: setTimeout ，setInterval， setImmediate， I/O ，UI渲染，requestAnimationFrame</li><li>microtasks: Promise， process.nextTick， Object.observe， MutationObserver</li></ul><p>再简单点可以总结为：<br><img src="https://pic1.zhimg.com/v2-e92a4f5f686d115832b63b9b9e3ac2cd_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-e92a4f5f686d115832b63b9b9e3ac2cd_hd.jpg" alt=""></p><ol><li>在 macrotask 队列中执行最早的那个 task ，然后移出</li><li>再执行 microtask 队列中所有可用的任务，然后移出</li><li>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</li></ol><p>这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。<br>优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。<br>如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。</p><p>为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到：</p><blockquote><p>JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。<br>setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、 MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。<br>要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。<br>实在不行，只能用 setTimeout 创建 task 了。<br>为啥要用 microtask？<br>根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。<br>反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</p></blockquote><p>首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调，</p><p>MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。</p><p>setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行：</p><pre><code>setTimeout(function(){    console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;);},0);</code></pre><p>它会将回调函数加入task中，等到执行。<br><img src="https://pic2.zhimg.com/v2-59cf9f88d7daac690d39edfb9fffc8b8_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-59cf9f88d7daac690d39edfb9fffc8b8_hd.jpg" alt=""></p><pre><code>setTimeout(function(){console.log(4)},0);new Promise(function(resolve){    console.log(1)    for( var i=0 ; i&lt;10000 ; i++ ){        i==9999 &amp;&amp; resolve()    }    console.log(2)}).then(function(){    console.log(5)});console.log(3);结果是：1,2,3,5,4</code></pre><p>再看这个，两个自执行同时执行：</p><pre><code>&lt;script&gt;(function test() {  setTimeout(function () {    console.log(4)  }, 0);  new Promise(function executor (resolve) {    console.log(1);    for(var i = 0; i &lt; 10000; i++) {      i == 9999 &amp;&amp; resolve();    }    console.log(2);  }).then(function() {    console.log(5);  });  console.log(3);})()(function test2() {  setTimeout(function () {    console.log(42)  }, 0);  new Promise(function executor (resolve) {    console.log(12);    for(var i = 0; i &lt; 10000; i++) {      i == 9999 &amp;&amp; resolve();    }    console.log(22);  }).then(function() {    console.log(52);  });  console.log(32);})()&lt;/script&gt;</code></pre><p><img src="https://pic2.zhimg.com/v2-cd18c572eb05069895ede7e34388bb8d_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-cd18c572eb05069895ede7e34388bb8d_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-afcb6fa6fb862818359f757107b769ab_b.jpg" alt=""><br>整个执行过程是一个 main thread 【<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/link%3Furl%3DCV-egCVH8yK1w-ilUqGsztryG8s2mbuhAliIC_L1n_-BSZ_KJ16tAfaNkmbcRtU8" target="_blank" rel="noopener">主线程</a>】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的<code>setTimeout</code>进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。</p><p>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：</p><p>1.先执行 macrotasks：I/O -》 UI渲染</p><p>2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe</p><p>3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：</p><p>setTimeout ，setInterval –》setImmediate</p><p>综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</p><pre><code>setImmediate(function(){    console.log(1);},0);setTimeout(function(){    console.log(2);},0);new Promise(function(resolve){    console.log(3);    resolve();    console.log(4);}).then(function(){    console.log(5);});console.log(6);process.nextTick(function(){    console.log(7);});console.log(8);结果是：3 4 6 8 7 5 2 1 </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解ES6 Async Functions (异步函数)</title>
      <link href="/2018/05/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%20%20Async%20Functions/"/>
      <url>/2018/05/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%20%20Async%20Functions/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="async-异步-函数变体"><a href="#async-异步-函数变体" class="headerlink" title="async(异步) 函数变体"></a>async(异步) 函数变体</h2><p>以下是已经存在的异步函数变体。请注意无处不在的 <code>async</code> 关键字。</p><ul><li>异步函数声明： <code>async function foo() {}</code></li><li>异步函数表达式： <code>const foo = async function () {};</code></li><li>异步函数定义：<code>let obj = { async foo() {} }</code></li><li>异步箭头函数： <code>const foo = async () =&gt; {};</code></li></ul><h2 id="async-异步-函数总是返回-Promises"><a href="#async-异步-函数总是返回-Promises" class="headerlink" title="async(异步) 函数总是返回 Promises"></a>async(异步) 函数总是返回 Promises</h2><p>async(异步) 函数的 Promise 完成状态：</p><pre><code>async function asyncFunc() {return 123;}asyncFunc().then(x =&gt; console.log(x));// 123</code></pre><p>async(异步) 函数的 Promise 拒绝状态：</p><pre><code>async function asyncFunc() {throw new Error(&apos;Problem!&apos;);}asyncFunc().catch(err =&gt; console.log(err));// Error: Problem!</code></pre><h2 id="通过-await-处理-async-异步-计算的结果和错误"><a href="#通过-await-处理-async-异步-计算的结果和错误" class="headerlink" title="通过 await 处理 async(异步) 计算的结果和错误"></a>通过 <code>await</code> 处理 async(异步) 计算的结果和错误</h2><p><code>await</code>（只允许在 async(异步) 函数内部使用）等待其操作对象 Promise 返回：</p><ul><li>如果 Promise 是完成状态，<code>await</code> 的结果是完成态的值。</li><li>如果 Promise 是拒绝状态，<code>await</code> 会抛出拒绝值。</li></ul><p>处理单个 async(异步) 返回值：</p><pre><code>async function asyncFunc() {const result = await otherAsyncFunc();   console.log(result);}// 等价于:function asyncFunc() {return otherAsyncFunc().then(result =&gt; {       console.log(result);});}</code></pre><p>按顺序处理多个 async(异步) 返回值：</p><pre><code>async function asyncFunc() {const result1 = await otherAsyncFunc1();   console.log(result1);const result2 = await otherAsyncFunc2();   console.log(result2);}// 等价于:function asyncFunc() {return otherAsyncFunc1().then(result1 =&gt; {       console.log(result1);return otherAsyncFunc2();}).then(result2 =&gt; {       console.log(result2);});}</code></pre><p>并行处理多个 async(异步) 返回值：</p><pre><code>async function asyncFunc() {const [result1, result2] = await Promise.all([       otherAsyncFunc1(),       otherAsyncFunc2(),]);   console.log(result1, result2);}// 等价于:function asyncFunc() {return Promise.all([       otherAsyncFunc1(),       otherAsyncFunc2(),]).then([result1, result2] =&gt; {       console.log(result1, result2);});}</code></pre><p>错误处理：</p><pre><code>async function asyncFunc() {try {await otherAsyncFunc();} catch (err) {       console.error(err);}}// 等价于:function asyncFunc() {return otherAsyncFunc().catch(err =&gt; {       console.error(err);});}</code></pre><h2 id="理解-async-异步-函数"><a href="#理解-async-异步-函数" class="headerlink" title="理解 async(异步) 函数"></a>理解 async(异步) 函数</h2><p>在我解释 async(异步) 函数之前，我需要解释一下如何组合使用 Promises 和 Generator ，通过看起来同步的代码来执行 async(异步) 操作。</p><p>对于能够 async(异步) 计算其一次性结果的函数，作为 ES6 一部分的 Promises 已经变得流行起来。一个例子是 <a href="https://link.zhihu.com/?target=https%3A//fetch.spec.whatwg.org/%23concept-request" target="_blank" rel="noopener">客户端 fetch API</a> ，它是 XMLHttpRequest 获取数据的替代方法。使用示例如下：</p><pre><code>function fetchJson(url) {return fetch(url).then(request =&gt; request.text()).then(text =&gt; {return JSON.parse(text);}).catch(error =&gt; {       console.log(`ERROR: ${error.stack}`);});}fetchJson(&apos;http://example.com/some_file.json&apos;).then(obj =&gt; console.log(obj));</code></pre><h2 id="通过-generator-来编写异步代码"><a href="#通过-generator-来编写异步代码" class="headerlink" title="通过 generator 来编写异步代码"></a>通过 generator 来编写异步代码</h2><p>co 是一个使用 Promise 和 generator 来实现看似同步编码的库，但与上一示例中使用的样式相同：</p><pre><code>const fetchJson = co.wrap(function* (url) {try {let request = yield fetch(url);let text = yield request.text();return JSON.parse(text);}catch (error) {       console.log(`ERROR: ${error.stack}`);}});</code></pre><p>每次回调函数（ generator 函数）产生一个 Promise 对象给 co ，回调会被暂停，只有当 Promise 执行完成后，co 才会继续执行回调 。 如果 Promise 处于完成状态，<code>yield</code> 返回完成状态的值，如果处于拒绝状态，<code>yield</code> 抛出拒绝状态的错误。此外，co 保证结果是通过回调执行完成才返回的（类似于 <code>then()</code> 所做的工作）。</p><h2 id="通过-async-异步-函数来编写异步代码"><a href="#通过-async-异步-函数来编写异步代码" class="headerlink" title="通过 async(异步) 函数来编写异步代码"></a>通过 async(异步) 函数来编写异步代码</h2><p>async(异步) 函数用的特定语法基本上和 co 类似：</p><pre><code>async function fetchJson(url) {try {let request = await fetch(url);let text = await request.text();return JSON.parse(text);}catch (error) {       console.log(`ERROR: ${error.stack}`);}}</code></pre><p>在内部，异步函数写法更类似于 generators 。</p><h2 id="以同步开始，异步处理的-async-异步-函数"><a href="#以同步开始，异步处理的-async-异步-函数" class="headerlink" title="以同步开始，异步处理的 async(异步) 函数"></a>以同步开始，异步处理的 async(异步) 函数</h2><p>以下是 async(异步)函数是如何工作的：</p><ol><li>async(异步) 函数总是返回一个 Promise 对象 <code>p</code> 。Promise 对象在 async(异步) 函数开始执行时被创建。</li><li>函数体执行过程中，可以通过 <code>return</code> 或 <code>throw</code> 终止执行。或者通过 <code>await</code> 暂停执行，在这种情况下，通常会在以后继续执行。</li><li>返回 Promise 对象 <code>p</code>。</li></ol><p>当执行 async(异步) 函数的函数体时，<code>return x</code> 中的 <code>x</code> 是 Promise 对象 <code>p</code> 的完成状态的结果，而 <code>throw err</code> 是 <code>p</code> 的拒绝状态的结果。执行结果是异步返回的。换句话说：<code>then()</code> 和 <code>catch()</code> 的回调总是在当前代码完成后执行。</p><p>以下是代码示例：</p><pre><code>async function asyncFunc() {   console.log(&apos;asyncFunc()&apos;); // (A)return &apos;abc&apos;;}asyncFunc().then(x =&gt; console.log(`Resolved: ${x}`)); // (B)console.log(&apos;main&apos;); // (C)// Output:// asyncFunc()// main// Resolved: abc</code></pre><p>您可以认为是以下的执行顺序：</p><ol><li>行A：async(异步) 函数以同步开始。async(异步) 函数的 Promise 通过 <code>return</code> 来返回完成状态的结果。</li><li>行C：执行继续。</li><li>行B：Promise 完成状态通知是异步发生的。</li></ol><h2 id="返回不被包裹的-Promise-对象"><a href="#返回不被包裹的-Promise-对象" class="headerlink" title="返回不被包裹的 Promise 对象"></a>返回不被包裹的 Promise 对象</h2><p>Promise 的 resolve 是一项标准操作。 <code>return</code> 就是使用它来 resolve async(异步) 函数的 Promise <code>p</code> 的。这意味着：</p><ol><li>返回一个非 Promise 值，该值将被处理成 <code>p</code> 的完成状态值。</li><li>返回一个 Promise 对象，那么 <code>p</code> 此时相当于是该 Promise 的状态。</li></ol><p>因此，您可以返回一个 Promise ，并且这个 Promise 不会包裹在别的 Promise 中：</p><pre><code>async function asyncFunc() {return Promise.resolve(123);}asyncFunc().then(x =&gt; console.log(x)) // 123</code></pre><p>有趣的是，返回一个拒绝状态（reject）的 Promise 对象会导致 async(异步) 函数被拒绝（reject）（通常，您可以使用 <code>throw</code> ）：</p><pre><code>async function asyncFunc() {return Promise.reject(new Error(&apos;Problem!&apos;));}asyncFunc().catch(err =&gt; console.error(err)); // Error: Problem!</code></pre><p>这与 Promise 解决方案的工作方式是一致的。 使你能够在不使用 <code>await</code> 的情况下，使用其他 async(异步) 计算来执行完成和拒绝处理：</p><pre><code>async function asyncFunc() {return anotherAsyncFunc();}</code></pre><p>上面的代码示例和下面的类似，但是比下面的更高效。（以下代码示例没有包裹 <code>anotherAsyncFunc()</code> 的 Promise ，而是包裹 <code>anotherAsyncFunc()</code> 本身 ）：</p><pre><code>async function asyncFunc() {return await anotherAsyncFunc();}</code></pre><h2 id="使用-await-小贴士"><a href="#使用-await-小贴士" class="headerlink" title="使用 await 小贴士"></a>使用 <code>await</code> 小贴士</h2><h2 id="不要忘记使用-await"><a href="#不要忘记使用-await" class="headerlink" title="不要忘记使用 await"></a>不要忘记使用 <code>await</code></h2><p>在 async(异步) 函数中容易犯的一个错误就是在调用 async(异步) 函数时忘记使用 <code>await</code> ：</p><pre><code>async function asyncFunc() {const value = otherAsyncFunc(); // missing `await`!···}</code></pre><p>在这个例子中，方法执行返回的 Promise 对象赋值给了 <code>value</code> ，它通常不是你在 async(异步) 函数中想要的结果。</p><p>await 甚至可以在 async(异步) 函数不返回任何值的情况下起作用。它的 Promise 只是用来告诉调用者完成状态。例如：</p><pre><code>async function foo() {await step1(); // (A)···}</code></pre><p>行A中的 <code>await</code> 确保在执行 <code>foo()</code> 剩余部分之前， <code>step1()</code> 已经执行完成。</p><h2 id="不需要使用-await-的情况"><a href="#不需要使用-await-的情况" class="headerlink" title="不需要使用 await 的情况"></a>不需要使用 await 的情况</h2><p>有时，你只想触发异步计算，并且不需要关注它什么时候完成。以下是代码示例：</p><pre><code>async function asyncFunc() {const writer = openFile(&apos;someFile.txt&apos;);   writer.write(&apos;hello&apos;); // don’t wait   writer.write(&apos;world&apos;); // don’t waitawait writer.close(); // wait for file to close}</code></pre><p>在这里，我们不关心单个的写入操作是否完成，只需要他们以正确的顺序执行 (API必须保证，但这是由 async(异步) 函数的执行模型所鼓励的，正如我们所见)。</p><p><code>asyncFunc()</code> 函数最后一行的 <code>await</code> 确保该函数仅在文件写入关闭后才会执行。</p><p>由于返回的 Promises 没有被其他 async(异步) 函数包裹，所以你可以用 <code>return</code> 替换 <code>await writer.close()</code> ：</p><pre><code>async function asyncFunc() {const writer = openFile(&apos;someFile.txt&apos;);   writer.write(&apos;hello&apos;);   writer.write(&apos;world&apos;);return writer.close();}</code></pre><p>这两个版本各有利弊，<code>await</code> 版本可能稍微更容易理解。</p><h2 id="await-是顺序执行的，Promise-all-是并行的"><a href="#await-是顺序执行的，Promise-all-是并行的" class="headerlink" title="await 是顺序执行的，Promise.all() 是并行的"></a>await 是顺序执行的，Promise.all() 是并行的</h2><p>下面的代码调用了两个 async(异步) 函数， <code>asyncFunc1()</code> 和 <code>asyncFunc1()</code> 。</p><pre><code>async function foo() {const result1 = await asyncFunc1();const result2 = await asyncFunc2();}</code></pre><p>这两个函数调用顺序执行。但是并行执行它们往往会加快速度。您可以使用 Promise.all() ：</p><pre><code>async function foo() {const [result1, result2] = await Promise.all([       asyncFunc1(),       asyncFunc2(),]);}</code></pre><p>我们现在正在等待一个包含两个元素的数组的 Promise ，而不是等待两个 Promise。</p><h2 id="异步函数和回调"><a href="#异步函数和回调" class="headerlink" title="异步函数和回调"></a>异步函数和回调</h2><p>async(异步) 函数的一个限制是 <code>await</code>(等待) 只影响直接相关的 async(异步) 函数。因此，async(异步) 函数无法在回调（但是，回调可以是 async(异步) 函数本身，稍后我们将会看到）中使用 <code>await</code>(等待)。这使得基于回调的实用函数和方法难以使用。例子中我们将使用数组方法 <code>map()</code> 和 <code>forEach()</code>。</p><h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><p>我们从数组方法 <code>map()</code> 开始讲解。在下面的代码示例中，我们想要加载由 URLs 数组指向的文件，并将它们返回到数组中。</p><pre><code>async function downloadContent(urls) {return urls.map(url =&gt; {// 错误的语法!const content = await httpGet(url);return content;});}</code></pre><p>这不起作用，因为在正常箭头函数中 <code>await</code> 语法上是非法的(愚人码头注： <code>await</code>(等待) 只影响直接相关的 async(异步) 函数)。那么如何使用异步的箭头函数呢？</p><pre><code>async function downloadContent(urls) {return urls.map(async (url) =&gt; { // 注意这一行中的 async ;const content = await httpGet(url);return content;});}</code></pre><p>这段代码有两个问题：</p><ul><li>现在返回的结果是一个 Promises 对象的数组，而不是一个字符串的数组。</li><li>一旦 <code>map()</code> 执行完成，回调执行的工作并不能同时完成，因为 <code>await</code> 只暂停了包裹它的箭头函数 和 <code>httpGet()</code> 异步执行达到完成状态。这意味着你不能使用 <code>await</code>，来等待 <code>downloadContent()</code> 执行结束。</li></ul><p>我们可以通过 <code>Promise.all()</code> 来解决这两个问题，<code>Promise.all()</code> 可以将一系列的 Promise 转换为一个 Promise 数组（所有值都是经过 Promise 完成并返回）：</p><pre><code>async function downloadContent(urls) {const promiseArray = urls.map(async (url) =&gt; {const content = await httpGet(url);return content;});return await Promise.all(promiseArray);}</code></pre><p><code>map()</code> 的回调并不对 <code>httpGet()</code> 的结果起作用，只是起到不断执行的作用。因此，这里我们不需要一个异步的箭头函数，只需要一个普通的箭头函数就能达到相同的结果。</p><pre><code>async function downloadContent(urls) {const promiseArray = urls.map(       url =&gt; httpGet(url));return await Promise.all(promiseArray);}</code></pre><p>我们仍然可以做一个小的改进：这个异步函数稍微有点低效 – 首先通过 <code>await</code> 来解开 <code>Promise.all()</code> 的结果，然后通过 <code>return</code> 再次包裹它。 假设 <code>return</code> 不包裹 Promises，我们可以直接返回 <code>Promise.all()</code> 的结果：</p><pre><code>async function downloadContent(urls) {const promiseArray = urls.map(       url =&gt; httpGet(url));return Promise.all(promiseArray);}</code></pre><h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h2><p>我们使用数组的 forEach() 方法在控制台中打印几个通过 URLs 加载的文件的内容：</p><pre><code>async function logContent(urls) {   urls.forEach(url =&gt; {// Wrong syntaxconst content = await httpGet(url);       console.log(content);});}</code></pre><p>同样的，这里的代码会产生一个语法错误，因为你不能在通常的箭头函数内部使用 <code>await</code> 。</p><p>我们换作异步箭头函数：</p><pre><code>async function logContent(urls) {   urls.forEach(async url =&gt; {const content = await httpGet(url);       console.log(content);});// Not finished here}</code></pre><p>这段代码起作用了，但是会出现一个警告：<code>httpGet()</code> 返回的 Promise 对象是异步完成的，这也意味着当 <code>forEach()</code> 返回的时候回调可能还没有结束，因此你无法等到 <code>logContent()</code> 只能结束。</p><p>如果你并不想要这个结果，你可以将 <code>forEach()</code> 转换为 <code>for-of</code> 循环。</p><pre><code>async function logContent(urls) {for (const url of urls) {const content = await httpGet(url);       console.log(content);}}</code></pre><p>现在一切都在 <code>for-of</code> 循环完成后完成。但是，处理步骤依次发生：<code>httpGet()</code> 只是在第一次调用完成后再次调用。如果您希望处理步骤并行执行，你必须使用 <code>Promise.all()</code>：</p><pre><code>async function logContent(urls) {await Promise.all(urls.map(async url =&gt; {const content = await httpGet(url);           console.log(content);}));}</code></pre><p><code>map()</code> 用于创建一个 Promises 数组。 我们对他们的完成结果并不感兴趣，我们只要 <code>await</code>(等待) 所有方法执行完成。这意味着我们希望的是在 async(异步) 函数完成之后所有的执行都已经完成。我们也可以返回 <code>Promise.all()</code> ，但是该函数的结果是一个数组，其元素都是未完成状态的。</p><h2 id="使用异步函数小贴士"><a href="#使用异步函数小贴士" class="headerlink" title="使用异步函数小贴士"></a>使用异步函数小贴士</h2><h2 id="了解你的-Promises"><a href="#了解你的-Promises" class="headerlink" title="了解你的 Promises"></a>了解你的 Promises</h2><p>async(异步) 函数的基础就是 <a href="https://link.zhihu.com/?target=http%3A//exploringjs.com/es6/ch_promises.html" target="_blank" rel="noopener">Promises</a> 对象，这就是为什么理解 Promises 对于理解 async(异步) 函数至关重要。特别是当遇到不是基于 Promises 的老代码来实现 async(异步) 函数时，你通常别无选择，只能用 Promise 来重构。</p><p>举个例子，这里有个 “promisified” 版本的 <code>XMLHttpRequest</code> ：</p><pre><code>function httpGet(url, responseType=&quot;&quot;) {return new Promise(function (resolve, reject) {const request = new XMLHttpRequest();           request.onload = function () {if (this.status === 200) {// Success                   resolve(this.response);} else {// Something went wrong (404 etc.)                   reject(new Error(this.statusText));}};           request.onerror = function () {               reject(new Error(&apos;XMLHttpRequest Error: &apos;+this.statusText));};           request.open(&apos;GET&apos;, url);           xhr.responseType = responseType;           request.send();});}</code></pre><p>XMLHttpRequest 的 API 是基于回调的。通过一个 async(异步) 函数来实现它，意味着你必须在回调中返回 Promise 的完成(fulfill) 或拒绝(reject) 状态。这是不可能的，因为你只能通过 <code>return</code> 或者 <code>throw</code> 来完成这样的操作。你不能从回调函数内部 <code>return</code> 一个函数的结果。<code>throw</code>也有类似的约束。</p><p>因此，异步函数的通用编码风格是：</p><ul><li>直接使用 Promise 对象来构建异步原语。</li><li>用异步函数来使用这些原语。</li></ul><p>扩展阅读：“Exploring ES6” 中的 “<a href="https://link.zhihu.com/?target=http%3A//exploringjs.com/es6/ch_promises.html" target="_blank" rel="noopener">异步编程中的 Promises 对象</a>” 章节</p><h2 id="立即调用异步函数表达式"><a href="#立即调用异步函数表达式" class="headerlink" title="立即调用异步函数表达式"></a>立即调用异步函数表达式</h2><p>有时，如果你可以在模块或脚本的顶层使用 await ，那将是一种很好的选择。当然，它只能在异步函数中使用。您可以创建一个异步函数 <code>main()</code> 并立即调用它：</p><pre><code>async function main() {   console.log(await asyncFunction());}main();</code></pre><p>或者您可以使用立即调用异步函数表达式：</p><pre><code>(async function () {   console.log(await asyncFunction());})();</code></pre><p>另一个选择是立即调用异步箭头函数：</p><pre><code>(async () =&gt; {   console.log(await asyncFunction());})();</code></pre><h2 id="用异步函数进行单元测试"><a href="#用异步函数进行单元测试" class="headerlink" title="用异步函数进行单元测试"></a>用异步函数进行单元测试</h2><p>以下代码使用 <a href="https://link.zhihu.com/?target=https%3A//mochajs.org/" target="_blank" rel="noopener">测试框架 mocha</a> 对异步函数 asyncFun1() 和 asyncFun2() 来进行单元测试：</p><pre><code>import assert from &apos;assert&apos;;// Bug: the following test always succeedstest(&apos;Testing async code&apos;, function () {   asyncFunc1() // (A).then(result1 =&gt; {assert.strictEqual(result1, &apos;a&apos;); // (B)return asyncFunc2();}).then(result2 =&gt; {assert.strictEqual(result2, &apos;b&apos;); // (C)});});</code></pre><p>然而，这个测试总是成功的，因为 mocha 不会等待 B 行和 C 行断言执行完成。</p><p>你可以通过返回链式调用的 Promise 来解决这个问题，因为 mocha 会识别一个测试是否返回一个 Promise ，然后等待该 Promise 完成 再进行下一步（除非超时）。</p><pre><code>return asyncFunc1() // (A)</code></pre><p>异步函数总是返回 Promises ，这使得它们能方便的、完美的来进行这种单元测试：</p><pre><code>import assert from &apos;assert&apos;;test(&apos;Testing async code&apos;, async function () {const result1 = await asyncFunc1();assert.strictEqual(result1, &apos;a&apos;);const result2 = await asyncFunc2();assert.strictEqual(result2, &apos;b&apos;);});</code></pre><p>在 mocha 中使用异步单元测试异步函数有两个优点：代码更简洁，能够准确处理返回的 Promise 对象。</p><h2 id="不要担心没有处理的拒绝拒态"><a href="#不要担心没有处理的拒绝拒态" class="headerlink" title="不要担心没有处理的拒绝拒态"></a>不要担心没有处理的拒绝拒态</h2><p>当前的 JavaScript 引擎可以在拒绝态未处理的情况下提出警告。以下代码在过去会经常执行失败，但是当前的 JavaScript 引擎可以进行警告：</p><pre><code>JavaScript 代码:async function foo() {throw new Error(&apos;Problem!&apos;);}foo();</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
            <tag> 异步 </tag>
            
            <tag> Async </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TypeScript入门</title>
      <link href="/2018/05/08/TypeScript%E5%85%A5%E9%97%A8/"/>
      <url>/2018/05/08/TypeScript%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>目前angular、deno已经开始使用typescript，并且我们熟知的vue，在3.0也即将会使用typescript，可以说，前端领域，typescript会逐渐变为必备的技能，那么，为什么typescript变得越来越火呢？</p><p>网上有各种typescript和javascript的对比，那么在我的角度的理解，javascript是解释型（动态）语言，可以说是从上到下执行，在我们开发过程中，比如有语法错误等等，需要执行到这一行代码才能知道，而typescript则像写易语言那样生成exe时，需要静态编译，而静态编译这个过程，会把代码都检查一遍，看是否通过检测，最终才生成exe，typescript最终是也是编译成javascript原生代码的，只是在这个生成过程中，会进行各种检测，来检查代码是否符合语法啊规则啊，符合的话最终再编译成javascript，规范了我们代码的编写，同时也提高了代码的复用以及组件化，在runtime阶段为我们提前找到错误。<br><img src="/2018/05/08/TypeScript入门/1.webp" alt=""><br>typescript支持es5/es6的语法，并且扩展了javascript语法，更像java、c#、swift这种语言了。</p><p>在前端nodejs很火，但是为什么在后端却不火，很大程度也是因为nodejs也是解释型（动态）语言，优势就是解释型语言比较灵活，但是缺点也很明显，用node开发后台程序，开发一直爽，重构火葬场.一旦重构了，就会出现很多问题，像Java、c#这类语言，非常严谨，类型检查等非常严谨，而javascript呢，一般是靠我们用肉眼去排查，很麻烦，typescript就是解决这一类问题的。</p><p>总而言之，typescript是未来的趋势，也是谷歌推荐的框架，我也是刚学typescript，很多都是站在前辈的肩膀总结的，废话不多说，我们开始进入正题吧！</p><hr><h2 id="TypeScript-安装"><a href="#TypeScript-安装" class="headerlink" title="TypeScript 安装"></a>TypeScript 安装</h2><p>首先我们全局安装</p><p><code>npm i typescript -g</code></p><p>全局安装完成后，我们新建一个<code>hello.ts</code>的ts文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;TypeScript&quot;</span><br></pre></td></tr></table></figure></p><p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个ts文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;TypeScript&quot;</span><br></pre></td></tr></table></figure></p><p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，我平时使用vscode来开发，需要配置一下vscode就可以。</p><p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    /* Basic Options */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                          /* Specify ECMAScript target version: &apos;ES3&apos; (default), &apos;ES5&apos;, &apos;ES2015&apos;, &apos;ES2016&apos;, &apos;ES2017&apos;,&apos;ES2018&apos; or &apos;ESNEXT&apos;. */</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                     /* Specify module code generation: &apos;none&apos;, &apos;commonjs&apos;, &apos;amd&apos;, &apos;system&apos;, &apos;umd&apos;, &apos;es2015&apos;, or &apos;ESNext&apos;. */</span><br><span class="line">    // &quot;lib&quot;: [],                             /* Specify library files to be included in the compilation. */</span><br><span class="line">    // &quot;allowJs&quot;: true,                       /* Allow javascript files to be compiled. */</span><br><span class="line">    // &quot;checkJs&quot;: true,                       /* Report errors in .js files. */</span><br><span class="line">    // &quot;jsx&quot;: &quot;preserve&quot;,                     /* Specify JSX code generation: &apos;preserve&apos;, &apos;react-native&apos;, or &apos;react&apos;. */</span><br><span class="line">    // &quot;declaration&quot;: true,                   /* Generates corresponding &apos;.d.ts&apos; file. */</span><br><span class="line">    // &quot;declarationMap&quot;: true,                /* Generates a sourcemap for each corresponding &apos;.d.ts&apos; file. */</span><br><span class="line">    // &quot;sourceMap&quot;: true,                     /* Generates corresponding &apos;.map&apos; file. */</span><br><span class="line">    // &quot;outFile&quot;: &quot;./&quot;,                       /* Concatenate and emit output to single file. */</span><br><span class="line">     &quot;outDir&quot;: &quot;./dist&quot;,                        /* Redirect output structure to the directory. */</span><br><span class="line">    // &quot;rootDir&quot;: &quot;./&quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */</span><br><span class="line">    // &quot;composite&quot;: true,                     /* Enable project compilation */</span><br><span class="line">    // &quot;removeComments&quot;: true,                /* Do not emit comments to output. */</span><br><span class="line">    // &quot;noEmit&quot;: true,                        /* Do not emit outputs. */</span><br><span class="line">    // &quot;importHelpers&quot;: true,                 /* Import emit helpers from &apos;tslib&apos;. */</span><br><span class="line">    // &quot;downlevelIteration&quot;: true,            /* Provide full support for iterables in &apos;for-of&apos;, spread, and destructuring when targeting &apos;ES5&apos; or &apos;ES3&apos;. */</span><br><span class="line">    // &quot;isolatedModules&quot;: true,               /* Transpile each file as a separate module (similar to &apos;ts.transpileModule&apos;). */</span><br><span class="line"></span><br><span class="line">    /* Strict Type-Checking Options */</span><br><span class="line">    &quot;strict&quot;: true,                           /* Enable all strict type-checking options. */</span><br><span class="line">    // &quot;noImplicitAny&quot;: true,                 /* Raise error on expressions and declarations with an implied &apos;any&apos; type. */</span><br><span class="line">    // &quot;strictNullChecks&quot;: true,              /* Enable strict null checks. */</span><br><span class="line">    // &quot;strictFunctionTypes&quot;: true,           /* Enable strict checking of function types. */</span><br><span class="line">    // &quot;strictBindCallApply&quot;: true,           /* Enable strict &apos;bind&apos;, &apos;call&apos;, and &apos;apply&apos; methods on functions. */</span><br><span class="line">    // &quot;strictPropertyInitialization&quot;: true,  /* Enable strict checking of property initialization in classes. */</span><br><span class="line">    // &quot;noImplicitThis&quot;: true,                /* Raise error on &apos;this&apos; expressions with an implied &apos;any&apos; type. */</span><br><span class="line">    // &quot;alwaysStrict&quot;: true,                  /* Parse in strict mode and emit &quot;use strict&quot; for each source file. */</span><br><span class="line"></span><br><span class="line">    /* Additional Checks */</span><br><span class="line">    // &quot;noUnusedLocals&quot;: true,                /* Report errors on unused locals. */</span><br><span class="line">    // &quot;noUnusedParameters&quot;: true,            /* Report errors on unused parameters. */</span><br><span class="line">    // &quot;noImplicitReturns&quot;: true,             /* Report error when not all code paths in function return a value. */</span><br><span class="line">    // &quot;noFallthroughCasesInSwitch&quot;: true,    /* Report errors for fallthrough cases in switch statement. */</span><br><span class="line"></span><br><span class="line">    /* Module Resolution Options */</span><br><span class="line">    // &quot;moduleResolution&quot;: &quot;node&quot;,            /* Specify module resolution strategy: &apos;node&apos; (Node.js) or &apos;classic&apos; (TypeScript pre-1.6). */</span><br><span class="line">    // &quot;baseUrl&quot;: &quot;./&quot;,                       /* Base directory to resolve non-absolute module names. */</span><br><span class="line">    // &quot;paths&quot;: &#123;&#125;,                           /* A series of entries which re-map imports to lookup locations relative to the &apos;baseUrl&apos;. */</span><br><span class="line">    // &quot;rootDirs&quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */</span><br><span class="line">    // &quot;typeRoots&quot;: [],                       /* List of folders to include type definitions from. */</span><br><span class="line">    // &quot;types&quot;: [],                           /* Type declaration files to be included in compilation. */</span><br><span class="line">    // &quot;allowSyntheticDefaultImports&quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */</span><br><span class="line">    &quot;esModuleInterop&quot;: true                   /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &apos;allowSyntheticDefaultImports&apos;. */</span><br><span class="line">    // &quot;preserveSymlinks&quot;: true,              /* Do not resolve the real path of symlinks. */</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    // &quot;sourceRoot&quot;: &quot;&quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */</span><br><span class="line">    // &quot;mapRoot&quot;: &quot;&quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */</span><br><span class="line">    // &quot;inlineSourceMap&quot;: true,               /* Emit a single file with source maps instead of having a separate file. */</span><br><span class="line">    // &quot;inlineSources&quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &apos;--inlineSourceMap&apos; or &apos;--sourceMap&apos; to be set. */</span><br><span class="line"></span><br><span class="line">    /* Experimental Options */</span><br><span class="line">    // &quot;experimentalDecorators&quot;: true,        /* Enables experimental support for ES7 decorators. */</span><br><span class="line">    // &quot;emitDecoratorMetadata&quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个json文件里有很多选项</p><ul><li><code>target</code>是选择编译到什么语法</li><li><code>module</code>则是模块类型</li><li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li></ul><p>接下来我们需要开启监控了，在vscode任务栏中<br><img src="/2018/05/08/TypeScript入门/2.webp" alt=""><br><img src="/2018/05/08/TypeScript入门/3.webp" alt=""><br><img src="/2018/05/08/TypeScript入门/4.webp" alt=""><br>此时就会开启监控了，会监听ts的变化，然后自动去编译。</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>java、c#是强类型语言，而js是弱类型语言，强弱类语言有什么区别呢？typescript最大的优点就是类型检查，可以帮你检查你定义的类型和赋值的类型。</p><h4 id="布尔类型boolean"><a href="#布尔类型boolean" class="headerlink" title="布尔类型boolean"></a>布尔类型boolean</h4><pre><code>// 在js中，定义isFlag为true，为布尔类型booleanlet isFlag = true;// 但是我们也可以重新给它赋值为字符串isFlag = &quot;hello swr&quot;;// 在ts中，定义isFlag为true，为布尔类型boolean// 在变量名后加冒号和类型，如  :booleanlet isFlag:boolean = true// 重新赋值到字符串类型会报错isFlag = &quot;hello swr&quot; // 在java中，一般是这样定义，要写变量名也要写类型名// int a = 10; // string name = &quot;TypeScript&quot;</code></pre><h4 id="数字类型number"><a href="#数字类型number" class="headerlink" title="数字类型number"></a>数字类型number</h4><pre><code>let age:number = 28;age = 29;</code></pre><h4 id="字符串类型string"><a href="#字符串类型string" class="headerlink" title="字符串类型string"></a>字符串类型string</h4><pre><code>let name:string = &quot;TypeScript&quot;name = &quot;iamswr&quot;</code></pre><p>以上<code>boolean、number、string</code>类型有个共性，就是可以通过<code>typeof</code>来获取到是什么类型，是基本数据类型。</p><p>那么复杂的数据类型是怎么处理的呢？</p><h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h4><pre><code>// 在js中let pets = [&quot;旺财&quot;,&quot;小黑&quot;];// 在ts中// 需要注意的是，这个是一个字符串类型的数组// 只能往里面写字符串，写别的类型会报错let pets:string[] = [&quot;旺财&quot;,&quot;小黑&quot;];// 另外一种ts写法let pets:Array&lt;string&gt; = [&quot;旺财&quot;,&quot;小黑&quot;];// 那么如果想在数组里放对象呢？let pets:Array&lt;object&gt; = [{name:&quot;旺财&quot;},{name:&quot;小黑&quot;}];// 那么怎样在一个数组中，随意放string、number、boolean类型呢？// 这里的 | 相当于 或 的意思let arr:Array&lt;string|number|boolean&gt; = [&quot;hello swr&quot;,28];// 想在数组中放任意类型let arr:Array&lt;any&gt; = [&quot;hello swr&quot;,28,true]</code></pre><h4 id="元组类型tuple"><a href="#元组类型tuple" class="headerlink" title="元组类型tuple"></a>元组类型tuple</h4><p>什么是元组类型？其实元组是数组的一种。</p><pre><code>let person:[string,number] = [&apos;TypeScript&apos;,28]</code></pre><p>有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上，多了少了或者类型不对都会报错。</p><p>元组类型是一个不可变的数组，长度、类型是不可变的。</p><h4 id="枚举类型enum"><a href="#枚举类型enum" class="headerlink" title="枚举类型enum"></a>枚举类型enum</h4><p>枚举在java中是从6.0才引入的一种类型，在java和ts中的关键字都是<code>enum</code>。</p><p>什么是枚举？枚举有点类似一一列举，一个一个数出来，在易语言中，我们会经常枚举窗口，来找到自己想要的，一般用于值是某几个固定的值，比如生肖（有12种）、星座（有12种）、性别（男女）等，这些值是固定的，可以一个一个数出来。</p><p>为什么我们要用枚举呢？我们可以定义一些值，定义完了后可以直接拿来用了，用的时候也不会赋错值。</p><p>比如我们普通赋值</p><pre><code>// 我们给性别赋值一个boy，但是我们有时候手误，可能输成boy1、boy2了// 这样就会导致我们赋值错误了let sex = &quot;boy&quot;</code></pre><p>既然这样容易导致手误赋错值，那么我们可以定义一个枚举</p><pre><code>// 定义一个枚举类型的值enum sex {  BOY,  GIRL}console.log(sex)console.log(`TypeScript是${sex.BOY}`)</code></pre><p>我们看看转为es5语法是怎样的</p><pre><code>// 转为es5语法&quot;use strict&quot;;var sex;(function (sex) {    sex[sex[&quot;BOY&quot;] = 0] = &quot;BOY&quot;;    sex[sex[&quot;GIRL&quot;] = 1] = &quot;GIRL&quot;;})(sex || (sex = {}));console.log(sex); // 打印输出{ &apos;0&apos;: &apos;BOY&apos;, &apos;1&apos;: &apos;GIRL&apos;, BOY: 0, GIRL: 1 }console.log(&quot;\u90B5\u5A01\u5112\u662F&quot; + sex.BOY); // 打印输出 TypeScript是0</code></pre><p>是不是感觉有点像给对象添加各种属性，然后这个属性又有点像常量，然后通过对象去取这个属性？</p><p>上面这样写，不是很友好，那么我们还可以给<code>BOY`</code>GIRL`赋值</p><pre><code>enum sex{    BOY=&quot;男&quot;,    GIRL=&quot;女&quot;}// 转化为es5语法// 我们顺便看看实现的原理&quot;use strict&quot;;var sex;// 首先这里是一个自执行函数// 并且把sex定义为对象，传参进给自执行函数// 然后给sex对象添加属性并且赋值(function (sex) {    sex[&quot;BOY&quot;] = &quot;\u7537&quot;;    sex[&quot;GIRL&quot;] = &quot;\u5973&quot;;})(sex || (sex = {}));console.log(sex); // 打印输出 { BOY: &apos;男&apos;, GIRL: &apos;女&apos; }console.log(&quot;\u90B5\u5A01\u5112\u662F&quot; + sex.BOY); // 打印输出 TypeScript是男</code></pre><p>比如我们实际项目中，特别是商城类，订单会存在很多状态流转，那么非常适合用枚举</p><pre><code>enum orderStatus {    WAIT_FOR_PAY = &quot;待支付&quot;,    UNDELIVERED = &quot;完成支付，待发货&quot;,    DELIVERED = &quot;已发货&quot;,    COMPLETED = &quot;已确认收货&quot;}</code></pre><p>到这里，我们会有一个疑虑，为什么我们不这样写呢？</p><pre><code>let orderStatus2 = {    WAIT_FOR_PAY : &quot;待支付&quot;,    ...}</code></pre><p>如果我们直接写对象的键值对方式，是可以在外部修改这个值的，而我们通过<code>enum</code>则不能修改定义好的值了，更加严谨。</p><h4 id="任意类型-any"><a href="#任意类型-any" class="headerlink" title="任意类型 any"></a>任意类型 any</h4><p><code>any</code>有好处也有坏处，特别是前端，很多时候写类型的时候，几乎分不清楚类型，任意去写，写起来很爽，但是对于后续的重构、迭代等是非常不友好的，会暴露出很多问题，某种程度来说，any类型就是放弃了类型检查了。。。</p><p>比如我们有这样一个场景，就是需要获取某一个dom节点</p><pre><code>let btn = document.getElementById(&apos;btn&apos;);btn.style.color = &quot;blue&quot;;</code></pre><p>此时我们发现在ts中会报错<br> <img src="/2018/05/08/TypeScript入门/5.webp" alt=""><br> 因为我们取这个dom节点，有可能取到，也有可能没取到，当没取到的时候，相当于是null，是没有style这个属性的。</p><p>那么我们可以给它添加一个类型为<code>any</code></p><pre><code>// 添加一个any类型，此时就不会报错了，但是也相当于放弃了类型检查了let btn:any = document.getElementById(&apos;btn&apos;);btn.style.color = &quot;blue&quot;;// 当然也有粗暴一些的方式，利用 ! 强制断言let btn = document.getElementById(&quot;btn&quot;);btn!.style!.color = &quot;blue&quot;;// 可以赋值任何类型的值// 跟以前我们var let声明的一模一样的let person:any = &quot;TypeScript&quot;person = 28</code></pre><h4 id="null-undefined类型"><a href="#null-undefined类型" class="headerlink" title="null undefined类型"></a>null undefined类型</h4><p>这个也没什么好说的，不过可以看下下面的例子</p><pre><code>// (string | number | null | undefined) 相当于这几种类型// 是 string 或 number 或 null 或 undefinedlet str:(string | number | null | undefined)str = &quot;hello swr&quot;str = 28str = nullstr = undefined</code></pre><h4 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h4><p>void表示没有任何类型，一般是定义函数没有返回值。</p><pre><code>// ts写法function say(name:string):void {  console.log(&quot;hello&quot;,name)}say(&quot;swr&quot;)// 转为es5&quot;use strict&quot;;function say(name) {    console.log(&quot;hello&quot;, name);}say(&quot;swr&quot;);</code></pre><p>怎么理解叫没有返回值呢？此时我们给函数return一个值</p><pre><code>function say(name:string):void {  console.log(&quot;hello&quot;,name)  // return&quot;ok&quot; 会报错  return&quot;ok&quot;  // return undefined 不会报错  // return 不会报错}say(&quot;swr&quot;)</code></pre><p>那么此时我们希望这个函数返回一个字符串类型怎么办？</p><pre><code>function say(name:string):string {  console.log(&quot;hello&quot;,name)  return&quot;ok&quot;}say(&quot;swr&quot;)</code></pre><h4 id="never类型"><a href="#never类型" class="headerlink" title="never类型"></a>never类型</h4><p>这个用得很少，一般是用于抛出异常。</p><pre><code>let xx:never;function error(message: string): never {  throw new Error(message);}error(&quot;error&quot;)</code></pre><h4 id="我们要搞明白any、never、void"><a href="#我们要搞明白any、never、void" class="headerlink" title="我们要搞明白any、never、void"></a>我们要搞明白any、never、void</h4><ul><li>any是任意的值</li><li>void是不能有任何值</li><li>never永远不会有返回值</li></ul><p><code>any</code>比较好理解，就是任何值都可以</p><pre><code>let str:any = &quot;hello swr&quot;str = 28str = true</code></pre><p><code>void</code>不能有任何值(返回值)</p><pre><code>function say():void {}</code></pre><p><code>never</code>则不好理解，什么叫永远不会有返回值？</p><pre><code>// 除了上面举例的抛出异常以外，我们看一下这个例子// 这个loop函数，一旦开始执行，就永远不会结束// 可以看出在while中，是死循环，永远都不会有返回值，包括undefinedfunction loop():never {    while(true){        console.log(&quot;陷入死循环啦&quot;)    }}loop()// 包括比如JSON.parse也是使用这种 never | anyfunction parse(str:string):(never | any){    return JSON.parse(str)}// 首先在正常情况下，我们传一个JSON格式的字符串，是可以正常得到一个JSON对象的let json = parse(&apos;{&quot;name&quot;:&quot;TypeScript&quot;}&apos;)// 但是有时候，传进去的不一定是JSON格式的字符串，那么就会抛出异常// 此时就需要never了let json = parse(&quot;iamswr&quot;)</code></pre><p>也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。</p><p>实际开发中，是never和联合类型来一起用，比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():(never | string) &#123;</span><br><span class="line">  return &quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是这样定义的</p><pre><code>function say(name:string):void {  console.log(&quot;hello&quot;,name)}say(&quot;TypeScript&quot;)</code></pre><p>形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数放在后面</p><pre><code>// 形参和实参一一对应，完全一样function say(name:string,age:number):void {  console.log(&quot;hello&quot;,name,age)}say(&quot;TypeScript&quot;,28)// 可选参数，用 ？ 处理，只能放在后面function say(name:string,age?:number):void {  console.log(&quot;hello&quot;,name,age)}say(&quot;TypeScript&quot;)</code></pre><p>那么如何设置默认参数呢？</p><pre><code>// 在js中我们是这样写的function ajax(url,method=&quot;get&quot;){    console.log(url,method)}// 在ts中我们是这样写的function ajax(url:string,method:string = &quot;GET&quot;) {  console.log(url,method)}</code></pre><p>那么如何设置剩余参数呢？可以利用扩展运算符</p><pre><code>function sum(...args:Array&lt;number&gt;):number {  returneval(args.join(&quot;+&quot;))}let total:number = sum(1,2,3,4,5)console.log(total)</code></pre><p>那么如何实现函数重载呢？函数重载是java中非常有名的，在java中函数的重载，是指两个或者两个以上的同名函数，参数的个数和类型不一样</p><pre><code>// 比如说我们现在有2个同名函数function say(name:string){}function say(name:string,age:number){}// 那么我想达到一个效果// 当我传参数name时，执行name:string这个函数// 当我传参数name和age时，执行name:string,age:number这个函数// 此时该怎么办？</code></pre><h4 id="接下来看一下typescript中的函数重载"><a href="#接下来看一下typescript中的函数重载" class="headerlink" title="接下来看一下typescript中的函数重载"></a>接下来看一下typescript中的函数重载</h4><pre><code>// 首先声明两个函数名一样的函数function say(val: string): void; // 函数的声明function say(val: number): void; // 函数的声明// 函数的实现，注意是在这里是有函数体的// 其实下面的say()无论怎么执行，实际上就是执行下面的函数function say(val: any):void {  console.log(val)}say(&quot;hello swr&quot;)say(28)</code></pre><p>在typescript中主要体现是同一个同名函数提供多个函数类型定义，函数实际上就只有一个，就是拥有函数体那个，如果想根据传入值类型的不一样执行不同逻辑，则需要在这个函数里面进行一个类型判断。</p><p>那么这个函数重载有什么作用呢？其实在ts中，函数重载只是用来限制参数的个数和类型，用来检查类型的，而且重载不能拆开几个函数，这一点和java的处理是不一样的，需要注意。</p><hr><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h4 id="如何定义一个类？"><a href="#如何定义一个类？" class="headerlink" title="如何定义一个类？"></a>如何定义一个类？</h4><pre><code>// ts写法// 其实跟es6非常像，没太大的区别class Person{  // 这里声明的变量，是实例上的属性  name:string  age:number  constructor(name:string,age:number){    // this.name和this.age必须在前面先声明好类型    // name:string   age:number    this.name = name    this.age = age  }  // 原型方法  say():string{    return&quot;hello swr&quot;  }}let p = new Person(&quot;TypeScript&quot;,28)// 那么转为es5呢？&quot;use strict&quot;;var Person = /** @class */ (function () {    function Person(name, age) {        this.name = name;        this.age = age;    }    Person.prototype.say = function () {        return&quot;hello swr&quot;;    };    return Person;}());var p = new Person(&quot;TypeScript&quot;, 28);</code></pre><h4 id="可以发现，其实跟我们es6的class是非常像的，那么类的继承是怎样实现呢？"><a href="#可以发现，其实跟我们es6的class是非常像的，那么类的继承是怎样实现呢？" class="headerlink" title="可以发现，其实跟我们es6的class是非常像的，那么类的继承是怎样实现呢？"></a>可以发现，其实跟我们es6的class是非常像的，那么类的继承是怎样实现呢？</h4><pre><code>// 类的继承和es6也是差不多class Parent{  // 这里声明的变量，是实例上的属性  name:string  age:number  constructor(name:string,age:number){    // this.name和this.age必须在前面先声明好类型    // name:string   age:number    this.name = name    this.age = age  }  // 原型方法  say():string{    return&quot;hello swr&quot;  }}class Child extends Parent{  childName:string  constructor(name:string,age:number,childName:string){    super(name,age)    this.childName = childName  }  childSay():string{    return this.childName  }}let child = new Child(&quot;TypeScript&quot;,28,&quot;bb&quot;)console.log(child)</code></pre><h4 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h4><ul><li><code>public</code>公开的，可以供自己、子类以及其它类访问</li><li><code>protected</code>受保护的，可以供自己、子类访问，但是其他就访问不了</li><li><code>private</code>私有的，只有自己访问，而子类、其他都访问不了</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Parent&#123;</span><br><span class="line">  public name:string</span><br><span class="line">  protected age:number</span><br><span class="line">  private money:number</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 也可以简写为</span><br><span class="line">   * constructor(public name:string,protected age:number,private money:number)</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">  constructor(name:string,age:number,money:number)&#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">    this.money = money</span><br><span class="line">  &#125;</span><br><span class="line">  getName():string&#123;</span><br><span class="line">    return this.name</span><br><span class="line">  &#125;</span><br><span class="line">  getAge():number&#123;</span><br><span class="line">    return this.age</span><br><span class="line">  &#125;</span><br><span class="line">  getMoney():number&#123;</span><br><span class="line">    return this.money</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Parent(&quot;TypeScript&quot;,28,10)</span><br><span class="line">console.log(p.name)</span><br><span class="line">console.log(p.age) // 报错</span><br><span class="line">console.log(p.money) // 报错</span><br></pre></td></tr></table></figure><h4 id="静态属性、静态方法，跟es6差不多"><a href="#静态属性、静态方法，跟es6差不多" class="headerlink" title="静态属性、静态方法，跟es6差不多"></a>静态属性、静态方法，跟es6差不多</h4><pre><code>class Person{    // 这是类的静态属性    static name = &quot;TypeScript&quot;    // 这是类的静态方法，需要通过这个类去调用    static say(){        console.log(&quot;hello swr&quot;)    }}let p = new Person()Person.say() // hello swrp.say() // 报错</code></pre><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类和方法，有点类似抽取共性出来，但是又不是具体化，比如说，世界上的动物都需要吃东西，那么会把吃东西这个行为，抽象出来。</p><p>如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错。</p><pre><code>// 关键字 abstract 抽象的意思// 首先定义个抽象类Animal// Animal类有一个抽象方法eatabstract class Animal{    // 实际上是使用了public修饰符    // 如果添加private修饰符则会报错    abstract eat():void;}// 需要注意的是，这个Animal类是不能实例化的let animal = new Animal() // 报错// 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中// 实现这个抽象方法，不然会报错// 报错，因为在子类中没有实现eat抽象方法class Person extends Animal{    eat1(){        console.log(&quot;吃米饭&quot;)    }}// Dog类继承Animal类后并且实现了抽象方法eat，所以不会报错class Dog extends Animal{    eat(){        console.log(&quot;吃骨头&quot;)    }}</code></pre><hr><h2 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h2><p>这里的接口，主要是一种规范，规范某些类必须遵守规范，和抽象类有点类似，但是不局限于类，还有属性、函数等。</p><h4 id="首先我们看看接口是如何规范对象的"><a href="#首先我们看看接口是如何规范对象的" class="headerlink" title="首先我们看看接口是如何规范对象的"></a>首先我们看看接口是如何规范对象的</h4><pre><code>// 假设我需要获取用户信息// 我们通过这样的方式，规范必须传name和age的值function getUserInfo(user:{name:string,age:number}){    console.log(`${user.name}${user.age}`)}getUserInfo({name:&quot;TypeScript&quot;,age:28})</code></pre><p>这样看，还是挺完美的，那么问题就出现了，如果我另外还有一个方法，也是需要这个规范呢？</p><pre><code>function getUserInfo(user:{name:string,age:number}){    console.log(`${user.name}${user.age}`)}function getInfo(user:{name:string,age:number}){    console.log(`${user.name}${user.age}`)}getUserInfo({name:&quot;TypeScript&quot;,age:28})getInfo({name:&quot;iamswr&quot;,age:28})</code></pre><p>可以看出，函数<code>getUserInfo</code>和<code>getInfo</code>都遵循同一个规范，那么我们有办法对这个规范复用吗？</p><pre><code>// 首先把需要复用的规范，写到接口中 关键字 interfaceinterface infoInterface{    name:string,    age:number}// 然后把这个接口，替换到我们需要复用的地方function getUserInfo(user:infoInterface){    console.log(`${user.name}${user.age}`)}function getInfo(user:infoInterface){    console.log(`${user.name}${user.age}`)}getUserInfo({name:&quot;TypeScript&quot;,age:28})getInfo({name:&quot;iamswr&quot;,age:28})</code></pre><p>那么有些参数可传可不传，该怎么处理呢？</p><pre><code>interface infoInterface{    name:string,    age:number,    city?:string // 该参数为可选参数}function getUserInfo(user:infoInterface){    console.log(`${user.name}${user.age}${user.city}`)}function getInfo(user:infoInterface){    console.log(`${user.name}${user.age}`)}getUserInfo({name:&quot;TypeScript&quot;,age:28,city:&quot;深圳&quot;})getInfo({name:&quot;iamswr&quot;,age:28})</code></pre><h4 id="接口是如何规范函数的"><a href="#接口是如何规范函数的" class="headerlink" title="接口是如何规范函数的"></a>接口是如何规范函数的</h4><pre><code>// 对一个函数的参数和返回值进行规范interface mytotal {  // 左侧是函数的参数，右侧是函数的返回类型  (a:number,b:number) : number}let total:mytotal = function (a:number,b:number):number {  return a + b}console.log(total(10,20))</code></pre><h4 id="接口是如何规范数组的"><a href="#接口是如何规范数组的" class="headerlink" title="接口是如何规范数组的"></a>接口是如何规范数组的</h4><pre><code>interface userInterface {  // index为数组的索引，类型是number  // 右边是数组里为字符串的数组成员  [index: number]: string}let arr: userInterface = [&apos;TypeScript&apos;, &apos;iamswr&apos;];console.log(arr);</code></pre><h4 id="接口是如何规范类的"><a href="#接口是如何规范类的" class="headerlink" title="接口是如何规范类的"></a>接口是如何规范类的</h4><p>这个比较重要，因为写react的时候会经常使用到类</p><pre><code>// 首先实现一个接口interface Animal{    // 这个类必须有name    name:string,    // 这个类必须有eat方法    // 规定eat方法的参数类型以及返回值类型    eat(any:string):void}// 关键字 implements 实现// 因为接口是抽象的，需要通过子类去实现它class Person implements Animal{    name:string    constructor(name:string){        this.name = name    }    eat(any:string):void{        console.log(`吃${any}`)    }}</code></pre><p>那么如果想遵循多个接口呢？</p><pre><code>interface Animal{    name:string,    eat(any:string):void}// 新增一个接口interface Animal2{    sleep():void}// 可以在implements后面通过逗号添加，和java是一样的// 一个类只能继承一个父类，但是却能遵循多个接口class Person implements Animal,Animal2{    name:string    constructor(name:string){        this.name = name    }    eat(any:string):void{        console.log(`吃${any}`)    }    sleep(){        console.log(&apos;睡觉&apos;)    }}</code></pre><h4 id="接口可以继承接口"><a href="#接口可以继承接口" class="headerlink" title="接口可以继承接口"></a>接口可以继承接口</h4><pre><code>interface Animal{    name:string,    eat(any:string):void}// 像类一样，通过extends继承interface Animal2 extends Animal{    sleep():void}// 因为Animal2类继承了Animal// 所以这里遵循Animal2就相当于把Animal也继承了class Person implements Animal2{    name:string    constructor(name:string){        this.name = name    }    eat(any:string):void{        console.log(`吃${any}`)    }    sleep(){        console.log(&apos;睡觉&apos;)    }}</code></pre><hr><h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><p>泛型可以支持不特定的数据类型，什么叫不特定呢？比如我们有一个方法，里面接收参数，但是参数类型我们是不知道，但是这个类型在方法里面很多地方会用到，参数和返回值要保持一致性</p><pre><code>// 假设我们有一个需求，我们不知道函数接收什么类型的参数，也不知道返回值的类型// 而我们又需要传进去的参数类型和返回值的类型保持一致，那么我们就需要用到泛型// &lt;T&gt;的意思是泛型，即generic type// 可以看出value的类型也为T，返回值的类型也为Tfunction deal&lt;T&gt;(value:T):T{    return value}// 下面的&lt;string&gt;、&lt;number&gt;实际上用的时候再传给上面的&lt;T&gt;console.log(deal&lt;string&gt;(&quot;TypeScript&quot;))console.log(deal&lt;number&gt;(28))</code></pre><h4 id="实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的"><a href="#实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的" class="headerlink" title="实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的"></a>实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的</h4><pre><code>class MyMath&lt;T&gt;{  // 定义一个私有属性  private arr:T[] = []  // 规定传参类型  add(value:T){    this.arr.push(value)  }  // 规定返回值的类型  max():T{    return Math.max.apply(null,this.arr)  }}// 这里规定了类型为number// 相当于把T都替换成numberlet mymath = new MyMath&lt;number&gt;()mymath.add(1)mymath.add(2)mymath.add(3)console.log(mymath.max())// 假设我们传个字符串呢？// 则会报错:类型“&quot;TypeScript&quot;”的参数不能赋给类型“number”的参数。mymath.add(&quot;TypeScript&quot;)</code></pre><p>那么我们会思考，有了接口为什么还需要抽象类？</p><p>接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。</p><p>比如说，我们父类有10个方法，其中9个是实现过的方法，有1个是抽象的方法，那么子类继承过来，只需要实现这一个抽象的方法就可以了，但是接口的话，则是全是抽象的，子类都要实现这些方法，简而言之，接口里面不可以放实现，而抽象类可以放实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20个 CSS高级技巧汇总</title>
      <link href="/2018/05/02/20%E4%B8%AACSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"/>
      <url>/2018/05/02/20%E4%B8%AACSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>使用技巧会让人变的越来越懒，没错，我就是想让你变懒。下面是我收集的CSS高级技巧，希望你懒出境界。</p><h2 id="1-黑白图像"><a href="#1-黑白图像" class="headerlink" title="1. 黑白图像"></a>1. 黑白图像</h2><p>这段代码会让你的彩色照片显示为黑白照片，是不是很酷？</p><pre><code>img.desaturate { filter: grayscale(100%);-webkit-filter: grayscale(100%);-moz-filter: grayscale(100%);-ms-filter: grayscale(100%);-o-filter: grayscale(100%);}</code></pre><h2 id="2-使用-not-在菜单上应用-取消应用边框"><a href="#2-使用-not-在菜单上应用-取消应用边框" class="headerlink" title="2. 使用 :not() 在菜单上应用/取消应用边框"></a>2. 使用 <code>:not()</code> 在菜单上应用/取消应用边框</h2><p>先给每一个菜单项添加边框</p><pre><code>/* add border */.nav li { border-right: 1px solid #666;}</code></pre><p>然后再除去最后一个元素</p><pre><code>// remove border /.nav li:last-child { border-right: none;}</code></pre><p>可以直接使用 :not() 伪类来应用元素：</p><pre><code>.nav li:not(:last-child) { border-right: 1px solid #666;}</code></pre><p>这样代码就干净，易读，易于理解了。</p><p>当然，如果你的新元素有兄弟元素的话，也可以使用通用的兄弟选择符（~）：</p><pre><code>.nav li:first-child ~ li { border-left: 1px solid #666;}</code></pre><h2 id="3-页面顶部阴影"><a href="#3-页面顶部阴影" class="headerlink" title="3. 页面顶部阴影"></a>3. 页面顶部阴影</h2><p>下面这个简单的 CSS3 代码片段可以给网页加上漂亮的顶部阴影效果：</p><pre><code>body:before { content: &quot;&quot;; position: fixed; top: -10px; left: 0; width: 100%; height: 10px;-webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8);-moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100;}</code></pre><h2 id="4-给-body-添加行高"><a href="#4-给-body-添加行高" class="headerlink" title="4. 给 body 添加行高"></a>4. 给 body 添加行高</h2><p>你不需要分别添加 line-height 到每个p,h标记等。只要添加到 body 即可：</p><pre><code>body { line-height: 1;}</code></pre><p>这样文本元素就可以很容易地从 body 继承。</p><h2 id="5-所有一切都垂直居中"><a href="#5-所有一切都垂直居中" class="headerlink" title="5. 所有一切都垂直居中"></a>5. 所有一切都垂直居中</h2><p>要将所有元素垂直居中，太简单了：</p><pre><code>html, body { height: 100%; margin: 0;}body {-webkit-align-items: center; -ms-flex-align: center;  align-items: center; display: -webkit-flex; display: flex;}</code></pre><p>看，是不是很简单。</p><p>注意：在IE11中要小心flexbox</p><h2 id="6-逗号分隔的列表"><a href="#6-逗号分隔的列表" class="headerlink" title="6. 逗号分隔的列表"></a>6. 逗号分隔的列表</h2><p>让HTML列表项看上去像一个真正的，用逗号分隔的列表：</p><pre><code>ul &gt; li:not(:last-child)::after { content: &quot;,&quot;;}</code></pre><p>对最后一个列表项使用 :not() 伪类。</p><h2 id="7-使用负的-nth-child-选择项目"><a href="#7-使用负的-nth-child-选择项目" class="headerlink" title="7. 使用负的 nth-child 选择项目"></a>7. 使用负的 nth-child 选择项目</h2><p>在CSS中使用负的 nth-child 选择项目1到项目n。</p><pre><code>li { display: none;}/* select items 1 through 3 and display them */li:nth-child(-n+3) { display: block;}</code></pre><h2 id="8-对图标使用-SVG"><a href="#8-对图标使用-SVG" class="headerlink" title="8. 对图标使用 SVG"></a>8. 对图标使用 SVG</h2><p>我们没有理由不对图标使用SVG：</p><pre><code>.logo { background: url(&quot;logo.svg&quot;);}</code></pre><p>SVG对所有的分辨率类型都具有良好的扩展性，并支持所有浏览器都回归到IE9。这样可以避开.png、.jpg或.gif文件了。</p><h2 id="9-优化显示文本"><a href="#9-优化显示文本" class="headerlink" title="9. 优化显示文本"></a>9. 优化显示文本</h2><p>有时，字体并不能在所有设备上都达到最佳的显示，所以可以让设备浏览器来帮助你：</p><pre><code>html {-moz-osx-font-smoothing: grayscale;-webkit-font-smoothing: antialiased; text-rendering: optimizeLegibility;}</code></pre><p>注：请负责任地使用 optimizeLegibility。此外，IE /Edge没有 text-rendering 支持。</p><h2 id="10-对纯-CSS-滑块使用-max-height"><a href="#10-对纯-CSS-滑块使用-max-height" class="headerlink" title="10. 对纯 CSS 滑块使用 max-height"></a>10. 对纯 CSS 滑块使用 max-height</h2><p>使用 max-height 和溢出隐藏来实现只有CSS的滑块：</p><pre><code>.slider ul { max-height: 0; overlow: hidden;}.slider:hover ul { max-height: 1000px; transition: .3s ease;}</code></pre><h2 id="11-继承-box-sizing"><a href="#11-继承-box-sizing" class="headerlink" title="11. 继承 box-sizing"></a>11. 继承 box-sizing</h2><p>让 box-sizing 继承 html：</p><pre><code>html { box-sizing: border-box;}*, *:before, *:after { box-sizing: inherit;}</code></pre><p>这样在插件或杠杆其他行为的其他组件中就能更容易地改变 box-sizing 了。</p><h2 id="12-表格单元格等宽"><a href="#12-表格单元格等宽" class="headerlink" title="12. 表格单元格等宽"></a>12. 表格单元格等宽</h2><p>表格工作起来很麻烦，所以务必尽量使用 table-layout: fixed 来保持单元格的等宽：</p><pre><code>.calendar { table-layout: fixed;}</code></pre><h2 id="13-用-Flexbox-摆脱外边距的各种-hack"><a href="#13-用-Flexbox-摆脱外边距的各种-hack" class="headerlink" title="13. 用 Flexbox 摆脱外边距的各种 hack"></a>13. 用 Flexbox 摆脱外边距的各种 hack</h2><p>当需要用到列分隔符时，通过flexbox的 space-between 属性，你就可以摆脱nth-，first-，和 last-child 的hack了：</p><pre><code>.list { display: flex; justify-content: space-between;}.list .person { flex-basis: 23%;}</code></pre><p>现在，列表分隔符就会在均匀间隔的位置出现。</p><h2 id="14-使用属性选择器用于空链接"><a href="#14-使用属性选择器用于空链接" class="headerlink" title="14. 使用属性选择器用于空链接"></a>14. 使用属性选择器用于空链接</h2><p>当a元素没有文本值，但 href 属性有链接的时候显示链接：</p><pre><code>a[href^=&quot;http&quot;]:empty::before { content: attr(href);}</code></pre><p>相当方便。</p><h2 id="15-检测鼠标双击"><a href="#15-检测鼠标双击" class="headerlink" title="15. 检测鼠标双击"></a>15. 检测鼠标双击</h2><p>HTML：</p><pre><code>&lt;div class=&quot;test3&quot;&gt;&lt;span&gt;&lt;input type=&quot;text&quot; value=&quot; &quot; readonly=&quot;true&quot; /&gt;&lt;a href=&quot;http://renpingjun.com&quot;&gt;Double click me&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;</code></pre><p>CSS：</p><pre><code>.test3 span { position: relative;}.test3 span a { position: relative; z-index: 2;}.test3 span a:hover, .test3 span a:active { z-index: 4;}.test3 span input { background: transparent; border: 0; cursor: pointer; position: absolute; top: -1px; left: 0; width: 101%; /* Hacky */ height: 301%; /* Hacky */ z-index: 3;}.test3 span input:focus { background: transparent; border: 0; z-index: 1;}</code></pre><h2 id="16-CSS-写出三角形"><a href="#16-CSS-写出三角形" class="headerlink" title="16. CSS 写出三角形"></a>16. CSS 写出三角形</h2><pre><code>/* create an arrow that points up */div.arrow-up { width:0px; height:0px; border-left:5px solid transparent; /* left arrow slant */ border-right:5px solid transparent; /* right arrow slant */ border-bottom:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;}/* create an arrow that points down */div.arrow-down { width:0px; height:0px; border-left:5px solid transparent; border-right:5px solid transparent; border-top:5px solid #2f2f2f; font-size:0px; line-height:0px;}/* create an arrow that points left */div.arrow-left { width:0px; height:0px; border-bottom:5px solid transparent; /* left arrow slant */ border-top:5px solid transparent; /* right arrow slant */ border-right:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;}/* create an arrow that points right */div.arrow-right { width:0px; height:0px; border-bottom:5px solid transparent; /* left arrow slant */ border-top:5px solid transparent; /* right arrow slant */ border-left:5px solid #2f2f2f; /* bottom, add background color here */ font-size:0px; line-height:0px;}</code></pre><h2 id="17-CSS3-calc-的使用"><a href="#17-CSS3-calc-的使用" class="headerlink" title="17. CSS3 calc() 的使用"></a>17. CSS3 calc() 的使用</h2><p>calc() 用法类似于函数，能够给元素设置动态的值：</p><pre><code>/* basic calc */.simpleBlock { width: calc(100% - 100px);}/* calc in calc */.complexBlock { width: calc(100% - 50% / 3); padding: 5px calc(3% - 2px); margin-left: calc(10% + 10px);}</code></pre><h2 id="18-文本渐变"><a href="#18-文本渐变" class="headerlink" title="18. 文本渐变"></a>18. 文本渐变</h2><p>文本渐变效果很流行，使用 CSS3 能够很简单就实现：</p><pre><code>h2[data-text] { position: relative;}h2[data-text]::after { content: attr(data-text); z-index: 10; color: #e3e3e3; position: absolute; top: 0; left: 0;-webkit-mask-image: -webkit-gradient(linear, left top, left bottom, from(rgba(0,0,0,0)), color-stop(50%, rgba(0,0,0,1)), to(rgba(0,0,0,0)));}</code></pre><h2 id="19-禁用鼠标事件"><a href="#19-禁用鼠标事件" class="headerlink" title="19. 禁用鼠标事件"></a>19. 禁用鼠标事件</h2><p>CSS3 新增的 pointer-events 让你能够禁用元素的鼠标事件，例如，一个连接如果设置了下面的样式就无法点击了。</p><pre><code>.disabled { pointer-events: none; }</code></pre><h2 id="20-模糊文本"><a href="#20-模糊文本" class="headerlink" title="20. 模糊文本"></a>20. 模糊文本</h2><p>简单但很漂亮的文本模糊效果，简单又好看！</p><pre><code>.blur {  color: transparent;  text-shadow: 0 0 5px rgba(0,0,0,0.5);}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue源码必知必会</title>
      <link href="/2018/05/02/Vue%E6%BA%90%E7%A0%81%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2018/05/02/Vue%E6%BA%90%E7%A0%81%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Vue.js源码分析，记录了个人学习Vue.js源码的过程中的一些心得以及收获。以及对于Vue框架，周边库的一些学习心得和个人见解。</p><p>在学习的过程中我分别为Vue.js、Vuex、Vue-router加上了注释，分别在文件夹<a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/vue-src" target="_blank" rel="noopener">vue-src</a>、<a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/vuex-src" target="_blank" rel="noopener">vuex-src</a>以及<a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/vue-router-src" target="_blank" rel="noopener">vue-router-src</a>中，希望可以帮助有需要的同学更好地学习理解Vue.js及周边库的源码。</p><p>感谢尤大提高生产力。</p><p>当前Vue.js源码版本2.3.0，Vuex版本为2.4.0，Vue-router版本为3.0.1。</p><p>本项目希望对Vue.js做更进一步的探索与学习，Vue.js基础内容请参考Vue.js官网，<a href="https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/</a>。 可能会有理解存在偏差的地方，欢迎提issue指出，共同学习，共同进步。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h2 id="源码相关"><a href="#源码相关" class="headerlink" title="源码相关"></a>源码相关</h2><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E5%2593%258D%25E5%25BA%2594%25E5%25BC%258F%25E5%258E%259F%25E7%2590%2586.MarkDown" target="_blank" rel="noopener">Vue.js响应式原理</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E4%25BE%259D%25E8%25B5%2596%25E6%2594%25B6%25E9%259B%2586.MarkDown" target="_blank" rel="noopener">Vue.js依赖收集</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E4%25BB%258E%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%2592%25E5%25BA%25A6%25E5%2586%258D%25E7%259C%258B%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2591%25E5%25AE%259A.MarkDown" target="_blank" rel="noopener">从Vue.js源码角度再看数据绑定</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/Vue%25E4%25BA%258B%25E4%25BB%25B6%25E6%259C%25BA%25E5%2588%25B6.MarkDown" target="_blank" rel="noopener">Vue.js事件机制</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/VNode%25E8%258A%2582%25E7%2582%25B9.MarkDown" target="_blank" rel="noopener">VNode节点(Vue.js实现)</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/VirtualDOM%25E4%25B8%258Ediff%28Vue%25E5%25AE%259E%25E7%258E%25B0%29.MarkDown" target="_blank" rel="noopener">Virtual DOM与diff(Vue.js实现)</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E8%2581%258A%25E8%2581%258AVue%25E7%259A%2584template%25E7%25BC%2596%25E8%25AF%2591.MarkDown" target="_blank" rel="noopener">聊聊Vue.js的template编译</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/Vue.js%25E5%25BC%2582%25E6%25AD%25A5%25E6%259B%25B4%25E6%2596%25B0DOM%25E7%25AD%2596%25E7%2595%25A5%25E5%258F%258AnextTick.MarkDown" target="_blank" rel="noopener">Vue.js异步更新DOM策略及nextTick</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E4%25BB%258Etemplate%25E5%2588%25B0DOM%28Vue.js%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%2592%25E5%25BA%25A6%25E7%259C%258B%25E5%2586%2585%25E9%2583%25A8%25E8%25BF%2590%25E8%25A1%258C%25E6%259C%25BA%25E5%2588%25B6%29.MarkDown" target="_blank" rel="noopener">从template到DOM（Vue.js源码角度看内部运行机制）</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/Vuex%25E6%25BA%2590%25E7%25A0%2581%25E8%25A7%25A3%25E6%259E%2590.MarkDown" target="_blank" rel="noopener">Vuex源码解析</a></p><h2 id="随笔杂谈"><a href="#随笔杂谈" class="headerlink" title="随笔杂谈"></a>随笔杂谈</h2><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/Vue%25E7%25BB%2584%25E4%25BB%25B6%25E9%2597%25B4%25E9%2580%259A%25E4%25BF%25A1.MarkDown" target="_blank" rel="noopener">Vue组件间通信</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/answershuto/learnVue/blob/master/docs/%25E8%25AF%25B4%25E8%25AF%25B4element%25E7%25BB%2584%25E4%25BB%25B6%25E5%25BA%2593broadcast%25E4%25B8%258Edispatch.MarkDown" target="_blank" rel="noopener">说说element组件库broadcast与dispatch</a></p><p>该源码分析，会带着大家一起学习<code>Vue</code>的大部分代码，而不是简单的讲一下它的原理，我会尽可能的多解释每一行主要的代码含义，另外一些辅助方法什么的，大家可以在学习的过程中，自己看一眼就知道了。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/Vue%25E6%25BA%2590%25E7%25A0%2581%25E7%259B%25AE%25E5%25BD%2595%25E7%25BB%2593%25E6%259E%2584%25E6%2595%25B4%25E7%2590%2586.md" target="_blank" rel="noopener">Vue源码目录结构整理</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E4%25BB%258E%25E5%2585%25A5%25E5%258F%25A3%25E6%2596%2587%25E4%25BB%25B6%25E6%259F%25A5%25E7%259C%258BVue%25E6%25BA%2590%25E7%25A0%2581.md" target="_blank" rel="noopener">从入口文件查看Vue源码</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E4%25BB%258E%25E4%25B8%2580%25E4%25B8%25AA%25E5%25B0%258F%25E6%25A0%2597%25E5%25AD%2590%25E6%259F%25A5%25E7%259C%258BVue%25E7%259A%2584%25E7%2594%259F%25E5%2591%25BD%25E5%2591%25A8%25E6%259C%259F.md" target="_blank" rel="noopener">从小栗子查看Vue的生命周期</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E5%258F%258C%25E5%2590%2591%25E6%2595%25B0%25E6%258D%25AE%25E7%25BB%2591%25E5%25AE%259A.md" target="_blank" rel="noopener">双向数据绑定</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/compile%25E6%25A6%2582%25E8%25BF%25B0.md" target="_blank" rel="noopener">compile概述</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/compile%25E2%2580%2594%25E2%2580%2594%25E7%2594%259F%25E6%2588%2590ast.md" target="_blank" rel="noopener">compile——生成ast</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/compile%25E2%2580%2594%25E2%2580%2594%25E4%25BC%2598%25E5%258C%2596%25E9%259D%2599%25E6%2580%2581%25E5%2586%2585%25E5%25AE%25B9.md" target="_blank" rel="noopener">compile——优化静态内容</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/compile%25E2%2580%2594%25E2%2580%2594%25E7%2594%259F%25E6%2588%2590render%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2.md" target="_blank" rel="noopener">compile——生成render字符串</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/vdom%25E6%25A6%2582%25E8%25BF%25B0.md" target="_blank" rel="noopener">vdom概述</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/Vue.extend.md" target="_blank" rel="noopener">Vue.extend</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/vdom%25E2%2580%2594%25E2%2580%2594VNode.md" target="_blank" rel="noopener">vdom——VNode</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/children%25E7%259A%2584%25E5%25BD%2592%25E4%25B8%2580%25E5%258C%2596%25E5%25A4%2584%25E7%2590%2586.md" target="_blank" rel="noopener">children的归一化处理</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/patch%25E2%2580%2594%25E2%2580%2594%25E5%2588%259B%25E5%25BB%25BAdom.md" target="_blank" rel="noopener">patch——创建dom</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/patch%25E2%2580%2594%25E2%2580%2594diff.md" target="_blank" rel="noopener">patch——diff</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/patch%25E2%2580%2594%25E2%2580%2594%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589%25E7%25BB%2584%25E4%25BB%25B6%25E7%259A%2584%25E5%25A4%2584%25E7%2590%2586%25E6%25B5%2581%25E7%25A8%258B.md" target="_blank" rel="noopener">patch——自定义组件的处理流程</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E4%25BA%258B%25E4%25BB%25B6%25E5%25A4%2584%25E7%2590%2586.md" target="_blank" rel="noopener">事件处理</a></p><p>指令的处理</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/directives%25E6%25A6%2582%25E8%25BF%25B0.md" target="_blank" rel="noopener">directives概述</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/%25E8%2587%25AA%25E5%25AE%259A%25E4%25B9%2589%25E6%258C%2587%25E4%25BB%25A4.md" target="_blank" rel="noopener">自定义指令</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-for.md" target="_blank" rel="noopener">v-for</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-if.md" target="_blank" rel="noopener">v-if</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-once.md" target="_blank" rel="noopener">v-once</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-show.md" target="_blank" rel="noopener">v-show</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-text%25E3%2580%2581v-html%25E3%2580%2581v-cloak%25E3%2580%2581v-pre.md" target="_blank" rel="noopener">v-text、v-html、v-cloak、v-pre</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/v-model.md" target="_blank" rel="noopener">v-model</a></p><p>内置组件和标签</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/slot%25E5%2592%258C%25E4%25BD%259C%25E7%2594%25A8%25E5%259F%259F%25E6%258F%2592%25E6%25A7%25BD.md" target="_blank" rel="noopener">slot和作用域插槽</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/keep-alive.md" target="_blank" rel="noopener">keep-alive</a></p><p>以下是整理一些比较零散的数据，主要是记录结构中每个数据表示什么意思，会不断完善更新：</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/Vue-globals.md" target="_blank" rel="noopener">Vue全局属性</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/Vue%25E5%25AE%259E%25E4%25BE%258B%25E5%25B1%259E%25E6%2580%25A7.md" target="_blank" rel="noopener">Vue实例属性</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/AstElement.md" target="_blank" rel="noopener">AstElement</a></p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/liutao/vue2.0-source/blob/master/VNode.md" target="_blank" rel="noopener">VNode</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue你可能不知道的7个技巧</title>
      <link href="/2018/04/10/Vue%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%847%E4%B8%AA%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/04/10/Vue%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%847%E4%B8%AA%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="一、善用watch的immediate属性"><a href="#一、善用watch的immediate属性" class="headerlink" title="一、善用watch的immediate属性"></a>一、善用watch的immediate属性</h2><p>这一点我在项目中也是这么写的。例如有请求需要再也没初始化的时候就执行一次，然后监听他的变化，很多人这么写：</p><pre><code>created(){    this.fetchPostList()},watch: {    searchInputValue(){        this.fetchPostList()    }}</code></pre><p>上面的这种写法我们可以完全如下写：</p><pre><code> watch: {    searchInputValue:{        handler: &apos;fetchPostList&apos;,        immediate: true    }}</code></pre><h2 id="二、组件注册，值得借鉴"><a href="#二、组件注册，值得借鉴" class="headerlink" title="二、组件注册，值得借鉴"></a>二、组件注册，值得借鉴</h2><p>一般情况下，我们组件如下写：</p><pre><code>import BaseButton from &apos;./baseButton&apos;import BaseIcon from &apos;./baseIcon&apos;import BaseInput from &apos;./baseInput&apos;export default {  components: {    BaseButton,    BaseIcon,    BaseInput  }}&lt;BaseInput  v-model=&quot;searchText&quot; @keydown.enter=&quot;search&quot; /&gt;&lt;BaseButton @click=&quot;search&quot;&gt;  &lt;BaseIcon name=&quot;search&quot;/&gt;&lt;/BaseButton&gt;</code></pre><p>步骤一般有三部，</p><blockquote><p>第一步，引入、</p></blockquote><blockquote><p>第二步注册、</p></blockquote><blockquote><p>第三步才是正式的使用，</p></blockquote><p>这也是最常见和通用的写法。但是这种写法经典归经典，好多组件，要引入多次，注册多次，感觉很烦。</p><p>我们可以借助一下webpack，使用 require.context() 方法来创建自己的（模块）上下文，从而实现自动动态require组件。</p><p>思路是：在src文件夹下面main.js中，借助webpack动态将需要的基础组件统统打包进来。</p><p>代码如下：</p><pre><code>import Vue from &apos;vue&apos;import upperFirst from &apos;lodash/upperFirst&apos;import camelCase from &apos;lodash/camelCase&apos;// Require in a base component contextconst requireComponent = require.context(&apos;./components&apos;, false, /base-[\w-]+\.vue$/)requireComponent.keys().forEach(fileName =&gt; {  // Get component config  const componentConfig = requireComponent(fileName)  // Get PascalCase name of component  const componentName = upperFirst(    camelCase(fileName.replace(/^\.\//, &apos;&apos;).replace(/\.\w+$/, &apos;&apos;))  )  // Register component globally  Vue.component(componentName, componentConfig.default || componentConfig)})</code></pre><p>这样我们引入组件只需要第三步就可以了：</p><pre><code>&lt;BaseInput   v-model=&quot;searchText&quot;   @keydown.enter=&quot;search&quot;/&gt;&lt;BaseButton @click=&quot;search&quot;&gt;   &lt;BaseIcon name=&quot;search&quot;/&gt;&lt;/BaseButton&gt;</code></pre><h2 id="三、精简vuex的modules引入"><a href="#三、精简vuex的modules引入" class="headerlink" title="三、精简vuex的modules引入"></a>三、精简vuex的modules引入</h2><p>对于vuex，我们输出store如下写：</p><pre><code>import auth from &apos;./modules/auth&apos;import posts from &apos;./modules/posts&apos;import comments from &apos;./modules/comments&apos;export default new Vuex.Store({  modules: {    auth,    posts,    comments  }})</code></pre><p>要引入好多modules，然后再注册到Vuex.Store中~~</p><p>精简的做法和上面类似，也是运用 require.context()读取文件，代码如下：</p><pre><code>import camelCase from &apos;lodash/camelCase&apos;const requireModule = require.context(&apos;.&apos;, false, /\.js$/)const modules = {}requireModule.keys().forEach(fileName =&gt; {// Don&apos;t register this file as a Vuex moduleif (fileName === &apos;./index.js&apos;) returnconst moduleName = camelCase(  fileName.replace(/(\.\/|\.js)/g, &apos;&apos;))modules[moduleName] = {              namespaced: true,             ...requireModule(fileName),            }})export default modules</code></pre><p>这样我们只需如下代码就可以了：</p><pre><code>import modules from &apos;./modules&apos;export default new Vuex.Store({   modules})</code></pre><h2 id="四、路由的延迟加载"><a href="#四、路由的延迟加载" class="headerlink" title="四、路由的延迟加载"></a>四、路由的延迟加载</h2><p>这一点，关于vue的引入，我之前在中也提及过，可以通过require方式或者import()方式动态加载组件。</p><pre><code>{ path: &apos;/admin&apos;, name: &apos;admin-dashboard&apos;, component:require(&apos;@views/admin&apos;).default}</code></pre><p>或者</p><pre><code>{  path: &apos;/admin&apos;,  name: &apos;admin-dashboard&apos;,  component:() =&gt; import(&apos;@views/admin&apos;)}</code></pre><p>加载路由。</p><h2 id="五、router-key组件刷新"><a href="#五、router-key组件刷新" class="headerlink" title="五、router key组件刷新"></a>五、router key组件刷新</h2><p>下面这个场景真的是伤透了很多程序员的心…<br> 先默认大家用的是Vue-router来实现路由的控制。 假设我们在写一个博客网站，需求是从/post-haorooms/a，跳转到/post-haorooms/b。然后我们惊人的发现，页面跳转后数据竟然没更新？！原因是vue-router”智能地”发现这是同一个组件，然后它就决定要复用这个组件，所以你在created函数里写的方法压根就没执行。通常的解决方案是监听$route的变化来初始化数据，如下：</p><pre><code>data() {  return {    loading: false,    error: null,    post: null  }}, watch: {  &apos;$route&apos;: {    handler: &apos;resetData&apos;,    immediate: true  }},methods: {  resetData() {    this.loading = false    this.error = null    this.post = null    this.getPost(this.$route.params.id)  },  getPost(id){  }}</code></pre><p>bug是解决了，可每次这么写也太不优雅了吧？秉持着能偷懒则偷懒的原则，我们希望代码这样写：</p><pre><code>data() {  return {    loading: false,    error: null,    post: null  }},created () {  this.getPost(this.$route.params.id)},methods () {  getPost(postId) {    // ...  }}</code></pre><p>解决方案：给router-view添加一个唯一的key，这样即使是公用组件，只要url变化了，就一定会重新创建这个组件。</p><pre><code>&lt;router-view :key=&quot;$route.fullpath&quot;&gt;&lt;/router-view&gt;</code></pre><p>注：我个人的经验，这个一般应用在子路由里面，这样才可以不避免大量重绘，假设app.vue根目录添加这个属性，那么每次点击改变地址都会重绘，还是得不偿失的！</p><h2 id="六、唯一组件根元素"><a href="#六、唯一组件根元素" class="headerlink" title="六、唯一组件根元素"></a>六、唯一组件根元素</h2><p>场景如下：</p><pre><code>(Emitted value instead of an instance of Error) Error compiling template: &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; - Component template should contain exactly one root element.    If you are using v-if on multiple elements, use v-else-if    to chain them instead.</code></pre><p>模板中div只能有一个，不能如上面那么平行2个div。</p><p>例如如下代码：</p><pre><code>&lt;template&gt;  &lt;li    v-for=&quot;route in routes&quot;    :key=&quot;route.name&quot;  &gt;    &lt;router-link :to=&quot;route&quot;&gt;      {{ route.title }}    &lt;/router-link&gt;  &lt;/li&gt;&lt;/template&gt;</code></pre><p>会报错！</p><p>我们可以用render函数来渲染</p><pre><code>functional: true,render(h, { props }) { return props.routes.map(route =&gt;   &lt;li key={route.name}&gt;     &lt;router-link to={route}&gt;       {route.title}     &lt;/router-link&gt;   &lt;/li&gt; )}</code></pre><h2 id="七、组件包装、事件属性穿透问题"><a href="#七、组件包装、事件属性穿透问题" class="headerlink" title="七、组件包装、事件属性穿透问题"></a>七、组件包装、事件属性穿透问题</h2><p>当我们写组件的时候，通常我们都需要从父组件传递一系列的props到子组件，同时父组件监听子组件emit过来的一系列事件。举例子：</p><pre><code>//父组件&lt;BaseInput     :value=&quot;value&quot;    label=&quot;密码&quot;     placeholder=&quot;请填写密码&quot;    @input=&quot;handleInput&quot;    @focus=&quot;handleFocus&gt;&lt;/BaseInput&gt;//子组件&lt;template&gt;  &lt;label&gt;    {{ label }}    &lt;input      :value=&quot;value&quot;      :placeholder=&quot;placeholder&quot;      @focus=$emit(&apos;focus&apos;, $event)&quot;      @input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot;    &gt;  &lt;/label&gt;&lt;/template&gt;</code></pre><p>这样写很不精简，很多属性和事件都是手动定义的，我们可以如下写：</p><pre><code>&lt;input    :value=&quot;value&quot;    v-bind=&quot;$attrs&quot;    v-on=&quot;listeners&quot;&gt;computed: {  listeners() {    return {      ...this.$listeners,      input: event =&gt;         this.$emit(&apos;input&apos;, event.target.value)    }  }}</code></pre><p>$attrs包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定，并且可以通过 v-bind=”$attrs” 传入内部组件。</p><p>$listeners包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue2.0模板渲染底层思想</title>
      <link href="/2018/04/02/Vue2-0%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93%E5%BA%95%E5%B1%82%E6%80%9D%E6%83%B3/"/>
      <url>/2018/04/02/Vue2-0%E6%A8%A1%E6%9D%BF%E6%B8%B2%E6%9F%93%E5%BA%95%E5%B1%82%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>初衷</p><p>在使用vue2.0的过程，有时看API很难理解vue作者的思想，这促使我想要去深入了解vue底层的思想，了解完底层的一些思想，才能更好的用活框架，虽然网上已经有很多源码解析的文档，但我觉得只有自己动手了，才能更加深印象。</p><p>vue2.0和1.0模板渲染的区别</p><p>Vue 2.0 中模板渲染与 Vue 1.0 完全不同，1.0 中采用的 DocumentFragment （<a href="https://link.zhihu.com/?target=https%3A//juejin.im/entry/59116fa6a0bb9f0058aaaa4c" target="_blank" rel="noopener">想了解可以观看这篇文章</a>），而 2.0 中借鉴 React 的 Virtual DOM。基于 Virtual DOM，2.0 还可以支持服务端渲染（SSR），也支持 JSX 语法（改良版的 render 函数）。</p><p>知识普及</p><p>在开始阅读源码之前，先了解一些相关的知识：AST 数据结构，VNode 数据结构，createElement 的问题，render函数。</p><p>AST 数据结构</p><p>AST 的全称是 Abstract Syntax Tree（抽象语法树），是源代码的抽象语法结构的树状表现形式，计算机学科中编译原理的概念。而vue就是将模板代码映射为AST数据结构，进行语法解析。</p><p>我们看一下 Vue 2.0 源码中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/flow/compiler.js%23L63-L142" target="_blank" rel="noopener">AST 数据结构</a> 的定义：</p><pre><code>declare type ASTNode = ASTElement | ASTText | ASTExpressiondeclare type ASTElement = { // 有关元素的一些定义  type: 1;  tag: string;  attrsList: Array&lt;{ name: string; value: string }&gt;;  attrsMap: { [key: string]: string | null };  parent: ASTElement | void;  children: Array&lt;ASTNode&gt;;  //......}declare type ASTExpression = {  type: 2;  expression: string;  text: string;  static?: boolean;}declare type ASTText = {  type: 3;  text: string;  static?: boolean;}</code></pre><p>我们看到 ASTNode 有三种形式：ASTElement，ASTText，ASTExpression。用属性 type 区分。</p><p>VNode数据结构</p><p>下面是 Vue 2.0 源码中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/vdom/vnode.js%23L23-L50" target="_blank" rel="noopener">VNode 数据结构</a> 的定义 (带注释的跟下面介绍的内容有关)：</p><pre><code>constructor {  this.tag = tag   //元素标签  this.data = data  //属性  this.children = children  //子元素列表  this.text = text  this.elm = elm  //对应的真实 DOM 元素  this.ns = undefined  this.context = context   this.functionalContext = undefined  this.key = data &amp;&amp; data.key  this.componentOptions = componentOptions  this.componentInstance = undefined  this.parent = undefined  this.raw = false  this.isStatic = false //是否被标记为静态节点  this.isRootInsert = true  this.isComment = false  this.isCloned = false  this.isOnce = false}</code></pre><p>真实DOM存在什么问题，为什么要用虚拟DOM</p><p>我们为什么不直接使用原生 DOM 元素，而是使用真实 DOM 元素的简化版 VNode，最大的原因就是 document.createElement 这个方法创建的真实 DOM 元素会带来性能上的损失。我们来看一个 document.createElement 方法的例子</p><pre><code>let div = document.createElement(&apos;div&apos;);for(let k in div) {  console.log(k);}</code></pre><p>打开 console 运行一下上面的代码，会发现打印出来的属性多达 228 个，而这些属性有 90% 多对我们来说都是无用的。VNode 就是简化版的真实 DOM 元素，关联着真实的dom，比如属性elm，只包括我们需要的属性，并新增了一些在 diff 过程中需要使用的属性，例如 isStatic。</p><p>render函数</p><p>这个函数是通过编译模板文件得到的，其运行结果是 VNode。render 函数 与 JSX 类似，Vue 2.0 中除了 Template 也支持 JSX 的写法。大家可以使用 <a href="https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/api/%3F%23Vue-compile" target="_blank" rel="noopener">Vue.compile(template)</a>方法编译下面这段模板。</p><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;header&gt;    &lt;h1&gt;I am a template!&lt;/h1&gt;  &lt;/header&gt;  &lt;p v-if=&quot;message&quot;&gt;    {{ message }}  &lt;/p&gt;  &lt;p v-else&gt;    No message.  &lt;/p&gt;&lt;/div&gt;</code></pre><p>方法会返回一个对象，对象中有 render 和 staticRenderFns 两个值。看一下生成的 render函数</p><pre><code>(function() {  with(this){    return _c(&apos;div&apos;,{   //创建一个 div 元素      attrs:{&quot;id&quot;:&quot;app&quot;}  //div 添加属性 id      },[        _m(0),  //静态节点 header，此处对应 staticRenderFns 数组索引为 0 的 render 函数        _v(&quot; &quot;), //空的文本节点        (message) //三元表达式，判断 message 是否存在         //如果存在，创建 p 元素，元素里面有文本，值为 toString(message)        ?_c(&apos;p&apos;,[_v(&quot;\n    &quot;+_s(message)+&quot;\n  &quot;)])        //如果不存在，创建 p 元素，元素里面有文本，值为 No message.         :_c(&apos;p&apos;,[_v(&quot;\n    No message.\n  &quot;)])      ]    )  }})</code></pre><p>要看懂上面的 render函数，只需要了解 _c，_m，_v，_s 这几个函数的定义，其中 _c 是 createElement（创建元素），_m 是 renderStatic（渲染静态节点），_v 是 createTextVNode（创建文本dom），_s 是 toString （转换为字符串）</p><p>除了 render 函数，还有一个 staticRenderFns 数组，这个数组中的函数与 VDOM 中的 diff 算法优化相关，我们会在编译阶段给后面不会发生变化的 VNode 节点打上 static 为 true 的标签，那些被标记为静态节点的 VNode 就会单独生成 staticRenderFns 函数</p><pre><code>(function() { //上面 render 函数 中的 _m(0) 会调用这个方法  with(this){    return _c(&apos;header&apos;,[_c(&apos;h1&apos;,[_v(&quot;I&apos;m a template!&quot;)])])  }})</code></pre><p>模板渲染过程（重要的函数介绍）</p><p>了解完一些基础知识后，接下来我们讲解下模板的渲染过程</p><p><img src="https://pic2.zhimg.com/v2-4a8793499b4d1a5395f2b5f7d0584a4b_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-4a8793499b4d1a5395f2b5f7d0584a4b_hd.jpg" alt=""><br><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/entries/web-runtime-with-compiler.js%23L14-L67" target="_blank" rel="noopener">$mount</a> 函数，主要是获取 template，然后进入 compileToFunctions 函数。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/platforms/web/compiler/index.js%23L36-L84" target="_blank" rel="noopener">compileToFunctions</a> 函数，主要将 template 编译成 render 函数。首先读缓存，没有缓存就调用 compile 方法拿到 render 函数 的字符串形式，再通过 new Function 的方式生成 render 函数。</p><pre><code>// 有缓存的话就直接在缓存里面拿const key = options &amp;&amp; options.delimiters            ? String(options.delimiters) + template            : templateif (cache[key]) {    return cache[key]}const res = {}const compiled = compile(template, options) // compile 后面会详细讲res.render = makeFunction(compiled.render) //通过 new Function 的方式生成 render 函数并缓存const l = compiled.staticRenderFns.lengthres.staticRenderFns = new Array(l)for (let i = 0; i &lt; l; i++) {    res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i])}......}return (cache[key] = res) // 记录至缓存中</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/index.js" target="_blank" rel="noopener">compile</a> 函数就是将 template 编译成 render 函数的字符串形式，后面一小节我们会详细讲到。</p><p>完成render方法的生成后，会进入 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/instance/lifecycle.js%23L38-L75" target="_blank" rel="noopener">_mount</a> 中进行DOM更新。该方法的核心逻辑如下：</p><pre><code>// 触发 beforeMount 生命周期钩子callHook(vm, &apos;beforeMount&apos;)// 重点：新建一个 Watcher 并赋值给 vm._watchervm._watcher = new Watcher(vm, function updateComponent () {  vm._update(vm._render(), hydrating)}, noop)hydrating = false// manually mounted instance, call mounted on self// mounted is called for render-created child components in its inserted hookif (vm.$vnode == null) {  vm._isMounted = true  callHook(vm, &apos;mounted&apos;)}return vm</code></pre><p>首先会new一个watcher对象（主要是将模板与数据建立联系），在watcher对象创建后，会运行传入的方法 vm._update(vm._render(), hydrating) 。其中的vm._render()主要作用就是运行前面compiler生成的render方法，并返回一个vNode对象。vm.update() 则会对比新的 vdom 和当前 vdom，并把差异的部分渲染到真正的 DOM 树上。<br>（想深入了解watcher的背后实现原理的，可以观看这篇文章 <a href="https://link.zhihu.com/?target=http%3A//zhouweicsu.github.io/blog/2017/03/07/vue-2-0-reactivity/" target="_blank" rel="noopener">Vue2.0 源码阅读：响应式原理</a>）</p><p>compile</p><p>上文中提到 compile 函数就是将 template 编译成 render 函数 的字符串形式。</p><pre><code>export function compile (  template: string,  options: CompilerOptions): CompiledResult {  const AST = parse(template.trim(), options) //1. parse  optimize(AST, options)  //2.optimize  const code = generate(AST, options) //3.generate  return {    AST,    render: code.render,    staticRenderFns: code.staticRenderFns  }}</code></pre><p>这个函数主要有三个步骤组成：parse，optimize 和 generate，分别输出一个包含 AST，staticRenderFns 的对象和 render函数 的字符串。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/parser/index.js" target="_blank" rel="noopener">parse</a> 函数，主要功能是将 template字符串解析成 AST。前面定义了ASTElement的数据结构，parse 函数就是将template里的结构（指令，属性，标签等）转换为AST形式存进ASTElement中，最后解析生成AST。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/optimizer.js%23L21-L29" target="_blank" rel="noopener">optimize</a> 函数（src/compiler/optimizer.js）主要功能就是标记静态节点，为后面 patch 过程中对比新旧 VNode 树形结构做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js%23L22-L47" target="_blank" rel="noopener">generate</a> 函数（src/compiler/codegen/index.js）主要功能就是根据 AST 结构拼接生成 render 函数的字符串。</p><pre><code>const code = AST ? genElement(AST) : &apos;_c(&quot;div&quot;)&apos; staticRenderFns = prevStaticRenderFnsonceCount = prevOnceCountreturn {    render: `with(this){return ${code}}`, //最外层包一个 with(this) 之后返回    staticRenderFns: currentStaticRenderFns}</code></pre><p>其中 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/compiler/codegen/index.js%23L49-L83" target="_blank" rel="noopener">genElement</a> 函数（src/compiler/codegen/index.js）是会根据 AST 的属性调用不同的方法生成字符串返回。</p><pre><code>function genElement (el: ASTElement): string {  if (el.staticRoot &amp;&amp; !el.staticProcessed) {    return genStatic(el)  } else if (el.once &amp;&amp; !el.onceProcessed) {    return genOnce(el)  } else if (el.for &amp;&amp; !el.forProcessed) {    return genFor(el)  } else if (el.if &amp;&amp; !el.ifProcessed) {    return genIf(el)  } else if (el.tag === &apos;template&apos; &amp;&amp; !el.slotTarget) {    return genChildren(el) || &apos;void 0&apos;  } else if (el.tag === &apos;slot&apos;) {  }    return code  }}</code></pre><p>以上就是 compile 函数中三个核心步骤的介绍，compile 之后我们得到了 render 函数 的字符串形式，后面通过 new Function 得到真正的渲染函数。数据发现变化后，会执行 Watcher 中的 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/blob/v2.1.10/src/core/instance/lifecycle.js%23L77-L114" target="_blank" rel="noopener">_update</a> 函数（src/core/instance/lifecycle.js），_update 函数会执行这个渲染函数，输出一个新的 VNode 树形结构的数据。然后在调用 patch 函数，拿这个新的 VNode 与旧的 VNode 进行对比，只有发生了变化的节点才会被更新到真实 DOM 树上。</p><p>patch</p><p>patch.js 就是新旧 VNode 对比的 diff 函数，主要是为了优化dom，通过算法使操作dom的行为降到最低，diff 算法来源于 snabbdom，是 VDOM 思想的核心。snabbdom 的算法为了 DOM 操作跨层级增删节点较少的这一目标进行优化，它只会在同层级进行, 不会跨层级比较。</p><p>想更加深入VNode diff算法原理的，可以观看（<a href="https://link.zhihu.com/?target=https%3A//github.com/aooy/blog/issues/2" target="_blank" rel="noopener">解析vue2.0的diff算法</a>）</p><p>总结</p><ul><li>compile 函数主要是将 template 转换为 AST，优化 AST，再将 AST 转换为 render函数；</li><li>render函数 与数据通过 Watcher 产生关联；</li><li>在数据发生变化时调用 patch 函数，执行此 render 函数，生成新 VNode，与旧 VNode 进行 diff，最终更新 DOM 树。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS继承</title>
      <link href="/2018/03/30/JS%E7%BB%A7%E6%89%BF/"/>
      <url>/2018/03/30/JS%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/03/30/JS继承/1.webp" alt=""><br><img src="/2018/03/30/JS继承/2.webp" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;head&gt;  </span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;  </span><br><span class="line">        &lt;title&gt;&lt;/title&gt;  </span><br><span class="line">        &lt;script type=&quot;text/javascript&quot;&gt;  </span><br><span class="line">            function MAN(name, sex, age) &#123;  </span><br><span class="line">                this.name = name;  </span><br><span class="line">                this.sex = sex;  </span><br><span class="line">                this.age = age;  </span><br><span class="line">                this.say = function(school, zhuanye) &#123;  </span><br><span class="line">                    console.log(this.name + &quot;,&quot; + this.sex + &quot;,今年&quot; + this.age + &quot;岁！在&quot; + school + &quot;学习&quot; + zhuanye);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            MAN.prototype.cao = function() &#123;  </span><br><span class="line">                console.log(this.name + &quot;,&quot; + this.sex + &quot;,都已经&quot; + this.age + &quot;了,再不疯狂我们就老了！&quot;)  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            function WOMAN(name, sex, age) &#123;  </span><br><span class="line">                //方法1：对象冒充  </span><br><span class="line">                //this.man = MAN;   </span><br><span class="line">                //this.man(name, sex, age);  </span><br><span class="line">                //方法2：call  </span><br><span class="line">                //MAN.call(this,name, sex, age);  </span><br><span class="line">                //方法3：apply  </span><br><span class="line">                //MAN.apply(this,[name, sex, age]);  </span><br><span class="line">                //方法4：bind  </span><br><span class="line">                //MAN.bind(this)(name, sex, age);  </span><br><span class="line">                MAN.bind(this)(name, sex, age);  </span><br><span class="line">            &#125;  </span><br><span class="line">            //方法5：prototype  </span><br><span class="line">            WOMAN.prototype = new MAN();  </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">            //注意：方法1,2,3,4只能继承this.XXX=XXX的属性,不能继承XXX.prototype.xxx==function()&#123;&#125;,注释掉方法5可以看到  </span><br><span class="line">            //方法5只能继承XXX.prototype.xxx==function()&#123;&#125;的属性，不能继承this.XXX=XXX的属性，注释掉方法1,2,3,4可以看到  </span><br><span class="line">              </span><br><span class="line">            var man = new MAN(&quot;张三&quot;, &quot;男&quot;, 26);  </span><br><span class="line">            man.say(&apos;蓝翔技校&apos;, &apos;电气焊&apos;);  </span><br><span class="line">            man.cao();  </span><br><span class="line">            var woman = new WOMAN(&quot;小红&quot;, &quot;女&quot;, 18);  </span><br><span class="line">            woman.say(&apos;清华大学&apos;, &apos;挖掘机&apos;);  </span><br><span class="line">            woman.cao();  </span><br><span class="line">        &lt;/script&gt;  </span><br><span class="line">    &lt;/head&gt;  </span><br><span class="line">  </span><br><span class="line">    &lt;body&gt;  </span><br><span class="line">    &lt;/body&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/03/30/JS继承/3.webp" alt=""><br>众所周知，在 ES 6 之前没有类的概念，所以不能像 Java 中一个 extends 关键字就搞定了继承关系，需要一些 tricks 来实现，下面就介绍一些比较常用的方法。</p><h2 id="一-原型链继承："><a href="#一-原型链继承：" class="headerlink" title="(一) 原型链继承："></a>(一) 原型链继承：</h2><pre><code>function Parent(name) {     this.name = name;}Parent.prototype.sayName = function() {    console.log(&apos;parent name:&apos;, this.name);}function Child(name) {    this.name = name;}Child.prototype = new Parent(&apos;father&apos;);Child.prototype.constructor = Child;Child.prototype.sayName = function() {    console.log(&apos;child name:&apos;, this.name);}var child = new Child(&apos;son&apos;);child.sayName();    // child name: son</code></pre><p>只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。</p><p>这种方法存在两个缺点：</p><ol><li>子类型无法给超类型传递参数，在面向对象的继承中，我们总希望通过 var child = new Child(‘son’, ‘father’); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent(‘father’) 去调用父类。</li><li>Child.prototype.sayName 必须写在 Child.prototype = new Parent(‘father’); 之后，不然就会被覆盖掉。</li></ol><h2 id="二-类式继承："><a href="#二-类式继承：" class="headerlink" title="(二) 类式继承："></a>(二) 类式继承：</h2><pre><code>function Parent(name) {     this.name = name;}Parent.prototype.sayName = function() {    console.log(&apos;parent name:&apos;, this.name);}Parent.prototype.doSomthing = function() {    console.log(&apos;parent do something!&apos;);}function Child(name, parentName) {    Parent.call(this, parentName);    this.name = name;}Child.prototype.sayName = function() {    console.log(&apos;child name:&apos;, this.name);}var child = new Child(&apos;son&apos;);child.sayName();      // child name: sonchild.doSomthing();   // TypeError: child.doSomthing is not a function</code></pre><p>相当于 Parent 这个函数在 Child 函数中执行了一遍，并且将所有与 this 绑定的变量都切换到了 Child 上，这样就克服了第一种方式带来的问题。</p><p>缺点：</p><ol><li>没有原型，每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。</li></ol><h2 id="三-组合式继承：前两种方式的结合"><a href="#三-组合式继承：前两种方式的结合" class="headerlink" title="(三) 组合式继承：前两种方式的结合"></a>(三) 组合式继承：前两种方式的结合</h2><pre><code>function Parent(name) {     this.name = name;}Parent.prototype.sayName = function() {    console.log(&apos;parent name:&apos;, this.name);}Parent.prototype.doSomething = function() {    console.log(&apos;parent do something!&apos;);}function Child(name, parentName) {    Parent.call(this, parentName);    this.name = name;}Child.prototype.sayName = function() {    console.log(&apos;child name:&apos;, this.name);}Child.prototype = new Parent();      Child.prototype.construtor = Child;var child = new Child(&apos;son&apos;);child.sayName();       // child name: sonchild.doSomething();   // parent do something!</code></pre><p>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。</p><p>这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</p><p>组合式继承是 JS 最常用的继承模式，但组合继承使用过程中会被调用两次：一次是创建子类型的时候，另一次是在子类型构造函数的内部。</p><pre><code>function Parent(name) {     this.name = name;}Parent.prototype.sayName = function() {    console.log(&apos;parent name:&apos;, this.name);}Parent.prototype.doSomething = function() {    console.log(&apos;parent do something!&apos;);}function Child(name, parentName) {    Parent.call(this, parentName);      // 第二次调用    this.name = name;}Child.prototype.sayName = function() {    console.log(&apos;child name:&apos;, this.name);}Child.prototype = new Parent();         // 第一次调用Child.prototype.construtor = Child;var child = new Child(&apos;son&apos;);child.sayName();      child.doSomething();   </code></pre><p>显然从上述的代码中可以看出，第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了，所以这时候你可能会这样写：</p><pre><code>Child.prototype = Parent.prototype;</code></pre><p>这样写显然是不对的：</p><ol><li>首先，你这样写的话相当于是子类和父类都指向同一个对象，这时候如果你添加了新的方法给 Child 但实际上 Parent 并不需要，相当于强行给 Parent 添加了一个未知的方法。</li><li>其次，仔细想想，这样体现不出继承的多态性，比如此时子类想要重写父类的 getName 的方法，那么父类的方法也就会随之修改，这显然违背了多态性。</li></ol><p>也就是说我们第一次调用构造函数的时候，其实是不管构造函数里面的内容，所以我们何不 new 一个空函数，将其 prototype 指向 Parent.prototype，代码如下：</p><h2 id="四-寄生组合式继承："><a href="#四-寄生组合式继承：" class="headerlink" title="(四) 寄生组合式继承："></a>(四) 寄生组合式继承：</h2><pre><code>function Parent(name) {    this.name = name;}Parent.prototype.sayName = function() {    console.log(&apos;parent name:&apos;, this.name);}function Child(name, parentName) {    Parent.call(this, parentName);      this.name = name;    }function create(proto) {    function F(){}    F.prototype = proto;    F.prototype.construtor = F;    return new F();}Child.prototype = create(Parent.prototype);Child.prototype.sayName = function() {    console.log(&apos;child name:&apos;, this.name);}Child.prototype.construtor = Child;var parent = new Parent(&apos;father&apos;);parent.sayName();    // parent name: fathervar child = new Child(&apos;son&apos;, &apos;father&apos;);child.sayName();     // child name: son</code></pre><p>这就是所谓的寄生组合式继承方式，跟组合式继承的区别在于，他不需要在一次实例中调用两次父类的构造函数，假如说父类的构造器代码很多，还需要调用两次的话对系统肯定会有影响，寄生组合式继承的思想在于：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。</p><p>在上面的代码中，我们手动创建了一个 create 函数，但是其实是存在于 Object 对象中，不需要我们手动去创建，所以上面的代码可以改为：</p><pre><code>function Parent(name) {    this.name = name;}Parent.prototype.sayName = function() {    console.log(&apos;parent name:&apos;, this.name);}function Child(name, parentName) {    Parent.call(this, parentName);      this.name = name;    }function inheritPrototype(Parent, Child) {    Child.prototype = Object.create(Parent.prototype);   //修改    Child.prototype.construtor = Child;}inheritPrototype(Parent, Child);Child.prototype.sayName = function() {    console.log(&apos;child name:&apos;, this.name);}var parent = new Parent(&apos;father&apos;);parent.sayName();      // parent name: fathervar child = new Child(&apos;son&apos;, &apos;father&apos;);child.sayName();       // child name: son</code></pre><h2 id="五-ES-6-继承："><a href="#五-ES-6-继承：" class="headerlink" title="(五) ES 6 继承："></a>(五) ES 6 继承：</h2><p>当然，如果你学习过 ES 6，那么写继承关系就会特别简单，如果你学过 Java 就会发现，ES 6 中的继承跟 Java 太像了，上述的代码可改为：</p><pre><code>class Parent {    constructor(name) {    this.name = name;    }    doSomething() {    console.log(&apos;parent do something!&apos;);    }    sayName() {    console.log(&apos;parent name:&apos;, this.name);    }}class Child extends Parent {    constructor(name, parentName) {    super(parentName);    this.name = name;    }    sayName() {     console.log(&apos;child name:&apos;, this.name);    }}const child = new Child(&apos;son&apos;, &apos;father&apos;);child.sayName();            // child name: sonchild.doSomething();        // parent do something!const parent = new Parent(&apos;father&apos;);parent.sayName();           // parent name: father</code></pre><p>JavaScript前端开发</p><p>JavaScript(ES5)中没有像Java那样类的概念，写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。但是我们可以通过原型链prototype来模拟类，去实现继承的相关功能。下面来看看ES5中实现继承常见的三种方法。代码如下：</p><pre><code>/** * JavaScript(ES5)中实现继承的几种方法 */// 定义基类Personfunction Person(name, age) {  this.name = name;  this.age = age;}// 共享数据Person.prototype.LEGS_NUM = 2;// 共享方法Person.prototype.info = function () {  console.log(&apos;My name is &apos; + this.name + &apos; .I\&apos;m &apos; + this.age + &apos; years old now&apos;);};Person.prototype.walk = function () {  console.log(this.name + &apos; is walking...&apos;);};// Student子类function Student(name, age, className) {  // 调用父类  Person.call(this, name, age);  this.className = className;}// 1⃣️ 方法一：Person.prototype直接赋值给Student.prototype// Student.prototype = Person.prototype;// 2⃣️ 方法二：Student.prototype为Person的实例// Student.prototype = new Person();// 3⃣️ 方法三：创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototypeStudent.prototype = Object.create(Person.prototype);Student.prototype.constructor = Student;// 覆盖父类的info方法Student.prototype.info = function () {  console.log(&apos;My name is &apos; + this.name + &apos;,I\&apos;m &apos; + this.age + &apos; years old now, and from class &apos; + this.className + &apos;.&apos;);};// Student类的共享方法Student.prototype.learn = function (subject) {  console.log(this.name + &apos; is learning &apos; + subject + &apos;.&apos;);};// 测试,创建一个Student的实例var microzz = new Student(&apos;Microzz&apos;, 22, 5);microzz.info(); // My name is Microzz,I&apos;m 22 years old now, and from class 5.console.log(microzz.LEGS_NUM); // 2microzz.walk(); // Microzz is walking...microzz.learn(&apos;JavaScript&apos;); // Microzz is learning JavaScript.console.log(microzz.__proto__.__proto__ === Person.prototype); // trueconsole.log(microzz.__proto__ === Student.prototype); // trueconsole.log(microzz.__proto__.constructor === Student); // true</code></pre><p>三种方法比较</p><p>上面代码中有三种方法实现继承，现在我们可以来分析一下这几种方法。<br>这种方法中，Person.prototype直接赋值给Student.prototype，但是有一个很严重的问题，如果子类prototype添加新的东西的话也会改写父类。所以这种方法不推荐。<br>第二种方法Student.prototype为Person的实例，这也是可以实现的。但是Person构造函数有参数应该传什么呢？传任何一个都是很奇怪的。所以也不推荐。<br>第三种方法是比较理想的，创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype。但是Object.create也有一点小瑕疵，因为它是ES5之后才支持的，不过我们可以通过模拟实现Object.create方法。代码如下：</p><pre><code>if (!Object.create) {  Object.prototype.create = function (proto) {    function F() {}    F.prototype = proto;    return new F;  }}</code></pre><p>这样在ES5中就完美实现了继承😄</p><h2 id="ES6中的实现"><a href="#ES6中的实现" class="headerlink" title="ES6中的实现"></a>ES6中的实现</h2><p>概述</p><p>ES6提供了更接近传统语言”类”的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。下面我们用ES6的语法实现类的继承。</p><p>代码</p><pre><code>// 基类 Personclass Person {  // 父类的构造方法  constructor(name, age) {    this.name = name;    this.age = age;    // 共享变量    this.LEGS_NUM = 2;  }  // 父类的info方法  info() {    console.log(`My name is ${this.name}, I\&apos;m ${this.age} years old now.`);  }  // 父类的walk方法  walk() {    console.log(this.name + &apos; is walking...&apos;);  }}// 子类 Studentclass Student extends Person {  constructor(name, age, className) {    // 调用基类的构造方法    super(name, age);    this.className = className;  }  // 覆盖父类的info方法  info() {    console.log(`My name is ${this.name}, I\&apos;m ${this.age} years old, and from class ${this.className}.`);  }}// 实例化一个Student的实例let stu = new Student(&apos;Zhaohui&apos;, 22, 5);stu.info(); // My name is Zhaohui, I&apos;m 22 years old, and from class 5.stu.walk(); // Zhaohui is walking...console.log(stu.LEGS_NUM); // 2console.log(stu instanceof Student); // trueconsole.log(stu instanceof Person); // true</code></pre><p>这样我们就通过ES6中的class实现了“类”的继承了</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Koa2使用koa-body实现文件上传(Node可读流可写流)</title>
      <link href="/2018/03/27/Koa2%E4%BD%BF%E7%94%A8koa-body%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2018/03/27/Koa2%E4%BD%BF%E7%94%A8koa-body%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="koa-body文件上传自定义文件夹及文件名称"><a href="#koa-body文件上传自定义文件夹及文件名称" class="headerlink" title="koa-body文件上传自定义文件夹及文件名称"></a><a href="http://www.ptbird.cn/koa-body-diy-upload-dir-and-filename.html" target="_blank" rel="noopener">koa-body文件上传自定义文件夹及文件名称</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">const Koa = require(&apos;koa&apos;),</span><br><span class="line">//bodyParser = require(&apos;koa-bodyparser&apos;),</span><br><span class="line">router = require(&apos;koa-router&apos;)(),</span><br><span class="line">stc = require(&apos;koa-static&apos;),</span><br><span class="line">render = require(&apos;koa-art-template&apos;),</span><br><span class="line">fs = require(&apos;fs&apos;),</span><br><span class="line">path = require(&apos;path&apos;);</span><br><span class="line">const koaBody = require(&apos;koa-body&apos;);</span><br><span class="line"></span><br><span class="line">//引入子模块</span><br><span class="line"></span><br><span class="line">var admin = require(&apos;./routes/admin.js&apos;);</span><br><span class="line">var api = require(&apos;./routes/api.js&apos;);</span><br><span class="line">var index = require(&apos;./routes/index.js&apos;);</span><br><span class="line"></span><br><span class="line">var app = new Koa();</span><br><span class="line">//配置koa-art-template 模板引擎</span><br><span class="line">render(app, &#123;</span><br><span class="line">root: path.join(__dirname, &apos;views&apos;),</span><br><span class="line">extname: &apos;.html&apos;,</span><br><span class="line">debug: process.env.NODE_ENV !== &apos;production&apos;,</span><br><span class="line">minimize: true,</span><br><span class="line">htmlMinifierOptions: &#123;</span><br><span class="line">collapseWhitespace: true,</span><br><span class="line">minifyCSS: true,</span><br><span class="line">minifyJS: true,</span><br><span class="line">// automatically merged at runtime: rules.map(rule =&gt; rule.test)</span><br><span class="line">ignoreCustomFragments: []</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//app.use(bodyParser());</span><br><span class="line">app.use(stc(</span><br><span class="line">path.join(__dirname, &apos;./statics&apos;)</span><br><span class="line">))</span><br><span class="line">app.use(stc(</span><br><span class="line">path.join(__dirname, &apos;./public&apos;)</span><br><span class="line">))</span><br><span class="line">//koaBody</span><br><span class="line">app.use(koaBody(&#123;</span><br><span class="line">multipart: true, // 支持文件上传</span><br><span class="line">encoding: &apos;gzip&apos;,</span><br><span class="line">formidable: &#123;</span><br><span class="line">uploadDir: path.join(__dirname, &apos;public/upload/&apos;), // 设置文件上传目录</span><br><span class="line">keepExtensions: true, // 保持文件的后缀</span><br><span class="line">maxFieldsSize: 2 * 1024 * 1024, // 文件上传大小</span><br><span class="line">onFileBegin: (name, file) =&gt; &#123; // 文件上传前的设置</span><br><span class="line">// console.log(`name: $&#123;name&#125;`);</span><br><span class="line">// console.log(file);</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;));</span><br><span class="line">//配置路由</span><br><span class="line">router.use(index);</span><br><span class="line">/*</span><br><span class="line">  /admin   配置子路由  层级路由</span><br><span class="line"></span><br><span class="line"> /admin/user</span><br><span class="line"> */</span><br><span class="line">router.use(&apos;/admin&apos;, admin);</span><br><span class="line">/*</span><br><span class="line"> /api/newslist   新闻列表的api</span><br><span class="line"> */</span><br><span class="line">router.use(&apos;/api&apos;, api); /*在模块里面暴露路由并且启动路由*/</span><br><span class="line"></span><br><span class="line">router.post(&apos;/getData&apos;, async(ctx, next) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">let request = ctx.request;</span><br><span class="line">let req_query = request.query;</span><br><span class="line">let req_querystring = request.querystring;</span><br><span class="line">console.log(request, req_query, req_querystring);</span><br><span class="line">console.log(ctx.request.body)</span><br><span class="line">console.log(ctx.request.files);</span><br><span class="line"> </span><br><span class="line">ctx.cookies.set(</span><br><span class="line">&apos;MyName&apos;, &apos;Koa2&apos;, &#123;</span><br><span class="line">domain: &apos;127.0.0.1&apos;, // 写cookie所在的域名</span><br><span class="line">path: &apos;/&apos;, // 写cookie所在的路径</span><br><span class="line">maxAge: 1000 * 60 * 60 * 24, // cookie有效时长</span><br><span class="line">expires: new Date(&apos;2018-12-31&apos;), // cookie失效时间</span><br><span class="line">httpOnly: false, // 是否只用于http请求中获取</span><br><span class="line">overwrite: false // 是否允许重写</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">//ctx.status = 200</span><br><span class="line">return ctx.body = &#123;</span><br><span class="line">code: 200,</span><br><span class="line">data: &#123;</span><br><span class="line">arr: [1, 2, 3, 4]</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">router.post(&apos;/uploadPic&apos;, async(ctx, next) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">const file = ctx.request.files.file; // 上传的文件在ctx.request.files.file</span><br><span class="line">// 创建可读流</span><br><span class="line">const reader = fs.createReadStream(file.path);</span><br><span class="line">// 修改文件的名称</span><br><span class="line">var myDate = new Date();</span><br><span class="line">var newFilename = file.name.split(&apos;.&apos;)[0] + &apos;_&apos; + myDate.getTime() + &apos;.&apos; + file.name.split(&apos;.&apos;)[1];</span><br><span class="line">var targetPath = path.join(__dirname, &apos;./public/upload/&apos;) + `/$&#123;newFilename&#125;`;</span><br><span class="line">//创建可写流</span><br><span class="line">const upStream = fs.createWriteStream(targetPath);</span><br><span class="line">// 可读流通过管道写入可写流</span><br><span class="line">reader.pipe(upStream);</span><br><span class="line">//ctx.redirect(&apos;/&apos;)</span><br><span class="line">//返回保存的路径</span><br><span class="line">return ctx.body = &#123;</span><br><span class="line">code: 200,</span><br><span class="line">data: &#123;</span><br><span class="line">url: &apos;http://&apos; + ctx.headers.host + &apos;/upload/&apos; + newFilename</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//启动路由</span><br><span class="line">app.use(router.routes()).use(router.allowedMethods());</span><br><span class="line"></span><br><span class="line">app.listen(12300);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS前端错误监控与上报</title>
      <link href="/2018/02/21/JS%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E4%B8%8E%E4%B8%8A%E6%8A%A5/"/>
      <url>/2018/02/21/JS%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E4%B8%8E%E4%B8%8A%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="我们的目标是什么？"><a href="#我们的目标是什么？" class="headerlink" title="我们的目标是什么？"></a>我们的目标是什么？</h3><p>将用户在使用网页服务时产生的影响用户体验的异常通过网络请求传回服务器，并进行可视化的展现，整个过程要求我们回传的错误信息包含错误类型、调用堆栈等错误信息以便开发人员定位错误。</p><h3 id="需上报的错误类型有几种？"><a href="#需上报的错误类型有几种？" class="headerlink" title="需上报的错误类型有几种？"></a>需上报的错误类型有几种？</h3><ol><li>静态资源加载失败</li><li>AJAX请求失败</li><li>JavaScript异常<ul><li>运行时报错<ul><li>同步错误</li><li>异步错误</li></ul></li><li>语法错误</li></ul></li><li>promise异常</li></ol><h3 id="捕获错误有几种方式？"><a href="#捕获错误有几种方式？" class="headerlink" title="捕获错误有几种方式？"></a>捕获错误有几种方式？</h3><p>这里我总结了几种，分别是：</p><ul><li>onerror全局监听</li><li>addEventListener全局监听</li><li>try…catch主动捕获</li><li>promise…catch主动捕获</li><li>重写<code>XMLHttpRequest</code>对象方法</li><li>MVVM框架例如VUE和React中的官方错误处理方法</li></ul><p>下面分别介绍：</p><h4 id="try-catch"><a href="#try-catch" class="headerlink" title="try catch"></a>try catch</h4><p>使用方法大家应该都知道，使用try…catch可以主动的处理异常，养成在关键操作处写try…catch的习惯可以非常好的帮助后续判断线上遇到的各种异常。</p><p>这里需要指出try catch需要注意的几点：</p><ol><li><p>try-catch 只能捕获到同步的运行时错误，其他类型无法捕获</p><p><strong>解决方案：</strong> onerror都可以捕获到运行时的同步/异步错误</p></li></ol><h4 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h4><blockquote><p>当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的error事件，并执行window.onerror()。</p></blockquote><p>window.error可以用于全局捕获JavaScript产生的错误，使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) </span>&#123; </span><br><span class="line">   <span class="comment">// message：错误信息（字符串）。</span></span><br><span class="line">   <span class="comment">// source：发生错误的脚本URL（字符串）</span></span><br><span class="line">   <span class="comment">// lineno：发生错误的行号（数字）</span></span><br><span class="line">   <span class="comment">// colno：发生错误的列号（数字）</span></span><br><span class="line">   <span class="comment">// error：Error对象（对象）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是使用时需要注意几点：</p><ol><li><p><strong>Script Error</strong> </p><p>在单页面应用中，当我们使用script标签引入了JS文件，当该JS文件的来源域名和网页的域名不同时，这时如果该JS文件内部报错，则我们只能捕获到Script Error，而不是详细的错误信息，这是由于浏览器的跨域限制。</p><p><strong>解决方案：</strong></p><ul><li>需要在跨域的script标签中加入<code>crossorigin</code>属性，例如<code>&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot; crossorigin&gt;&lt;/script&gt;</code></li><li>需要给跨域资源的服务器的response header设置允许跨域：<code>Access-Control-Allow-Origin:*</code></li></ul></li><li><p>不能全局捕获到资源（如图片或脚本）的加载失败</p><p><strong>解决方案：</strong> 使用<code>window.addEventListener</code>捕获。</p></li><li><p>onerror无法捕获语法错误</p></li><li><p>onerror最好写在所有 JS 脚本的前面，否则有可能捕获不到错误</p></li></ol><h4 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener"></a>addEventListener</h4><blockquote><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，不过（至少在Firefox中）能被单一的window.addEventListener捕获。</p></blockquote><p>使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'error'</span>, (error) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><code>window.addEventListener</code>在运行时错误和资源加载错误时返回的错误对象不同，可以参考下面两图：</p><p>运行时错误：</p><p><img src="/2018/02/21/JS前端错误监控与上报/1.jpg" alt=""></p><p>资源加载错误：</p><p><img src="/2018/02/21/JS前端错误监控与上报/2.jpg" alt=""></p><p>使用时需要注意的点：</p><ol><li>不同浏览器下返回的error对象可能不同，需要注意兼容处理。</li><li>需要注意避免addEventListener重复监听。</li></ol><h4 id="promise-catch"><a href="#promise-catch" class="headerlink" title="promise catch"></a>promise catch</h4><p>在promise中使用catch可以非常方便的捕获到异步error，使用方法大家也应该都了解了。</p><p>这里说一下需要注意的点:</p><p>没有写catch的Promise中抛出的错误无法被onerror 或 try-catch捕获到，所以我们务必要在Promise中不要忘记写catch处理抛出的异常。</p><p>   <strong>解决方案：</strong> 为了防止有漏掉的Promise异常，建议在全局增加一个对<code>unhandledrejection</code>的监听，用来全局监听Uncaught Promise Error。使用方式：</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"unhandledrejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; </span><br><span class="line"><span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="重写XMLHttpRequest对象的方法"><a href="#重写XMLHttpRequest对象的方法" class="headerlink" title="重写XMLHttpRequest对象的方法"></a>重写<code>XMLHttpRequest</code>对象的方法</h4><p>该方法主要针对AJAX请求异常,附上参考代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 open</span></span><br><span class="line">        XMLHttpRequest.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 先在此处取得请求的url、method</span></span><br><span class="line">            _self.reqUrl = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">            _self.reqMethod = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 在调用原生 open 实现重写</span></span><br><span class="line">            _self.xhrOpen.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重写 send</span></span><br><span class="line">        XMLHttpRequest.prototype.send = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 记录xhr</span></span><br><span class="line">            <span class="keyword">var</span> xhrmsg = &#123;</span><br><span class="line">                <span class="string">'url'</span>: _self.reqUrl,</span><br><span class="line">                <span class="string">'type'</span>: _self.reqMethod,</span><br><span class="line">                <span class="comment">// 此处可以取得 ajax 的请求参数</span></span><br><span class="line">                <span class="string">'data'</span>: <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.addEventListener(<span class="string">'readystatechange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="comment">// 此处可以取得一些响应信息</span></span><br><span class="line">                    <span class="comment">// 响应信息</span></span><br><span class="line">                    xhrmsg[<span class="string">'res'</span>] = <span class="keyword">this</span>.response;</span><br><span class="line">                    xhrmsg[<span class="string">'status'</span>] = <span class="keyword">this</span>.status;</span><br><span class="line">                    <span class="keyword">this</span>.status &gt;= <span class="number">200</span> &amp;&amp; <span class="keyword">this</span>.status &lt; <span class="number">400</span> ?</span><br><span class="line">                        xhrmsg[<span class="string">'level'</span>] = <span class="string">'success'</span> : xhrmsg[<span class="string">'level'</span>] = <span class="string">'error'</span>;</span><br><span class="line">                    xhrArray.push(xhrmsg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            _self.xhrSend.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="MVVM框架提供的错误处理钩子"><a href="#MVVM框架提供的错误处理钩子" class="headerlink" title="MVVM框架提供的错误处理钩子"></a>MVVM框架提供的错误处理钩子</h4><p>VUE和React都分别提供了对应的错误处理钩子，由于笔者使用VUE多一些，这里介绍一下VUE的错误处理：</p><p><strong>VUE官方文档介绍：</strong></p><blockquote><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p><p> 从 2.2.0 起，这个钩子也会捕获组件生命周期钩子里的错误。同样的，当这个钩子是 <code>undefined</code> 时，被捕获的错误会通过 <code>console.error</code> 输出而避免应用崩溃。</p><p> 从 2.4.0 起这个钩子也会捕获 Vue 自定义事件处理函数内部的错误了。</p></blockquote><p>下面我们看一下实际情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div @click=<span class="string">"clickerror"</span>&gt;error&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="keyword">this</span>.mounterror();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    mounterror() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"抛出mount错误"</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    clickerror() &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"抛出click错误"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = <span class="function">(<span class="params">err, vm, info</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'通过vue errorHandler捕获的错误'</span>);</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">  <span class="built_in">console</span>.error(vm);</span><br><span class="line">  <span class="built_in">console</span>.error(info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/02/21/JS前端错误监控与上报/3.jpg" alt=""></p><p>可以看到生命周期钩子里的错误是可以被errorHandler捕获到，但是当我们主动点击div触发clickerror时，会发现这时错误并没有被errorHandler捕获到，控制台输出的是Uncaught Error，也就是没有被捕获到的错误，所以需要注意的是，errorHandler方法目前还捕获不到绑定监听事件触发的异常，但是可以捕获到在生命周期钩子中调用的方法的错误。</p><blockquote><p>在React中，可以使用ErrorBoundary组件包括业务组件的方式进行异常捕获，配合React 16.0+新出的componentDidCatch API，可以实现统一的异常捕获和日志上报。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    // Display fallback UI</span><br><span class="line">    this.setState(&#123; hasError: true &#125;);</span><br><span class="line">    // You can also log the error to an error reporting service</span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      // You can render any custom fallback UI</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用方式如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ErrorBoundary&gt;</span><br><span class="line">  &lt;MyWidget /&gt;</span><br><span class="line">&lt;/ErrorBoundary&gt;</span><br></pre></td></tr></table></figure><p><strong>解决方案</strong> ：使用window.onerror</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">message, source, lineno, colno, error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'通过onerror捕获到的错误'</span>);</span><br><span class="line">  <span class="built_in">console</span>.error(message);</span><br><span class="line">  <span class="built_in">console</span>.error(source);</span><br><span class="line">  <span class="built_in">console</span>.error(lineno);</span><br><span class="line">  <span class="built_in">console</span>.error(colno);</span><br><span class="line">  <span class="built_in">console</span>.error(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MVVM框架中使用onerror监听全局异常会发现并不能捕获到绑定事件的详细错误信息，只会输出Script Error，</p><p><img src="/2018/02/21/JS前端错误监控与上报/4.jpg" alt=""></p><p>这时我们可以尝试进入webpack配置，设置<code>devtool:&quot;source-map&quot;</code>,这时在控制台再次打印可以看见成功捕获到绑定事件的错误。</p><p><img src="/2018/02/21/JS前端错误监控与上报/5.jpg" alt=""></p><h3 id="错误上报"><a href="#错误上报" class="headerlink" title="错误上报"></a>错误上报</h3><p>两种主流上报方式：</p><ol><li><p>通过Ajax发送数据</p><p>因为Ajax请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建img标签的形式进行上报。</p></li><li><p>动态创建 img 标签的形式</p></li></ol><p><code>new Image().src = reportUrl + &#39;?msg=&#39; + msg;</code></p><h3 id="前端性能与异常上报"><a href="#前端性能与异常上报" class="headerlink" title="前端性能与异常上报"></a><a href="https://github.com/xingbofeng/xingbofeng.github.io/issues/36" target="_blank" rel="noopener">前端性能与异常上报</a></h3><h3 id="前端性能监控：window-performance"><a href="#前端性能监控：window-performance" class="headerlink" title="前端性能监控：window.performance"></a><a href="https://libin1991.github.io/2016/04/23/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%9Awindow-performance/" target="_blank" rel="noopener">前端性能监控：window.performance</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> 错误监控 </tag>
            
            <tag> 上报 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我也来实现一把MVVM</title>
      <link href="/2018/02/03/%E6%88%91%E4%B9%9F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%8A%8AMVVM/"/>
      <url>/2018/02/03/%E6%88%91%E4%B9%9F%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%8A%8AMVVM/</url>
      
        <content type="html"><![CDATA[<p>大家都知道，vue是个MVVM框架，能够实现view和model的双向绑定，不像backbone那样，model改变需要手动去通知view更新，而vue实现的原理就是通过Object.defineProperty实现数据挟持，定义setter，然后数据改变的时候通知视图更新。</p><p>下面是网上vue的实现原理图：</p><p> <img src="https://user-gold-cdn.xitu.io/2018/4/10/162ad3d5be3e5105?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image"></p><h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653b294cd1b80e3?imageslim" alt=""></p><h4 id="1、MVVM"><a href="#1、MVVM" class="headerlink" title="1、MVVM"></a>1、MVVM</h4><p>入口文件，在这里对vue当中的$el、methods、$data进行初始化，调用observer遍历$data的数据并进行挟持，调用compile遍历$el下的所有节点，解析指令和取值操作。遍历$data的数据，通过Object.defineProperty的getter和setter实现对$data的代理。</p><h4 id="2、Observer"><a href="#2、Observer" class="headerlink" title="2、Observer"></a>2、Observer</h4><p>遍历data，通过Object.defineProperty设置getter和setter，在setter知道数据发生了改变，然后通知Wacher去更新view。</p><h4 id="3、Compile"><a href="#3、Compile" class="headerlink" title="3、Compile"></a>3、Compile</h4><p>遍历$el下的所有节点，解析指令和取值操作等，为每个节点绑定更新函数（为什么在compile这里绑定呢？因为这里刚好是遍历的节点☺），绑定事件和method的关系，同时也添加订阅者，当接受到视图更新的订阅消息后，调用更新函数，实现视图更新。同时在添加订阅者的时候，初始化渲染视图。</p><h4 id="4、Watcher"><a href="#4、Watcher" class="headerlink" title="4、Watcher"></a>4、Watcher</h4><p>Watcher作为订阅者，充当Observer和Compile的中间桥梁，包含update方法，update方法调用Compile中绑定的事件更新函数，实现对视图的初始化和更新操作。</p><h3 id="MVVM的实现"><a href="#MVVM的实现" class="headerlink" title="MVVM的实现"></a>MVVM的实现</h3><p>MVVM完成初始化操作，并且调用observer和compile。对$data进行代理，如此便可以通过this.attribute来代理this.$data.attribute。因为一个属性可能对应多个指令，所以需要一个_binding属性来存放属性对应的所有订阅者，这样属性一改变，就可以取出所有的订阅者去更新视图。</p><pre><code>function MVVM(options) {  // 初始化  this.$data = options.data;  this.$methods = options.methods;  this.$el = options.el;  // 保存data的每个属性对应的所有watcher  this._binding  = {};  // 调用observer和compile  this._observer(options.data);  this._compile();  // this.xxx 代理this.$data.xxx  this.proxyAttribute();}</code></pre><h3 id="Observer的实现"><a href="#Observer的实现" class="headerlink" title="Observer的实现"></a>Observer的实现</h3><p>Observer遍历$data，通过Object.defineProperty的setter的挟持数据改变，监听到数据改变后取出所有该属性对应的订阅者，然后通知更新函数更新视图。</p><p>注意：这里有循环，且闭包（getter和setter）里面需要依赖循环项（value和key），所以用立即执行函数解决循环项获取不对的问题。</p><pre><code>MVVM.prototype._observer = function(data) {  var self = this;  for(var key in this.$data) {    if (this.$data.hasOwnProperty(key)) {      // 初始化属性对应的订阅者容器（数组）      this._binding[key] = {        _directives: [],        _texts: []      };      if(typeof this.$data[key] === &quot;object&quot;) {        return this._observer(this.$data[key]);      }      var val = data[key];      // 立即执行函数获取正确的循环项      (function(value, key) {        Object.defineProperty(self.$data, key, {          enumerable: true,          configurable: true,          get: function() {            return value;          },          set(newval) {            if(newval === value) {              return;            }            value = newval;            // 监听到数据改变后取出所有该属性对应的订阅者，通知view更新-属性            if(self._binding[key]._directives) {              self._binding[key]._directives.forEach(function(watcher) {                watcher.update();              }, self);            }            // 监听到数据改变后取出所有该属性对应的订阅者，通知view更新-文本            if(self._binding[key]._texts) {              self._binding[key]._texts.forEach(function(watcher) {                watcher.update();              }, self);            }          }        });      })(val, key);    }  }}</code></pre><h3 id="Compile的实现"><a href="#Compile的实现" class="headerlink" title="Compile的实现"></a>Compile的实现</h3><p>Compile遍历所有的节点，解析指令，为每个节点绑定更新函数，且添加订阅者，当订阅者通知view更新的时候，调用更新函数，实现对视图的更新。</p><p>这里同样需要使用立即执行函数来解决闭包依赖的循环项问题。</p><p>还有一点需要解决的是，如果节点的innerText依赖多个属性的话，如何做到只替换改变属性对应的文本问题。</p><p>比如：已经被编译解析成“欢迎： 鸣人”，如果message改变为“你好”，怎么让使得“欢迎：鸣人”改为“你好：鸣人”。</p><pre><code>MVVM.prototype._compile = function() {  var dom = document.querySelector(this.$el);  var children = dom.children;  var self = this;  var i = 0, j = 0;  // 更新函数，但observer中model的数据改变的时候，通过Watcher的update调用更新函数，从而更新dom  var updater = null;  for(; i &lt; children.length; i++) {    var node = children[i];    (function(node) {      // 解析{{}}里面的内容      // 保存指令原始内容，不然数据更新时无法完成替换      var text = node.innerText;      var matches = text.match(/{{([^{}]+)}}/g);      if(matches &amp;&amp; matches.length &gt; 0) {        // 保存和node绑定的所有属性        node.bindingAttributes = [];        for(j = 0; j &lt; matches.length; j++) {          // data某个属性          var attr = matches[j].match(/{{([^{}]+)}}/)[1];          // 将和该node绑定的data属性保存起来          node.bindingAttributes.push(attr);          (function(attr) {            updater = function() {              // 改变的属性值对应的文本进行替换              var innerText = text.replace(new RegExp(&quot;{{" + attr + "}}&quot;, &quot;g&quot;), self.$data[attr]);              // 如果该node绑定多个属性 eg:&lt;div&gt;{{title}}{{description}}&lt;/div&gt;              for(var k = 0; k &lt; node.bindingAttributes.length; k++) {                if(node.bindingAttributes[k] !== attr) {                  // 恢复原来没改变的属性对应的文本                  innerText = innerText.replace(&quot;{{" + node.bindingAttributes[k] + "}}&quot;, self.$data[node.bindingAttributes[k]]);                }              }              node.innerText = innerText;            }            self._binding[attr]._texts.push(new Watcher(self, attr, updater));          })(attr);        }      }      // 解析vue指令      var attributes = node.getAttributeNames();      for(j = 0; j &lt; attributes.length; j++) {        // vue指令        var attribute = attributes[j];        // DOM attribute        var domAttr = null;        // 绑定的data属性        var vmDataAttr = node.getAttribute(attribute);        if(/v-bind:([^=]+)/.test(attribute)) {          // 解析v-bind          domAttr = RegExp.$1;          // 更新函数          updater = function(val) {            node[domAttr] = val;          }          // data属性绑定多个watcher          self._binding[vmDataAttr]._directives.push(            new Watcher(self, vmDataAttr, updater)          )        } elseif(attribute === &quot;v-model&quot; &amp;&amp; (node.tagName = &apos;INPUT&apos; || node.tagName == &apos;TEXTAREA&apos;)) {          // 解析v-model          // 更新函数          updater = function(val) {            node.value = val;          }          // data属性绑定多个watcher          self._binding[vmDataAttr]._directives.push(            new Watcher(self, vmDataAttr, updater)          )          // 监听input/textarea的数据变化，同步到model去，实现双向绑定          node.addEventListener(&quot;input&quot;, function(evt) {            var $el = evt.currentTarget;            self.$data[vmDataAttr] = $el.value;          });        } elseif(/v-on:([^=]+)/.test(attribute)) {          // 解析v-on          var event = RegExp.$1;          var method = vmDataAttr;          node.addEventListener(event, function(evt) {            self.$methods[method] &amp;&amp; self.$methods[method].call(self, evt);          });        }      }    })(node);  }}</code></pre><h3 id="Watcher的实现"><a href="#Watcher的实现" class="headerlink" title="Watcher的实现"></a>Watcher的实现</h3><p>Watcher充当订阅者的角色，架起了Observer和Compile的桥梁，Observer监听到数据变化后，通知Wathcer更新视图(调用Wathcer的update方法)，Watcher再告诉Compile去调用更新函数，实现dom的更新。同时页面的初始化渲染也交给了Watcher（当然也可以放到Compile进行）。</p><pre><code>function Watcher(vm, attr, cb) {  this.vm = vm; // viewmodel  this.attr = attr; // data的属性，一个watcher订阅一个data属性  this.cb = cb; // 更新函数，在compile那边定义  // 初始化渲染视图  this.update();}Watcher.prototype.update = function() {  // 通知comile中的更新函数更新dom   this.cb(this.vm.$data[this.attr]);}</code></pre><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><p>git地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FVikiLee%2FMVVM.git" target="_blank" rel="noopener">github.com/VikiLee/MVV…</a></p><p>鸣谢：<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5acc17cb51882555745a03f8" target="_blank" rel="noopener">juejin.im/post/5acc17…</a></p><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;view&quot;&gt;    &lt;div v-bind:id=&quot;id&quot;&gt;      {{message}}:{{name}}    &lt;/div&gt;    &lt;input type=&quot;text&quot; v-model=&quot;name&quot;/&gt;    &lt;button v-on:click=&quot;handleClick&quot;&gt;获取输入值&lt;/button&gt;  &lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;js/MVVM.js&quot;type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script&gt;  var vue = new MVVM({    el: &quot;#view&quot;,    data: {      message: &quot;欢迎光临&quot;,      name: &quot;鸣人&quot;,      id: &quot;id&quot;    },    methods: {      handleClick: function() {        alert(this.message + &quot;:&quot; + this.name + &quot;, 点击确定路飞会出来&quot;);        this.name = &apos;路飞&apos;;      }    }  })  setTimeout(function() {    vue.message = &quot;你好&quot;;  }, 1000);&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web 安全攻防总结</title>
      <link href="/2018/01/23/Web-%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/23/Web-%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>Web 安全的对于 Web 从业人员来说是一个非常重要的课题，所以在这里总结一下 Web 相关的安全攻防知识，希望以后不要再踩雷，也希望对看到这篇文章的同学有所帮助。今天这边文章主要的内容就是分析几种常见的攻击的类型以及防御的方法。</p><blockquote><p>也许你对所有的安全问题都有一定的认识，但最主要的还是在编码设计的过程中时刻绷紧安全那根弦，需要反复推敲每个实现细节，安全无小事。</p><p>本文代码 Demo 都是基于 Node.js 讲解，其他服务端语言同样可以参考。</p></blockquote><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>首先说下最常见的 XSS 漏洞，XSS (Cross Site Script)，跨站脚本攻击，因为缩写和 CSS (Cascading Style Sheets) 重叠，所以只能叫 XSS。</p><p>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。</p><h3 id="非持久型-XSS"><a href="#非持久型-XSS" class="headerlink" title="非持久型 XSS"></a>非持久型 XSS</h3><p>非持久型 XSS 漏洞，也叫反射型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br><img src="/2018/01/23/Web-安全攻防总结/xss1.jpg" alt="非持久型 XSS"><br>举一个例子，比如你的 Web 页面中包含有以下代码：</p><pre><code>&lt;select&gt;    &lt;script&gt;        document.write(&apos;&apos;                + &apos;&lt;optionvalue=1&gt;&apos;                +     location.href.substring(location.href.indexOf(&apos;default=&apos;) + 8)                + &apos;&lt;/option&gt;&apos;            );            document.write(&apos;&lt;optionvalue=2&gt;English&lt;/option&gt;&apos;);    &lt;/script&gt;&lt;/select&gt;</code></pre><p>攻击者可以直接通过 URL (类似： </p><pre><code>https://xx.com/xx?default=&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code></pre><p>注入可执行的脚本代码。</p><p>非持久型 XSS 漏洞攻击有以下几点<strong>特征</strong>：</p><ul><li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li><li>攻击者需要诱骗点击</li><li>反馈率低，所以较难发现和响应修复</li><li>盗取用户敏感保密信息</li></ul><p>为了<strong>防止出现非持久型 XSS 漏洞</strong>，需要确保这么几件事情：</p><ul><li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li><li>尽量不要从 URL，<code>document.referrer</code>，<code>document.forms</code> 等这种 DOM API 中获取数据直接渲染。</li><li>尽量不要使用 <code>eval</code>, <code>new Function()</code>，<code>document.write()</code>，<code>document.writeln()</code>，<code>window.setInterval()</code>，<code>window.setTimeout()</code>，<code>innerHTML</code>，<code>document.creteElement()</code> 等可执行字符串的方法。</li><li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li><li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li></ul><blockquote><p>escape 转义的目的是将一些构成 HTML 标签的元素转义，比如 <code>&lt;</code>，<code>&gt;</code>，<code>空格</code> 等，转义成 <code>&amp;lt;</code>，<code>&amp;gt;</code>，<code>&amp;nbsp;</code> 等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。</p></blockquote><h3 id="持久型-XSS"><a href="#持久型-XSS" class="headerlink" title="持久型 XSS"></a>持久型 XSS</h3><p>持久型 XSS 漏洞，也被称为存储型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如发帖留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。</p><p>主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，refferer，forms 等，而是来源于后端从数据库中读出来的数据。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。攻击成功需要同时满足以下几个条件：</p><ul><li>POST 请求提交表单后端没做转义直接入库。</li><li>后端从数据库中取出数据没做转义直接输出给前端。</li><li>前端拿到后端数据没做转义直接渲染成 DOM。</li></ul><p>持久型 XSS 有以下几个<strong>特点</strong>：</p><ul><li>持久性，植入在数据库中</li><li>危害面广，甚至可以让用户机器变成 DDoS 攻击的肉鸡。</li><li>盗取用户敏感私密信息</li></ul><p>为了<strong>防止持久型 XSS 漏洞</strong>，需要前后端共同努力：</p><ul><li>后端在入库前应该选择不相信任何前端数据，将所有的字段统一进行转义处理。</li><li>后端在输出给前端数据统一进行转义处理。</li><li>前端在渲染页面 DOM 的时候应该选择不相信任何后端数据，任何字段都需要做转义处理。</li></ul><h3 id="基于字符集的-XSS"><a href="#基于字符集的-XSS" class="headerlink" title="基于字符集的 XSS"></a>基于字符集的 XSS</h3><p>其实现在很多的浏览器以及各种开源的库都专门针对了 XSS 进行转义处理，尽量默认抵御绝大多数 XSS 攻击，但是还是有很多方式可以绕过转义规则，让人防不胜防。比如「基于字符集的 XSS 攻击」就是绕过这些转义处理的一种攻击方式，比如有些 Web 页面字符集不固定，用户输入非期望字符集的字符，有时会绕过转义过滤规则。</p><p>以基于 utf-7 的 XSS 为例</p><p>utf-7 是可以将所有的 unicode 通过 7bit 来表示的一种字符集 (但现在已经从 Unicode 规格中移除)。</p><p>这个字符集为了通过 7bit 来表示所有的文字, 除去数字和一部分的符号,其它的部分将都以 base64 编码为基础的方式呈现。</p><pre><code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;      可以被解释为：+ADw-script+AD4-alert(+ACI-xss+ACI-)+ADw-/script+AD4-</code></pre><p>可以形成「基于字符集的 XSS 攻击」的原因是由于浏览器在 meta 没有指定 charset 的时候有自动识别编码的机制，所以这类攻击通常就是发生在没有指定或者没来得及指定 meta 标签的 charset 的情况下。</p><p>所以我们有什么办法避免这种 XSS 呢？</p><ul><li>记住指定 <code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></li><li>XML 中不仅要指定字符集为 utf-8，而且标签要闭合</li><li>牛文推荐：<a href="http://drops.wooyun.org/papers/1327" target="_blank" rel="noopener">http://drops.wooyun.org/papers/1327</a> （这个讲的很详细）</li></ul><h3 id="基于-Flash-的跨站-XSS"><a href="#基于-Flash-的跨站-XSS" class="headerlink" title="基于 Flash 的跨站 XSS"></a>基于 Flash 的跨站 XSS</h3><p>基于 Flash 的跨站 XSS 也是属于反射型 XSS 的一种，虽然现在开发 ActionScript 的产品线几乎没有了，但还是提一句吧，AS 脚本可以接受用户输入并操作 cookie，攻击者可以配合其他 XSS（持久型或者非持久型）方法将恶意 swf 文件嵌入页面中。主要是因为 AS 有时候需要和 JS 传参交互，攻击者会通过恶意的 XSS 注入篡改参数，窃取并操作cookie。</p><p>避免方法：</p><ul><li>严格管理 cookie 的读写权限</li><li>对 Flash 能接受用户输入的参数进行过滤 escape 转义处理</li></ul><h3 id="未经验证的跳转-XSS"><a href="#未经验证的跳转-XSS" class="headerlink" title="未经验证的跳转 XSS"></a>未经验证的跳转 XSS</h3><p>有一些场景是后端需要对一个传进来的待跳转的 URL 参数进行一个 302 跳转，可能其中会带有一些用户的敏感（cookie）信息。如果服务器端做302 跳转，跳转的地址来自用户的输入，攻击者可以输入一个恶意的跳转地址来执行脚本。</p><p>这时候需要通过以下方式来防止这类漏洞：</p><ul><li>对待跳转的 URL 参数做白名单或者某种规则过滤</li><li>后端注意对敏感信息的保护, 比如 cookie 使用来源验证。</li></ul><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF（Cross-Site Request Forgery），中文名称：跨站请求伪造攻击</p><p>那么 CSRF 到底能够干嘛呢？你可以这样简单的理解：攻击者可以盗用你的登陆信息，以你的身份模拟发送各种请求。攻击者只要借助少许的社会工程学的诡计，例如通过 QQ 等聊天软件发送的链接(有些还伪装成短域名，用户无法分辨)，攻击者就能迫使 Web 应用的用户去执行攻击者预设的操作。例如，当用户登录网络银行去查看其存款余额，在他没有退出时，就点击了一个 QQ 好友发来的链接，那么该用户银行帐户中的资金就有可能被转移到攻击者指定的帐户中。</p><p>所以遇到 CSRF 攻击时，将对终端用户的数据和操作指令构成严重的威胁。当受攻击的终端用户具有管理员帐户的时候，CSRF 攻击将危及整个 Web 应用程序。</p><h3 id="CSRF-原理"><a href="#CSRF-原理" class="headerlink" title="CSRF 原理"></a>CSRF 原理</h3><p>下图大概描述了 CSRF 攻击的原理，可以理解为有一个小偷在你配钥匙的地方得到了你家的钥匙，然后拿着要是去你家想偷什么偷什么。<br><img src="/2018/01/23/Web-安全攻防总结/csrf.jpg" alt="csrf原理"><br>完成 CSRF 攻击必须要有三个条件：</p><ol><li>用户已经登录了站点 A，并在本地记录了 cookie</li><li>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。</li><li>站点 A 没有做任何 CSRF 防御</li></ol><p>你也许会问：「如果我不满足以上三个条件中的任意一个，就不会受到 CSRF 的攻击」。其实可以这么说的，但你不能保证以下情况不会发生：</p><ul><li>你不能保证你登录了一个网站后，不再打开一个 tab 页面并访问另外的网站，特别现在浏览器都是支持多 tab 的。</li><li>你不能保证你关闭浏览器了后，你本地的 cookie 立刻过期，你上次的会话已经结束。</li><li>上图中所谓的攻击网站 B，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</li></ul><h3 id="预防-CSRF"><a href="#预防-CSRF" class="headerlink" title="预防 CSRF"></a>预防 CSRF</h3><p>CSRF 的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的 CSRF 防御也都在服务端进行。服务端的预防 CSRF 攻击的方式方法有多种，但思路上都是差不多的，主要从以下两个方面入手：</p><ul><li>正确使用 GET，POST 请求和 cookie</li><li>在非 GET 请求中增加 token</li></ul><p>一般而言，普通的 Web 应用都是以 GET、POST 请求为主，还有一种请求是 cookie 方式。我们一般都是按照如下规则设计应用的请求：</p><ul><li>GET 请求常用在查看，列举，展示等不需要改变资源属性的时候（数据库 query 查询的时候）</li><li>POST 请求常用在 From 表单提交，改变一个资源的属性或者做其他一些事情的时候（数据库有 insert、update、delete 的时候）</li></ul><p>当正确的使用了 GET 和 POST 请求之后，剩下的就是在非 GET 方式的请求中增加随机数，这个大概有三种方式来进行：</p><ul><li><p><strong>为每个用户生成一个唯一的 cookie token</strong>，所有表单都包含同一个伪随机值，这种方案最简单，因为攻击者不能获得第三方的 cookie(理论上)，所以表单中的数据也就构造失败，但是由于用户的 cookie 很容易由于网站的 XSS 漏洞而被盗取，所以这个方案必须要在没有 XSS 的情况下才安全。</p></li><li><p><strong>每个 POST 请求使用验证码</strong>，这个方案算是比较完美的，但是需要用户多次输入验证码，用户体验比较差，所以不适合在业务中大量运用。</p></li><li><p><strong>渲染表单的时候，为每一个表单包含一个 csrfToken</strong>，提交表单的时候，带上 csrfToken，然后在后端做 csrfToken 验证。</p></li></ul><p>CSRF 的防御可以根据应用场景的不同自行选择。CSRF 的防御工作确实会在正常业务逻辑的基础上带来很多额外的开发量，但是这种工作量是值得的，毕竟用户隐私以及财产安全是产品最基础的根本。</p><h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>SQL 注入漏洞（SQL Injection）是 Web 开发中最常见的一种安全漏洞。可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作，甚至有可能获取数据库乃至系统用户最高权限。</p><p>而造成 SQL 注入的原因是因为程序没有有效的转义过滤用户的输入，使攻击者成功的向服务器提交恶意的 SQL 查询代码，程序在接收后错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变，额外的执行了攻击者精心构造的恶意代码。</p><p>很多 Web 开发者没有意识到 SQL 查询是可以被篡改的，从而把 SQL 查询当作可信任的命令。殊不知，SQL 查询是可以绕开访问控制，从而绕过身份验证和权限检查的。更有甚者，有可能通过 SQL 查询去运行主机系统级的命令。</p><h3 id="SQL-注入原理"><a href="#SQL-注入原理" class="headerlink" title="SQL 注入原理"></a>SQL 注入原理</h3><p>下面将通过一些真实的例子来详细讲解 SQL 注入的方式的原理。</p><p>考虑以下简单的管理员登录表单：</p><pre><code>&lt;formaction=&quot;/login&quot;method=&quot;POST&quot;&gt;&lt;p&gt;Username: &lt;inputtype=&quot;text&quot;name=&quot;username&quot; /&gt;&lt;/p&gt;&lt;p&gt;Password: &lt;inputtype=&quot;password&quot;name=&quot;password&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;inputtype=&quot;submit&quot;value=&quot;登陆&quot; /&gt;&lt;/p&gt;&lt;/form&gt;</code></pre><p>后端的 SQL 语句可能是如下这样的：</p><pre><code>let querySQL = `    SELECT *    FROM user    WHERE username=&apos;${username}&apos;    AND psw=&apos;${password}&apos;`;// 接下来就是执行 sql 语句...</code></pre><p>目的就是来验证用户名和密码是不是正确，按理说乍一看上面的 SQL 语句也没什么毛病，确实是能够达到我们的目的，可是你只是站在用户会老老实实按照你的设计来输入的角度来看问题，如果有一个恶意攻击者输入的用户名是 <code>zoumiaojiang&#39; OR 1 = 1 --</code>，密码随意输入，就可以直接登入系统了。WFT!</p><p>冷静下来思考一下，我们之前预想的真实 SQL 语句是:</p><pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;AND psw=&apos;mypassword&apos;</code></pre><p>可以恶意攻击者的奇怪用户名将你的 SQL 语句变成了如下形式：</p><pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1--&apos; AND psw=&apos;xxxx&apos;</code></pre><p>在 SQL 中，<code>--</code> 是注释后面的内容的意思，所以查询语句就变成了：</p><pre><code>SELECT * FROMuserWHERE username=&apos;zoumiaojiang&apos;OR1 = 1</code></pre><p>这条 SQL 语句的查询条件永远为真，所以意思就是恶意攻击者不用我的密码，就可以登录进我的账号，然后可以在里面为所欲为，然而这还只是最简单的注入，牛逼的 SQL 注入高手甚至可以通过 SQL 查询去运行主机系统级的命令，将你主机里的内容一览无余，这里我也没有这个能力讲解的太深入，毕竟不是专业研究这类攻击的，但是通过以上的例子，已经了解了 SQL 注入的原理，我们基本已经能找到防御 SQL 注入的方案了。</p><h3 id="如何预防-SQL-注入"><a href="#如何预防-SQL-注入" class="headerlink" title="如何预防 SQL 注入"></a>如何预防 SQL 注入</h3><p>防止 SQL 注入主要是不能允许用户输入的内容影响正常的 SQL 语句的逻辑，当用户的输入的信息将要用来拼接 SQL 语句的话，我们应该永远选择不相信，任何内容都必须进行转义过滤，当然做到这个还是不够的，下面列出防御 SQL 注入的几点注意事项：</p><ul><li><p><strong>严格限制Web应用的数据库的操作权限</strong>，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p></li><li><p><strong>后端代码检查输入的数据是否符合预期</strong>，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p></li><li><p><strong>对进入数据库的特殊字符（<code>&#39;</code>，<code>&quot;</code>，<code>\</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&amp;</code>，<code>*</code>，<code>;</code> 等）进行转义处理</strong>，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 <code>lodash._escapehtmlchar</code> 库。</p></li><li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口</strong>，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 <code>query</code> 方法中的 <code>?</code> 占位参数。</p></li></ul><pre><code>mysql.query(`SELECT * FROM user WHERE username = ? AND psw = ?`, [username, psw]);</code></pre><ul><li><p><strong>在应用发布之前建议使用专业的 SQL 注入检测工具进行检测</strong>，以及时修补被发现的 SQL 注入漏洞。网上有很多这方面的开源工具，例如 sqlmap、SQLninja 等。</p></li><li><p><strong>避免网站打印出 SQL 错误信息</strong>，比如类型错误、字段不匹配等，把代码里的 SQL 语句暴露出来，以防止攻击者利用这些错误信息进行 SQL 注入。</p></li><li><p><strong>不要过于细化返回的错误信息</strong>，如果目的是方便调试，就去使用后端日志，不要在接口上过多的暴露出错信息，毕竟真正的用户不关心太多的技术细节，只要话术合理就行。</p></li></ul><p>碰到要操作的数据库的代码，一定要慎重，小心使得万年船，多找几个人多来几次 code review，将问题都暴露出来，而且要善于利用工具，操作数据库相关的代码属于机密，没事不要去各种论坛晒自家站点的 SQL 语句，万一被人盯上了呢？</p><h2 id="命令行注入"><a href="#命令行注入" class="headerlink" title="命令行注入"></a>命令行注入</h2><p>命令行注入漏洞，指的是攻击者能够通过 HTTP 请求直接侵入主机，执行攻击者预设的 shell 命令，听起来好像匪夷所思，这往往是 Web 开发者最容易忽视但是却是最危险的一个漏洞之一，看一个实例：</p><p>假如现在需要实现一个需求：用户提交一些内容到服务器，然后在服务器执行一些系统命令去产出一个结果返回给用户，接口的部分实现如下：</p><pre><code>// 以 Node.js 为例，假如在接口中需要从 github 下载用户指定的 repoconst exec = require(&apos;mz/child_process&apos;).exec;let params = {/* 用户输入的参数 */};exec(`git clone ${params.repo} /some/path`);</code></pre><p>这段代码确实能够满足业务需求，正常的用户也确实能从指定的 git repo 上下载到想要的代码，可是和 SQL 注入一样，这段代码在恶意攻击者眼中，简直就是香饽饽。</p><p>如果 <code>params.repo</code> 传入的是 <code>https://github.com/zoumiaojiang/zoumiaojiang.github.io.git</code> 当然没问题了。</p><p>可是如果 <code>params.repo</code> 传入的是 <code>https://github.com/xx/xx.git &amp;&amp; rm -rf /* &amp;&amp;</code> 恰好你的服务是用 root 权限起的就惨了。</p><p>具体恶意攻击者能用命令行注入干什么也像 SQL 注入一样，手法是千变万化的，比如「<a href="http://wiki.bash-hackers.org/howto/redirection_tutorial" target="_blank" rel="noopener">反弹 shell 注入</a>」等，但原理都是一样的，我们绝对有能力防止命令行注入发生。防止命令行注入需要做到以下几件事情：</p><ul><li>后端对前端提交内容需要完全选择不相信，并且对其进行规则限制（比如正则表达式）。</li><li>在调用系统命令前对所有传入参数进行命令行参数转义过滤。</li><li>不要直接拼接命令语句，借助一些工具做拼接、转义预处理，例如 Node.js 的 <code>shell-escape</code> npm 包。</li></ul><p>还是前面的例子，我们可以做到如下：</p><pre><code>const exec = require(&apos;mz/child_process&apos;).exec;// 借助 shell-escape npm 包解决参数转义过滤问题const shellescape = require(&apos;shell-escape&apos;);let params = {/* 用户输入的参数 */};// 先过滤一下参数，让参数符合预期if (!/正确的表达式/.test(params.repo)) {return;}let cmd = shellescape([&apos;git&apos;,&apos;clone&apos;,    params.repo,&apos;/some/path&apos;]);// cmd 的值: git clone &apos;https://github.com/xx/xx.git &amp;&amp; rm -rf / &amp;&amp;&apos; /some/path// 这样就不会被注入成功了。exec(cmd);</code></pre><blockquote><p>无论是在何种后端语言环境中，凡是涉及到代码调用系统 shell 命令的时候都一定要谨慎。</p></blockquote><h2 id="DDoS-攻击"><a href="#DDoS-攻击" class="headerlink" title="DDoS 攻击"></a>DDoS 攻击</h2><p>DDoS 又叫分布式拒绝服务，全称 Distributed Denial of Service，其原理就是利用大量的请求造成资源过载，导致服务不可用，这个攻击应该不能算是安全问题，这应该算是一个另类的存在，因为这种攻击根本就是耍流氓的存在，「伤敌一千，自损八百」的行为。出于保护 Web App 不受攻击的攻防角度，还是介绍一下 DDoS 攻击吧，毕竟也是挺常见的。</p><p>DDoS 攻击可以理解为：「你开了一家店，隔壁家点看不惯，就雇了一大堆黑社会人员进你店里干坐着，也不消费，其他客人也进不来，导致你营业惨淡」。为啥说 DDoS 是个「伤敌一千，自损八百」的行为呢？毕竟隔壁店还是花了不少钱雇黑社会但是啥也没得到不是？DDoS 攻击的目的基本上就以下几个：</p><ul><li>深仇大恨，就是要干死你</li><li>敲诈你，不给钱就干你</li><li>忽悠你，不买我防火墙服务就会有“人”继续干你</li></ul><p>也许你的站点遭受过 DDoS 攻击，具体什么原因怎么解读见仁见智。DDos 攻击从层次上可分为网络层攻击与应用层攻击，从攻击手法上可分为快型流量攻击与慢型流量攻击，但其原理都是造成资源过载，导致服务不可用。</p><h3 id="网络层-DDoS"><a href="#网络层-DDoS" class="headerlink" title="网络层 DDoS"></a>网络层 DDoS</h3><p>网络层 DDos 攻击包括 <code>SYN Flood</code>、<code>ACK Flood</code>、<code>UDP Flood</code>、<code>ICMP Flood</code> 等。</p><p><strong>SYN Flood 攻击</strong></p><p>SYN flood 攻击主要利用了 TCP 三次握手过程中的 Bug，我们都知道 TCP 三次握手过程是要建立连接的双方发送 SYN，SYN + ACK，ACK 数据包，而当攻击方随意构造源 IP 去发送 SYN 包时，服务器返回的 SYN + ACK 就不能得到应答（因为 IP 是随意构造的），此时服务器就会尝试重新发送，并且会有至少 30s 的等待时间，导致资源饱和服务不可用，此攻击属于慢型 DDoS 攻击。</p><p><strong>ACK Flood 攻击</strong></p><p>ACK Flood 攻击是在 TCP 连接建立之后，所有的数据传输 TCP 报文都是带有 ACK 标志位的，主机在接收到一个带有 ACK 标志位的数据包的时候，需要检查该数据包所表示的连接四元组是否存在，如果存在则检查该数据包所表示的状态是否合法，然后再向应用层传递该数据包。如果在检查中发现该数据包不合法，例如该数据包所指向的目的端口在本机并未开放，则主机操作系统协议栈会回应 RST 包告诉对方此端口不存在。</p><p><strong>UDP Flood 攻击</strong></p><p>UDP flood 攻击是由于 UDP 是一种无连接的协议，因此攻击者可以伪造大量的源 IP 地址去发送 UDP 包，此种攻击属于大流量攻击。正常应用情况下，UDP 包双向流量会基本相等，因此发起这种攻击的攻击者在消耗对方资源的时候也在消耗自己的资源。</p><p><strong>ICMP Flood 攻击</strong></p><p>ICMP Flood 攻击属于大流量攻击，其原理就是不断发送不正常的 ICMP 包（所谓不正常就是 ICMP 包内容很大），导致目标带宽被占用，但其本身资源也会被消耗。目前很多服务器都是禁 ping 的（在防火墙在可以屏蔽 ICMP 包），因此这种攻击方式已经落伍。</p><h3 id="网络层-DDoS-防御"><a href="#网络层-DDoS-防御" class="headerlink" title="网络层 DDoS 防御"></a>网络层 DDoS 防御</h3><p>网络层的 DDoS 攻击究其本质其实是无法防御的，我们能做得就是不断优化服务本身部署的网络架构，以及提升网络带宽。当然，还是做好以下几件事也是有助于缓解网络层 DDoS 攻击的冲击：</p><ul><li>网络架构上做好优化，采用负载均衡分流。</li><li>确保服务器的系统文件是最新的版本，并及时更新系统补丁。</li><li>添加抗 DDos 设备，进行流量清洗。</li><li>限制同时打开的 SYN 半连接数目，缩短 SYN 半连接的 Timeout 时间。</li><li>限制单 IP 请求频率。</li><li>防火墙等防护设置禁止 ICMP 包等。</li><li>严格限制对外开放的服务器的向外访问。</li><li>运行端口映射程序或端口扫描程序，要认真检查特权端口和非特权端口。</li><li>关闭不必要的服务。</li><li>认真检查网络设备和主机/服务器系统的日志。只要日志出现漏洞或是时间变更,那这台机器就可能遭到了攻击。</li><li>限制在防火墙外与网络文件共享。这样会给黑客截取系统文件的机会，主机的信息暴露给黑客，无疑是给了对方入侵的机会。</li><li>加钱堆机器。。</li><li>报警。。</li></ul><h3 id="应用层-DDoS"><a href="#应用层-DDoS" class="headerlink" title="应用层 DDoS"></a>应用层 DDoS</h3><p>应用层 DDoS 攻击不是发生在网络层，是发生在 TCP 建立握手成功之后，应用程序处理请求的时候，现在很多常见的 DDoS 攻击都是应用层攻击。应用层攻击千变万化，目的就是在网络应用层耗尽你的带宽，下面列出集中典型的攻击类型。</p><p><strong>CC 攻击</strong></p><p>当时绿盟为了防御 DDoS 攻击研发了一款叫做 <code>Collapasar</code> 的产品，能够有效的防御 SYN Flood 攻击。黑客为了挑衅，研发了一款 <code>Challenge Collapasar</code> 攻击工具（简称 CC）。</p><p>CC 攻击的原理，就是针对消耗资源比较大的页面不断发起不正常的请求，导致资源耗尽。因此在发送 CC 攻击前，我们需要寻找加载比较慢，消耗资源比较多的网页，比如需要查询数据库的页面、读写硬盘文件的等。通过 CC 攻击，使用爬虫对某些加载需要消耗大量资源的页面发起 HTTP 请求。</p><p><strong>DNS Flood</strong></p><p>DNS Flood 攻击采用的方法是向被攻击的服务器发送大量的域名解析请求，通常请求解析的域名是随机生成或者是网络世界上根本不存在的域名，被攻击的DNS 服务器在接收到域名解析请求的时候首先会在服务器上查找是否有对应的缓存，如果查找不到并且该域名无法直接由服务器解析的时候，DNS 服务器会向其上层 DNS 服务器递归查询域名信息。域名解析的过程给服务器带来了很大的负载，每秒钟域名解析请求超过一定的数量就会造成 DNS 服务器解析域名超时。</p><p>根据微软的统计数据，一台 DNS 服务器所能承受的动态域名查询的上限是每秒钟 9000 个请求。而我们知道，在一台 P3 的 PC 机上可以轻易地构造出每秒钟几万个域名解析请求，足以使一台硬件配置极高的 DNS 服务器瘫痪，由此可见 DNS 服务器的脆弱性。</p><p><strong>HTTP 慢速连接攻击</strong></p><p>针对 HTTP 协议，先建立起 HTTP 连接，设置一个较大的 Conetnt-Length，每次只发送很少的字节，让服务器一直以为 HTTP 头部没有传输完成，这样连接一多就很快会出现连接耗尽。</p><h3 id="应用层-DDoS-防御"><a href="#应用层-DDoS-防御" class="headerlink" title="应用层 DDoS 防御"></a>应用层 DDoS 防御</h3><ul><li>判断 User-Agent 字段（不可靠，因为可以随意构造）</li><li>针对 IP + cookie，限制访问频率（由于 cookie 可以更改，IP 可以使用代理，或者肉鸡，也不可靠)</li><li>关闭服务器最大连接数等，合理配置中间件，缓解 DDoS 攻击。</li><li>请求中添加验证码，比如请求中有数据库操作的时候。</li><li>编写代码时，尽量实现优化，并合理使用缓存技术，减少数据库的读取操作。</li><li>加钱堆机器。。</li><li>报警。。</li></ul><p>应用层的防御有时比网络层的更难，因为导致应用层被 DDoS 攻击的因素非常多，有时往往是因为程序员的失误，导致某个页面加载需要消耗大量资源，有时是因为中间件配置不当等等。而应用层 DDoS 防御的核心就是区分人与机器（爬虫），因为大量的请求不可能是人为的，肯定是机器构造的。因此如果能有效的区分人与爬虫行为，则可以很好地防御此攻击。</p><h3 id="其他-DDoS-攻击"><a href="#其他-DDoS-攻击" class="headerlink" title="其他 DDoS 攻击"></a>其他 DDoS 攻击</h3><p>发起 DDoS 也是需要大量的带宽资源的，但是互联网就像森林，林子大了什么鸟都有，DDoS 攻击者也能找到其他的方式发起廉价并且极具杀伤力的 DDoS 攻击。</p><p><strong>利用 XSS</strong></p><p>举个例子，如果 12306 页面有一个 XSS 持久型漏洞被恶意攻击者发现，只需在春节抢票期间在这个漏洞中执行脚本使得往某一个小站点随便发点什么请求，然后随着用户访问的增多，感染用户增多，被攻击的站点自然就会迅速瘫痪了。这种 DDoS 简直就是无本万利，不用惊讶，现在大站有 XSS 漏洞的不要太多。</p><p><strong>来自 P2P 网络攻击</strong></p><p>大家都知道，互联网上的 P2P 用户和流量都是一个极为庞大的数字。如果他们都去一个指定的地方下载数据，成千上万的真实 IP 地址连接过来，没有哪个设备能够支撑住。拿 BT 下载来说，伪造一些热门视频的种子，发布到搜索引擎，就足以骗到许多用户和流量了，但是这只是基础攻击。</p><p>高级的 P2P 攻击，是直接欺骗资源管理服务器。如迅雷客户端会把自己发现的资源上传到资源管理服务器，然后推送给其它需要下载相同资源的用户，这样，一个链接就发布出去。通过协议逆向，攻击者伪造出大批量的热门资源信息通过资源管理中心分发出去，瞬间就可以传遍整个 P2P 网络。更为恐怖的是，这种攻击是无法停止的，即使是攻击者自身也无法停止，攻击一直持续到 P2P 官方发现问题更新服务器且下载用户重启下载软件为止。</p><blockquote><p>最后总结下，DDoS 不可能防的住，就好比你的店只能容纳 50 人，黑社会有 100 人，你就换一家大店，能容纳 500 人，然后黑社会又找来了 1000 人，这种堆人头的做法就是 DDoS 本质上的攻防之道，「道高一尺，魔高一丈，魔高一尺，道高一丈」，讲真，必要的时候就答应勒索你的人的条件吧，实在不行就报警吧。</p></blockquote><h2 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h2><p>流量劫持应该算是黑产行业的一大经济支柱了吧？简直是让人恶心到吐，不吐槽了，还是继续谈干货吧，流量劫持基本分两种：<code>DNS 劫持</code> 和 <code>HTTP 劫持</code>，目的都是一样的，就是当用户访问 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 的时候，给你展示的并不是或者不完全是 <a href="https://zoumiaojiang.com" target="_blank" rel="noopener">zoumiaojiang.com</a> 提供的 “内容”。</p><h3 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h3><p>DNS 劫持，也叫做域名劫持，可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果你打的车是小作坊派来的，直接给你拉到小作坊去了</strong>」，DNS 的作用是把网络地址域名对应到真实的计算机能够识别的 IP 地址，以便计算机能够进一步通信，传递网址和内容等。如果当用户通过某一个域名访问一个站点的时候，被篡改的 DNS 服务器返回的是一个恶意的钓鱼站点的 IP，用户就被劫持到了恶意钓鱼站点，然后继而会被钓鱼输入各种账号密码信息，泄漏隐私。<br><img src="/2018/01/23/Web-安全攻防总结/dns.jpg" alt="dns劫持"><br>这类劫持，要不就是网络运营商搞的鬼，一般小的网络运营商与黑产勾结会劫持 DNS，要不就是电脑中毒，被恶意篡改了路由器的 DNS 配置，基本上做为开发者或站长却是很难察觉的，除非有用户反馈，现在升级版的 DNS 劫持还可以对特定用户、特定区域等使用了用户画像进行筛选用户劫持的办法，另外这类广告显示更加随机更小，一般站长除非用户投诉否则很难觉察到，就算觉察到了取证举报更难。无论如何，如果接到有 DNS 劫持的反馈，一定要做好以下几件事：</p><ul><li>取证很重要，时间、地点、IP、拨号账户、截屏、URL 地址等一定要有。</li><li>可以跟劫持区域的电信运营商进行投诉反馈。</li><li>如果投诉反馈无效，直接去工信部投诉，一般来说会加白你的域名。</li></ul><h3 id="HTTP-劫持"><a href="#HTTP-劫持" class="headerlink" title="HTTP 劫持"></a>HTTP 劫持</h3><p>HTTP 劫持您可以这么理解，「<strong>你打了一辆车想去商场吃饭，结果司机跟你一路给你递小作坊的广告</strong>」，HTTP 劫持主要是当用户访问某个站点的时候会经过运营商网络，而不法运营商和黑产勾结能够截获 HTTP 请求返回内容，并且能够篡改内容，然后再返回给用户，从而实现劫持页面，轻则插入小广告，重则直接篡改成钓鱼网站页面骗用户隐私。能够实施流量劫持的根本原因，是 HTTP 协议没有办法对通信对方的身份进行校验以及对数据完整性进行校验。如果能解决这个问题，则流量劫持将无法轻易发生。所以防止 HTTP 劫持的方法只有将内容加密，让劫持者无法破解篡改，这样就可以防止 HTTP 劫持了。</p><p>HTTPS 协议就是一种基于 SSL 协议的安全加密网络应用层协议，可以很好的防止 HTTP 劫持。这里有篇 <a href="https://www.jianshu.com/p/13a1b955d095" target="_blank" rel="noopener">文章</a> 讲的不错。HTTPS 在这就不深讲了，后面有机会我会单独好好讲讲 HTTPS。如果不想站点被 HTTP 劫持，赶紧将你的站点全站改造成 HTTPS 吧。</p><h2 id="服务器漏洞"><a href="#服务器漏洞" class="headerlink" title="服务器漏洞"></a>服务器漏洞</h2><p>服务器除了以上提到的那些大名鼎鼎的漏洞和臭名昭著的攻击以外，其实还有很多其他的漏洞，往往也很容易被忽视，在这个小节也稍微介绍几种。</p><h3 id="越权操作漏洞"><a href="#越权操作漏洞" class="headerlink" title="越权操作漏洞"></a>越权操作漏洞</h3><p>如果你的系统是有登录控制的，那就要格外小心了，因为很有可能你的系统越权操作漏洞，越权操作漏洞可以简单的总结为 「<strong>A 用户能看到或者操作 B 用户的隐私内容</strong>」，如果你的系统中还有权限控制就更加需要小心了。所以每一个请求都需要做 userid 的判断</p><p>以下是一段有漏洞的后端示意代码：</p><pre><code>// ctx 为请求的 context 上下文let msgId = ctx.params.msgId;mysql.query(&apos;SELECT * FROM msg_table WHERE msg_id = ?&apos;,    [msgId]);</code></pre><p>以上代码是任何人都可以查询到任何用户的消息，只要有 msg_id 就可以，这就是比较典型的越权漏洞，需要如下这么改进一下：</p><pre><code>// ctx 为请求的 context 上下文let msgId = ctx.params.msgId;let userId = ctx.session.userId; // 从会话中取出当前登陆的 userIdmysql.query(&apos;SELECT * FROM msg_table WHERE msg_id = ? AND user_id = ?&apos;,    [msgId, userId]);</code></pre><p>嗯，大概就是这个意思，如果有更严格的权限控制，那在每个请求中凡是涉及到数据库的操作都需要先进行严格的验证，并且在设计数据库表的时候需要考虑进 userId 的账号关联以及权限关联。</p><h3 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h3><p>目录遍历漏洞指通过在 URL 或参数中构造 <code>../</code>，<code>./</code> 和类似的跨父目录字符串的 ASCII 编码、unicode 编码等，完成目录跳转，读取操作系统各个目录下的敏感文件，也可以称作「任意文件读取漏洞」。</p><p>目录遍历漏洞原理：程序没有充分过滤用户输入的 <code>../</code> 之类的目录跳转符，导致用户可以通过提交目录跳转来遍历服务器上的任意文件。使用多个<code>..</code> 符号，不断向上跳转，最终停留在根 <code>/</code>，通过绝对路径去读取任意文件。</p><p>目录遍历漏洞几个示例和测试，一般构造 URL 然后使用浏览器直接访问，或者使用 Web 漏洞扫描工具检测，当然也可以自写程序测试。</p><pre><code>http://somehost.com/../../../../../../../../../etc/passwdhttp://somehost.com/some/path?file=../../Windows/system.ini# 借助 %00 空字符截断是一个比较经典的攻击手法http://somehost.com/some/path?file=../../Windows/system.ini%00.js# 使用了 IIS 的脚本目录来移动目录并执行指令http://somehost.com/scripts/..%5c../Windows/System32/cmd.exe?/c+dir+c:\</code></pre><p><strong>防御</strong> 方法就是需要对 URL 或者参数进行 <code>../</code>，<code>./</code> 等字符的转义过滤。</p><h3 id="物理路径泄漏"><a href="#物理路径泄漏" class="headerlink" title="物理路径泄漏"></a>物理路径泄漏</h3><p>物理路径泄露属于低风险等级缺陷，它的危害一般被描述为「攻击者可以利用此漏洞得到信息，来对系统进一步地攻击」，通常都是系统报错 500 的错误信息直接返回到页面可见导致的漏洞。得到物理路径有些时候它能给攻击者带来一些有用的信息，比如说：可以大致了解系统的文件目录结构；可以看出系统所使用的第三方软件；也说不定会得到一个合法的用户名（因为很多人把自己的用户名作为网站的目录名）。</p><p>防止这种泄漏的方法就是做好后端程序的出错处理，定制特殊的 500 报错页面。</p><h3 id="源码暴露漏洞"><a href="#源码暴露漏洞" class="headerlink" title="源码暴露漏洞"></a>源码暴露漏洞</h3><p>和物理路径泄露类似，就是攻击者可以通过请求直接获取到你站点的后端源代码，然后就可以对系统进一步研究攻击。那么导致源代码暴露的原因是什么呢？基本上就是发生在服务器配置上了，服务器可以设置哪些路径的文件才可以被直接访问的，这里给一个 koa 服务起的例子，正常的 koa 服务器可以通过 koa-static 中间件去指定静态资源的目录，好让静态资源可以通过路径的路由访问。比如你的系统源代码目录是这样的：</p><pre><code>|- project    |- src    |- static    |- ...|- server.js</code></pre><p>你想要将 static 的文件夹配成静态资源目录，你应该会在 <code>server.js</code> 做如下配置：</p><pre><code>const Koa = require(&apos;koa&apos;);const serve = require(&apos;koa-static&apos;);const app = new Koa();app.use(serve(__dirname + &apos;/project/static&apos;));</code></pre><p>但是如果配错了静态资源的目录，可能就出大事了，比如：</p><pre><code>// ...app.use(serve(__dirname + &apos;/project&apos;));</code></pre><p>这样所有的源代码都可以通过路由访问到了，所有的服务器都提供了静态资源机制，所以在通过服务器配置静态资源目录和路径的时候，一定要注意检验，不然很可能产生漏洞。</p><p>最后，希望 Web 开发者们能够管理好自己的代码隐私，注意代码安全问题，比如不要将产品的含有敏感信息的代码放到第三方外部站点或者暴露给外部用户，尤其是前端代码，私钥类似的保密性的东西不要直接输出在代码里或者页面中。也许还有很多值得注意的点，但是归根结底还是绷住安全那根弦，对待每一行代码都要多多推敲。</p>]]></content>
      
      
      
        <tags>
            
            <tag> xss </tag>
            
            <tag> CSRF </tag>
            
            <tag> SQL注入 </tag>
            
            <tag> DDoS 攻击 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>KOA2框架原理解析和实现</title>
      <link href="/2018/01/08/KOA2%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%92%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/01/08/KOA2%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E5%92%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是koa框架？"><a href="#什么是koa框架？" class="headerlink" title="什么是koa框架？"></a>什么是koa框架？</h3><p>koa是一个基于node实现的一个新的web框架，它是由express框架的原班人马打造的。它的特点是优雅、简洁、表达力强、自由度高。它更express相比，它是一个更轻量的node框架，因为它所有功能都通过插件实现，这种插拔式的架构设计模式，很符合unix哲学。</p><p>koa框架现在更新到了2.x版本，本文从零开始，循序渐进，讲解koa2的框架源码结构和实现原理，展示和详解koa2框架源码中的几个最重要的概念，然后手把手教大家亲自实现一个简易的koa2框架，帮助大家学习和更深层次的理解koa2，看完本文以后，再去对照koa2的源码进行查看，相信你的思路将会非常的顺畅。</p><p>本文所用的框架是koa2，它跟koa1不同，koa1使用的是generator+co.js的执行方式，而koa2中使用了async/await，因此本文的代码和demo需要运行在node 8版本及其以上，如果读者的node版本较低，建议升级或者安装babel-cli，用其中的babel-node来运行本文涉及到的代码。</p><h3 id="koa源码结构"><a href="#koa源码结构" class="headerlink" title="koa源码结构"></a>koa源码结构</h3><p><img src="/2018/01/08/KOA2框架原理解析和实现/166f12b8563436a3.webp" alt=""><br>上图是koa2的源码目录结构的lib文件夹，lib文件夹下放着四个koa2的核心文件：application.js、context.js、request.js、response.js。</p><h4 id="application-js"><a href="#application-js" class="headerlink" title="application.js"></a>application.js</h4><p>application.js是koa的入口文件，它向外导出了创建class实例的构造函数，它继承了events，这样就会赋予框架事件监听和事件触发的能力。application还暴露了一些常用的api，比如toJSON、listen、use等等。</p><p>listen的实现原理其实就是对http.createServer进行了一个封装，重点是这个函数中传入的callback，它里面包含了中间件的合并，上下文的处理，对res的特殊处理。</p><p>use是收集中间件，将多个中间件放入一个缓存队列中，然后通过koa-compose这个插件进行递归组合调用这一些列的中间件。</p><h4 id="context-js"><a href="#context-js" class="headerlink" title="context.js"></a>context.js</h4><p>这部分就是koa的应用上下文ctx,其实就一个简单的对象暴露，里面的重点在delegate，这个就是代理，这个就是为了开发者方便而设计的，比如我们要访问ctx.repsponse.status但是我们通过delegate，可以直接访问ctx.status访问到它。</p><h4 id="request-js、response-js"><a href="#request-js、response-js" class="headerlink" title="request.js、response.js"></a>request.js、response.js</h4><p>这两部分就是对原生的res、req的一些操作了，大量使用es6的get和set的一些语法，去取headers或者设置headers、还有设置body等等，这些就不详细介绍了，有兴趣的读者可以自行看源码。</p><h3 id="实现koa2的四大模块"><a href="#实现koa2的四大模块" class="headerlink" title="实现koa2的四大模块"></a>实现koa2的四大模块</h3><p>上文简述了koa2源码的大体框架结构，接下来我们来实现一个koa2的框架，笔者认为理解和实现一个koa框架需要实现四个大模块，分别是：</p><ul><li><p>封装node http server、创建Koa类构造函数</p></li><li><p>构造request、response、context对象</p></li><li><p>中间件机制和剥洋葱模型的实现</p></li><li><p>错误捕获和错误处理</p></li></ul><p>下面我们就逐一分析和实现。</p><h4 id="模块一：封装node-http-server和创建Koa类构造函数"><a href="#模块一：封装node-http-server和创建Koa类构造函数" class="headerlink" title="模块一：封装node http server和创建Koa类构造函数"></a>模块一：封装node http server和创建Koa类构造函数</h4><p>阅读koa2的源码得知，实现koa的服务器应用和端口监听，其实就是基于node的原生代码进行了封装，如下图的代码就是通过node原生代码实现的服务器监听。</p><pre><code>let http = require(&apos;http&apos;);let server = http.createServer((req, res) =&gt; {    res.writeHead(200);    res.end(&apos;hello world&apos;);});server.listen(3000, () =&gt; {        console.log(&apos;listenning on 3000&apos;);});</code></pre><p>我们需要将上面的node原生代码封装实现成koa的模式：</p><pre><code>const http = require(&apos;http&apos;);const Koa = require(&apos;koa&apos;);const app = new Koa();app.listen(3000);</code></pre><p>实现koa的第一步就是对以上的这个过程进行封装，为此我们需要创建application.js实现一个Application类的构造函数：</p><pre><code>let http = require(&apos;http&apos;);class Application{        constructor() {                this.callbackFunc;    }    listen(port) {                let server = http.createServer(this.callback());        server.listen(port);    }    use(fn) {        this.callbackFunc = fn;    }    callback() {        return(req, res) =&gt; {            this.callbackFunc(req, res);        };    }}module.exports = Application;</code></pre><p>然后创建example.js，引入application.js，运行服务器实例启动监听代码：</p><pre><code>let Koa = require(&apos;./application&apos;);let app = new Koa();app.use((req, res) =&gt; {    res.writeHead(200);    res.end(&apos;hello world&apos;);});app.listen(3000, () =&gt; {    console.log(&apos;listening on 3000&apos;);});</code></pre><p>现在在浏览器输入localhost:3000即可看到浏览器里显示“hello world”。现在第一步我们已经完成了，对http server进行了简单的封装和创建了一个可以生成koa实例的类class，这个类里还实现了app.use用来注册中间件和注册回调函数，app.listen用来开启服务器实例并传入callback回调函数，第一模块主要是实现典型的koa风格和搭好了一个koa的简单的架子。接下来我们开始编写和讲解第二模块。</p><h5 id="模块二：构造request、response、context对象"><a href="#模块二：构造request、response、context对象" class="headerlink" title="模块二：构造request、response、context对象"></a>模块二：构造request、response、context对象</h5><p>阅读koa2的源码得知，其中context.js、request.js、response.js三个文件分别是request、response、context三个模块的代码文件。context就是我们平时写koa代码时的ctx，它相当于一个全局的koa实例上下文this，它连接了request、response两个功能模块，并且暴露给koa的实例和中间件等回调函数的参数中，起到承上启下的作用。</p><p>request、response两个功能模块分别对node的原生request、response进行了一个功能的封装，使用了getter和setter属性，基于node的对象req/res对象封装koa的request/response对象。我们基于这个原理简单实现一下request.js、response.js，首先创建request.js文件，然后写入以下代码：</p><pre><code>let url = require(&apos;url&apos;);module.exports = {    get query() {        return url.parse(this.req.url, true).query;    }};</code></pre><p>这样当你在koa实例里使用ctx.query的时候，就会返回url.parse(this.req.url, true).query的值。看源码可知，基于getter和setter，在request.js里还封装了header、url、origin、path等方法，都是对原生的request上用getter和setter进行了封装，笔者不再这里一一实现。</p><p>接下来我们实现response.js文件代码模块，它和request原理一样，也是基于getter和setter对原生response进行了封装，那我们接下来通过对常用的ctx.body和ctx.status这个两个语句当做例子简述一下如果实现koa的response的模块，我们首先创建好response.js文件，然后输入下面的代码：</p><pre><code>module.exports = {    get body() {        returnthis._body;    },    set body(data) {        this._body = data;    },    get status() {        returnthis.res.statusCode;    },    set status(statusCode) {        if (typeof statusCode !== &apos;number&apos;) {            thrownewError(&apos;something wrong!&apos;);        }        this.res.statusCode = statusCode;    }};</code></pre><p>以上代码实现了对koa的status的读取和设置，读取的时候返回的是基于原生的response对象的statusCode属性，而body的读取则是对this._body进行读写和操作。这里对body进行操作并没有使用原生的this.res.end，因为在我们编写koa代码的时候，会对body进行多次的读取和修改，所以真正返回浏览器信息的操作是在application.js里进行封装和操作。</p><p>现在我们已经实现了request.js、response.js，获取到了request、response对象和他们的封装的方法，然后我们开始实现context.js，context的作用就是将request、response对象挂载到ctx的上面，让koa实例和代码能方便的使用到request、response对象中的方法。现在我们创建context.js文件，输入如下代码：</p><pre><code>let proto = {};function delegateSet(property, name) {    proto.__defineSetter__(name, function (val) {        this[property][name] = val;    });}function delegateGet(property, name) {    proto.__defineGetter__(name, function () {        returnthis[property][name];    });}let requestSet = [];let requestGet = [&apos;query&apos;];let responseSet = [&apos;body&apos;, &apos;status&apos;];let responseGet = responseSet;requestSet.forEach(ele =&gt; {    delegateSet(&apos;request&apos;, ele);});requestGet.forEach(ele =&gt; {    delegateGet(&apos;request&apos;, ele);});responseSet.forEach(ele =&gt; {    delegateSet(&apos;response&apos;, ele);});responseGet.forEach(ele =&gt; {    delegateGet(&apos;response&apos;, ele);});module.exports = proto;</code></pre><p>context.js文件主要是对常用的request和response方法进行挂载和代理，通过context.query直接代理了context.request.query，context.body和context.status代理了context.response.body与context.response.status。而context.request，context.response则会在application.js中挂载</p><p>本来可以用简单的setter和getter去设置每一个方法，但是由于context对象定义方法比较简单和规范，在koa源码里可以看到，koa源码用的是<strong>defineSetter</strong>和<strong>defineSetter</strong>来代替setter/getter每一个属性的读取设置，这样做主要是方便拓展和精简了写法，当我们需要代理更多的res和req的方法的时候，可以向context.js文件里面的数组对象里面添加对应的方法名和属性名即可。</p><p>目前为止，我们已经得到了request、response、context三个模块对象了，接下来就是将request、response所有方法挂载到context下，让context实现它的承上启下的作用，修改application.js文件，添加如下代码：</p><pre><code>let http = require(&apos;http&apos;);let context = require(&apos;./context&apos;);let request = require(&apos;./request&apos;);let response = require(&apos;./response&apos;);createContext(req, res) {          let ctx = Object.create(this.context);   ctx.request = Object.create(this.request);   ctx.response = Object.create(this.response);   ctx.req = ctx.request.req = req;   ctx.res = ctx.response.res = res;    return ctx;}</code></pre><p>可以看到，我们添加了createContext这个方法，这个方法是关键，它通过Object.create创建了ctx，并将request和response挂载到了ctx上面，将原生的req和res挂载到了ctx的子属性上，往回看一下context/request/response.js文件，就能知道当时使用的this.res或者this.response之类的是从哪里来的了，原来是在这个createContext方法中挂载到了对应的实例上，构建了运行时上下文ctx之后，我们的app.use回调函数参数就都基于ctx了。</p><h4 id="模块三：中间件机制和剥洋葱模型的实现"><a href="#模块三：中间件机制和剥洋葱模型的实现" class="headerlink" title="模块三：中间件机制和剥洋葱模型的实现"></a>模块三：中间件机制和剥洋葱模型的实现</h4><p>目前为止我们已经成功实现了上下文context对象、 请求request对象和响应response对象模块，还差一个最重要的模块，就是koa的中间件模块，koa的中间件机制是一个剥洋葱式的模型，多个中间件通过use放进一个数组队列然后从外层开始执行，遇到next后进入队列中的下一个中间件，所有中间件执行完后开始回帧，执行队列中之前中间件中未执行的代码部分，这就是剥洋葱模型，koa的中间件机制。</p><p>koa的剥洋葱模型在koa1中使用的是generator + co.js去实现的，koa2则使用了async/await + Promise去实现的，接下来我们基于async/await + Promise去实现koa2中的中间件机制。首先，假设当koa的中间件机制已经做好了，那么它是能成功运行下面代码的：</p><pre><code>let Koa = require(&apos;../src/application&apos;);let app = new Koa();app.use(async (ctx, next) =&gt; {    console.log(1);    await next();    console.log(6);});app.use(async (ctx, next) =&gt; {    console.log(2);    await next();    console.log(5);});app.use(async (ctx, next) =&gt; {    console.log(3);    ctx.body = &quot;hello world&quot;;    console.log(4);});app.listen(3000, () =&gt; {    console.log(&apos;listenning on 3000&apos;);});</code></pre><p>运行成功后会在终端输出123456，那就能验证我们的koa的剥洋葱模型是正确的。接下来我们开始实现，修改application.js文件，添加如下代码：</p><pre><code>compose() {    return async ctx =&gt; {        function createNext(middleware, oldNext) {            return async () =&gt; {                await middleware(ctx, oldNext);            }        }        let len = this.middlewares.length;        let next = async () =&gt; {            return Promise.resolve();        };        for (let i = len - 1; i &gt;= 0; i--) {            let currentMiddleware = this.middlewares[i];            next = createNext(currentMiddleware, next);        }        await next();    };}callback() {    return(req, res) =&gt; {        let ctx = this.createContext(req, res);        let respond = () =&gt;this.responseBody(ctx);        let onerror = (err) =&gt;this.onerror(err, ctx);        let fn = this.compose();        return fn(ctx);    };}</code></pre><p>koa通过use函数，把所有的中间件push到一个内部数组队列this.middlewares中，剥洋葱模型能让所有的中间件依次执行，每次执行完一个中间件，遇到next()就会将控制权传递到下一个中间件，下一个中间件的next参数，剥洋葱模型的最关键代码是compose这个函数：</p><pre><code>compose() {        return async ctx =&gt; {            function createNext(middleware, oldNext) {                returnasync () =&gt; {                    await middleware(ctx, oldNext);                }            }            let len = this.middlewares.length;            let next = async () =&gt; {                return Promise.resolve();            };            for (let i = len - 1; i &gt;= 0; i--) {                let currentMiddleware = this.middlewares[i];                next = createNext(currentMiddleware, next);            }            await next();        };    }</code></pre><p>createNext函数的作用就是将上一个中间件的next当做参数传给下一个中间件，并且将上下文ctx绑定当前中间件，当中间件执行完，调用next()的时候，其实就是去执行下一个中间件。</p><pre><code>for (let i = len - 1; i &gt;= 0; i--) {        let currentMiddleware = this.middlewares[i];        next = createNext(currentMiddleware, next); }</code></pre><p>上面这段代码其实就是一个链式反向递归模型的实现，i是从最大数开始循环的，将中间件从最后一个开始封装，每一次都是将自己的执行函数封装成next当做上一个中间件的next参数，这样当循环到第一个中间件的时候，只需要执行一次next()，就能链式的递归调用所有中间件，这个就是koa剥洋葱的核心代码机制。</p><p>到这里我们总结一下上面所有剥洋葱模型代码的流程，通过use传进来的中间件是一个回调函数，回调函数的参数是ctx上下文和next，next其实就是控制权的交接棒，next的作用是停止运行当前中间件，将控制权交给下一个中间件，执行下一个中间件的next()之前的代码，当下一个中间件运行的代码遇到了next()，又会将代码执行权交给下下个中间件，当执行到最后一个中间件的时候，控制权发生反转，开始回头去执行之前所有中间件中剩下未执行的代码，这整个流程有点像一个伪递归，当最终所有中间件全部执行完后，会返回一个Promise对象，因为我们的compose函数返回的是一个async的函数，async函数执行完后会返回一个Promise，这样我们就能将所有的中间件异步执行同步化，通过then就可以执行响应函数和错误处理函数。</p><p>当中间件机制代码写好了以后，运行我们的上面的例子，已经能输出123456了，至此，我们的koa的基本框架已经基本做好了，不过一个框架不能只实现功能，为了框架和服务器实例的健壮，还需要加上错误处理机制。</p><h4 id="模块四：错误捕获和错误处理"><a href="#模块四：错误捕获和错误处理" class="headerlink" title="模块四：错误捕获和错误处理"></a>模块四：错误捕获和错误处理</h4><p>要实现一个基础框架，错误处理和捕获必不可少，一个健壮的框架，必须保证在发生错误的时候，能够捕获到错误和抛出的异常，并反馈出来，将错误信息发送到监控系统上进行反馈，目前我们实现的简易koa框架还没有能实现这一点，我们接下加上错误处理和捕获的机制。</p><pre><code>throw new Error(&apos;oooops&apos;);</code></pre><p>基于现在的框架，如果中间件代码中出现如上错误异常抛出，是捕获不到错误的，这时候我们看一下application.js中的callback函数的return返回代码，如下：</p><pre><code>return fn(ctx).then(respond);</code></pre><p>可以看到，fn是中间件的执行函数，每一个中间件代码都是由async包裹着的，而且中间件的执行函数compose返回的也是一个async函数，我们根据es7的规范知道，async返回的是一个promise的对象实例，我们如果想要捕获promise的错误，只需要使用promise的catch方法，就可以把所有的中间件的异常全部捕获到，修改后callback的返回代码如下：</p><pre><code>return fn(ctx).then(respond).catch(onerror);</code></pre><p>现在我们已经实现了中间件的错误异常捕获，但是我们还缺少框架层发生错误的捕获机制，我们希望我们的服务器实例能有错误事件的监听机制，通过on的监听函数就能订阅和监听框架层面上的错误，实现这个机制不难，使用nodejs原生events模块即可，events模块给我们提供了事件监听on函数和事件触发emit行为函数，一个发射事件，一个负责接收事件，我们只需要将koa的构造函数继承events模块即可，构造后的伪代码如下：</p><pre><code>let EventEmitter = require(&apos;events&apos;);class Application extends EventEmitter{}</code></pre><p>继承了events模块后，当我们创建koa实例的时候，加上on监听函数，代码如下：</p><pre><code>let app = new Koa();app.on(&apos;error&apos;, err =&gt; {    console.log(&apos;error happends: &apos;, err.stack);});</code></pre><p>这样我们就实现了框架层面上的错误的捕获和监听机制了。总结一下，错误处理和捕获，分中间件的错误处理捕获和框架层的错误处理捕获，中间件的错误处理用promise的catch，框架层面的错误处理用nodejs的原生模块events，这样我们就可以把一个服务器实例上的所有的错误异常全部捕获到了。至此，我们就完整实现了一个轻量版的koa框架了。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>前为止，我们已经实现了一个轻量版的koa框架了，我们实现了封装node http server、创建Koa类构造函数、构造request、response、context对象、中间件机制和剥洋葱模型的实现、错误捕获和错误处理这四个大模块，理解了这个轻量版koa的实现原理，再去看koa2的源码，你就会发现一切都豁然开朗，koa2的源码无非就是在这个轻量版基础上加了很多工具函数和细节的处理，限于篇幅笔者就不再一一介绍了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>vue2组件懒加载</title>
      <link href="/2018/01/07/vue2%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/01/07/vue2%E7%BB%84%E4%BB%B6%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是懒加载"><a href="#什么是懒加载" class="headerlink" title="什么是懒加载"></a>什么是懒加载</h3><p>懒加载也叫延迟加载，即在需要的时候进行加载，随用随载。</p><h3 id="为什么需要懒加载"><a href="#为什么需要懒加载" class="headerlink" title="为什么需要懒加载"></a>为什么需要懒加载</h3><p>在单页应用中，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，延时过长，不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时</p><h3 id="如何与webpack配合实现组件懒加载"><a href="#如何与webpack配合实现组件懒加载" class="headerlink" title="如何与webpack配合实现组件懒加载"></a>如何与webpack配合实现组件懒加载</h3><p>　　1、在webpack配置文件中的output路径配置chunkFilename属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">        path: resolve(__dirname, &apos;dist&apos;),</span><br><span class="line">        filename: options.dev ? &apos;[name].js&apos; : &apos;[name].js?[chunkhash]&apos;,</span><br><span class="line">        chunkFilename: &apos;chunk[id].js?[chunkhash]&apos;,</span><br><span class="line">        publicPath: options.dev ? &apos;/assets/&apos; : publicPath</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>chunkFilename路径将会作为组件懒加载的路径</p><p>2、配合webpack支持的异步加载方法</p><ul><li>resolve =&gt; require([URL], resolve), 支持性好</li><li>() =&gt; system.import(URL) , webpack2官网上已经声明将逐渐废除, 不推荐使用</li><li>() =&gt; import(URL), webpack2官网推荐使用, 属于es7范畴, 需要配合babel的syntax-dynamic-import插件使用, 具体使用方法如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-core babel-loader babel-plugin-syntax-dynamic-import babel-preset-es2015</span><br><span class="line"></span><br><span class="line">use: [&#123;</span><br><span class="line">        loader: &apos;babel-loader&apos;,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [[&apos;es2015&apos;, &#123;modules: false&#125;]],</span><br><span class="line">          plugins: [&apos;syntax-dynamic-import&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br></pre></td></tr></table></figure><h3 id="具体实例中实现懒加载"><a href="#具体实例中实现懒加载" class="headerlink" title="具体实例中实现懒加载"></a>具体实例中实现懒加载</h3><h4 id="路由中配置异步组件"><a href="#路由中配置异步组件" class="headerlink" title="路由中配置异步组件"></a>路由中配置异步组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default new Router(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            mode: &apos;history&apos;,</span><br><span class="line">            path: &apos;/my&apos;,</span><br><span class="line">            name: &apos;my&apos;,</span><br><span class="line">            component:  resolve =&gt; require([&apos;../page/my/my.vue&apos;], resolve),//懒加载</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="实例中配置异步组件"><a href="#实例中配置异步组件" class="headerlink" title="实例中配置异步组件"></a>实例中配置异步组件</h4><blockquote><p>推荐<code>historyTab: () =&gt; import(&#39;../../component/historyTab/historyTab.vue&#39;)</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">        historyTab: resolve =&gt; &#123;require([&apos;../../component/historyTab/historyTab.vue&apos;], resolve)&#125;,//懒加载</span><br><span class="line">        //historyTab: () =&gt; import(&apos;../../component/historyTab/historyTab.vue&apos;)</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h4 id="全局注册异步组件"><a href="#全局注册异步组件" class="headerlink" title="全局注册异步组件"></a>全局注册异步组件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&apos;mideaHeader&apos;, () =&gt; &#123;</span><br><span class="line">    System.import(&apos;./component/header/header.vue&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 懒加载 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于Viewport与device-width的一点理解</title>
      <link href="/2018/01/02/%E5%85%B3%E4%BA%8EViewport%E4%B8%8Edevice-width%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/"/>
      <url>/2018/01/02/%E5%85%B3%E4%BA%8EViewport%E4%B8%8Edevice-width%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="再进行移动web开发的时候都要加一句："><a href="#再进行移动web开发的时候都要加一句：" class="headerlink" title="再进行移动web开发的时候都要加一句："></a>再进行移动web开发的时候都要加一句：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;</span><br></pre></td></tr></table></figure><ol><li>我们经常使用的<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">里的viewport究竟是什么意思，这里的device-width跟我们用JS获取到的屏宽的区别与联系分别是什么，为什么去掉<meta>标签后页面会变得很小很小？</li><li>为什么很多分辨率很大的屏幕宽度其实并不大，屏幕分辨率与用JS获取到的屏宽的区别与联系分别又是什么？</li></ol><h3 id="视口-viewport"><a href="#视口-viewport" class="headerlink" title="视口 viewport"></a>视口 viewport</h3><h4 id="viewport-基础"><a href="#viewport-基础" class="headerlink" title="viewport 基础"></a>viewport 基础</h4><p>viewport 解释为中文就是‘视口’的意思，也就是浏览器中用于显示网页的区域。在 PC 端，其大小也就是浏览器可视区域的大小，所以我们也不会太关注此概念；而在移动端，绝大多数情况下 viewport 都大于浏览器可视区，保证 PC 页面在移动浏览器上面的可视性。为提升可视性体验，针对移动端有了对 viewport 的深入研究。</p><h4 id="viewport-详解"><a href="#viewport-详解" class="headerlink" title="viewport 详解"></a>viewport 详解</h4><p>在移动端有三种类型的 viewport: layoutviewport、visualviewport、idealviewport。具体解释如下：</p><ul><li>layoutviewport:  大于实际屏幕， 元素的宽度继承于 layoutviewport，用于保证网站的外观特性与桌面浏览器一样。layoutviewport 到底多宽，每个浏览器不同。iPhone 的 safari 为 980px，通过 document.document.clientWidth 获取。</li><li>visualviewport: 当前显示在屏幕上的页面，即浏览器可视区域的宽度。</li><li>idealviewport: 为浏览器定义的可完美适配移动端的理想 viewport，固定不变，可以认为是设备视口宽度。比如 iphone 7 为 375px, iphone 7p 为 414px。</li></ul><h4 id="viewport-设置"><a href="#viewport-设置" class="headerlink" title="viewport 设置"></a>viewport 设置</h4><p>我们通过对几种 viewport 设置可以对网页的展示进行有效的控制，在移动端我们经常会在 head 标签中看到这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&apos;viewport&apos; content=&apos;width=device-width,initial-scale=1,user-scale=no&apos; /&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2018/01/02/关于Viewport与device-width的一点理解/1.webp" alt=""></p><h4 id="1px的物理像素的解决方案"><a href="#1px的物理像素的解决方案" class="headerlink" title="1px的物理像素的解决方案"></a>1px的物理像素的解决方案</h4><p>从第一部分的讨论可知 viewport 的 initial-scale 具有缩放页面的效果。对于 dpr=2 的屏幕，1px压缩一半便可与1px的设备像素比匹配，这就可以通过将缩放比 initial-scale 设置为 0.5=1/2 而实现。以此类推 dpr=3的屏幕可以将 initial-scale设置为 0.33=1/3 来实现。</p><pre><code>(function (baseFontSize) {    const _baseFontSize = baseFontSize || 75;    const ua = navigator.userAgent;    const matches = ua.match(/Android[\S\s]+AppleWebkit\/(\d{3})/i);    const isIos = navigator.appVersion.match(/(iphone|ipad|ipod)/gi);    const dpr = window.devicePixelRatio || 1;    if (!isIos &amp;&amp; !(matches &amp;&amp; matches[1] &gt; 534)) {        // 如果非iOS, 非Android4.3以上, dpr设为1;        dpr = 1;    }    const scale = 1 / dpr;    const metaEl = document.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;);    if (!metaEl) {        metaEl = document.createElement(&apos;meta&apos;);        metaEl.setAttribute(&apos;name&apos;, &apos;viewport&apos;);        window.document.head.appendChild(metaEl);    }    metaEl.setAttribute(&apos;content&apos;, &apos;width=device-width,user-scalable=no,initial-scale=&apos; + scale + &apos;,maximum-scale=&apos; + scale + &apos;,minimum-scale=&apos; + scale);    document.documentElement.style.fontSize = document.documentElement.clientWidth / (750 / _baseFontSize) + &apos;px&apos;;})();</code></pre><hr><p>要说这个，先来了解下一些移动端基础知识：</p><h3 id="1、物理像素-设备像素，分辨率"><a href="#1、物理像素-设备像素，分辨率" class="headerlink" title="1、物理像素(设备像素，分辨率)"></a>1、物理像素(设备像素，分辨率)</h3><p>设备像素，在同一个设备上，它的物理像素是固定的，这是厂商在出厂时就设置好了的，即一个设备的分辨率是固定的。</p><h3 id="2、逻辑像素-CSS像素"><a href="#2、逻辑像素-CSS像素" class="headerlink" title="2、逻辑像素(CSS像素)"></a>2、逻辑像素(CSS像素)</h3><p>CSS像素，viewport中的一个小方格，CSS样式代码中使用的是逻辑像素。如果在一个设备中，物理像素与逻辑像素相等，将不会产生任何问题。但是，在iphone 4中，物理像素是640px<em>960px，而逻辑像素数为320</em>480px。因此，需要使用大约4个物理像素来显示一个CSS像素。</p><h3 id="3、像素比"><a href="#3、像素比" class="headerlink" title="3、像素比"></a>3、像素比</h3><p>物理像素与逻辑像素之间的比例。当像素比为1:1时，使用1个物理像素显示1个逻辑像素；当像素比为2:1时，使用4个物理像素显示1个逻辑像素。</p><h3 id="4、CSS中的1px并不等于设备的1px"><a href="#4、CSS中的1px并不等于设备的1px" class="headerlink" title="4、CSS中的1px并不等于设备的1px"></a>4、CSS中的1px并不等于设备的1px</h3><p>在CSS中一般使用px作为单位，在Web浏览器中CSS的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成一个错觉，那就是CSS中的像素就是设备的物理像素。但实际情况却并非如此，CSS中的像素只是一个抽象的单位，在不同的设备或不同的环境中，CSS中的1px所代表的设备物理像素是不同的。<br>在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320<em>480，在iphone3上，1个CSS像素确实是等于1个物理像素的。后来随着技术的发展，移动设备的像素越来越高，从iphone4开始，推出了所谓的Retina屏，分辨率提高了一倍，变成640</em>960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，1个CSS像素是等于4个物理像素的。</p><h3 id="5、实现真正的1物理像素"><a href="#5、实现真正的1物理像素" class="headerlink" title="5、实现真正的1物理像素"></a>5、实现真正的1物理像素</h3><p>当viewport的属性initial-scale为1时，页面大小正常，但initial-scale为0.5时，页面被缩小了1倍，像素比为2:1的设备本来1个CSS像素宽度占2个物理像素宽度，缩小后的1个CSS像素宽度就只占1个物理像素，即实现了真正的1物理像素。<br><code>eg：border-width:1px</code>并不是最小边框，浏览器可以显示的最小粒度比1px还要小。为什么会出现比border-width:1px更细的边框？<br>屏幕能够显示的最小粒度是1个物理像素，iPhone4的像素比为2，设置border-width:1px后，边框占了4个物理像素，如果能让边框的宽度为1物理像素，那么它就比1个CSS像素要细，这可以通过设置<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=0.5&quot;&gt;</code>。</p><h2 id="CSS-pixel与device-pixels-css-px与device-px"><a href="#CSS-pixel与device-pixels-css-px与device-px" class="headerlink" title="CSS pixel与device pixels (css px与device px)"></a>CSS pixel与device pixels (css px与device px)</h2><p>首先了解下什么是CSS pixels，什么是device pixels；</p><p>1．CSS pixels可以理解为<code>css像素</code>，是浏览器使用的抽象单位，主要用来在网页上绘制内容。也可以说css px是专门为web开发者提出的一个抽象概念，也只跟我们平时写的css样式有关，与分辨率（比如720px*1280px）里的px没关系。</p><p>2． device pixels可以理解为是设备像素，官方的解释是：显示屏幕的最小物理单位，每个dp包含自己的颜色、高宽等。</p><p>对于我们做web开发的人来说，我们用到的最多的地方是“css像素”，即类似width:300px;font-size:14px;这类的css语句里用到的。它跟设备自身的px是没关系的。也就是说1个CSS 像素占多少个物理像素是不确定的，这个问题通过页面的放缩比较容易理解。比如一个普通的html页面上，有一个300px的元素；如果我们放大页面，元素会占据更多的设备像素（即device pixels），但它的CSS pixels不变，依然是300px；缩小页面也是同样的道理，占据了更少的device pixels，但它的CSS pixels不变。也就是说，元素占据了多少device pixels，是由当前页面的放缩比例而定的。</p><p>不过，页面的缩放对我们web开发来说是好像没有任何意义的。但有一个问题，我们开发出来的页面是想要在各个屏幕个以最佳的样式展示出来的，我们不能让页面里存在不能控制的元素。所以就出现了它：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot; /&gt;</code> 也就是我们在进行web开发的时候经常用到的viewport。那么viewport到底是个什么玩意儿呢，而且content里面width为什么要等于device-width呢，device-width又是个什么概念呢？下面我们来看看它们哥俩儿是什么。</p><h2 id="Viewport-与-device-width"><a href="#Viewport-与-device-width" class="headerlink" title="Viewport 与 device-width"></a>Viewport 与 device-width</h2><p>在解释这两个概念之前，先说一个大家都知道，但不明白为什么的情况：把一个普通的在PC上开发的HTML页面直接放手机上，你会发现不管多大的页面都可以在小小的手机屏幕上显示，但是图文都会显示的特别小；如果你用js获取下页面宽度，你会发现，大多数的页面宽度都是980px的，这个就跟viewport有关。</p><p>Viewport起源于苹果，但现在已经被大多数浏览器支持。关于viewport有两个概念visual viewport跟layout viewport。这里visual viewport也就是视觉上的窗口，可以理解为设备自己的宽度。这时，如果你有一个长960的页面，有一个元素是20%（实际解析出来就是192px）。但如果我用宽为320px的屏幕打开呢，这个元素就成了64px，但是这个时候我设置的字体大小是12px，在320px的屏幕上就只能显示64/12个字了～</p><p>鉴于这个问题，苹果找到一种解决方法，在移动版的safari中定义了viewport meta标签，它的作用就是创建一个虚拟的窗口（viewport），这个虚拟的窗口就是layout viewport分辨率接近桌面显示器，apple将其定位为980px。在手机上，可以通过document.documentElement.clientWidth来获取。</p><p>其他浏览器厂商也有不同的解决办法，例如UCweb是使用的中间技术。</p><p>另外据说，不同浏览器厂商对于layout viewport的大小都有自己的定义。但是，我用手上不多的几个手机（小米2s、SONY、金立、ipad）测试的结果，都是980px。其中在小米2s上测试了小米自带浏览器、QQ浏览器、UC浏览器、谷歌浏览器，还有opera浏览器，结果都一样；其他的手机上面不管装了什么浏览器，都测试了，结果都是980px。但是这个值对于我们web开发来说，好像也没有什么用处。</p><p>因为大多数情况下，<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;</code>这个标签对我们来说是最给力的，可以让我们的页面里的图文显示的是正常的，很大程度上提高了页面的可读性。而这一meta标签的功能就是设置layout viewport为device-width的宽度。但是device-width具体是什么呢？</p><blockquote><font color="#ff0000">第一代iphone的时候，分辨率为320<em>480，屏幕尺寸为3.5寸<span style="border-bottom:2px solid blue;">（注意，这个3.5寸说的是屏幕的对角线宽）</span>，这时候device-width就是320px，也是手机的分辨率宽，此时device-width就是设备宽。但第二代的iphone分辨率提高为了480</em>960，屏幕尺寸为依然为3.5寸，如果device-width还是设备宽，那么同样是320px的页面放480*960的手机屏上，图文就会变得比较小，又会影响其可读性。<span style="border-bottom:2px solid blue;">因此iphone的device-width一直维持在320px，ipad一直维持在1024px</span>。这个时候，device-width就不是设备宽了（也就不是分辨率的宽了），是一个中间层。Android采用的也是这一概念，其device-width值以360居多，但也不乏有像540px和600px这样的奇葩。在设置了<meta>标签以后，device-width值可以用window.innerWidth来获取device-width值。</font></blockquote><h2 id="有关DPI"><a href="#有关DPI" class="headerlink" title="有关DPI"></a>有关DPI</h2><p>dpi(Dots Per Inch)，有时也叫做ppi(Point Per Inch)，翻译过来也叫像素密度，表示设备每英寸所占有的像素数；数值越高，即代表显示屏能够以越高的密度显示图像。（注：这里的像素，指的是device pixels。）DPI的计算公式：</p><p><img src="/2018/01/02/关于Viewport与device-width的一点理解/201157547867064.jpg" alt=""></p><p>有意思的是，这个值比苹果官网上公布的326还有高一点点。</p><p><img src="/2018/01/02/关于Viewport与device-width的一点理解/201158077397288.jpg" alt=""></p><p>其中，PPI在120-160之间的手机被归为低密度手机，160-240被归为中密度，240-320被归为高密度，320以上被归为超高密度（Apple给了它一个上流的名字——retina）。</p><p>这些密度对应着一个特定的缩放比例值，拿我们最熟悉的iphone4或4s来说，它们的PPI是326，属于超高密度的手机。当我们书写一个宽度为320px的页面放到iphone中显示，你会发现，它竟然是满宽的。这是因为，页面被默认放大了两倍，也就是640px，而iphone4或4s的宽，正是640px。    </p><h2 id="DevicePixelRadio"><a href="#DevicePixelRadio" class="headerlink" title="DevicePixelRadio"></a>DevicePixelRadio</h2><p>DevicePixelRadio，定义：<code>window.devicePixelRatio</code>是设备上物理像素（也就是device-width）和设备独立像素（device-independent pixels，即dips）的比例。公式表示就是：window.devicePixelRatio = 物理像素/dips</p><p>Android 和 iPhone 中，都有一个占整个屏幕大小的换算单位，<font color="#ff0000"><strong> Android 中叫 dip 或 dp，iPhone 中叫 point </strong></font>。Dip，就是device independent pixels，设备独立像素。而设备的物理像素和 dip 的比例就是 devicePixelRatio，此值可以通过 window.devicePixelRatio 属性获取。</p><p>据我查找到的一些资料显示，这里的独立像素的值其实就是device-width值。这个值也就是我们平时在手机上布局用的宽度，当然是在设置了<meta>标签的前提下。</p><h3 id="这里为什么提到devicePixelRatio这个概念呢？"><a href="#这里为什么提到devicePixelRatio这个概念呢？" class="headerlink" title="这里为什么提到devicePixelRatio这个概念呢？"></a>这里为什么提到devicePixelRatio这个概念呢？</h3><p>因为当devicePixelRatio=1.5的时候，也就是说当屏幕分辨率宽与device-width的比值为1.5时，某些手机自带的浏览器（特别是三星手机出现在最多）会出现1px的线解析成2px的bug，但是经测试同一部手机上安装的UC浏览器一般不会有这个bug。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈 instanceof 和 typeof 的实现原理</title>
      <link href="/2018/01/01/%E6%B5%85%E8%B0%88-instanceof-%E5%92%8C-typeof-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/01/01/%E6%B5%85%E8%B0%88-instanceof-%E5%92%8C-typeof-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="typeof-实现原理"><a href="#typeof-实现原理" class="headerlink" title="typeof 实现原理"></a>typeof 实现原理</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，我们可以利用 <code>typeof</code> 来判断<code>number</code>, <code>string</code>, <code>object</code>, <code>boolean</code>, <code>function</code>, <code>undefined</code>,<code>symbol</code> 这七种类型，这种判断能帮助我们搞定一些问题，比如在判断不是 object 类型的数据的时候，<code>typeof</code>能比较清楚的告诉我们具体是哪一类的类型。但是，很遗憾的一点是，<code>typeof</code> 在判断一个 object的数据的时候只能告诉我们这个数据是 object, 而不能细致的具体到是哪一种 object, 比如👉</p><pre><code>let s =newString(&apos;abc&apos;);typeof s ===&apos;object&apos;// trues instanceofString// true</code></pre><p>要想判断一个数据具体是哪一种 object 的时候，我们需要利用 <code>instanceof</code> 这个操作符来判断，这个我们后面会说到。</p><p>来谈谈关于 <code>typeof</code> 的原理吧，我们可以先想一个很有意思的问题，js 在底层是怎么存储数据的类型信息呢？或者说，一个 js 的变量，在它的底层实现中，它的类型信息是怎么实现的呢？</p><p>其实，js 在底层存储变量的时候，会在变量的机器码的低位1-3位存储其类型信息👉<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">000：对象</span><br><span class="line"></span><br><span class="line">010：浮点数</span><br><span class="line"></span><br><span class="line">100：字符串</span><br><span class="line"></span><br><span class="line">110：布尔</span><br></pre></td></tr></table></figure></p><ul><li>1：整数</li></ul><p>but, 对于 <code>undefined</code> 和 <code>null</code> 来说，这两个值的信息存储是有点特殊的。</p><p><code>null</code>：所有机器码均为0</p><p><code>undefined</code>：用 −2^30 整数来表示</p><p>所以，<code>typeof</code> 在判断 <code>null</code> 的时候就出现问题了，由于 <code>null</code> 的所有机器码均为0，因此直接被当做了对象来看待。</p><p>然而用 <code>instanceof</code> 来判断的话👉</p><pre><code>nullinstanceofnull// TypeError: Right-hand side of &apos;instanceof&apos; is not an object</code></pre><p><code>null</code> 直接被判断为不是 object，这也是 JavaScript 的历史遗留bug，可以参考typeof。</p><p>因此在用 <code>typeof</code> 来判断变量类型的时候，我们需要注意，最好是用 <code>typeof</code> 来判断基本数据类型（包括<code>symbol</code>），避免对 null 的判断。</p><p>还有一个不错的判断类型的方法，就是<strong><font color="#dd0000">Object.prototype.toString</font></strong>，我们可以利用这个方法来对一个变量的类型来进行比较准确的判断</p><pre><code>Object.prototype.toString.call(1)// &quot;[object Number]&quot;Object.prototype.toString.call(&apos;hi&apos;)// &quot;[object String]&quot;Object.prototype.toString.call({a:&apos;hi&apos;})// &quot;[object Object]&quot;Object.prototype.toString.call([1,&apos;a&apos;])// &quot;[object Array]&quot;Object.prototype.toString.call(true)// &quot;[object Boolean]&quot;Object.prototype.toString.call(()=&gt;{})// &quot;[object Function]&quot;Object.prototype.toString.call(null)// &quot;[object Null]&quot;Object.prototype.toString.call(undefined)// &quot;[object Undefined]&quot;Object.prototype.toString.call(Symbol(1))// &quot;[object Symbol]&quot;</code></pre><h3 id="instanceof-操作符的实现原理"><a href="#instanceof-操作符的实现原理" class="headerlink" title="instanceof 操作符的实现原理"></a>instanceof 操作符的实现原理</h3><p>之前我们提到了 <code>instanceof</code> 来判断对象的具体类型，其实 <code>instanceof</code> 主要的作用就是判断一个实例是否属于某种类型</p><pre><code>let person =function(){}let nicole =new person()nicole instanceof person // true</code></pre><p>当然，<code>instanceof</code> 也可以判断一个实例是否是其父类型或者祖先类型的实例。</p><pre><code>let person =function(){}let programmer =function(){}programmer.prototype =new person()let nicole =new programmer()nicole instanceof person // truenicole instanceof programmer // true</code></pre><p>这是 <code>instanceof</code> 的用法，但是 <code>instanceof</code> 的原理是什么呢？根据 ECMAScript 语言规范，我梳理了一下大概的思路，然后整理了一段代码如下</p><pre><code>function new_instance_of(leftVaule, rightVaule){    let rightProto = rightVaule.prototype;// 取右表达式的 prototype 值    leftVaule = leftVaule.__proto__;// 取左表达式的__proto__值    while(true){        if(leftVaule ===null){            returnfalse;            }        if(leftVaule === rightProto){            returntrue;            }        leftVaule = leftVaule.__proto__     }}</code></pre><p><font color="#dd0000">其实 <code>instanceof</code> 主要的实现原理就是只要右边变量的 <code>prototype</code> 在左边变量的原型链上即可。因此，<code>instanceof</code> 在查找的过程中会遍历左边变量的原型链，直到找到右边变量的 <code>prototype</code>，如果查找失败，则会返回 false，告诉我们左边变量并非是右边变量的实例。<br></font><br><br>看几个很有趣的例子</p><pre><code>functionFoo(){}Object instanceof Object// trueFunction instanceof Function// trueFunction instanceof Object// trueFoo instanceof Foo// falseFoo instanceof Object// trueFoo instanceof Function// true</code></pre><p>要想全部理解 <code>instanceof</code> 的原理，除了我们刚刚提到的实现原理，我们还需要知道 JavaScript 的原型继承原理。</p><p>关于原型继承的原理，我简单用一张图来表示</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/meG6Vo0MevjCzDE6dwt2qtltaDsSluC9M8KmmeZsLSJnFTgdTtcCRToR3zWJFYicViaUlvyAGdfwEzADj8Jk8kzQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""><br>我们知道每个 JavaScript 对象均有一个隐式的 <code>__proto__</code> 原型属性，而显式的原型属性是 <code>prototype</code>，只有 <code>Object.prototype.__proto__</code> 属性在未修改的情况下为 null 值。根据图上的原理，我们来梳理上面提到的几个有趣的 <code>instanceof</code> 使用的例子。</p><p><code>Object instanceof Object</code></p><p>由图可知，Object 的 <code>prototype</code> 属性是 <code>Object.prototype</code>, 而由于 Object 本身是一个函数，由 Function 所创建，所以 <code>Object.__proto__</code> 的值是 <code>Function.prototype</code>，而 <code>Function.prototype</code> 的 <code>__proto__</code> 属性是 <code>Object.prototype</code>，所以我们可以判断出，<code>Object instanceof Object</code> 的结果是 true 。用代码简单的表示一下</p><pre><code>leftValue =Object.__proto__ =Function.prototype;rightValue =Object.prototype;// 第一次判断leftValue != rightValueleftValue =Function.prototype.__proto__ =Object.prototype// 第二次判断leftValue === rightValue// 返回 true</code></pre><p><code>Function instanceof Function</code> 和 <code>Function instanceof Object</code> 的运行过程与 <code>Object instanceof Object</code> 类似，故不再详说。</p><p><code>Foo instanceof Foo</code></p><p>Foo 函数的 <code>prototype</code> 属性是 <code>Foo.prototype</code>，而 Foo 的 <code>__proto__</code> 属性是 <code>Function.prototype</code>，由图可知，Foo 的原型链上并没有 <code>Foo.prototype</code> ，因此 <code>Foo instanceof Foo</code> 也就返回 false 。</p><p>我们用代码简单的表示一下</p><pre><code>leftValue =Foo, rightValue =FooleftValue =Foo.__proto =Function.prototyperightValue =Foo.prototype// 第一次判断leftValue != rightValueleftValue =Function.prototype.__proto__ =Object.prototype// 第二次判断leftValue != rightValueleftValue =Object.prototype =null// 第三次判断leftValue ===null// 返回 false</code></pre><p><code>Foo instanceof Object</code></p><pre><code>leftValue =Foo, rightValue =ObjectleftValue =Foo.__proto__ =Function.prototyperightValue =Object.prototype// 第一次判断leftValue != rightValueleftValue =Function.prototype.__proto__ =Object.prototype// 第二次判断leftValue === rightValue// 返回 true </code></pre><p><code>Foo instanceof Function</code></p><pre><code>leftValue =Foo, rightValue =FunctionleftValue =Foo.__proto__ =Function.prototyperightValue =Function.prototype// 第一次判断leftValue === rightValue// 返回 true </code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简单来说，我们使用 <code>typeof</code> 来判断基本数据类型是 ok 的，不过需要注意当用 <code>typeof</code> 来判断 <code>null</code> 类型时的问题，如果想要判断一个对象的具体类型可以考虑用 <code>instanceof</code>，但是 <code>instanceof</code> 也可能判断不准确，比如一个数组，他可以被 <code>instanceof</code> 判断为 Object。所以我们要想比较准确的判断对象实例的类型时，可以采取 <code>Object.prototype.toString.call</code> 方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> typeof </tag>
            
            <tag> instanceof </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跨域之由Request Method:OPTIONS初窥CORS</title>
      <link href="/2018/01/01/%E8%B7%A8%E5%9F%9F%E4%B9%8B%E7%94%B1Request-Method-OPTIONS%E5%88%9D%E7%AA%A5CORS/"/>
      <url>/2018/01/01/%E8%B7%A8%E5%9F%9F%E4%B9%8B%E7%94%B1Request-Method-OPTIONS%E5%88%9D%E7%AA%A5CORS/</url>
      
        <content type="html"><![CDATA[<h2 id="跨域资源共享——CORS"><a href="#跨域资源共享——CORS" class="headerlink" title="跨域资源共享——CORS"></a><a href="https://juejin.im/post/5bfa5f8e6fb9a049a7117b67" target="_blank" rel="noopener">跨域资源共享——CORS</a></h2><h2 id="一篇文章搞明白CORS跨域"><a href="#一篇文章搞明白CORS跨域" class="headerlink" title="一篇文章搞明白CORS跨域"></a><a href="https://segmentfault.com/a/1190000017149446" target="_blank" rel="noopener">一篇文章搞明白CORS跨域</a></h2><h2 id="不就是跨域么-慌个XX-掘金"><a href="#不就是跨域么-慌个XX-掘金" class="headerlink" title="不就是跨域么?慌个XX - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a2f92c65188253e2470f16d" target="_blank" rel="noopener">不就是跨域么?慌个XX - 掘金</a></h2><p>面试问到数据交互的时候，经常会问跨域如何处理。大部分人都会回答JSONP，然后面试官紧接着就会问：“JSONP缺点是什么啊？”这个时候坑就来了，如果面试者说它支持GET方式，然后面试官就会追问，那如果POST方式发送请求怎么办？基础扎实一些的面试者会说，使用CORS跨域，不扎实的可能就摇摇头了。</p><p>这还没结束，如果公司比较正规或者很在乎技术功底，你面试的又是重要岗位，HR还想砍你的工资，就会再补一刀，CORS跨域有什么问题呢？这时候能回答上来的就没几个了，就算是你答出来兼容性不好，需要IE10+浏览器,对方依然有话说，那兼容性怎么处理呢？应试者就没话了，要么被Pass掉，即便留下来，谈工资的时候就没底气了。</p><p>CORS跨域实在是面试官pass一个人的利器。</p><p>为什么会这样呢？</p><ul><li><p>1.遇到CORS请求的情况不多，开发者使用这个场景的很少，大部分都JSONP搞定了。</p></li><li><p>2.开发者自身技能不扎实，偷懒心态，平常没有意识和意愿去提升自己的技术水平。</p></li><li><p>3.相关的学习资料少、纯前端小白搭建可测试的环境难度大。</p></li></ul><p>面对这条拦路虎，我们今天就彻底解决掉它，让它不再是我们的软肋，而是彰显我们技术实力的亮点。</p><h2 id="首先，什么是CORS"><a href="#首先，什么是CORS" class="headerlink" title="首先，什么是CORS?"></a>首先，什么是CORS?</h2><blockquote><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。<br>    它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p></blockquote><p>优缺点</p><p>优点：</p><ul><li>1.支持POST以及所有HTTP请求</li><li>2.安全性相对JSOP更高</li><li>3.前端要做的事儿比较少</li></ul><p>缺点：</p><ul><li>1.不兼容老版本浏览器，如IE9及其以下</li><li>2.需要服务端支持</li><li>3.使用起来稍微复杂了些</li></ul><p>怎么用？</p><p>前端部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;CORS跨域请求&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        function createCORSRequest(method, url) &#123;</span><br><span class="line">            var xhr = new XMLHttpRequest();</span><br><span class="line">            if (&quot;withCredentials&quot; in xhr) &#123;</span><br><span class="line">                xhr.open(method, url, true);</span><br><span class="line">            &#125; else if (typeof XDomainRequest != &quot;undefined&quot;) &#123;</span><br><span class="line">                xhr = new XDomainRequest();</span><br><span class="line">                xhr.open(method, url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                xhr = null;</span><br><span class="line">            &#125;</span><br><span class="line">            return xhr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        window.onload = function () &#123;</span><br><span class="line">            var oBtn = document.getElementById(&apos;btn1&apos;);</span><br><span class="line">            oBtn.onclick = function () &#123;</span><br><span class="line">                var xhr = createCORSRequest(&quot;get&quot;, &quot;http://wpdic.com/cors.php&quot;);</span><br><span class="line">                if (xhr) &#123;</span><br><span class="line">                    xhr.onload = function () &#123;</span><br><span class="line">                        var json = JSON.parse(xhr.responseText);</span><br><span class="line">                        alert(json.a);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    xhr.onerror = function () &#123;</span><br><span class="line">                        alert(&apos;请求失败.&apos;);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    xhr.send();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;获取数据&quot; id=&quot;btn1&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>注意点：</p><p>1.上面代码兼容IE8,因为用了XDomainRequest</p><p>2.其它代码你就当成XMLHttpRequset用，别考虑什么2.0不2.0的</p><p>3.如果你想post数据，可以往 xhr.send()里面搞</p><p>4.这里不建议大家研究”simple methdod”之类的知识，代码弄懂了会用就行，遇到问题了再查也不晚</p><p>后台部分：</p><pre><code>&lt;?phpheader(&apos;content-type:application:json;charset=utf8&apos;);header(&apos;Access-Control-Allow-Origin:*&apos;);header(&apos;Access-Control-Allow-Methods:GET,POST&apos;);header(&apos;Access-Control-Allow-Credentials: true&apos;);header(&apos;Access-Control-Allow-Headers:x-requested-with,content-type&apos;);$str = &apos;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5}&apos;; echo $str;?&gt;</code></pre><p>注意点：</p><p>1.Access-Control-Allow-Origin:<em> 表示允许任何域名跨域访问，如果需要指定某域名才允许跨域访问，只需把Access-Control-Allow-Origin:</em>改为Access-Control-Allow-Origin:允许的域名,实际工作也要这么做2.Access-Control-Allow-Methods:GET,POST  规定允许的方法，建议控制严格些，不要随意放开DELETE之类的权限</p><p>2.Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p>最后，面试常考问题：</p><p>CORS和JSONP的应用场景区别？</p><blockquote><p>CORS要求浏览器(&gt;IE10)和服务器的同时支持，是跨域的根本解决方法，由浏览器自动完成。优点在于功能更加强大支持各种HTTP Method，缺点是兼容性不如JSONP。</p></blockquote><hr><p>刚接触前端的时候，以为HTTP的Request Method只有GET与POST两种，后来才了解到，原来还有HEAD、PUT、DELETE、OPTIONS……</p><p>目前的工作中，HEAD、PUT、DELETE我是真的没有见过……但是OPTIONS几乎天天都会遇到。本地环境跑公司项目的时候，每次POST之前，为啥浏览器还偷偷给我来一次没有返回的OPTIONS请求？</p><blockquote><p>原来，浏览器在某些请求中，在正式通信前会增加一次HTTP查询请求，称为”预检”请求（preflight）。OPTIONS方法是用于请求获得由Request-URI标识的资源在请求/响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。该请求方法的响应不能缓存。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p></blockquote><p>如果这个OPTIONS请求包含一个正文（有Content-Length或Transfer-Encoding存在），则必须有Content-Type来指定媒体类型。虽然规范里没有定义这种正文的用法，但是HTTP将来的扩展可能会用它来查询服务器上更详细的信息。不支持该扩展的服务器可以忽略该请求正文。</p><p>如果该URI是一个星号（“<em>”），OPTIONS请求将试图应用于服务器，而不是某个指定资源。由于服务器的通信选项通常依赖于资源，所以此“</em>”请求只能作为“ping”或者“no-op”方法；或者用来测试服务器的性能。例如，用来测试HTTP/1.1代理。</p><p>如果该URI不是星号，则只能用来获取该资源通信中可用的选项。</p><p>得到的200响应应该包含一个头域，指明服务器实现的和适用于该资源的可选特征（如：Allow），可能还包括该规范尚未定义的扩展。如果有响应正文，则应包含关于通信选项的信息。本规范没有定义该正文格式，但可能在HTTO将来的扩展中定义。可以利用内容协商来选择合适的响应格式。如果没有响应正文，响应必须包含Content-Length，并且值为“0”。</p><p>请求头的Max-Forwards用来请求特定代理。当代理收到一个允许URI转发的OPTIONS请求，则检查Max-Forwards。如果Max-Forwards值为0，则不能转发该消息；相反，代理会将自己的通信选项去响应。如果Max-Forwards是正整数，代理转发请求的时候会将该值减1。如果请求中没有Max-Forwards，转发的请求也不会有。</p><h2 id="简而言之"><a href="#简而言之" class="headerlink" title="简而言之"></a>简而言之</h2><p>OPTIONS请求方法的主要用途有两个：</p><p>1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。</p><p>2、用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个HTTP OPTIONS请求头，用以判断实际发送的请求是否安全。<br><img src="https://pic3.zhimg.com/v2-8f8d34a757502c306d82fa44f4645068_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8f8d34a757502c306d82fa44f4645068_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-38b8f2ec0da0115511cee8a1b604c6a4_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-38b8f2ec0da0115511cee8a1b604c6a4_hd.jpg" alt=""><br>如上两张图片，图2就是本地环境，本地环境请求接口的时候，每次请求接口之前都会多一次OPTIONS请求。</p><p><img src="https://pic4.zhimg.com/v2-31c4436fae8e077e9d935ac58bd861d6_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-31c4436fae8e077e9d935ac58bd861d6_hd.jpg" alt=""></p><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p><p>它允许浏览器向跨源服务器，发出<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html" target="_blank" rel="noopener">XMLHttpRequest</a>请求，从而克服了AJAX只能<a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。</p><blockquote><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<br>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。<br>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p></blockquote><h2 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h2><p>浏览器将CORS请求分为两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>同时满足以下条件，就是简单请求：</p><blockquote><p>（1) 请求方法是以下三种方法之一：</p></blockquote><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul><h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p><p>Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。都以Access-Control- 开头：</p><p>（1）Access-Control-Allow-Origin</p><p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p><blockquote><p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p></blockquote><p>（2）Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p>（3）Access-Control-Expose-Headers</p><p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</p><h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p><p>我工作中写的所有页面拉的接口都是非简单请求。<br><img src="https://pic1.zhimg.com/v2-6749c6523db660ed4e194e16779c5fa3_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-6749c6523db660ed4e194e16779c5fa3_hd.jpg" alt=""><br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>在页面域名与接口域名不一致的情况下，就出现了每次请求前先发送一个options请求的问题。</p><p>OPTIONS请求头信息中，除了Origin字段，还至少会多两个特殊字段：</p><p>（1）Access-Control-Request-Method</p><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</p><p>（2）Access-Control-Request-Headers</p><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</p><p><img src="https://pic3.zhimg.com/v2-da5ae04890068d4ffc9f4714e48719dd_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-da5ae04890068d4ffc9f4714e48719dd_hd.jpg" alt=""><br>至于其他乱七八糟的字段，现在的我还用不到也不懂，将会慢慢深入了解。</p><p>服务器收到预检请求后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p><p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="https://link.zhihu.com/?target=http%3A//lizard.qa.nt.ctripcorp.com" target="_blank" rel="noopener">http://lizard.qa.nt.ctripcorp.com</a>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p><p>XMLHttpRequest cannot load <a href="https://link.zhihu.com/?target=http%3A//lizard.qa.nt.ctripcorp.com" target="_blank" rel="noopener">http://lizard.qa.nt.ctripcorp.com</a><br>Origin <a href="https://link.zhihu.com/?target=http%3A//lizard.qa.nt.ctripcorp.com" target="_blank" rel="noopener">http://lizard.qa.nt.ctripcorp.com</a> is not allowed by Access-Control-Allow-Origin.</p><p>其他字段中Access-Control-Max-Age 用来指定本次预检请求的有效期，单位为秒。该字段可选。</p><h2 id="与JSONP的对比"><a href="#与JSONP的对比" class="headerlink" title="与JSONP的对比"></a>与JSONP的对比</h2><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，JSONP的优势在于支持老旧浏览器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>44个JavaScript 变态题解析</title>
      <link href="/2017/12/31/44%E4%B8%AAJavaScript-%E5%8F%98%E6%80%81%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/12/31/44%E4%B8%AAJavaScript-%E5%8F%98%E6%80%81%E9%A2%98%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/12/31/44个JavaScript-变态题解析/1.jpg" alt=""></p><h2 id="第1题"><a href="#第1题" class="headerlink" title="第1题"></a>第1题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</span><br></pre></td></tr></table></figure><p>知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Fmap" target="_blank" rel="noopener">Array/map</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FNumber%2FparseInt" target="_blank" rel="noopener">Number/parseInt</a></li><li><p><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.w3school.com.cn%2Fjsref%2Fjsref_parseInt.asp" target="_blank" rel="noopener">JavaScript parseInt</a></p><p>首先, map接受两个参数, 一个回调函数 callback, 一个回调函数的this值</p><p>其中回调函数接受三个参数 currentValue, index, arrary;</p><p>而题目中, map只传入了回调函数–parseInt.</p><p>其次, parseInt 只接受两个两个参数 string, radix(基数).</p></li></ul><blockquote><p> 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。<br> 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。<br> 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</p></blockquote><p> 所以本题即问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&apos;1&apos;, 0);</span><br><span class="line">parseInt(&apos;2&apos;, 1);</span><br><span class="line">parseInt(&apos;3&apos;, 2);</span><br></pre></td></tr></table></figure></p><p> 首先后两者参数不合法.</p><p> 所以答案是 [1, NaN, NaN]</p><h2 id="第2题"><a href="#第2题" class="headerlink" title="第2题"></a>第2题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[typeof null, null instanceof Object]</span><br></pre></td></tr></table></figure><p> 两个知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Ftypeof" target="_blank" rel="noopener">Operators/typeof</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Finstanceof" target="_blank" rel="noopener">Operators/instanceof</a></li><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Finstanceof" target="_blank" rel="noopener">Operators/instanceof(中)</a></p><p>typeof 返回一个表示类型的字符串.</p><p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上.</p><p>这个题可以直接看链接… 因为 typeof null === ‘object’ 自语言之初就是这样….</p></li></ul><p>typeof 的结果请看下表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type         result</span><br><span class="line">Undefined   &quot;undefined&quot;</span><br><span class="line">Null        &quot;object&quot;</span><br><span class="line">Boolean     &quot;boolean&quot;</span><br><span class="line">Number      &quot;number&quot;</span><br><span class="line">String      &quot;string&quot;</span><br><span class="line">Symbol      &quot;symbol&quot;</span><br><span class="line">Host object Implementation-dependent</span><br><span class="line">Function    &quot;function&quot;</span><br><span class="line">Object      &quot;object&quot;</span><br></pre></td></tr></table></figure></p><p> 所以答案 [object, false]</p><h2 id="第3题"><a href="#第3题" class="headerlink" title="第3题"></a>第3题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</span><br></pre></td></tr></table></figure><p> 知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2FReduce" target="_blank" rel="noopener">Array/Reduce</a></li></ul><p>arr.reduce(callback[, initialValue])</p><p>reduce接受两个参数, 一个回调, 一个初始值.</p><p>回调函数接受四个参数 previousValue, currentValue, currentIndex, array</p><p>需要注意的是 If the array is empty and no initialValue was provided, TypeError would be thrown.</p><p>所以第二个表达式会报异常. 第一个表达式等价于 Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</p><p>答案 an error</p><h2 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var val = &apos;smtg&apos;;</span><br><span class="line">console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;);</span><br></pre></td></tr></table></figure><p> 两个知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FOperator_Precedence" target="_blank" rel="noopener">Operators/Operator_Precedence</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FConditional_Operator" target="_blank" rel="noopener">Operators/Conditional_Operator</a></li></ul><p>简而言之 + 的优先级 大于 ?</p><p>所以原题等价于 ‘Value is true’ ? ‘Somthing’ : ‘Nonthing’ 而不是 ‘Value is’ + (true ? ‘Something’ : ‘Nonthing’)</p><p>答案 ‘Something’</p><h2 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;World!&apos;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class="line">        var name = &apos;Jack&apos;;</span><br><span class="line">        console.log(&apos;Goodbye &apos; + name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Hello &apos; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p> 这个相对简单, 一个知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FGlossary%2FHoisting" target="_blank" rel="noopener">Hoisting</a></p><p>在 JavaScript中， functions 和 variables 会被提升。变量提升是JavaScript将声明移至作用域 scope (全局域或者当前函数作用域) 顶部的行为。</p></li></ul><p>这个题目相当于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;World!&apos;;</span><br><span class="line">(function () &#123;</span><br><span class="line">    var name;</span><br><span class="line">    if (typeof name === &apos;undefined&apos;) &#123;</span><br><span class="line">        name = &apos;Jack&apos;;</span><br><span class="line">        console.log(&apos;Goodbye &apos; + name);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&apos;Hello &apos; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p> 所以答案是 ‘Goodbye Jack’</p><h2 id="第6题"><a href="#第6题" class="headerlink" title="第6题"></a>第6题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var END = Math.pow(2, 53);</span><br><span class="line">var START = END - 100;</span><br><span class="line">var count = 0;</span><br><span class="line">for (var i = START; i &lt;= END; i++) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line">console.log(count);</span><br></pre></td></tr></table></figure><p> 一个知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FInfinity" target="_blank" rel="noopener">Infinity</a></p><p>在 JS 里, Math.pow(2, 53) == 9007199254740992 是可以表示的最大值. 最大值加一还是最大值. 所以循环不会停.</p></li></ul><h2 id="第7题"><a href="#第7题" class="headerlink" title="第7题"></a>第7题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var ary = [0,1,2];</span><br><span class="line">ary[10] = 10;</span><br><span class="line">ary.filter(function(x) &#123; return x === undefined;&#125;);</span><br></pre></td></tr></table></figure><p>答案是 []</p><p> 看一篇文章理解稀疏数组</p><ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fziyunfei%2Farchive%2F2012%2F09%2F16%2F2687165.html" target="_blank" rel="noopener">译 JavaScript中的稀疏数组与密集数组</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Ffilter" target="_blank" rel="noopener">Array/filter</a></li></ul><p>我们来看一下 Array.prototype.filter 的 polyfill:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">if (!Array.prototype.filter) &#123;</span><br><span class="line">  Array.prototype.filter = function(fun/*, thisArg*/) &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">    if (this === void 0 || this === null) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var t = Object(this);</span><br><span class="line">    var len = t.length &gt;&gt;&gt; 0;</span><br><span class="line">    if (typeof fun !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new TypeError();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var res = [];</span><br><span class="line">    var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0;</span><br><span class="line">    for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">      if (i in t) &#123; // 注意这里!!!</span><br><span class="line">        var val = t[i];</span><br><span class="line">        if (fun.call(thisArg, val, i, t)) &#123;</span><br><span class="line">          res.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 我们看到在迭代这个数组的时候, 首先检查了这个索引值是不是数组的一个属性, 那么我们测试一下.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 in ary; =&gt; true</span><br><span class="line">3 in ary; =&gt; false</span><br><span class="line">10 in ary; =&gt; true</span><br></pre></td></tr></table></figure></p><p>也就是说 从 3 - 9 都是没有初始化的’坑’!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些’坑’的.</p><h2 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h2><pre><code>var two   = 0.2var one   = 0.1var eight = 0.8var six   = 0.6[two - one == one, eight - six == two]</code></pre><ul><li><p><a href="https://link.juejin.im?target=http%3A%2F%2Fourjs.com%2Fdetail%2F54695381bc3f9b154e000046" target="_blank" rel="noopener">JavaScript的设计缺陷?浮点运算：0.1 + 0.2 != 0.3</a></p><p>IEEE 754标准中的浮点数并不能精确地表达小数</p><p>那什么时候精准, 什么时候不经准呢? 笔者也不知道…</p><p>答案 [true, false]</p></li></ul><h2 id="第9题"><a href="#第9题" class="headerlink" title="第9题"></a>第9题</h2><pre><code>function showCase(value) {    switch(value) {    case &apos;A&apos;:        console.log(&apos;Case A&apos;);        break;    case &apos;B&apos;:        console.log(&apos;Case B&apos;);        break;    case undefined:        console.log(&apos;undefined&apos;);        break;    default:        console.log(&apos;Do not know!&apos;);    }}showCase(new String(&apos;A&apos;));</code></pre><p> 两个知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fswitch" target="_blank" rel="noopener">Statements/switch</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString" target="_blank" rel="noopener">String</a></li></ul><p>switch 是严格比较, String 实例和 字符串不一样.</p><pre><code>var s_prim = &apos;foo&apos;;var s_obj = new String(s_prim);console.log(typeof s_prim); // &quot;string&quot;console.log(typeof s_obj);  // &quot;object&quot;console.log(s_prim === s_obj); // false</code></pre><p> 答案是 ‘Do not know!’</p><h2 id="第10题"><a href="#第10题" class="headerlink" title="第10题"></a>第10题</h2><pre><code>function showCase2(value) {    switch(value) {    case &apos;A&apos;:        console.log(&apos;Case A&apos;);        break;    case &apos;B&apos;:        console.log(&apos;Case B&apos;);        break;    case undefined:        console.log(&apos;undefined&apos;);        break;    default:        console.log(&apos;Do not know!&apos;);    }}showCase2(String(&apos;A&apos;));</code></pre><p>解释:<br> String(x) does not create an object but does return a string, i.e. typeof String(1) === “string”</p><p>还是刚才的知识点, 只不过 String 不仅是个构造函数 直接调用返回一个字符串哦.</p><p> 答案 ‘Case A’</p><h2 id="第11题"><a href="#第11题" class="headerlink" title="第11题"></a>第11题</h2><pre><code>function isOdd(num) {    return num % 2 == 1;}function isEven(num) {    return num % 2 == 0;}function isSane(num) {    return isEven(num) || isOdd(num);}var values = [7, 4, &apos;13&apos;, -9, Infinity];values.map(isSane);</code></pre><p> 一个知识点</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FArithmetic_Operators%23Remainder" target="_blank" rel="noopener">Arithmetic_Operators#Remainder</a></li></ul><p>此题等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7 % 2 =&gt; 1</span><br><span class="line">4 % 2 =&gt; 0</span><br><span class="line">&apos;13&apos; % 2 =&gt; 1</span><br><span class="line">-9 % % 2 =&gt; -1</span><br><span class="line">Infinity % 2 =&gt; NaN</span><br></pre></td></tr></table></figure></p><p> 需要注意的是 余数的正负号随第一个操作数.</p><p> 答案 [true, true, true, false, false]</p><h2 id="第12题"><a href="#第12题" class="headerlink" title="第12题"></a>第12题</h2><pre><code>parseInt(3, 8)parseInt(3, 2)parseInt(3, 0)</code></pre><p> 第一个题讲过了, 答案 3, NaN, 3</p><h2 id="第13题"><a href="#第13题" class="headerlink" title="第13题"></a>第13题</h2><pre><code>Array.isArray( Array.prototype )</code></pre><p> 一个知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Fprototype" target="_blank" rel="noopener">Array/prototype</a></p><p>一个鲜为人知的实事: Array.prototype =&gt; [];</p><p>答案: true</p></li></ul><h2 id="第14题"><a href="#第14题" class="headerlink" title="第14题"></a>第14题</h2><pre><code>var a = [0];if ([0]) {  console.log(a == true);} else {  console.log(&quot;wut&quot;);}</code></pre><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdorey.github.io%2FJavaScript-Equality-Table%2F" target="_blank" rel="noopener">JavaScript-Equality-Table</a></p><p>答案: false</p></li></ul><h2 id="第15题"><a href="#第15题" class="headerlink" title="第15题"></a>第15题</h2><pre><code>[]==[]</code></pre><p> == 是万恶之源, 看上图</p><p> 答案是 false</p><h2 id="第16题"><a href="#第16题" class="headerlink" title="第16题"></a>第16题</h2><pre><code>&apos;5&apos; + 3&apos;5&apos; - 3</code></pre><p> 两个知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FArithmetic_Operators%23Addition" target="_blank" rel="noopener">Arithmetic_Operators#Addition</a></li><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FArithmetic_Operators%23Subtraction" target="_blank" rel="noopener">Arithmetic_Operators#Subtraction</a></p><ul><li>用来表示两个数的和或者字符串拼接, -表示两数之差.</li></ul></li></ul><p>请看例子, 体会区别:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; &apos;5&apos; + 3</span><br><span class="line">&apos;53&apos;</span><br><span class="line">&gt; 5 + &apos;3&apos;</span><br><span class="line">&apos;53&apos;</span><br><span class="line">&gt; 5 - &apos;3&apos;</span><br><span class="line">2</span><br><span class="line">&gt; &apos;5&apos; - 3</span><br><span class="line">2</span><br><span class="line">&gt; &apos;5&apos; - &apos;3&apos;</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><p> 也就是说 - 会尽可能的将两个操作数变成数字, 而 + 如果两边不都是数字, 那么就是字符串拼接.</p><p> 答案是 ‘53’, 2</p><h2 id="第17题"><a href="#第17题" class="headerlink" title="第17题"></a>第17题</h2><pre><code>1 + - + + + - + 1</code></pre><p> 这里应该是(倒着看)</p><pre><code>1 + (a)  =&gt; 2a = - (b) =&gt; 1b = + (c) =&gt; -1c = + (d) =&gt; -1d = + (e) =&gt; -1e = + (f) =&gt; -1f = - (g) =&gt; -1g = + 1   =&gt; 1</code></pre><p> 所以答案 2</p><h2 id="第18题"><a href="#第18题" class="headerlink" title="第18题"></a>第18题</h2><pre><code>var ary = Array(3);ary[0]=2ary.map(function(elem) { return &apos;1&apos;; });</code></pre><p> 稀疏数组. 同第7题.</p><p> 题目中的数组其实是一个长度为3, 但是没有内容的数组, array 上的操作会跳过这些未初始化的’坑’.</p><p> 所以答案是 [“1”, undefined × 2]</p><p> 这里贴上 Array.prototype.map 的 polyfill.</p><pre><code>Array.prototype.map = function(callback, thisArg) {        var T, A, k;        if (this == null) {            throw new TypeError(&apos; this is null or not defined&apos;);        }        var O = Object(this);        var len = O.length &gt;&gt;&gt; 0;        if (typeof callback !== &apos;function&apos;) {            throw new TypeError(callback + &apos; is not a function&apos;);        }        if (arguments.length &gt; 1) {            T = thisArg;        }        A = new Array(len);        k = 0;        while (k &lt; len) {            var kValue, mappedValue;            if (k in O) {                kValue = O[k];                mappedValue = callback.call(T, kValue, k, O);                A[k] = mappedValue;            }            k++;        }        return A;    };</code></pre><h2 id="第19题"><a href="#第19题" class="headerlink" title="第19题"></a>第19题</h2><pre><code>function sidEffecting(ary) {  ary[0] = ary[2];}function bar(a,b,c) {  c = 10  sidEffecting(arguments);  return a + b + c;}bar(1,1,1)</code></pre><p> 这是一个大坑, 尤其是涉及到 ES6语法的时候</p><p> 知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2Farguments" target="_blank" rel="noopener">Functions/arguments</a></li></ul><p>首先 The arguments object is an Array-like object corresponding to the arguments passed to a function.</p><p>也就是说 arguments 是一个 object, c 就是 arguments[2], 所以对于 c 的修改就是对 arguments[2] 的修改.</p><p>所以答案是 21.</p><p>然而!!!!!!</p><p>当函数参数涉及到 any rest parameters, any default parameters or any destructured parameters 的时候, 这个 arguments 就不在是一个 mapped arguments object 了…..</p><p>请看:</p><pre><code>function sidEffecting(ary) {  ary[0] = ary[2];}function bar(a,b,c=3) {  c = 10  sidEffecting(arguments);  return a + b + c;}bar(1,1,1)</code></pre><p> 答案是 12 !!!!</p><p> 请读者细细体会!!</p><h2 id="第20题"><a href="#第20题" class="headerlink" title="第20题"></a>第20题</h2><pre><code>var a = 111111111111111110000,    b = 1111;a + b;</code></pre><p> 答案还是 111111111111111110000. 解释是 Lack of precision for numbers in JavaScript affects both small and big numbers. 但是笔者不是很明白……………. 请读者赐教!</p><h2 id="第21题"><a href="#第21题" class="headerlink" title="第21题"></a>第21题</h2><pre><code>var x = [].reverse;x();</code></pre><p> 这个题有意思!</p><p> 知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2Freverse" target="_blank" rel="noopener">Array/reverse</a></p><p>The reverse method transposes the elements of the calling array object in place, mutating the array, and returning a reference to the array.</p><p>也就是说 最后会返回这个调用者(this), 可是 x 执行的时候是上下文是全局. 那么最后返回的是 window.</p><p>答案是 window</p></li></ul><h2 id="第22题"><a href="#第22题" class="headerlink" title="第22题"></a>第22题</h2><pre><code>Number.MIN_VALUE &gt; 0</code></pre><p> true</p><h2 id="第23题"><a href="#第23题" class="headerlink" title="第23题"></a>第23题</h2><pre><code>[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</code></pre><p> 这个题也还可以.</p><p> 这个题会让人误以为是 2 &gt; 1 &amp;&amp; 2 &lt; 3 其实不是的.</p><p> 这个题等价于</p><pre><code>1 &lt; 2 =&gt; true;true &lt; 3 =&gt;  1 &lt; 3 =&gt; true;3 &lt; 2 =&gt; false;false &lt; 1 =&gt; 0 &lt; 1 =&gt; true;</code></pre><p> 答案是 [true, true]</p><h2 id="第24题"><a href="#第24题" class="headerlink" title="第24题"></a>第24题</h2><pre><code>// the most classic wtf2 == [[[2]]]</code></pre><p> 这个题我是猜的. 我猜的 true, 至于为什么…..</p><p> both objects get converted to strings and in both cases the resulting string is “2” 我不能信服…</p><h2 id="第25题"><a href="#第25题" class="headerlink" title="第25题"></a>第25题</h2><pre><code>3.toString()3..toString()3...toString()</code></pre><p> 这个题也挺逗, 我做对了 :) 答案是 error, ‘3’, error</p><p> 你如果换一个写法就更费解了</p><pre><code>var a = 3;a.toString()</code></pre><p> 这个答案就是 ‘3’;</p><p> 为啥呢?</p><p> 因为在 js 中 1.1, 1., .1 都是合法的数字. 那么在解析 3.toString 的时候这个 . 到底是属于这个数字还是函数调用呢? 只能是数字, 因为3.合法啊!</p><h2 id="第26题"><a href="#第26题" class="headerlink" title="第26题"></a>第26题</h2><pre><code>(function(){  var x = y = 1;})();console.log(y);console.log(x);</code></pre><p> 答案是 1, error</p><p> y 被赋值到全局. x 是局部变量. 所以打印 x 的时候会报 ReferenceError</p><h2 id="第27题"><a href="#第27题" class="headerlink" title="第27题"></a>第27题</h2><pre><code>var a = /123/,    b = /123/;a == ba === b</code></pre><p> 即使正则的字面量一致, 他们也不相等.</p><p> 答案 false, false</p><h2 id="第28题"><a href="#第28题" class="headerlink" title="第28题"></a>第28题</h2><pre><code>var a = [1, 2, 3],    b = [1, 2, 3],    c = [1, 2, 4]a ==  ba === ba &gt;   ca &lt;   c</code></pre><p> 字面量相等的数组也不相等.</p><p> 数组在比较大小的时候按照字典序比较</p><p> 答案 false, false, false, true</p><h2 id="第29题"><a href="#第29题" class="headerlink" title="第29题"></a>第29题</h2><pre><code>var a = {}, b = Object.prototype;[a.prototype === b, Object.getPrototypeOf(a) === b]</code></pre><p> 知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FObject%2FgetPrototypeOf" target="_blank" rel="noopener">Object/getPrototypeOf</a></p><p>只有 Function 拥有一个 prototype 的属性. 所以 a.prototype 为 undefined.</p><p>而 Object.getPrototypeOf(obj) 返回一个具体对象的原型(该对象的内部[[prototype]]值)</p><p>答案 false, true</p></li></ul><h2 id="第30题"><a href="#第30题" class="headerlink" title="第30题"></a>第30题</h2><pre><code>function f() {}var a = f.prototype, b = Object.getPrototypeOf(f);a === b</code></pre><p> f.prototype is the object that will become the parent of any objects created with new f while Object.getPrototypeOf returns the parent in the inheritance hierarchy.</p><p> f.prototype 是使用使用 new 创建的 f 实例的原型. 而 Object.getPrototypeOf 是 f 函数的原型.</p><p> 请看:</p><pre><code>a === Object.getPrototypeOf(new f()) // trueb === Function.prototype // true</code></pre><p> 答案 false</p><h2 id="31"><a href="#31" class="headerlink" title="31"></a>31</h2><pre><code>function foo() { }var oldName = foo.name;foo.name = &quot;bar&quot;;[oldName, foo.name]</code></pre><p> 答案 [‘foo’, ‘foo’]</p><p> 知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname" target="_blank" rel="noopener">Function/name</a></p><p>因为函数的名字不可变.</p></li></ul><h2 id="第32题"><a href="#第32题" class="headerlink" title="第32题"></a>第32题</h2><pre><code>&quot;1 2 3&quot;.replace(/\d/g, parseInt)</code></pre><p> 知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString%2Freplace%23Specifying_a_function_as_a_parameter" target="_blank" rel="noopener">String/replace#Specifying_a_function_as_a_parameter</a></p><p>str.replace(regexp|substr, newSubStr|function)</p><p>如果replace函数传入的第二个参数是函数, 那么这个函数将接受如下参数</p></li><li><p>match 首先是匹配的字符串</p></li><li>p1, p2 …. 然后是正则的分组</li><li>offset match 匹配的index</li><li>string 整个字符串</li></ul><p>由于题目中的正则没有分组, 所以等价于问</p><pre><code>parseInt(&apos;1&apos;, 0)parseInt(&apos;2&apos;, 2)parseInt(&apos;3&apos;, 4)</code></pre><p> 答案: 1, NaN, 3</p><h2 id="第33题"><a href="#第33题" class="headerlink" title="第33题"></a>第33题</h2><pre><code>function f() {}var parent = Object.getPrototypeOf(f);f.name // ?parent.name // ?typeof eval(f.name) // ?typeof eval(parent.name) //  ?</code></pre><p> 先说以下答案 ‘f’, ‘Empty’, ‘function’, error 这个答案并不重要…..</p><p> 这里第一小问和第三小问很简单不解释了.</p><p> 第二小问笔者在自己的浏览器测试的时候是 ‘’, 第四问是 ‘undefined’</p><p> 所以应该是平台相关的. 这里明白 parent === Function.prototype 就好了.</p><h2 id="第34题"><a href="#第34题" class="headerlink" title="第34题"></a>第34题</h2><pre><code>var lowerCaseOnly =  /^[a-z]+$/;[lowerCaseOnly.test(null), lowerCaseOnly.test()]</code></pre><p> 知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FRegExp%2Ftest" target="_blank" rel="noopener">RegExp/test</a></p><p>这里 test 函数会将参数转为字符串. ‘nul’, ‘undefined’ 自然都是全小写了</p><p>答案: true, true</p></li></ul><h2 id="第35题"><a href="#第35题" class="headerlink" title="第35题"></a>第35题</h2><pre><code>[,,,].join(&quot;, &quot;)</code></pre><p> [,,,] =&gt; [undefined × 3]</p><p> 因为javascript 在定义数组的时候允许最后一个元素后跟一个,, 所以这是个长度为三的稀疏数组(这是长度为三, 并没有 0, 1, 2三个属性哦)</p><p> 答案: “, , “</p><h2 id="第36题"><a href="#第36题" class="headerlink" title="第36题"></a>第36题</h2><pre><code>var a = {class: &quot;Animal&quot;, name: &apos;Fido&apos;};a.class</code></pre><p> 这个题比较流氓.. 因为是浏览器相关, class是个保留字(现在是个关键字了)</p><p> 所以答案不重要, 重要的是自己在取属性名称的时候尽量避免保留字. 如果使用的话请加引号 a[‘class’]</p><h2 id="第37题"><a href="#第37题" class="headerlink" title="第37题"></a>第37题</h2><pre><code>var a = new Date(&quot;epoch&quot;)</code></pre><p> 知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FDate" target="_blank" rel="noopener">Date</a></li><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FDate%2Fparse" target="_blank" rel="noopener">Date/parse</a></p><p>简单来说, 如果调用 Date 的构造函数传入一个字符串的话需要符合规范, 即满足 Date.parse 的条件.</p><p>另外需要注意的是 如果格式错误 构造函数返回的仍是一个Date 的实例 Invalid Date.</p><p>答案 Invalid Date</p></li></ul><h2 id="第38题"><a href="#第38题" class="headerlink" title="第38题"></a>第38题</h2><pre><code>var a = Function.length,    b = new Function().lengtha === b</code></pre><p> 我们知道一个function(Function 的实例)的 length 属性就是函数签名的参数个数, 所以 b.length == 0.</p><p> 另外 Function.length 定义为1……</p><p> 所以不相等…….答案 false</p><h2 id="第39题"><a href="#第39题" class="headerlink" title="第39题"></a>第39题</h2><pre><code>var a = Date(0);var b = new Date(0);var c = new Date();[a === b, b === c, a === c]</code></pre><p> 还是关于Date 的题, 需要注意的是</p><ul><li>如果不传参数等价于当前时间.</li><li><p>如果是函数调用 返回一个字符串.</p><p>答案 false, false, false</p></li></ul><h2 id="第40题"><a href="#第40题" class="headerlink" title="第40题"></a>第40题</h2><pre><code>var min = Math.min(), max = Math.max()min &lt; max</code></pre><p> 知识点:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FMath%2Fmin" target="_blank" rel="noopener">Math/min</a></li><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FMath%2Fmax" target="_blank" rel="noopener">Math/max</a></p><p>有趣的是, Math.min 不传参数返回 Infinity, Math.max 不传参数返回 -Infinity😆</p><p>答案: false</p></li></ul><h2 id="第41题"><a href="#第41题" class="headerlink" title="第41题"></a>第41题</h2><pre><code>function captureOne(re, str) {  var match = re.exec(str);  return match &amp;&amp; match[1];}var numRe  = /num=(\d+)/ig,    wordRe = /word=(\w+)/i,    a1 = captureOne(numRe,  &quot;num=1&quot;),    a2 = captureOne(wordRe, &quot;word=1&quot;),    a3 = captureOne(numRe,  &quot;NUM=2&quot;),    a4 = captureOne(wordRe,  &quot;WORD=2&quot;);[a1 === a2, a3 === a4]</code></pre><p> 知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FRegExp%2Fexec" target="_blank" rel="noopener">RegExp/exec</a></p><p>通俗的讲</p><p>因为第一个正则有一个 g 选项 它会‘记忆’他所匹配的内容, 等匹配后他会从上次匹配的索引继续, 而第二个正则不会</p></li></ul><p>举个例子</p><pre><code>var myRe = /ab*/g;var str = &apos;abbcdefabh&apos;;var myArray;while ((myArray = myRe.exec(str)) !== null) {  var msg = &apos;Found &apos; + myArray[0] + &apos;. &apos;;  msg += &apos;Next match starts at &apos; + myRe.lastIndex;  console.log(msg);}// Found abb. Next match starts at 3// Found ab. Next match starts at 9</code></pre><p> 所以 a1 = ‘1’; a2 = ‘1’; a3 = null; a4 = ‘2’</p><p> 答案 [true, false]</p><h2 id="第42题"><a href="#第42题" class="headerlink" title="第42题"></a>第42题</h2><pre><code>var a = new Date(&quot;2014-03-19&quot;),    b = new Date(2014, 03, 19);[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]</code></pre><p> 这个….</p><blockquote><p> JavaScript inherits 40 years old design from C: days are 1-indexed in C’s struct tm, but months are 0 indexed. In addition to that, getDay returns the 0-indexed day of the week, to get the 1-indexed day of the month you have to use getDate,<br>                    which doesn’t return a Date object.</p></blockquote><pre><code>a.getDay()3b.getDay()6a.getMonth()2b.getMonth()3</code></pre><p> 都是套路!</p><p> 答案 [false, false]</p><h2 id="第43题"><a href="#第43题" class="headerlink" title="第43题"></a>第43题</h2><pre><code>if (&apos;http://giftwrapped.com/picture.jpg&apos;.match(&apos;.gif&apos;)) {  &apos;a gif file&apos;} else {  &apos;not a gif file&apos;}</code></pre><p> 知识点:</p><ul><li><p><a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FString%2Fmatch" target="_blank" rel="noopener">String/match</a></p><p>String.prototype.match 接受一个正则, 如果不是, 按照 new RegExp(obj) 转化. 所以 . 并不会转义<br>那么 /gif 就匹配了 /.gif/</p><p>答案: ‘a gif file’</p></li></ul><h2 id="第44题"><a href="#第44题" class="headerlink" title="第44题"></a>第44题</h2><pre><code>function foo(a) {    var a;    return a;}function bar(a) {    var a = &apos;bye&apos;;    return a;}[foo(&apos;hello&apos;), bar(&apos;hello&apos;)]</code></pre><p> 在两个函数里, a作为参数其实已经声明了, 所以 var a; var a = ‘bye’ 其实就是 a; a =’bye’</p><p> 所以答案 ‘hello’, ‘bye’</p><p> 全部结束!</p><hr><h2 id="JS-花式编程"><a href="#JS-花式编程" class="headerlink" title="JS 花式编程"></a><a href="http://jartto.wang/2017/10/18/js-fancy-programming/" target="_blank" rel="noopener">JS 花式编程</a></h2><p>炫技可能是程序员的癖好，加之 JS 的神奇 Feature，所以各种编程中的奇技淫巧层出不穷。最近看了几篇挺火的文章，觉得挺有意思，特此收集。</p><h3 id="在-if-中使用逗号表达式"><a href="#在-if-中使用逗号表达式" class="headerlink" title="在 if 中使用逗号表达式"></a>在 if 中使用逗号表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(let a = 1, let b = a) console.log(b);</span><br></pre></td></tr></table></figure><p>Jartto: 值得一提的是，逗号表达式会执行每一部分，而结果是逗号后部分。</p><h3 id="有趣的-try-catch"><a href="#有趣的-try-catch" class="headerlink" title="有趣的 try catch"></a>有趣的 try catch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line"></span><br><span class="line">    something</span><br><span class="line"></span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line"></span><br><span class="line">    window.location.href =</span><br><span class="line"></span><br><span class="line">        &quot;http://stackoverflow.com/search?q=[js]+&quot; +</span><br><span class="line"></span><br><span class="line">        e.message;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.random().toString(16).substring(2) // &quot;5c31298e546e2&quot;</span><br><span class="line">Math.random().toString(36).substring(2) // &quot;isx80x30s2&quot;</span><br></pre></td></tr></table></figure><p>Jartto: 我如果没记错，这是某企业的笔试题。</p><h3 id="JS-中-void-的使用"><a href="#JS-中-void-的使用" class="headerlink" title="JS 中 void 的使用"></a><code>JS</code> 中 <code>void</code> 的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let data = void0; // undefined</span><br></pre></td></tr></table></figure><p>Jartto: void在JavaScript中是一个操作符，对传入的操作不执行并且返回 undefined。</p><p>我们经常在 <code>href</code> 中写 <code>javascript:void(0)</code>，其实通过 <code>void</code> 来操作不执行。</p><h3 id="隐式取整"><a href="#隐式取整" class="headerlink" title="隐式取整"></a>隐式取整</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let a = ~~2.33; // 2</span><br><span class="line"></span><br><span class="line">let b = 2.33 | 0; // 2</span><br><span class="line"></span><br><span class="line">let c = 2.33 &gt;&gt; 0; // 2</span><br></pre></td></tr></table></figure><h3 id="金钱格式化-1-234-567-890"><a href="#金钱格式化-1-234-567-890" class="headerlink" title="金钱格式化 1,234,567,890"></a>金钱格式化 <code>1,234,567,890</code></h3><p>方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Let test1 = &apos;1234567890&apos;;</span><br><span class="line"></span><br><span class="line">Let format = test1.replace(/\B(?=(\d&#123;3&#125;)+(?!\d))/g, &apos;,&apos;);</span><br><span class="line"></span><br><span class="line">console.log(format); // 1,234,567,890</span><br></pre></td></tr></table></figure></p><p>方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">functionformatCash(str) &#123;</span><br><span class="line"></span><br><span class="line">return str.split(&apos;&apos;).reverse().reduce((prev, next, index) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">return ((index % 3) ? next : (next + &apos;,&apos;)) + prev;</span><br><span class="line"></span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(formatCash(&apos;1234567890&apos;)); // 1,234,567,890</span><br></pre></td></tr></table></figure></p><p>方式三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Number(1234567890).toLocaleString();</span><br></pre></td></tr></table></figure></p><h3 id="隐式转换字符串类型成数字"><a href="#隐式转换字符串类型成数字" class="headerlink" title="隐式转换字符串类型成数字"></a>隐式转换字符串类型成数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = &apos;1a&apos;;</span><br><span class="line"></span><br><span class="line">console.log(+a); // NaN</span><br></pre></td></tr></table></figure><p>等价于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let b = Number(&apos;1a&apos;);</span><br><span class="line"></span><br><span class="line">console.log(b); // NaN</span><br></pre></td></tr></table></figure></p><p>Jartto: 规范编程的话，请避免隐式转换，众所周知，隐式转换不符合语意化编程。</p><h3 id="隐式转换布尔类型"><a href="#隐式转换布尔类型" class="headerlink" title="隐式转换布尔类型"></a>隐式转换布尔类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let b = !! a;</span><br></pre></td></tr></table></figure><h3 id="注意-parseInt"><a href="#注意-parseInt" class="headerlink" title="注意 parseInt"></a>注意 <code>parseInt</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(0.0000007) === 7// true</span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...new Set([1, &quot;1&quot;, 2, 1, 1, 3])]</span><br></pre></td></tr></table></figure></p><p>方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a = [1, 1, &quot;1&quot;, 2, 2, &quot;2&quot;, 3, 3, &quot;3&quot;];</span><br><span class="line"></span><br><span class="line">let b = Array.from(newSet(a));</span><br><span class="line"></span><br><span class="line">console.log(b);</span><br></pre></td></tr></table></figure></p><p>方式三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.unique3 = function()&#123;</span><br><span class="line"></span><br><span class="line">var res = [];</span><br><span class="line"></span><br><span class="line">var json = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; this.length; i++)&#123;</span><br><span class="line"></span><br><span class="line">if(!json[this[i]])&#123;</span><br><span class="line"></span><br><span class="line">   res.push(this[i]);</span><br><span class="line"></span><br><span class="line">   json[this[i]] = 1;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">return res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = [112,112,34,&apos;你好&apos;,112,112,34,&apos;你好&apos;,&apos;str&apos;,&apos;str1&apos;];</span><br><span class="line"></span><br><span class="line">alert(arr.unique3());</span><br></pre></td></tr></table></figure></p><p>原理：</p><ol><li>创建一个新的数组存放结果</li><li>创建一个空对象</li><li>for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值为1，存入到第2步建立的对象中。</li></ol><p>至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</p><h3 id="用最短的代码实现一个长度为m-6-且值都n-8-的数组"><a href="#用最短的代码实现一个长度为m-6-且值都n-8-的数组" class="headerlink" title="用最短的代码实现一个长度为m(6)且值都n(8)的数组"></a>用最短的代码实现一个长度为m(6)且值都n(8)的数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(6).fill(8);</span><br></pre></td></tr></table></figure><p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...&apos;8&apos;.repeat(6)];</span><br></pre></td></tr></table></figure></p><h4 id="apply-取一个数组的最大值和最小值"><a href="#apply-取一个数组的最大值和最小值" class="headerlink" title="apply 取一个数组的最大值和最小值"></a><code>apply</code> 取一个数组的最大值和最小值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];</span><br><span class="line"></span><br><span class="line">let maxInNumbers = Math.max.apply(Math, numbers);</span><br><span class="line"></span><br><span class="line">let minInNumbers = Math.min.apply(Math, numbers);</span><br></pre></td></tr></table></figure><h3 id="将-argruments-对象转换成数组"><a href="#将-argruments-对象转换成数组" class="headerlink" title="将 argruments 对象转换成数组"></a>将 <code>argruments</code> 对象转换成数组</h3><p>方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let argArray1 = Array.prototype.slice.call(arguments);</span><br></pre></td></tr></table></figure></p><p>方式二，<code>ES6</code> 写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let argArray2 = Array.from(arguments);</span><br></pre></td></tr></table></figure></p><h3 id="交换两个数的值"><a href="#交换两个数的值" class="headerlink" title="交换两个数的值"></a>交换两个数的值</h3><p>方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a = 1, b = 2;</span><br><span class="line"></span><br><span class="line">[a, b] = [b, a];</span><br></pre></td></tr></table></figure></p><p>方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a = 1, b = 2, c;</span><br><span class="line"></span><br><span class="line">c = a;</span><br><span class="line"></span><br><span class="line">a = b;</span><br><span class="line"></span><br><span class="line">b = c;</span><br><span class="line"></span><br><span class="line">console.log(a, b);</span><br></pre></td></tr></table></figure></p><p>Jartto: 方式二是学 C 语言时记忆最准的了🙈。</p><h4 id="统计字符串中相同字符出现的次数（参考）"><a href="#统计字符串中相同字符出现的次数（参考）" class="headerlink" title="统计字符串中相同字符出现的次数（参考）"></a>统计字符串中相同字符出现的次数（<a href="https://www.zhihu.com/question/46943112/answer/103585546" target="_blank" rel="noopener">参考</a>）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = &apos;abcdaabc&apos;;</span><br><span class="line"></span><br><span class="line">let info = arr.split(&apos;&apos;).reduce((p, k) =&gt; (p[k]++ || (p[k] = 1), p), &#123;&#125;);</span><br><span class="line"></span><br><span class="line">console.log(info); //&#123; a: 3, b: 2, c: 2, d: 1 &#125;</span><br></pre></td></tr></table></figure><h4 id="是否包含某元素"><a href="#是否包含某元素" class="headerlink" title="是否包含某元素"></a>是否包含某元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if(~&quot;asdf&quot;.lastIndexOf(&quot;a&quot;))&#123;</span><br><span class="line"></span><br><span class="line">  alert(&quot;exists&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>~是移位操作，找不到下标返回-1，移位之后是0，恰好0==false；找到的话，至少返回0，移位后是1，也就是true</p><h3 id="includes-和-indexOf-区别"><a href="#includes-和-indexOf-区别" class="headerlink" title="includes 和 indexOf 区别"></a><code>includes</code> 和 <code>indexOf</code> 区别</h3><h3 id="将-n-维数组破开成一维（参考）"><a href="#将-n-维数组破开成一维（参考）" class="headerlink" title="将 n 维数组破开成一维（参考）"></a>将 n 维数组破开成一维（<a href="https://www.zhihu.com/question/46943112/answer/115665473" target="_blank" rel="noopener">参考</a>）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let foo0 = [1, [2, 3], [4, 5, [6,7,[8]]], [9], 10]; var foo1 = foo0.join(&apos;,&apos;).split(&apos;,&apos;); </span><br><span class="line"></span><br><span class="line">console.log(foo1); //[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;]</span><br></pre></td></tr></table></figure><h3 id="十九、浮点取整十九、浮点取整"><a href="#十九、浮点取整十九、浮点取整" class="headerlink" title="#十九、浮点取整十九、浮点取整"></a><a href="#十九、浮点取整">#十九、浮点取整</a>十九、浮点取整</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.3  &gt;&gt; 0</span><br></pre></td></tr></table></figure><p>Jartto: 按位操作只能针对 <code>int</code> 类型，所以 <code>js</code> 在做按位操作时，会自动把 <code>float</code> 转换成 <code>int</code>。</p><h3 id="随机颜色值"><a href="#随机颜色值" class="headerlink" title="随机颜色值"></a>随机颜色值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(Math.random() * (2 &lt;&lt; 23)).toString(16);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入理解window.onload</title>
      <link href="/2017/12/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3window-onload/"/>
      <url>/2017/12/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3window-onload/</url>
      
        <content type="html"><![CDATA[<p><strong>现象：</strong>在一个 Hybrid 应用中，用户反馈弱网条件下页面的进度条总是不消失，最后发现是页面接口先于其他资源返回，而接口中包含大量图片导致了 <code>onload</code> 会推迟，从而客户端控制的进度条不会消失，页面调用客户端的方法不会执行。</p><h4 id="先放结论"><a href="#先放结论" class="headerlink" title="先放结论"></a>先放结论</h4><p><strong>onload的触发时机：</strong> JS 加载并执行完毕且页面中所有外链资源加载完成之后大约 3 - 4ms（这个值跟机型和浏览器有关）</p><p><strong>最佳实践：</strong> JS代码的执行要放到onload里。如果是服务端渲染带图片的列表，图片最好由JS异步加载，避免阻塞onload。</p><h4 id="onload不是立即触发的"><a href="#onload不是立即触发的" class="headerlink" title="onload不是立即触发的"></a>onload不是立即触发的</h4><p>请问下面哪个alert先触发？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line">    alert(&apos;onload&apos;);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    alert(&apos;timeout&apos;);</span><br><span class="line">&#125;, 2)</span><br></pre></td></tr></table></figure></p><p>答案是 <code>timeout</code> 先触发。而在我的电脑上，把 <code>timeout</code> 的值调成100 或 100 以上，就是 <code>onload</code> 先触发了。</p><h4 id="JS的执行对onload有影响"><a href="#JS的执行对onload有影响" class="headerlink" title="JS的执行对onload有影响"></a>JS的执行对onload有影响</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line">    alert(&apos;onload&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var a</span><br><span class="line">for (var i = 0; i &lt; 100000000; i++) &#123;</span><br><span class="line">    a = a + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会发现 onload 会等很久才触发，因此JS的执行最好放在onload之后。</p><h4 id="动态加载的资源可能对onload产生影响"><a href="#动态加载的资源可能对onload产生影响" class="headerlink" title="动态加载的资源可能对onload产生影响"></a>动态加载的资源可能对onload产生影响</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;&lt;/body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.onload = function() &#123;</span><br><span class="line">    alert(&apos;onload&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  document.body.innerHTML = &apos;&lt;img src=&quot;a.png&quot;&gt; .... &lt;img src=&quot;z.png&quot;&gt;&apos;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>我们把网速调的慢一点，我们会很清晰的发现这种 JS 动态加进去的图片也会阻塞 <code>onload</code>，只有 a-z 图片都加载完成，onload 才会触发。而我们改成下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onload = function() &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">       document.body.innerHTML = &apos;&lt;img src=&quot;a.png&quot;&gt; .... &lt;img src=&quot;z.png&quot;&gt;&apos;;</span><br><span class="line">    &#125;, 10)</span><br><span class="line">    alert(&apos;onload&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这时就会发现，onload 马上就触发了，不必等待图片加载完成。</p><p>再讲一个更实际的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;aaa.png&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">    alert(&apos;onload&apos;);</span><br><span class="line">&#125;</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: imgList,</span><br><span class="line">  success: function(arr) &#123;</span><br><span class="line">        arr.forEach(function() &#123;</span><br><span class="line">            $(&apos;body&apos;).append(&apos;&lt;img src=&quot;&apos; + arr.imgUrl + &apos;&quot;&gt;&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>假设 aaa.png 加载时间为 100ms，ajax 接口返回时间为 50ms，那么假设 imgList 中有 100 张图片，那么 onload 的时间就会被推迟到这 100 张图片都加载完成之后。</p><p>而如果 aaa.png 加载时间为 50ms，接口请求为 100ms 的时候，就不会有这个问题。但是我们没法保证接口请求一定慢于图片请求。</p><p>因此<strong>带图片的列表请求需要放在 window.onload 之后执行</strong>。</p><h4 id="onload和客户端方法的对应"><a href="#onload和客户端方法的对应" class="headerlink" title="onload和客户端方法的对应"></a>onload和客户端方法的对应</h4><p>iOS 中判断 webview 加载完成的 <strong>webViewDidFinishLoad</strong> 方法，Android 中判断 <code>webview</code> 加载完成的 <strong>onPageFinished</strong> 方法本质触发时机上都对应页面上的 <code>window.onload</code>，一般来说会稍晚于 <code>window.onload</code>（某些特殊情况会早于 <code>window.onload</code>，比如页面里有 <code>iframe</code> 等情况）。</p><p>也就是说 <strong>对 onload 有影响的因素也同样会影响这些 Native 方法</strong>。而在 Hybrid 开发中，一些 Native 和 Web 之间的交互和调用往往要在<code>webViewDidFinishLoad / onPageFinished</code> 之后。因此如果 <code>onload</code> 的触发被推迟了，那么这些 <code>Native</code> 相关的调用也都会被推迟。</p><p><strong>因此如果是Hybrid应用，尤其要注意让onload尽快触发。</strong></p><h4 id="百度统计对onload的影响"><a href="#百度统计对onload的影响" class="headerlink" title="百度统计对onload的影响"></a>百度统计对onload的影响</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var _hmt = _hmt || [];</span><br><span class="line">    (function() &#123;</span><br><span class="line">      var hm = document.createElement(&quot;script&quot;);</span><br><span class="line">      hm.src = &quot;https://hm.baidu.com/hm.js?2fdsasa8f9f2f0e59e7db6c398edfbfcb1f&quot;;</span><br><span class="line">      var s = document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">      s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面是百度统计的代码，我们可以看到它动态加载了一个 <code>script</code>，而这个 <code>script</code> 会马上以一个小 gif 的形式发送一个上报请求，经过测试，如果页面上没有其它元素，这个 <strong>小 gif 加载完成后才会触发 onload</strong>，那么总加载时间就是 script 加载时间 + gif 加载时间。</p><p>因此应该尽量把百度统计代码提前，避免百度统计拖慢 onload 时间。百度统计官方也是<strong>建议将统计代码放在 head 中</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> window.onload </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS常用设计模式</title>
      <link href="/2017/12/25/JS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/12/25/JS%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>由于 JS 或者前端的场景限制，并不是 23 种设计模式都常用。</p><p>有的是没有使用场景，有的模式使用场景非常少，所以只是列举 7 个常见的模式</p><blockquote><p>本文的脉络：</p></blockquote><ul><li>设计与模式</li><li>5 大设计原则</li><li>7 种常见的设计模式</li></ul><blockquote><p>一句话解释含义</p></blockquote><ul><li>列举生活中的场景 、 业务代码场景</li><li>js 代码演示</li></ul><h2 id="设计与模式"><a href="#设计与模式" class="headerlink" title="设计与模式"></a>设计与模式</h2><p>之前一直以为「设计模式」是一个完整的名词</p><p>其实「设计」和「模式」是要分开来说的</p><ul><li>「设计」：5 个常见的设计原则</li><li>「模式」：代码中常见的”套路”,被程序员总结成了相对固定的写法，称之为「模式」</li></ul><p>也就是说学习”设计模式”,首先肯定要学习和理解 5 个设计原则。</p><p>因为所有的模式，都是肯定是符合 5 大设计原则中的几个，至少不违背设计原则的。</p><p>所以我们在学习模式时，不能上来就把 23 种模式的 js 实现看一遍，这样是很难理解的。</p><p>我觉得正确的学习顺序是：</p><ul><li>先学习 5 大设计原则</li><li>再学习 23 种模式</li></ul><p>而「模式」的学习顺序是：</p><ul><li>1.尝试用一句话概括这个模式。 （不理解也没关系，至少对定义有一个大致印象）</li><li>2.联想在生活中的例子。（模式往往反映一种思想）</li><li>3.更重要的是理解「模式」的代码中的应用（有的模式思想在生活中可能没有合适的例子）</li><li>4.最后才是用 js 代码去演示和实现「模式」</li></ul><p>「模式」的学习步骤中，我觉得<strong>理解在代码中应用场景</strong>是最重要的</p><p>这也是为什么所谓 23 种「模式」，这个文章只是大致讲了 7 种。</p><p>因为我觉得没有很多场景的模式，学习了意义也不大。</p><h2 id="5-大设计原则"><a href="#5-大设计原则" class="headerlink" title="5 大设计原则"></a>5 大设计原则</h2><p>5 大设计原则，可能书和书的叫法不太一样。</p><p>但是我觉得最重要的是，理解意思即可，毕竟实际上并不是所有「模式」都满足 5 大设计原则</p><p>往往只是满足 1、2 条，然后不违反其他原则，这样。</p><ul><li><strong>1.单一职责原则</strong></li><li><strong>2.开放-封闭原则</strong></li><li><strong>3.面向接口编程</strong></li><li>4.李氏置换原则</li><li>5.接口独立原则</li></ul><p>个人理解 前 3 点 比较常见，后面的 2 个原则我也不太理解，或者可能前端场景下比较少见。</p><blockquote><p>单一职责原则</p></blockquote><p>一个函数只做一件事，如果功能过于复杂，最好让一段代码只负责一部分逻辑。</p><blockquote><p>开放-封闭原则</p></blockquote><p>对拓展开放，对修改封闭。</p><ul><li>比如常见的 Vue 和 jQuery 都提供插件拓展机制，你如果希望增加功能，可以拓展某一个技术栈的生态。而不是直接修改源码</li></ul><blockquote><p>面向接口编程</p></blockquote><p>调用者时，只按照接口，不必清楚接口内部的类如何实现。</p><ul><li>比如前后分离开发时，前端只需要关注接口文档，不必了解具体实现</li><li>比如设计 UI 组件时，我只需要考虑用户需要如何调用，不用让他操心，我的内部实现。</li></ul><h2 id="7-种常见的设计模式"><a href="#7-种常见的设计模式" class="headerlink" title="7 种常见的设计模式"></a>7 种常见的设计模式</h2><p>我们要说的 7 种常见设计模式如下：</p><ul><li>工厂模式</li><li>单例模式</li><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>观察者模式</li><li>迭代器模式</li></ul><p>每 1 个模式的学习顺序遵循以下 3 点</p><ul><li><p>一句话概括这个模式的思想</p></li><li><p>生活场景的应用 和 业务场景的应用(重点理解业务场景)</p></li><li><p>js 演示该模式</p></li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote><p>一句话描述: 工厂模式将 new 操作符封装，拓展一个 create 的接口开发给调用者</p></blockquote><p>业务场景</p><ul><li>jQuery 的 $()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.$ = function(selector) &#123;</span><br><span class="line">    returnnew jQuery(selector);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如 jQuery 把 $暴露给开发者，类似于 create 方法。</p><p>有了$一般我们也不会使用 new jQuery() 来创建 jquery 对象</p><p>这样做的好处:</p><ul><li>$作为 create 写起来更加简单</li><li>做了一层拓展，这样暴露给用户的是$,内部源码可以做各种修改，甚至不叫jQuery叫xQuery也可以，只要最终还是暴露$,对用户来说就是一样的。</li></ul><p><strong>符合开放-封闭原则</strong></p><blockquote><p>js 演示</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Product&#123;</span><br><span class="line">    constructor(options) &#123;</span><br><span class="line">        this.name = options.name;</span><br><span class="line">        this.time = options.time;</span><br><span class="line">        this.init();</span><br><span class="line">    &#125;</span><br><span class="line">    init() &#123;</span><br><span class="line">        console.log(`产品名：$&#123;this.name&#125; 保质期：$&#123;this.time&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Factory&#123;</span><br><span class="line">    create(options) &#123;</span><br><span class="line">        returnnew Product(options);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let factory = new Factory();</span><br><span class="line">let product1 = factory.create(&#123; name: &quot;面包&quot;, time: &quot;1个月&quot; &#125;);</span><br></pre></td></tr></table></figure><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><blockquote><p>一句话描述：一个类只有一个实例<br>业务场景</p></blockquote><ul><li>场景 1: 比如 Vue 的插件机制。Vue.use()多次，也只存在第一个插件实例。</li><li>场景 2: 比如 Vuex 的 Store 在实例化时，就算你实例化多个，也只存在一个 Store,这样才能保证共享数据嘛。</li><li>场景 3: 创建一个购物车组件。因为购物车往往整个项目只需要 1 个</li></ul><p>比如 Vue.use 时，我们知道 Vue 源码中会去做判断调用插件的 install 方法</p><p>但是只要 Vue.use 就直接调用的。</p><p>Vue 会把 Vue.use 的东西 push 到一个数组，每次执行 use 方法都会先检查数组里是否已经有这个插件了，没有就 push，有的话就不再执行后面的逻辑了。</p><p>这样保证项目，这个插件的 install 只初始化 1 次。</p><p>我觉得这就是单例模式思想的一种应用。来避免多次初始化可能造成的问题。</p><blockquote><p>js 实现演示</p></blockquote><p>实现思路</p><ul><li>给 SingleObject 添加一个静态方法 getInstance</li><li>将来实例化时，不是通过 new，而是 SingleObject.getInstance()</li><li>getInstance 内部的实现就是，第一次调用是用变量缓存实例。之后调用时判断该变量是否有值，没有值就可以 new，有值就把这个变量 return</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function SingleObject() &#123;</span><br><span class="line">    this.instance = null;</span><br><span class="line">    this.name = &quot;单例&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SingleObject.getInstance = function() &#123;</span><br><span class="line">    if (this.instance === null) &#123;</span><br><span class="line">        this.instance = new SingleObject();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        returnthis.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = SingleObject.getInstance();</span><br><span class="line">var obj2 = SingleObject.getInstance();</span><br><span class="line"></span><br><span class="line">console.log(obj1 === obj2);</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><blockquote><p>一句话描述： 接口不兼容时，对旧接口做一层包装，来适配新需求。<br>生活场景</p></blockquote><p>插头的电压，不同国家是存在差异的嘛，经常有电源适配器来做一层包装，从而适配我们的电压。</p><blockquote><p>业务场景</p></blockquote><ul><li>Vue 的 computed 提供给函数和对象 2 种写法。Vue 内部需要做一层适配</li><li>Node.js 中间层</li></ul><p>比如 Vue 源码内部遍历 computed 对象后，需要把用户传递的函数作为该计算属性的 getter 的返回值嘛</p><p>但是用户有可能会传递 fn，也可能传递一个带 get、set 方法的对象</p><p>那么 Vue 面对用户提供的不同接口，它就需要做一层适配。</p><p>无论函数直接提供函数，还是提供的对象，Vue 都转化为一个函数</p><p>Vue 类似这种处理非常多，因为 Vue 提供给用户很宽松的写法嘛。比如你可以用 template 也可以用 render，但是最终 template 一定会被适配成 render 来调用</p><p>另一个例子，我觉得现在流行的 Node.js 中间层，也算是适配器模式的应用。</p><p>后端提供一些基础数据，但是移动端和 PC 端要求的数据格式是不同，且经常变化的。</p><p>Node.js 中间层的作用，可以让后端的基础数据不做变化，只是对数据在 Node 中再包装一次，来适配具体的业务场景</p><blockquote><p>js 实现演示</p></blockquote><p>重点理解这个适配器，在业务的应用。</p><p>感觉单纯用 js 代码演示可能比较呆板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 新增加的适配器</span><br><span class="line">class Adaptee&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name = &quot;我是适配器&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parse() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 原来的旧代码</span><br><span class="line">class OldApi&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = &apos;我是旧的接口&apos;this.adaptee = new Adaptee()</span><br><span class="line">        this.adaptee.parse()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var oldApi = new OldApi()</span><br></pre></td></tr></table></figure></p><p>这样我们拓展了一个新的叫做适配器的类，利用它来处理旧数据，而不是直接去具体修改旧数据</p><p>对拓展开发，对修改封闭，典型的符合开发-封闭的设计原则</p><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><blockquote><p>一句话描述： 1.为对象装饰一些新功能，2.旧的功能属性全都保留<br>生活场景</p></blockquote><p>手机壳对于手机，就是一种装饰器</p><blockquote><p>业务场景</p></blockquote><ul><li>ES7的装饰器语法</li></ul><p>下面介绍了「ES7的 @ 装饰符」的使用，可以直接跳过。</p><ul><li>可以修饰类</li></ul><p>例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function decorator(target)&#123;</span><br><span class="line">    target.type = &apos;人类&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">class Animal&#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(Animal.type)</span><br></pre></td></tr></table></figure></p><p><strong>不传递参数时 @ 就相当于 Animal = decorator(Animal) || Animal</strong></p><p>也可以传递参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function setType(type)&#123;</span><br><span class="line">    returnfunction(target)&#123;</span><br><span class="line">        target.type = type</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@setType(&apos;人类&apos;)</span><br><span class="line">classAnimal&#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(Animal.type)</span><br></pre></td></tr></table></figure></p><p><strong>传递参数时 @ 就相当于 Animal = setType(type)(Animal) || Animal</strong></p><ul><li>也可以修饰类中的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123; return`$&#123;this.first&#125;$&#123;this.last&#125;` &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function readonly(target, name, descriptor)&#123;</span><br><span class="line">  descriptor.writable = false;</span><br><span class="line">  return descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>readonly的3个参数含义如下</p><ul><li>target： Person.prototype</li><li>name : key</li><li>descriptor : 描述器</li></ul><blockquote><p>js演示</p></blockquote><p>实现东西</p><p>就是我有一个Circle类，用circle.draw()可以画一个圆</p><p>经过装饰后，可以画一个带红色边框的圆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Circle&#123;</span><br><span class="line">    draw() &#123;</span><br><span class="line">        console.log(&quot;draw&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Decorator&#123;</span><br><span class="line">    constructor(circle) &#123;</span><br><span class="line">        this.circle = circle</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setRedBorder() &#123;</span><br><span class="line">        console.log(&apos;border装饰为红色&apos;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    draw() &#123;</span><br><span class="line">        this.circle.draw()</span><br><span class="line">        this.setRedBorder()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let circle = new Circle()</span><br><span class="line">let decorator = new Decorator(circle)</span><br><span class="line"></span><br><span class="line">circle.draw()</span><br><span class="line">decorator.draw()</span><br></pre></td></tr></table></figure></p><p>符合单一职责原则，和开放-封闭原则</p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote><p>一句话描述: 无法直接访问时，通过代理来访问目标对象</p></blockquote><p>这里区分一下适配器模式、代理模式、装饰器模式</p><ul><li><p>适配器模式是在原来的基础上，做了一层包装。虽然没有动原来的接口，但最终我们是用包装好的适配后的数据，肯定有修改的。</p></li><li><p>代理模式，是通过代理，访问原数据。没有什么包装和修改。</p></li><li><p>装饰器模式，是原来的功能和函数都还要用的的基础上，增加一些拓展功能。而适配的话是在包装时做一些改造。</p></li></ul><blockquote><p>生活场景</p></blockquote><ul><li>翻墙用的VPN</li><li>海外代购</li><li>各级代理商</li></ul><blockquote><p>业务场景</p></blockquote><ul><li>绑定多个li时的事件代理</li><li>Vue的data、props被访问时，就做了代理。</li><li>ES6的proxy的代理</li></ul><p>ul下多个li，通过给父元素绑定click事件，实现对多个li的监听。叫做事件代理</p><p>当然这里能实现代理，也依靠了事件冒泡。但是不过是利用什么机制做的代理。这种思想可以看做是代理的思想。</p><p>Vue的data，在Vue初始化时，this._init() ==&gt; this.initState() ==&gt; this.initData()</p><p>在initData中，除了递归循环把vm的data全都包装为响应式对象之外，还调用了proxy()</p><p>这个proxy内部实现的，就是当你访问this.msg时，实际上就访问了this.data.msg</p><p>毕竟我们不可能真的把msg挂到Vue.prototype上。</p><p>这也是代理的思想。但是当然不是冒泡机制实现的，这里是利用引用的传递。</p><p>ES6还提供了Proxy,被Proxy包装的对象，也是一种代理。</p><p>原对象和包装后的对象，很像明星和经纪人之间的关系</p><blockquote><p>js演示</p></blockquote><p>实现的效果就是proxyData.getName()，代理的是data.getName()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Data&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.name = &apos;元数据&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getName()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ProxyData&#123;</span><br><span class="line">    constructor(data)&#123;</span><br><span class="line">        this.data = data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getName()&#123;</span><br><span class="line">        this.data.getName()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let data = new Data()</span><br><span class="line">let proxyData = new ProxyData(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data.getName()</span><br><span class="line">proxyData.getName()</span><br></pre></td></tr></table></figure></p><p>代理模式符合开放-封闭原则</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote><p>一句话描述：把watcher收集到一个队列，等到发布时再依次通知watcher，来实现异步的一种模式。<br>生活场景</p></blockquote><p>观察者模式被广泛的应用在日常生活和开发实践中</p><ul><li>斗鱼主播是发布者，观众但是订阅者。</li><li>猎头是发布者，候选人是订阅者</li><li>赛跑时，裁判开枪来发布，所有的运动员就是订阅者。</li></ul><p>这里订阅者也可以理解为观察者。</p><blockquote><p>业务场景</p></blockquote><ul><li>1.Vue的收集依赖、派发更新</li><li>2.浏览器事件机制</li><li>3.Promise.then的异步事件</li><li>4.Vue的生命周期钩子</li><li>5.Node.js的eventEmitter</li><li>场景1：Vue的收集依赖、派发更新</li></ul><p>「订阅」: Vue的响应式数据，在页面渲染时，触发getter收集watcher依赖。</p><p>「发布」:数据变化时，触发setter，Notify所有的watcher调用他们的update方法</p><ul><li>场景2：浏览器事件机制</li></ul><p>「订阅」: btn绑定了click事件，那个fn就被放到事件队列中<br>「发布」: 用户点击时，触发click事件。</p><ul><li>场景3 : Promise.then</li></ul><p>「订阅」: then调用时，把then的成功函数保存在一个变量中</p><p>「发布」: 当调用resolve时，状态变化，并且把保存的then的成功函数调用</p><ul><li>场景4: Vue的生命周期钩子</li></ul><p>「订阅」: 在option上写beforeCreate对应的函数</p><p>「发布」: 当组件初始化阶段，到了对应时机，vue帮你调用用户提供的函数</p><blockquote><p>js实现一个eventEmiiter</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class EventEmitter&#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.eventMap = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on( type, fn ) &#123;</span><br><span class="line">        if ( !this.eventMap[type] ) &#123;</span><br><span class="line">            this.eventMap[type] = []</span><br><span class="line">        &#125; </span><br><span class="line">        this.eventMap[type].push(fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit( type, ...params ) &#123;</span><br><span class="line">        this.eventMap[type].forEach(fn =&gt; &#123;</span><br><span class="line">            fn(...params);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off( type, fn ) &#123;</span><br><span class="line">        let list = this.eventMap[type];</span><br><span class="line">        let atIndex = list.indexOf(fn);</span><br><span class="line">        </span><br><span class="line">        if (atIndex !== -1) &#123;</span><br><span class="line">            list.splice(atIndex, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><blockquote><p>一句话描述： 1.按顺序访问集合, 2.调用者不用关系内部的数据结构</p></blockquote><p>ES6之后，我们知道除了数组之外的有序集合挺多的</p><ul><li>Array</li><li>Map</li><li>Set</li><li>nodelist</li><li>arguments</li></ul><p>那数组的迭代，或者遍历可以用10几种API</p><p>那么如果要遍历Map/Set或者nodelist呢。如果给每一种数据结构都搞一套API就会很麻烦</p><p>包括JQ都有each遍历。</p><p>会导致api泛滥的，所以我们把遍历这种行为，抽象成一种模式。</p><blockquote><p>场景</p></blockquote><ul><li>ES6的iterator</li><li>为什么需要iterator</li><li>iterator是什么</li></ul><p>了解一下iterator的内容，如果已经了解可以直接跳过</p><blockquote><p>为什么需要iterator</p></blockquote><p>因为js需要遍历的数据结构越来越多，如果给每一个数据结构都搞一套API会很麻烦。</p><p>所以，需要有一个统一的接口，可以遍历各种数据结构。</p><blockquote><p>iterator是什么</p></blockquote><p>就是比如Array.prototype就有一个[Symbol.iterator]属性</p><p>这个属性对应的是一个函数，函数调用后，得到一个迭代器</p><p>我们用这个迭代器就可以遍历各种符合iterator标准的数据结构啦。</p><p>怎么遍历呢？ 迭代器有next，用while去迭代</p><p>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function each(data) &#123;</span><br><span class="line">    let iterator = data[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">    let item = &#123; done: false &#125;;</span><br><span class="line">    while (item.done === false) &#123;</span><br><span class="line">        item = iterator.next();</span><br><span class="line">        if ( item.done ) return item</span><br><span class="line">        console.log(item)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let arr = [1, 2, 3, 4];</span><br><span class="line">let nodeList = document.querySelectorAll(&quot;p&quot;);</span><br><span class="line">let m = newMap();</span><br><span class="line">m.set(&quot;a&quot;, 100);</span><br><span class="line">m.set(&quot;b&quot;, 100);</span><br><span class="line"></span><br><span class="line">each(arr)</span><br><span class="line">each(nodeList)</span><br><span class="line">each(m)</span><br></pre></td></tr></table></figure></p><p>那么，难道每一个开发者，都需要自己封装一个each方法吗？</p><p>ES6提供的for…of就是类似于each，用来遍历符合iterator接口的数据结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( let v of nodeList ) &#123;</span><br><span class="line">    console.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>迭代器模式的js实现</p></blockquote><p>这个要关注实现思路。</p><p>这里只是把数组设计成迭代器，有一个next方法和hasNext方法</p><p>需要有2个类</p><ul><li>1.Wrapper类，提供一个getIterator方法，可以生成一个迭代器</li><li>2.Iterator类，迭代器。有next和hasNext方法</li></ul><pre><code>class Iterator{    constructor(wrapper) {        this.list = wrapper.list        this.index = 0    }    next() {        if ( this.hasNext() ) {            returnthis.list[this.index++]        } else {            returnnull                    }    }    hasNext() {        returnthis.index &lt; this.list.length    }}class Wrapper{    constructor(list) {        this.list = list    }    getIterator(iterator) {        returnnew Iterator(this)    }}var arr = [1, 2, 3]var iterator = new Wrapper( arr ).getIterator()while ( iterator.hasNext() ) {    console.log(iterator.next())}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>promise的模拟实现</title>
      <link href="/2017/12/20/Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/12/20/Promise%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><h2 id="1-1-什么是promise"><a href="#1-1-什么是promise" class="headerlink" title="1.1 什么是promise"></a>1.1 什么是promise</h2><p><code>Promise</code> 对象是 <code>JavaScript</code> 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。</p><h2 id="1-2-promise解决的问题"><a href="#1-2-promise解决的问题" class="headerlink" title="1.2 promise解决的问题"></a>1.2 promise解决的问题</h2><h3 id="1-2-1-回调地狱"><a href="#1-2-1-回调地狱" class="headerlink" title="1.2.1 回调地狱"></a>1.2.1 回调地狱</h3><p><code>Promise</code> 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p><h3 id="1-2-2-并行结果"><a href="#1-2-2-并行结果" class="headerlink" title="1.2.2 并行结果"></a>1.2.2 并行结果</h3><p>如果几个异步操作之间并没有前后顺序之分,但需要等多个异步操作都完成后才能执行后续的任务，无法实现并行节约时间。</p><h2 id="1-3-promise简介"><a href="#1-3-promise简介" class="headerlink" title="1.3 promise简介"></a>1.3 promise简介</h2><p>在 <code>ES6 Promises</code> 标准中定义的API还不是很多，目前大致有下面三种类型。</p><h3 id="1-3-1-consturctor"><a href="#1-3-1-consturctor" class="headerlink" title="1.3.1 consturctor"></a>1.3.1 <strong>consturctor</strong></h3><p>首先，<code>Promise</code> 是一个对象，也是一个构造函数。</p><pre><code>functionf1(resolve, reject) {  // 异步代码...}var promise = newPromise(f1);</code></pre><h3 id="1-3-2-Instance-Method"><a href="#1-3-2-Instance-Method" class="headerlink" title="1.3.2 Instance Method"></a>1.3.2 Instance Method</h3><p><code>Promise</code>对象通过自身的状态，来控制异步操作。Promise实例具有三种状态。</p><ul><li>异步操作未完成（pending）</li><li>异步操作成功（fulfilled）</li><li>异步操作失败（rejected）</li></ul><p>这三种的状态的变化途径只有两种。</p><ul><li>从“未完成”到“成功”</li><li>从“未完成”到“失败”</li></ul><p>所以<code>Promise</code>的最终结果只有两个,</p><ul><li>异步操作成功，Promise实例传回一个值（value）,状态变为<code>fulfilled</code>。</li><li><p>异步操作失败，Promise 实例抛出一个错误（error）,状态变为<code>rejected</code>。</p><p>  promise.then(onFulfilled, onRejected)<br>  // resolve(成功)时,onFulfilled 会被调用// reject(失败)时,onRejected 会被调用</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/3/5/161f55d1eecd52cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="1-3-3-Static-Method"><a href="#1-3-3-Static-Method" class="headerlink" title="1.3.3 Static Method"></a>1.3.3 Static Method</h3><p>像 <code>Promise</code>这样的全局对象还拥有一些静态方法。包括 <code>Promise.all()</code>还有<code>Promise.resolve()</code> 等在内，主要都是一些对<code>Promise</code>进行操作的辅助方法。</p><h1 id="2-Promise的实现"><a href="#2-Promise的实现" class="headerlink" title="2.Promise的实现"></a>2.<code>Promise</code>的实现</h1><h2 id="2-1-resolve和reject"><a href="#2-1-resolve和reject" class="headerlink" title="2.1 resolve和reject"></a>2.1 resolve和reject</h2><p><code>resolve</code>和<code>reject</code>都是函数</p><pre><code>//构造函数中functionPromise(executor) {    let self = this;    /*初始化status*/    self.status = &apos;pending&apos;;    /*初始化value*/    self.value = undefined;    /*订阅事件的数组*/    self.onResolvedCallBacks = [];    self.onRejectedCallBacks = [];    /*此函数将Promise实例的状态由pending 转化为 fulfilled*/functionresolve(value) {        if (value instanceofPromise) {            return value.then(resolve, reject);        }        setTimeout(function () {            if (self.status === &apos;pending&apos;) {                self.status = &apos;fulfilled&apos;;                self.value = value;                /*发布已经订阅过的事件*/                self.onResolvedCallBacks.forEach(item =&gt; item(self.value))            }        }, 0)    }    /*此函数将Promise实例的状态由pending 转化为 rejected*/functionreject(reason) {        setTimeout(function () {            if (self.status === &apos;pending&apos;) {                self.status = &apos;rejected&apos;;                self.value = reason;                /*发布已经订阅过的事件*/                self.onRejectedCallBacks.forEach(item =&gt; item(self.value))            }        }, 0)    }    // new Promise 的时候，执行器（executor）的代码会立即执行try {        executor(resolve, reject);    } catch (e) {        reject(e);    }}</code></pre><h2 id="2-2-then方法"><a href="#2-2-then方法" class="headerlink" title="2.2 then方法"></a>2.2 then方法</h2><p><code>promise</code>成功后，<code>onFullfilled</code>会被调用。并且把<code>promise</code>的值当做它的第一个参数。<code>promise</code>在成功之前，不会调用它，并且只能被调用一次。<code>reject</code>也一样。</p><pre><code>// 先封装一个方法function resolvePromise(promise2,x,resolve,reject){//  if(promise2 === x){    return reject(new TypeError(&apos;循环引用&apos;));  }  // 为了防止resolve和reject同时调用  let called = false;//promise2是否已经resolve 或reject了  if(x instanceof Promise){    if(x.status == PENDING){      x.then(function(y){        resolvePromise(promise2,y,resolve,reject);      },reject);    }else{      x.then(resolve,reject);    }    //x是一个thenable对象或函数，只要有then方法的对象，  }elseif(x!= null &amp;&amp;((typeof x==&apos;object&apos;)||(typeof x == &apos;function&apos;))){    //当我们的promise和别的promise进行交互，编写这段代码的时候尽量的考虑兼容性，    //允许别人瞎写，x可以是对象，也可以是函数    try{      letthen = x.then;      if(typeof then == &apos;function&apos;){        //有些promise会同时执行成功和失败的回调        then.call(x,function(y){          //如果promise2已经成功或失败了，则不会再处理了          if(called)return;          called = true;          resolvePromise(promise2,y,resolve,reject)        },function(err){          if(called)return;          called = true;          reject(err);        });      }else{        //到此的话x不是一个thenable对象，那直接把它当成值resolve promise2就可以了        // 当返回一个对象 {name:&apos;a&apos;,then:{age:8}},对象里的then不是thenable对象        resolve(x);      }    }catch(e){      if(called)return;      called = true;      reject(e);    }  }else{    //如果X是一个普通 的值，则用x的值去resolve promise2    resolve(x);  }}Promise.prototype.then = function(onFulfilled,onRejected){  //如果成功和失败的回调没有传，则表示这个then没有任何逻辑，只会把值往后抛,叫做值的穿透  // 例如：promise.then().then().then(function(data){},function(err){})  onFulfilled = typeof onFulfilled == &apos;function&apos;?onFulfilled:function(value){return  value};  onRejected = typeof onRejected == &apos;function&apos;?onRejected:reason=&gt;{throw reason};  //如果当前promise状态已经是成功态了，onFulfilled直接取值  let self = this;  let promise2;  if(self.status == FULFILLED){    return promise2 = new Promise(function(resolve,reject){      setTimeout(function(){        try{          let x =onFulfilled(self.value);          //如果获取到了返回值x,会走解析promise的过程          resolvePromise(promise2,x,resolve,reject);        }catch(e){          //如果执行成功的回调过程中出错了，用错误原因把promise2 reject          reject(e);        }      })    });  }  if(self.status == REJECTED){    return promise2 = new Promise(function(resolve,reject){      setTimeout(function(){        try{          let x =onRejected(self.value);          resolvePromise(promise2,x,resolve,reject);        }catch(e){          reject(e);        }      })    });  }  if(self.status == PENDING){    return promise2 = new Promise(function(resolve,reject){      self.onResolvedCallbacks.push(function(){        try{          let x =onFulfilled(self.value);          //如果获取到了返回值x,会走解析promise的过程          resolvePromise(promise2,x,resolve,reject);        }catch(e){          reject(e);        }      });      self.onRejectedCallbacks.push(function(){        try{          let x =onRejected(self.value);          resolvePromise(promise2,x,resolve,reject);        }catch(e){          reject(e);        }      });    });  }}</code></pre><h2 id="2-2-catch方法"><a href="#2-2-catch方法" class="headerlink" title="2.2 catch方法"></a>2.2 catch方法</h2><pre><code>Promise.prototype.catch=function (callback) {  returnthis.then(null,callback);}---------使用-------let promise = newPromise(function (resolve, reject) {  reject(&apos;错误&apos;);})promise.then(function(data){console.log(data)}).catch(e=&gt;{console.log(e)});</code></pre><h2 id="2-3-all-方法"><a href="#2-3-all-方法" class="headerlink" title="2.3 all 方法"></a>2.3 all 方法</h2><pre><code>Promise.all = function (promises) {  returnnewPromise(function (resolve,reject) {    let arr =[];//arr是最终返回值的结果的集合。let j =0;    functionprocessData(i,data){// 每调用一次此函数，j就会+1；      arr[i] = data;// 每次成功的结果都放入数组中if(++j===promises.length){        resolve(arr); //只有promises中的最后一个成功，才能调用resolve方法。      }    }    for(let i=0;i&lt;promises.length;i++){      promises[i].then(function (data) {          processData(i,data);      },reject)// 如果有一个失败，整体就会失败    }  })}</code></pre><p>使用方法：</p><pre><code>functionread(file) {  returnnew Promise1(function (resolve, reject) {    require(&apos;fs&apos;).readFile(file,&apos;utf8&apos;,function (err, data) {      resolve(data);    })  })}Promise1.all([read(&apos;./1.txt&apos;),read(&apos;./2.txt&apos;)]).then(function (data) {  console.log(data)})// [&apos;file1&apos;,&apos;file2&apos;]</code></pre><h2 id="2-4-race-方法"><a href="#2-4-race-方法" class="headerlink" title="2.4 race 方法"></a>2.4 race 方法</h2><p>只要有一个promise成功，就会执行成功的回调，参数是由promise组成的数组</p><pre><code>Promise.race=function (promises) {  return new Promise(function (resolve, reject) {    for(let i=0;i&lt;promises.length;i++){      promises[i].then(resolve,reject);    }  })}</code></pre><h2 id="2-5-resolve方法"><a href="#2-5-resolve方法" class="headerlink" title="2.5 resolve方法"></a>2.5 resolve方法</h2><pre><code>Promise.resolve = function (value) {  return new Promise(function (resolve, reject) {    resolve(value)  })}</code></pre><h2 id="2-6-reject-方法"><a href="#2-6-reject-方法" class="headerlink" title="2.6 reject 方法"></a>2.6 reject 方法</h2><pre><code>Promise.reject = function (reason) {  return new Promise(function (resolve, reject) {    reject(reason);  })}</code></pre><h1 id="3-Promise对象的缺点："><a href="#3-Promise对象的缺点：" class="headerlink" title="3.Promise对象的缺点："></a>3.<code>Promise</code>对象的缺点：</h1><ul><li><p>1、无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。</p></li><li><p>2、如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。</p></li><li><p>3、当处于<code>Pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue动画大全</title>
      <link href="/2017/12/10/Vue%E5%8A%A8%E7%94%BB%E5%A4%A7%E5%85%A8/"/>
      <url>/2017/12/10/Vue%E5%8A%A8%E7%94%BB%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS动画"><a href="#CSS动画" class="headerlink" title="CSS动画"></a>CSS动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br><span class="line">2135</span><br><span class="line">2136</span><br><span class="line">2137</span><br><span class="line">2138</span><br><span class="line">2139</span><br><span class="line">2140</span><br><span class="line">2141</span><br><span class="line">2142</span><br><span class="line">2143</span><br><span class="line">2144</span><br><span class="line">2145</span><br><span class="line">2146</span><br><span class="line">2147</span><br><span class="line">2148</span><br><span class="line">2149</span><br><span class="line">2150</span><br><span class="line">2151</span><br><span class="line">2152</span><br><span class="line">2153</span><br><span class="line">2154</span><br><span class="line">2155</span><br><span class="line">2156</span><br><span class="line">2157</span><br><span class="line">2158</span><br><span class="line">2159</span><br><span class="line">2160</span><br><span class="line">2161</span><br><span class="line">2162</span><br><span class="line">2163</span><br><span class="line">2164</span><br><span class="line">2165</span><br><span class="line">2166</span><br><span class="line">2167</span><br><span class="line">2168</span><br><span class="line">2169</span><br><span class="line">2170</span><br><span class="line">2171</span><br><span class="line">2172</span><br><span class="line">2173</span><br><span class="line">2174</span><br><span class="line">2175</span><br><span class="line">2176</span><br><span class="line">2177</span><br><span class="line">2178</span><br><span class="line">2179</span><br><span class="line">2180</span><br><span class="line">2181</span><br><span class="line">2182</span><br><span class="line">2183</span><br><span class="line">2184</span><br><span class="line">2185</span><br><span class="line">2186</span><br><span class="line">2187</span><br><span class="line">2188</span><br><span class="line">2189</span><br><span class="line">2190</span><br><span class="line">2191</span><br><span class="line">2192</span><br><span class="line">2193</span><br><span class="line">2194</span><br><span class="line">2195</span><br><span class="line">2196</span><br><span class="line">2197</span><br><span class="line">2198</span><br><span class="line">2199</span><br><span class="line">2200</span><br><span class="line">2201</span><br><span class="line">2202</span><br><span class="line">2203</span><br><span class="line">2204</span><br><span class="line">2205</span><br><span class="line">2206</span><br><span class="line">2207</span><br><span class="line">2208</span><br><span class="line">2209</span><br><span class="line">2210</span><br><span class="line">2211</span><br><span class="line">2212</span><br><span class="line">2213</span><br><span class="line">2214</span><br><span class="line">2215</span><br><span class="line">2216</span><br><span class="line">2217</span><br><span class="line">2218</span><br><span class="line">2219</span><br><span class="line">2220</span><br><span class="line">2221</span><br><span class="line">2222</span><br><span class="line">2223</span><br><span class="line">2224</span><br><span class="line">2225</span><br><span class="line">2226</span><br><span class="line">2227</span><br><span class="line">2228</span><br><span class="line">2229</span><br><span class="line">2230</span><br><span class="line">2231</span><br><span class="line">2232</span><br><span class="line">2233</span><br><span class="line">2234</span><br><span class="line">2235</span><br><span class="line">2236</span><br><span class="line">2237</span><br><span class="line">2238</span><br><span class="line">2239</span><br><span class="line">2240</span><br><span class="line">2241</span><br><span class="line">2242</span><br><span class="line">2243</span><br><span class="line">2244</span><br><span class="line">2245</span><br><span class="line">2246</span><br><span class="line">2247</span><br><span class="line">2248</span><br><span class="line">2249</span><br><span class="line">2250</span><br><span class="line">2251</span><br><span class="line">2252</span><br><span class="line">2253</span><br><span class="line">2254</span><br><span class="line">2255</span><br><span class="line">2256</span><br><span class="line">2257</span><br><span class="line">2258</span><br><span class="line">2259</span><br><span class="line">2260</span><br><span class="line">2261</span><br><span class="line">2262</span><br><span class="line">2263</span><br><span class="line">2264</span><br><span class="line">2265</span><br><span class="line">2266</span><br><span class="line">2267</span><br><span class="line">2268</span><br><span class="line">2269</span><br><span class="line">2270</span><br><span class="line">2271</span><br><span class="line">2272</span><br><span class="line">2273</span><br><span class="line">2274</span><br><span class="line">2275</span><br><span class="line">2276</span><br><span class="line">2277</span><br><span class="line">2278</span><br><span class="line">2279</span><br><span class="line">2280</span><br><span class="line">2281</span><br><span class="line">2282</span><br><span class="line">2283</span><br><span class="line">2284</span><br><span class="line">2285</span><br><span class="line">2286</span><br><span class="line">2287</span><br><span class="line">2288</span><br><span class="line">2289</span><br><span class="line">2290</span><br><span class="line">2291</span><br><span class="line">2292</span><br><span class="line">2293</span><br><span class="line">2294</span><br><span class="line">2295</span><br><span class="line">2296</span><br><span class="line">2297</span><br><span class="line">2298</span><br><span class="line">2299</span><br><span class="line">2300</span><br><span class="line">2301</span><br><span class="line">2302</span><br><span class="line">2303</span><br><span class="line">2304</span><br><span class="line">2305</span><br><span class="line">2306</span><br><span class="line">2307</span><br><span class="line">2308</span><br><span class="line">2309</span><br><span class="line">2310</span><br><span class="line">2311</span><br><span class="line">2312</span><br><span class="line">2313</span><br><span class="line">2314</span><br><span class="line">2315</span><br><span class="line">2316</span><br><span class="line">2317</span><br><span class="line">2318</span><br><span class="line">2319</span><br><span class="line">2320</span><br><span class="line">2321</span><br><span class="line">2322</span><br><span class="line">2323</span><br><span class="line">2324</span><br><span class="line">2325</span><br><span class="line">2326</span><br><span class="line">2327</span><br><span class="line">2328</span><br><span class="line">2329</span><br><span class="line">2330</span><br><span class="line">2331</span><br><span class="line">2332</span><br><span class="line">2333</span><br><span class="line">2334</span><br><span class="line">2335</span><br><span class="line">2336</span><br><span class="line">2337</span><br><span class="line">2338</span><br><span class="line">2339</span><br><span class="line">2340</span><br><span class="line">2341</span><br><span class="line">2342</span><br><span class="line">2343</span><br><span class="line">2344</span><br><span class="line">2345</span><br><span class="line">2346</span><br><span class="line">2347</span><br><span class="line">2348</span><br><span class="line">2349</span><br><span class="line">2350</span><br><span class="line">2351</span><br><span class="line">2352</span><br><span class="line">2353</span><br><span class="line">2354</span><br><span class="line">2355</span><br><span class="line">2356</span><br><span class="line">2357</span><br><span class="line">2358</span><br><span class="line">2359</span><br><span class="line">2360</span><br><span class="line">2361</span><br><span class="line">2362</span><br><span class="line">2363</span><br><span class="line">2364</span><br><span class="line">2365</span><br><span class="line">2366</span><br><span class="line">2367</span><br><span class="line">2368</span><br><span class="line">2369</span><br><span class="line">2370</span><br><span class="line">2371</span><br><span class="line">2372</span><br><span class="line">2373</span><br><span class="line">2374</span><br><span class="line">2375</span><br><span class="line">2376</span><br><span class="line">2377</span><br><span class="line">2378</span><br><span class="line">2379</span><br><span class="line">2380</span><br><span class="line">2381</span><br><span class="line">2382</span><br><span class="line">2383</span><br><span class="line">2384</span><br><span class="line">2385</span><br><span class="line">2386</span><br><span class="line">2387</span><br><span class="line">2388</span><br><span class="line">2389</span><br><span class="line">2390</span><br><span class="line">2391</span><br><span class="line">2392</span><br><span class="line">2393</span><br><span class="line">2394</span><br><span class="line">2395</span><br><span class="line">2396</span><br><span class="line">2397</span><br><span class="line">2398</span><br><span class="line">2399</span><br><span class="line">2400</span><br><span class="line">2401</span><br><span class="line">2402</span><br><span class="line">2403</span><br><span class="line">2404</span><br><span class="line">2405</span><br><span class="line">2406</span><br><span class="line">2407</span><br><span class="line">2408</span><br><span class="line">2409</span><br><span class="line">2410</span><br><span class="line">2411</span><br><span class="line">2412</span><br><span class="line">2413</span><br><span class="line">2414</span><br><span class="line">2415</span><br><span class="line">2416</span><br><span class="line">2417</span><br><span class="line">2418</span><br><span class="line">2419</span><br><span class="line">2420</span><br><span class="line">2421</span><br><span class="line">2422</span><br><span class="line">2423</span><br><span class="line">2424</span><br><span class="line">2425</span><br><span class="line">2426</span><br><span class="line">2427</span><br><span class="line">2428</span><br><span class="line">2429</span><br><span class="line">2430</span><br><span class="line">2431</span><br><span class="line">2432</span><br><span class="line">2433</span><br><span class="line">2434</span><br><span class="line">2435</span><br><span class="line">2436</span><br><span class="line">2437</span><br><span class="line">2438</span><br><span class="line">2439</span><br><span class="line">2440</span><br><span class="line">2441</span><br><span class="line">2442</span><br><span class="line">2443</span><br><span class="line">2444</span><br><span class="line">2445</span><br><span class="line">2446</span><br><span class="line">2447</span><br><span class="line">2448</span><br><span class="line">2449</span><br><span class="line">2450</span><br><span class="line">2451</span><br><span class="line">2452</span><br><span class="line">2453</span><br><span class="line">2454</span><br><span class="line">2455</span><br><span class="line">2456</span><br><span class="line">2457</span><br><span class="line">2458</span><br><span class="line">2459</span><br><span class="line">2460</span><br><span class="line">2461</span><br><span class="line">2462</span><br><span class="line">2463</span><br><span class="line">2464</span><br><span class="line">2465</span><br><span class="line">2466</span><br><span class="line">2467</span><br><span class="line">2468</span><br><span class="line">2469</span><br><span class="line">2470</span><br><span class="line">2471</span><br><span class="line">2472</span><br><span class="line">2473</span><br><span class="line">2474</span><br><span class="line">2475</span><br><span class="line">2476</span><br><span class="line">2477</span><br><span class="line">2478</span><br><span class="line">2479</span><br><span class="line">2480</span><br><span class="line">2481</span><br><span class="line">2482</span><br><span class="line">2483</span><br><span class="line">2484</span><br><span class="line">2485</span><br><span class="line">2486</span><br><span class="line">2487</span><br><span class="line">2488</span><br><span class="line">2489</span><br><span class="line">2490</span><br><span class="line">2491</span><br><span class="line">2492</span><br><span class="line">2493</span><br><span class="line">2494</span><br><span class="line">2495</span><br><span class="line">2496</span><br><span class="line">2497</span><br><span class="line">2498</span><br><span class="line">2499</span><br><span class="line">2500</span><br><span class="line">2501</span><br><span class="line">2502</span><br><span class="line">2503</span><br><span class="line">2504</span><br><span class="line">2505</span><br><span class="line">2506</span><br><span class="line">2507</span><br><span class="line">2508</span><br><span class="line">2509</span><br><span class="line">2510</span><br><span class="line">2511</span><br><span class="line">2512</span><br><span class="line">2513</span><br><span class="line">2514</span><br><span class="line">2515</span><br><span class="line">2516</span><br><span class="line">2517</span><br><span class="line">2518</span><br><span class="line">2519</span><br><span class="line">2520</span><br><span class="line">2521</span><br><span class="line">2522</span><br><span class="line">2523</span><br><span class="line">2524</span><br><span class="line">2525</span><br><span class="line">2526</span><br><span class="line">2527</span><br><span class="line">2528</span><br><span class="line">2529</span><br><span class="line">2530</span><br><span class="line">2531</span><br><span class="line">2532</span><br><span class="line">2533</span><br><span class="line">2534</span><br><span class="line">2535</span><br><span class="line">2536</span><br><span class="line">2537</span><br><span class="line">2538</span><br><span class="line">2539</span><br><span class="line">2540</span><br><span class="line">2541</span><br><span class="line">2542</span><br><span class="line">2543</span><br><span class="line">2544</span><br><span class="line">2545</span><br><span class="line">2546</span><br><span class="line">2547</span><br><span class="line">2548</span><br><span class="line">2549</span><br><span class="line">2550</span><br><span class="line">2551</span><br><span class="line">2552</span><br><span class="line">2553</span><br><span class="line">2554</span><br><span class="line">2555</span><br><span class="line">2556</span><br><span class="line">2557</span><br><span class="line">2558</span><br><span class="line">2559</span><br><span class="line">2560</span><br><span class="line">2561</span><br><span class="line">2562</span><br><span class="line">2563</span><br><span class="line">2564</span><br><span class="line">2565</span><br><span class="line">2566</span><br><span class="line">2567</span><br><span class="line">2568</span><br><span class="line">2569</span><br><span class="line">2570</span><br><span class="line">2571</span><br><span class="line">2572</span><br><span class="line">2573</span><br><span class="line">2574</span><br><span class="line">2575</span><br><span class="line">2576</span><br><span class="line">2577</span><br><span class="line">2578</span><br><span class="line">2579</span><br><span class="line">2580</span><br><span class="line">2581</span><br><span class="line">2582</span><br><span class="line">2583</span><br><span class="line">2584</span><br><span class="line">2585</span><br><span class="line">2586</span><br><span class="line">2587</span><br><span class="line">2588</span><br><span class="line">2589</span><br><span class="line">2590</span><br><span class="line">2591</span><br><span class="line">2592</span><br><span class="line">2593</span><br><span class="line">2594</span><br><span class="line">2595</span><br><span class="line">2596</span><br><span class="line">2597</span><br><span class="line">2598</span><br><span class="line">2599</span><br><span class="line">2600</span><br><span class="line">2601</span><br><span class="line">2602</span><br><span class="line">2603</span><br><span class="line">2604</span><br><span class="line">2605</span><br><span class="line">2606</span><br><span class="line">2607</span><br><span class="line">2608</span><br><span class="line">2609</span><br><span class="line">2610</span><br><span class="line">2611</span><br><span class="line">2612</span><br><span class="line">2613</span><br><span class="line">2614</span><br><span class="line">2615</span><br><span class="line">2616</span><br><span class="line">2617</span><br><span class="line">2618</span><br><span class="line">2619</span><br><span class="line">2620</span><br><span class="line">2621</span><br><span class="line">2622</span><br><span class="line">2623</span><br><span class="line">2624</span><br><span class="line">2625</span><br><span class="line">2626</span><br><span class="line">2627</span><br><span class="line">2628</span><br><span class="line">2629</span><br><span class="line">2630</span><br><span class="line">2631</span><br><span class="line">2632</span><br><span class="line">2633</span><br><span class="line">2634</span><br><span class="line">2635</span><br><span class="line">2636</span><br><span class="line">2637</span><br><span class="line">2638</span><br><span class="line">2639</span><br><span class="line">2640</span><br><span class="line">2641</span><br><span class="line">2642</span><br><span class="line">2643</span><br><span class="line">2644</span><br><span class="line">2645</span><br><span class="line">2646</span><br><span class="line">2647</span><br><span class="line">2648</span><br><span class="line">2649</span><br><span class="line">2650</span><br><span class="line">2651</span><br><span class="line">2652</span><br><span class="line">2653</span><br><span class="line">2654</span><br><span class="line">2655</span><br><span class="line">2656</span><br><span class="line">2657</span><br><span class="line">2658</span><br><span class="line">2659</span><br><span class="line">2660</span><br><span class="line">2661</span><br><span class="line">2662</span><br><span class="line">2663</span><br><span class="line">2664</span><br><span class="line">2665</span><br><span class="line">2666</span><br><span class="line">2667</span><br><span class="line">2668</span><br><span class="line">2669</span><br><span class="line">2670</span><br><span class="line">2671</span><br><span class="line">2672</span><br><span class="line">2673</span><br><span class="line">2674</span><br><span class="line">2675</span><br><span class="line">2676</span><br><span class="line">2677</span><br><span class="line">2678</span><br><span class="line">2679</span><br><span class="line">2680</span><br><span class="line">2681</span><br><span class="line">2682</span><br><span class="line">2683</span><br><span class="line">2684</span><br><span class="line">2685</span><br><span class="line">2686</span><br><span class="line">2687</span><br><span class="line">2688</span><br><span class="line">2689</span><br><span class="line">2690</span><br><span class="line">2691</span><br><span class="line">2692</span><br><span class="line">2693</span><br><span class="line">2694</span><br><span class="line">2695</span><br><span class="line">2696</span><br><span class="line">2697</span><br><span class="line">2698</span><br><span class="line">2699</span><br><span class="line">2700</span><br><span class="line">2701</span><br><span class="line">2702</span><br><span class="line">2703</span><br><span class="line">2704</span><br><span class="line">2705</span><br><span class="line">2706</span><br><span class="line">2707</span><br><span class="line">2708</span><br><span class="line">2709</span><br><span class="line">2710</span><br><span class="line">2711</span><br><span class="line">2712</span><br><span class="line">2713</span><br><span class="line">2714</span><br><span class="line">2715</span><br><span class="line">2716</span><br><span class="line">2717</span><br><span class="line">2718</span><br><span class="line">2719</span><br><span class="line">2720</span><br><span class="line">2721</span><br><span class="line">2722</span><br><span class="line">2723</span><br><span class="line">2724</span><br><span class="line">2725</span><br><span class="line">2726</span><br><span class="line">2727</span><br><span class="line">2728</span><br><span class="line">2729</span><br><span class="line">2730</span><br><span class="line">2731</span><br><span class="line">2732</span><br><span class="line">2733</span><br><span class="line">2734</span><br><span class="line">2735</span><br><span class="line">2736</span><br><span class="line">2737</span><br><span class="line">2738</span><br><span class="line">2739</span><br><span class="line">2740</span><br><span class="line">2741</span><br><span class="line">2742</span><br><span class="line">2743</span><br><span class="line">2744</span><br><span class="line">2745</span><br><span class="line">2746</span><br><span class="line">2747</span><br><span class="line">2748</span><br><span class="line">2749</span><br><span class="line">2750</span><br><span class="line">2751</span><br><span class="line">2752</span><br><span class="line">2753</span><br><span class="line">2754</span><br><span class="line">2755</span><br><span class="line">2756</span><br><span class="line">2757</span><br><span class="line">2758</span><br><span class="line">2759</span><br><span class="line">2760</span><br><span class="line">2761</span><br><span class="line">2762</span><br><span class="line">2763</span><br><span class="line">2764</span><br><span class="line">2765</span><br><span class="line">2766</span><br><span class="line">2767</span><br><span class="line">2768</span><br><span class="line">2769</span><br><span class="line">2770</span><br><span class="line">2771</span><br><span class="line">2772</span><br><span class="line">2773</span><br><span class="line">2774</span><br><span class="line">2775</span><br><span class="line">2776</span><br><span class="line">2777</span><br><span class="line">2778</span><br><span class="line">2779</span><br><span class="line">2780</span><br><span class="line">2781</span><br><span class="line">2782</span><br><span class="line">2783</span><br><span class="line">2784</span><br><span class="line">2785</span><br><span class="line">2786</span><br><span class="line">2787</span><br><span class="line">2788</span><br><span class="line">2789</span><br><span class="line">2790</span><br><span class="line">2791</span><br><span class="line">2792</span><br><span class="line">2793</span><br><span class="line">2794</span><br><span class="line">2795</span><br><span class="line">2796</span><br><span class="line">2797</span><br><span class="line">2798</span><br><span class="line">2799</span><br><span class="line">2800</span><br><span class="line">2801</span><br><span class="line">2802</span><br><span class="line">2803</span><br><span class="line">2804</span><br><span class="line">2805</span><br><span class="line">2806</span><br><span class="line">2807</span><br><span class="line">2808</span><br><span class="line">2809</span><br><span class="line">2810</span><br><span class="line">2811</span><br><span class="line">2812</span><br><span class="line">2813</span><br><span class="line">2814</span><br><span class="line">2815</span><br><span class="line">2816</span><br><span class="line">2817</span><br><span class="line">2818</span><br><span class="line">2819</span><br><span class="line">2820</span><br><span class="line">2821</span><br><span class="line">2822</span><br><span class="line">2823</span><br><span class="line">2824</span><br><span class="line">2825</span><br><span class="line">2826</span><br><span class="line">2827</span><br><span class="line">2828</span><br><span class="line">2829</span><br><span class="line">2830</span><br><span class="line">2831</span><br><span class="line">2832</span><br><span class="line">2833</span><br><span class="line">2834</span><br><span class="line">2835</span><br><span class="line">2836</span><br><span class="line">2837</span><br><span class="line">2838</span><br><span class="line">2839</span><br><span class="line">2840</span><br><span class="line">2841</span><br><span class="line">2842</span><br><span class="line">2843</span><br><span class="line">2844</span><br><span class="line">2845</span><br><span class="line">2846</span><br><span class="line">2847</span><br><span class="line">2848</span><br><span class="line">2849</span><br><span class="line">2850</span><br><span class="line">2851</span><br><span class="line">2852</span><br><span class="line">2853</span><br><span class="line">2854</span><br><span class="line">2855</span><br><span class="line">2856</span><br><span class="line">2857</span><br><span class="line">2858</span><br><span class="line">2859</span><br><span class="line">2860</span><br><span class="line">2861</span><br><span class="line">2862</span><br><span class="line">2863</span><br><span class="line">2864</span><br><span class="line">2865</span><br><span class="line">2866</span><br><span class="line">2867</span><br><span class="line">2868</span><br><span class="line">2869</span><br><span class="line">2870</span><br><span class="line">2871</span><br><span class="line">2872</span><br><span class="line">2873</span><br><span class="line">2874</span><br><span class="line">2875</span><br><span class="line">2876</span><br><span class="line">2877</span><br><span class="line">2878</span><br><span class="line">2879</span><br><span class="line">2880</span><br><span class="line">2881</span><br><span class="line">2882</span><br><span class="line">2883</span><br><span class="line">2884</span><br><span class="line">2885</span><br><span class="line">2886</span><br><span class="line">2887</span><br><span class="line">2888</span><br><span class="line">2889</span><br><span class="line">2890</span><br><span class="line">2891</span><br><span class="line">2892</span><br><span class="line">2893</span><br><span class="line">2894</span><br><span class="line">2895</span><br><span class="line">2896</span><br><span class="line">2897</span><br><span class="line">2898</span><br><span class="line">2899</span><br><span class="line">2900</span><br><span class="line">2901</span><br><span class="line">2902</span><br><span class="line">2903</span><br><span class="line">2904</span><br><span class="line">2905</span><br><span class="line">2906</span><br><span class="line">2907</span><br><span class="line">2908</span><br><span class="line">2909</span><br><span class="line">2910</span><br><span class="line">2911</span><br><span class="line">2912</span><br><span class="line">2913</span><br><span class="line">2914</span><br><span class="line">2915</span><br><span class="line">2916</span><br><span class="line">2917</span><br><span class="line">2918</span><br><span class="line">2919</span><br><span class="line">2920</span><br><span class="line">2921</span><br><span class="line">2922</span><br><span class="line">2923</span><br><span class="line">2924</span><br><span class="line">2925</span><br><span class="line">2926</span><br><span class="line">2927</span><br><span class="line">2928</span><br><span class="line">2929</span><br><span class="line">2930</span><br><span class="line">2931</span><br><span class="line">2932</span><br><span class="line">2933</span><br><span class="line">2934</span><br><span class="line">2935</span><br><span class="line">2936</span><br><span class="line">2937</span><br><span class="line">2938</span><br><span class="line">2939</span><br><span class="line">2940</span><br><span class="line">2941</span><br><span class="line">2942</span><br><span class="line">2943</span><br><span class="line">2944</span><br><span class="line">2945</span><br><span class="line">2946</span><br><span class="line">2947</span><br><span class="line">2948</span><br><span class="line">2949</span><br><span class="line">2950</span><br><span class="line">2951</span><br><span class="line">2952</span><br><span class="line">2953</span><br><span class="line">2954</span><br><span class="line">2955</span><br><span class="line">2956</span><br><span class="line">2957</span><br><span class="line">2958</span><br><span class="line">2959</span><br><span class="line">2960</span><br><span class="line">2961</span><br><span class="line">2962</span><br><span class="line">2963</span><br><span class="line">2964</span><br><span class="line">2965</span><br><span class="line">2966</span><br><span class="line">2967</span><br><span class="line">2968</span><br><span class="line">2969</span><br><span class="line">2970</span><br><span class="line">2971</span><br><span class="line">2972</span><br><span class="line">2973</span><br><span class="line">2974</span><br><span class="line">2975</span><br><span class="line">2976</span><br><span class="line">2977</span><br><span class="line">2978</span><br><span class="line">2979</span><br><span class="line">2980</span><br><span class="line">2981</span><br><span class="line">2982</span><br><span class="line">2983</span><br><span class="line">2984</span><br><span class="line">2985</span><br><span class="line">2986</span><br><span class="line">2987</span><br><span class="line">2988</span><br><span class="line">2989</span><br><span class="line">2990</span><br><span class="line">2991</span><br><span class="line">2992</span><br><span class="line">2993</span><br><span class="line">2994</span><br><span class="line">2995</span><br><span class="line">2996</span><br><span class="line">2997</span><br><span class="line">2998</span><br><span class="line">2999</span><br><span class="line">3000</span><br><span class="line">3001</span><br><span class="line">3002</span><br><span class="line">3003</span><br><span class="line">3004</span><br><span class="line">3005</span><br><span class="line">3006</span><br><span class="line">3007</span><br><span class="line">3008</span><br><span class="line">3009</span><br><span class="line">3010</span><br><span class="line">3011</span><br><span class="line">3012</span><br><span class="line">3013</span><br><span class="line">3014</span><br><span class="line">3015</span><br><span class="line">3016</span><br><span class="line">3017</span><br><span class="line">3018</span><br><span class="line">3019</span><br><span class="line">3020</span><br><span class="line">3021</span><br><span class="line">3022</span><br><span class="line">3023</span><br><span class="line">3024</span><br><span class="line">3025</span><br><span class="line">3026</span><br><span class="line">3027</span><br><span class="line">3028</span><br><span class="line">3029</span><br><span class="line">3030</span><br><span class="line">3031</span><br><span class="line">3032</span><br><span class="line">3033</span><br><span class="line">3034</span><br><span class="line">3035</span><br><span class="line">3036</span><br><span class="line">3037</span><br><span class="line">3038</span><br><span class="line">3039</span><br><span class="line">3040</span><br><span class="line">3041</span><br><span class="line">3042</span><br><span class="line">3043</span><br><span class="line">3044</span><br><span class="line">3045</span><br><span class="line">3046</span><br><span class="line">3047</span><br><span class="line">3048</span><br><span class="line">3049</span><br><span class="line">3050</span><br><span class="line">3051</span><br><span class="line">3052</span><br><span class="line">3053</span><br><span class="line">3054</span><br><span class="line">3055</span><br><span class="line">3056</span><br><span class="line">3057</span><br><span class="line">3058</span><br><span class="line">3059</span><br><span class="line">3060</span><br><span class="line">3061</span><br><span class="line">3062</span><br><span class="line">3063</span><br><span class="line">3064</span><br><span class="line">3065</span><br><span class="line">3066</span><br><span class="line">3067</span><br><span class="line">3068</span><br><span class="line">3069</span><br><span class="line">3070</span><br><span class="line">3071</span><br><span class="line">3072</span><br><span class="line">3073</span><br><span class="line">3074</span><br><span class="line">3075</span><br><span class="line">3076</span><br><span class="line">3077</span><br><span class="line">3078</span><br><span class="line">3079</span><br><span class="line">3080</span><br><span class="line">3081</span><br><span class="line">3082</span><br><span class="line">3083</span><br><span class="line">3084</span><br><span class="line">3085</span><br><span class="line">3086</span><br><span class="line">3087</span><br><span class="line">3088</span><br><span class="line">3089</span><br><span class="line">3090</span><br><span class="line">3091</span><br><span class="line">3092</span><br><span class="line">3093</span><br><span class="line">3094</span><br><span class="line">3095</span><br><span class="line">3096</span><br><span class="line">3097</span><br><span class="line">3098</span><br><span class="line">3099</span><br><span class="line">3100</span><br><span class="line">3101</span><br><span class="line">3102</span><br><span class="line">3103</span><br><span class="line">3104</span><br><span class="line">3105</span><br><span class="line">3106</span><br><span class="line">3107</span><br><span class="line">3108</span><br><span class="line">3109</span><br><span class="line">3110</span><br><span class="line">3111</span><br><span class="line">3112</span><br><span class="line">3113</span><br><span class="line">3114</span><br><span class="line">3115</span><br><span class="line">3116</span><br><span class="line">3117</span><br><span class="line">3118</span><br><span class="line">3119</span><br><span class="line">3120</span><br><span class="line">3121</span><br><span class="line">3122</span><br><span class="line">3123</span><br><span class="line">3124</span><br><span class="line">3125</span><br><span class="line">3126</span><br><span class="line">3127</span><br><span class="line">3128</span><br><span class="line">3129</span><br><span class="line">3130</span><br><span class="line">3131</span><br><span class="line">3132</span><br><span class="line">3133</span><br><span class="line">3134</span><br><span class="line">3135</span><br><span class="line">3136</span><br><span class="line">3137</span><br><span class="line">3138</span><br><span class="line">3139</span><br><span class="line">3140</span><br><span class="line">3141</span><br><span class="line">3142</span><br><span class="line">3143</span><br><span class="line">3144</span><br><span class="line">3145</span><br><span class="line">3146</span><br><span class="line">3147</span><br><span class="line">3148</span><br><span class="line">3149</span><br><span class="line">3150</span><br><span class="line">3151</span><br><span class="line">3152</span><br><span class="line">3153</span><br><span class="line">3154</span><br><span class="line">3155</span><br><span class="line">3156</span><br><span class="line">3157</span><br><span class="line">3158</span><br><span class="line">3159</span><br><span class="line">3160</span><br><span class="line">3161</span><br><span class="line">3162</span><br><span class="line">3163</span><br><span class="line">3164</span><br><span class="line">3165</span><br><span class="line">3166</span><br><span class="line">3167</span><br><span class="line">3168</span><br><span class="line">3169</span><br><span class="line">3170</span><br><span class="line">3171</span><br><span class="line">3172</span><br><span class="line">3173</span><br><span class="line">3174</span><br><span class="line">3175</span><br><span class="line">3176</span><br><span class="line">3177</span><br><span class="line">3178</span><br><span class="line">3179</span><br><span class="line">3180</span><br><span class="line">3181</span><br><span class="line">3182</span><br><span class="line">3183</span><br><span class="line">3184</span><br><span class="line">3185</span><br><span class="line">3186</span><br><span class="line">3187</span><br><span class="line">3188</span><br><span class="line">3189</span><br><span class="line">3190</span><br><span class="line">3191</span><br><span class="line">3192</span><br><span class="line">3193</span><br><span class="line">3194</span><br><span class="line">3195</span><br><span class="line">3196</span><br><span class="line">3197</span><br><span class="line">3198</span><br><span class="line">3199</span><br><span class="line">3200</span><br><span class="line">3201</span><br><span class="line">3202</span><br><span class="line">3203</span><br><span class="line">3204</span><br><span class="line">3205</span><br><span class="line">3206</span><br><span class="line">3207</span><br><span class="line">3208</span><br><span class="line">3209</span><br><span class="line">3210</span><br><span class="line">3211</span><br><span class="line">3212</span><br><span class="line">3213</span><br><span class="line">3214</span><br><span class="line">3215</span><br><span class="line">3216</span><br><span class="line">3217</span><br><span class="line">3218</span><br><span class="line">3219</span><br><span class="line">3220</span><br><span class="line">3221</span><br><span class="line">3222</span><br><span class="line">3223</span><br><span class="line">3224</span><br><span class="line">3225</span><br><span class="line">3226</span><br><span class="line">3227</span><br><span class="line">3228</span><br><span class="line">3229</span><br></pre></td><td class="code"><pre><span class="line">&lt;!doctype html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;CSS3动画实现方式大全&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.2.1.js&quot; &gt;&lt;/script&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.left &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">color: white;</span><br><span class="line">background: #444444;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left ul &#123;</span><br><span class="line">list-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.left a &#123;</span><br><span class="line">color: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#right &#123;</span><br><span class="line">position: fixed;</span><br><span class="line">top: 100px;</span><br><span class="line">right: 30%;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 200px;</span><br><span class="line">margin: 100px auto;</span><br><span class="line">background: url(http://www.100sucai.com/img/demo/1373.png)</span><br><span class="line">&#125;</span><br><span class="line">/*******************1、闪光灯***********************/</span><br><span class="line"></span><br><span class="line">.animation1 &#123;</span><br><span class="line">-webkit-animation: flash 1s .2s ease both;</span><br><span class="line">-moz-animation: flash 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes flash &#123;</span><br><span class="line">0%,</span><br><span class="line">50%,</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">25%,</span><br><span class="line">75% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes flash &#123;</span><br><span class="line">0%,</span><br><span class="line">50%,</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">25%,</span><br><span class="line">75% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************2、弹起***********************/</span><br><span class="line"></span><br><span class="line">.animation2 &#123;</span><br><span class="line">-webkit-animation: bounce 1s .2s ease both;</span><br><span class="line">-moz-animation: bounce 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounce &#123;</span><br><span class="line">0%,</span><br><span class="line">20%,</span><br><span class="line">50%,</span><br><span class="line">80%,</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: translateY(-30px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: translateY(-15px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounce &#123;</span><br><span class="line">0%,</span><br><span class="line">20%,</span><br><span class="line">50%,</span><br><span class="line">80%,</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-moz-transform: translateY(-30px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-moz-transform: translateY(-15px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************3、摇摆***********************/</span><br><span class="line"></span><br><span class="line">.animation3 &#123;</span><br><span class="line">-webkit-animation: shake 1s .2s ease both;</span><br><span class="line">-moz-animation: shake 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes shake &#123;</span><br><span class="line">0%,</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateX(0);</span><br><span class="line">&#125;</span><br><span class="line">10%,</span><br><span class="line">30%,</span><br><span class="line">50%,</span><br><span class="line">70%,</span><br><span class="line">90% &#123;</span><br><span class="line">-webkit-transform: translateX(-10px);</span><br><span class="line">&#125;</span><br><span class="line">20%,</span><br><span class="line">40%,</span><br><span class="line">60%,</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateX(10px);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes shake &#123;</span><br><span class="line">0%,</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateX(0);</span><br><span class="line">&#125;</span><br><span class="line">10%,</span><br><span class="line">30%,</span><br><span class="line">50%,</span><br><span class="line">70%,</span><br><span class="line">90% &#123;</span><br><span class="line">-moz-transform: translateX(-10px);</span><br><span class="line">&#125;</span><br><span class="line">20%,</span><br><span class="line">40%,</span><br><span class="line">60%,</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: translateX(10px);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************4、秋千***********************/</span><br><span class="line"></span><br><span class="line">.animation4 &#123;</span><br><span class="line">-webkit-animation: tada 1s .2s ease both;</span><br><span class="line">-moz-animation: tada 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes tada &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">10%,</span><br><span class="line">20% &#123;</span><br><span class="line">-webkit-transform: scale(0.9) rotate(-3deg)</span><br><span class="line">&#125;</span><br><span class="line">30%,</span><br><span class="line">50%,</span><br><span class="line">70%,</span><br><span class="line">90% &#123;</span><br><span class="line">-webkit-transform: scale(1.1) rotate(3deg)</span><br><span class="line">&#125;</span><br><span class="line">40%,</span><br><span class="line">60%,</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scale(1.1) rotate(-3deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scale(1) rotate(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes tada &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">10%,</span><br><span class="line">20% &#123;</span><br><span class="line">-moz-transform: scale(0.9) rotate(-3deg)</span><br><span class="line">&#125;</span><br><span class="line">30%,</span><br><span class="line">50%,</span><br><span class="line">70%,</span><br><span class="line">90% &#123;</span><br><span class="line">-moz-transform: scale(1.1) rotate(3deg)</span><br><span class="line">&#125;</span><br><span class="line">40%,</span><br><span class="line">60%,</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: scale(1.1) rotate(-3deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: scale(1) rotate(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************5、swing***********************/</span><br><span class="line"></span><br><span class="line">.animation5 &#123;</span><br><span class="line">-webkit-animation: swing 1s .2s ease both;</span><br><span class="line">-moz-animation: swing 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes swing &#123;</span><br><span class="line">20%,</span><br><span class="line">40%,</span><br><span class="line">60%,</span><br><span class="line">80%,</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: top center</span><br><span class="line">&#125;</span><br><span class="line">20% &#123;</span><br><span class="line">-webkit-transform: rotate(15deg)</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: rotate(-10deg)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: rotate(5deg)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: rotate(-5deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: rotate(0deg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes swing &#123;</span><br><span class="line">20%,</span><br><span class="line">40%,</span><br><span class="line">60%,</span><br><span class="line">80%,</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: top center</span><br><span class="line">&#125;</span><br><span class="line">20% &#123;</span><br><span class="line">-moz-transform: rotate(15deg)</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-moz-transform: rotate(-10deg)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-moz-transform: rotate(5deg)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: rotate(-5deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: rotate(0deg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************6、疯狂摆动***********************/</span><br><span class="line"></span><br><span class="line">.animation6 &#123;</span><br><span class="line">-webkit-animation: wobble 1s .2s ease both;</span><br><span class="line">-moz-animation: wobble 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes wobble &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateX(0%)</span><br><span class="line">&#125;</span><br><span class="line">15% &#123;</span><br><span class="line">-webkit-transform: translateX(-25%) rotate(-5deg)</span><br><span class="line">&#125;</span><br><span class="line">30% &#123;</span><br><span class="line">-webkit-transform: translateX(20%) rotate(3deg)</span><br><span class="line">&#125;</span><br><span class="line">45% &#123;</span><br><span class="line">-webkit-transform: translateX(-15%) rotate(-3deg)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: translateX(10%) rotate(2deg)</span><br><span class="line">&#125;</span><br><span class="line">75% &#123;</span><br><span class="line">-webkit-transform: translateX(-5%) rotate(-1deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateX(0%)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes wobble &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: translateX(0%)</span><br><span class="line">&#125;</span><br><span class="line">15% &#123;</span><br><span class="line">-moz-transform: translateX(-25%) rotate(-5deg)</span><br><span class="line">&#125;</span><br><span class="line">30% &#123;</span><br><span class="line">-moz-transform: translateX(20%) rotate(3deg)</span><br><span class="line">&#125;</span><br><span class="line">45% &#123;</span><br><span class="line">-moz-transform: translateX(-15%) rotate(-3deg)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-moz-transform: translateX(10%) rotate(2deg)</span><br><span class="line">&#125;</span><br><span class="line">75% &#123;</span><br><span class="line">-moz-transform: translateX(-5%) rotate(-1deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateX(0%)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************7、脉冲***********************/</span><br><span class="line"></span><br><span class="line">.animation7 &#123;</span><br><span class="line">-webkit-animation: pulse 1s .2s ease both;</span><br><span class="line">-moz-animation: pulse 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes pulse &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: scale(1.1)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes pulse &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-moz-transform: scale(1.1)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************8、翻转***********************/</span><br><span class="line"></span><br><span class="line">.animation8 &#123;</span><br><span class="line">-webkit-animation: flip 1s .2s ease both;</span><br><span class="line">-moz-animation: flip 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes flip &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateY(0);</span><br><span class="line">-webkit-animation-timing-function: ease-out</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) translateZ(150px) rotateY(170deg);</span><br><span class="line">-webkit-animation-timing-function: ease-out</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) translateZ(150px) rotateY(190deg) scale(1);</span><br><span class="line">-webkit-animation-timing-function: ease-in</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateY(360deg) scale(.95);</span><br><span class="line">-webkit-animation-timing-function: ease-in</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) scale(1);</span><br><span class="line">-webkit-animation-timing-function: ease-in</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes flip &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateY(0);</span><br><span class="line">-moz-animation-timing-function: ease-out</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-moz-transform: perspective(400px) translateZ(150px) rotateY(170deg);</span><br><span class="line">-moz-animation-timing-function: ease-out</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-moz-transform: perspective(400px) translateZ(150px) rotateY(190deg) scale(1);</span><br><span class="line">-moz-animation-timing-function: ease-in</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateY(360deg) scale(.95);</span><br><span class="line">-moz-animation-timing-function: ease-in</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: perspective(400px) scale(1);</span><br><span class="line">-moz-animation-timing-function: ease-in</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************9、X轴淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation9 &#123;</span><br><span class="line">-webkit-animation: flipInX 1s .2s ease both;</span><br><span class="line">-moz-animation: flipInX 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes flipInX &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateX(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateX(-10deg)</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateX(10deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateX(0deg);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes flipInX &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateX(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateX(-10deg)</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateX(10deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateX(0deg);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************10、X轴淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation10 &#123;</span><br><span class="line">-webkit-animation: flipOutX 1s .2s ease both;</span><br><span class="line">-moz-animation: flipOutX 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes flipOutX &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateX(0deg);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateX(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes flipOutX &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateX(0deg);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateX(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************11、Y轴淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation11 &#123;</span><br><span class="line">-webkit-animation: flipInY 1s .2s ease both;</span><br><span class="line">-moz-animation: flipInY 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes flipInY &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateY(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateY(-10deg)</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateY(10deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateY(0deg);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes flipInY &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateY(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateY(-10deg)</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateY(10deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateY(0deg);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************12、Y轴淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation12 &#123;</span><br><span class="line">-webkit-animation: flipOutY 1s .2s ease both;</span><br><span class="line">-moz-animation: flipOutY 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes flipOutY &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateY(0deg);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: perspective(400px) rotateY(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes flipOutY &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateY(0deg);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: perspective(400px) rotateY(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************13、下方淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation13 &#123;</span><br><span class="line">-webkit-animation: fadeInUp 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeInUp 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeInUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeInUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************14、上方淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation14 &#123;</span><br><span class="line">-webkit-animation: fadeInDown 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeInDown 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeInDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(-20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeInDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(-20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************15、左边淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation15 &#123;</span><br><span class="line">-webkit-animation: fadeInLeft 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeInLeft 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeInLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(-20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeInLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(-20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************16、右边淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation16 &#123;</span><br><span class="line">-webkit-animation: fadeInRight 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeInRight 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeInRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeInRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************17、底部淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation17 &#123;</span><br><span class="line">-webkit-animation: fadeInUpBig 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeInUpBig 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeInUpBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(2000px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeInUpBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(2000px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************18、顶部淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation18 &#123;</span><br><span class="line">-webkit-animation: fadeInDownBig 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeInDownBig 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeInDownBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeInDownBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************19、页面左边淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation19 &#123;</span><br><span class="line">-webkit-animation: fadeInLeftBig 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeInLeftBig 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeInLeftBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeInLeftBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************20、页面右边淡入***********************/</span><br><span class="line"></span><br><span class="line">.animation20 &#123;</span><br><span class="line">-webkit-animation: fadeInRightBig 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeInRightBig 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeInRightBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(2000px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeInRightBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(2000px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************21、向上淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation21 &#123;</span><br><span class="line">-webkit-animation: fadeOutUp 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeOutUp 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeOutUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(-20px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeOutUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(-20px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************22、向下淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation22 &#123;</span><br><span class="line">-webkit-animation: fadeOutDown 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeOutDown 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeOutDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(20px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeOutDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(20px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************23、向左淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation23 &#123;</span><br><span class="line">-webkit-animation: fadeOutLeft 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeOutLeft 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeOutLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(-20px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeOutLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(-20px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************24、向右淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation24 &#123;</span><br><span class="line">-webkit-animation: fadeOutRight 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeOutRight 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeOutRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(20px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeOutRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(20px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************25、顶部淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation25 &#123;</span><br><span class="line">-webkit-animation: fadeOutTopBig 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeOutTopBig 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeOutTopBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeOutTopBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************26、底部淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation26 &#123;</span><br><span class="line">-webkit-animation: fadeOutUpBig 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeOutUpBig 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeOutUpBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeOutUpBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************27、页面左边淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation27 &#123;</span><br><span class="line">-webkit-animation: fadeOutLeftBig 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeOutLeftBig 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeOutLeftBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeOutLeftBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************28、页面右边淡出***********************/</span><br><span class="line"></span><br><span class="line">.animation28 &#123;</span><br><span class="line">-webkit-animation: fadeOutRightBig 1s .2s ease both;</span><br><span class="line">-moz-animation: fadeOutRightBig 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeOutRightBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes fadeOutRightBig &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************29、bounceIn***********************/</span><br><span class="line"></span><br><span class="line">.animation29 &#123;</span><br><span class="line">-webkit-animation: bounceIn 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceIn 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceIn &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: scale(.3)</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: scale(1.05)</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">-webkit-transform: scale(.9)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceIn &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: scale(.3)</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: scale(1.05)</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">-moz-transform: scale(.9)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************30、bounceInDown***********************/</span><br><span class="line"></span><br><span class="line">.animation30 &#123;</span><br><span class="line">-webkit-animation: bounceInDown 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceInDown 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceInDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateY(-10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceInDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: translateY(-10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************31、bounceInUp***********************/</span><br><span class="line"></span><br><span class="line">.animation31 &#123;</span><br><span class="line">-webkit-animation: bounceInUp 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceInUp 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceInUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(-30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateY(10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceInUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(-30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: translateY(10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************32、bounceInLeft***********************/</span><br><span class="line"></span><br><span class="line">.animation32 &#123;</span><br><span class="line">-webkit-animation: bounceInLeft 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceInLeft 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceInLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateX(-10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceInLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: translateX(-10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************33、bounceInRight***********************/</span><br><span class="line"></span><br><span class="line">.animation33 &#123;</span><br><span class="line">-webkit-animation: bounceInRight 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceInRight 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceInRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(-30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateX(10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceInRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(-30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: translateX(10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************34、bounceOut***********************/</span><br><span class="line"></span><br><span class="line">.animation34 &#123;</span><br><span class="line">-webkit-animation: bounceOut 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceOut 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceOut &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">25% &#123;</span><br><span class="line">-webkit-transform: scale(.95)</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: scale(1.1)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: scale(.3)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceOut &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: scale(1)</span><br><span class="line">&#125;</span><br><span class="line">25% &#123;</span><br><span class="line">-moz-transform: scale(.95)</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: scale(1.1)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: scale(.3)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************35、bounceOutDown***********************/</span><br><span class="line"></span><br><span class="line">.animation35 &#123;</span><br><span class="line">-webkit-animation: bounceOutDown 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceOutDown 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceOutDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">20% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(-20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceOutDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">20% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(-20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************36、bounceOutUp***********************/</span><br><span class="line"></span><br><span class="line">.animation36 &#123;</span><br><span class="line">-webkit-animation: bounceOutUp 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceOutUp 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceOutUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">20% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateY(20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceOutUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: translateY(0)</span><br><span class="line">&#125;</span><br><span class="line">20% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateY(20px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateY(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************37、bounceOutLeft***********************/</span><br><span class="line"></span><br><span class="line">.animation37 &#123;</span><br><span class="line">-webkit-animation: bounceInLeft 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceInLeft 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceInLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateX(-10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceInLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(-2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: translateX(-10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************38、bounceOutRight***********************/</span><br><span class="line"></span><br><span class="line">.animation38 &#123;</span><br><span class="line">-webkit-animation: bounceInRight 1s .2s ease both;</span><br><span class="line">-moz-animation: bounceInRight 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounceInRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(-30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateX(10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes bounceInRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(2000px)</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(-30px)</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: translateX(10px)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateX(0)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************39、rotateIn***********************/</span><br><span class="line"></span><br><span class="line">.animation39 &#123;</span><br><span class="line">-webkit-animation: rotateIn 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateIn 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateIn &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: center center;</span><br><span class="line">-webkit-transform: rotate(-200deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: center center;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateIn &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: center center;</span><br><span class="line">-moz-transform: rotate(-200deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: center center;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************40、rotateInDownLeft***********************/</span><br><span class="line"></span><br><span class="line">.animation40 &#123;</span><br><span class="line">-webkit-animation: rotateInDownLeft 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateInDownLeft 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateInDownLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: left bottom;</span><br><span class="line">-webkit-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: left bottom;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateInDownLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: left bottom;</span><br><span class="line">-moz-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: left bottom;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************41、rotateInDownRight***********************/</span><br><span class="line"></span><br><span class="line">.animation41 &#123;</span><br><span class="line">-webkit-animation: rotateInDownRight 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateInDownRight 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateInDownRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: right bottom;</span><br><span class="line">-webkit-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: right bottom;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateInDownRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: right bottom;</span><br><span class="line">-moz-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: right bottom;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************42、rotateInUpLeft***********************/</span><br><span class="line"></span><br><span class="line">.animation42 &#123;</span><br><span class="line">-webkit-animation: rotateInUpLeft 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateInUpLeft 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateInUpLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: left bottom;</span><br><span class="line">-webkit-transform: rotate(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: left bottom;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateInUpLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: left bottom;</span><br><span class="line">-moz-transform: rotate(90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: left bottom;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************43、rotateInUpRight***********************/</span><br><span class="line"></span><br><span class="line">.animation43 &#123;</span><br><span class="line">-webkit-animation: rotateInUpRight 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateInUpRight 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateInUpRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: right bottom;</span><br><span class="line">-webkit-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: right bottom;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateInUpRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: right bottom;</span><br><span class="line">-moz-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: right bottom;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************44、rotateOut***********************/</span><br><span class="line"></span><br><span class="line">.animation44 &#123;</span><br><span class="line">-webkit-animation: rotateOut 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateOut 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateOut &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateOut &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************45、rotateOutDownLeft***********************/</span><br><span class="line"></span><br><span class="line">.animation45 &#123;</span><br><span class="line">-webkit-animation: rotateOutDownLeft 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateOutDownLeft 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateOutDownLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: left bottom;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: left bottom;</span><br><span class="line">-webkit-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateOutDownLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: left bottom;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: left bottom;</span><br><span class="line">-moz-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************46、rotateOutDownRight***********************/</span><br><span class="line"></span><br><span class="line">.animation46 &#123;</span><br><span class="line">-webkit-animation: rotateOutDownRight 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateOutDownRight 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateOutDownRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: right bottom;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: right bottom;</span><br><span class="line">-webkit-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateOutDownRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: right bottom;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: right bottom;</span><br><span class="line">-moz-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************47、rotateOutUpLeft***********************/</span><br><span class="line"></span><br><span class="line">.animation47 &#123;</span><br><span class="line">-webkit-animation: rotateOutUpLeft 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateOutUpLeft 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateOutUpLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: left top;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: left top;</span><br><span class="line">-webkit-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateOutUpLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: left top;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: left top;</span><br><span class="line">-moz-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************48、rotateOutUpRight***********************/</span><br><span class="line"></span><br><span class="line">.animation48 &#123;</span><br><span class="line">-webkit-animation: rotateOutUpRight 1s .2s ease both;</span><br><span class="line">-moz-animation: rotateOutUpRight 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rotateOutUpRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform-origin: right top;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform-origin: right top;</span><br><span class="line">-webkit-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rotateOutUpRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform-origin: right top;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">opacity: 1</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform-origin: right top;</span><br><span class="line">-moz-transform: rotate(-90deg);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************49、hinge***********************/</span><br><span class="line"></span><br><span class="line">.animation49 &#123;</span><br><span class="line">-webkit-animation: hinge 1s .2s ease both;</span><br><span class="line">-moz-animation: hinge 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes hinge &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: rotate(0);</span><br><span class="line">-webkit-transform-origin: top left;</span><br><span class="line">-webkit-animation-timing-function: ease-in-out</span><br><span class="line">&#125;</span><br><span class="line">20%,</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: rotate(80deg);</span><br><span class="line">-webkit-transform-origin: top left;</span><br><span class="line">-webkit-animation-timing-function: ease-in-out</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: rotate(60deg);</span><br><span class="line">-webkit-transform-origin: top left;</span><br><span class="line">-webkit-animation-timing-function: ease-in-out</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: rotate(60deg) translateY(0);</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform-origin: top left;</span><br><span class="line">-webkit-animation-timing-function: ease-in-out</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(700px);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes hinge &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-moz-transform: rotate(0);</span><br><span class="line">-moz-transform-origin: top left;</span><br><span class="line">-moz-animation-timing-function: ease-in-out</span><br><span class="line">&#125;</span><br><span class="line">20%,</span><br><span class="line">60% &#123;</span><br><span class="line">-moz-transform: rotate(80deg);</span><br><span class="line">-moz-transform-origin: top left;</span><br><span class="line">-moz-animation-timing-function: ease-in-out</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-moz-transform: rotate(60deg);</span><br><span class="line">-moz-transform-origin: top left;</span><br><span class="line">-moz-animation-timing-function: ease-in-out</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-moz-transform: rotate(60deg) translateY(0);</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform-origin: top left;</span><br><span class="line">-moz-animation-timing-function: ease-in-out</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-moz-transform: translateY(700px);</span><br><span class="line">opacity: 0</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************50、rollIn***********************/</span><br><span class="line"></span><br><span class="line">.animation50 &#123;</span><br><span class="line">-webkit-animation: rollIn 1s .2s ease both;</span><br><span class="line">-moz-animation: rollIn 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rollIn &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(-100%) rotate(-120deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0px) rotate(0deg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rollIn &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(-100%) rotate(-120deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0px) rotate(0deg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************51、rollOut***********************/</span><br><span class="line"></span><br><span class="line">.animation51 &#123;</span><br><span class="line">-webkit-animation: rollOut 1s .2s ease both;</span><br><span class="line">-moz-animation: rollOut 1s .2s ease both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes rollOut &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-webkit-transform: translateX(0px) rotate(0deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-webkit-transform: translateX(100%) rotate(120deg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes rollOut &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">opacity: 1;</span><br><span class="line">-moz-transform: translateX(0px) rotate(0deg)</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">opacity: 0;</span><br><span class="line">-moz-transform: translateX(100%) rotate(120deg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************52、slideDown***********************/</span><br><span class="line"></span><br><span class="line">.slideDown &#123;</span><br><span class="line">animation-name: slideDown;</span><br><span class="line">-webkit-animation-name: slideDown;</span><br><span class="line">animation-duration: 1s;</span><br><span class="line">-webkit-animation-duration: 1s;</span><br><span class="line">animation-timing-function: ease;</span><br><span class="line">-webkit-animation-timing-function: ease;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes slideDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: translateY(-100%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: translateY(8%);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">transform: translateY(-4%);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: translateY(4%);</span><br><span class="line">&#125;</span><br><span class="line">95% &#123;</span><br><span class="line">transform: translateY(-2%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: translateY(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes slideDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateY(-100%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: translateY(8%);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">-webkit-transform: translateY(-4%);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateY(4%);</span><br><span class="line">&#125;</span><br><span class="line">95% &#123;</span><br><span class="line">-webkit-transform: translateY(-2%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************53、slideUp***********************/</span><br><span class="line"></span><br><span class="line">.slideUp &#123;</span><br><span class="line">animation-name: slideUp;</span><br><span class="line">-webkit-animation-name: slideUp;</span><br><span class="line">animation-duration: 1s;</span><br><span class="line">-webkit-animation-duration: 1s;</span><br><span class="line">animation-timing-function: ease;</span><br><span class="line">-webkit-animation-timing-function: ease;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes slideUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: translateY(100%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: translateY(-8%);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">transform: translateY(4%);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: translateY(-4%);</span><br><span class="line">&#125;</span><br><span class="line">95% &#123;</span><br><span class="line">transform: translateY(2%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: translateY(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes slideUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateY(100%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: translateY(-8%);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">-webkit-transform: translateY(4%);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateY(-4%);</span><br><span class="line">&#125;</span><br><span class="line">95% &#123;</span><br><span class="line">-webkit-transform: translateY(2%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************54、slideLeft***********************/</span><br><span class="line"></span><br><span class="line">.slideLeft &#123;</span><br><span class="line">animation-name: slideLeft;</span><br><span class="line">-webkit-animation-name: slideLeft;</span><br><span class="line">animation-duration: 1s;</span><br><span class="line">-webkit-animation-duration: 1s;</span><br><span class="line">animation-timing-function: ease-in-out;</span><br><span class="line">-webkit-animation-timing-function: ease-in-out;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes slideLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: translateX(150%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: translateX(-8%);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">transform: translateX(4%);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: translateX(-4%);</span><br><span class="line">&#125;</span><br><span class="line">95% &#123;</span><br><span class="line">transform: translateX(2%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: translateX(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes slideLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateX(150%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: translateX(-8%);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">-webkit-transform: translateX(4%);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateX(-4%);</span><br><span class="line">&#125;</span><br><span class="line">95% &#123;</span><br><span class="line">-webkit-transform: translateX(2%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateX(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************55、slideRight***********************/</span><br><span class="line"></span><br><span class="line">.slideRight &#123;</span><br><span class="line">animation-name: slideRight;</span><br><span class="line">-webkit-animation-name: slideRight;</span><br><span class="line">animation-duration: 1s;</span><br><span class="line">-webkit-animation-duration: 1s;</span><br><span class="line">animation-timing-function: ease-in-out;</span><br><span class="line">-webkit-animation-timing-function: ease-in-out;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes slideRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: translateX(-150%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: translateX(8%);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">transform: translateX(-4%);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: translateX(4%);</span><br><span class="line">&#125;</span><br><span class="line">95% &#123;</span><br><span class="line">transform: translateX(-2%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: translateX(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes slideRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateX(-150%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: translateX(8%);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">-webkit-transform: translateX(-4%);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateX(4%);</span><br><span class="line">&#125;</span><br><span class="line">95% &#123;</span><br><span class="line">-webkit-transform: translateX(-2%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateX(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************56、slideExpandUp***********************/</span><br><span class="line"></span><br><span class="line">.slideExpandUp &#123;</span><br><span class="line">animation-name: slideExpandUp;</span><br><span class="line">-webkit-animation-name: slideExpandUp;</span><br><span class="line">animation-duration: 1.6s;</span><br><span class="line">-webkit-animation-duration: 1.6s;</span><br><span class="line">animation-timing-function: ease-out;</span><br><span class="line">-webkit-animation-timing-function: ease -out;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes slideExpandUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: translateY(100%) scaleX(0.5);</span><br><span class="line">&#125;</span><br><span class="line">30% &#123;</span><br><span class="line">transform: translateY(-8%) scaleX(0.5);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">transform: translateY(2%) scaleX(0.5);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: translateY(0%) scaleX(1.1);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: translateY(0%) scaleX(0.9);</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">transform: translateY(0%) scaleX(1.05);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: translateY(0%) scaleX(0.95);</span><br><span class="line">&#125;</span><br><span class="line">90% &#123;</span><br><span class="line">transform: translateY(0%) scaleX(1.02);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: translateY(0%) scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes slideExpandUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateY(100%) scaleX(0.5);</span><br><span class="line">&#125;</span><br><span class="line">30% &#123;</span><br><span class="line">-webkit-transform: translateY(-8%) scaleX(0.5);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: translateY(2%) scaleX(0.5);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleX(1.1);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleX(0.9);</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleX(1.05);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleX(0.95);</span><br><span class="line">&#125;</span><br><span class="line">90% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleX(1.02);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************57、expandUp***********************/</span><br><span class="line"></span><br><span class="line">.expandUp &#123;</span><br><span class="line">animation-name: expandUp;</span><br><span class="line">-webkit-animation-name: expandUp;</span><br><span class="line">animation-duration: 0.7s;</span><br><span class="line">-webkit-animation-duration: 0.7s;</span><br><span class="line">animation-timing-function: ease;</span><br><span class="line">-webkit-animation-timing-function: ease;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes expandUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: translateY(100%) scale(0.6) scaleY(0.5);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: translateY(-7%) scaleY(1.12);</span><br><span class="line">&#125;</span><br><span class="line">75% &#123;</span><br><span class="line">transform: translateY(3%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: translateY(0%) scale(1) scaleY(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes expandUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateY(100%) scale(0.6) scaleY(0.5);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: translateY(-7%) scaleY(1.12);</span><br><span class="line">&#125;</span><br><span class="line">75% &#123;</span><br><span class="line">-webkit-transform: translateY(3%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scale(1) scaleY(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************58、bounce***********************/</span><br><span class="line"></span><br><span class="line">.bounce &#123;</span><br><span class="line">animation-name: bounce;</span><br><span class="line">-webkit-animation-name: bounce;</span><br><span class="line">animation-duration: 1.6s;</span><br><span class="line">-webkit-animation-duration: 1.6s;</span><br><span class="line">animation-timing-function: ease;</span><br><span class="line">-webkit-animation-timing-function: ease;</span><br><span class="line">transform-origin: 50% 100%;</span><br><span class="line">-ms-transform-origin: 50% 100%;</span><br><span class="line">-webkit-transform-origin: 50% 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes bounce &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: translateY(0%) scaleY(0.6);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: translateY(-100%) scaleY(1.1);</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">transform: translateY(0%) scaleY(0.95) scaleX(1.05);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: translateY(0%) scaleY(1.05) scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">90% &#123;</span><br><span class="line">transform: translateY(0%) scaleY(0.95) scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: translateY(0%) scaleY(1) scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bounce &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleY(0.6);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: translateY(-100%) scaleY(1.1);</span><br><span class="line">&#125;</span><br><span class="line">70% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleY(0.95) scaleX(1.05);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleY(1.05) scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">90% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleY(0.95) scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0%) scaleY(1) scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************59、pulse***********************/</span><br><span class="line"></span><br><span class="line">.pulse &#123;</span><br><span class="line">animation-name: pulse;</span><br><span class="line">-webkit-animation-name: pulse;</span><br><span class="line">animation-duration: 1.5s;</span><br><span class="line">-webkit-animation-duration: 1.5s;</span><br><span class="line">animation-iteration-count: infinite;</span><br><span class="line">-webkit-animation-iteration-count: infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes pulse &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: scale(0.9);</span><br><span class="line">opacity: 0.7;</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: scale(1);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scale(0.9);</span><br><span class="line">opacity: 0.7;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes pulse &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scale(0.95);</span><br><span class="line">opacity: 0.7;</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: scale(1);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scale(0.95);</span><br><span class="line">opacity: 0.7;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************60、bigEntrance***********************/</span><br><span class="line"></span><br><span class="line">.bigEntrance &#123;</span><br><span class="line">animation-name: bigEntrance;</span><br><span class="line">-webkit-animation-name: bigEntrance;</span><br><span class="line">animation-duration: 1.6s;</span><br><span class="line">-webkit-animation-duration: 1.6s;</span><br><span class="line">animation-timing-function: ease-out;</span><br><span class="line">-webkit-animation-timing-function: ease-out;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes bigEntrance &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: scale(0.3) rotate(6deg) translateX(-30%) translateY(30%);</span><br><span class="line">opacity: 0.2;</span><br><span class="line">&#125;</span><br><span class="line">30% &#123;</span><br><span class="line">transform: scale(1.03) rotate(-2deg) translateX(2%) translateY(-2%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">45% &#123;</span><br><span class="line">transform: scale(0.98) rotate(1deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: scale(1.01) rotate(-1deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">75% &#123;</span><br><span class="line">transform: scale(0.99) rotate(1deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">90% &#123;</span><br><span class="line">transform: scale(1.01) rotate(0deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scale(1) rotate(0deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes bigEntrance &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scale(0.3) rotate(6deg) translateX(-30%) translateY(30%);</span><br><span class="line">opacity: 0.2;</span><br><span class="line">&#125;</span><br><span class="line">30% &#123;</span><br><span class="line">-webkit-transform: scale(1.03) rotate(-2deg) translateX(2%) translateY(-2%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">45% &#123;</span><br><span class="line">-webkit-transform: scale(0.98) rotate(1deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: scale(1.01) rotate(-1deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">75% &#123;</span><br><span class="line">-webkit-transform: scale(0.99) rotate(1deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">90% &#123;</span><br><span class="line">-webkit-transform: scale(1.01) rotate(0deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scale(1) rotate(0deg) translateX(0%) translateY(0%);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************61、expandOpen***********************/</span><br><span class="line"></span><br><span class="line">.expandOpen &#123;</span><br><span class="line">animation-name: expandOpen;</span><br><span class="line">-webkit-animation-name: expandOpen;</span><br><span class="line">animation-duration: 1.2s;</span><br><span class="line">-webkit-animation-duration: 1.2s;</span><br><span class="line">animation-timing-function: ease-out;</span><br><span class="line">-webkit-animation-timing-function: ease-out;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes expandOpen &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: scale(1.8);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: scale(0.95);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scale(1.05);</span><br><span class="line">&#125;</span><br><span class="line">90% &#123;</span><br><span class="line">transform: scale(0.98);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scale(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes expandOpen &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scale(1.8);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: scale(0.95);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scale(1.05);</span><br><span class="line">&#125;</span><br><span class="line">90% &#123;</span><br><span class="line">-webkit-transform: scale(0.98);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scale(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************62、fadeIn***********************/</span><br><span class="line"></span><br><span class="line">.fadeIn &#123;</span><br><span class="line">animation-name: fadeIn;</span><br><span class="line">-webkit-animation-name: fadeIn;</span><br><span class="line">animation-duration: 1.5s;</span><br><span class="line">-webkit-animation-duration: 1.5s;</span><br><span class="line">animation-timing-function: ease-in-out;</span><br><span class="line">-webkit-animation-timing-function: ease-in-out;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes fadeIn &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: scale(0);</span><br><span class="line">opacity: 0.0;</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: scale(1.1);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scale(0.9);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scale(1);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes fadeIn &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scale(0);</span><br><span class="line">opacity: 0.0;</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: scale(1.1);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scale(0.9);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scale(1);</span><br><span class="line">opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************63、hatch***********************/</span><br><span class="line"></span><br><span class="line">.hatch &#123;</span><br><span class="line">animation-name: hatch;</span><br><span class="line">-webkit-animation-name: hatch;</span><br><span class="line">animation-duration: 2s;</span><br><span class="line">-webkit-animation-duration: 2s;</span><br><span class="line">animation-timing-function: ease-in-out;</span><br><span class="line">-webkit-animation-timing-function: ease-in-out;</span><br><span class="line">transform-origin: 50% 100%;</span><br><span class="line">-ms-transform-origin: 50% 100%;</span><br><span class="line">-webkit-transform-origin: 50% 100%;</span><br><span class="line">visibility: visible !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes hatch &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: rotate(0deg) scaleY(0.6);</span><br><span class="line">&#125;</span><br><span class="line">20% &#123;</span><br><span class="line">transform: rotate(-2deg) scaleY(1.05);</span><br><span class="line">&#125;</span><br><span class="line">35% &#123;</span><br><span class="line">transform: rotate(2deg) scaleY(1);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: rotate(-2deg);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">transform: rotate(1deg);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: rotate(-1deg);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: rotate(0deg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes hatch &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: rotate(0deg) scaleY(0.6);</span><br><span class="line">&#125;</span><br><span class="line">20% &#123;</span><br><span class="line">-webkit-transform: rotate(-2deg) scaleY(1.05);</span><br><span class="line">&#125;</span><br><span class="line">35% &#123;</span><br><span class="line">-webkit-transform: rotate(2deg) scaleY(1);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: rotate(-2deg);</span><br><span class="line">&#125;</span><br><span class="line">65% &#123;</span><br><span class="line">-webkit-transform: rotate(1deg);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: rotate(-1deg);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: rotate(0deg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************64、floating***********************/</span><br><span class="line"></span><br><span class="line">.floating &#123;</span><br><span class="line">animation-name: floating;</span><br><span class="line">-webkit-animation-name: floating;</span><br><span class="line">animation-duration: 1.5s;</span><br><span class="line">-webkit-animation-duration: 1.5s;</span><br><span class="line">animation-iteration-count: infinite;</span><br><span class="line">-webkit-animation-iteration-count: infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes floating &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: translateY(0%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: translateY(8%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: translateY(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes floating &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: translateY(0%);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: translateY(8%);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: translateY(0%);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************65、tossing***********************/</span><br><span class="line"></span><br><span class="line">.tossing &#123;</span><br><span class="line">animation-name: tossing;</span><br><span class="line">-webkit-animation-name: tossing;</span><br><span class="line">animation-duration: 2.5s;</span><br><span class="line">-webkit-animation-duration: 2.5s;</span><br><span class="line">animation-iteration-count: infinite;</span><br><span class="line">-webkit-animation-iteration-count: infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes tossing &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: rotate(-4deg);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">transform: rotate(4deg);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: rotate(-4deg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes tossing &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: rotate(-4deg);</span><br><span class="line">&#125;</span><br><span class="line">50% &#123;</span><br><span class="line">-webkit-transform: rotate(4deg);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: rotate(-4deg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************66、pullUp***********************/</span><br><span class="line"></span><br><span class="line">.pullUp &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-image: none !important;</span><br><span class="line">background-color: #fe5652 !important;</span><br><span class="line">border-radius: 24px;</span><br><span class="line">margin: 0px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.pullUp &#123;</span><br><span class="line">animation-name: pullUp;</span><br><span class="line">-webkit-animation-name: pullUp;</span><br><span class="line">animation-duration: 1.1s;</span><br><span class="line">-webkit-animation-duration: 1.1s;</span><br><span class="line">animation-timing-function: ease-out;</span><br><span class="line">-webkit-animation-timing-function: ease-out;</span><br><span class="line">transform-origin: 50% 100%;</span><br><span class="line">-ms-transform-origin: 50% 100%;</span><br><span class="line">-webkit-transform-origin: 50% 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes pullUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: scaleY(0.1);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">transform: scaleY(1.02);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: scaleY(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scaleY(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scaleY(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scaleY(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scaleY(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes pullUp &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scaleY(0.1);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: scaleY(1.02);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: scaleY(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scaleY(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scaleY(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scaleY(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scaleY(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************67、pullDown***********************/</span><br><span class="line"></span><br><span class="line">.pullDown &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-image: none !important;</span><br><span class="line">background-color: #fe5652 !important;</span><br><span class="line">border-radius: 24px;</span><br><span class="line">margin: 0px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.pullDown &#123;</span><br><span class="line">animation-name: pullDown;</span><br><span class="line">-webkit-animation-name: pullDown;</span><br><span class="line">animation-duration: 1.1s;</span><br><span class="line">-webkit-animation-duration: 1.1s;</span><br><span class="line">animation-timing-function: ease-out;</span><br><span class="line">-webkit-animation-timing-function: ease-out;</span><br><span class="line">transform-origin: 50% 0%;</span><br><span class="line">-ms-transform-origin: 50% 0%;</span><br><span class="line">-webkit-transform-origin: 50% 0%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes pullDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: scaleY(0.1);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">transform: scaleY(1.02);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: scaleY(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scaleY(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scaleY(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scaleY(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scaleY(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes pullDown &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scaleY(0.1);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: scaleY(1.02);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: scaleY(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scaleY(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scaleY(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scaleY(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scaleY(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************68、stretchLeft***********************/</span><br><span class="line"></span><br><span class="line">.stretchLeft &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-image: none !important;</span><br><span class="line">background-color: #fe5652 !important;</span><br><span class="line">border-radius: 24px;</span><br><span class="line">margin: 0px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.stretchLeft &#123;</span><br><span class="line">animation-name: stretchLeft;</span><br><span class="line">-webkit-animation-name: stretchLeft;</span><br><span class="line">animation-duration: 1.5s;</span><br><span class="line">-webkit-animation-duration: 1.5s;</span><br><span class="line">animation-timing-function: ease-out;</span><br><span class="line">-webkit-animation-timing-function: ease-out;</span><br><span class="line">transform-origin: 100% 0%;</span><br><span class="line">-ms-transform-origin: 100% 0%;</span><br><span class="line">-webkit-transform-origin: 100% 0%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes stretchLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: scaleX(0.3);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">transform: scaleX(1.02);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: scaleX(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scaleX(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scaleX(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scaleX(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes stretchLeft &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scaleX(0.3);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: scaleX(1.02);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: scaleX(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scaleX(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scaleX(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scaleX(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*******************69、stretchRight***********************/</span><br><span class="line"></span><br><span class="line">.stretchRight &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-image: none !important;</span><br><span class="line">background-color: #fe5652 !important;</span><br><span class="line">border-radius: 24px;</span><br><span class="line">margin: 0px auto;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.stretchRight &#123;</span><br><span class="line">animation-name: stretchRight;</span><br><span class="line">-webkit-animation-name: stretchRight;</span><br><span class="line">animation-duration: 1.5s;</span><br><span class="line">-webkit-animation-duration: 1.5s;</span><br><span class="line">animation-timing-function: ease-out;</span><br><span class="line">-webkit-animation-timing-function: ease-out;</span><br><span class="line">transform-origin: 0% 0%;</span><br><span class="line">-ms-transform-origin: 0% 0%;</span><br><span class="line">-webkit-transform-origin: 0% 0%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@keyframes stretchRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">transform: scaleX(0.3);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">transform: scaleX(1.02);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">transform: scaleX(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scaleX(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scaleX(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">transform: scaleX(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">transform: scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes stretchRight &#123;</span><br><span class="line">0% &#123;</span><br><span class="line">-webkit-transform: scaleX(0.3);</span><br><span class="line">&#125;</span><br><span class="line">40% &#123;</span><br><span class="line">-webkit-transform: scaleX(1.02);</span><br><span class="line">&#125;</span><br><span class="line">60% &#123;</span><br><span class="line">-webkit-transform: scaleX(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scaleX(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scaleX(0.98);</span><br><span class="line">&#125;</span><br><span class="line">80% &#123;</span><br><span class="line">-webkit-transform: scaleX(1.01);</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">-webkit-transform: scaleX(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**************************完******************************/</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">$(function() &#123;</span><br><span class="line">$(&apos;#css1&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation1&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css2&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation2&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css3&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation3&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css4&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation4&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css5&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation5&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css6&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation6&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css7&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation7&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css8&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation8&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css9&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation9&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css10&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation10&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css11&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation11&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css12&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation12&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css13&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation13&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css14&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation14&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css15&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation15&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css16&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation16&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css17&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation17&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css18&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation18&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css19&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation19&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css20&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation20&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css21&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation21&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css22&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation22&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css23&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation23&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css24&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation24&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css25&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation25&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css26&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation26&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css27&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation27&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css28&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation28&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css29&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation29&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css30&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation30&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css31&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation31&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css32&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation32&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css33&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation33&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css34&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation34&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css35&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation35&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css36&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation36&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css37&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation37&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css38&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation38&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css39&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation39&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css40&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation40&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css41&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation41&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css42&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation42&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css43&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation43&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css44&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation44&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css45&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation45&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css46&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation46&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css47&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation47&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css48&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation48&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css49&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation49&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css50&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation50&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css51&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;animation51&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css52&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;slideDown&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css53&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;slideUp&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css54&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;slideLeft&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css55&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;slideRight&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css56&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;slideExpandUp&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css57&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;expandUp&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css58&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;bounce&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css59&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;pulse&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css60&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;bigEntrance&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css61&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;expandOpen&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css62&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;fadeIn&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css63&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;hatch&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css64&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;floating&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css65&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;tossing&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css66&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;pullUp&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css67&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;pullDown&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css68&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;stretchLeft&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;#css69&apos;).click(function() &#123;</span><br><span class="line">$(&apos;#right&apos;).removeClass();</span><br><span class="line">$(&apos;#right&apos;).addClass(&apos;stretchRight&apos;);</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;</span><br><span class="line">&lt;ul class=&quot;nav&quot;&gt;</span><br><span class="line">&lt;h2&gt;CSS3图片动画展示&lt;/h2&gt;</span><br><span class="line">&lt;a href=&quot;http://www.100sucai.com/css3/1.html&quot; target=&quot;_blank&quot;&gt;100素材网   CSS3动画&lt;/a&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css1&quot; href=&quot;#&quot; href=&quot;#&quot; title=&quot;闪光灯&quot;&gt;1、闪光灯&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css2&quot; href=&quot;#&quot; title=&quot;弹起&quot;&gt;2、弹起&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css3&quot; href=&quot;#&quot; title=&quot;摇摆&quot;&gt;3、摇摆&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css4&quot; href=&quot;#&quot; title=&quot;秋千&quot;&gt;4、秋千&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css5&quot; href=&quot;#&quot; title=&quot;swing&quot;&gt;5、swing&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css6&quot; href=&quot;#&quot; title=&quot;疯狂摆动&quot;&gt;6、疯狂摆动&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css7&quot; href=&quot;#&quot; title=&quot;脉冲&quot;&gt;7、脉冲&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css8&quot; href=&quot;#&quot; title=&quot;翻转&quot;&gt;8、翻转&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css9&quot; href=&quot;#&quot; title=&quot;X轴淡入&quot;&gt;9、X轴淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css10&quot; href=&quot;#&quot; title=&quot;X轴淡出&quot;&gt;10、X轴淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css11&quot; href=&quot;#&quot; title=&quot;Y轴淡入&quot;&gt;11、Y轴淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css12&quot; href=&quot;#&quot; title=&quot;Y轴淡出&quot;&gt;12、Y轴淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css13&quot; href=&quot;#&quot; title=&quot;下方淡入&quot;&gt;13、下方淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css14&quot; href=&quot;#&quot; title=&quot;上方淡入&quot;&gt;14、上方淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css15&quot; href=&quot;#&quot; title=&quot;左边淡入&quot;&gt;15、左边淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css16&quot; href=&quot;#&quot; title=&quot;右边淡入&quot;&gt;16、右边淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css17&quot; href=&quot;#&quot; title=&quot;底部淡入&quot;&gt;17、底部淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css18&quot; href=&quot;#&quot; title=&quot;顶部淡入&quot;&gt;18、顶部淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css19&quot; href=&quot;#&quot; title=&quot;页面左边淡入&quot;&gt;19、页面左边淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css20&quot; href=&quot;#&quot; title=&quot;页面右边淡入&quot;&gt;20、页面右边淡入&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css21&quot; href=&quot;#&quot; title=&quot;向上淡出&quot;&gt;21、向上淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css22&quot; href=&quot;#&quot; title=&quot;向下淡出&quot;&gt;22、向下淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css23&quot; href=&quot;#&quot; title=&quot;向左淡出&quot;&gt;23、向左淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css24&quot; href=&quot;#&quot; title=&quot;向右淡出&quot;&gt;24、向右淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css25&quot; href=&quot;#&quot; title=&quot;顶部淡出&quot;&gt;25、顶部淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css26&quot; href=&quot;#&quot; title=&quot;底部淡出&quot;&gt;26、底部淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css27&quot; href=&quot;#&quot; title=&quot;页面左边淡出&quot;&gt;27、页面左边淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css28&quot; href=&quot;#&quot; title=&quot;页面右边淡出&quot;&gt;28、页面右边淡出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css29&quot; href=&quot;#&quot; title=&quot;bounceIn&quot;&gt;29、bounceIn&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css30&quot; href=&quot;#&quot; title=&quot;bounceInDown&quot;&gt;30、bounceInDown&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css31&quot; href=&quot;#&quot; title=&quot;bounceInUp&quot;&gt;31、bounceInUp&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css32&quot; href=&quot;#&quot; title=&quot;bounceInLeft&quot;&gt;32、bounceInLeft&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css33&quot; href=&quot;#&quot; title=&quot;bounceInRight&quot;&gt;33、bounceInRight&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css34&quot; href=&quot;#&quot; title=&quot;bounceOut&quot;&gt;34、bounceOut&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css35&quot; href=&quot;#&quot; title=&quot;bounceOutDown&quot;&gt;35、bounceOutDown&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css36&quot; href=&quot;#&quot; title=&quot;bounceOutUp&quot;&gt;36、bounceOutUp&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css37&quot; href=&quot;#&quot; title=&quot;bounceOutLeft&quot;&gt;37、bounceOutLeft&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css38&quot; href=&quot;#&quot; title=&quot;bounceOutRight&quot;&gt;38、bounceOutRight&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css39&quot; href=&quot;#&quot; title=&quot;rotateIn&quot;&gt;39、rotateIn&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css40&quot; href=&quot;#&quot; title=&quot;rotateInDownLeft&quot;&gt;40、rotateInDownLeft&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css41&quot; href=&quot;#&quot; title=&quot;rotateInDownRight&quot;&gt;41、rotateInDownRight&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css42&quot; href=&quot;#&quot; title=&quot;rotateInUpLeft&quot;&gt;42、rotateInUpLeft&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css43&quot; href=&quot;#&quot; title=&quot;rotateInUpRight&quot;&gt;43、rotateInUpRight&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css44&quot; href=&quot;#&quot; title=&quot;rotateOut&quot;&gt;44、rotateOut&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css45&quot; href=&quot;#&quot; title=&quot;rotateOutDownLeft&quot;&gt;45、rotateOutDownLeft&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css46&quot; href=&quot;#&quot; title=&quot;rotateOutDownRight&quot;&gt;46、rotateOutDownRight&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css47&quot; href=&quot;#&quot; title=&quot;rotateOutUpLeft&quot;&gt;47、rotateOutUpLeft&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css48&quot; href=&quot;#&quot; title=&quot;rotateOutUpRight&quot;&gt;48、rotateOutUpRight&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css49&quot; href=&quot;#&quot; title=&quot;hinge&quot;&gt;49、hinge&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css50&quot; href=&quot;#&quot; title=&quot;rollIn&quot;&gt;50、rollIn&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css51&quot; href=&quot;#&quot; title=&quot;rollOut&quot;&gt;51、rollOut&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css52&quot; href=&quot;#&quot; title=&quot;slideDown&quot;&gt;52、slideDown&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css53&quot; href=&quot;#&quot; title=&quot;slideUp&quot;&gt;53、slideUp&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css54&quot; href=&quot;#&quot; title=&quot;slideLeft&quot;&gt;54、slideLeft&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css55&quot; href=&quot;#&quot; title=&quot;slideRight&quot;&gt;55、slideRight&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css56&quot; href=&quot;#&quot; title=&quot;slideExpandUp&quot;&gt;56、slideExpandUp&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css57&quot; href=&quot;#&quot; title=&quot;expandUp&quot;&gt;57、expandUp&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css58&quot; href=&quot;#&quot; title=&quot;bounce&quot;&gt;58、bounce&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css59&quot; href=&quot;#&quot; title=&quot;pulse&quot;&gt;59、pulse&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css60&quot; href=&quot;#&quot; title=&quot;bigEntrance&quot;&gt;60、bigEntrance&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css61&quot; href=&quot;#&quot; title=&quot;expandOpen&quot;&gt;61、expandOpen&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css62&quot; href=&quot;#&quot; title=&quot;fadeIn&quot;&gt;62、fadeIn&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css63&quot; href=&quot;#&quot; title=&quot;hatch&quot;&gt;63、hatch&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css64&quot; href=&quot;#&quot; title=&quot;floating&quot;&gt;64、floating&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css65&quot; href=&quot;#&quot; title=&quot;tossing&quot;&gt;65、tossing&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css66&quot; href=&quot;#&quot; title=&quot;pullUp&quot;&gt;66、pullUp&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css67&quot; href=&quot;#&quot; title=&quot;pullDown&quot;&gt;67、pullDown&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css68&quot; href=&quot;#&quot; title=&quot;stretchLeft&quot;&gt;68、stretchLeft&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a id=&quot;css69&quot; href=&quot;#&quot; title=&quot;stretchRight&quot;&gt;69、stretchRight&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="Vue-路由切换动画"><a href="#Vue-路由切换动画" class="headerlink" title="Vue 路由切换动画"></a>Vue 路由切换动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br></pre></td><td class="code"><pre><span class="line">/************ move ***************/</span><br><span class="line">/* move-bottom-to-top */</span><br><span class="line">.move-bottom-to-top-enter-active &#123;</span><br><span class="line">  animation: moveFromBottom 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-bottom-to-top-leave-active &#123;</span><br><span class="line">  animation: moveToTop 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromBottom &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveToTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-top-to-bottom */</span><br><span class="line">.move-top-to-bottom-enter-active &#123;</span><br><span class="line">  animation: moveFromTop 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-top-to-bottom-leave-active &#123;</span><br><span class="line">  animation: moveToBottom 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromTop &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveToBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-left-to-right */</span><br><span class="line">.move-left-to-right-enter-active &#123;</span><br><span class="line">  animation: moveFromLeft 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-left-to-right-leave-active &#123;</span><br><span class="line">  animation: moveToRight 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromLeft &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveToRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-right-to-left */</span><br><span class="line">.move-right-to-left-enter-active &#123;</span><br><span class="line">  animation: moveFromRight 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-right-to-left-leave-active &#123;</span><br><span class="line">  animation: moveToLeft 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromRight &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveToLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-bottom-to-top */</span><br><span class="line">.move-bottom-to-top-enter-active &#123;</span><br><span class="line">  animation: moveFromBottom 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-bottom-to-top-leave-active &#123;</span><br><span class="line">  animation: moveToTop 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromBottom &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveToTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-top-to-bottom */</span><br><span class="line">.move-top-to-bottom-enter-active &#123;</span><br><span class="line">  animation: moveFromTop 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-top-to-bottom-leave-active &#123;</span><br><span class="line">  animation: moveToBottom 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromTop &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveToBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-left-to-right */</span><br><span class="line">.move-left-to-right-enter-active &#123;</span><br><span class="line">  animation: moveFromLeft 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-left-to-right-leave-active &#123;</span><br><span class="line">  animation: moveToRight 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromLeft &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveToRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-right-to-left */</span><br><span class="line">.move-right-to-left-enter-active &#123;</span><br><span class="line">  animation: moveFromRight 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-right-to-left-leave-active &#123;</span><br><span class="line">  animation: moveToLeft 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromRight &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveToLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/************ move-fade ***************/</span><br><span class="line">/* move-fade-bottom-to-top */</span><br><span class="line">.move-fade-bottom-to-top-enter-active &#123;</span><br><span class="line">  animation: moveFadeFromBottom 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-fade-bottom-to-top-leave-active &#123;</span><br><span class="line">  animation: moveFadeToTop 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromBottom &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeToTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-fade-top-to-bottom */</span><br><span class="line">.move-fade-top-to-bottom-enter-active &#123;</span><br><span class="line">  animation: moveFadeFromTop 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-fade-top-to-bottom-leave-active &#123;</span><br><span class="line">  animation: moveFadeToBottom 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromTop &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeToBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-fade-left-to-right */</span><br><span class="line">.move-fade-left-to-right-enter-active &#123;</span><br><span class="line">  animation: moveFadeFromLeft 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-fade-left-to-right-leave-active &#123;</span><br><span class="line">  animation: moveFadeToRight 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromLeft &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeToRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-fade-right-to-left */</span><br><span class="line">.move-fade-right-to-left-enter-active &#123;</span><br><span class="line">  animation: moveFadeFromRight 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-fade-right-to-left-leave-active &#123;</span><br><span class="line">  animation: moveFadeFromLeft 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromRight &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-fade-bottom-to-top */</span><br><span class="line">.move-fade-bottom-to-top-enter-active &#123;</span><br><span class="line">  animation: moveFadeFromBottom 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-fade-bottom-to-top-leave-active &#123;</span><br><span class="line">  animation: moveFadeToTop 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromBottom &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeToTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-fade-top-to-bottom */</span><br><span class="line">.move-fade-top-to-bottom-enter-active &#123;</span><br><span class="line">  animation: moveFadeFromTop 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-fade-top-to-bottom-leave-active &#123;</span><br><span class="line">  animation: moveFadeToBottom 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromTop &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeToBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-fade-left-to-right */</span><br><span class="line">.move-fade-left-to-right-enter-active &#123;</span><br><span class="line">  animation: moveFadeFromLeft 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-fade-left-to-right-leave-active &#123;</span><br><span class="line">  animation: moveFadeToRight 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromLeft &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeToRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-fade-right-to-left */</span><br><span class="line">.move-fade-right-to-left-enter-active &#123;</span><br><span class="line">  animation: moveFadeFromRight 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-fade-right-to-left-leave-active &#123;</span><br><span class="line">  animation: moveFadeToLeft 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeFromRight &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFadeToLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/************ move-different ***************/</span><br><span class="line">/* move-different-bottom-to-top */</span><br><span class="line">.move-different-bottom-to-top-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: moveDifferentFromBottom 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-different-bottom-to-top-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveDifferentToTop 0.7s ease-in-out both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromBottom &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentToTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-different-top-to-bottom */</span><br><span class="line">.move-different-top-to-bottom-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: moveDifferentFromTop 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-different-top-to-bottom-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveDifferentToBottom 0.7s ease-in-out both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromTop &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentToBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-different-left-to-right */</span><br><span class="line">.move-different-left-to-right-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: moveDifferentFromLeft 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-different-left-to-right-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveDifferentToRight 0.7s ease-in-out both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromLeft &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentToRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-different-right-to-left */</span><br><span class="line">.move-different-right-to-left-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: moveDifferentFromRight 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-different-right-to-left-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveDifferentFromLeft 0.7s ease-in-out both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromRight &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-different-bottom-to-top */</span><br><span class="line">.move-different-bottom-to-top-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: moveDifferentFromBottom 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-different-bottom-to-top-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveDifferentToTop 0.7s ease-in-out both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromBottom &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentToTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-different-top-to-bottom */</span><br><span class="line">.move-different-top-to-bottom-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: moveDifferentFromTop 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-different-top-to-bottom-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveDifferentToBottom 0.7s ease-in-out both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromTop &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentToBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-different-left-to-right */</span><br><span class="line">.move-different-left-to-right-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: moveDifferentFromLeft 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-different-left-to-right-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveDifferentToRight 0.7s ease-in-out both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromLeft &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentToRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* move-different-right-to-left */</span><br><span class="line">.move-different-right-to-left-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: moveDifferentFromRight 0.6s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.move-different-right-to-left-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveDifferentToLeft 0.7s ease-in-out both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentFromRight &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveDifferentToLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***************** scale *******************/</span><br><span class="line">/* scale-down-to-down */</span><br><span class="line">.scale-down-to-down-enter-active &#123;</span><br><span class="line">  animation: scaleUpDown 0.5s ease both;</span><br><span class="line">  animation-delay: 0.3s;</span><br><span class="line">&#125;</span><br><span class="line">.scale-down-to-down-leave-active &#123;</span><br><span class="line">  animation: scaleDown 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes scaleUpDown &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: scale(1.2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes scaleDown &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: scale(0.8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* scale-up-to-up */</span><br><span class="line">.scale-up-to-up-enter-active &#123;</span><br><span class="line">  animation: scaleUp 0.7s ease both;</span><br><span class="line">  animation-delay: 0.3s;</span><br><span class="line">&#125;</span><br><span class="line">.scale-up-to-up-leave-active &#123;</span><br><span class="line">  animation: scaleDownUp 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes scaleUp &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: scale(0.8);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes scaleDownUp &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: scale(1.2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* scale-down-to-up */</span><br><span class="line">.scale-down-to-up-enter-active &#123;</span><br><span class="line">  animation: scaleUpCenter 0.4s ease-out both;</span><br><span class="line">  animation-delay: 0.4s;</span><br><span class="line">&#125;</span><br><span class="line">.scale-down-to-up-leave-active &#123;</span><br><span class="line">  animation: scaleDownCenter 0.4s ease-in both;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes scaleUpCenter &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: scale(0.7);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes scaleDownCenter &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: scale(0.7);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/************ rotate-glue **************/</span><br><span class="line">/* rotate-glue-bottom-to-top */</span><br><span class="line">.rotate-glue-bottom-to-top-enter-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveFromBottom 0.6s ease both;</span><br><span class="line">  animation-delay: 0.2s;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-glue-bottom-to-top-leave-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  transform-origin: 50% 0%;</span><br><span class="line">  animation: rotateBottomSideFirst 0.8s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateBottomSideFirst &#123;</span><br><span class="line">  40% &#123;</span><br><span class="line">    transform: rotateX(-15deg);</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    animation-timing-function: ease-out;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(0.8) translateZ(-200px);</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* rotate-glue-top-to-bottom */</span><br><span class="line">.rotate-glue-top-to-bottom-enter-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveFromTop 0.6s ease both;</span><br><span class="line">  animation-delay: 0.2s;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-glue-top-to-bottom-leave-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  transform-origin: 50% 100%;</span><br><span class="line">  animation: rotateTopSideFirst 0.8s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateTopSideFirst &#123;</span><br><span class="line">  40% &#123;</span><br><span class="line">    transform: rotateX(15deg);</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    animation-timing-function: ease-out;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(0.8) translateZ(-200px);</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* rotate-glue-left-to-right */</span><br><span class="line">.rotate-glue-left-to-right-enter-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveFromLeft 0.6s ease both;</span><br><span class="line">  animation-delay: 0.2s;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-glue-left-to-right-leave-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  transform-origin: 100% 50%;</span><br><span class="line">  animation: rotateLeftSideFirst 0.8s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateLeftSideFirst &#123;</span><br><span class="line">  40% &#123;</span><br><span class="line">    transform: rotateY(-15deg);</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    animation-timing-function: ease-out;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(0.8) translateZ(-200px);</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* rotate-glue-right-to-left */</span><br><span class="line">.rotate-glue-right-to-left-enter-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  animation: moveFromRight 0.6s ease both;</span><br><span class="line">  animation-delay: 0.2s;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-glue-right-to-left-leave-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  transform-origin: 0% 50%;</span><br><span class="line">  animation: rotateRightSideFirst 0.8s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateRightSideFirst &#123;</span><br><span class="line">  40% &#123;</span><br><span class="line">    transform: rotateY(15deg);</span><br><span class="line">    opacity: 0.8;</span><br><span class="line">    animation-timing-function: ease-out;</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: scale(0.8) translateZ(-200px);</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/********** rotate-flip ***********/</span><br><span class="line">.rotate-flip-top-enter-active &#123;</span><br><span class="line">  transform-origin: 50% 50%;</span><br><span class="line">  animation: flipInBottom 0.5s both ease-out;</span><br><span class="line">  animation-delay: 0.5s;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-flip-top-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 50%;</span><br><span class="line">  animation: flipOutTop 0.5s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flipInBottom &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateZ(-1000px) rotateX(-90deg);</span><br><span class="line">    opacity: 0.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flipOutTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateZ(-1000px) rotateX(90deg);</span><br><span class="line">    opacity: 0.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-flip-bottom-enter-active &#123;</span><br><span class="line">  transform-origin: 50% 50%;</span><br><span class="line">  animation: flipInTop 0.5s both ease-out;</span><br><span class="line">  animation-delay: 0.5s;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-flip-bottom-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 50%;</span><br><span class="line">  animation: flipOutBottom 0.5s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flipInTop &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateZ(-1000px) rotateX(90deg);</span><br><span class="line">    opacity: 0.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flipOutBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateZ(-1000px) rotateX(-90deg);</span><br><span class="line">    opacity: 0.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-flip-left-enter-active &#123;</span><br><span class="line">  transform-origin: 50% 50%;</span><br><span class="line">  animation: flipInRight 0.5s both ease-out;</span><br><span class="line">  animation-delay: 0.5s;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-flip-left-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 50%;</span><br><span class="line">  animation: flipOutLeft 0.5s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flipInRight &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateZ(-1000px) rotateY(90deg);</span><br><span class="line">    opacity: 0.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flipOutLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateZ(-1000px) rotateY(-90deg);</span><br><span class="line">    opacity: 0.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-flip-right-enter-active &#123;</span><br><span class="line">  transform-origin: 50% 50%;</span><br><span class="line">  animation: flipInLeft 0.5s both ease-out;</span><br><span class="line">  animation-delay: 0.5s;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-flip-right-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 50%;</span><br><span class="line">  animation: flipOutRight 0.5s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flipInLeft &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    transform: translateZ(-1000px) rotateY(-90deg);</span><br><span class="line">    opacity: 0.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes flipOutRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    transform: translateZ(-1000px) rotateY(90deg);</span><br><span class="line">    opacity: 0.2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*************** rotate-fall **************/</span><br><span class="line">.rotate-fall-enter-active &#123;</span><br><span class="line">  z-index: 1;</span><br><span class="line">  animation: scaleUp 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-fall-leave-active &#123;</span><br><span class="line">  z-index: 999;</span><br><span class="line">  transform-origin: 0% 0%;</span><br><span class="line">  animation: rotateFall 1s both ease-in;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateFall &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  20% &#123;</span><br><span class="line">    transform: rotateZ(10deg);</span><br><span class="line">    animation-timing-function: ease-out;</span><br><span class="line">  &#125;</span><br><span class="line">  40% &#123;</span><br><span class="line">    transform: rotateZ(17deg);</span><br><span class="line">  &#125;</span><br><span class="line">  60% &#123;</span><br><span class="line">    transform: rotateZ(16deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: translateY(100%) rotateZ(17deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*************** rotate-sides **************/</span><br><span class="line">.rotate-sides-enter-active &#123;</span><br><span class="line">  animation: rotateSlideIn 1s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-sides-leave-active &#123;</span><br><span class="line">  animation: rotateSlideOut 1s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateSlideIn &#123;</span><br><span class="line">  0%,</span><br><span class="line">  25% &#123;</span><br><span class="line">    opacity: 0.5;</span><br><span class="line">    transform: translateZ(-500px) translateX(200%);</span><br><span class="line">  &#125;</span><br><span class="line">  75% &#123;</span><br><span class="line">    opacity: 0.5;</span><br><span class="line">    transform: translateZ(-500px);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">    transform: translateZ(0) translateX(0);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateSlideOut &#123;</span><br><span class="line">  25% &#123;</span><br><span class="line">    opacity: 0.5;</span><br><span class="line">    transform: translateZ(-500px);</span><br><span class="line">  &#125;</span><br><span class="line">  75% &#123;</span><br><span class="line">    opacity: 0.5;</span><br><span class="line">    transform: translateZ(-500px) translateX(-200%);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    opacity: 0.5;</span><br><span class="line">    transform: translateZ(-500px) translateX(-200%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*****************  rotate-push *********************/</span><br><span class="line">.rotate-push-right-to-left-enter-active &#123;</span><br><span class="line">  transform-origin: 100% 50%;</span><br><span class="line">  animation: rotatePullRight 0.5s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-push-right-to-left-leave-active &#123;</span><br><span class="line">  transform-origin: 0% 50%;</span><br><span class="line">  animation: rotatePushLeft 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotatePullRight &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: rotateY(-90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotatePushLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: rotateY(90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-push-left-to-right-enter-active &#123;</span><br><span class="line">  transform-origin: 0% 50%;</span><br><span class="line">  animation: rotatePullLeft 0.5s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-push-left-to-right-leave-active &#123;</span><br><span class="line">  transform-origin: 100% 50%;</span><br><span class="line">  animation: rotatePushRight 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotatePullLeft &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: rotateY(90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotatePushRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: rotateY(-90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-push-top-to-bottom-enter-active &#123;</span><br><span class="line">  transform-origin: 50% 0%;</span><br><span class="line">  animation: rotatePullTop 0.5s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-push-top-to-bottom-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 100%;</span><br><span class="line">  animation: rotatePushBottom 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotatePullTop &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: rotateX(-90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotatePushBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: rotateX(90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-push-bottom-to-top-enter-active &#123;</span><br><span class="line">  transform-origin: 50% 100%;</span><br><span class="line">  animation: rotatePullBottom 0.5s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-push-bottom-to-top-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 0%;</span><br><span class="line">  animation: rotatePushTop 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotatePullBottom &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: rotateX(90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotatePushTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: rotateX(-90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* rotate-fold */</span><br><span class="line">.rotate-fold-bottom-to-top-enter-active &#123;</span><br><span class="line">  animation: moveFromBottomFade 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-fold-bottom-to-top-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 100%;</span><br><span class="line">  animation: rotateFoldTop 0.7s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromBottomFade &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateFoldTop &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateY(-100%) rotateX(90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-fold-top-to-bottom-enter-active &#123;</span><br><span class="line">  animation: moveFromTopFade 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-fold-top-to-bottom-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 0%;</span><br><span class="line">  animation: rotateFoldBottom 0.7s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromTopFade &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateFoldBottom &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateY(100%) rotateX(-90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-fold-left-to-right-enter-active &#123;</span><br><span class="line">  animation: moveFromLeftFade 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-fold-left-to-right-leave-active &#123;</span><br><span class="line">  transform-origin: 0% 50%;</span><br><span class="line">  animation: rotateFoldRight 0.7s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromLeftFade &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(-100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateFoldRight &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateX(100%) rotateY(90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-fold-right-to-left-enter-active &#123;</span><br><span class="line">  animation: moveFromRightFade 0.7s ease both;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-fold-right-to-left-leave-active &#123;</span><br><span class="line">  transform-origin: 100% 50%;</span><br><span class="line">  animation: rotateFoldLeft 0.7s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes moveFromRightFade &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(100%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateFoldLeft &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">    transform: translateX(-100%) rotateY(-90deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/***************** rotate-carousel ****************/</span><br><span class="line">.rotate-carousel-top-enter-active &#123;</span><br><span class="line">  transform-origin: 50% 0%;</span><br><span class="line">  animation: rotateCarouselTopIn 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-carousel-top-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 100%;</span><br><span class="line">  animation: rotateCarouselTopOut 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateCarouselTopIn &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(200%) scale(0.4) rotateX(-65deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateCarouselTopOut &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(-200%) scale(0.4) rotateX(65deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-carousel-bottom-enter-active &#123;</span><br><span class="line">  transform-origin: 50% 100%;</span><br><span class="line">  animation: rotateCarouselBottomIn 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-carousel-bottom-leave-active &#123;</span><br><span class="line">  transform-origin: 50% 0%;</span><br><span class="line">  animation: rotateCarouselBottomOut 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateCarouselBottomIn &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(-200%) scale(0.4) rotateX(65deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateCarouselBottomOut &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateY(200%) scale(0.4) rotateX(-65deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-carousel-left-enter-active &#123;</span><br><span class="line">  transform-origin: 0% 50%;</span><br><span class="line">  animation: rotateCarouselLeftIn 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-carousel-left-leave-active &#123;</span><br><span class="line">  transform-origin: 100% 50%;</span><br><span class="line">  animation: rotateCarouselLeftOut 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateCarouselLeftIn &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(200%) scale(0.4) rotateY(65deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateCarouselLeftOut &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(-150%) scale(0.4) rotateY(-65deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.rotate-carousel-right-enter-active &#123;</span><br><span class="line">  transform-origin: 0% 50%;</span><br><span class="line">  animation: rotateCarouselRightIn 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">.rotate-carousel-right-leave-active &#123;</span><br><span class="line">  transform-origin: 100% 50%;</span><br><span class="line">  animation: rotateCarouselRightOut 0.8s both ease;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateCarouselRightIn &#123;</span><br><span class="line">  from &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(-150%) scale(0.4) rotateY(65deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes rotateCarouselRightOut &#123;</span><br><span class="line">  to &#123;</span><br><span class="line">    opacity: 0.3;</span><br><span class="line">    transform: translateX(200%) scale(0.4) rotateY(65deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 入口页,如app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    ...</span><br><span class="line">    // 例如使用 move-right-to-left 动画</span><br><span class="line">    &lt;transition name=&quot;move-right-to-left&quot;&gt;</span><br><span class="line">      &lt;router-view class=&quot;app-router-view&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/transition&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  // 引入vue-transition.css</span><br><span class="line">  import &apos;vue-transition.css&apos;</span><br><span class="line">  ...</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  // 给页面加上以下样式，动画才能生效</span><br><span class="line">  html,</span><br><span class="line">  body,</span><br><span class="line">  .app &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 100%;</span><br><span class="line">    height: 100%;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">  &#125;</span><br><span class="line">  .app &#123;</span><br><span class="line">    background-color: #000;</span><br><span class="line">    perspective: 1200px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .app .app-router-view &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    backface-visibility: hidden;</span><br><span class="line">    transform: translate3d(0, 0, 0);</span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">    visibility: visible;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="Github-vue-transition-css"><a href="#Github-vue-transition-css" class="headerlink" title="Github vue-transition.css"></a>Github <a href="https://github.com/WebCodeFarmer/vue-transition.css" target="_blank" rel="noopener">vue-transition.css</a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3) 有可能是 true 吗？</title>
      <link href="/2017/12/10/a-1-a-2-a-3-%E6%9C%89%E5%8F%AF%E8%83%BD%E6%98%AF-true-%E5%90%97%EF%BC%9F/"/>
      <url>/2017/12/10/a-1-a-2-a-3-%E6%9C%89%E5%8F%AF%E8%83%BD%E6%98%AF-true-%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="一个有趣的问题："><a href="#一个有趣的问题：" class="headerlink" title="一个有趣的问题："></a>一个有趣的问题：</h2><p><strong>在 JavaScript 中， <code>(a ==1 &amp;&amp; a== 2 &amp;&amp; a==3)</code> 是否有可能为 <code>true</code> ？</strong></p><p>这是一道我被某科技公司问到的面试题。发生在两周之前，我仍然在努力寻找答案。</p><p>我知道我们从来不会在日常工作中写出这样的代码，但我对问题的答案仍然十分很好奇。</p><h2 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h2><p>利用松散相等运算符 <code>==</code> 的工作原理，你可以简单地创建一个带有自定义<code>toString</code>( 或者 <code>valueOf</code>)函数的对象，在每一次使用它时候改变它所的返回值，使其满足所有三个条件。</p><pre><code>const a = {i: 1,toString: function () {return a.i++;  }}if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {console.log(&apos;Hello World!&apos;);}// Hello World!</code></pre><blockquote><p>之所以会得到如此结果，是由于表达式中使用了松散相等的运算符 <code>==</code>。使用松散相等时，如果其中一个操作数与另一个类型不同，则 JS 引擎将尝试将一个操作转换为另一个类型。在左边对象、右边的数字的情况下，它会尝试将对象转换为一个数，首先通过调用 <code>valueOf</code> 如果是可调用的。否则，它会调用<code>toString</code>方法。我使用<code>toString</code>仅仅是因为它是我的第一反应，<code>valueOf</code> 会更合理。如果我不从<code>toString</code>返回一个字符串（而是返回数字），JS 引擎会尝试将字符串转换为一个数字，虽然有一个稍长的路径，但它仍然会给我们同样的结果。</p></blockquote><h2 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h2><p>我不可否认——其他答案无疑是正确的，但你真的不能过错下面的代码：</p><pre><code>var aﾠ = 1;var a = 2;var ﾠa = 3;if(aﾠ==1 &amp;&amp; a== 2 &amp;&amp;ﾠa==3) {console.log(&quot;Why hello there!&quot;)}</code></pre><p>请注意<code>if</code> 语句中的奇怪间距。它是半宽度韩文=,=。这是一个 Unicode 空格字符，但是 ECMAScript 不将其解释为一个空格 —— 这意味着它是一个有效的标识符。因此有三个完全不同的变量，一个是<code>a</code>后加半宽度韩文，一个是<code>a</code>， 一个是<code>a</code>前加半宽度韩文。。。</p><p>用下划线 <code>_</code> 替代半宽度韩文，增加可读性，相同的代码看起来像这样：</p><pre><code>var a_ = 1;var a = 2;var _a = 3;if(a_==1 &amp;&amp; a== 2 &amp;&amp;_a==3) {console.log(&quot;Why hello there!&quot;)}</code></pre><h2 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h2><p>这是完全可能的！</p><pre><code>var val = 0;Object.defineProperty(window, &apos;a&apos;, {   get: function() {        return ++val;  }});if (a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {    console.log(&apos;yay&apos;);}</code></pre><blockquote><p>使用一个<code>get</code>，让 <code>a</code> 的返回值为三个不同的值。然而这并不意味着我们应该在真正的代码中使用。。。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html2canvas保存图片压缩图片</title>
      <link href="/2017/12/05/html2canvas%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
      <url>/2017/12/05/html2canvas%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">async $html2canvas(el, options = &#123;&#125;) &#123;</span><br><span class="line">const &#123;</span><br><span class="line">type</span><br><span class="line">&#125; = options;</span><br><span class="line">const canvas = await html2canvas(el, &#123;</span><br><span class="line">useCORS: true</span><br><span class="line">&#125;);</span><br><span class="line">try &#123;</span><br><span class="line">if(type &amp;&amp; type === &quot;dataURL&quot;) &#123;</span><br><span class="line">return canvas.toDataURL(&quot;image/png&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">console.warn(&quot;warn&quot;);</span><br><span class="line">return canvas;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch(err) &#123;</span><br><span class="line">console.log(&quot;err&quot;);</span><br><span class="line">console.log(err);</span><br><span class="line">&#125;</span><br><span class="line">return canvas;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">async print() &#123;</span><br><span class="line">const el = document.getElementById(&quot;invite&quot;);</span><br><span class="line">var width = el.offsetWidth * 0.8;</span><br><span class="line">var height = el.offsetHeight * 0.8;</span><br><span class="line">const options = &#123;</span><br><span class="line">type: &quot;dataURL&quot;,</span><br><span class="line">useCORS: true,</span><br><span class="line">logging: true,</span><br><span class="line">taintTest: false,</span><br><span class="line">allowTaint: false,</span><br><span class="line">width: el.offsetWidth * 0.8,</span><br><span class="line">height: el.offsetHeight * 0.8</span><br><span class="line">&#125;;</span><br><span class="line">var output = await this.$html2canvas(el, options);</span><br><span class="line">this.ImgToBase64(output, width, height);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ImgToBase64(base64, width, height) &#123;   //压缩图片</span><br><span class="line">var that = this;</span><br><span class="line">var img = new Image();</span><br><span class="line">img.src = base64;</span><br><span class="line">img.onload = function() &#123;</span><br><span class="line">var rate = 0.8;   //压缩图片</span><br><span class="line">img.width = width * rate;</span><br><span class="line">img.height = height * rate;</span><br><span class="line">//生成canvas</span><br><span class="line">var canvas = document.createElement(&quot;canvas&quot;);</span><br><span class="line">var ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">canvas.width = img.width;</span><br><span class="line">canvas.height = img.height;</span><br><span class="line">ctx.drawImage(img, 0, 0, img.width, img.height);</span><br><span class="line">var base64 = canvas.toDataURL(&apos;image/jpeg&apos;, 0.95);</span><br><span class="line">that.output = base64;</span><br><span class="line">that.$nextTick(() =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">that.$emit(&quot;savaImg&quot;, that.output);</span><br><span class="line">&#125;, 0)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;that.output&apos;)</span><br><span class="line">console.log(that.output)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> html2canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue的MVVM模式实现</title>
      <link href="/2017/11/19/Vue%E7%9A%84MVVM%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/11/19/Vue%E7%9A%84MVVM%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/11/19/Vue的MVVM模式实现/timg.png" alt="timg"></p><h3 id="1、MVVM模式"><a href="#1、MVVM模式" class="headerlink" title="1、MVVM模式"></a>1、MVVM模式</h3><p>MVVM的设计思想：关注Model（数据）的变化，让MVVM框架去自动更新DOM的状态，比较主流的实现有：angular的（脏值检测）vue的（数据劫持-&gt;发布订阅模式）我们重点了解vue（数据劫持-&gt;发布订阅模式）的实现方式，让我们从操作DOM的繁琐操作中解脱出来</p><h3 id="2、核心方法Object-defineProperty的理解"><a href="#2、核心方法Object-defineProperty的理解" class="headerlink" title="2、核心方法Object.defineProperty的理解"></a>2、核心方法Object.defineProperty的理解</h3><p>我们先简单看一下这个方法它也是用来实现我们数据劫持（数据监听）的关键方法，我们知道vue框架是不兼容IE6~8低版本的，主要是因为它的用到了ES5中的这个Object.defineProperty的方法，而且这个方法暂时没有很好的降级方案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, &apos;b&apos;, &#123;</span><br><span class="line">    value: 123,         // 设置的属性值</span><br><span class="line">    writable: false,    // 是否只读</span><br><span class="line">    enumerable: false,  // 是否可枚举</span><br><span class="line">    configurable: false// </span><br><span class="line">&#125;);</span><br><span class="line">console.log(a.b); //123</span><br></pre></td></tr></table></figure></p><p>方法使用很简单，它接受三个参数，而且都是必填的</p><ul><li>第一个参数：目标对象</li><li>第二个参数：需要定义的属性或方法的名字。</li><li>第三个参数：目标属性所拥有的特性</li></ul><p>前两个参数比较好理解，主要看第三个参数它是一个对象，看看有哪些属性定义</p><ul><li>value：属性的值。</li><li>writable：如果为 false ，属性的值就不能被重写,只能为只读了。</li><li>enumerable：是否可枚举，默认是false不可枚举的（通常设置为true）</li><li>configurable：总开关，一旦为false，就不能再设置其他的（ value ， writable ， enumerable）</li><li>get()：函数，获取属性值时执行的方法（不可以和writable、value属性共存）</li><li>set()：函数，设置属性值时执行的方法（不可以和writable、value属性共存）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 常用定义</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &apos;school&apos;, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    get: function()&#123;        </span><br><span class="line">        // 获取属性值时会调用get方法</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newVal)&#123;        </span><br><span class="line">        // 设置属性值时会调用set方法</span><br><span class="line">        return newVal</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通过这个Object.defineProperty这个方法，可以实现对定义的引用数据类型的实现监听，被方法监听后的对象，里面定义的值发生被获取和设置操作的时候，会分别触发Object.defineProperty里面参数三的get和set方法。</p><h3 id="3、数据劫持"><a href="#3、数据劫持" class="headerlink" title="3、数据劫持"></a>3、数据劫持</h3><p>在了解完了Object.defineProperty方法后，我们现在要通过它来实现我们的数据劫持功能Obaerve的方法，看如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function MyVue(options = &#123;&#125;)&#123;    </span><br><span class="line">    // 将所有的属性挂载到$options身上</span><br><span class="line">    this.$options = options;    </span><br><span class="line">    // 获取到data数据（Model）</span><br><span class="line">    var data = this._data = this.$options.data;    </span><br><span class="line">    // 劫持数据</span><br><span class="line">    observe(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给需要观察的对象都添加 Object.defineProperty 的监听</span><br><span class="line">function Observe(data)&#123;    </span><br><span class="line">    for (let key in data) &#123;        </span><br><span class="line">        let val = data[key];        </span><br><span class="line">        // 递归 =》来实现深层的数据监听</span><br><span class="line">        observe(val)        </span><br><span class="line">        Object.defineProperty(data, key, &#123;</span><br><span class="line">            enumerable: true,</span><br><span class="line">            get() &#123;                </span><br><span class="line">                return val</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newval) &#123; </span><br><span class="line">                if (val === newval) &#123; //设置的值是否和以前是一样的，如果是就什么都不做</span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">                val = newval // 这里要把新设置的值也在添加一次数据劫持来实现深度响应,</span><br><span class="line">                observe(newval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function observe(data)&#123;</span><br><span class="line">    // 这里做一下数据类型的判断，只有引用数据类型才去做数据劫持</span><br><span class="line">    if (typeof data != &apos;object&apos;) return</span><br><span class="line">    returnnew Observe(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）以上代码做了这些事情，先定义了初始换构造函数MyVue我们通过它来获取到我们传进来的数据data和我们定义的DOM节点范围，然后把data传进定好的数据劫持方法observe<br>2）Observe实现了对数据的监听整体逻辑，这里有个细节点，没有直接用构造函数Observe去劫持我们的数据，而是写多了一个observe的小方法用来new Observe，并且在里面做了引用数据类型的判断。这样做的目的是为了方便递归来实现数据结构的深层监听，因为我们的data结构肯定是复杂多样的，例如下面代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里数据结构嵌套很多，要实现深层的数据监听采用了递归的实现方式</span><br><span class="line">data: &#123; a: &#123;b:2&#125; , c:&#123;q:12,k:&#123;name:&apos;binhemori&apos;&#125;&#125; , f:&apos;mvvvm&apos;,o:[12,5,9,8]&#125;</span><br></pre></td></tr></table></figure></p><p>3）这里还需要注意的是我们在set方法里面有再一次把设置的新值，执行了一遍observe方法，是为了实现深度响应，因为在赋值的时候可能会赋值一个引用数据类型的值，我们知道vue有个特点，是不能新增不存在的属性和不能存在属性没有get和set方法的，如果赋值进来的新属性值是引用数据类型，就会把我们原先执行过数据劫持方法的对象地址给替换掉，而新对象是没有经过数据劫持的就是没有get和set的方法，所以我们在设置新值的时候需要在重新给他执行一遍observe数据劫持，确保开发者不管怎样去设置值的时候都能被劫持到</p><hr><p>说了这么多，我们来使用一下看看有没有实现对数据的劫持（数据监听）吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;     </span><br><span class="line">    &lt;div&gt;</span><br><span class="line">         &lt;div&gt;这里的数据1======&lt;span style=&quot;color: red;&quot;&gt;&#123;&#123;a.b&#125;&#125;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">         &lt;div&gt;这里是数据2======&lt;span style=&quot;color: green;&quot;&gt;&#123;&#123;c&#125;&#125;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">     &lt;/div&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; v-model=&quot;a.b&quot; value=&quot;&quot;&gt;</span><br><span class="line"> &lt;/div&gt;</span><br><span class="line"> &lt;!-- 引入自己定义的mvvm模块 --&gt;</span><br><span class="line"> &lt;script src=&quot;./mvvm.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">     var myvue = new MyVue(&#123;</span><br><span class="line">         el: &apos;#app&apos;,</span><br><span class="line">         data: &#123; a: &#123; b: &apos;你好&apos; &#125;, c: 12, o: [12, 5, 9, 8] &#125;</span><br><span class="line">     &#125;) </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/11/19/Vue的MVVM模式实现/3.png" alt="3"></p><p>可以看到对我们所定义的data中的数据都已经有了get和set方法了，到这里我们对data中数据的变化都是可以监听的到了</p><h3 id="4、数据代理"><a href="#4、数据代理" class="headerlink" title="4、数据代理"></a>4、数据代理</h3><p>数据代理，我们用过vue的都知道，在实际使用中是能直接通过实例+属性（vm.a）直接获取到数据的，而我们上面的代码要获取到数据还需要这样myvue._data.a这样来获取到数据，中间多了一个 _data 的环节，这样使用起来不是很方便的，下面我们来实现让我们的实例this来代理（ _data）数据，从而实现 myvue.a 这样的操作可以直接获取到数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function MyVue(options = &#123;&#125;) &#123;    </span><br><span class="line">    // 将所有的属性挂载到$options身上</span><br><span class="line">    this.$options = options;    </span><br><span class="line">    // 获取到data数据（Model）</span><br><span class="line">    var data = this._data = this.$options.data;</span><br><span class="line">    observe(data);    </span><br><span class="line">    </span><br><span class="line">    // this 就代理数据 this._data</span><br><span class="line">    for (const key in data) &#123;        </span><br><span class="line">    Object.defineProperty(this, key, &#123;</span><br><span class="line">            enumerable: true,</span><br><span class="line">            get() &#123;                </span><br><span class="line">                // this.a 这里取值的时候 实际上是去_data中的值</span><br><span class="line">                return this._data[key] </span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVal) &#123; </span><br><span class="line">                // 设置值的时候其实也是去改this._data.a的值</span><br><span class="line">                this._data[key] = newVal</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码实现了我们的数据代理，就是在构建实例的时候，把data中的数据遍历一次出来，依次加到我们this上，加的过程中也不要忘记添加Object.defineProperty，只要是数据我们都需要添加监听。如下图我们已经实现了对数据的代理</p><p><img src="/2017/11/19/Vue的MVVM模式实现/2.png" alt="2"></p><h3 id="5、编译模板（Compile）"><a href="#5、编译模板（Compile）" class="headerlink" title="5、编译模板（Compile）"></a>5、编译模板（Compile）</h3><p>我们已经完成对数据劫持也实现了this对数据的代理，那么接下来要做的就是怎样把数据编译到我们的DOM节点上面，也就是让视图层（view）要展示我们的数据了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// 将数据和节点挂载在一起</span><br><span class="line">function Compile(el, vm) &#123;    </span><br><span class="line">    // el表示替换的范围</span><br><span class="line">    vm.$el = document.querySelector(el);    </span><br><span class="line">    // 这里注意我们没有去直接操作DOM，而是把这个步骤移到内存中来操作，这里的操作是不会引发DOM节点的回流</span><br><span class="line">    let fragment = document.createDocumentFragment(); // 文档碎片</span><br><span class="line">    let child;   </span><br><span class="line">    </span><br><span class="line">    while (child = vm.$el.firstChild) &#123; </span><br><span class="line">        // 将app的内容移入内存中</span><br><span class="line">        fragment.appendChild(child);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    replace(fragment)    </span><br><span class="line">    function replace(fragment) &#123;        </span><br><span class="line">        Array.from(fragment.childNodes).forEach(function (node) &#123; //循环每一层</span><br><span class="line">            let text = node.textContent;            </span><br><span class="line">            let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/g;</span><br><span class="line">                        </span><br><span class="line">            // 这里做了判断只有文本节点才去匹配，而且还要带&#123;&#123;***&#125;&#125;的字符串</span><br><span class="line">            if (node.nodeType === 3 &amp;&amp; reg.test(text)) &#123;  </span><br><span class="line">                // 把匹配到的内容拆分成数组              </span><br><span class="line">                let arr = RegExp.$1.split(&apos;.&apos;); </span><br><span class="line">                let val = vm;                </span><br><span class="line">                </span><br><span class="line">                // 这里对我们匹配到的定义数组，会依次去遍历它，来实现对实例的深度赋值</span><br><span class="line">                arr.forEach(function (k) &#123; // this.a.b  this.c</span><br><span class="line">                    val = val[k]</span><br><span class="line">                &#125;)      </span><br><span class="line">                          </span><br><span class="line">                // 用字符串的replace方法替换掉我们获取到的数据val</span><br><span class="line">                node.textContent = text.replace(/\&#123;\&#123;(.*)\&#125;\&#125;/, val)</span><br><span class="line">            &#125;         </span><br><span class="line">                   </span><br><span class="line">            // 这里做了判断，如果有子节点的话 使用递归</span><br><span class="line">            if (node.childNodes) &#123;</span><br><span class="line">                replace(node)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;    </span><br><span class="line">    // 最后把编译完的DOM加入到app元素中</span><br><span class="line">    vm.$el.appendChild(fragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上代码实现我们对数据的编译Compile如下图，可以看到我们把获取到el下面所有的子节点都存储到了文档碎片 fragment 中暂时存储了起来（放到内存中），因为这里要去频繁的操作DOM和查找DOM，所以移到内存中操作</p><p><img src="/2017/11/19/Vue的MVVM模式实现/4.png" alt="4"></p><ul><li>1）先用while循环，先把 el 中所有的子节点都添加到文档碎片中fragment.appendChild(child);</li><li>2）然后我们通过replace方法去遍历文档中所有的子节点，将他们文本节点中（node.nodeType = 3）带有双大括号语法中的内容都获取到，把匹配到的值拆分成数组，然后遍历依次去data中查找获取，遍历的节点如果有子节点的话继续使用replace方法直到反回undefined</li><li>3）获取到数据后，用replace方法替换掉文本中双大括号的整块内容，然后在放回el元素中vm.$el.appendChild(fragment)，</li></ul><h3 id="6、关联视图（view）与数据（model）"><a href="#6、关联视图（view）与数据（model）" class="headerlink" title="6、关联视图（view）与数据（model）"></a>6、关联视图（view）与数据（model）</h3><p>在成功的将我们的数据绑定到了DOM节点之后，要实现我们的视图层（view）跟数据层（model）的关联，现在实际上还没有关联起来，因为无法通过改数据值来引发视图的变化，实现这步之前先聊一下JS中比较常用的设计模式发布订阅模式也是vue实现双向数据绑定的很关键的一步</p><h5 id="发布订阅模式（又称观察者模式）"><a href="#发布订阅模式（又称观察者模式）" class="headerlink" title="发布订阅模式（又称观察者模式）"></a>发布订阅模式（又称观察者模式）</h5><p>我们先简单手动实现一个（就是一个数组关系）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 发布订阅</span><br><span class="line">function Dep() &#123;    </span><br><span class="line">    this.subs = []</span><br><span class="line">&#125;</span><br><span class="line">// 订阅</span><br><span class="line">Dep.prototype.addSub = function (sub) &#123;    </span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">&#125;</span><br><span class="line">// 通知</span><br><span class="line">Dep.prototype.notify = function (sub) &#123;    </span><br><span class="line">    this.subs.forEach(item =&gt; item.update())</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">// watcher是一个类，通过这个类创建的函数都会有update的方法</span><br><span class="line">function Watcher(fn) &#123;    </span><br><span class="line">    this.fn = fn;</span><br><span class="line">&#125;</span><br><span class="line">Watcher.prototype.update = function () &#123;    </span><br><span class="line">    this.fn() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里用Dep方法来实现订阅和通知，在这个类中有addSub（添加）和notify（通知）两个方法，我们把将要做的事情（函数）通过addSub添加进数组里，等时机一到就notify通知里面所有的方法执行</p><p>大家会发现为什么要另外定义一个创建函数的方法watcher，而不是直接把方法扔到addSub中好，这样不是多此一举嘛？其实这样做的有它的目的，其中一个好处就是我们通过watcher创建的函数都会有一个update执行的方法可以方便我们调用。而另外一个用处我下面会讲到，先把它运用起来吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function replace(fragment) &#123;     </span><br><span class="line">    Array.from(fragment.childNodes).forEach(function (node) &#123; </span><br><span class="line">         let text = node.textContent;         </span><br><span class="line">         let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/g;   </span><br><span class="line">               </span><br><span class="line">         if (node.nodeType === 3 &amp;&amp; reg.test(text)) &#123;             </span><br><span class="line">             let arr = RegExp.$1.split(&apos;.&apos;);             </span><br><span class="line">             let val = vm; </span><br><span class="line">             arr.forEach(function (k) &#123; </span><br><span class="line">                 val = val[k]</span><br><span class="line">             &#125;)             </span><br><span class="line">             // 在这里运用了Watcher函数来新增要操作的事情</span><br><span class="line">             new Watcher(vm, RegExp.$1, function (newVal) &#123;</span><br><span class="line">                 node.textContent = text.replace(/\&#123;\&#123;(.*)\&#125;\&#125;/, newVal)</span><br><span class="line">             &#125;)</span><br><span class="line"></span><br><span class="line">             node.textContent = text.replace(/\&#123;\&#123;(.*)\&#125;\&#125;/, val)</span><br><span class="line">         &#125;         </span><br><span class="line">             </span><br><span class="line">         if (node.childNodes) &#123;</span><br><span class="line">             replace(node)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到我们把定义函数的方法watcher加到了replace方法里面，但是这里的watcher更刚写编写的多了两个形参vm、RegExp.$1，而且写法也新增了一些内容，因为当new Watcher的时候会引发发生几个操作，来看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> // vm做数据代理的地方</span><br><span class="line">function MyVue(options = &#123;&#125;) &#123;    </span><br><span class="line">    this.$options = options;    </span><br><span class="line">    var data = this._data = this.$options.data;</span><br><span class="line">    observe(data);    </span><br><span class="line">    for (const key in data) &#123;        </span><br><span class="line">        Object.defineProperty(this, key, &#123;</span><br><span class="line">            enumerable: true,</span><br><span class="line">            get() &#123;                </span><br><span class="line">                return this._data[key] </span><br><span class="line">            &#125;,</span><br><span class="line">            set(newVal) &#123; </span><br><span class="line">                this._data[key] = newVal</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 数据劫持函数</span><br><span class="line">function Observe(data) &#123;       </span><br><span class="line">    let dep = new Dep();    </span><br><span class="line">    for (let key in data) &#123;        </span><br><span class="line">        let val = data[key];</span><br><span class="line">        observe(val)        </span><br><span class="line">        Object.defineProperty(data, key, &#123;</span><br><span class="line">            enumerable: true,</span><br><span class="line">            get() &#123;                </span><br><span class="line">                /* 获取值的时候 Dep.target </span><br><span class="line">                   对于着 watcher的实例，把他创建的实例加到订阅队列中</span><br><span class="line">                */</span><br><span class="line">                Dep.target &amp;&amp; dep.addSub(Dep.target); </span><br><span class="line">                return val</span><br><span class="line">            &#125;,</span><br><span class="line">            set(newval) &#123; </span><br><span class="line">                if (val === newval) &#123;                    </span><br><span class="line">                    return</span><br><span class="line">                &#125;</span><br><span class="line">                val = newval;</span><br><span class="line">                observe(newval);                </span><br><span class="line">                // 设置值的时候让所有的watcher.update方法执行即可触发所有数据更新</span><br><span class="line">                dep.notify() </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Watcher(vm, exp, fn) &#123;    </span><br><span class="line">    this.fn = fn;    </span><br><span class="line">    // 这里我们新增了一些内容，用来可以获取对于的数据</span><br><span class="line">    this.vm = vm;    </span><br><span class="line">    this.exp = exp; </span><br><span class="line">    Dep.target = this</span><br><span class="line">    let val = vm;    </span><br><span class="line">    let arr = exp.split(&apos;.&apos;);    </span><br><span class="line">    /* 执行这一步的时候操作的是vm.a，</span><br><span class="line">    而这一步操作其实就是操作的vm._data.a的操作，</span><br><span class="line">    会触发this代理的数据和_data上面的数据</span><br><span class="line">    */</span><br><span class="line">    arr.forEach(function (k) &#123;</span><br><span class="line">        val = val[k]</span><br><span class="line">    &#125;)</span><br><span class="line">    Dep.target = null;</span><br><span class="line">&#125;</span><br><span class="line">// 这里是设置值操作</span><br><span class="line">Watcher.prototype.update = function () &#123;    </span><br><span class="line">    let val = this.vm;    </span><br><span class="line">    let arr = this.exp.split(&apos;.&apos;);</span><br><span class="line">    arr.forEach(function (k) &#123;</span><br><span class="line">        val = val[k]</span><br><span class="line">    &#125;)    </span><br><span class="line">    this.fn(val) //这里面要传一个新值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里开始会有点绕，一定要理解好操作数据的时候会触发的那个实例上面数据的get和set，操作的是那个数据这个思维</p><p>1）首先看在Watcher构造函数中新增了一些私有属性分别代表：</p><ul><li>Dep.target = this（在构造函数Dep.target临时存储着watcher的当前实例）</li><li>this.vm = vm（vm = myvue实例）</li><li>this.exp = exp（exp = 匹配的查找的对象”a.b”是字符串类型的值）</li></ul><p>我们存储这些属性后，接下来就要去获取用exp匹配的字符串里面对于数据也就是 vm.a.b，但是此时的exp是个字符串，你不能直接这样取值vm[a.b]这是错误的语法，所以要循环去取到对于的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function (k) &#123;        </span><br><span class="line">        // arr = [a,b] </span><br><span class="line">        val = val[k]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>第一次循环的时候是vm[a] = {b:12}，取到了a这个对象，然后在赋值回去就是把当前的val变成了a这个对象</li><li>第二次循环的时候val已经变成了 a对象，此时的k变成了b，val就变成了：a[b] = 12</li></ul><p>经过两次遍历后我们获取到值是vm代理数据上面的a对象，也就是会触发代理数据上面对于数据的get的方法（vm.a.b）而这个操作返回的是 this._data[k] 它又会触发 vm._data.a.b 数据上的get方法，也就是走到了Observe 函数里面的get，此时的Dep.target存储的是当前watcher方法的实例（这个实例里面已经有要操作数据的信息），并且把取到最新的值传到了方法中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">get() &#123;    </span><br><span class="line">    // 走到这里的时候 Dep.target 已经存储了 watcher的当前实例实例，把他创建的实例加到订阅队列中</span><br><span class="line">    Dep.target &amp;&amp; dep.addSub(Dep.target); </span><br><span class="line">    return val</span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line">// 把要做的更新视图层的操作方法用Watcher定义好，里面已经定义好了要操作的对象</span><br><span class="line">new Watcher(vm, RegExp.$1, function (newVal) &#123;</span><br><span class="line">    node.textContent = text.replace(/\&#123;\&#123;(.*)\&#125;\&#125;/, newVal)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Watcher.prototype.update = function () &#123;    </span><br><span class="line">    let val = this.vm;    </span><br><span class="line">    let arr = this.exp.split(&apos;.&apos;);</span><br><span class="line">    arr.forEach(function (k) &#123;</span><br><span class="line">        val = val[k]</span><br><span class="line">    &#125;)    this.fn(val) // 把对于的新值传递到方法里面</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里因为加多了一层 vm.a 这样的数据代理，所以逻辑有点绕，记住这句话就好理解操作 vm.a 代理数据上面值的时候，其实就是操作的vm._data中的数据所以会触发两个地方的get和set方法，好说这么多，我们来看是否实现数据变动触发视图层的变化吧</p><p><img src="/2017/11/19/Vue的MVVM模式实现/text2.gif" alt=""></p><p>这里就实现了数据的变更触发视图层的更新操作了</p><h3 id="7、input双向数据绑定的实现"><a href="#7、input双向数据绑定的实现" class="headerlink" title="7、input双向数据绑定的实现"></a>7、input双向数据绑定的实现</h3><p>最后一步就来实现视图层的变更触发数据结构的变更操作，上面我们已经把视图与数据关联最核心的代码讲解了，剩下视图变更触发数据变更就比较好实现了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &lt;div id=&quot;app&quot;&gt;    </span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;div&gt;这里的数据1======&lt;span style=&quot;color: red;&quot;&gt;&#123;&#123;a.b&#125;&#125;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;这里是数据2======&lt;span style=&quot;color: green;&quot;&gt;&#123;&#123;c&#125;&#125;&lt;/span&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;a.b&quot; value=&quot;&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 引入自己定义的mvvm模块 --&gt;</span><br><span class="line">&lt;script src=&quot;./mvvm.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var myvue = new MyVue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123; a: &#123; b: &apos;你好&apos; &#125;, c: 12, o: [12, 5, 9, 8] &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">// 获取所有元素节点</span><br><span class="line">if (node.nodeType === 1) &#123;    </span><br><span class="line">    let nodeAttr = node.attributes    </span><br><span class="line">    Array.from(nodeAttr).forEach(function (attr) &#123;        </span><br><span class="line">        let name = attr.name; // v-model=&quot;a.b&quot;</span><br><span class="line">        let exp = attr.value; // a.b</span><br><span class="line"></span><br><span class="line">        if (name.indexOf(&apos;v-&apos;) &gt;= 0) &#123;            </span><br><span class="line">            let val = vm;            </span><br><span class="line">            let arr = exp.split(&apos;.&apos;);</span><br><span class="line">            arr.forEach(function (n) &#123;</span><br><span class="line">                val = val[n]</span><br><span class="line">            &#125;)            </span><br><span class="line">            // 这个还好处理，取到对应的值设置给input.value就好</span><br><span class="line">            node.value = val;</span><br><span class="line">        &#125;        </span><br><span class="line">        // 这里也要定义一个Watcher，因为数据变更的时候也要变更带有v-model属性名的值</span><br><span class="line">        new Watcher(vm, exp, function (newVal) &#123;</span><br><span class="line">            node.value = newVal</span><br><span class="line">        &#125;)        </span><br><span class="line">        // 这里是视图变化的时候，变更数据结构上面的值</span><br><span class="line">        node.addEventListener(&apos;input&apos;, function (e) &#123;            </span><br><span class="line">            let newVal = e.target.value            </span><br><span class="line">            if (name.indexOf(&apos;v-&apos;) &gt;= 0) &#123;                </span><br><span class="line">                let val = vm;                </span><br><span class="line">                let arr = exp.split(&apos;.&apos;);</span><br><span class="line">                arr.forEach(function (k,index) &#123;     </span><br><span class="line">                    if (typeof val[k] === &apos;object&apos;) &#123;</span><br><span class="line">                        val = val[k]</span><br><span class="line">                    &#125; else&#123;                        </span><br><span class="line">                    if (index === arr.length-1) &#123;</span><br><span class="line">                            val[k] = newVal</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码对数据变更触发视图层变更的逻辑更上一节一样即可，主要是node.addEventListener(‘input’)这里设置数据的问题，其实原理跟第六节关联视图（view）与数据（model）的逻辑一样，有一定需要注意的是这边加了一个引用数据类型的判断，不然他的循环会到最底层的数据类型值（也就是基础数据类型）</p><p>1）这里判断到取到的不是对象数据类型，不做替换操作 （val = val[k]）<br>2）判断是不是已经最后一个层级了index === arr.length-1，如果是的话直接把input中的值赋值进当前数据中即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(function (k,index) &#123;     </span><br><span class="line">    if (typeof val[k] === &apos;object&apos;) &#123;        </span><br><span class="line">        // 如果有嵌套的话就继续查找</span><br><span class="line">        val = val[k]</span><br><span class="line">    &#125; else&#123;        </span><br><span class="line">        if (index === arr.length-1) &#123;            </span><br><span class="line">        // 查找到最后一个后直接赋值</span><br><span class="line">            val[k] = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>以上是整个mvvm双向数据绑定的简单实现原理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Virtual Dom介绍</title>
      <link href="/2017/11/18/Virtual-Dom%E4%BB%8B%E7%BB%8D/"/>
      <url>/2017/11/18/Virtual-Dom%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000016129036" target="_blank" rel="noopener">你不知道的Virtual DOM（一）：Virtual Dom介绍</a><br><a href="https://segmentfault.com/a/1190000016145981" target="_blank" rel="noopener">你不知道的Virtual DOM（二）：Virtual Dom的更新</a><br><a href="https://segmentfault.com/a/1190000016186666" target="_blank" rel="noopener">你不知道的Virtual DOM（三）：Virtual Dom更新优化</a><br><a href="https://segmentfault.com/a/1190000016200003" target="_blank" rel="noopener">你不知道的Virtual DOM（四）：key的作用</a><br><a href="https://segmentfault.com/a/1190000016248276" target="_blank" rel="noopener">你不知道的Virtual DOM（五）：自定义组件</a><br><a href="https://segmentfault.com/a/1190000016328371" target="_blank" rel="noopener">你不知道的Virtual DOM（六）：事件处理&amp;异步更新</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> Virtual Dom </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实现一个回到顶部</title>
      <link href="/2017/11/16/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8/"/>
      <url>/2017/11/16/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9B%9E%E5%88%B0%E9%A1%B6%E9%83%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实际应用中，经常用到滚动到页面顶部或某个位置，一般简单用锚点处理或用js将<code>document.body.scrollTop</code>设置为0，结果是页面一闪而过滚到指定位置，不是特别友好。我们想要的效果是要有点缓冲效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;html,body&apos;).animate(&#123;</span><br><span class="line">   scrollTop: 0</span><br><span class="line">&#125;, 700);</span><br></pre></td></tr></table></figure></p><p>现代浏览器陆续意识到了这种需求，<code>scrollIntoView</code>意思是滚动到可视，css中提供了<code>scroll-behavior</code>属性，js有<code>Element.scrollIntoView()</code>方法。</p><blockquote><p>纯css实现tab切换</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;纯css实现tab切换&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">* &#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tab &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 150px;</span><br><span class="line">margin-left: 30px;</span><br><span class="line">margin-top: 30px;</span><br><span class="line">border: 1px solid #eee;</span><br><span class="line">position: relative;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input[type=&apos;radio&apos;] &#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tab label &#123;</span><br><span class="line">display: block;</span><br><span class="line">cursor: pointer;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 60px;</span><br><span class="line">height: 30px;</span><br><span class="line">line-height: 30px;</span><br><span class="line">text-align: center;</span><br><span class="line">border: 1px solid #eee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.label-1 &#123;</span><br><span class="line">left: 0;</span><br><span class="line">top: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.label-2 &#123;</span><br><span class="line">left: 60px;</span><br><span class="line">top: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input[type=&apos;radio&apos;]:checked~div[class^=&apos;mod&apos;] &#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input[type=&apos;radio&apos;]:checked~label &#123;</span><br><span class="line">background: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[class^=&apos;mod&apos;] &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 40px;</span><br><span class="line">left: 20px;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;tab&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; id=&quot;r-1&quot; name=&quot;tab&quot; checked&gt;</span><br><span class="line">&lt;label for=&quot;r-1&quot; class=&quot;label-1&quot;&gt;第一张&lt;/label&gt;</span><br><span class="line">&lt;div class=&quot;mod-1&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;275万购昌平邻铁三居&lt;/li&gt;</span><br><span class="line">&lt;li&gt;总价20万买一居&lt;/li&gt;</span><br><span class="line">&lt;li&gt;200万内购五环三居&lt;/li&gt;</span><br><span class="line">&lt;li&gt;北京首现零首付楼盘&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;input type=&quot;radio&quot; id=&quot;r-2&quot; name=&quot;tab&quot;&gt;</span><br><span class="line">&lt;label for=&quot;r-2&quot; class=&quot;label-2&quot;&gt;第二张&lt;/label&gt;</span><br><span class="line">&lt;div class=&quot;mod-2&quot;&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;新中式的酷色温情&lt;/li&gt;</span><br><span class="line">&lt;li&gt;深圳房价大跌,每平8W&lt;/li&gt;</span><br><span class="line">&lt;li&gt;800万买沙井三房&lt;/li&gt;</span><br><span class="line">&lt;li&gt;宝安房价平均900W&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><blockquote><p>纯css实现tab切换2</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;cssTab切换2&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">* &#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">text-decoration: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tab &#123;</span><br><span class="line">width: 300px;</span><br><span class="line">height: 300px;</span><br><span class="line">margin: 30px auto;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.nav &#123;</span><br><span class="line">height: 30px</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.content &#123;</span><br><span class="line">height: 270px;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.cont &#123;</span><br><span class="line">height: 270px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#the1 &#123;</span><br><span class="line">background: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#the2 &#123;</span><br><span class="line">background: blue;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;tab&quot;&gt;</span><br><span class="line">&lt;div class=&quot;nav&quot;&gt;</span><br><span class="line">&lt;a href=&quot;#the1&quot;&gt;ONE&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;#the2&quot;&gt;TWO&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">&lt;div id=&quot;the1&quot; class=&quot;cont&quot;&gt;第一张&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;the2&quot; class=&quot;cont&quot;&gt;第二张&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h1 id="scroll-behavior"><a href="#scroll-behavior" class="headerlink" title="scroll-behavior"></a>scroll-behavior</h1><p><code>scroll-behavior</code>属性可取值 <code>auto</code> | <code>smooth</code> | <code>inherit</code> | <code>unset</code></p><p><code>scroll-behavior: smooth;</code>是我们想要的缓冲效果。在PC浏览器中，页面默认滚动是在<code>&lt;html&gt;</code>标签上，移动端大多数在<code>&lt;body&gt;</code>标签上，在我们想要实现平滑“回到顶部”，只需在这两个标签上都加上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">  scroll-behavior: smooth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>准确的说，写在容器元素上，可以让容器（非鼠标手势触发）的滚动变得平滑，而不局限于<code>&lt;html&gt;</code>，<code>&lt;body&gt;</code>标签。</p><p>利用这个css属性可以一步将原来纯css标签直接切换，变成平滑过渡切换效果。</p><blockquote><p>纯css实现tab切换3</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">html,</span><br><span class="line">body &#123;</span><br><span class="line">scroll-behavior: smooth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tab label &#123;</span><br><span class="line">padding: 10px;</span><br><span class="line">border: 1px solid #ccc;</span><br><span class="line">margin-right: -1px;</span><br><span class="line">text-align: center;</span><br><span class="line">float: left;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.tab::after &#123;</span><br><span class="line">content: &quot;&quot;;</span><br><span class="line">display: table;</span><br><span class="line">clear: both;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box &#123;</span><br><span class="line">height: 200px;</span><br><span class="line">border: 1px solid #ccc;</span><br><span class="line">scroll-behavior: smooth;</span><br><span class="line">overflow: hidden;</span><br><span class="line">margin-top: 10px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item &#123;</span><br><span class="line">height: 100%;</span><br><span class="line">position: relative;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item input &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">height: 100%;</span><br><span class="line">width: 1px;</span><br><span class="line">border: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">margin: 0;</span><br><span class="line">clip: rect(0 0 0 0);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;纯CSS选项卡&lt;/h1&gt;</span><br><span class="line">&lt;div class=&quot;tab&quot;&gt;</span><br><span class="line">&lt;label for=&quot;tab1&quot;&gt;选项卡1&lt;/label&gt;</span><br><span class="line">&lt;label for=&quot;tab2&quot;&gt;选项卡2&lt;/label&gt;</span><br><span class="line">&lt;label for=&quot;tab3&quot;&gt;选项卡3&lt;/label&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;tab1&quot;&gt;</span><br><span class="line">&lt;p&gt;选项卡1内容&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;tab2&quot;&gt;</span><br><span class="line">&lt;p&gt;选项卡2内容&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;item&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; id=&quot;tab3&quot;&gt;</span><br><span class="line">&lt;p&gt;选项卡3内容&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="/2017/11/16/实现一个回到顶部/1.gif" alt="css-tab"></p><p>再来看一下这个css属性<a href="https://www.caniuse.com/#search=scroll-behavior" target="_blank" rel="noopener">scroll-behavior</a>在各大浏览器中的支持情况</p><p><img src="/2017/11/16/实现一个回到顶部/2.png" alt="scroll-behavior-compatibility"></p><p>呃~支持度不是很好，这样一行css代码能应用上当然是最好的，不行就退化成一闪而过的效果咯。下面再看下js提供的api。</p><h1 id="Element-scrollIntoView"><a href="#Element-scrollIntoView" class="headerlink" title="Element.scrollIntoView()"></a>Element.scrollIntoView()</h1><p><code>Element.scrollIntoView()</code> 方法让当前的元素滚动到浏览器窗口的可视区域内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.scrollIntoView();    // 等同于element.scrollIntoView(true)</span><br><span class="line">element.scrollIntoView(alignToTop);      // Boolean型参数</span><br><span class="line">element.scrollIntoView(scrollIntoViewOptions);     // Object型参数</span><br></pre></td></tr></table></figure></p><blockquote><p>一个很实用的用法【解决键盘弹出后挡表单的问题】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 解决键盘弹出后挡表单的问题</span><br><span class="line">    window.addEventListener(&apos;resize&apos;, function() &#123;</span><br><span class="line">      if(</span><br><span class="line">        document.activeElement.tagName === &apos;INPUT&apos; ||</span><br><span class="line">        document.activeElement.tagName === &apos;TEXTAREA&apos;</span><br><span class="line">      ) &#123;</span><br><span class="line">        window.setTimeout(function() &#123;</span><br><span class="line">          if(&apos;scrollIntoView&apos; in document.activeElement) &#123;</span><br><span class="line">            document.activeElement.scrollIntoView();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            document.activeElement.scrollIntoViewIfNeeded();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, 0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h2 id="参数alignToTop"><a href="#参数alignToTop" class="headerlink" title="参数alignToTop"></a>参数alignToTop</h2><p>一个<code>Boolean</code>值：</p><ul><li>如果为<code>true</code>，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的<code>scrollIntoViewOptions: {block: &quot;start&quot;, inline: &quot;nearest&quot;}</code>。这是这个参数的默认值。</li><li>如果为<code>false</code>，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的<code>scrollIntoViewOptions: {block: &quot;end&quot;, inline: &quot;nearest&quot;}</code>。</li></ul><h2 id="参数scrollIntoViewOptions"><a href="#参数scrollIntoViewOptions" class="headerlink" title="参数scrollIntoViewOptions"></a>参数scrollIntoViewOptions</h2><p>一个带有选项的 <code>object</code>：</p><pre><code>{  behavior: &quot;auto&quot;  | &quot;instant&quot; | &quot;smooth&quot;,  block:    &quot;start&quot; | &quot;end&quot;,}</code></pre><ul><li><code>behavior</code> 可选<br>定义缓动动画， “auto”, “instant”, 或 “smooth” 之一。默认为 “auto”。</li><li><code>block</code> 可选<br><code>&quot;start&quot;</code>, <code>&quot;center&quot;</code>, <code>&quot;end&quot;</code>, 或 <code>&quot;nearest&quot;</code>之一。默认为 <code>&quot;center&quot;</code>。</li><li><code>inline</code> 可选<br><code>&quot;start&quot;</code>, <code>&quot;center&quot;</code>, <code>&quot;end&quot;</code>, 或 <code>&quot;nearest&quot;</code>之一。默认为 <code>&quot;nearest&quot;</code>。</li></ul><p>浏览器支持</p><p><img src="/2017/11/16/实现一个回到顶部/3.png" alt=""></p><p>可以看到对于无参数的情况支持还是很好的，有参数的该API在浏览器中支持不是很好，我们可以同时结合CSS设置<code>scroll-behavior: smooth;</code>滚动效果，在执行滚动使用<code>target.scrollIntoView()</code>，即可达到“完美滚动”（不太完美）效果。</p><h1 id="向下兼容"><a href="#向下兼容" class="headerlink" title="向下兼容"></a>向下兼容</h1><p>要达到所有浏览器都有相同（类似）效果，那就要把剩余不支持<code>scroll-behavior</code>属性的浏览器揪出来，用js去完成使命了。</p><h2 id="判断是否支持scroll-behavior属性"><a href="#判断是否支持scroll-behavior属性" class="headerlink" title="判断是否支持scroll-behavior属性"></a>判断是否支持<code>scroll-behavior</code>属性</h2><p>很简单，用以下这一行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(typeofwindow.getComputedStyle(document.body).scrollBehavior === &apos;undefined&apos;) &#123;</span><br><span class="line">  // 兼容js代码</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 原生滚动api</span><br><span class="line">  // Element.scrollIntoView()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断是否支持<code>scroll-behavior</code>属性，直接利用原生<code>Element.scrollIntoView()</code>滚动，否则向下兼容处理。</p><h2 id="缓冲算法"><a href="#缓冲算法" class="headerlink" title="缓冲算法"></a>缓冲算法</h2><p>缓冲的直观效果是越来越慢，直到停止，也就是在相同时间内运动的距离越来越短。这样可以设置一个定时器，移动到当前点到目标点距离的缓冲率（比如1/2，1/3，…）处，比如，缓冲率设为2，当前距离目标点64px，下一秒就是32px，然后16px，8px…，到达某个阈值结束，也就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var position = position + (destination - position) / n;</span><br></pre></td></tr></table></figure></p><p>下面来简单实现一个点击右下方的”回到顶部“按钮，页面缓动滚动到顶部的demo。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.content &#123;</span><br><span class="line">height: 3000px;</span><br><span class="line">border: 1px solid #ccc;</span><br><span class="line">box-shadow: 0 0 2px solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.back-to-top &#123;</span><br><span class="line">width: 18px;</span><br><span class="line">padding: 10px;</span><br><span class="line">border: 1px solid #ccc;</span><br><span class="line">box-shadow: 0 0 2px #333;</span><br><span class="line">position: fixed;</span><br><span class="line">right: 20px;</span><br><span class="line">bottom: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.back-to-top:hover &#123;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">&lt;p&gt;很多内容。。。&lt;/p&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;section class=&quot;back-to-top&quot;&gt;</span><br><span class="line">回到顶部</span><br><span class="line">&lt;/section&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var scrollTopSmooth = function(position) &#123;</span><br><span class="line">// 不存在原生`requestAnimationFrame`，用`setTimeout`模拟替代</span><br><span class="line">if(!window.requestAnimationFrame) &#123;</span><br><span class="line">window.requestAnimationFrame = function(cb) &#123;</span><br><span class="line">return setTimeout(cb, 17);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">// 当前滚动高度</span><br><span class="line">var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">// step</span><br><span class="line">var step = function() &#123;</span><br><span class="line">var distance = position - scrollTop;</span><br><span class="line">scrollTop = scrollTop + distance / 5;</span><br><span class="line">if(Math.abs(distance) &lt; 1) &#123;</span><br><span class="line">window.scrollTo(0, position);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">window.scrollTo(0, scrollTop);</span><br><span class="line">requestAnimationFrame(step);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">step();</span><br><span class="line">&#125;</span><br><span class="line">$backToTop = document.querySelector(&apos;.back-to-top&apos;)</span><br><span class="line">$backToTop.addEventListener(&apos;click&apos;, function() &#123;</span><br><span class="line">scrollTopSmooth(0);</span><br><span class="line">&#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2017/11/16/实现一个回到顶部/4.gif" alt=""></p><h2 id="简单封装"><a href="#简单封装" class="headerlink" title="简单封装"></a>简单封装</h2><p>上面的小demo中，缓冲算法和当前滚动业务代码耦合在一起了，下面单独拆解出单独一个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 缓冲函数</span><br><span class="line"> * @param &#123;Number&#125; position 当前滚动位置</span><br><span class="line"> * @param &#123;Number&#125; destination 目标位置</span><br><span class="line"> * @param &#123;Number&#125; rate 缓动率</span><br><span class="line"> * @param &#123;Function&#125; callback 缓动结束回调函数 两个参数分别是当前位置和是否结束</span><br><span class="line"> */</span><br><span class="line">var easeout = function (position, destination, rate, callback) &#123;</span><br><span class="line">   if (position === destination || typeof destination !== &apos;number&apos;) &#123;</span><br><span class="line">     returnfalse;</span><br><span class="line">   &#125;</span><br><span class="line">   destination = destination || 0;</span><br><span class="line">   rate = rate || 2;</span><br><span class="line"> </span><br><span class="line">   // 不存在原生`requestAnimationFrame`，用`setTimeout`模拟替代</span><br><span class="line">   if (!window.requestAnimationFrame) &#123;</span><br><span class="line">     window.requestAnimationFrame = function (fn) &#123;</span><br><span class="line">       return setTimeout(fn, 17);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   var step = function () &#123;</span><br><span class="line">     position = position + (destination - position) / rate;</span><br><span class="line">     if (Math.abs(destination - position) &lt; 1) &#123;</span><br><span class="line">       callback(destination, true);</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">     callback(position, false);</span><br><span class="line">     requestAnimationFrame(step);</span><br><span class="line">   &#125;;</span><br><span class="line">   step();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>拆分后，这个小缓冲算法就可以被重复调用啦，而且，适用于滚动到指定位置（不仅仅是到顶部）和缓冲率（控制滚动快慢），当前小demo调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var scrollTopSmooth = function (position) &#123;</span><br><span class="line">  // 当前滚动高度</span><br><span class="line">  var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class="line">  easeout(scrollTop, position, 5, function (val) &#123;</span><br><span class="line">    window.scrollTo(0, val);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$backToTop = document.querySelector(&apos;.back-to-top&apos;)</span><br><span class="line">$backToTop.addEventListener(&apos;click&apos;, function () &#123;</span><br><span class="line">  scrollTopSmooth(200);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综合来看，简单实现一个完美滚动注意以下即可</p><ol><li><code>&lt;html&gt;</code>，<code>&lt;body&gt;</code>标签加上<code>scroll-behavior: smooth;</code>属性；</li><li>判断当前浏览器是否支持<code>scrollBehavior</code>属性；</li><li>如果支持直接用原生滚动api<code>Element.scrollIntoView()</code>；</li><li>如果不支持则用js小缓冲算法兼容处理。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">/* 滚动条动画：</span><br><span class="line"> * 移动端:document.body.scrollTop</span><br><span class="line">   PC端：document.documentElement.scrollTop</span><br><span class="line">   </span><br><span class="line">   //使用:gotoTop(400,callBack)</span><br><span class="line">   gotoTop(durations,  callback = undefined) &#123;</span><br><span class="line">      const doc = document.documentElement</span><br><span class="line">      const scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)</span><br><span class="line">      for (var i = 60; i &gt;= 0; i--) &#123;</span><br><span class="line">        setTimeout((i =&gt; &#123;</span><br><span class="line">          return () =&gt; &#123;</span><br><span class="line">            doc.scrollTop = scrollTop * i / 60</span><br><span class="line">            if (i === 0 &amp;&amp; typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">              callback()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i), durations * (1 - i / 60))</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> * */</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">var requestAnimFrame = (function() &#123;</span><br><span class="line">return window.requestAnimationFrame ||</span><br><span class="line">window.webkitRequestAnimationFrame ||</span><br><span class="line">window.mozRequestAnimationFrame ||</span><br><span class="line">function(callback) &#123;</span><br><span class="line">window.setTimeout(callback, 1000 / 60);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var cancelAnimationFrame = (function() &#123;</span><br><span class="line">return window.cancelAnimationFrame ||</span><br><span class="line">window.webkitCancelAnimationFrame ||</span><br><span class="line">window.mozCancelAnimationFrame ||</span><br><span class="line">window.oCancelAnimationFrame ||</span><br><span class="line">function(id) &#123;</span><br><span class="line">window.clearTimeout(id)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// Tween中的方法接受4个参数t,b,c,d 。t为初始时间 b、c、d三个参数（即初始值，变化量，持续时间）。返回值为当前位置</span><br><span class="line">// t =&gt; time(初始记步次数)  b =&gt; begin(初始位置)   c =&gt; change(变化量)   d =&gt; duration(持续次数)</span><br><span class="line"></span><br><span class="line">var tween = &#123;</span><br><span class="line">linear: function(t, b, c, d) &#123;</span><br><span class="line">return c * t / d + b;</span><br><span class="line">&#125;,</span><br><span class="line">easeIn: function(t, b, c, d) &#123;</span><br><span class="line">return c * (t /= d) * t + b;</span><br><span class="line">&#125;,</span><br><span class="line">strongEaseIn: function(t, b, c, d) &#123;</span><br><span class="line">return c * (t /= d) * t * t * t * t + b;</span><br><span class="line">&#125;,</span><br><span class="line">strongEaseOut: function(t, b, c, d) &#123;</span><br><span class="line">return c * ((t = t / d - 1) * t * t * t * t + 1) + b;</span><br><span class="line">&#125;,</span><br><span class="line">sineaseIn: function(t, b, c, d) &#123;</span><br><span class="line">return c * (t /= d) * t * t + b;</span><br><span class="line">&#125;,</span><br><span class="line">sineaseOut: function(t, b, c, d) &#123;</span><br><span class="line">return c * ((t = t / d - 1) * t * t + 1) + b;</span><br><span class="line">&#125;,</span><br><span class="line">easeInOutQuad: function(t, b, c, d) &#123;</span><br><span class="line">t /= d / 2;</span><br><span class="line">if(t &lt; 1) return c / 2 * t * t + b;</span><br><span class="line">t--;</span><br><span class="line">return -c / 2 * (t * (t - 2) - 1) + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var myReq; </span><br><span class="line">//回到顶部元素元素，结束位置，耗时，回调，滚动函数</span><br><span class="line">export var animatedScrollTo = function(element, to, duration, callback, Bzr = &apos;linear&apos;) &#123;</span><br><span class="line">var start = element.scrollTop,</span><br><span class="line">change = to - start,</span><br><span class="line">animationStart = +new Date();</span><br><span class="line">var animating = true;</span><br><span class="line">var lastpos = null;</span><br><span class="line"></span><br><span class="line">var animateScroll = function() &#123;</span><br><span class="line">if(!animating) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">myReq=requestAnimFrame(animateScroll);</span><br><span class="line">var now = +new Date();</span><br><span class="line">var val = Math.floor(tween[Bzr](now - animationStart, start, change, duration));</span><br><span class="line"></span><br><span class="line">if(lastpos) &#123;</span><br><span class="line">if(lastpos === element.scrollTop) &#123;</span><br><span class="line">lastpos = val;</span><br><span class="line">element.scrollTop = val;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">animating = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">lastpos = val;</span><br><span class="line">element.scrollTop = val;</span><br><span class="line">&#125;</span><br><span class="line">if(now &gt; animationStart + duration) &#123;</span><br><span class="line">element.scrollTop = to;</span><br><span class="line">animating = false;</span><br><span class="line">cancelAnimationFrame(myReq);   //清除定时器动画</span><br><span class="line">callback&amp;&amp;callback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">myReq=requestAnimFrame(animateScroll);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>vue-router浅析原理</title>
      <link href="/2017/11/15/Vue-router%E6%B5%85%E6%9E%90%E5%8E%9F%E7%90%86/"/>
      <url>/2017/11/15/Vue-router%E6%B5%85%E6%9E%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>近期被问到一个问题，在你们项目中使用的是Vue的SPA（单页面）还是Vue的多页面设计？</p><p>这篇文章主要围绕Vue的SPA单页面设计展开。<br>关于如何展开Vue多页面设计<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a8e3f00f265da4e747fc700" target="_blank" rel="noopener">请点击查看</a>。</p><h2 id="vue-router是什么？"><a href="#vue-router是什么？" class="headerlink" title="vue-router是什么？"></a>vue-router是什么？</h2><p>首先我们需要知道vue-router是什么，它是干什么的？</p><p>这里指的路由并不是指我们平时所说的硬件路由器，这里的路由就是SPA（单页应用）的路径管理器。<br>换句话说，vue-router就是WebApp的链接路径管理系统。</p><p>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。</p><p>那与传统的页面跳转有什么区别呢？</p><p>1.vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。</p><p>2.传统的页面应用，是用一些超链接来实现页面切换和跳转的。</p><p>在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。</p><p>至于为啥不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，必须使用vue-router来进行管理。</p><h2 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h2><p>SPA(single page application):单一页面应用程序，有且只有一个完整的页面；当它在加载页面的时候，不会加载整个页面的内容，而只更新某个指定的容器中内容。</p><p>单页面应用(SPA)的核心之一是:</p><p>1.更新视图而不重新请求页面;</p><p>2.vue-router在实现单页面前端路由时，提供了三种方式：Hash模式、History模式、abstract模式，根据mode参数来决定采用哪一种方式。</p><h4 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h4><p>vue-router 提供了三种运行模式：</p><p>● hash: 使用 URL hash 值来作路由。默认模式。</p><p>● history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。</p><p>● abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。</p><h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p><strong>vue-router 默认模式是 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，当 URL 改变时，页面不会去重新加载</strong>。</p><p>hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分（/#/..），浏览器只会加载相应位置的内容，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；<strong>所以说Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据</strong>。</p><h3 id="History模式"><a href="#History模式" class="headerlink" title="History模式"></a>History模式</h3><p>HTML5 History API提供了一种功能，能让开发人员在不刷新整个页面的情况下修改站点的URL，就是利用 history.pushState API 来完成 URL 跳转而无须重新加载页面；</p><p>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p><pre><code>//main.js文件中const router = new VueRouter({  mode: &apos;history&apos;,  routes: [...]})</code></pre><p>当使用 history 模式时，URL 就像正常的 url，例如 <a href="https://link.juejin.im?target=http%3A%2F%2Fyoursite.com%2Fuser%2Fid%25EF%25BC%258C%25E6%25AF%2594%25E8%25BE%2583%25E5%25A5%25BD%25E7%259C%258B%25EF%25BC%2581" target="_blank" rel="noopener">yoursite.com/user/id，比较好…</a><br>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问</p><p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</p><pre><code>export const routes = [   {path: &quot;/&quot;, name: &quot;homeLink&quot;, component:Home}  {path: &quot;/register&quot;, name: &quot;registerLink&quot;, component: Register},  {path: &quot;/login&quot;, name: &quot;loginLink&quot;, component: Login},  {path: &quot;*&quot;, redirect: &quot;/&quot;}]</code></pre><p>此处就设置如果URL输入错误或者是URL 匹配不到任何静态资源，就自动跳到到Home页面。</p><h3 id="abstract模式"><a href="#abstract模式" class="headerlink" title="abstract模式"></a>abstract模式</h3><p>abstract模式是使用一个不依赖于浏览器的浏览历史虚拟管理后端。</p><p>根据平台差异可以看出，在 Weex 环境中只支持使用 abstract 模式。 不过，vue-router 自身会对环境做校验，如果发现没有浏览器的 API，vue-router 会自动强制进入 abstract 模式，所以 在使用 vue-router 时只要不写 mode 配置即可，默认会在浏览器环境中使用 hash 模式，在移动端原生环境中使用 abstract 模式。 （当然，你也可以明确指定在所有情况下都使用 abstract 模式）</p><h2 id="vue-router使用方式"><a href="#vue-router使用方式" class="headerlink" title="vue-router使用方式"></a>vue-router使用方式</h2><p><strong>1:下载</strong> npm i vue-router -S</p><p><strong>2:在main.js中引入 </strong> import VueRouter from ‘vue-router’;</p><p><strong>3:安装插件</strong> Vue.use(VueRouter);</p><p><strong>4:创建路由对象并配置路由规则</strong></p><p>let router = new VueRouter({routes:[{path:’/home’,component:Home}]});</p><p><strong>5:将其路由对象传递给Vue的实例</strong>，options中加入 router:router</p><p><strong>6:在app.vue中留坑</strong></p><pre><code>&lt;router-view&gt;&lt;/router-view&gt;</code></pre><p>具体实现请看如下代码：</p><pre><code>//main.js文件中引入import Vue from &apos;vue&apos;;import VueRouter from &apos;vue-router&apos;;//主体import App from &apos;./components/app.vue&apos;;import index from &apos;./components/index.vue&apos;//安装插件Vue.use(VueRouter); //挂载属性//创建路由对象并配置路由规则let router = new VueRouter({    routes: [        //一个个对象        { path: &apos;/index&apos;, component: index }    ]});//new Vue 启动new Vue({    el: &apos;#app&apos;,    //让vue知道我们的路由规则    router: router, //可以简写router    render: c =&gt; c(App),})</code></pre><p>最后记得在在app.vue中“留坑”</p><pre><code>//app.vue中&lt;template&gt;    &lt;div&gt;        &lt;!-- 留坑，非常重要 --&gt;        &lt;router-view&gt;&lt;/router-view&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        data(){            return {}        }    }&lt;/script&gt;</code></pre><h2 id="vue-router源码分析"><a href="#vue-router源码分析" class="headerlink" title="vue-router源码分析"></a>vue-router源码分析</h2><p>我们先来看看vue的实现路径。<br><img src="https://user-gold-cdn.xitu.io/2018/10/18/16684f162d3090eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>在入口文件中需要实例化一个 VueRouter 的实例对象 ，然后将其传入 Vue 实例的 options 中。</p><pre><code>export default class VueRouter {  static install: () =&gt; void;  static version: string;  app: any;  apps: Array&lt;any&gt;;  ready: boolean;  readyCbs: Array&lt;Function&gt;;  options: RouterOptions;  mode: string;  history: HashHistory | HTML5History | AbstractHistory;  matcher: Matcher;  fallback: boolean;  beforeHooks: Array&lt;?NavigationGuard&gt;;  resolveHooks: Array&lt;?NavigationGuard&gt;;  afterHooks: Array&lt;?AfterNavigationHook&gt;;  constructor (options: RouterOptions = {}) {    this.app = null    this.apps = []    this.options = options    this.beforeHooks = []    this.resolveHooks = []    this.afterHooks = []    // 创建 matcher 匹配函数    this.matcher = createMatcher(options.routes || [], this)    // 根据 mode 实例化具体的 History，默认为&apos;hash&apos;模式    let mode = options.mode || &apos;hash&apos;    // 通过 supportsPushState 判断浏览器是否支持&apos;history&apos;模式    // 如果设置的是&apos;history&apos;但是如果浏览器不支持的话，&apos;history&apos;模式会退回到&apos;hash&apos;模式    // fallback 是当浏览器不支持 history.pushState 控制路由是否应该回退到 hash 模式。默认值为 true。    this.fallback = mode === &apos;history&apos; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== falseif (this.fallback) {      mode = &apos;hash&apos;    }    // 不在浏览器内部的话，就会变成&apos;abstract&apos;模式    if (!inBrowser) {      mode = &apos;abstract&apos;    }    this.mode = mode     // 根据不同模式选择实例化对应的 History 类    switch (mode) {      case&apos;history&apos;:        this.history = new HTML5History(this, options.base)        breakcase&apos;hash&apos;:        this.history = new HashHistory(this, options.base, this.fallback)        breakcase&apos;abstract&apos;:        this.history = new AbstractHistory(this, options.base)        break      default:        if (process.env.NODE_ENV !== &apos;production&apos;) {          assert(false, `invalid mode: ${mode}`)        }    }  }  match (    raw: RawLocation,    current?: Route,    redirectedFrom?: Location  ): Route {    return this.matcher.match(raw, current, redirectedFrom)  }  get currentRoute (): ?Route {    return this.history &amp;&amp; this.history.current  }  init (app: any /* Vue component instance */) {    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; assert(      install.installed,      `not installed. Make sure to call \`Vue.use(VueRouter)\` ` +      `before creating root instance.`    )    this.apps.push(app)    // main app already initialized.    if (this.app) {      return    }    this.app = app    const history = this.history    // 根据history的类别执行相应的初始化操作和监听    if (history instanceof HTML5History) {      history.transitionTo(history.getCurrentLocation())    } elseif (history instanceof HashHistory) {      const setupHashListener = () =&gt; {        history.setupListeners()      }      history.transitionTo(        history.getCurrentLocation(),        setupHashListener,        setupHashListener      )    }    history.listen(route =&gt; {      this.apps.forEach((app) =&gt; {        app._route = route      })    })  }  // 路由跳转之前  beforeEach (fn: Function): Function {    return registerHook(this.beforeHooks, fn)  }  // 路由导航被确认之间前  beforeResolve (fn: Function): Function {    return registerHook(this.resolveHooks, fn)  }  // 路由跳转之后  afterEach (fn: Function): Function {    return registerHook(this.afterHooks, fn)  }  // 第一次路由跳转完成时被调用的回调函数  onReady (cb: Function, errorCb?: Function) {    this.history.onReady(cb, errorCb)  }  // 路由报错  onError (errorCb: Function) {    this.history.onError(errorCb)  }  // 路由添加，这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {    this.history.push(location, onComplete, onAbort)  }  // 这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的。  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {    this.history.replace(location, onComplete, onAbort)  }  // 相对于当前页面向前或向后跳转多少个页面,类似 window.history.go(n)。n可为正数可为负数。正数返回上一个页面  go (n: number) {    this.history.go(n)  }  // 后退到上一个页面  back () {    this.go(-1)  }  // 前进到下一个页面  forward () {    this.go(1)  }  getMatchedComponents (to?: RawLocation | Route): Array&lt;any&gt; {    const route: any = to      ? to.matched        ? to        : this.resolve(to).route      : this.currentRoute    if (!route) {      return []    }    return [].concat.apply([], route.matched.map(m =&gt; {      return Object.keys(m.components).map(key =&gt; {        return m.components[key]      })    }))  }  resolve (    to: RawLocation,    current?: Route,    append?: boolean  ): {    location: Location,    route: Route,    href: string,    // for backwards compat    normalizedTo: Location,    resolved: Route  } {    const location = normalizeLocation(      to,      current || this.history.current,      append,      this    )    const route = this.match(location, current)    const fullPath = route.redirectedFrom || route.fullPath    const base = this.history.base    const href = createHref(base, fullPath, this.mode)    return {      location,      route,      href,      // for backwards compat      normalizedTo: location,      resolved: route    }  }  addRoutes (routes: Array&lt;RouteConfig&gt;) {    this.matcher.addRoutes(routes)    if (this.history.current !== START) {      this.history.transitionTo(this.history.getCurrentLocation())    }  }}</code></pre><h3 id="HashHistory"><a href="#HashHistory" class="headerlink" title="HashHistory"></a>HashHistory</h3><p>• hash虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端没影响，因此，改变hash不会重新加载页面。</p><p>• 可以为hash的改变添加监听事件：</p><pre><code>window.addEventListener(&quot;hashchange&quot;,funcRef,false)</code></pre><p>• 每一次改变hash(window.location.hash)，都会在浏览器访问历史中增加一个记录。</p><pre><code>export class HashHistory extends History {  constructor (router: Router, base: ?string, fallback: boolean) {    super(router, base)    // check history fallback deeplinking    // 如果是从history模式降级来的，需要做降级检查    if (fallback &amp;&amp; checkFallback(this.base)) {    // 如果降级且做了降级处理，则返回      return    }    ensureSlash()  }  .......function checkFallback (base) {  const location = getLocation(base)  // 得到除去base的真正的 location 值  if (!/^\/#/.test(location)) {  // 如果此时地址不是以 /# 开头的  // 需要做一次降级处理，降为 hash 模式下应有的 /# 开头    window.location.replace(      cleanPath(base + &apos;/#&apos; + location)    )    returntrue  }}function ensureSlash (): boolean {// 得到 hash 值  const path = getHash()  if (path.charAt(0) === &apos;/&apos;) {   // 如果是以 / 开头的，直接返回即可    returntrue  }  // 不是的话，需要手动保证一次 替换 hash 值  replaceHash(&apos;/&apos; + path)  returnfalse}exportfunction getHash (): string {  // We can&apos;t use window.location.hash here because it&apos;s not  // consistent across browsers - Firefox will pre-decode it!  // 因为兼容性的问题，这里没有直接使用 window.location.hash  // 因为 Firefox decode hash 值  const href = window.location.href  const index = href.indexOf(&apos;#&apos;)  return index === -1 ? &apos;&apos; : decodeURI(href.slice(index + 1))}// 得到hash之前的url地址function getUrl (path) {  const href = window.location.href  const i = href.indexOf(&apos;#&apos;)  const base = i &gt;= 0 ? href.slice(0, i) : href  return `${base}#${path}`}// 添加一个hashfunction pushHash (path) {  if (supportsPushState) {    pushState(getUrl(path))  } else {    window.location.hash = path  }}// 替代hashfunction replaceHash (path) {  if (supportsPushState) {    replaceState(getUrl(path))  } else {    window.location.replace(getUrl(path))  }}</code></pre><p>hash的改变会自动添加到浏览器的访问历史记录中。 那么视图的更新是怎么实现的呢，看下 transitionTo()方法：</p><pre><code>transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) {    const route = this.router.match(location, this.current) //找到匹配路由    this.confirmTransition(route, () =&gt; { //确认是否转化      this.updateRoute(route) //更新route      onComplete &amp;&amp; onComplete(route)      this.ensureURL()      // fire ready cbs once      if (!this.ready) {        this.ready = true        this.readyCbs.forEach(cb =&gt; { cb(route) })      }    }, err =&gt; {      if (onAbort) {        onAbort(err)      }      if (err &amp;&amp; !this.ready) {        this.ready = true        this.readyErrorCbs.forEach(cb =&gt; { cb(err) })      }    })  }//更新路由updateRoute (route: Route) {    const prev = this.current // 跳转前路由    this.current = route // 装备跳转路由    this.cb &amp;&amp; this.cb(route) // 回调函数，这一步很重要，这个回调函数在index文件中注册，会更新被劫持的数据 _router    this.router.afterHooks.forEach(hook =&gt; {      hook &amp;&amp; hook(route, prev)    })  }}</code></pre><h4 id="pushState"><a href="#pushState" class="headerlink" title="pushState"></a>pushState</h4><pre><code>exportfunction pushState (url?: string, replace?: boolean) {  saveScrollPosition()  // try...catch the pushState call to get around Safari  // DOM Exception 18 where it limits to 100 pushState calls  // 加了 try...catch 是因为 Safari 有调用 pushState 100 次限制  // 一旦达到就会抛出 DOM Exception 18 错误  const history = window.history  try {    if (replace) {    // replace 的话 key 还是当前的 key 没必要生成新的      history.replaceState({ key: _key }, &apos;&apos;, url)    } else {    // 重新生成 key      _key = genKey()       // 带入新的 key 值      history.pushState({ key: _key }, &apos;&apos;, url)    }  } catch (e) {  // 达到限制了 则重新指定新的地址    window.location[replace ? &apos;replace&apos; : &apos;assign&apos;](url)  }}</code></pre><h4 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h4><pre><code>// 直接调用 pushState 传入 replace 为 trueexportfunction replaceState (url?: string) {  pushState(url, true)}</code></pre><p>pushState和replaceState两种方法的共同特点：当调用他们修改浏览器历史栈后，虽然当前url改变了，但浏览器不会立即发送请求该url，这就为单页应用前端路由，更新视图但不重新请求页面提供了基础。</p><h4 id="supportsPushState"><a href="#supportsPushState" class="headerlink" title="supportsPushState"></a>supportsPushState</h4><pre><code>export const supportsPushState = inBrowser &amp;&amp; (function () {  const ua = window.navigator.userAgent  if (    (ua.indexOf(&apos;Android 2.&apos;) !== -1 || ua.indexOf(&apos;Android 4.0&apos;) !== -1) &amp;&amp;    ua.indexOf(&apos;Mobile Safari&apos;) !== -1 &amp;&amp;    ua.indexOf(&apos;Chrome&apos;) === -1 &amp;&amp;    ua.indexOf(&apos;Windows Phone&apos;) === -1  ) {    returnfalse  }  return window.history &amp;&amp; &apos;pushState&apos;in window.history})()</code></pre><p>其实所谓响应式属性，即当_route值改变时，会自动调用Vue实例的render()方法，更新视图。<br>$router.push()–&gt;HashHistory.push()–&gt;History.transitionTo()–&gt;History.updateRoute()–&gt;{app._route=route}–&gt;vm.render()</p><h4 id="监听地址栏"><a href="#监听地址栏" class="headerlink" title="监听地址栏"></a>监听地址栏</h4><p>在浏览器中，用户可以直接在浏览器地址栏中输入改变路由，因此还需要监听浏览器地址栏中路由的变化 ，并具有与通过代码调用相同的响应行为，在HashHistory中这一功能通过setupListeners监听hashchange实现：</p><pre><code>setupListeners () {    window.addEventListener(&apos;hashchange&apos;, () =&gt; {        if (!ensureSlash()) {            return        }        this.transitionTo(getHash(), route =&gt; {            replaceHash(route.fullPath)        })    })}</code></pre><h3 id="HTML5History"><a href="#HTML5History" class="headerlink" title="HTML5History"></a>HTML5History</h3><p>History interface是浏览器历史记录栈提供的接口，通过back(),forward(),go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</p><pre><code>export class HTML5History extends History {  constructor (router: Router, base: ?string) {    super(router, base)    const expectScroll = router.options.scrollBehavior //指回滚方式    const supportsScroll = supportsPushState &amp;&amp; expectScroll    if (supportsScroll) {      setupScroll()    }    const initLocation = getLocation(this.base)    //监控popstate事件    window.addEventListener(&apos;popstate&apos;, e =&gt; {      const current = this.current      // Avoiding first `popstate` event dispatched in some browsers but first      // history route not updated since async guard at the same time.      // 避免在某些浏览器中首次发出“popstate”事件      // 由于同一时间异步监听，history路由没有同时更新。      const location = getLocation(this.base)      if (this.current === START &amp;&amp; location === initLocation) {        return      }      this.transitionTo(location, route =&gt; {        if (supportsScroll) {          handleScroll(router, route, current, true)        }      })    })  }</code></pre><p>hash模式仅改变hash部分的内容，而hash部分是不会包含在http请求中的(hash带#)：</p><p><a href="https://link.juejin.im?target=http%3A%2F%2Foursite.com%2F%23%2Fuser%2Fid" target="_blank" rel="noopener">oursite.com/#/user/id</a> //如请求，只会发送<a href="http://oursite.com/" target="_blank" rel="noopener">http://oursite.com/</a></p><p>所以hash模式下遇到根据url请求页面不会有问题</p><p>而history模式则将url修改的就和正常请求后端的url一样(history不带#)</p><p><a href="https://link.juejin.im?target=http%3A%2F%2Foursite.com%2Fuser%2Fid" target="_blank" rel="noopener">oursite.com/user/id</a></p><p>如果这种向后端发送请求的话，后端没有配置对应/user/id的get路由处理,会返回404错误。</p><p>官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。</p><h4 id="两种模式比较"><a href="#两种模式比较" class="headerlink" title="两种模式比较"></a>两种模式比较</h4><p>一般的需求场景中，hash模式与history模式是差不多的，根据MDN的介绍，调用history.pushState()相比于直接修改hash主要有以下优势：</p><p>• pushState设置的新url可以是与当前url同源的任意url,而hash只可修改#后面的部分，故只可设置与当前同文档的url</p><p>• pushState设置的新url可以与当前url一模一样，这样也会把记录添加到栈中，而hash设置的新值必须与原来不一样才会触发记录添加到栈中</p><p>• pushState通过stateObject可以添加任意类型的数据记录中，而hash只可添加短字符串<br>pushState可额外设置title属性供后续使用</p><h3 id="AbstractHistory"><a href="#AbstractHistory" class="headerlink" title="AbstractHistory"></a>AbstractHistory</h3><p>‘abstract’模式，不涉及和浏览器地址的相关记录，流程跟’HashHistory’是一样的，其原理是通过数组模拟浏览器历史记录栈的功能</p><pre><code>//abstract.js实现，这里通过栈的数据结构来模拟路由路径export class AbstractHistory extends History {  index: number;  stack: Array&lt;Route&gt;;  constructor (router: Router, base: ?string) {    super(router, base)    this.stack = []    this.index = -1  }  // 对于 go 的模拟  go (n: number) {    // 新的历史记录位置    const targetIndex = this.index + n    // 小于或大于超出则返回    if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) {      return    }    // 取得新的 route 对象    // 因为是和浏览器无关的 这里得到的一定是已经访问过的    const route = this.stack[targetIndex]    // 所以这里直接调用 confirmTransition 了    // 而不是调用 transitionTo 还要走一遍 match 逻辑    this.confirmTransition(route, () =&gt; {      this.index = targetIndex      this.updateRoute(route)    })  } //确认是否转化路由  confirmTransition (route: Route, onComplete: Function, onAbort?: Function) {    const current = this.current    const abort = err =&gt; {      if (isError(err)) {        if (this.errorCbs.length) {          this.errorCbs.forEach(cb =&gt; { cb(err) })        } else {          warn(false, &apos;uncaught error during route navigation:&apos;)          console.error(err)        }      }      onAbort &amp;&amp; onAbort(err)    }    //判断如果前后是同一个路由，不进行操作    if (      isSameRoute(route, current) &amp;&amp;      route.matched.length === current.matched.length    ) {      this.ensureURL()      return abort()    }    //下面是各类钩子函数的处理    //*********************    })  }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Service Worker,PWA</title>
      <link href="/2017/11/14/Service-Worker-PWA/"/>
      <url>/2017/11/14/Service-Worker-PWA/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Service-Worker"><a href="#什么是Service-Worker" class="headerlink" title="什么是Service Worker"></a>什么是<code>Service Worker</code></h2><p><code>Service Worker</code>本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步<code>API</code>。</p><ul><li><code>Service Worker</code>的本质是一个<code>Web Worker</code>，它独立于<code>JavaScript</code>主线程，因此它不能直接访问<code>DOM</code>，也不能直接访问<code>window</code>对象，但是，<code>Service Worker</code>可以访问<code>navigator</code>对象，也可以通过消息传递的方式（<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">postMessage</a>）与<code>JavaScript</code>主线程进行通信。</li><li><code>Service Worker</code>是一个网络代理，它可以控制<code>Web</code>页面的所有网络请求。</li><li><code>Service Worker</code>具有自身的生命周期，使用好<code>Service Worker</code>的关键是灵活控制其生命周期。</li></ul><h2 id="Service-Worker的作用"><a href="#Service-Worker的作用" class="headerlink" title="Service Worker的作用"></a><code>Service Worker</code>的作用</h2><ul><li>用于浏览器缓存</li><li>实现离线<code>Web APP</code></li><li>消息推送</li></ul><h2 id="Service-Worker兼容性"><a href="#Service-Worker兼容性" class="headerlink" title="Service Worker兼容性"></a><code>Service Worker</code>兼容性</h2><p><img src="/2017/11/14/Service-Worker-PWA/1.webp" alt=""></p><p><code>Service Worker</code>是现代浏览器的一个高级特性，它依赖于<code>fetch API</code>、<code>Cache Storage</code>、<code>Promise</code>等，其中，<code>Cache</code>提供了<code>Request / Response</code>对象对的存储机制，<code>Cache Storage</code>存储多个<code>Cache</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在了解<code>Service Worker</code>的原理之前，先来看一段<code>Service Worker</code>的示例：</p><pre><code>self.importScripts(&apos;./serviceworker-cache-polyfill.js&apos;);var urlsToCache = [  &apos;/&apos;,  &apos;/index.js&apos;,  &apos;/style.css&apos;,  &apos;/favicon.ico&apos;,];varCACHE_NAME=&apos;counterxing&apos;;self.addEventListener(&apos;install&apos;, function(event) {  self.skipWaiting();  event.waitUntil(    caches.open(CACHE_NAME)    .then(function(cache) {      returncache.addAll(urlsToCache);    })  );});self.addEventListener(&apos;fetch&apos;, function(event) {  event.respondWith(    caches.match(event.request)    .then(function(response) {      if (response) {        return response;      }      returnfetch(event.request);    })  );});self.addEventListener(&apos;activate&apos;, function(event) {  var cacheWhitelist = [&apos;counterxing&apos;];  event.waitUntil(    caches.keys().then(function(cacheNames) {      returnPromise.all(        cacheNames.map(function(cacheName) {          if (cacheWhitelist.indexOf(cacheName) ===-1) {            returncaches.delete(cacheName);          }        })      );    })  );});</code></pre><p>下面开始逐段逐段地分析，揭开<code>Service Worker</code>的神秘面纱：</p><h2 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a><code>polyfill</code></h2><p>首先看第一行：<code>self.importScripts(&#39;./serviceworker-cache-polyfill.js&#39;);</code>，这里引入了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener">Cache API</a>的一个<a href="https://github.com/dominiccooney/cache-polyfill" target="_blank" rel="noopener">polyfill</a>，这个<code>polyfill</code>支持使得在较低版本的浏览器下也可以使用<code>Cache Storage API</code>。想要实现<code>Service Worker</code>的功能，一般都需要搭配<code>Cache API</code>代理网络请求到缓存中。</p><p>在<code>Service Worker</code>线程中，使用<code>importScripts</code>引入<code>polyfill</code>脚本，目的是对低版本浏览器的兼容。</p><h2 id="Cache-Resources-List-And-Cache-Name"><a href="#Cache-Resources-List-And-Cache-Name" class="headerlink" title="Cache Resources List And Cache Name"></a><code>Cache Resources List</code> And <code>Cache Name</code></h2><p>之后，使用一个<code>urlsToCache</code>列表来声明需要缓存的静态资源，再使用一个变量<code>CACHE_NAME</code>来确定当前缓存的<code>Cache Storage Name</code>，这里可以理解成<code>Cache Storage</code>是一个<code>DB</code>，而<code>CACHE_NAME</code>则是<code>DB</code>名：</p><pre><code>var urlsToCache = [  &apos;/&apos;,  &apos;/index.js&apos;,  &apos;/style.css&apos;,  &apos;/favicon.ico&apos;,];varCACHE_NAME=&apos;counterxing&apos;;</code></pre><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a><code>Lifecycle</code></h2><p><code>Service Worker</code>独立于浏览器<code>JavaScript</code>主线程，有它自己独立的生命周期。</p><p>如果需要在网站上安装<code>Service Worker</code>，则需要在<code>JavaScript</code>主线程中使用以下代码引入<code>Service Worker</code>。</p><pre><code>if (&apos;serviceWorker&apos;innavigator) {  navigator.serviceWorker.register(&apos;/sw.js&apos;).then(function(registration) {    console.log(&apos;成功安装&apos;, registration.scope);  }).catch(function(err) {    console.log(err);  });}</code></pre><p>此处，一定要注意<code>sw.js</code>文件的路径，在我的示例中，处于当前域根目录下，这意味着，<code>Service Worker</code>和网站是同源的，可以为当前网站的所有请求做代理，如果<code>Service Worker</code>被注册到<code>/imaging/sw.js</code>下，那只能代理<code>/imaging</code>下的网络请求。</p><p>可以使用<code>Chrome</code>控制台，查看当前页面的<code>Service Worker</code>情况：</p><p><img src="/2017/11/14/Service-Worker-PWA/2.webp" alt=""></p><p>安装完成后，<code>Service Worker</code>会经历以下生命周期：</p><ol><li>下载（<code>download</code>）</li><li>安装（<code>install</code>）</li><li>激活（<code>activate</code>）</li></ol><ul><li><p>用户首次访问<code>Service Worker</code>控制的网站或页面时，<code>Service Worker</code>会立刻被下载。之后至少每<code>24</code>小时它会被下载一次。它可能被更频繁地下载，不过每<code>24</code>小时一定会被下载一次，以避免不良脚本长时间生效。</p></li><li><p>在下载完成后，开始安装<code>Service Worker</code>，在安装阶段，通常需要缓存一些我们预先声明的静态资源，在我们的示例中，通过<code>urlsToCache</code>预先声明。</p></li><li><p>在安装完成后，会开始进行激活，浏览器会尝试下载<code>Service Worker</code>脚本文件，下载成功后，会与前一次已缓存的<code>Service Worker</code>脚本文件做对比，如果与前一次的<code>Service Worker</code>脚本文件不同，证明<code>Service Worker</code>已经更新，会触发<code>activate</code>事件。完成激活。</p></li></ul><p>如图所示，为<code>Service Worker</code>大致的生命周期：</p><p><img src="/2017/11/14/Service-Worker-PWA/3.webp" alt=""></p><h3 id="install"><a href="#install" class="headerlink" title="install"></a><code>install</code></h3><p>在安装完成后，尝试缓存一些静态资源：</p><pre><code>self.addEventListener(&apos;install&apos;, function(event) {  self.skipWaiting();  event.waitUntil(    caches.open(CACHE_NAME)    .then(function(cache) {      returncache.addAll(urlsToCache);    })  );});</code></pre><p>首先，<code>self.skipWaiting()</code>执行，告知浏览器直接跳过等待阶段，淘汰过期的<code>sw.js</code>的<code>Service Worker</code>脚本，直接开始尝试激活新的<code>Service Worker</code>。</p><p>然后使用<code>caches.open</code>打开一个<code>Cache</code>，打开后，通过<code>cache.addAll</code>尝试缓存我们预先声明的静态文件。</p><h3 id="监听fetch，代理网络请求"><a href="#监听fetch，代理网络请求" class="headerlink" title="监听fetch，代理网络请求"></a>监听<code>fetch</code>，代理网络请求</h3><p>页面的所有网络请求，都会通过<code>Service Worker</code>的<code>fetch</code>事件触发，<code>Service Worker</code>通过<code>caches.match</code>尝试从<code>Cache</code>中查找缓存，缓存如果命中，则直接返回缓存中的<code>response</code>，否则，创建一个真实的网络请求。</p><pre><code>self.addEventListener(&apos;fetch&apos;, function(event) {  event.respondWith(    caches.match(event.request)    .then(function(response) {      if (response) {        return response;      }      returnfetch(event.request);    })  );});</code></pre><p>如果我们需要在请求过程中，再向<code>Cache Storage</code>中添加新的缓存，可以通过<code>cache.put</code>方法添加，看以下例子：</p><pre><code>self.addEventListener(&apos;fetch&apos;, function(event) {  event.respondWith(    caches.match(event.request)    .then(function(response) {      // 缓存命中if (response) {        return response;      }      // 注意，这里必须使用clone方法克隆这个请求// 原因是response是一个Stream，为了让浏览器跟缓存都使用这个response// 必须克隆这个response，一份到浏览器，一份到缓存中缓存。// 只能被消费一次，想要再次消费，必须clone一次var fetchRequest =event.request.clone();      returnfetch(fetchRequest).then(        function(response) {          // 必须是有效请求，必须是同源响应，第三方的请求，因为不可控，最好不要缓存if (!response ||response.status!==200||response.type!==&apos;basic&apos;) {            return response;          }          // 消费过一次，又需要再克隆一次var responseToCache =response.clone();          caches.open(CACHE_NAME)            .then(function(cache) {              cache.put(event.request, responseToCache);            });          return response;        }      );    })  );});</code></pre><blockquote><p>在项目中，一定要注意控制缓存，接口请求一般是不推荐缓存的。所以在我自己的项目中，并没有在这里做动态的缓存方案。</p></blockquote><h3 id="activate"><a href="#activate" class="headerlink" title="activate"></a><code>activate</code></h3><p><code>Service Worker</code>总有需要更新的一天，随着版本迭代，某一天，我们需要把新版本的功能发布上线，此时需要淘汰掉旧的缓存，旧的<code>Service Worker</code>和<code>Cache Storage</code>如何淘汰呢？</p><pre><code>self.addEventListener(&apos;activate&apos;, function(event) {  var cacheWhitelist = [&apos;counterxing&apos;];  event.waitUntil(    caches.keys().then(function(cacheNames) {      returnPromise.all(        cacheNames.map(function(cacheName) {          if (cacheWhitelist.indexOf(cacheName) ===-1) {            returncaches.delete(cacheName);          }        })      );    })  );});</code></pre><ol><li>首先有一个白名单，白名单中的<code>Cache</code>是不被淘汰的。</li><li>之后通过<code>caches.keys()</code>拿到所有的<code>Cache Storage</code>，把不在白名单中的<code>Cache</code>淘汰。</li><li>淘汰使用<code>caches.delete()</code>方法。它接收<code>cacheName</code>作为参数，删除该<code>cacheName</code>所有缓存。</li></ol><h2 id="sw-precache-webpack-plugin"><a href="#sw-precache-webpack-plugin" class="headerlink" title="sw-precache-webpack-plugin"></a>sw-precache-webpack-plugin</h2><p><a href="https://github.com/goldhand/sw-precache-webpack-plugin" target="_blank" rel="noopener">sw-precache-webpack-plugin</a>是一个<code>webpack plugin</code>，可以通过配置的方式在<code>webpack</code>打包时生成我们想要的<code>sw.js</code>的<code>Service Worker</code>脚本。</p><p>一个最简单的配置如下：</p><pre><code>var path =require(&apos;path&apos;);var SWPrecacheWebpackPlugin =require(&apos;sw-precache-webpack-plugin&apos;);constPUBLIC_PATH=&apos;https://www.my-project-name.com/&apos;;  // webpack needs the trailing slash for output.publicPathmodule.exports= {  entry: {    main:path.resolve(__dirname, &apos;src/index&apos;),  },  output: {    path:path.resolve(__dirname, &apos;src/bundles/&apos;),    filename:&apos;[name]-[hash].js&apos;,    publicPath:PUBLIC_PATH,  },  plugins: [    newSWPrecacheWebpackPlugin(      {        cacheId:&apos;my-project-name&apos;,        dontCacheBustUrlsMatching:/\.\w{8}\./,        filename:&apos;service-worker.js&apos;,        minify:true,        navigateFallback:PUBLIC_PATH+&apos;index.html&apos;,        staticFileGlobsIgnorePatterns: [/\.map$/,/asset-manifest\.json$/],      }    ),  ],}</code></pre><p>在执行<code>webpack</code>打包后，会生成一个名为<code>service-worker.js</code>文件，用于缓存<code>webpack</code>打包后的静态文件。</p><p>一个最简单的<a href="https://github.com/goldhand/sw-precache-webpack-plugin/tree/master/examples" target="_blank" rel="noopener">示例</a>。</p><h2 id="Service-Worker-Cache-VS-Http-Cache"><a href="#Service-Worker-Cache-VS-Http-Cache" class="headerlink" title="Service Worker Cache VS Http Cache"></a><code>Service Worker Cache</code> VS <code>Http Cache</code></h2><p>对比起<code>Http Header</code>缓存，<code>Service Worker</code>配合<code>Cache Storage</code>也有自己的优势：</p><ol><li>缓存与更新并存：每次更新版本，借助<code>Service Worker</code>可以立马使用缓存返回，但与此同时可以发起请求，校验是否有新版本更新。</li><li>无侵入式：<code>hash</code>值实在是太难看了。</li><li>不易被冲掉：<code>Http</code>缓存容易被冲掉，也容易过期，而<code>Cache Storage</code>则不容易被冲掉。也没有过期时间的说法。</li><li>离线：借助<code>Service Worker</code>可以实现离线访问应用。</li></ol><p>但是缺点是，由于<code>Service Worker</code>依赖于<code>fetch API</code>、依赖于<code>Promise</code>、<code>Cache Storage</code>等，兼容性不太好。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>本文只是简单总结了<code>Service Worker</code>的基本使用和使用<code>Service Worker</code>做客户端缓存的简单方式，然而，<code>Service Worker</code>的作用远不止于此，例如：借助<code>Service Worker</code>做离线应用、用于做网络应用的推送（可参考<a href="https://developers.google.com/web/fundamentals/codelabs/push-notifications/" target="_blank" rel="noopener">push-notifications</a>）等。</p><p>甚至可以借助<code>Service Worker</code>，对接口进行缓存，在我所在的项目中，其实并不会做的这么复杂。不过做接口缓存的好处是支持离线访问，对离线状态下也能正常访问我们的<code>Web</code>应用。</p><p><code>Cache Storage</code>和<code>Service Worker</code>总是分不开的。<code>Service Worker</code>的最佳用法其实就是配合<code>Cache Storage</code>做离线缓存。借助于<code>Service Worker</code>，可以轻松实现对网络请求的控制，对于不同的网络请求，采取不同的策略。例如对于<code>Cache</code>的策略，其实也是存在多种情况。例如可以优先使用网络请求，在网络请求失败时再使用缓存、亦可以同时使用缓存和网络请求，一方面检查请求，一方面有检查缓存，然后看两个谁快，就用谁。</p><hr><h2 id="Progressive-Web-Apps（PWA）"><a href="#Progressive-Web-Apps（PWA）" class="headerlink" title="Progressive Web Apps（PWA）"></a>Progressive Web Apps（PWA）</h2><p><code>Progressive Web App</code>, 简称 PWA，是提升<code>Web App</code>的体验的一种新方法，能给用户原生应用的体验。</p><p><code>PWA</code>能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，<code>PWA</code>本质上是<code>Web App</code>，借助一些新技术也具备了<code>Native App</code>的一些特性，兼具<code>Web App</code>和<code>Native App</code>的优点。</p><p><code>PWA</code>的主要特点包括下面三点：</p><p>可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现</p><p>体验 - 快速响应，并且有平滑的动画响应用户的操作</p><p>粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面<br><code>PWA</code>本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过<a href="https://developers.google.cn/web/progressive-web-apps/checklist" target="_blank" rel="noopener">PWA Checklist</a>查看现有的特征。</p><p>通过上面的<code>PWA Checklist</code>，总结起来，<code>PWA</code>大致有以下的优势：</p><ul><li>体验：通过<code>Service Worker</code>配合<code>Cache Storage API</code>，保证了<code>PWA</code>首屏的加载效率，甚至配合本地存储可以支持离线应用；</li><li>粘性：<code>PWA</code>是可以安装的，用户点击安装到桌面后，会在桌面创建一个 PWA 应用，并且不需要从应用商店下载，可以借助<code>Web App Manifest</code>提供给用户和<code>Native App</code>一样的沉浸式体验，可以通过给用户发送离线通知，让用户回流；</li><li>渐进式：适用于大多数现代浏览器，随着浏览器版本的迭代，其功能是渐进增强的；</li><li>无版本问题：如<code>Web</code>应用的优势，更新版本只需要更新应用程序对应的静态文件即可，<code>Service Worker</code>会帮助我们进行更新；</li><li>跨平台：<code>Windows</code>、<code>Mac OSX</code>、<code>Android</code>、<code>IOS</code>，一套代码，多处使用；</li><li>消息推送：即使用户已经关闭应用程序，仍然可以对用户进行消息推送；</li></ul><p>总的说来，只要<code>Web</code>应用支持的功能，对于<code>PWA</code>而言，基本都支持，此外，还提供了原生能力。</p><h3 id="使用PWA-manifest添加桌面入口"><a href="#使用PWA-manifest添加桌面入口" class="headerlink" title="使用PWA manifest添加桌面入口"></a>使用<code>PWA manifest</code>添加桌面入口</h3><p>注意这里说的<code>manifest</code>不是指的<code>manifest</code>缓存，这个<code>manifest</code>是一个<code>JSON</code>文件，开发者可以利用它控制在用户想要看到应用的区域（例如移动设备主屏幕）中如何向用户显示网络应用或网站，指示用户可以启动哪些功能，以及定义其在启动时的外观。</p><p><code>manifest</code>提供了将网站书签保存到设备主屏幕的功能。当网站以这种方式启动时：</p><ul><li>它具有唯一的图标和名称，以便用户将其与其他网站区分开来。</li><li>它会在下载资源或从缓存恢复资源时向用户显示某些信息。</li><li>它会向浏览器提供默认显示特性，以避免网站资源可用时的过渡过于生硬。</li></ul><p>下面是我的博客网站的<code>manifest.json</code>文件，作为桌面入口配置文件的示例：</p><pre><code>{  &quot;name&quot;: &quot;Counterxing&quot;,  &quot;short_name&quot;: &quot;Counterxing&quot;,  &quot;description&quot;: &quot;Why did you encounter me?&quot;,  &quot;start_url&quot;: &quot;/index.html&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;orientation&quot;: &quot;any&quot;,  &quot;background_color&quot;: &quot;#ACE&quot;,  &quot;theme_color&quot;: &quot;#ACE&quot;,  &quot;icons&quot;: [{    &quot;src&quot;: &quot;/images/logo/logo072.png&quot;,    &quot;sizes&quot;: &quot;72x72&quot;,    &quot;type&quot;: &quot;image/png&quot;  }, {    &quot;src&quot;: &quot;/images/logo/logo152.png&quot;,    &quot;sizes&quot;: &quot;152x152&quot;,    &quot;type&quot;: &quot;image/png&quot;  }, {    &quot;src&quot;: &quot;/images/logo/logo192.png&quot;,    &quot;sizes&quot;: &quot;192x192&quot;,    &quot;type&quot;: &quot;image/png&quot;  }, {    &quot;src&quot;: &quot;/images/logo/logo256.png&quot;,    &quot;sizes&quot;: &quot;256x256&quot;,    &quot;type&quot;: &quot;image/png&quot;  }, {    &quot;src&quot;: &quot;/images/logo/logo512.png&quot;,    &quot;sizes&quot;: &quot;512x512&quot;,    &quot;type&quot;: &quot;image/png&quot;  }]}</code></pre><p>上面的字段含义也不用多解释了，大致就是启动的<code>icon</code>样式，应用名称、简写名称与描述等，其中必须确保有<code>short_name</code>和<code>name</code>。此外，最好设定好<code>start_url</code>，表示启动的根页面路径，如果不添加，则是使用当前路径。</p><p><code>display</code>为<code>standalone</code>，则会隐藏浏览器的<code>UI</code>界面，如果设置<code>display</code>为<code>browser</code>，则启动时保存浏览器的<code>UI</code>界面。</p><p><code>orientation</code>表示启动时的方向，横屏、竖屏等，具体参数值可参考<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="noopener">文档</a>。</p><p><code>background_color</code>和<code>theme_color</code>表示应用程序的背景颜色和主题颜色。</p><p>在创建好<code>manifest.json</code>后，将、使用<code>link</code>标签添加到应用程序的所有页面上，<code>&lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;</code></p><h3 id="安装到桌面"><a href="#安装到桌面" class="headerlink" title="安装到桌面"></a>安装到桌面</h3><h4 id="桌面端（以Mac-OSX为例）"><a href="#桌面端（以Mac-OSX为例）" class="headerlink" title="桌面端（以Mac OSX为例）"></a>桌面端（以<code>Mac OSX</code>为例）</h4><p>只有注册、激活了<code>Service Worker</code>的网站才能够安装到桌面，在<code>Chrome 70</code>版本之前，需要手动开启实验性功能，步骤如下：</p><ol><li>进入<code>chrome://flags</code></li><li>找到<code>Desktop PWAs</code>，选择<code>Enabled</code></li></ol><p><img src="/2017/11/14/Service-Worker-PWA/4.webp" alt=""><br>此时，进入一个支持<code>PWA</code>的网站（例如<a href="https://events.google.com/io2016/" target="_blank" rel="noopener">Google I/O</a>），在<code>Chrome</code>浏览器右上角，点击安装。即可安装到桌面。这里以我的博客为例：</p><blockquote><p>可以到<a href="https://github.com/hemanth/awesome-pwa" target="_blank" rel="noopener">awesome-pwa</a>查找目前支持<code>PWA</code>的网站列表</p></blockquote><p><img src="/2017/11/14/Service-Worker-PWA/5.webp" alt=""><br>接着点击安装：</p><p><img src="/2017/11/14/Service-Worker-PWA/6.webp" alt=""><br>这样，一个<code>PWA</code>应用就安装到你的机器上了，这里我的操作系统为<code>Mac OSX</code>，应用程序可以通过<code>Launchpad</code>打开，在<code>Windows</code>也是同理的，会被安装到桌面上，可通过开始菜单找到应用程序。</p><p><img src="/2017/11/14/Service-Worker-PWA/7.webp" alt=""><br>打开应用程序，发现其与原始应用几乎没有任何差距：</p><p><img src="/2017/11/14/Service-Worker-PWA/8.webp" alt=""></p><blockquote><p>Windows与上述方法类似，这里就不做过多阐述</p></blockquote><h4 id="移动端（以IOS为例）"><a href="#移动端（以IOS为例）" class="headerlink" title="移动端（以IOS为例）"></a>移动端（以<code>IOS</code>为例）</h4><p>由于当初苹果推出<code>PWA</code>时，并没有一个统一的<code>manifest</code>的规范，最开始的设计是通过<code>meta</code>和<code>link</code>标签来设定应用的对应参数的，所以，在移动端上的<code>PWA</code>应用，为了兼容<code>Windows Phone</code>和<code>iPhone</code>，需要在所有页面的<code>HTML</code>的<code>head</code>中添加以下的标签：</p><pre><code>&lt;metaname=&quot;msapplication-TileImage&quot;content=&quot;./images/logo/logo152.png&quot;&gt;&lt;metaname=&quot;msapplication-TileColor&quot;content=&quot;#2F3BA2&quot;&gt;&lt;metaname=&quot;apple-mobile-web-app-capable&quot;content=&quot;yes&quot;&gt;&lt;metaname=&quot;apple-mobile-web-app-status-bar-style&quot;content=&quot;black&quot;&gt;&lt;metaname=&quot;apple-mobile-web-app-title&quot;content=&quot;Counterxing&quot;&gt;&lt;linkrel=&quot;apple-touch-icon&quot;href=&quot;./images/logo/logo152.png&quot;&gt;</code></pre><p>添加好后，就可以体验我们的<code>PWA</code>了！</p><p><code>IOS</code>在<code>11.3</code>版本之后也支持<code>PWA</code>了，知道这一消息的我，卸载了手机上很多软件，立刻体验上了<code>PWA</code>。</p><p>这里以<a href="https://m.douban.com" target="_blank" rel="noopener">豆瓣移动端</a>为例使用<code>Safiri</code>浏览器打开一个网站，点击下方分享图标，选择添加到主屏幕。</p><p><img src="/2017/11/14/Service-Worker-PWA/9.webp" alt=""><br><img src="/2017/11/14/Service-Worker-PWA/10.webp" alt=""><br>然后在新弹出的一个浏览器页面，选择添加：</p><p><img src="/2017/11/14/Service-Worker-PWA/11.webp" alt=""><br>就以上简短的步骤，移动端上的一个<code>PWA</code>桌面应用就添加好了，赶紧体验吧！</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文是笔者写的<code>Service Worker</code>学习与实践系列文章的第二篇，主要讲述的是配合<code>Service Worker</code>使用的<code>PWA</code>的优势，如何配置<code>manifest.json</code>文件来实现将<code>PWA</code>安装到桌面，并通过<code>Mac OSX</code>和<code>IOS</code>如何安装<code>PWA</code>到桌面的详细步骤，阐述了如何配置<code>PWA</code>，使其方便地安装到桌面上。</p><p>下一篇文章中，主要讲述<code>Service Worker</code>在<code>PWA</code>实践中的重要能力：<code>Web Push</code>。</p><hr><h2 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h2><p>说到底，<code>PWA</code>的消息推送也是服务端推送的一种，常见的服务端推送方法，例如广泛使用的轮询、长轮询、<code>Web Socket</code>等，说到底，都是客户端与服务端之间的通信，在<code>Service Worker</code>中，客户端接收到通知，是基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification" target="_blank" rel="noopener">Notification</a>来进行推送的。</p><p>那么，我们来看一下，如何直接使用<code>Notification</code>来发送一条推送呢？下面是一段示例代码：</p><pre><code>// 在主线程中使用let notification =newNotification(&apos;您有新消息&apos;, {  body:&apos;Hello Service Worker&apos;,  icon:&apos;./images/logo/logo152.png&apos;,});notification.onclick=function() {  console.log(&apos;点击了&apos;);};</code></pre><p>在控制台敲下上述代码后，则会弹出以下通知：</p><p><img src="/2017/11/14/Service-Worker-PWA/12.webp" alt=""><br>然而，<code>Notification</code>这个<code>API</code>，只推荐在<code>Service Worker</code>中使用，不推荐在主线程中使用，在<code>Service Worker</code>中的使用方法为：</p><pre><code>// 添加notificationclick事件监听器，在点击notification时触发self.addEventListener(&apos;notificationclick&apos;, function(event) {  // 关闭当前的弹窗event.notification.close();  // 在新窗口打开页面event.waitUntil(    clients.openWindow(&apos;https://google.com&apos;)  );});// 触发一条通知self.registration.showNotification(&apos;您有新消息&apos;, {  body:&apos;Hello Service Worker&apos;,  icon:&apos;./images/logo/logo152.png&apos;,});</code></pre><p>读者可以在<a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/showNotification" target="_blank" rel="noopener">MDN Web Docs</a>关于<code>Notification</code>在<code>Service Worker</code>中的相关用法，在本文就不浪费大量篇幅来进行较为详细的阐述了。</p><h2 id="申请推送的权限"><a href="#申请推送的权限" class="headerlink" title="申请推送的权限"></a>申请推送的权限</h2><p>如果浏览器直接给所有开发者开放向用户推送通知的权限，那么势必用户会受到大量垃圾信息的骚扰，因此这一权限是需要申请的，如果用户禁止了消息推送，开发者是没有权利向用户发起消息推送的。我们可以通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager" target="_blank" rel="noopener">serviceWorkerRegistration.pushManager.getSubscription</a>方法查看用户是否已经允许推送通知的权限。修改<code>sw-register.js</code>中的代码：</p><pre><code>if (&apos;serviceWorker&apos;innavigator) {  navigator.serviceWorker.register(&apos;/sw.js&apos;).then(function (swReg) {    swReg.pushManager.getSubscription()      .then(function(subscription) {        if (subscription) {          console.log(JSON.stringify(subscription));        } else {          console.log(&apos;没有订阅&apos;);          subscribeUser(swReg);        }      });  });}</code></pre><p>上面的代码调用了<code>swReg.pushManager</code>的<code>getSubscription</code>，可以知道用户是否已经允许进行消息推送，如果<code>swReg.pushManager.getSubscription</code>的<code>Promise</code>被<code>reject</code>了，则表示用户还没有订阅我们的消息，调用<code>subscribeUser</code>方法，向用户申请消息推送的权限：</p><pre><code>functionsubscribeUser(swReg) {  constapplicationServerKey=urlB64ToUint8Array(applicationServerPublicKey);  swReg.pushManager.subscribe({    userVisibleOnly:true,    applicationServerKey: applicationServerKey  })  .then(function(subscription) {    console.log(JSON.stringify(subscription));  })  .catch(function(err) {    console.log(&apos;订阅失败: &apos;, err);  });}</code></pre><p>上面的代码通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/PushManager" target="_blank" rel="noopener">serviceWorkerRegistration.pushManager.subscribe</a>向用户发起订阅的权限，这个方法返回一个<code>Promise</code>，如果<code>Promise</code>被<code>resolve</code>，则表示用户允许应用程序推送消息，反之，如果被<code>reject</code>，则表示用户拒绝了应用程序的消息推送。如下图所示：</p><p><img src="/2017/11/14/Service-Worker-PWA/13.webp" alt=""><br><code>serviceWorkerRegistration.pushManager.subscribe</code>方法通常需要传递两个参数：</p><ul><li><code>userVisibleOnly</code>，这个参数通常被设置为<code>true</code>，用来表示后续信息是否展示给用户。</li><li><p><code>applicationServerKey</code>，这个参数是一个<code>Uint8Array</code>，用于加密服务端的推送信息，防止中间人攻击，会话被攻击者篡改。这一参数是由服务端生成的公钥，通过<code>urlB64ToUint8Array</code>转换的，这一函数通常是固定的，如下所示：</p><p>  functionurlB64ToUint8Array(base64String) {</p><pre><code>constpadding=&apos;=&apos;.repeat((4-base64String.length%4) %4);constbase64= (base64String + padding)  .replace(/\-/g, &apos;+&apos;)  .replace(/_/g, &apos;/&apos;);constrawData=window.atob(base64);constoutputArray=newUint8Array(rawData.length);for (let i =0; i &lt;rawData.length; ++i) {  outputArray[i] =rawData.charCodeAt(i);}return outputArray;</code></pre><p>  }</p></li></ul><p>关于服务端公钥如何获取，在文章后续会有相关阐述。</p><h2 id="处理拒绝的权限"><a href="#处理拒绝的权限" class="headerlink" title="处理拒绝的权限"></a>处理拒绝的权限</h2><p>如果在调用<code>serviceWorkerRegistration.pushManager.subscribe</code>后，用户拒绝了推送权限，同样也可以在应用程序中，通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/notification/permission" target="_blank" rel="noopener">Notification.permission</a>获取到这一状态，<code>Notification.permission</code>有以下三个取值，：</p><ul><li><code>granted</code>：用户已经明确的授予了显示通知的权限。</li><li><code>denied</code>：用户已经明确的拒绝了显示通知的权限。</li><li><p><code>default</code>：用户还未被询问是否授权，在应用程序中，这种情况下权限将视为<code>denied</code>。</p><p>  if (Notification.permission===’granted’) {</p><pre><code>// 用户允许消息推送</code></pre><p>  } else {</p><pre><code>// 还不允许消息推送，向用户申请消息推送的权限</code></pre><p>  }</p></li></ul><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>上述代码中的<code>applicationServerPublicKey</code>通常情况下是由服务端生成的公钥，在页面初始化的时候就会返回给客户端，服务端会保存每个用户对应的公钥与私钥，以便进行消息推送。</p><p>在我的示例演示中，我们可以使用<code>Google</code>配套的实验网站<a href="https://web-push-codelab.glitch.me/" target="_blank" rel="noopener">web-push-codelab</a>生成公钥与私钥，以便发送消息通知：</p><p><img src="/2017/11/14/Service-Worker-PWA/14.webp" alt=""></p><h2 id="发送推送"><a href="#发送推送" class="headerlink" title="发送推送"></a>发送推送</h2><p>在<code>Service Worker</code>中，通过监听<code>push</code>事件来处理消息推送：</p><pre><code>self.addEventListener(&apos;push&apos;, function(event) {  consttitle=event.data.text();  constoptions= {    body:event.data.text(),    icon:&apos;./images/logo/logo512.png&apos;,  };  event.waitUntil(self.registration.showNotification(title, options));});</code></pre><p>在上面的代码中，在<code>push</code>事件回调中，通过<code>event.data.text()</code>拿到消息推送的文本，然后调用上面所说的<code>self.registration.showNotification</code>来展示消息推送。</p><h2 id="服务端发送"><a href="#服务端发送" class="headerlink" title="服务端发送"></a>服务端发送</h2><p>那么，如何在服务端识别指定的用户，向其发送对应的消息推送呢？</p><p>在调用<code>swReg.pushManager.subscribe</code>方法后，如果用户是允许消息推送的，那么该函数返回的<code>Promise</code>将会<code>resolve</code>，在<code>then</code>中获取到对应的<code>subscription</code>。</p><p><code>subscription</code>一般是下面的格式：</p><pre><code>{  &quot;endpoint&quot;: &quot;https://fcm.googleapis.com/fcm/send/cSEJGmI_x2s:APA91bHzRHllE6tNoEHqjHQSlLpcQHeiGr7X78EIa1QrUPFqDGDM_4RVKNxoLPV3_AaCCejR4uwUawBKYcQLmLpUrCUoZetQ9pVzQCJSomB5BvoFZBzkSnUb-ALm4D1lqwV9w_uP3M0E&quot;,  &quot;expirationTime&quot;: null,  &quot;keys&quot;: {    &quot;p256dh&quot;: &quot;BDOx1ZTtsFL2ncSN17Bu7-Wl_1Z7yIiI-lKhtoJ2dAZMToGz-XtQOe6cuMLMa3I8FoqPfcPy232uAqoISB4Z-UU&quot;,    &quot;auth&quot;: &quot;XGWy-wlmrAw3Be818GLZ8Q&quot;  }}</code></pre><p>使用<code>Google</code>配套的实验网站<a href="https://web-push-codelab.glitch.me/" target="_blank" rel="noopener">web-push-codelab</a>，发送消息推送。</p><p><img src="/2017/11/14/Service-Worker-PWA/15.webp" alt=""></p><h2 id="web-push"><a href="#web-push" class="headerlink" title="web-push"></a>web-push</h2><p>在服务端，使用<a href="https://github.com/web-push-libs" target="_blank" rel="noopener">web-push-libs</a>，实现公钥与私钥的生成，消息推送功能，<a href="https://github.com/web-push-libs/web-push" target="_blank" rel="noopener">Node.js版本</a>。</p><pre><code>constwebpush=require(&apos;web-push&apos;);// VAPID keys should only be generated only once.constvapidKeys=webpush.generateVAPIDKeys();webpush.setGCMAPIKey(&apos;&lt;Your GCM API Key Here&gt;&apos;);webpush.setVapidDetails(  &apos;mailto:example@yourdomain.org&apos;,  vapidKeys.publicKey,  vapidKeys.privateKey);// pushSubscription是前端通过swReg.pushManager.subscribe获取到的subscriptionconstpushSubscription= {  endpoint:&apos;.....&apos;,  keys: {    auth:&apos;.....&apos;,    p256dh:&apos;.....&apos;  }};webpush.sendNotification(pushSubscription, &apos;Your Push Payload Text&apos;);</code></pre><p>上面的代码中，<code>GCM API Key</code>需要在<a href="https://console.firebase.google.com" target="_blank" rel="noopener">Firebase console</a>中申请，申请教程可参考这篇<a href="https://www.pushbots.help/install-pushbots-in-your-app-or-website/android/the-google-part-fcmgcm-api-key-and-sender-id" target="_blank" rel="noopener">博文</a>。</p><p>在这个我写的示例<code>Demo</code>中，我把<code>subscription</code>写死了：</p><pre><code>constwebpush=require(&apos;web-push&apos;);webpush.setVapidDetails(  &apos;mailto:503908971@qq.com&apos;,  &apos;BCx1qqSFCJBRGZzPaFa8AbvjxtuJj9zJie_pXom2HI-gisHUUnlAFzrkb-W1_IisYnTcUXHmc5Ie3F58M1uYhZU&apos;,  &apos;g5pubRphHZkMQhvgjdnVvq8_4bs7qmCrlX-zWAJE9u8&apos;);constsubscription= {  &quot;endpoint&quot;:&quot;https://fcm.googleapis.com/fcm/send/cSEJGmI_x2s:APA91bHzRHllE6tNoEHqjHQSlLpcQHeiGr7X78EIa1QrUPFqDGDM_4RVKNxoLPV3_AaCCejR4uwUawBKYcQLmLpUrCUoZetQ9pVzQCJSomB5BvoFZBzkSnUb-ALm4D1lqwV9w_uP3M0E&quot;,  &quot;expirationTime&quot;:null,  &quot;keys&quot;: {    &quot;p256dh&quot;:&quot;BDOx1ZTtsFL2ncSN17Bu7-Wl_1Z7yIiI-lKhtoJ2dAZMToGz-XtQOe6cuMLMa3I8FoqPfcPy232uAqoISB4Z-UU&quot;,    &quot;auth&quot;:&quot;XGWy-wlmrAw3Be818GLZ8Q&quot;  }};webpush.sendNotification(subscription, &apos;Counterxing&apos;);</code></pre><h2 id="交互响应"><a href="#交互响应" class="headerlink" title="交互响应"></a>交互响应</h2><p>默认情况下，推送的消息点击后是没有对应的交互的，配合<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Clients" target="_blank" rel="noopener">clients API</a>可以实现一些类似于原生应用的交互，这里参考了这篇<a href="https://blog.csdn.net/i10630226/article/details/78888698" target="_blank" rel="noopener">博文</a>的实现：</p><blockquote><p><code>Service Worker</code>中的<code>self.clients</code>对象提供了<code>Client</code>的访问，<code>Client</code>接口表示一个可执行的上下文，如<code>Worker</code>或<code>SharedWorker</code>。<code>Window</code>客户端由更具体的<code>WindowClient</code>表示。 你可以从<code>Clients.matchAll()</code>和<code>Clients.get()</code>等方法获取<code>Client/WindowClient</code>对象。</p></blockquote><h3 id="新窗口打开"><a href="#新窗口打开" class="headerlink" title="新窗口打开"></a>新窗口打开</h3><p>使用<code>clients.openWindow</code>在新窗口打开一个网页：</p><pre><code>self.addEventListener(&apos;notificationclick&apos;, function(event) {  event.notification.close();  // 新窗口打开event.waitUntil(    clients.openWindow(&apos;https://google.com/&apos;)  );});</code></pre><h3 id="聚焦已经打开的页面"><a href="#聚焦已经打开的页面" class="headerlink" title="聚焦已经打开的页面"></a>聚焦已经打开的页面</h3><p>利用<code>cilents</code>提供的相关<code>API</code>获取，当前浏览器已经打开的页面<code>URLs</code>。不过这些<code>URLs</code>只能是和你<code>SW</code>同域的。然后，通过匹配<code>URL</code>，通过<code>matchingClient.focus()</code>进行聚焦。没有的话，则新打开页面即可。</p><pre><code>self.addEventListener(&apos;notificationclick&apos;, function(event) {  event.notification.close();  consturlToOpen=self.location.origin+&apos;/index.html&apos;;  constpromiseChain=clients.matchAll({      type:&apos;window&apos;,      includeUncontrolled:true    })    .then((windowClients) =&gt; {      let matchingClient =null;      for (let i =0; i &lt;windowClients.length; i++) {        constwindowClient= windowClients[i];        if (windowClient.url=== urlToOpen) {          matchingClient = windowClient;          break;        }      }      if (matchingClient) {        returnmatchingClient.focus();      } else {        returnclients.openWindow(urlToOpen);      }    });  event.waitUntil(promiseChain);});</code></pre><h3 id="检测是否需要推送"><a href="#检测是否需要推送" class="headerlink" title="检测是否需要推送"></a>检测是否需要推送</h3><p>如果用户已经停留在当前的网页，那我们可能就不需要推送了，那么针对于这种情况，我们应该怎么检测用户是否正在网页上呢？</p><blockquote><p>通过<code>windowClient.focused</code>可以检测到当前的<code>Client</code>是否处于聚焦状态。</p></blockquote><pre><code>self.addEventListener(&apos;push&apos;, function(event) {  constpromiseChain=clients.matchAll({      type:&apos;window&apos;,      includeUncontrolled:true    })    .then((windowClients) =&gt; {      let mustShowNotification =true;      for (let i =0; i &lt;windowClients.length; i++) {        constwindowClient= windowClients[i];        if (windowClient.focused) {          mustShowNotification =false;          break;        }      }      return mustShowNotification;    })    .then((mustShowNotification) =&gt; {      if (mustShowNotification) {        consttitle=event.data.text();        constoptions= {          body:event.data.text(),          icon:&apos;./images/logo/logo512.png&apos;,        };        returnself.registration.showNotification(title, options);      } else {        console.log(&apos;用户已经聚焦于当前页面，不需要推送。&apos;);      }    });});</code></pre><h3 id="合并消息"><a href="#合并消息" class="headerlink" title="合并消息"></a>合并消息</h3><p>该场景的主要针对消息的合并。比如，当只有一条消息时，可以直接推送，那如果该用户又发送一个消息呢？ 这时候，比较好的用户体验是直接将推送合并为一个，然后替换即可。 那么，此时我们就需要获得当前已经展示的推送消息，这里主要通过<code>registration.getNotifications() API</code>来进行获取。该<code>API</code>返回的也是一个<code>Promise</code>对象。通过<code>Promise</code>在<code>resolve</code>后拿到的<code>notifications</code>，判断其<code>length</code>，进行消息合并。</p><pre><code>self.addEventListener(&apos;push&apos;, function(event) {  // ...    .then((mustShowNotification) =&gt; {      if (mustShowNotification) {        returnregistration.getNotifications()          .then(notifications=&gt; {            let options = {              icon:&apos;./images/logo/logo512.png&apos;,              badge:&apos;./images/logo/logo512.png&apos;            };            let title =event.data.text();            if (notifications.length) {              options.body=`您有${notifications.length}条新消息`;            } else {              options.body=event.data.text();            }            returnself.registration.showNotification(title, options);          });      } else {        console.log(&apos;用户已经聚焦于当前页面，不需要推送。&apos;);      }    });  // ...});</code></pre><p><img src="/2017/11/14/Service-Worker-PWA/16.webp" alt=""></p><h3 id="服务端推送的几种方式"><a href="#服务端推送的几种方式" class="headerlink" title="服务端推送的几种方式"></a>服务端推送的几种方式</h3><p>服务端推送是现今<code>Web</code>开发过程中最常见的需求。例如：</p><ul><li>即时聊天工具</li><li>H5网络游戏</li><li>消息通知</li></ul><p>一般的服务器推送包括：</p><ul><li>最简单的是客户端轮询的方式，在客户端创建一个定时器，每隔一定的时间去请求服务端，每次请求检查状态变化以判断服务端是否有新数据更新。</li><li>基于 AJAX 的长轮询（<code>long-polling</code>）方式，服务器在一段时间后再返回信息；</li><li><code>HTTP Streaming</code>，通过<code>iframe</code>和<code>&lt;script&gt;</code>标签完成数据的传输；</li><li><code>TCP</code>长连接/<code>WebSocket</code>，可以实现服务器主动发送数据至网页端，它和<code>HTTP</code>一样，是一个基于<code>HTTP</code>的应用层协议，跑的是<code>TCP</code>，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像<code>HTTP</code>的请求和响应</li><li><code>SSE: Server-Sent Events</code>，这是通过<code>http</code>协议变通实现的，通过服务端向客户端声明，接下来是要发送的是流信息，本质上就是完成一次耗时长的下载。</li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本文通过一个简单的例子，讲述了<code>Service Worker</code>中消息推送的原理。<code>Service Worker</code>中的消息推送是基于<code>Notification API</code>的，这一<code>API</code>的使用首先需要用户授权，通过在<code>Service Worker</code>注册时的<code>serviceWorkerRegistration.pushManager.subscribe</code>方法来向用户申请权限，如果用户拒绝了消息推送，应用程序也需要相关处理。</p><p>消息推送是基于谷歌云服务的，因此，在国内，收到<code>GFW</code>的限制，这一功能的支持并不好，<code>Google</code>提供了一系列推送相关的库，例如<code>Node.js</code>中，使用<a href="https://github.com/web-push-libs/web-push" target="_blank" rel="noopener">web-push</a>来实现。一般原理是：在服务端生成公钥和私钥，并针对用户将其公钥和私钥存储到服务端，客户端只存储公钥。<code>Service Worker</code>的<code>swReg.pushManager.subscribe</code>可以获取到<code>subscription</code>，并发送给服务端，服务端利用<code>subscription</code>向指定的用户发起消息推送。</p><p>消息推送功能可以配合<code>clients API</code>做特殊处理。</p><p>如果用户安装了<code>PWA</code>应用，即使用户关闭了应用程序，<code>Service Worker</code>也在运行，即使用户未打开应用程序，也会收到消息通知。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Service Worker </tag>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>call和apply的第一个参数是null/undefined时函数内的的this指向window或global</title>
      <link href="/2017/11/11/call%E5%92%8Capply%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AFnull-undefined%E6%97%B6%E5%87%BD%E6%95%B0%E5%86%85%E7%9A%84%E7%9A%84this%E6%8C%87%E5%90%91window%E6%88%96global/"/>
      <url>/2017/11/11/call%E5%92%8Capply%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AFnull-undefined%E6%97%B6%E5%87%BD%E6%95%B0%E5%86%85%E7%9A%84%E7%9A%84this%E6%8C%87%E5%90%91window%E6%88%96global/</url>
      
        <content type="html"><![CDATA[<h2 id="谁说-JavaScript-很简单了？"><a href="#谁说-JavaScript-很简单了？" class="headerlink" title="谁说 JavaScript 很简单了？"></a><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000009024648" target="_blank" rel="noopener">谁说 JavaScript 很简单了？</a></h2><h2 id="JavaScript系列——数组元素左右移动N位算法实现"><a href="#JavaScript系列——数组元素左右移动N位算法实现" class="headerlink" title="JavaScript系列——数组元素左右移动N位算法实现"></a><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000012882330" target="_blank" rel="noopener">JavaScript系列——数组元素左右移动N位算法实现</a></h2><p>14年的面试题，想不到今天在群里有人还问了这个！<br><img src="https://pic1.zhimg.com/v2-2ba203f9e2e5fd627521c12d5e8f4e91_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-2ba203f9e2e5fd627521c12d5e8f4e91_hd.jpg" alt=""><br>call/apply用来改变函数的执行上下文（this），它们的第一个参数thisArg是个对象，即作为函数内的this。</p><p>多数时候你传啥函数内就是啥。仅以call示例</p><pre><code>function fun() {alert(this);}fun.call(1);fun.call(&apos;a&apos;);fun.call(true);fun.call({name:&apos;jack&apos;});</code></pre><p>分别弹出“1”、“a”、“true”、“[object Object]”。</p><p>有两种情况需要注意，传null或undefined时，将是JS执行环境的全局变量。浏览器中是window，其它环境（如node）则是global。</p><pre><code>fun.call(null); // window or globalfun.call(undefined); // window or global</code></pre><p>这在ECMAScript5.1 15.3.4.4中有解释，如下<br><img src="https://pic2.zhimg.com/v2-a55dd237510bbfca06ff1f5ad5c1ac2e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-a55dd237510bbfca06ff1f5ad5c1ac2e_hd.jpg" alt=""><br>严格模式下情况又有所不同，ES3比较宽容尽量去揣测代码意图。ES5严格模式（ie6/7/8/9除外）则不再揣测，给call/apply传入的任何参数不再转换。如下</p><pre><code>&apos;use strict&apos;function fun() {alert(this);}fun.call(null)      // nullfun.call(undefined) // undefined </code></pre><h2 id="几个面试小题："><a href="#几个面试小题：" class="headerlink" title="几个面试小题："></a>几个面试小题：</h2><p><img src="https://pic1.zhimg.com/v2-99d1bfc9bfa325ea383e8e5209a46384_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-99d1bfc9bfa325ea383e8e5209a46384_hd.jpg" alt=""><br>1.alert(alert(1)&amp;&amp;alert(2)):    第一个alert执行没返回undefined【alert 是函数，alert（1）相当调用，但没有返回值，所以是undefined】，alert（2） 直接短路掉。</p><p>2.alert(1&amp;&amp;2)   &amp;&amp;第一个为true，才会执行第二个，如果全部是true返回最后一个值。</p><p>3.<br><img src="https://pic3.zhimg.com/v2-3c568d3cbe2ee035f846917f7907903d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-3c568d3cbe2ee035f846917f7907903d_hd.jpg" alt=""><br>多次bind只保留第一次的。</p><p>4.<br><img src="https://pic3.zhimg.com/v2-99af21478704f737a974a986e9fd41cc_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-99af21478704f737a974a986e9fd41cc_hd.jpg" alt=""><br>5.<br><img src="https://pic4.zhimg.com/v2-eef9d265365a8782e55efa78ad718b01_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-eef9d265365a8782e55efa78ad718b01_hd.jpg" alt=""><img src="https://pic4.zhimg.com/v2-d355491fab6f0917e3b6b141992dac5c_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-d355491fab6f0917e3b6b141992dac5c_hd.jpg" alt=""><img src="https://pic4.zhimg.com/v2-698cc4f2c86dccb91268ae9b597089dc_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-698cc4f2c86dccb91268ae9b597089dc_hd.jpg" alt=""><br>6.自定义事件</p><pre><code>var myEvent = new Event(&apos;myEvent&apos;);document.addEventListener(&apos;myEvent&apos;, log, false);function log() {  console.log(&apos;hello event&apos;);}document.dispatchEvent(myEvent);</code></pre><p>7.数组循环移动<br><img src="https://pic4.zhimg.com/v2-c996087a776f590d84df53c1827872d2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c996087a776f590d84df53c1827872d2_hd.jpg" alt=""><br>需求</p><p>假设有这样一个数组</p><pre><code>[1,2,3,4,5]</code></pre><p>现在想要左移或者右移N位，比如移动1位</p><pre><code>//左移1位[2,3,4,5,1]//右移1位[5,1,2,3,4]</code></pre><p>算法实现</p><p>这样一道题目，你先不要看我下面的代码，自己思考一下如何实现它，不管是复杂的还是简单的方法。<br>可以先告诉你我用了2行代码实现左、右移动元素。</p><p>拆分法</p><p>当我们没有具体思路的时候，就先假设数组移动1位的情况。</p><pre><code>[1,2,3,4,5]=&gt;[null,1,2,3,4] and [5,null,null,null,null]=&gt;[5,1,2,3,4]</code></pre><p>这里可以看成2个数组，一个是没有到达边界的元素移动[null,1,2,3,4]，一个是到达了边界的元素移动[5,null,null,null,null]，当元素到达边界，就会往数组的初始位置移动，形成了一个循环的过程。</p><p>很明显，如果我们将这2个移动后的数组合并起来，就是需求的结果。</p><p>移动2位</p><p>同样符合2个移动后的数组合并起来为结果的情况</p><pre><code>[1,2,3,4,5]=&gt;[null,null,1,2,3] and [4,5,null,null,null]=&gt;[4,5,1,2,3]</code></pre><p>刚好移动数组长度</p><pre><code>[1,2,3,4,5]=&gt;[1,2,3,4,5] and [] //如果没有，就假设为空数组</code></pre><p>合并数组</p><p>假设移动1位的情况<br>上面的步骤，我们找到了规律，接下来要做的是找到2个数组，需要用到slice截取数组元素。<br>截取第一个数组</p><pre><code>arr.slice(0,-1)// [1,2,3,4]</code></pre><p>截取第二个数组</p><pre><code>arr.slice(-1)// [5]</code></pre><p>合并数组</p><pre><code>arr.slice(-1).concat(arr.slice(0,-1))// [5,1,2,3,4]</code></pre><p>这样你就实现了移动1位的情况，接着，你继续拿+5和-5范围内的数字进行测试，发现都可以正常移动，当数字大于5或者小于-5的时候，代码就无效了，始终输出[1,2,3,4,5]</p><pre><code>arr.slice(-6).concat(arr.slice(0,-6))// [1,2,3,4,5]</code></pre><p>我们再加上一个小技巧，求余数，假设是移动6，那么，实际上和移动1是相同的，我们就可以根据公式求余数</p><pre><code>n = n%arr.length// n = 6%5 余1</code></pre><p>同理，当移动-6时</p><pre><code>n = n%arr.length// n = -6%5 余-1</code></pre><p>接着带入公式，发现输出全部都正确了！！</p><p>思路分析完了，应该很清晰了吧，源码在下面、</p><p>算法源码</p><p>arr表示原始数组，n表示移动的距离，可以是正数、可以是0、也可以是负数、正数表示右移，负数表示左移，0表示不移动。</p><pre><code>function moveElement(arr, n) {  if(Math.abs(n)&gt;arr.length) n = n%arr.length  return arr.slice(-n).concat(arr.slice(0,-n))}// moveElement(arr, 9)// moveElement(arr, 0)// moveElement(arr, -9)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>H5如何唤起APP</title>
      <link href="/2017/11/04/H5%E5%A6%82%E4%BD%95%E5%94%A4%E8%B5%B7APP/"/>
      <url>/2017/11/04/H5%E5%A6%82%E4%BD%95%E5%94%A4%E8%B5%B7APP/</url>
      
        <content type="html"><![CDATA[<p>前一段时间在做电流App H5页面，需求中落地页占比较大，落地页承担的职责就是引流。引流有两种形式，同时也是我们对唤端的定义：引导已下载用户打开APP，引导未下载用户下载APP。</p><p>引导已下载用户打开APP，从数据上说用户停留在APP中的时间更多了，是在提高用户粘性；从体验上说，APP体验是要比H5好的。引导未下载用户下载APP，可以增加我们的用户量。</p><p>上面其实分别解释了 <strong>什么是唤端</strong> 以及 <strong>为什么要唤端</strong>，也就是  <em>3W法则</em> 中的 What 和 Why，那么接下来我们就要聊一聊 How 了，也就是 <strong>如何唤端</strong> 。</p><p>我们先来看看常见的唤端方式以及他们适用的场景：</p><h2 id="唤端媒介"><a href="#唤端媒介" class="headerlink" title="唤端媒介"></a>唤端媒介</h2><h3 id="URL-Scheme"><a href="#URL-Scheme" class="headerlink" title="URL Scheme"></a>URL Scheme</h3><h4 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h4><p>我们的手机上有许多私密信息，联系方式、照片、银行卡信息…我们不希望这些信息可以被手机应用随意获取到，信息泄露的危害甚大。所以，如何保证个人信息在设备所有者知情并允许的情况下被使用，是智能设备的核心安全问题。</p><p>对此，苹果使用了名为 <em>沙盒</em> 的机制：应用只能访问它声明可能访问的资源。但沙盒也阻碍了应用间合理的信息共享，某种程度上限制了应用的能力。</p><p>因此，我们急需要一个辅助工具来帮助我们实现应用通信， URL Scheme 就是这个工具。</p><h4 id="URL-Scheme-是什么"><a href="#URL-Scheme-是什么" class="headerlink" title="URL Scheme 是什么"></a>URL Scheme 是什么</h4><p>我们来看一下 URL 的组成：</p><pre><code>[scheme:][//authority][path][?query][#fragment]</code></pre><p>我们拿 <code>https://www.baidu.com</code> 来举例，scheme 自然就是 <code>https</code> 了。</p><p>就像给服务器资源分配一个 URL，以便我们去访问它一样，我们同样也可以给手机APP分配一个特殊格式的 URL，用来访问这个APP或者这个APP中的某个功能(来实现通信)。APP得有一个标识，好让我们可以定位到它，它就是 URL 的 Scheme 部分。</p><h4 id="常用APP的-URL-Scheme"><a href="#常用APP的-URL-Scheme" class="headerlink" title="常用APP的 URL Scheme"></a>常用APP的 URL Scheme</h4><table><thead><tr><th>APP</th><th style="text-align:center">微信</th><th style="text-align:center">支付宝</th><th style="text-align:center">淘宝</th><th style="text-align:center">微博</th><th style="text-align:center">QQ</th></tr></thead><tbody><tr><td>URL Scheme</td><td style="text-align:center">weixin://</td><td style="text-align:center">alipay://</td><td style="text-align:center">taobao://</td><td style="text-align:center">sinaweibo://</td><td style="text-align:center">mqq://</td></tr></tbody></table><h4 id="URL-Scheme-语法"><a href="#URL-Scheme-语法" class="headerlink" title="URL Scheme 语法"></a>URL Scheme 语法</h4><p>上面表格中都是最简单的用于打开 APP 的 URL Scheme，下面才是我们常用的 URL Scheme 格式：</p><pre><code>     行为(应用的某个功能)                |scheme://[path][?query]   |               |应用标识       功能需要的参数</code></pre><h3 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h3><p>安卓的原生谷歌浏览器自从 chrome25 版本开始对于唤端功能做了一些变化，URL Scheme 无法再启动Android应用。 例如，通过 iframe 指向 <code>weixin://</code>，即使用户安装了微信也无法打开。所以，APP需要实现谷歌官方提供的 <code>intent:</code> 语法，或者实现让用户通过自定义手势来打开APP，当然这就是题外话了。</p><h4 id="Intent-语法"><a href="#Intent-语法" class="headerlink" title="Intent 语法"></a>Intent 语法</h4><pre><code>intent:   HOST/URI-path // Optional host    #Intent;       package=[string];       action=[string];       category=[string];       component=[string];       scheme=[string];    end;</code></pre><p>如果用户未安装 APP，则会跳转到系统默认商店。当然，如果你想要指定一个唤起失败的跳转地址，添加下面的字符串在 <code>end;</code> 前就可以了:</p><pre><code>S.browser_fallback_url=[encoded_full_url]</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>下面是打开 Zxing 二维码扫描 APP 的 intent。</p><pre><code>intent:   //scan/   #Intent;       package=com.google.zxing.client.android;       scheme=zxing;    end; </code></pre><p>打开这个 APP ，可以通过如下的方式：</p><pre><code>&lt;ahref=&quot;intent://scan/#Intent;scheme=zxing;package=com.google.zxing.client.android;S.browser_fallback_url=http%3A%2F%2Fzxing.org;end&quot;&gt; Take a QR code &lt;/a&gt;</code></pre><h3 id="Universal-Link"><a href="#Universal-Link" class="headerlink" title="Universal Link"></a>Universal Link</h3><h4 id="Universal-Link-是什么"><a href="#Universal-Link-是什么" class="headerlink" title="Universal Link 是什么"></a>Universal Link 是什么</h4><p>Universal Link 是苹果在 WWDC2015 上为 iOS9 引入的新功能，通过传统的 HTTP 链接即可打开 APP。如果用户未安装 APP，则会跳转到该链接所对应的页面。</p><h4 id="为什么要使用-Universal-Link"><a href="#为什么要使用-Universal-Link" class="headerlink" title="为什么要使用 Universal Link"></a>为什么要使用 Universal Link</h4><p>传统的 Scheme 链接有以下几个痛点：</p><ul><li>在 ios 上会有确认弹窗提示用户是否打开，对于用户来说唤端，多出了一步操作。若用户未安装 APP ，也会有一个提示窗，告知我们 “打不开该网页，因为网址无效”</li><li>传统 Scheme 跳转无法得知唤端是否成功，Universal Link 唤端失败可以直接打开此链接对应的页面</li><li>Scheme 在微信、微博、QQ浏览器、手百中都已经被禁止使用，使用 Universal Link 可以避开它们的屏蔽（ 截止到 18年8月21日，微信和QQ浏览器已经禁止了 Universal Link，其他主流APP未发现有禁止 ）</li></ul><h4 id="如何让-APP-支持-Universal-Link"><a href="#如何让-APP-支持-Universal-Link" class="headerlink" title="如何让 APP 支持 Universal Link"></a>如何让 APP 支持 Universal Link</h4><p>有大量的文章会详细的告诉我们如何配置，你也可以去看<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Farchive%2Fdocumentation%2FGeneral%2FConceptual%2FAppSearch%2FUniversalLinks.html%23%2F%2Fapple_ref%2Fdoc%2Fuid%2FTP40016308-CH12-SW2" target="_blank" rel="noopener">官方文档</a>，我这里简单的写一个12345。</p><ol><li>拥有一个支持 <strong>https</strong> 的域名</li><li>在 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.apple.com%2F" target="_blank" rel="noopener">开发者中心</a> ，Identifiers 下 AppIDs 找到自己的 App ID，编辑打开 Associated Domains 服务。</li><li>打开工程配置中的 Associated Domains ，在其中的 Domains 中填入你想支持的域名，必须以 <code>applinks:</code> 为前缀</li><li>配置 <code>apple-app-site-association</code> 文件，文件名必须为 <code>apple-app-site-association</code> ，<strong>不带任何后缀</strong></li><li>上传该文件到你的 HTTPS 服务器的 <strong>根目录</strong> 或者 <code>.well-known</code> 目录下</li></ol><h4 id="Universal-Link-配置中的坑"><a href="#Universal-Link-配置中的坑" class="headerlink" title="Universal Link 配置中的坑"></a>Universal Link 配置中的坑</h4><p>这里放一下我们在配置过程中遇到的坑，当然首先你在配置过程中必须得严格按照上面的要求去做，尤其是加粗的地方。</p><ol><li>域名问题</li></ol><p>Universal Link 支持的域名最多只能支持到二级域名，如果你用到了三级域名，Universal Link 唤端是不会生效的。</p><ol start="2"><li>跨域问题</li></ol><p>IOS 9.2 以后，必须要触发跨域才能支持 Universal Link 唤端。</p><p>IOS 那边有这样一个判断，如果你要打开的 Universal Link 和 当前页面是同一域名，ios 尊重用户最可能的意图，直接打开链接所对应的页面。如果不在同一域名下，则在你的 APP 中打开链接，也就是执行具体的唤端操作。</p><ol start="3"><li>Universal Link 是空页面</li></ol><p>Universal Link 本质上是个空页面，如果未安装 APP，Universal Link 被当做普通的页面链接，自然会跳到 404 页面，所以我们需要将它绑定到我们的中转页或者下载页。</p><h2 id="如何调用三种唤端媒介"><a href="#如何调用三种唤端媒介" class="headerlink" title="如何调用三种唤端媒介"></a>如何调用三种唤端媒介</h2><p>通过前面的介绍，我们可以发现，无论是 URL Scheme 还是 Intent 或者 Universal Link ，他们都算是 URL ，只是 URL Scheme 和 Intent 算是特殊的 URL。所以我们可以拿使用 URL 的方法来使用它们。</p><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><pre><code>&lt;iframesrc=&quot;sinaweibo://qrcode&quot;&gt;</code></pre><p>在只有 URL Scheme 的日子里，iframe 是使用最多的了。因为在未安装 app 的情况下，不会去跳转错误页面。但是 iframe 在各个系统以及各个应用中的兼容问题还是挺多的，不能全部使用 URL Scheme。</p><h3 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h3><pre><code>&lt;ahref=&quot;intent://scan/#Intent;scheme=zxing;package=com.google.zxing.client.android;end&quot;&quot;&gt;扫一扫&lt;/a&gt;</code></pre><p>前面我们提到 Intent 协议，官方给出的用例使用的就是使用的 a 标签，所以我们跟着一起用就可以了。</p><p>使用过程中，对于动态生成的 a 标签，使用 <code>dispatch</code> 来模拟触发点击事件，发现很多种 event 传递过去都无效；使用 <code>click()</code> 来模拟触发，部分场景下存在这样的情况，第一次点击过后，回到原先页面，再次点击，点击位置和页面所识别位置有不小的偏移，所以 Intent 协议从 a 标签换成了 window.location。</p><h3 id="window-location"><a href="#window-location" class="headerlink" title="window.location"></a>window.location</h3><p>URL Scheme 在 ios 9+ 上诸如 safari、UC、QQ浏览器中， iframe 均无法成功唤起 APP，只能通过 window.location 才能成功唤端。</p><p>当然，如果我们的 app 支持 Universal Link，ios 9+ 就用不到 URL Scheme 了。而 Universal Link 在使用过程中，我发现在 qq 中，无论是 iframe 导航 还是 a 标签打开 又或者 window.location 都无法成功唤端，一开始我以为是 qq 和微信一样禁止了 Universal Link 唤端的功能，其实不然，百般试验下，通过 top.location 唤端成功了。</p><h2 id="判断唤端是否成功"><a href="#判断唤端是否成功" class="headerlink" title="判断唤端是否成功"></a>判断唤端是否成功</h2><p>如果唤端失败（APP 未安装），我们总是要做一些处理的，可以是跳转下载页，可以是 ios 下跳转 App Store… 但是Js 并不能提供给我们获取 APP 唤起状态的能力，Android Intent 以及 Universal Link 倒是不用担心，它们俩的自身机制允许它们唤端失败后直接导航至相应的页面，但是 URL Scheme 并不具备这样的能力，所以我们只能通过一些很 hack 的方式来实现 APP 唤起检测功能。</p><pre><code>const initialTime = newDate();let counter = 0;let waitTime = 0;const checkOpen = setInterval(() =&gt; {   count++;   waitTime = newDate() - initialTime;   if (waitTime &gt; 2500) {      clearInterval(checkOpen);      cb();   }   if (counter &lt; 100) return;   clearInterval(checkOpen);   const hide = document.hidden || document.webkitHidden;   if (!hide) {      cb(); // 唤端失败的回调函数   }}, 20);</code></pre><p>APP 如果被唤起的话，页面就会进入后台运行，setInterval 在 ios 中不会停止运行，在 android 中停止运行。</p><p>每 20ms 执行一次，执行 100次 在页面中实际耗费与 2000 ms 不会相差多少。</p><p>我们的判断条件比预期时间多设置了 500ms，所以如果安卓中 setInterval 内的函数执行 100 次以内所费时间超过 2500ms，则说明 APP 唤起成功，反之则代表失败。</p><p>我们通过 document.hidden 和 document.webkitHidden 属性来判断 APP 在 ios 中是否被正常唤起，2000ms 内，页面转入后台运行，document.hidden 会返回 true，代表唤端成功，反之则代表失败。</p><h2 id="没有完美的方案"><a href="#没有完美的方案" class="headerlink" title="没有完美的方案"></a>没有完美的方案</h2><p>透过上面的几个点，我们可以发现，无论是 <em>唤端媒介</em> 、 <em>调用唤端媒介</em> 还是 <em>判断唤端结果</em> 都没有一个十全十美的方法，我们在代码层上能做的只是在确保最常用的场景（比如 微信、微博、手百 等）唤端无误的情况下，最大化的兼容剩余的场景。</p><p>好的，我们接下来扯一些代码以外的，让我们的 APP 能够在更多的平台唤起。</p><ul><li>微信、微博、手百、QQ浏览器等。</li></ul><p>这些应用能阻止唤端是因为它们直接屏蔽掉了 URL Scheme 。接下来可能就有看官疑惑了，微信中是可以打开大众点评的呀，微博里面可以打开优酷呀，那是如何实现的呢？</p><p>它们都各自维护着一个白名单，如果你的域名在白名单内，那这个域名下所有的页面发起的 URL Scheme 就都会被允许。就像微信，如果你是腾讯的“家属”，你就可以加入白名单了，微信的白名单一般只包含着“家属”，除此外很难申请到白名单资质。但是微博之类的都是可以联系他们的渠道童鞋进行申请的，只是条件各不相同，比如微博的就是在你的 APP 中添加打开微博的入口，三个月内唤起超过 100w 次，就可以加入白名单了。</p><ul><li>腾讯应用宝直接打开 APP 的某个功能</li></ul><p>刚刚我们说到，如果你不是微信的家属，那你是很难进入白名单的，所以在安卓中我们一般都是直接打开腾讯应用宝，ios 中 直接打开 App Store。点击腾讯应用宝中的“打开”按钮，可以直接唤起我们的 APP，但是无法打开 APP 中的某个功能（就是无法打开指定页面）。</p><p>腾讯应用宝对外开放了一个叫做 APP Link 的申请，只要你申请了 APP Link，就可以通过在打开应用宝的时候在应用宝地址后面添加上 <code>&amp;android_schema={your_scheme}</code> ，来打开指定的页面了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> app </tag>
            
            <tag> native </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 的 4 个阶段的撤销更改</title>
      <link href="/2017/11/03/Git-%E7%9A%84-4-%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E6%92%A4%E9%94%80%E6%9B%B4%E6%94%B9/"/>
      <url>/2017/11/03/Git-%E7%9A%84-4-%E4%B8%AA%E9%98%B6%E6%AE%B5%E7%9A%84%E6%92%A4%E9%94%80%E6%9B%B4%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-误操作救命篇一：-如何将改动撤销？"><a href="#Git-误操作救命篇一：-如何将改动撤销？" class="headerlink" title="Git 误操作救命篇一： 如何将改动撤销？"></a><a href="https://zhuanlan.zhihu.com/p/42929114" target="_blank" rel="noopener">Git 误操作救命篇一： 如何将改动撤销？</a></h2><p>虽然git诞生距今已有12年之久，网上各种关于git的介绍文章数不胜数，但是依然有很多人（包括我自己在内）对于它的功能不能完全掌握。以下的介绍只是基于我个人对于git的理解，并且可能生编硬造了一些不完全符合git说法的词语。目的只是为了让git通俗化，使初学者也能大概了解如何快速上手git。同时，下面所有讨论，我们都假设只使用一个分支，也就是主分支master的情况，虽然这种作法并不符合git规范，但是现实情况中绝大部分用户是直接在master分支上进行工作的，所以在这里我们不去引入更加复杂的各种分支的情况，也不涉及标签tag的操作，只讲在最简单的主分支上如何回退。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h1><h2 id="3个步骤"><a href="#3个步骤" class="headerlink" title="3个步骤"></a><strong>3个步骤</strong></h2><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwzsRUe3nJiclZIHpg0Mc2EYjcdSxicXjJSJDs9bOYlNEHbwJZzibibQxKpg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>正常情况下，我们的工作流就是3个步骤，对应上图中的3个箭头线：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  git add .</span><br><span class="line">  </span><br><span class="line">  git commit -m &quot;comment&quot;</span><br><span class="line">  </span><br><span class="line">  git push</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">git add .把所有文件放入暂存区；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">git commit把所有文件从暂存区提交进本地仓库；</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">git push把所有文件从本地仓库推送进远程仓库。</span><br></pre></td></tr></table></figure></p><h2 id="4个区"><a href="#4个区" class="headerlink" title="4个区"></a><strong>4个区</strong></h2><p>git之所以令人费解，主要是它相比于svn等等传统的版本管理工具，多引入了一个暂存区(Stage)的概念，就因为多了这一个概念，而使很多人疑惑。其实，在初学者来说，每个区具体怎么工作的，我们完全不需要关心，而只要知道有这么4个区就够了：</p><ul><li><p>工作区(Working Area)</p></li><li><p>暂存区(Stage)</p></li><li><p>本地仓库(Local Repository)</p></li><li><p>远程仓库(Remote Repository)</p></li></ul><h2 id="5种状态"><a href="#5种状态" class="headerlink" title="5种状态"></a><strong>5种状态</strong></h2><p>以上4个区，进入每一个区成功之后会产生一个状态，再加上最初始的一个状态，一共是5种状态。以下我们把这5种状态分别命名为：</p><ul><li><p>未修改(Origin)</p></li><li><p>已修改(Modified)</p></li><li><p>已暂存(Staged)</p></li><li><p>已提交(Committed)</p></li><li><p>已推送(Pushed)</p></li></ul><h1 id="检查修改"><a href="#检查修改" class="headerlink" title="检查修改"></a><strong>检查修改</strong></h1><p>了解了基本概念之后，我们来谈一谈犯错误之后如何撤销的问题。首先，我们要了解如何检查这3个步骤当中每一个步骤修改了什么，然后才好判断有没有修改成功。检查修改的二级命令都相同，都是diff，只是参数有所不同。</p><h2 id="已修改，未暂存"><a href="#已修改，未暂存" class="headerlink" title="已修改，未暂存"></a><strong>已修改，未暂存</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>首先，我们来看一下，如果我们只是简单地在浏览器里保存了一下文件，但是还没有做git add .之前，我们如何检查有哪些修改。我们先随便拿一个文件来做一下实验：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwDg9nsy9V0Ra5nMdBquNG1HpYFaOazjo6vl1LPHJpjMia8ibicSXu0Svyw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>我们在文件开头的第2行胡乱加了4个数字1234，存盘，这时文件进入了已修改状态，但是还没有进入暂存区，我们运行git diff，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/index.md b/index.md</span><br><span class="line"></span><br><span class="line">index 73ff1ba..1066758 100644</span><br><span class="line"></span><br><span class="line">--- a/index.md</span><br><span class="line"></span><br><span class="line">+++ b/index.md</span><br><span class="line"></span><br><span class="line">@@ -1,5 +1,5 @@</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">-layout: main</span><br><span class="line"></span><br><span class="line">+1234layout: main</span><br><span class="line"></span><br><span class="line">color: black</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>git diff的结果告诉我们哪些文件已经做了哪些修改。</p><p><strong>已暂存，未提交</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure></p><p>现在我们把修改放入暂存区看一下。先执行git add .，然后执行git diff，你会发现没有任何结果：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwXwBzS1lToMWWjy9lEibicoiaibAAAaZa1HCp2j6v52OTN1cjRDia7VTVE6w/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>这说明git diff这个命令只检查我们的工作区和暂存区之间的差异，如果我们想看到暂存区和本地仓库之间的差异，就需要加一个参数git diff –cached：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/index.md b/index.md</span><br><span class="line"></span><br><span class="line">index 73ff1ba..1066758 100644</span><br><span class="line"></span><br><span class="line">--- a/index.md</span><br><span class="line"></span><br><span class="line">+++ b/index.md</span><br><span class="line"></span><br><span class="line">@@ -1,5 +1,5 @@</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">-layout: main</span><br><span class="line"></span><br><span class="line">+1234layout: main</span><br><span class="line"></span><br><span class="line">color: black</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><p>这时候我们看到的差异是暂存区和本地仓库之间的差异。</p><p><strong>已提交，未推送</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff master origin/master</span><br></pre></td></tr></table></figure></p><p>现在，我们把修改从暂存区提交到本地仓库，再看一下差异。先执行git commit，然后再执行git diff –cached，没有差异，执行git diff master origin/master，可以看到差异：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwNSkuZnLBptQUSBddcyOZURahoMau6Rq0cebaYVniaudrh3kXToVj6WA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>在这里，master就是你的本地仓库，而origin/master就是你的远程仓库，master是主分支的意思，因为我们都在主分支上工作，所以这里两边都是master，而origin就代表远程。</p><h1 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a><strong>撤销修改</strong></h1><p>了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。</p><h2 id="已修改，未暂存-1"><a href="#已修改，未暂存-1" class="headerlink" title="已修改，未暂存"></a><strong>已修改，未暂存</strong></h2><p>如果我们只是在编辑器里修改了文件，但还没有执行git add .，这时候我们的文件还在工作区，并没有进入暂存区，我们可以用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> git checkout .</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">  git reset --hard</span><br></pre></td></tr></table></figure></p><p>来进行撤销操作。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnw3vn4WgIpIIyGGweDCXuZzlhpOwS62ibmJNjwviaXsCp9bwshpI9KAKBQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><p>可以看到，在执行完git checkout .之后，修改已被撤销，git diff没有任何内容了。</p><blockquote><p>一对反义词 git add .的反义词是git checkout .。做完修改之后，如果你想向前走一步，让修改进入暂存区，就执行git add .，如果你想向后退一步，撤销刚才的修改，就执行git checkout .。</p></blockquote><h2 id="已暂存，未提交"><a href="#已暂存，未提交" class="headerlink" title="已暂存，未提交"></a><strong>已暂存，未提交</strong></h2><p>你已经执行了git add .，但还没有执行git commit -m “comment”。这时候你意识到了错误，想要撤销，你可以执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset</span><br><span class="line"></span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard</span><br></pre></td></tr></table></figure></p><p>git reset只是把修改退回到了git add .之前的状态，也就是说文件本身还处于已修改未暂存状态，你如果想退回未修改状态，还需要执行git checkout .。</p><p>或许你已经注意到了，以上两个步骤都可以用同一个命令git reset –hard来完成。是的，就是这个强大的命令，可以一步到位地把你的修改完全恢复到未修改的状态。</p><p><strong>已提交，未推送</strong></p><p>你的手太快，你既执行了git add .，又执行了git commit，这时候你的代码已经进入了你的本地仓库，然而你后悔了，怎么办？不要着急，还有办法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure></p><p>还是这个git reset –hard命令，只不过这次多了一个参数origin/master，正如我们上面讲过的，origin/master代表远程仓库，既然你已经污染了你的本地仓库，那么就从远程仓库把代码取回来吧。</p><p><strong>已推送</strong></p><p>很不幸，你的手实在是太快了，你既git add了，又git commit了，并且还git push了，这时你的代码已经进入远程仓库。如果你想恢复的话，还好，由于你的本地仓库和远程仓库是等价的，你只需要先恢复本地仓库，再强制push到远程仓库就好了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line"></span><br><span class="line">git push -f</span><br></pre></td></tr></table></figure></p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9aPYe0E1fb1el0zsnhYXiadWS9DtUkHnwCtsdla2FrJ4nCjP0tBssNeB7ZqBkQON4Jcxb2ghrAUEibNa2icoiaB3cg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt=""></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>以上4种状态的撤销我们都用到了同一个命令git reset –hard，前2种状态的用法甚至完全一样，所以只要掌握了git reset –hard这个命令的用法，从此你再也不用担心提交错误了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从Vue.js源码看nextTick机制</title>
      <link href="/2017/10/29/%E4%BB%8EVue-js%E6%BA%90%E7%A0%81%E7%9C%8BnextTick%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/10/29/%E4%BB%8EVue-js%E6%BA%90%E7%A0%81%E7%9C%8BnextTick%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://link.zhihu.com/?target=https%3A//chuckliu.me/%23%21/posts/58bd08a2b5187d2fb51c04f9" target="_blank" rel="noopener">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></p><h2 id="可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。"><a href="#可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。" class="headerlink" title="可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。"></a>可能会有理解存在偏差的地方，欢迎大神斧正，共同学习，共同进步。</h2><h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>在使用vue.js的时候，有时候因为一些特定的业务场景，不得不去操作DOM，比如这样：</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt;    &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;export default {    data () {        return {            test: &apos;begin&apos;        };    },    methods () {        handleClick () {            this.test = &apos;end&apos;;            console.log(this.$refs.test.innerText);//打印“begin”        }    }}</code></pre><p>打印的结果是begin，为什么我们明明已经将test设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“begin”呢？</p><h2 id="Watcher队列"><a href="#Watcher队列" class="headerlink" title="Watcher队列"></a>Watcher队列</h2><p>带着疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。</p><pre><code>update () {    /* istanbul ignore else */    if (this.lazy) {        this.dirty = true    } else if (this.sync) {        /*同步则执行run直接渲染视图*/        this.run()    } else {        /*异步推送到观察者队列中，下一个tick时调用。*/        queueWatcher(this)    }}</code></pre><p>我们发现Vue.js默认是使用<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fguide%252Freactivity.html%2523%25E5%25BC%2582%25E6%25AD%25A5%25E6%259B%25B4%25E6%2596%25B0%25E9%2598%259F%25E5%2588%2597" target="_blank" rel="noopener">异步执行DOM更新</a>。<br>当异步执行update的时候，会调用queueWatcher函数。</p><pre><code>/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/export function queueWatcher (watcher: Watcher) {  /*获取watcher的id*/  const id = watcher.id  /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/  if (has[id] == null) {    has[id] = true    if (!flushing) {      /*如果没有flush掉，直接push到队列中即可*/      queue.push(watcher)    } else {      // if already flushing, splice the watcher based on its id      // if already past its id, it will be run next immediately.      let i = queue.length - 1      while (i &gt;= 0 &amp;&amp; queue[i].id &gt; watcher.id) {        i--      }      queue.splice(Math.max(i, index) + 1, 0, watcher)    }    // queue the flush    if (!waiting) {      waiting = true      nextTick(flushSchedulerQueue)    }  }}</code></pre><p>查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</p><p>那么，什么是下一个tick？</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>vue.js提供了一个<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fapi%252F%2523Vue-nextTick" target="_blank" rel="noopener">nextTick</a>函数，其实也就是上面调用的nextTick。</p><p>nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion，看一下源码：</p><pre><code>/** * Defer a task to execute it asynchronously. */ /*    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function    这个函数的作用是在task或者microtask中推入一个timerFunc，    在当前调用栈执行完以后以此执行直到执行到timerFunc    目的是延迟到当前调用栈执行完以后执行*/export const nextTick = (function () {  /*存放异步执行的回调*/  const callbacks = []  /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/  let pending = false  /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/  let timerFunc  /*下一个tick时的回调*/  function nextTickHandler () {    /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/    pending = false    /*执行所有callback*/    const copies = callbacks.slice(0)    callbacks.length = 0    for (let i = 0; i &lt; copies.length; i++) {      copies[i]()    }  }  // the nextTick behavior leverages the microtask queue, which can be accessed  // via either native Promise.then or MutationObserver.  // MutationObserver has wider support, however it is seriously bugged in  // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It  // completely stops working after triggering a few times... so, if native  // Promise is available, we will use it:  /* istanbul ignore if */  /*    这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法    优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。    如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。    参考：https://www.zhihu.com/question/55364497  */  if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) {    /*使用Promise*/    var p = Promise.resolve()    var logError = err =&gt; { console.error(err) }    timerFunc = () =&gt; {      p.then(nextTickHandler).catch(logError)      // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but      // it can get stuck in a weird state where callbacks are pushed into the      // microtask queue but the queue isn&apos;t being flushed, until the browser      // needs to do some other work, e.g. handle a timer. Therefore we can      // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.      if (isIOS) setTimeout(noop)    }  } else if (typeof MutationObserver !== &apos;undefined&apos; &amp;&amp; (    isNative(MutationObserver) ||    // PhantomJS and iOS 7.x    MutationObserver.toString() === &apos;[object MutationObserverConstructor]&apos;  )) {    // use MutationObserver where native Promise is not available,    // e.g. PhantomJS IE11, iOS7, Android 4.4    /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/    var counter = 1    var observer = new MutationObserver(nextTickHandler)    var textNode = document.createTextNode(String(counter))    observer.observe(textNode, {      characterData: true    })    timerFunc = () =&gt; {      counter = (counter + 1) % 2      textNode.data = String(counter)    }  } else {    // fallback to setTimeout    /* istanbul ignore next */    /*使用setTimeout将回调推入任务队列尾部*/    timerFunc = () =&gt; {      setTimeout(nextTickHandler, 0)    }  }  /*    推送到队列中下一个tick时执行    cb 回调函数    ctx 上下文  */  return function queueNextTick (cb?: Function, ctx?: Object) {    let _resolve    /*cb存到callbacks中*/    callbacks.push(() =&gt; {      if (cb) {        try {          cb.call(ctx)        } catch (e) {          handleError(e, ctx, &apos;nextTick&apos;)        }      } else if (_resolve) {        _resolve(ctx)      }    })    if (!pending) {      pending = true      timerFunc()    }    if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) {      return new Promise((resolve, reject) =&gt; {        _resolve = resolve      })    }  }})()</code></pre><p>它是一个立即执行函数,返回一个queueNextTick接口。</p><p>传入的cb会被push进callbacks中存放起来，然后执行timerFunc（pending是一个状态标记，保证timerFunc在下一个tick之前只执行一次）。</p><p>timerFunc是什么？</p><p>看了源码发现timerFunc会检测当前环境而不同实现，其实就是按照Promise，MutationObserver，setTimeout优先级，哪个存在使用哪个，最不济的环境下使用setTimeout。</p><p>两者的具体实现</p><ul><li>macrotasks: setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染</li><li>microtasks: Promise， process.nextTick， Object.observe， MutationObserver</li></ul><p>再简单点可以总结为：<br><img src="https://pic1.zhimg.com/v2-e92a4f5f686d115832b63b9b9e3ac2cd_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-e92a4f5f686d115832b63b9b9e3ac2cd_hd.jpg" alt=""></p><ol><li>在 macrotask 队列中执行最早的那个 task ，然后移出</li><li>再执行 microtask 队列中所有可用的任务，然后移出</li><li><p>下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</p><p>  这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。</p><pre><code>优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。</code></pre></li></ol><p>为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到：</p><blockquote><p>  JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。<br>setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、   MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。<br>       要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。<br>       实在不行，只能用 setTimeout 创建 task 了。<br>       为啥要用 microtask？<br>       根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。<br>       反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</p></blockquote><p>首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调，</p><p>MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。</p><p>至于 MutationObserver 如何模拟 nextTick 这点，直接看源码，其实就是创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容：    var counter = 1</p><pre><code>var observer = new MutationObserver(nextTickHandler)    var textNode = document.createTextNode(String(counter))    observer.observe(textNode, {      characterData: true    })    timerFunc = () =&gt; {      counter = (counter + 1) % 2      textNode.data = String(counter)    }</code></pre><p>   setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行：</p><pre><code>setTimeout(function(){    console.log(&quot;我不是立即执行的,一般我会延时4ms,哈哈&quot;);},0);</code></pre><p>它会将回调函数加入task中，等到执行。<br><img src="https://pic2.zhimg.com/v2-59cf9f88d7daac690d39edfb9fffc8b8_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-59cf9f88d7daac690d39edfb9fffc8b8_hd.jpg" alt=""></p><pre><code>setTimeout(function(){console.log(4)},0);new Promise(function(resolve){    console.log(1)    for( var i=0 ; i&lt;10000 ; i++ ){        i==9999 &amp;&amp; resolve()    }    console.log(2)}).then(function(){    console.log(5)});console.log(3);结果是：1,2,3,5,4</code></pre><p>再看这个，两个自执行同时执行：</p><pre><code>&lt;script&gt;(function test() {  setTimeout(function () {    console.log(4)  }, 0);  new Promise(function executor (resolve) {    console.log(1);    for(var i = 0; i &lt; 10000; i++) {      i == 9999 &amp;&amp; resolve();    }    console.log(2);  }).then(function() {    console.log(5);  });  console.log(3);})()(function test2() {  setTimeout(function () {    console.log(42)  }, 0);  new Promise(function executor (resolve) {    console.log(12);    for(var i = 0; i &lt; 10000; i++) {      i == 9999 &amp;&amp; resolve();    }    console.log(22);  }).then(function() {    console.log(52);  });  console.log(32);})()&lt;/script&gt;</code></pre><p><img src="https://pic2.zhimg.com/v2-cd18c572eb05069895ede7e34388bb8d_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-cd18c572eb05069895ede7e34388bb8d_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-afcb6fa6fb862818359f757107b769ab_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-afcb6fa6fb862818359f757107b769ab_hd.jpg" alt=""><br>整个执行过程是一个 main thread 【<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com/link%3Furl%3DCV-egCVH8yK1w-ilUqGsztryG8s2mbuhAliIC_L1n_-BSZ_KJ16tAfaNkmbcRtU8" target="_blank" rel="noopener">主线程</a>】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的 <code>setTimeout</code> 进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。</p><pre><code>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：</code></pre><p>   1.先执行 macrotasks：I/O -》 UI渲染</p><p>   2.再执行 microtasks ：process.nextTick  -》 Promise  -》MutationObserver -&gt;Object.observe</p><p>   3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次：</p><p>setTimeout ，setInterval –》setImmediate</p><pre><code>  综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。setImmediate(function(){    console.log(1);},0);setTimeout(function(){    console.log(2);},0);new Promise(function(resolve){    console.log(3);    resolve();    console.log(4);}).then(function(){    console.log(5);});console.log(6);process.nextTick(function(){    console.log(7);});console.log(8);结果是：3 4 6 8 7 5 2 1</code></pre><h2 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h2><pre><code>/*Github:https://github.com/answershuto*//** * Flush both queues and run the watchers. */ /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/function flushSchedulerQueue () {  flushing = true  let watcher, id  // Sort queue before flush.  // This ensures that:  // 1. Components are updated from parent to child. (because parent is always  //    created before the child)  // 2. A component&apos;s user watchers are run before its render watcher (because  //    user watchers are created before the render watcher)  // 3. If a component is destroyed during a parent component&apos;s watcher run,  //    its watchers can be skipped.  /*    给queue排序，这样做可以保证：    1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。    2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建    3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。  */  queue.sort((a, b) =&gt; a.id - b.id)  // do not cache length because more watchers might be pushed  // as we run existing watchers  /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/  for (index = 0; index &lt; queue.length; index++) {    watcher = queue[index]    id = watcher.id    /*将has的标记删除*/    has[id] = null    /*执行watcher*/    watcher.run()    // in dev build, check and stop circular updates.    /*      在测试环境中，检测watch是否在死循环中      比如这样一种情况      watch: {        test () {          this.test++;        }      }      持续执行了一百次watch代表可能存在死循环    */    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) {      circular[id] = (circular[id] || 0) + 1      if (circular[id] &gt; MAX_UPDATE_COUNT) {        warn(          &apos;You may have an infinite update loop &apos; + (            watcher.user              ? `in watcher with expression &quot;${watcher.expression}&quot;`              : `in a component render function.`          ),          watcher.vm        )        break      }    }  }  // keep copies of post queues before resetting state  /**/  /*得到队列的拷贝*/  const activatedQueue = activatedChildren.slice()  const updatedQueue = queue.slice()  /*重置调度者的状态*/  resetSchedulerState()  // call component updated and activated hooks  /*使子组件状态都改编成active同时调用activated钩子*/  callActivatedHooks(activatedQueue)  /*调用updated钩子*/  callUpdateHooks(updatedQueue)  // devtool hook  /* istanbul ignore if */  if (devtools &amp;&amp; config.devtools) {    devtools.emit(&apos;flush&apos;)  }}</code></pre><p>flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图</p><h2 id="为什么要异步更新视图"><a href="#为什么要异步更新视图" class="headerlink" title="为什么要异步更新视图"></a>为什么要异步更新视图</h2><p>来看一下下面这一段代码</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;div&gt;{{test}}&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;export default {    data () {        return {            test: 0        };    },    created () {      for(let i = 0; i &lt; 1000; i++) {        this.test++;      }    }}</code></pre><p>现在有这样的一种情况，created的时候test的值会被++循环执行1000次。<br>每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。<br>如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。<br>所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。<br>保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</p><h2 id="访问真实DOM节点更新后的数据"><a href="#访问真实DOM节点更新后的数据" class="headerlink" title="访问真实DOM节点更新后的数据"></a>访问真实DOM节点更新后的数据</h2><p>所以我们需要在修改data中的数据后访问真实的DOM节点更新后的数据，只需要这样，我们把文章第一个例子进行修改。</p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt;    &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;export default {    data () {        return {            test: &apos;begin&apos;        };    },    methods () {        handleClick () {            this.test = &apos;end&apos;;            this.$nextTick(() =&gt; {                console.log(this.$refs.test.innerText);//打印&quot;end&quot;            });            console.log(this.$refs.test.innerText);//打印“begin”        }    }}</code></pre><p>使用Vue.js的global API的$nextTick方法，即可在回调中获取已经更新好的DOM实例了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> nextTick </tag>
            
            <tag> event loop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS网格布局（Grid）完全教程</title>
      <link href="/2017/10/28/CSS%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%EF%BC%88Grid%EF%BC%89%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2017/10/28/CSS%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80%EF%BC%88Grid%EF%BC%89%E5%AE%8C%E5%85%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="CSS网格布局（Grid）完全教程"><a href="#CSS网格布局（Grid）完全教程" class="headerlink" title="CSS网格布局（Grid）完全教程"></a><a href="https://www.zcfy.cc/article/learn-css-grid-a-guide-to-learning-css-grid-jonathan-suh" target="_blank" rel="noopener">CSS网格布局（Grid）完全教程</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Grid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue.js 父子组件通信的十种方式&amp;奇技淫巧</title>
      <link href="/2017/10/22/Vue-js-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8D%81%E7%A7%8D%E6%96%B9%E5%BC%8F&amp;%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
      <url>/2017/10/22/Vue-js-%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8D%81%E7%A7%8D%E6%96%B9%E5%BC%8F&amp;%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="面试官：Vue-中父子组件通信有哪些方式？"><a href="#面试官：Vue-中父子组件通信有哪些方式？" class="headerlink" title=" 面试官：Vue 中父子组件通信有哪些方式？"></a><strong> 面试官：Vue 中父子组件通信有哪些方式？</strong></h3><h4 id="vue组件通信全揭秘-共7章"><a href="#vue组件通信全揭秘-共7章" class="headerlink" title="  vue组件通信全揭秘(共7章) "></a><font color="#dd0000"> <strong> <a href="https://juejin.im/post/5bd97e7c6fb9a022852a71cf" target="_blank" rel="noopener">vue组件通信全揭秘(共7章)</a> </strong></font><br></h4><blockquote><p>几种通信方式无外乎以下几种：</p></blockquote><ul><li><code>Prop</code>（常用）</li><li><code>$emit</code> (组件封装用的较多)</li><li><code>.sync</code>语法糖 （较少）</li><li><code>$attrs</code> 和 <code>$listeners</code> (组件封装用的较多)</li><li><code>provide</code> 和 <code>inject</code> （高阶组件/组件库用的较多）</li><li>其他方式通信</li></ul><h3 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h3><p>英式发音：[prɒp]。这个在我们日常开发当中用到的非常多。简单来说，<strong>我们可以通过 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html%23%25E9%2580%259A%25E8%25BF%2587-Prop-%25E5%2590%2591%25E5%25AD%2590%25E7%25BB%2584%25E4%25BB%25B6%25E4%25BC%25A0%25E9%2580%2592%25E6%2595%25B0%25E6%258D%25AE" target="_blank" rel="noopener">Prop</a> 向子组件传递数据</strong>。用一个形象的比喻来说，父子组件之间的数据传递相当于自上而下的下水管子，只能从上往下流，不能逆流。这也正是 Vue 的设计理念之<a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents-props.html%23%25E5%258D%2595%25E5%2590%2591%25E6%2595%25B0%25E6%258D%25AE%25E6%25B5%2581" target="_blank" rel="noopener">单向数据流</a>。而 Prop 正是管道与管道之间的一个衔接口，这样水（数据）才能往下流。说这么多，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;divid=&quot;app&quot;&gt;</span><br><span class="line">    &lt;child:content=&quot;message&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">let Child = Vue.extend(&#123;</span><br><span class="line">  template: &apos;&lt;h2&gt;&#123;&#123; content &#125;&#125;&lt;/h2&gt;&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    content: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: () =&gt; &#123; return&apos;from child&apos; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;from parent&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from parent</span><br></pre></td></tr></table></figure><h3 id="emit"><a href="#emit" class="headerlink" title="$emit"></a>$emit</h3><p>英式发音：[iˈmɪt]。官方说法是<strong>触发当前实例上的事件。附加参数都会传给监听器回调</strong>。按照我的理解不知道能不能给大家说明白，先简单看下代码吧：</p><pre><code>&lt;divid=&quot;app&quot;&gt;    &lt;my-button @greet=&quot;sayHi&quot;&gt;&lt;/my-button&gt;&lt;/div&gt;let MyButton = Vue.extend({  template: &apos;&lt;button @click=&quot;triggerClick&quot;&gt;click&lt;/button&gt;&apos;,  data () {    return {      greeting: &apos;vue.js!&apos;    }  },  methods: {    triggerClick () {      this.$emit(&apos;greet&apos;, this.greeting)    }  }})new Vue({  el: &apos;#app&apos;,  components: {    MyButton  },  methods: {    sayHi (val) {      alert(&apos;Hi, &apos; + val)   // &apos;Hi, vue.js!&apos;    }  }})</code></pre><p> 大致逻辑是酱婶儿的：当我在页面上点击按钮时，触发了组件 <code>MyButton</code> 上的监听事件 <code>greet</code>，并且把参数传给了回调函数 <code>sayHi</code> 。说白了，当我们从子组件 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23vm-emit" target="_blank" rel="noopener">Emit</a>（派发） 一个事件之前，其内部都提前在事件队列中 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23vm-on" target="_blank" rel="noopener">On</a>（监听）了这个事件及其监听回调。其实相当于下面这种写法：</p><pre><code>vm.$on(&apos;greet&apos;, functionsayHi (val) {  console.log(&apos;Hi, &apos; + val)})vm.$emit(&apos;greet&apos;, &apos;vue.js&apos;)// =&gt; &quot;Hi, vue.js&quot;</code></pre><h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h3><p>这个家伙在 <a href="mailto:vue@1.x" target="_blank" rel="noopener">vue@1.x</a> 的时候曾作为双向绑定功能存在，即子组件可以修改父组件中的值。因为它违反了<a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents-props.html%23%25E5%258D%2595%25E5%2590%2591%25E6%2595%25B0%25E6%258D%25AE%25E6%25B5%2581" target="_blank" rel="noopener">单向数据流</a>的设计理念，所以在 <a href="mailto:vue@2.0" target="_blank" rel="noopener">vue@2.0</a> 的时候被干掉了。但是在 <a href="mailto:vue@2.3.0" target="_blank" rel="noopener">vue@2.3.0</a>+ 以上版本又重新引入了这个 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents-custom-events.html%23sync-%25E4%25BF%25AE%25E9%25A5%25B0%25E7%25AC%25A6" target="_blank" rel="noopener">.sync</a> 修饰符。但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。说白了就是让我们手动进行更新父组件中的值了，从而使数据改动来源更加的明显。下面引入自官方的一段话：</p><blockquote><p>在有些情况下，我们可能需要对一个 prop 进行“双向绑定”。不幸的是，真正的双向绑定会带来维护上的问题，因为子组件可以修改父组件，且在父组件和子组件都没有明显的改动来源。</p></blockquote><p>既然作为一个语法糖，肯定是某种写法的简写形式，哪种写法呢，看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;text-document</span><br><span class="line">  v-bind:title=&quot;doc.title&quot;</span><br><span class="line">  v-on:update:title=&quot;doc.title = $event&quot;&gt;</span><br><span class="line">&lt;/text-document&gt;</span><br></pre></td></tr></table></figure></p><p>于是我们可以用 <code>.sync</code> 语法糖简写成如下形式：</p><pre><code>&lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt;</code></pre><p>废话这么多，如何做到“双向绑定” 呢？让我们进段广告，广告之后更加精彩！<br>…<br>好的，欢迎回来。假如我们想实现这样一个效果：改变子组件文本框中的值同时改变父组件中的值。怎么做？列位不妨先想想。先看段代码：</p><pre><code>&lt;divid=&quot;app&quot;&gt;    &lt;login:name.sync=&quot;userName&quot;&gt;&lt;/login&gt;     {{ userName }}&lt;/div&gt;let Login = Vue.extend({  template: `    &lt;div class=&quot;input-group&quot;&gt;      &lt;label&gt;姓名:&lt;/label&gt;      &lt;input v-model=&quot;text&quot;&gt;    &lt;/div&gt;  `,  props: [&apos;name&apos;],  data () {    return {      text: &apos;&apos;    }  },  watch: {    text (newVal) {      this.$emit(&apos;update:name&apos;, newVal)    }  }})new Vue({  el: &apos;#app&apos;,  data: {    userName: &apos;&apos;  },  components: {    Login  }})</code></pre><p>下面划重点，代码里有这一句话：</p><pre><code>this.$emit(&apos;update:name&apos;, newVal)</code></pre><p>官方语法是：<code>update:myPropName</code> 其中 <code>myPropName</code> 表示要更新的 prop 值。当然如果你不用 .sync 语法糖使用上面的 .$emit 也能达到同样的效果。仅此而已！</p><h3 id="attrs-和-listeners"><a href="#attrs-和-listeners" class="headerlink" title="$attrs 和 $listeners"></a><code>$attrs</code> 和 <code>$listeners</code></h3><ul><li>官网对 <code>$attrs</code> 的解释如下：</li></ul><blockquote><p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (<code>class</code> 和 <code>style</code> 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (<code>class</code> 和 <code>style</code> 除外)，并且可以通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件——在创建高级别的组件时非常有用。</p></blockquote><ul><li>官网对 <code>$listeners</code> 的解释如下：</li></ul><blockquote><p>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</p></blockquote><p>我觉得 <code>$attrs</code> 和 <code>$listeners</code> 属性像两个收纳箱，一个负责收纳属性，一个负责收纳事件，都是以对象的形式来保存数据。看下面的代码解释：</p><pre><code>&lt;divid=&quot;app&quot;&gt;    &lt;child:foo=&quot;foo&quot;:bar=&quot;bar&quot;        @one.native=&quot;triggerOne&quot;        @two=&quot;triggerTwo&quot;&gt;    &lt;/child&gt;&lt;/div&gt;</code></pre><p>从 Html 中可以看到，这里有俩属性和俩方法，区别是属性一个是 <code>prop</code> 声明，事件一个是 <code>.native</code> 修饰器。</p><pre><code>let Child = Vue.extend({  template: &apos;&lt;h2&gt;{{ foo }}&lt;/h2&gt;&apos;,  props: [&apos;foo&apos;],  created () {    console.log(this.$attrs, this.$listeners)    // -&gt; {bar: &quot;parent bar&quot;}    // -&gt; {two: fn}    // 这里我们访问父组件中的 `triggerTwo` 方法    this.$listeners.two()    // -&gt; &apos;two&apos;  }})new Vue({  el: &apos;#app&apos;,  data: {    foo: &apos;parent foo&apos;,    bar: &apos;parent bar&apos;  },  components: {    Child  },  methods: {    triggerOne () {      alert(&apos;one&apos;)    },    triggerTwo () {      alert(&apos;two&apos;)    }  }})</code></pre><p>可以看到，我们可以通过 <code>$attrs</code> 和 <code>$listeners</code> 进行数据传递，在需要的地方进行调用和处理，还是很方便的。当然，我们还可以通过 <code>v-on=&quot;$listeners&quot;</code> 一级级的往下传递，子子孙孙无穷尽也！</p><p>一个插曲！</p><p>当我们在组件上赋予了一个非Prop 声明时，编译之后的代码会把这些个属性都当成原始属性对待，添加到 html 原生标签上，看上面的代码编译之后的样子：</p><pre><code>&lt;h2 bar=&quot;parent bar&quot;&gt;parent foo&lt;/h2&gt;</code></pre><p>这样会很难看，同时也爆了某些东西。如何去掉？这正是 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23inheritAttrs" target="_blank" rel="noopener">inheritAttrs</a> 属性的用武之地！给组件加上这个属性就行了，一般是配合 <code>$attrs</code> 使用。看代码：</p><pre><code>// 源码let Child = Vue.extend({  ...  inheritAttrs: false, // 默认是 true  ...})</code></pre><p>再次编译：</p><pre><code>&lt;h2&gt;parent foo&lt;/h2&gt;</code></pre><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a><code>provide</code> / <code>inject</code></h3><p>他俩是对CP, 感觉挺神秘的。来看下官方对 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23provide-inject" target="_blank" rel="noopener">provide / inject</a> 的描述：</p><blockquote><p><code>provide</code> 和 <code>inject</code> 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。并且这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。</p></blockquote><p>看完描述有点懵懵懂懂！一句话总结就是：小时候你老爸什么东西都先帮你存着等你长大该娶媳妇儿了你要房子给你买要车给你买只要他有的尽量都会满足你。下面是这句话的代码解释：</p><pre><code>&lt;divid=&quot;app&quot;&gt;    &lt;son&gt;&lt;/son&gt;&lt;/div&gt;let Son = Vue.extend({  template: &apos;&lt;h2&gt;son&lt;/h2&gt;&apos;,  inject: {    house: {      default: &apos;没房&apos;    },    car: {      default: &apos;没车&apos;    },    money: {      // 长大工作了虽然有点钱// 仅供生活费，需要向父母要default: &apos;￥4500&apos;    }  },  created () {    console.log(this.house, this.car, this.money)    // -&gt; &apos;房子&apos;, &apos;车子&apos;, &apos;￥10000&apos;  }})new Vue({  el: &apos;#app&apos;,  provide: {    house: &apos;房子&apos;,    car: &apos;车子&apos;,    money: &apos;￥10000&apos;  },  components: {    Son  }})</code></pre><h3 id="其他方式通信"><a href="#其他方式通信" class="headerlink" title="其他方式通信"></a>其他方式通信</h3><p>除了以上五种方式外，其实还有：</p><ul><li><strong>EventBus</strong></li></ul><p>思路就是声明一个全局Vue实例变量 <code>EventBus</code> , 把所有的通信数据，事件监听都存储到这个变量上。这样就达到在组件间数据共享了，有点类似于 <a href="https://link.juejin.im?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2Fguide%2F" target="_blank" rel="noopener">Vuex</a>。但这种方式只适用于极小的项目，复杂项目还是推荐 Vuex。下面是实现 EventBus 的简单代码：</p><pre><code>&lt;divid=&quot;app&quot;&gt;   &lt;child&gt;&lt;/child&gt;&lt;/div&gt;// 全局变量let EventBus = new Vue()// 子组件let Child = Vue.extend({  template: &apos;&lt;h2&gt;child&lt;/h2&gt;&apos;,  created () {    console.log(EventBus.message)    // -&gt; &apos;hello&apos;    EventBus.$emit(&apos;received&apos;, &apos;from child&apos;)  }})new Vue({  el: &apos;#app&apos;,  components: {    Child  },  created () {    // 变量保存    EventBus.message = &apos;hello&apos;// 事件监听    EventBus.$on(&apos;received&apos;, function (val) {      console.log(&apos;received: &apos;+ val)      // -&gt; &apos;received: from child&apos;    })  }})</code></pre><ul><li><strong>Vuex</strong></li></ul><p>官方推荐的，Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。</p><ul><li><strong>$parent</strong></li></ul><p>父实例，如果当前实例有的话。通过访问父实例也能进行数据之间的交互，但极小情况下会直接修改父组件中的数据。</p><ul><li><strong>$root</strong></li></ul><p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。通过访问根组件也能进行数据之间的交互，但极小情况下会直接修改父组件中的数据。</p><ul><li><strong>broadcast / dispatch</strong></li></ul><p>他俩是 <a href="mailto:vue@1.0" target="_blank" rel="noopener">vue@1.0</a> 中的方法，分别是事件广播 和 事件派发。虽然 <a href="mailto:vue@2.0" target="_blank" rel="noopener">vue@2.0</a> 里面删掉了，但可以模拟这两个方法。可以借鉴 <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement%2Fblob%2F1.x%2Fsrc%2Fmixins%2Femitter.js%23L14" target="_blank" rel="noopener">Element</a> 实现。有时候还是非常有用的，比如我们在开发树形组件的时候等等。</p><hr><h2 id="给-props-属性设置多个类型"><a href="#给-props-属性设置多个类型" class="headerlink" title="给 props 属性设置多个类型"></a>给 props 属性设置多个类型</h2><p>这个技巧在开发组件的时候用的较多，为了更大的容错性考虑。比如一个 <code>&lt;my-button&gt;</code> 上暴露了一个 <code>width</code> 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// my-button.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    width: [String, Number],</span><br><span class="line">    default: &apos;100px&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们既可以传 <code>100px</code>，也可以传 <code>100</code> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- my-button.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button :style=&quot;computedWidth&quot;&gt;width: &#123;&#123; computedWidth &#125;&#125;&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      width: [String, Number],</span><br><span class="line">      default: &apos;100px&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      computedWidth () &#123;</span><br><span class="line">        let o = &#123;&#125;</span><br><span class="line">        if (typeof this.width === &apos;string&apos;) o.width = this.width</span><br><span class="line">        if (typeof this.width === &apos;number&apos;) o.width = this.width + &apos;px&apos;</span><br><span class="line">        return o</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在其他组件中使用 --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;my-button width=&quot;100px&quot;&gt;&lt;/my-button&gt;</span><br><span class="line">  &lt;!-- or --&gt;</span><br><span class="line">  &lt;my-button width=&quot;100&quot;&gt;&lt;/my-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h2 id="data-初始化"><a href="#data-初始化" class="headerlink" title="data 初始化"></a><strong>data</strong> 初始化</h2><p>因为 <code>props</code> 要比 <code>data</code> 先完成初始化，所以我们可以利用这一点给 <code>data</code> 初始化一些数据进去，看代码：</p><pre><code>export default {  data () {    return {      buttonSize: this.size    }  }, props: {   size: String }}</code></pre><p>除了以上，子组件的 <code>data</code> 函数也可以有参数，且该参数是当前实例对象。所有我们可以利用这一点做一些自己的判断。如，改写上面的代码：</p><pre><code>export default {  data (vm) {    return {      buttonSize: vm.size    }  }, props: {   size: String }}</code></pre><h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>我们在做 <code>v-if</code> 判断的时候，可以把判断条件放在 <code>template</code> 组件上，<a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fconditional.html%23%25E5%259C%25A8-lt-template-gt-%25E5%2585%2583%25E7%25B4%25A0%25E4%25B8%258A%25E4%25BD%25BF%25E7%2594%25A8-v-if-%25E6%259D%25A1%25E4%25BB%25B6%25E6%25B8%25B2%25E6%259F%2593%25E5%2588%2586%25E7%25BB%2584" target="_blank" rel="noopener">最终</a>的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;template v-if=&quot;isVal&quot;&gt;</span><br><span class="line">      &lt;h2&gt;...&lt;/h2&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">    &lt;template v-else&gt;</span><br><span class="line">      &lt;h2&gt;...&lt;/h2&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p><code>v-for</code> 也同样适用。</p><h2 id="Lifecycle-hook"><a href="#Lifecycle-hook" class="headerlink" title="Lifecycle hook"></a>Lifecycle hook</h2><p>生命周期钩子可以是一个数组类型，且数组中的函数会依次执行。</p><pre><code>export default { ... created: [   function one () {     console.log(1)   },   function two () {     console.log(2)   } ] ...}</code></pre><p>没什么用，知道就行了。事实上生命周期钩子还可以作用于 DOM 元素上，利用这一点，我们可以用父组件中的方法来初始化子组件的生命周期钩子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Child.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h3&gt;I&apos;m child!&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Parent.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">   &lt;child @hook:created=&quot;handleChildCreated&quot;&gt;&lt;/child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">   import Child from &apos;./child.vue&apos;</span><br><span class="line">   export default &#123;</span><br><span class="line">     components: [ Child ],</span><br><span class="line">     methods: &#123;</span><br><span class="line">       handleChildCreated () &#123;</span><br><span class="line">         console.log(&apos;handle child created...&apos;)</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其他钩子雷同，不再赘述。</p><h2 id="v-for-和-v-if-一起使用"><a href="#v-for-和-v-if-一起使用" class="headerlink" title="v-for 和 v-if 一起使用"></a>v-for 和 v-if 一起使用</h2><p>由于 <code>v-for</code> 比 <code>v-if</code> 渲染优先级更高，所以有时候可以一起使用。下面两种常见的情况下会倾向于把 <code>v-for</code> 和 <code>v-if</code> 放在同一个标签上使用：</p><ul><li>筛选一些不想显示的条目</li><li>为了避免渲染本应该被隐藏的列表</li></ul><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ul class=&quot;items&quot;&gt;</span><br><span class="line">    &lt;!-- 只有激活的用户才可以显示 --&gt;</span><br><span class="line">    &lt;li v-for=&quot;(user, index) in users&quot; v-if=&quot;user.isActive&quot; :key=&quot;user.id&quot;&gt;&#123;&#123; user.name &#125;&#125;&lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>关于以上两点不明白的地方可以参见 <a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fstyle-guide%2F%23%25E9%2581%25BF%25E5%2585%258D-v-if-%25E5%2592%258C-v-for-%25E7%2594%25A8%25E5%259C%25A8%25E4%25B8%2580%25E8%25B5%25B7-%25E5%25BF%2585%25E8%25A6%2581" target="_blank" rel="noopener">Vue 风格指南</a>。</p><h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>如果好多组件都共用到一些像 <code>props</code>、<code>data</code>、<code>methods</code> 等，可以单独抽出来放到 <code>mixins</code> 混合器中。</p><pre><code>// paging-mixin.vueexport default {  props: {    pageSize: 1,    pageLength: 10,    currentPage: 1    total: 20  },  methods: {    /**     * 上一页     */    prevPage (page) {      ...    },    /**     * 下一页     */    nextPage (page) {      ...    }    /**     * 跳转到当前页     */    currentPage (page) {      ...    }  }}</code></pre><p>比如在用户管理列表使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Users.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;user-model&quot;&gt;</span><br><span class="line">    &lt;my-table :data=&quot;users&quot;&gt;&lt;/my-table&gt;</span><br><span class="line">    &lt;my-paging</span><br><span class="line">      :page-length=&quot;pageLength&quot;</span><br><span class="line">      :page-size=&quot;pageSize&quot;</span><br><span class="line">      :current-page=&quot;currentPage&quot;</span><br><span class="line">      :total=&quot;total&quot;&gt;</span><br><span class="line">    &lt;/my-paging&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import PagingMixin from &apos;../mixins/paging-mixin.vue&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mixins: [PagingMixin],</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        users: [],</span><br><span class="line">        pageLength: 10,</span><br><span class="line">        pageSize: 1,</span><br><span class="line">        currentPage: 1,</span><br><span class="line">        total: 20</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>不用每个页面都写一遍 <code>props</code> 和 <code>methods</code> 了。</p><h2 id="render-函数"><a href="#render-函数" class="headerlink" title="render 函数"></a>render 函数</h2><p>下面是一段简单的 template 模板代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;h2&gt;title&lt;/h2&gt;</span><br><span class="line">    this is content</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>我们用<a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Frender-function.html" target="_blank" rel="noopener">渲染函数</a>来重写上面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    let _c = h</span><br><span class="line">    return _c(&apos;div&apos;, </span><br><span class="line">      &#123; class: &apos;box&apos;&#125;, </span><br><span class="line">      [_c(&apos;h2&apos;, &#123;&#125;, &apos;title&apos;), &apos;this is content&apos;])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，Vue 会把模板(template)编译成渲染函数(render) 。上面的 template 模板会被编译成如下渲染函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let render = function () &#123;</span><br><span class="line">  return _c(&apos;div&apos;,</span><br><span class="line">    &#123;staticClass:&quot;box&quot;&#125;,</span><br><span class="line">    [_c(&apos;h2&apos;, [_v(&quot;title&quot;)]), _v(&quot;this is content&quot;)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很像？ 正如官方说的，<strong>渲染函数比 template 更接近编译器</strong>。如果用一个流程图来解释的话，大概是这个样子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template</span><br><span class="line">    ↓</span><br><span class="line">预编译工具（vue-loader + vue-template-compile）</span><br><span class="line">    ↓</span><br><span class="line">  render</span><br><span class="line">    ↓</span><br><span class="line">resolve vnode</span><br></pre></td></tr></table></figure></p><p>具体参见 <code>Vue声明周期图示</code> </p><p>渲染函数用处：</p><ul><li>开发组件库，Element 源码用的都是 render</li><li>封装一些高阶组件。组件里面嵌套组件就是高阶组件，前提是要满足组件三要素：<code>props</code>、<code>event</code>、<code>slot</code></li><li>用于处理一些复杂的逻辑判断。如果我们一个组件里面有很多的 <code>v-if</code> 判断的话，用模板就显得不合适了，这个时候可以用渲染函数来轻松处理</li></ul><h2 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h2><p>捕获一个来自子孙组件的错误时被调用。有时候当我们想收集错误日志，却不想把错误暴露到浏览器控制台的时候很有用。下面是个例子：</p><p><code>Child.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 省略一些无关代码 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      // 故意把 console 写错</span><br><span class="line">      consol.log(&apos;这里会报错！&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><code>Parent.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;child&gt;&lt;/child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import Child from &apos;./Child.vue&apos;</span><br><span class="line">  export default &#123;</span><br><span class="line">    components: [ Child ],</span><br><span class="line">    /**</span><br><span class="line">     * 收到三个参数：</span><br><span class="line">     * 错误对象、发生错误的组件实例</span><br><span class="line">     * 以及一个包含错误来源信息的字符串。</span><br><span class="line">     * 此钩子可以返回 false 以阻止该错误继续向上传播。</span><br><span class="line">     */</span><br><span class="line">    errorCaptured (err, vm, info) &#123;</span><br><span class="line">      console.log(err)</span><br><span class="line">      // -&gt; ReferenceError: consle is not defined ...</span><br><span class="line">      console.log(vm)</span><br><span class="line">      // -&gt; &#123;_uid: 1, _isVue: true, $options: &#123;…&#125;, _renderProxy: o, _self: o,…&#125;</span><br><span class="line">      console.log(info)</span><br><span class="line">      // -&gt; `mounted hook`</span><br><span class="line">      // 告诉我们这个错误是在 vm 组件中的 mounted 钩子中发生的</span><br><span class="line">      </span><br><span class="line">      // 阻止该错误继续向上传播</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>关于 errorCaptured 更多说明，请<a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23errorCaptured" target="_blank" rel="noopener">移步官网-&gt;</a> 。</p><h2 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h2><p>通过 <code>v-once</code> 创建低开销的静态组件。渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 <code>v-once</code> 特性以确保这些内容只计算一次然后缓存起来，就像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; v-once&gt;</span><br><span class="line">    &lt;h2&gt; 用户协议 &lt;/h2&gt;</span><br><span class="line">    ... a lot of static content ...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。关于 <code>v-once</code> 更多介绍，请<a href="https://link.juejin.im?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23v-once" target="_blank" rel="noopener">移步官网-&gt;</a>。</p><h2 id="slot-scope"><a href="#slot-scope" class="headerlink" title="slot-scope"></a>slot-scope</h2><p>作用域插槽。<a href="mailto:`vue@2.5.0" target="_blank" rel="noopener">`vue@2.5.0</a><code>版本以前叫</code>scope<code>，之后的版本用</code>slot-scope<code>将其代替。除了 scope 只可以用于</code><template><code>元素，其它和</code>slot-scope` 都相同。</template></p><p>用过 Element 组件的同学都知道，当我们在使用 <a href="https://link.juejin.im?target=http%3A%2F%2Felement-cn.eleme.io%2F2.4%2F%23%2Fzh-CN%2Fcomponent%2Ftable%23zi-ding-yi-lie-mo-ban" target="_blank" rel="noopener"><code>&lt;el-table&gt;</code></a> 的时候会看到如下代码：</p><p><a href="mailto:Element@1.4.x" target="_blank" rel="noopener">Element@1.4.x</a> 的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;操作&quot;&gt;</span><br><span class="line">  &lt;template scope=&quot;scope&quot;&gt;</span><br><span class="line">  &lt;el-button</span><br><span class="line">    size=&quot;small&quot;</span><br><span class="line">    @click=&quot;handleEdit(scope.$index, scope.row)&quot;&gt;编辑&lt;/el-button&gt;</span><br><span class="line">  &lt;el-button</span><br><span class="line">    size=&quot;small&quot;</span><br><span class="line">    type=&quot;danger&quot;</span><br><span class="line">    @click=&quot;handleDelete(scope.$index, scope.row)&quot;&gt;删除&lt;/el-button&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>但在 2.0 之后的版本替换成了 <code>slot-scope</code>。</p><p><a href="mailto:Element@2.0.11" target="_blank" rel="noopener">Element@2.0.11</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-table-column label=&quot;操作&quot;&gt;</span><br><span class="line">  &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">    &lt;el-button</span><br><span class="line">      size=&quot;mini&quot;</span><br><span class="line">      @click=&quot;handleEdit(scope.$index, scope.row)&quot;&gt;编辑&lt;/el-button&gt;</span><br><span class="line">    &lt;el-button</span><br><span class="line">      size=&quot;mini&quot;</span><br><span class="line">      type=&quot;danger&quot;</span><br><span class="line">      @click=&quot;handleDelete(scope.$index, scope.row)&quot;&gt;删除&lt;/el-button&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/el-table-column&gt;</span><br></pre></td></tr></table></figure><p>说白了，<code>slot-scope</code> 相当于函数的回调，我把结果给你，你想怎么处理就怎么处理，一切随你：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getUserById (url, data, callback) &#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url,</span><br><span class="line">    data,</span><br><span class="line">    success: function (result) &#123;</span><br><span class="line">      callback(result)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用</span><br><span class="line">getUserById(&apos;/users&apos;, &#123; id: 1 &#125;, function (response) &#123;</span><br><span class="line">  // 拿到数据并开始处理自己的页面逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>下面我们来简单模拟下 <code>&lt;el-table&gt;</code> 组件内部是怎么使用 <code>slot-scope</code> 的，看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 定义模板</span><br><span class="line">let template = `</span><br><span class="line"> &lt;ul class=&quot;table&quot;&gt;</span><br><span class="line">  &lt;li v-for=&quot;(item, index) in data&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">    &lt;!-- 我希望数据由调用者自己处理 --&gt;</span><br><span class="line">    &lt;!-- &apos;row&apos; 相当于变量名，随便起名 --&gt;</span><br><span class="line">    &lt;slot :row=&quot;item&quot;&gt;</span><br><span class="line">      &lt;!-- 当使用者什么都没写的时候，默认值才会显示--&gt;</span><br><span class="line">      &#123;&#123; item.name &#125;&#125;</span><br><span class="line">    &lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line">`</span><br><span class="line">// 声明 `el-table` 组件</span><br><span class="line">Vue.component(&apos;el-table&apos;, &#123;</span><br><span class="line">  template,</span><br><span class="line">  props: &#123;</span><br><span class="line">    data: Array,</span><br><span class="line">    default: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 根组件</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    userData: [</span><br><span class="line">      &#123;id: 1, name: &apos;张三&apos;, isActived: false&#125;,</span><br><span class="line">      &#123;id: 2, name: &apos;李四&apos;, isActived: false&#125;,</span><br><span class="line">      &#123;id: 1, name: &apos;王五&apos;, isActived: true&#125;,</span><br><span class="line">      &#123;id: 1, name: &apos;赵六&apos;, isActived: false&#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;el-table :data=&quot;userData&quot;&gt;</span><br><span class="line">    &lt;!-- 使用的时候可以用 template --&gt;</span><br><span class="line">    &lt;!-- `scope` 只是个形参，随便起名 --&gt;</span><br><span class="line">    &lt;template slot-scope=&quot;scope&quot;&gt;</span><br><span class="line">      &lt;template v-if=&quot;scope.row.isActived&quot;&gt;</span><br><span class="line">        &lt;span class=&quot;red&quot;&gt;&#123;&#123; scope.row.name &#125;&#125;&lt;/span&gt;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">      &lt;template v-else&gt;</span><br><span class="line">        &#123;&#123; scope.row.name &#125;&#125;</span><br><span class="line">      &lt;/template&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">  &lt;/el-table&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">CSS：</span><br><span class="line"></span><br><span class="line">.red &#123;</span><br><span class="line">  color: red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们完全可以在 <code>&lt;li&gt;</code> 中进行逻辑判断，为什么还要放到外面进行处理呢？ 因为有时候我们用的不是自己开发的组件，比如上面的 <code>&lt;el-table&gt;</code> ，所以就有必要这么做了。最后，你可以狠狠的<a href="https://link.juejin.im?target=https%3A%2F%2Fcodepen.io%2Fgongph%2Fpen%2FPxbqyP" target="_blank" rel="noopener">戳这里</a>查看效果！</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试之Vue.$nextTick原理</title>
      <link href="/2017/10/21/%E9%9D%A2%E8%AF%95%E4%B9%8BVue-nextTick%E5%8E%9F%E7%90%86/"/>
      <url>/2017/10/21/%E9%9D%A2%E8%AF%95%E4%B9%8BVue-nextTick%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="面试官-Vue的nextTick是怎么监听DOM树更新完毕的？"><a href="#面试官-Vue的nextTick是怎么监听DOM树更新完毕的？" class="headerlink" title="面试官:Vue的nextTick是怎么监听DOM树更新完毕的？"></a>面试官:Vue的nextTick是怎么监听DOM树更新完毕的？</h2><p>nextTick是全局vue的一个函数，在vue系统中，用于处理dom更新的操作。vue里面有一个watcher，用于观察数据的变化，然后更新dom，vue里面并不是每次数据改变都会触发更新dom，而是将这些操作都缓存在一个队列，在一个事件循环结束之后，刷新队列，统一执行dom更新操作。 </p><p>通常情况下，我们不需要关心这个问题，而如果想在DOM状态更新后做点什么，则需要用到nextTick。在vue生命周期的created()钩子函数进行的DOM操作要放在Vue.nextTick()的回调函数中，因为created()钩子函数执行的时候DOM并未进行任何渲染，而此时进行DOM操作是徒劳的，所以此处一定要将DOM操作的JS代码放进Vue.nextTick()的回调函数中。而与之对应的mounted钩子函数，该钩子函数执行时所有的DOM挂载和渲染都已完成，此时该钩子函数进行任何DOM操作都不会有个问题。 </p><p><code>Vue.nextTick(callback)</code>，当数据发生变化，更新后执行回调。</p><p><code>Vue.$nextTick(callback)</code>，当dom发生变化，更新后执行的回调。</p><hr><p>废话少说，来看一个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;span id=&apos;name&apos; ref=&apos;name&apos;&gt;&#123;&#123; name &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;button @click=&apos;change&apos;&gt;change name&lt;/button&gt;</span><br><span class="line">  &lt;div id=&apos;content&apos;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        name: &apos;SHERlocked93&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      change() &#123;</span><br><span class="line">        const $name = this.$refs.name</span><br><span class="line">        this.$nextTick(() =&gt; console.log(&apos;setter前：&apos; + $name.innerHTML))</span><br><span class="line">        this.name = &apos; name改喽 &apos;</span><br><span class="line">        console.log(&apos;同步方式：&apos; + this.$refs.name.innerHTML)</span><br><span class="line">        setTimeout(() =&gt; this.console(&quot;setTimeout方式：&quot; + this.$refs.name.innerHTML))</span><br><span class="line">        this.$nextTick(() =&gt; console.log(&apos;setter后：&apos; + $name.innerHTML))</span><br><span class="line">        this.$nextTick().then(() =&gt; console.log(&apos;Promise方式：&apos; + $name.innerHTML))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>执行以下看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同步方式：SHERlocked93 </span><br><span class="line">setter前：SHERlocked93 </span><br><span class="line">setter后：name改喽 </span><br><span class="line">Promise方式：name改喽 </span><br><span class="line">setTimeout方式：name改喽</span><br></pre></td></tr></table></figure></p><hr><p>再看一段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div ref=&quot;text&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;button @click=&quot;handleClick&quot;&gt;text&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            text: &apos;start&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods () &#123;</span><br><span class="line">        handleClick () &#123;</span><br><span class="line">            this.text = &apos;end&apos;;</span><br><span class="line">            console.log(this.$refs.text.innerText);//打印“start”</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果是start，为什么明明已经将text设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“start”呢？</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>带着这个疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。</p><h3 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">      调度者接口，当依赖发生改变的时候进行回调。</span><br><span class="line">   */</span><br><span class="line">  update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">    /*同步则执行run直接渲染视图*/</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    /*异步推送到观察者队列中，由调度者调用。*/</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们发现Vue.js默认是使用异步执行DOM更新。<br>当异步执行update的时候，会调用queueWatcher函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Push a watcher into the watcher queue.</span><br><span class="line"> * Jobs with duplicate IDs will be skipped unless it&apos;s</span><br><span class="line"> * pushed when the queue is being flushed.</span><br><span class="line"> **/</span><br><span class="line"> /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/</span><br><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">    /*获取watcher的id*/</span><br><span class="line">  const id = watcher.id</span><br><span class="line">   /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">    /*如果没有flush掉，直接push到队列中即可*/</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // if already flushing, splice the watcher based on its id</span><br><span class="line">      // if already past its id, it will be run next immediately.</span><br><span class="line">      let i = queue.length - 1</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    // queue the flush</span><br><span class="line">    // 刷新队列</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true</span><br><span class="line"></span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。</p><h3 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/observer/scheduler.js</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Flush both queues and run the watchers.</span><br><span class="line"> */</span><br><span class="line">  /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/</span><br><span class="line">function flushSchedulerQueue () &#123;</span><br><span class="line">  flushing = true</span><br><span class="line">  let watcher, id</span><br><span class="line"></span><br><span class="line">  // Sort queue before flush.</span><br><span class="line">  // This ensures that:</span><br><span class="line">  // 1. Components are updated from parent to child. (because parent is always</span><br><span class="line">  //    created before the child)</span><br><span class="line">  // 2. A component&apos;s user watchers are run before its render watcher (because</span><br><span class="line">  //    user watchers are created before the render watcher)</span><br><span class="line">  // 3. If a component is destroyed during a parent component&apos;s watcher run,</span><br><span class="line">  //    its watchers can be skipped.</span><br><span class="line">  /*</span><br><span class="line">    刷新前给queue排序，这样做可以保证：</span><br><span class="line">    1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。</span><br><span class="line">    2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建</span><br><span class="line">    3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。</span><br><span class="line">  */</span><br><span class="line">  queue.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line"></span><br><span class="line">  // do not cache length because more watchers might be pushed</span><br><span class="line">  // as we run existing watchers</span><br><span class="line">  /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，</span><br><span class="line">  因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/</span><br><span class="line">  for (index = 0; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    if (watcher.before) &#123;</span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id</span><br><span class="line">     /*将has的标记删除*/</span><br><span class="line">    has[id] = null</span><br><span class="line">     /*执行watcher*/</span><br><span class="line">    watcher.run()</span><br><span class="line">    // in dev build, check and stop circular updates.</span><br><span class="line">    /*</span><br><span class="line">      在测试环境中，检测watch是否在死循环中</span><br><span class="line">      比如这样一种情况</span><br><span class="line">      watch: &#123;</span><br><span class="line">        test () &#123;</span><br><span class="line">          this.test++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      持续执行了一百次watch代表可能存在死循环</span><br><span class="line">    */</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; has[id] != null) &#123;</span><br><span class="line">      circular[id] = (circular[id] || 0) + 1</span><br><span class="line">      if (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;You may have an infinite update loop &apos; + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? `in watcher with expression &quot;$&#123;watcher.expression&#125;&quot;`</span><br><span class="line">              : `in a component render function.`</span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        break</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // keep copies of post queues before resetting state</span><br><span class="line">  /*得到队列的拷贝*/</span><br><span class="line">  const activatedQueue = activatedChildren.slice()</span><br><span class="line">  const updatedQueue = queue.slice()</span><br><span class="line">  /*重置调度者的状态*/</span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  // call component updated and activated hooks</span><br><span class="line">  /*使子组件状态都改编成active同时调用activated钩子*/</span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  /*调用updated钩子*/</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">  // devtool hook</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(&apos;flush&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图</p><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>vue.js提供了一个nextTick函数，其实也就是上面调用的nextTick。</p><p>nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion。</p><p>网上很多文章讨论的nextTick实现是2.4版本以下的实现，2.5以上版本对于nextTick的内部实现进行了大量的修改，看一下源码：</p><p>首先是从Vue 2.5+开始，抽出来了一个单独的文件next-tick.js来执行它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue/src/core/util/next-tick.js</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line">    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function</span><br><span class="line">    这个函数的作用是在task或者microtask中推入一个timerFunc，</span><br><span class="line">    在当前调用栈执行完以后以此执行直到执行到timerFunc</span><br><span class="line">    目的是延迟到当前调用栈执行完以后执行</span><br><span class="line">*/</span><br><span class="line">/*存放异步执行的回调*/</span><br><span class="line">const callbacks = []</span><br><span class="line">/*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/</span><br><span class="line">let pending = false</span><br><span class="line"></span><br><span class="line">/*下一个tick时的回调*/</span><br><span class="line">function flushCallbacks () &#123;</span><br><span class="line">/*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/</span><br><span class="line">  pending = false</span><br><span class="line">  //复制callback</span><br><span class="line">  const copies = callbacks.slice(0)</span><br><span class="line">  //清除callbacks</span><br><span class="line">  callbacks.length = 0</span><br><span class="line">  for (let i = 0; i &lt; copies.length; i++) &#123;</span><br><span class="line">  //触发callback的回调函数</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Here we have async deferring wrappers using both microtasks and (macro) tasks.</span><br><span class="line">// In &lt; 2.4 we used microtasks everywhere, but there are some scenarios where</span><br><span class="line">// microtasks have too high a priority and fire in between supposedly</span><br><span class="line">// sequential events (e.g. #4521, #6690) or even between bubbling of the same</span><br><span class="line">// event (#6566). However, using (macro) tasks everywhere also has subtle problems</span><br><span class="line">// when state is changed right before repaint (e.g. #6813, out-in transitions).</span><br><span class="line">// Here we use microtask by default, but expose a way to force (macro) task when</span><br><span class="line">// needed (e.g. in event handlers attached by v-on).</span><br><span class="line">/**</span><br><span class="line">其大概的意思就是：在Vue2.4之前的版本中，nextTick几乎都是基于microTask实现的，</span><br><span class="line">但是由于microTask的执行优先级非常高，在某些场景之下它甚至要比事件冒泡还要快，</span><br><span class="line">就会导致一些诡异的问题；但是如果全部都改成macroTask，对一些有重绘和动画的场</span><br><span class="line">景也会有性能的影响。所以最终nextTick采取的策略是默认走microTask，对于一些DOM</span><br><span class="line">的交互事件，如v-on绑定的事件回调处理函数的处理，会强制走macroTask。</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">let microTimerFunc</span><br><span class="line">let macroTimerFunc</span><br><span class="line">let useMacroTask = false</span><br><span class="line"></span><br><span class="line">// Determine (macro) task defer implementation.</span><br><span class="line">// Technically setImmediate should be the ideal choice, but it&apos;s only available</span><br><span class="line">// in IE. The only polyfill that consistently queues the callback after all DOM</span><br><span class="line">// events triggered in the same loop is by using MessageChannel.</span><br><span class="line">/* istanbul ignore if */</span><br><span class="line">/**</span><br><span class="line">而对于macroTask的执行，Vue优先检测是否支持原生setImmediate（高版本IE和Edge支持），</span><br><span class="line">不支持的话再去检测是否支持原生MessageChannel，如果还不支持的话为setTimeout(fn, 0)。</span><br><span class="line">**/</span><br><span class="line"></span><br><span class="line">if (typeof setImmediate !== &apos;undefined&apos; &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else if (typeof MessageChannel !== &apos;undefined&apos; &amp;&amp; ( </span><br><span class="line">// MessageChannel与原先的MutationObserver异曲同工</span><br><span class="line">/**</span><br><span class="line">在Vue 2.4版本以前使用的MutationObserver来模拟异步任务。</span><br><span class="line">而Vue 2.5版本以后，由于兼容性弃用了MutationObserver。</span><br><span class="line">Vue 2.5+版本使用了MessageChannel来模拟macroTask。</span><br><span class="line">除了IE以外，messageChannel的兼容性还是比较可观的。</span><br><span class="line">**/</span><br><span class="line">  isNative(MessageChannel) ||</span><br><span class="line">  // PhantomJS</span><br><span class="line">  MessageChannel.toString() === &apos;[object MessageChannelConstructor]&apos;</span><br><span class="line">)) &#123;</span><br><span class="line">  /**</span><br><span class="line">  可见，新建一个MessageChannel对象，该对象通过port1来检测信息，port2发送信息。</span><br><span class="line">  通过port2的主动postMessage来触发port1的onmessage事件，</span><br><span class="line">  进而把回调函数flushCallbacks作为macroTask参与事件循环。</span><br><span class="line">  **/</span><br><span class="line">  const channel = new MessageChannel()</span><br><span class="line">  const port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    port.postMessage(1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  /* istanbul ignore next */</span><br><span class="line">   //上面两种都不支持，用setTimeout</span><br><span class="line">  macroTimerFunc = () =&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Determine microtask defer implementation.</span><br><span class="line">/* istanbul ignore next, $flow-disable-line */</span><br><span class="line"></span><br><span class="line">if (typeof Promise !== &apos;undefined&apos; &amp;&amp; isNative(Promise)) &#123;</span><br><span class="line">/*使用Promise*/</span><br><span class="line">  const p = Promise.resolve()</span><br><span class="line">  microTimerFunc = () =&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    // in problematic UIWebViews, Promise.then doesn&apos;t completely break, but</span><br><span class="line">    // it can get stuck in a weird state where callbacks are pushed into the</span><br><span class="line">    // microtask queue but the queue isn&apos;t being flushed, until the browser</span><br><span class="line">    // needs to do some other work, e.g. handle a timer. Therefore we can</span><br><span class="line">    // &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span><br><span class="line">    //iOS的webview下，需要强制刷新队列，执行上面的回调函数</span><br><span class="line">    if (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // fallback to macro</span><br><span class="line">  microTimerFunc = macroTimerFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Wrap a function so that if any code inside triggers state change,</span><br><span class="line"> * the changes are queued using a (macro) task instead of a microtask.</span><br><span class="line"> */</span><br><span class="line"> /**</span><br><span class="line"> 在Vue执行绑定的DOM事件时，默认会给回调的handler函数调用withMacroTask方法做一层包装，</span><br><span class="line"> 它保证整个回调函数的执行过程中，遇到数据状态的改变，这些改变而导致的视图更新（DOM更新）</span><br><span class="line"> 的任务都会被推到macroTask而不是microtask。</span><br><span class="line"> **/</span><br><span class="line">export function withMacroTask (fn: Function): Function &#123;</span><br><span class="line">  return fn._withTask || (fn._withTask = function () &#123;</span><br><span class="line">    useMacroTask = true</span><br><span class="line">    const res = fn.apply(null, arguments)</span><br><span class="line">    useMacroTask = false</span><br><span class="line">    return res</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> /*</span><br><span class="line">    推送到队列中下一个tick时执行</span><br><span class="line">    cb 回调函数</span><br><span class="line">    ctx 上下文</span><br><span class="line">  */</span><br><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">   /*cb存到callbacks中*/</span><br><span class="line">  callbacks.push(() =&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &apos;nextTick&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending = true</span><br><span class="line">    if (useMacroTask) &#123;</span><br><span class="line">      macroTimerFunc()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      microTimerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !== &apos;undefined&apos;) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MessageChannel-VS-setTimeout"><a href="#MessageChannel-VS-setTimeout" class="headerlink" title="MessageChannel VS setTimeout"></a>MessageChannel VS setTimeout</h3><p>为什么要优先MessageChannel创建macroTask而不是setTimeout？</p><p><strong> <font color="#dd0000">HTML5中规定setTimeout的最小时间延迟是4ms，也就是说理想环境下异步回调最快也是4ms才能触发。</font> </strong></p><p>Vue使用这么多函数来模拟异步任务，其目的只有一个，就是让回调异步且尽早调用。而MessageChannel的延迟明显是小于setTimeout的。</p><p>说了这么多，到底什么是macrotasks，什么是microtasks呢？</p><h5 id="两者的具体实现"><a href="#两者的具体实现" class="headerlink" title="两者的具体实现"></a>两者的具体实现</h5><p><strong>macrotasks：</strong></p><blockquote><font color="#dd0000">setTimeout ，setInterval， setImmediate，requestAnimationFrame, I/O ，UI渲染</font></blockquote><p><strong>microtasks:</strong></p><blockquote><font color="#dd0000">Promise， process.nextTick， Object.observe， MutationObserver</font></blockquote><p><strong>1.在 macrotask 队列中执行最早的那个 task ，然后移出</strong></p><p><strong>2.再执行 microtask 队列中所有可用的任务，然后移出</strong></p><p><strong>3.下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步)</strong></p><p>那我们上面提到的任务队列到底是什么呢？跟macrotasks和microtasks有什么联系呢？</p><p>• 一个事件循环有一个或者多个任务队列；</p><p>• 每个事件循环都有一个microtask队列；</p><p>• macrotask队列就是我们常说的任务队列，microtask队列不是任务队列；</p><p>• 一个任务可以被放入到macrotask队列，也可以放入microtask队列；</p><p>• 当一个任务被放入microtask或者macrotask队列后，准备工作就已经结束，这时候可以开始执行任务了。</p><p>可见，setTimeout和Promises不是同一类的任务，处理方式应该会有区别，具体的处理方式有什么不同呢？ </p><p>通俗的解释一下，microtasks的作用是用来调度应在当前执行的脚本执行结束后立即执行的任务。 例如响应事件、或者异步操作，以避免付出额外的一个task的费用。</p><p>microtask会在两种情况下执行：</p><p>任务队列(macrotask = task queue)回调后执行，前提条件是当前没有其他执行中的代码。<br>每个task末尾执行。<br>另外在处理microtask期间，如果有新添加的microtasks，也会被添加到队列的末尾并执行。</p><p>也就是说执行顺序是：</p><p>开始 -&gt; 取task queue第一个task执行 -&gt; 取microtask全部任务依次执行 -&gt; 取task queue下一个任务执行 -&gt; 再次取出microtask全部任务执行 -&gt; … 这样循环往复</p><p>Promise一旦状态置为完成态，便为其回调(.then内的函数)安排一个microtask。</p><p>接下来我们看回我们上面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">&#125;,0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    for( var i=100000 ; i&gt;0 ; i-- )&#123;</span><br><span class="line">        i==1 &amp;&amp; resolve()</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(5);</span><br></pre></td></tr></table></figure><p>按照上面的规则重新分析一遍：</p><p>当运行到setTimeout时，会把setTimeout的回调函数console.log(1)放到任务队列里去，然后继续向下执行。</p><p>接下来会遇到一个Promise。首先执行打印console.log(2)，然后执行for循环，即时for循环要累加到10万，也是在执行栈里面，等待for循环执行完毕以后，将Promise的状态从fulfilled切换到resolve，随后把要执行的回调函数，也就是then里面的console.log(4)推到microtask里面去。接下来马上执行马上console.log(3)。</p><p>然后出Promise，还剩一个同步的console.log(5)，直接打印。这样第一轮下来，已经依次打印了2，3，5。</p><p>现在第一轮任务队列已经执行完毕，没有正在执行的代码。符合上面讲的microtask执行条件，因此会将microtask中的任务优先执行，因此执行console.log(4)</p><p>最后还剩macrotask里的setTimeout放入的函数console.log(1)最后执行。</p><p>如此分析输出顺序是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>我们再来看一个：</p><p>当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候：</p><p><strong> 1.先执行 macrotasks：I/O -》 UI渲染 </strong></p><p><strong> 2.再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver -&gt;Object.observe </strong></p><p><strong> 3.再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次： setTimeout ，setInterval –》setImmediate </strong></p><p>综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(function()&#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;,0);</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;,0);</span><br><span class="line">new Promise(function(resolve)&#123;</span><br><span class="line">    console.log(3);</span><br><span class="line">    resolve();</span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;).then(function()&#123;</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(6);</span><br><span class="line">process.nextTick(function()&#123;</span><br><span class="line">    console.log(7);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(8);</span><br><span class="line">结果是：3 4 6 8 7 5 2 1</span><br></pre></td></tr></table></figure><h3 id="使用了nextTick异步更新视图有什么好处呢？"><a href="#使用了nextTick异步更新视图有什么好处呢？" class="headerlink" title="使用了nextTick异步更新视图有什么好处呢？"></a>使用了nextTick异步更新视图有什么好处呢？</h3><p>接下来我们看一下一个Demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            test: 0</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    created () &#123;</span><br><span class="line">      for(let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        this.test++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有这样的一种情况，created的时候test的值会被++循环执行1000次。<br>每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。<br>如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。<br>所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。<br>保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> nextTick </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>19 个 JavaScript 有用的简写技术</title>
      <link href="/2017/10/11/19-%E4%B8%AA-JavaScript-%E6%9C%89%E7%94%A8%E7%9A%84%E7%AE%80%E5%86%99%E6%8A%80%E6%9C%AF/"/>
      <url>/2017/10/11/19-%E4%B8%AA-JavaScript-%E6%9C%89%E7%94%A8%E7%9A%84%E7%AE%80%E5%86%99%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-三元操作符"><a href="#1-三元操作符" class="headerlink" title="1.三元操作符"></a>1.三元操作符</h2><p>当想写if…else语句时，使用三元操作符来代替。</p><pre><code>const x = 20;let answer;if (x &gt; 10) {    answer = &apos;is greater&apos;;} else {    answer = &apos;is lesser&apos;;}</code></pre><p>简写：<br><code>const answer = x &gt; 10 ? &#39;is greater&#39; : &#39;is lesser&#39;;</code></p><p>也可以嵌套if语句：<br><code>const big = x &gt; 10 ? &quot; greater 10&quot; : x</code></p><h2 id="2-短路求值简写方式"><a href="#2-短路求值简写方式" class="headerlink" title="2.短路求值简写方式"></a>2.短路求值简写方式</h2><p>当给一个变量分配另一个值时，想确定源始值不是null，undefined或空值。可以写撰写一个多重条件的if语句。</p><pre><code>if (variable1 !== null || variable1 !== undefined || variable1 !== &apos;&apos;) {     let variable2 = variable1;}</code></pre><p>或者可以使用短路求值方法：<br><code>const variable2 = variable1 || &#39;new&#39;;</code></p><h2 id="3-声明变量简写方法"><a href="#3-声明变量简写方法" class="headerlink" title="3.声明变量简写方法"></a>3.声明变量简写方法</h2><pre><code>let x;let y;let z = 3;</code></pre><p>简写方法：<br><code>let x, y, z=3;</code></p><h2 id="4-if存在条件简写方法"><a href="#4-if存在条件简写方法" class="headerlink" title="4.if存在条件简写方法"></a>4.if存在条件简写方法</h2><p><code>if (likeJavaScript === true)</code></p><p>简写：<br><code>if (likeJavaScript)</code></p><p>只有likeJavaScript是真值时，二者语句才相等</p><p>如果判断值不是真值，则可以这样：</p><pre><code>let a;if ( a !== true ) {// do something...}</code></pre><p>简写：</p><pre><code>let a;if ( !a ) {// do something...}</code></pre><h2 id="5-JavaScript循环简写方法"><a href="#5-JavaScript循环简写方法" class="headerlink" title="5.JavaScript循环简写方法"></a>5.JavaScript循环简写方法</h2><p><code>for (let i = 0; i &lt; allImgs.length; i++)</code></p><p>简写：<br><code>for (let index in allImgs)</code><br>也可以使用Array.forEach：</p><pre><code>function logArrayElements(element, index, array) {  console.log(&quot;a[&quot; + index + &quot;] = &quot; + element);}[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 9</code></pre><h2 id="6-短路评价"><a href="#6-短路评价" class="headerlink" title="6.短路评价"></a>6.短路评价</h2><p>给一个变量分配的值是通过判断其值是否为null或undefined，则可以：</p><pre><code>let dbHost;if (process.env.DB_HOST) {  dbHost = process.env.DB_HOST;} else {  dbHost = &apos;localhost&apos;;}</code></pre><p>简写：<br><code>const dbHost = process.env.DB_HOST || &#39;localhost&#39;;</code></p><h2 id="7-十进制指数"><a href="#7-十进制指数" class="headerlink" title="7.十进制指数"></a>7.十进制指数</h2><p>当需要写数字带有很多零时（如10000000），可以采用指数（1e7）来代替这个数字：<br><code>for (let i = 0; i &lt; 10000; i++) {}</code><br>简写：</p><pre><code>for (let i = 0; i &lt; 1e7; i++) {}// 下面都是返回true1e0 === 1;1e1 === 10;1e2 === 100;1e3 === 1000;1e4 === 10000;1e5 === 100000;</code></pre><h2 id="8-对象属性简写"><a href="#8-对象属性简写" class="headerlink" title="8.对象属性简写"></a>8.对象属性简写</h2><p>如果属性名与key名相同，则可以采用ES6的方法：<br><code>const obj = { x:x, y:y };</code></p><p>简写：<br><code>const obj = { x, y };</code></p><h2 id="9-箭头函数简写"><a href="#9-箭头函数简写" class="headerlink" title="9.箭头函数简写"></a>9.箭头函数简写</h2><p>传统函数编写方法很容易让人理解和编写，但是当嵌套在另一个函数中，则这些优势就荡然无存。</p><pre><code>function sayHello(name) {  console.log(&apos;Hello&apos;, name);}setTimeout(function() {  console.log(&apos;Loaded&apos;)}, 2000);list.forEach(function(item) {  console.log(item);});</code></pre><p>简写：</p><pre><code>sayHello = name =&gt; console.log(&apos;Hello&apos;, name);setTimeout(() =&gt; console.log(&apos;Loaded&apos;), 2000);list.forEach(item =&gt; console.log(item));</code></pre><h2 id="10-隐式返回值简写"><a href="#10-隐式返回值简写" class="headerlink" title="10.隐式返回值简写"></a>10.隐式返回值简写</h2><p>经常使用return语句来返回函数最终结果，一个单独语句的箭头函数能隐式返回其值（函数必须省略{}为了省略return关键字）</p><p>为返回多行语句（例如对象字面表达式），则需要使用()包围函数体。</p><pre><code>function calcCircumference(diameter) {  return Math.PI * diameter}var func = function func() {  return { foo: 1 };};</code></pre><p>简写：</p><pre><code>calcCircumference = diameter =&gt; (  Math.PI * diameter;)var func = () =&gt; ({ foo: 1 });</code></pre><h2 id="11-默认参数值"><a href="#11-默认参数值" class="headerlink" title="11.默认参数值"></a>11.默认参数值</h2><p>为了给函数中参数传递默认值，通常使用if语句来编写，但是使用ES6定义默认值，则会很简洁：</p><pre><code>function volume(l, w, h) {  if (w === undefined)    w = 3;  if (h === undefined)    h = 4;  return l * w * h;}</code></pre><p>简写：</p><pre><code>volume = (l, w = 3, h = 4 ) =&gt; (l * w * h);volume(2) //output: 24</code></pre><h2 id="12-模板字符串"><a href="#12-模板字符串" class="headerlink" title="12.模板字符串"></a>12.模板字符串</h2><p>传统的JavaScript语言，输出模板通常是这样写的。</p><pre><code>const welcome = &apos;You have logged in as &apos; + first + &apos; &apos; + last + &apos;.&apos;const db = &apos;http://&apos; + host + &apos;:&apos; + port + &apos;/&apos; + database;</code></pre><p>ES6可以使用反引号和${}简写：</p><pre><code>const welcome = `You have logged in as ${first} ${last}`;const db = `http://${host}:${port}/${database}`;</code></pre><h2 id="13-解构赋值简写方法"><a href="#13-解构赋值简写方法" class="headerlink" title="13.解构赋值简写方法"></a>13.解构赋值简写方法</h2><p>在web框架中，经常需要从组件和API之间来回传递数组或对象字面形式的数据，然后需要解构它</p><pre><code>const observable = require(&apos;mobx/observable&apos;);const action = require(&apos;mobx/action&apos;);const runInAction = require(&apos;mobx/runInAction&apos;);const store = this.props.store;const form = this.props.form;const loading = this.props.loading;const errors = this.props.errors;const entity = this.props.entity;</code></pre><p>简写：</p><pre><code>import { observable, action, runInAction } from &apos;mobx&apos;;const { store, form, loading, errors, entity } = this.props;</code></pre><p>也可以分配变量名：</p><pre><code>const { store, form, loading, errors, entity:contact } = this.props;//最后一个变量名为contact</code></pre><h2 id="14-多行字符串简写"><a href="#14-多行字符串简写" class="headerlink" title="14.多行字符串简写"></a>14.多行字符串简写</h2><p>需要输出多行字符串，需要使用+来拼接：</p><pre><code>const lorem = &apos;Lorem ipsum dolor sit amet, consectetur\n\t&apos;    + &apos;adipisicing elit, sed do eiusmod tempor incididunt\n\t&apos;    + &apos;ut labore et dolore magna aliqua. Ut enim ad minim\n\t&apos;    + &apos;veniam, quis nostrud exercitation ullamco laboris\n\t&apos;    + &apos;nisi ut aliquip ex ea commodo consequat. Duis aute\n\t&apos;    + &apos;irure dolor in reprehenderit in voluptate velit esse.\n\t&apos;</code></pre><p>使用反引号，则可以达到简写作用：</p><pre><code>const lorem = `Lorem ipsum dolor sit amet, consectetur    adipisicing elit, sed do eiusmod tempor incididunt    ut labore et dolore magna aliqua. Ut enim ad minim    veniam, quis nostrud exercitation ullamco laboris    nisi ut aliquip ex ea commodo consequat. Duis aute    irure dolor in reprehenderit in voluptate velit esse.`</code></pre><h2 id="15-扩展运算符简写"><a href="#15-扩展运算符简写" class="headerlink" title="15.扩展运算符简写"></a>15.扩展运算符简写</h2><p>扩展运算符有几种用例让JavaScript代码更加有效使用，可以用来代替某个数组函数。</p><pre><code>// joining arraysconst odd = [1, 3, 5];const nums = [2 ,4 , 6].concat(odd);// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = arr.slice()</code></pre><p>简写：</p><pre><code>// joining arraysconst odd = [1, 3, 5 ];const nums = [2 ,4 , 6, ...odd];console.log(nums); // [ 2, 4, 6, 1, 3, 5 ]// cloning arraysconst arr = [1, 2, 3, 4];const arr2 = [...arr];</code></pre><p>不像concat()函数，可以使用扩展运算符来在一个数组中任意处插入另一个数组。</p><pre><code>const odd = [1, 3, 5 ];const nums = [2, ...odd, 4 , 6];</code></pre><p>也可以使用扩展运算符解构：</p><pre><code>const { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 };console.log(a) // 1console.log(b) // 2console.log(z) // { c: 3, d: 4 }</code></pre><h2 id="16-强制参数简写"><a href="#16-强制参数简写" class="headerlink" title="16.强制参数简写"></a>16.强制参数简写</h2><p>JavaScript中如果没有向函数参数传递值，则参数为undefined。为了增强参数赋值，可以使用if语句来抛出异常，或使用强制参数简写方法。</p><pre><code>function foo(bar) {  if(bar === undefined) {    throw new Error(&apos;Missing parameter!&apos;);  }  return bar;}</code></pre><p>简写：</p><pre><code>mandatory = () =&gt; {  throw new Error(&apos;Missing parameter!&apos;);}foo = (bar = mandatory()) =&gt; {  return bar;}</code></pre><h2 id="17-Array-find简写"><a href="#17-Array-find简写" class="headerlink" title="17.Array.find简写"></a>17.Array.find简写</h2><p>想从数组中查找某个值，则需要循环。在ES6中，find()函数能实现同样效果。</p><pre><code>const pets = [  { type: &apos;Dog&apos;, name: &apos;Max&apos;},  { type: &apos;Cat&apos;, name: &apos;Karl&apos;},  { type: &apos;Dog&apos;, name: &apos;Tommy&apos;},]function findDog(name) {  for(let i = 0; i&lt;pets.length; ++i) {    if(pets[i].type === &apos;Dog&apos; &amp;&amp; pets[i].name === name) {      return pets[i];    }  }}</code></pre><p>简写：</p><pre><code>pet = pets.find(pet =&gt; pet.type ===&apos;Dog&apos; &amp;&amp; pet.name === &apos;Tommy&apos;);console.log(pet); // { type: &apos;Dog&apos;, name: &apos;Tommy&apos; }</code></pre><h2 id="18-Object-key-简写"><a href="#18-Object-key-简写" class="headerlink" title="18.Object[key]简写"></a>18.Object[key]简写</h2><p>考虑一个验证函数</p><pre><code>function validate(values) {  if(!values.first)    return false;  if(!values.last)    return false;  return true;}console.log(validate({first:&apos;Bruce&apos;,last:&apos;Wayne&apos;})); // true</code></pre><p>假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认？</p><pre><code>// 对象验证规则const schema = {  first: {    required:true  },  last: {    required:true  }}// 通用验证函数const validate = (schema, values) =&gt; {  for(field in schema) {    if(schema[field].required) {      if(!values[field]) {        return false;      }    }  }  return true;}console.log(validate(schema, {first:&apos;Bruce&apos;})); // falseconsole.log(validate(schema, {first:&apos;Bruce&apos;,last:&apos;Wayne&apos;})); // true</code></pre><p>现在可以有适用于各种情况的验证函数，不需要为了每个而编写自定义验证函数了</p><h2 id="19-双重非位运算简写"><a href="#19-双重非位运算简写" class="headerlink" title="19.双重非位运算简写"></a>19.双重非位运算简写</h2><p>有一个有效用例用于双重非运算操作符。可以用来代替Math.floor()，其优势在于运行更快，可以阅读此文章了解更多位运算。<br><code>Math.floor(4.9) === 4 //true</code></p><p>简写：<br><code>~~4.9 === 4 //true</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React高阶组件HOC</title>
      <link href="/2017/10/04/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
      <url>/2017/10/04/React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是高阶组件？"><a href="#什么是高阶组件？" class="headerlink" title="什么是高阶组件？"></a>什么是高阶组件？</h4><blockquote><p>高阶部件是一种用于复用组件逻辑的高级技术，它并不是 React API的一部分，而是从React 演化而来的一种模式。 具体地说，高阶组件就是一个接收一个组件并返回另外一个新组件的函数！</p></blockquote><p>这是官方文档说的，我没有截全，因为后面的解释会造成误解，但简单讲高阶组件（函数）就好比一个加工厂，同样的，屏幕、cpu、扬声器、键盘按键、外壳、电池，小米手机工厂组装完就是小米手机，魅族手机组装完就是魅族手机，基本材料都是相同的，不同工厂（高阶组件）有不同的实现及产出，当然这个工厂（高阶组件）也可能是针对某个基本材料的处理。</p><p>总之产出的结果拥有了输入组件不具备的功能，输入的组件可以是一个组件的实例，也可以是一个组件类，还可以是一个无状态组件的函数。</p><h4 id="解决什么问题？"><a href="#解决什么问题？" class="headerlink" title="解决什么问题？"></a>解决什么问题？</h4><p>随着项目越来越复杂，开发过程中，多个组件需要某个功能，而且这个功能和页面并没有关系，所以也不能简单的抽取成一个新的组件，但是如果让同样的逻辑在各个组件里各自实现，无疑会导致重复的代码。比如页面有三种弹窗一个有title，一个没有，一个又有右上角关闭按钮，除此之外别无它样，你总不能整好几个弹窗组件吧，这里除了tilte,关闭按钮其他的就可以做为上面说的基本材料。</p><hr><h4 id="高阶组件总共分为两大类"><a href="#高阶组件总共分为两大类" class="headerlink" title="高阶组件总共分为两大类"></a>高阶组件总共分为两大类</h4><ul><li><p>代理方式</p><ol><li>操纵prop</li><li>访问ref（不推荐）</li><li>抽取状态</li><li>包装组件</li></ol></li><li><p>继承方式</p><ol><li>操纵生命周期</li><li>操纵prop</li></ol></li></ul><h4 id="代理方式之-操纵prop"><a href="#代理方式之-操纵prop" class="headerlink" title="代理方式之 操纵prop"></a>代理方式之 操纵prop</h4><h6 id="删除prop"><a href="#删除prop" class="headerlink" title="删除prop"></a>删除prop</h6><pre><code>import React from&apos;react&apos;functionHocRemoveProp(WrappedComponent) {  returnclassWrappingComPonentextendsReact.Component{    render() {      const { user, ...otherProps } = this.props;      return&lt;WrappedComponent {...otherProps} /&gt;    }  }}export default HocRemoveProp;</code></pre><h6 id="增加prop"><a href="#增加prop" class="headerlink" title="增加prop"></a>增加prop</h6><p>接下来我把简化了写法，把匿名函数去掉，同时换成箭头函数</p><pre><code>import React from&apos;react&apos;const HocAddProp = (WrappedComponent，uid) =&gt;classextendsReact.Component{    render() {      const newProps = {        uid,      };      return&lt;WrappedComponent {...this.props}  {...newProps}  /&gt;    }  }export default HocAddProp;</code></pre><p>上面HocRemoveProp高阶组件中，所做的事情和输入组件WrappedComponent功能一样，只是忽略了名为user的prop。也就是说，如果WrappedComponent能处理名为user的prop,这个高阶组件返回的组件则完全无视这个prop。</p><pre><code>const { user, ...otherProps } = this.props;</code></pre><p>这是一个利用es6语法技巧，经过上面的语句，otherProps里面就有this.props中所有的字段除了user.</p><p>假如我们现在不希望某个组件接收user的prop,那么我们就不要直接使用这个组件，而是把这个组件作为参数传递给HocRemoveProp，然后我们把这个函数的返回结果当作组件来使用</p><p>两个高阶组件的使用方法：</p><pre><code>const  newComponent = HocRemoveProp(SampleComponent);const  newComponent = HocAddProp(SampleComponent,&apos;1111111&apos;);</code></pre><p>也可以利用decorator语法糖这样使用</p><pre><code>import React, { Component } from&apos;React&apos;;@HocRemoveProp classSampleComponentextendsComponent{render() {}}exportdefault SampleComponent;</code></pre><h4 id="代理方式之-抽取状态"><a href="#代理方式之-抽取状态" class="headerlink" title="代理方式之 抽取状态"></a>代理方式之 抽取状态</h4><p>将所有的状态的管理交给外面的容器组件，这个模式就是 抽取状态</p><p>外面的容器就是这个高阶组件</p><pre><code>const HocContainer = (WrappedComponent) =&gt;classextendsReact.Component{    constructor(props) {      super(props)      this.state = {        name: &apos;&apos;      }    }    onNameChange = (event) =&gt; {      this.setState({        name: event.target.value      })    }    render() {      const newProps = {        name: {          value: this.state.name,          onChange: this.onNameChange        }      }      return&lt;WrappedComponent {...this.props} {...newProps} /&gt;    }  }@HocContainerclassSampleComponentextendsReact.Component{  render() {    return&lt;inputname=&quot;name&quot; {...this.props.name}/&gt;  }}</code></pre><p>这样当我们在使用这个已经被包裹的input组件（SampleComponent）时候</p><p>它的值就被放在了HocContainer高阶组件中，当很多这样的input组件都用这个HocContainer高阶组件时，那么它们的值都将保存在这个HocContainer高阶组件中</p><h4 id="代理方式之-包装组件"><a href="#代理方式之-包装组件" class="headerlink" title="代理方式之 包装组件"></a>代理方式之 包装组件</h4><pre><code>const HocStyleComponent = (WrappedComponent, style) =&gt;classextendsReact.Component{    render() {      return (        &lt;divstyle={style}&gt;&lt;WrappedComponent {...this.props} {...newProps} /&gt;&lt;/div&gt;      )    }  }</code></pre><p>这样使用</p><pre><code>import HocStyleComponent from&apos;./HocStyleComponent&apos;;const colorSytle ={color:&apos;#ff5555&apos;}const  newComponent = HocStyleComponent(SampleComponent, colorSytle);</code></pre><p>-代理方式的生命周期的过程类似于堆栈调用:</p><p>didmount 一&gt; HOC didmount 一&gt;(HOCs didmount) 一&gt;(HOCs will unmount) 一&gt;HOC will unmount一&gt;unmount</p><h4 id="在说继承方式之前先看一个例子"><a href="#在说继承方式之前先看一个例子" class="headerlink" title="在说继承方式之前先看一个例子"></a>在说继承方式之前先看一个例子</h4><pre><code>const MyContainer = (WrappedComponent) =&gt;classextendsWrappedComponent{    render() {      returnsuper.render();    }  }</code></pre><p>这个例子很简单，相当于把WrappedComponent组件的render方法，通过super.render()方法吐到了MyContainer 中，可以顺序调用。</p><ul><li>继承方式的生命周期的过程类似于队列调用:</li></ul><p>didmount 一&gt; HOC didmount 一&gt;(HOCs didmount) 一&gt;will unmount一&gt;HOC will unmount一&gt; (HOCs will unmount)</p><ul><li>代理方式下WrappedComponent会经历一个完整的生命周期，产生的新组件和参数组件是两个不同的组件，一次渲染，两个组件都会经历各自的生命周期，</li><li>在继承方式下，产生的新组件和参数组件合二为一，super.render只是生命周期中的函数，变成一个生命周期。</li></ul><p>来看下面的例子你就会明白了。</p><h4 id="继承方式之-操纵生命周期-渲染劫持"><a href="#继承方式之-操纵生命周期-渲染劫持" class="headerlink" title="继承方式之 操纵生命周期(渲染劫持)"></a>继承方式之 操纵生命周期(渲染劫持)</h4><p>首先创建一个高阶，在创建一个使用高阶组件的组件，也就是是输入组件，最后我在改变这个输入组件props</p><pre><code>import * as React from&apos;react&apos;;const HocComponent = (WrappedComponent) =&gt;classMyContainerextendsWrappedComponent{    render() {      if (this.props.time &amp;&amp; this.state.success) {        returnsuper.render()      }      return&lt;div&gt;倒计时完成了...&lt;/div&gt;    }  }</code></pre><p>这个高阶组件会直接读取输入组件中的props,state,然后控制了输入组件的render展示</p><p>只有在props.time和state.success同时为真的时候才会展示</p><pre><code>import * as React from&apos;react&apos;;import HocComponent from&apos;./HocComponent&apos;@HocComponentclassDemoComponentextendsReact.Component{  constructor(props) {    super(props);   this.state = {    success: true,   }; }  render() {    return&lt;div&gt;我是一个组件&lt;/div&gt;  }} exportdefault DemoComponent;</code></pre><p>然后调用，递减time数值直到变为0</p><h6 id="由此可以看出高阶组件也可以控制state"><a href="#由此可以看出高阶组件也可以控制state" class="headerlink" title="由此可以看出高阶组件也可以控制state"></a>由此可以看出高阶组件也可以控制state</h6><p>但是最好要限制这样做，可能会让WrappedComponent组件内部状态变得一团糟。建议可以通过重新命名state，以防止混淆。</p><h4 id="继承方式之-操纵prop"><a href="#继承方式之-操纵prop" class="headerlink" title="继承方式之 操纵prop"></a>继承方式之 操纵prop</h4><pre><code>const HOCPropsComponent = (WrappedComponent) =&gt;classextendsWrappedComponent{    render() {      const elementsTree = super.render();      let newProps = {        color: (elementsTree &amp;&amp; elementsTree.type === &apos;div&apos;) ? &apos;#fff&apos; : &apos;#ff5555&apos;      };      const props = Object.assign({}, elementsTree.props, newProps)      const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children)      return newElementsTree    }  }</code></pre><p>这样就传入了新的props，。</p><p>React.cloneElement( element, [props], […children])</p><p>参数：TYPE（ReactElement），[PROPS（object）]，[CHILDREN（ReactElement）]</p><p>克隆并返回一个新的 ReactElement ，新返回的元素会保留有旧元素的 props、ref、key，也会集成新的 props。</p><h5 id="还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，"><a href="#还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，" class="headerlink" title="还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，"></a>还有一个方式，在传递props上有着强于高阶组件的优势不用关心命名，</h5><pre><code>classaddPropsextendsReact.Component{  render() {    const newProps = &apos;uid&apos;returnthis.props.children(newProps)  }} </code></pre><p>使用方式</p><pre><code>&lt;addProps&gt;{   (argument) =&gt; &lt;div&gt;{argument}&lt;/div&gt;}&lt;/addProps&gt;</code></pre><p>感觉很方便，但是每次渲染都会重新定义一个新的函数，如果不想的话就不要定义匿名函数，</p><pre><code>showUid(argument) {    return&lt;div&gt;{argument}&lt;/div&gt;}</code></pre><h5 id="彩蛋recompose库"><a href="#彩蛋recompose库" class="headerlink" title="彩蛋recompose库"></a>彩蛋recompose库</h5><p>recompose是一个很流行的库，它提供了很多很有用的高阶组件（小工具），而且也可以优雅的组合它们。</p><h6 id="Step-1-扁平props"><a href="#Step-1-扁平props" class="headerlink" title="Step 1 扁平props."></a>Step 1 扁平props.</h6><p>我们有这样一个组件</p><pre><code>const Profile = ({ user }) =&gt; ( &lt;div&gt;&lt;div&gt;Username: {user.username}&lt;/div&gt;&lt;div&gt;Age: {user.age}&lt;/div&gt;&lt;/div&gt; )</code></pre><p>如果想要改变组件接口来接收单个 prop 而不是整个用户对象，可以用 recompose 提供的高 阶组件 flattenProp 来实现。</p><pre><code>const Profile = ({ username，age }) =&gt; ( &lt;div&gt;&lt;div&gt;Username: {username}&lt;/div&gt;&lt;div&gt;Age: {age}&lt;/div&gt;&lt;/div&gt; )</code></pre><p>const ProfileWithFlattenUser = flattenProp(‘user’)(Profile)；</p><p>现在我们希望同时使用多个高阶组件：一个用于扁平化处理用户 prop，另一个用于重命名用 户对象的单个 prop，不过串联使用函数的做法似乎不太好。 此时 recompose 库提供的 compose 函数就派上用场了。</p><pre><code>const enhance = compose( flattenProp(&apos;user&apos;), renameProp(&apos;username&apos;, &apos;name&apos;) )</code></pre><p>然后按照以下方式将它应用于原有组件：</p><pre><code>const EnhancedProfile = enhance(Profile)</code></pre><p>还可以将 compose 函数用 在我们自己的高阶组件上，甚至结合使用都可以：</p><pre><code>const enhance = compose(  flattenProp(&apos;user&apos;),  renameProp(&apos;username&apos;, &apos;name&apos;),  withInnerWidth )</code></pre><h6 id="Step-2-提取输入表单的State"><a href="#Step-2-提取输入表单的State" class="headerlink" title="Step 2 提取输入表单的State"></a>Step 2 提取输入表单的State</h6><p>我们将从Recompose库中使用withStateHandlers高阶组件。 它将允许我们将组件状态与组件本身隔离开来。 我们将使用它为电子邮件，密码和确认密码字段添加表单状态，以及上述字段的事件处理程序。</p><pre><code>import { withStateHandlers, compose } from&quot;recompose&quot;;const initialState = {  email: { value: &quot;&quot; },  password: { value: &quot;&quot; },  confirmPassword: { value: &quot;&quot; }};const onChangeEmail = props =&gt; event =&gt; ({  email: {    value: event.target.value,    isDirty: true  }});const onChangePassword = props =&gt; event =&gt; ({  password: {    value: event.target.value,    isDirty: true  }});const onChangeConfirmPassword = props =&gt; event =&gt; ({  confirmPassword: {    value: event.target.value,    isDirty: true  }});const withTextFieldState = withStateHandlers(initialState, {  onChangeEmail,  onChangePassword,  onChangeConfirmPassword});exportdefault withTextFieldState;</code></pre><p>withStateHandlers它接受初始状态和包含状态处理程序的对象。调用时，每个状态处理程序将返回新的状态。</p><p>好了，很辛苦也很感谢你能看到这里，关于recompose介绍到此为止，喜欢的朋友可以深入研究recompose其它的方法和源码。</p><p>不准确的地方欢迎拍砖</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 高阶组件 </tag>
            
            <tag> HOC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Event Loop 必知必会（六道题）</title>
      <link href="/2017/10/03/Event-Loop-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%88%E5%85%AD%E9%81%93%E9%A2%98%EF%BC%89/"/>
      <url>/2017/10/03/Event-Loop-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%EF%BC%88%E5%85%AD%E9%81%93%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>一直想写一篇关于 Event Loop 的文章，前不久发现 CNode 上有位同学写了一篇原理分析的<a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/5a9108d78d6e16e56bb80882%235a98d9a2ce1c90bc44c445af" target="_blank" rel="noopener">文章</a>很详细，这里我就不献丑了。本文就拿出六道题来补充一下，放出一张我认为非常直观的图。<br><img src="https://pic4.zhimg.com/v2-3a59c624e6ff95a7e8c5a23c979f5abe_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3a59c624e6ff95a7e8c5a23c979f5abe_hd.jpg" alt=""><br>绿色小块是 macrotask（宏任务），macrotask 中间的粉红箭头是 microtask（微任务）。</p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><pre><code>setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})</code></pre><p>运行结果：</p><pre><code>setImmediatesetTimeout</code></pre><p>或者：</p><pre><code>setTimeoutsetImmediate</code></pre><p>为什么结果不确定呢？</p><p>解释：setTimeout/setInterval 的第二个参数取值范围是：[1, 2^31 - 1]，如果超过这个范围则会初始化为 1，即 setTimeout(fn, 0) === setTimeout(fn, 1)。我们知道 setTimeout 的回调函数在 timer 阶段执行，setImmediate 的回调函数在 check 阶段执行，event loop 的开始会先检查 timer 阶段，但是在开始之前到 timer 阶段会消耗一定时间，所以就会出现两种情况：</p><ol><li>timer 前的准备时间超过 1ms，满足  loop-&gt;time &gt;= 1，则执行 timer 阶段（setTimeout）的回调函数</li><li>timer 前的准备时间小于 1ms，则先执行 check 阶段（setImmediate）的回调函数，下一次 event loop 执行 timer 阶段（setTimeout）的回调函数</li></ol><p>再看个例子：</p><pre><code>setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})conststart=Date.now()while(Date.now()-start&lt;10);</code></pre><p>运行结果一定是：</p><pre><code>setTimeoutsetImmediate</code></pre><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><pre><code>constfs=require(&apos;fs&apos;)fs.readFile(__filename,()=&gt;{setTimeout(()=&gt;{console.log(&apos;setTimeout&apos;)},0)setImmediate(()=&gt;{console.log(&apos;setImmediate&apos;)})})</code></pre><p>运行结果：</p><pre><code>setImmediatesetTimeout</code></pre><p>解释：fs.readFile 的回调函数执行完后：</p><ol><li>注册 setTimeout 的回调函数到 timer 阶段</li><li>注册 setImmediate 的回调函数到 check 阶段</li><li>event loop 从 pool 阶段出来继续往下一个阶段执行，恰好是 check 阶段，所以 setImmediate 的回调函数先执行</li><li>本次 event loop 结束后，进入下一次 event loop，执行 setTimeout 的回调函数</li></ol><p>所以，在 I/O Callbacks 中注册的 setTimeout 和 setImmediate，永远都是 setImmediate 先执行。</p><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><pre><code>setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)process.nextTick(functiontick(){process.nextTick(tick)})</code></pre><p>运行结果：setInterval 永远不会打印出来。</p><p>解释：process.nextTick 会无限循环，将 event loop 阻塞在 microtask 阶段，导致 event loop 上其他 macrotask 阶段的回调函数没有机会执行。</p><p>解决方法通常是用 setImmediate 替代 process.nextTick，如下：</p><pre><code>setInterval(()=&gt;{console.log(&apos;setInterval&apos;)},100)setImmediate(functionimmediate(){setImmediate(immediate)})</code></pre><p>运行结果：每 100ms 打印一次 setInterval。</p><p>解释：process.nextTick 内执行 process.nextTick 仍然将 tick 函数注册到当前 microtask 的尾部，所以导致 microtask 永远执行不完； setImmediate 内执行 setImmediate 会将 immediate 函数注册到下一次 event loop 的 check 阶段，而不是当前正在执行的 check 阶段，所以给了 event loop 上其他 macrotask 执行的机会。</p><p>再看个例子：</p><pre><code>setImmediate(()=&gt;{console.log(&apos;setImmediate1&apos;)setImmediate(()=&gt;{console.log(&apos;setImmediate2&apos;)})process.nextTick(()=&gt;{console.log(&apos;nextTick&apos;)})})setImmediate(()=&gt;{console.log(&apos;setImmediate3&apos;)})</code></pre><p>运行结果：</p><pre><code>setImmediate1setImmediate3nextTicksetImmediate2</code></pre><p>注意：并不是说 setImmediate 可以完全替代 process.nextTick，process.nextTick 在特定场景下还是无法被替代的，比如我们就想将一些操作放到最近的 microtask 里执行。</p><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><pre><code>constpromise=Promise.resolve().then(()=&gt;{returnpromise})promise.catch(console.error)</code></pre><p>运行结果：</p><pre><code>TypeError: Chaining cycle detected for promise #&lt;Promise&gt;    at &lt;anonymous&gt;    at process._tickCallback (internal/process/next_tick.js:188:7)    at Function.Module.runMain (module.js:667:11)    at startup (bootstrap_node.js:187:16)    at bootstrap_node.js:607:3</code></pre><p>解释：promise.then 类似于 process.nextTick，都会将回调函数注册到 microtask 阶段。上面代码会导致死循环，类似前面提到的：</p><pre><code>process.nextTick(functiontick(){process.nextTick(tick)})</code></pre><p>再看个例子：</p><pre><code>constpromise=Promise.resolve()promise.then(()=&gt;{  console.log(&apos;promise&apos;)})  process.nextTick(()=&gt;{      console.log(&apos;nextTick&apos;)  })</code></pre><p>运行结果：</p><pre><code>nextTickpromise</code></pre><p>解释：promise.then 虽然和 process.nextTick 一样，都将回调函数注册到 microtask，但优先级不一样。process.nextTick 的 microtask queue 总是优先于 promise 的 microtask queue 执行。</p><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><pre><code>setTimeout(()=&gt;{    console.log(1)},0)newPromise((resolve,reject)=&gt;{   console.log(2)   for(leti=0;i&lt;10000;i++){     i===9999&amp;&amp;resolve()   }   console.log(3)}).then(()=&gt;{   console.log(4)})console.log(5)</code></pre><p>运行结果：</p><p>解释：Promise 构造函数是同步执行的，所以先打印 2、3，然后打印 5，接下来 event loop 进入执行 microtask 阶段，执行 promise.then 的回调函数打印出 4，然后执行下一个 macrotask，恰好是 timer 阶段的 setTimeout 的回调函数，打印出 1。</p><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><pre><code>setImmediate(()=&gt;{    console.log(1)    setTimeout(()=&gt;{       console.log(2)    },100)    setImmediate(()=&gt;{       console.log(3)    })    process.nextTick(       ()=&gt;{console.log(4)})     })     process.nextTick(()=&gt;{       console.log(5)       setTimeout(()=&gt;{        console.log(6)},100)        setImmediate(()=&gt;{        console.log(7)})        process.nextTick(        ()=&gt;{console.log(8)})        })console.log(9)</code></pre><p>运行结果：</p><p>process.nextTick、setTimeout 和 setImmediate 的组合，请读者自己推理吧。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c" target="_blank" rel="noopener">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></li><li><a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/topic/57d68794cb6f605d360105bf" target="_blank" rel="noopener">https://cnodejs.org/topic/57d68794cb6f605d360105bf</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 事件循环 </tag>
            
            <tag> Event Loop </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS如何实现文字两端对齐</title>
      <link href="/2017/10/02/CSS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90/"/>
      <url>/2017/10/02/CSS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<p>最近在工作项目中接触到Web界面设计的问题，要实现文字两端对齐的效果。在网上搜索了一下，差不多都是互相转帖，用的都是类似的技巧：</p><pre><code>text-align:justify;text-justify:inter-ideograph;</code></pre><p>但问题是，我怎么就看不到效果呢？无论是英文还是中文，在IE和chrome下都不起作用。后来，终于在StackOverflow上找到解决方法了。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            .arter li {                font-size: 14px;                line-height: 24px;                color: #4a4a4a;            }            .arter span {                height: 24px;                line-height: 24px;                width: 65px;                text-align: justify;                display: inline-block;                overflow: hidden;                vertical-align: top;            }            .arter i {                display: inline-block;                width: 100%;                height: 0;            }            .arter1 li {                font-size: 14px;                line-height: 24px;                color: #4a4a4a;            }            .arter1 span {                height: 24px;                line-height: 24px;                width: 65px;                text-align: justify;                display: inline-block;                overflow: hidden;                vertical-align: top;            }            .arter1 span:after {                content: &quot; &quot;;                display: inline-block;                width: 100%;                height: 0px;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;ul class=&quot;arter&quot;&gt;            &lt;li&gt;&lt;span&gt;作品名称&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 宝贝儿&lt;/li&gt;            &lt;li&gt;&lt;span&gt;作品类型&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 油画&lt;/li&gt;            &lt;li&gt;&lt;span&gt;艺术家&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 张玉瀛&lt;/li&gt;            &lt;li&gt;&lt;span&gt;风格&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 超现实&lt;/li&gt;            &lt;li&gt;&lt;span&gt;材质&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 布面油画&lt;/li&gt;            &lt;li&gt;&lt;span&gt;题材&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 人物&lt;/li&gt;            &lt;li&gt;&lt;span&gt;创作时间&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 2011&lt;/li&gt;            &lt;li&gt;&lt;span&gt;所在位置&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 华东&lt;/li&gt;            &lt;li&gt;&lt;span&gt;尺寸&lt;i&gt;&lt;/i&gt;&lt;/span&gt;： 78x78cm&lt;/li&gt;        &lt;/ul&gt;        &lt;br /&gt;&lt;br /&gt;        &lt;ul class=&quot;arter1&quot;&gt;            &lt;li&gt;&lt;span&gt;作品名称&lt;/span&gt;： 宝贝儿&lt;/li&gt;            &lt;li&gt;&lt;span&gt;作品类型&lt;/span&gt;： 油画&lt;/li&gt;            &lt;li&gt;&lt;span&gt;艺术家&lt;/span&gt;： 张玉瀛&lt;/li&gt;            &lt;li&gt;&lt;span&gt;风格&lt;/span&gt;： 超现实&lt;/li&gt;            &lt;li&gt;&lt;span&gt;材质&lt;/span&gt;： 布面油画&lt;/li&gt;            &lt;li&gt;&lt;span&gt;题材&lt;/span&gt;： 人物&lt;/li&gt;            &lt;li&gt;&lt;span&gt;创作时间&lt;/span&gt;： 2011&lt;/li&gt;            &lt;li&gt;&lt;span&gt;所在位置&lt;/span&gt;： 华东&lt;/li&gt;            &lt;li&gt;&lt;span&gt;尺寸&lt;/span&gt;： 78x78cm&lt;/li&gt;        &lt;/ul&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>样式：<br><img src="https://pic1.zhimg.com/v2-b92871dee74e80785026c069073206ab_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-b92871dee74e80785026c069073206ab_hd.jpg" alt=""><br>从效果图可以看到，除了要在块级元素加text-align:justify样式外，还需要在里面加一个空的span元素，并应用样式。另外，对于中文还必须用空格隔开汉字，否则也没有两端对齐的效果。英文每个单词都有空格隔开，所以没问题。</p><p>但是加入HTML元素又违反了结构表现分离的原则，我们可以改用after、before伪元素：</p><pre><code>li:after {    content: &quot; &quot;;    display: inline-block;    width: 100%;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pm2 常用配置及命令</title>
      <link href="/2017/09/30/pm2-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%91%BD%E4%BB%A4/"/>
      <url>/2017/09/30/pm2-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果直接通过node app来启动，如果报错了可能直接停在整个运行，supervisor感觉只是拿来用作开发环境的。再网上找到pm2.目前似乎最常见的线上部署nodejs项目的有forever,pm2这两种。<br>使用场合:</p></blockquote><ul><li>supervisor是开发环境用。</li><li>forever管理多个站点，每个站点访问量不大，不需要监控。</li><li>nodemon 是开发环境使用，修改自动重启。</li><li>pm2 网站访问量比较大,需要完整的监控界面。</li></ul><p><code>PM2</code> 是 <code>node</code> 进程管理工具，可以利用它来简化很多 <code>node</code> 应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。本文就 <code>PM2</code> 进行入门性的介绍，基本涵盖了 <code>PM2</code> 的常用的功能和配置。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pm2</span><br></pre></td></tr></table></figure><p>如果你的node项目配置文件和以上代码不一样，，，莫急，pm2 也是有办法可以启动的（个人觉得这是一个万能的启动的方法）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pm2 start npm -- run XXX</span><br><span class="line">pm2 start npm --watch --name XXX -- run start</span><br></pre></td></tr></table></figure></p><p>用她替代：<code>npm run dev</code>，就可以写成：<code>pm2 start npm -- run dev</code>，项目启动：    </p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">pm2 start [server.js]</span><br><span class="line"># 启动服务</span><br><span class="line">pm2 list</span><br><span class="line"># 查看当前所跑服务的详情</span><br><span class="line">pm2 show [name]</span><br><span class="line"># 查看更加详细的信息这个命令可查看pm2配置 包括日志文件存放的位置等</span><br><span class="line">pm2 stop [id/name]</span><br><span class="line"># 关闭某个服务</span><br><span class="line">pm2 delete [id/name]</span><br><span class="line"># 删除某个服务</span><br><span class="line">pm2 stop all</span><br><span class="line"># 关闭所有服务</span><br><span class="line">pm2 logs</span><br><span class="line"># 查看实时日志</span><br><span class="line">pm2 restart [name]</span><br><span class="line"># 重新启动服务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pm2 logs 显示所有进程日志</span><br><span class="line">$ pm2 stop all 停止所有进程</span><br><span class="line">$ pm2 restart all 重启所有进程</span><br><span class="line">$ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程)</span><br><span class="line">$ pm2 stop 0 停止指定的进程</span><br><span class="line">$ pm2 restart 0 重启指定的进程</span><br><span class="line">$ pm2 startup 产生 init 脚本 保持进程活着</span><br><span class="line">$ pm2 web 运行健壮的 computer API endpoint (http://localhost:9615)</span><br><span class="line">$ pm2 delete 0 杀死指定的进程</span><br><span class="line">$ pm2 delete all 杀死全部进程</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">运行进程的不同方式：</span><br><span class="line">$ pm2 start app.js -i max 根据有效CPU数目启动最大进程数目</span><br><span class="line">$ pm2 start app.js -i 3 启动3个进程</span><br><span class="line">$ pm2 start app.js -x 用fork模式启动 app.js 而不是使用 cluster</span><br><span class="line">$ pm2 start app.js -x -- -a 23 用fork模式启动 app.js 并且传递参数 (-a 23)</span><br><span class="line">$ pm2 start app.js --name serverone 启动一个进程并把它命名为 serverone</span><br><span class="line">$ pm2 stop serverone 停止 serverone 进程</span><br><span class="line">$ pm2 start app.json 启动进程, 在 app.json里设置选项</span><br><span class="line">$ pm2 start app.js -i max -- -a 23 在--之后给 app.js 传递参数</span><br><span class="line">$ pm2 start app.js -i max -e err.log -o out.log 启动 并 生成一个配置文件</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>参数说明：</p><ul><li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</li><li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果 <code>-i 0</code> 或者 <code>-i max</code>，则根据当前机器核数确定实例数目。</li><li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如 <code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li><li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li><li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li><li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li></ul><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><pre><code>pm2 start ./bin/www --watch#注意，这里用了--watch参数，意味着当你的应用代码发生变化时，pm2会帮你自动重启服务</code></pre><h2 id="配置及部署"><a href="#配置及部署" class="headerlink" title="配置及部署"></a>配置及部署</h2><p>部署的配置文件示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 数组中放的是需要发布的项目一些变量的定义</span><br><span class="line">  &quot;apps&quot;: [&#123;</span><br><span class="line">    &quot;name&quot;: &quot;xxx&quot;, //项目名称</span><br><span class="line">    &quot;script&quot;: &quot;server.js&quot;, //用来启动的脚本</span><br><span class="line">    // &quot;instances&quot;:2,</span><br><span class="line">    // 启动项目所需要的环境变量</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">      &quot;COMMON_VARIABLE&quot;: &quot;true&quot;, //设置为true 可以在启动的时传入外部的变量进去</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;env_production&quot;: &#123;</span><br><span class="line">      &quot;NODE_ENV&quot;: &quot;production&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  // 部署</span><br><span class="line">  &quot;deploy&quot;: &#123;</span><br><span class="line">    &quot;production&quot;: &#123;</span><br><span class="line">      &quot;user&quot;: &quot;root&quot;,</span><br><span class="line">      &quot;host&quot;: &quot;0.0.0.0&quot;, //可以是数组 部署到多台主机</span><br><span class="line">      &quot;ref&quot;: &quot;origin/master&quot;, //选择拿哪个个分支的代码</span><br><span class="line">      &quot;repo&quot;: &quot;git@github.com:ihoey/hitalk.git&quot;, //仓库地址</span><br><span class="line">      &quot;path&quot;: &quot;/root/www/hitalk/production&quot;, //要发布到服务器上哪个目录下面</span><br><span class="line">      &quot;ssh_options&quot;: &quot;StrictHostKeyChecking=no&quot;, //避免key验证导致代码更新到远程仓库失败</span><br><span class="line">      &quot;post-deploy&quot;: &quot;source ~/.nvm/nvm.sh &amp;&amp; pm2 startOrRestart ecosystem.json --env production&quot;, //发布之后执行的动作 执行开启或更新pm2运行的服务</span><br><span class="line">      &quot;pre-deploy-local&quot;: &quot;echo &apos;Deploy Done!&apos;&quot;, //本地发布之前的动作</span><br><span class="line">      &quot;env&quot;: &#123; //指定部署到远程的仓库的环境 是production生产环境</span><br><span class="line">        &quot;NODE_ENV&quot;: &quot;production&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>说明:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apps:json结构，apps是一个数组，每一个数组成员就是对应一个pm2中运行的应用</span><br><span class="line">name:应用程序名称</span><br><span class="line">cwd:应用程序所在的目录</span><br><span class="line">script:应用程序的脚本路径</span><br><span class="line">log_date_format:</span><br><span class="line">error_file:自定义应用程序的错误日志文件</span><br><span class="line">out_file:自定义应用程序日志文件</span><br><span class="line">pid_file:自定义应用程序的pid文件</span><br><span class="line">instances:</span><br><span class="line">min_uptime:最小运行时间，这里设置的是60s即如果应用程序在60s内退出，pm2会认为程序异常退出，此时触发重启max_restarts设置数量</span><br><span class="line">max_restarts:设置应用程序异常退出重启的次数，默认15次（从0开始计数）</span><br><span class="line">cron_restart:定时启动，解决重启能解决的问题</span><br><span class="line">watch:是否启用监控模式，默认是false。如果设置成true，当应用程序变动时，pm2会自动重载。这里也可以设置你要监控的文件。</span><br><span class="line">merge_logs:</span><br><span class="line">exec_interpreter:应用程序的脚本类型，这里使用的shell，默认是nodejs</span><br><span class="line">exec_mode:应用程序启动模式，这里设置的是cluster_mode（集群），默认是fork</span><br><span class="line">autorestart:启用/禁用应用程序崩溃或退出时自动重启</span><br><span class="line">vizion:启用/禁用vizion特性(版本控制)</span><br></pre></td></tr></table></figure><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><p>第一次部署</p><pre><code>pm2 deploy ecosystem.json production setup</code></pre><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><pre><code>pm2 deploy ecosystem.json production</code></pre><p>好了，先记录这么多~</p>]]></content>
      
      
      
        <tags>
            
            <tag> pm2 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React setState</title>
      <link href="/2017/09/21/React-setState/"/>
      <url>/2017/09/21/React-setState/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/09/21/React-setState/1.webp" alt=""></p><blockquote><p>面试官：“react中<code>setState</code>是同步的还是异步？”</p></blockquote><blockquote><p>我：“异步的，<code>setState</code>不能立马拿到结果。”</p></blockquote><blockquote><p>面试官：“那什么场景下是异步的，可不可能是同步，什么场景下又是同步的？”</p></blockquote><blockquote><p>我：“……”</p></blockquote><h3 id="setState真的是异步的吗？"><a href="#setState真的是异步的吗？" class="headerlink" title="setState真的是异步的吗？"></a><code>setState</code>真的是异步的吗？</h3><p>这两天自己简单的看了下 <code>setState</code> 的部分实现代码，在这边给到大家一个自己个人的见解，可能文字或图片较多，没耐心的同学可以直接跳过看总结(<strong>源码版本是16.4.1</strong>)。</p><p><strong>看之前，为了方便理解和简化流程，我们默认react内部代码执行到<code>performWork</code><br>、<code>performWorkOnRoot</code>、<code>performSyncWork</code>、<code>performAsyncWork</code>这四个方法的时候，就是react去update更新并且作用到UI上。</strong></p><h3 id="一、合成事件中的setState"><a href="#一、合成事件中的setState" class="headerlink" title="一、合成事件中的setState"></a>一、合成事件中的<code>setState</code></h3><p>首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在<code>jsx</code>中常见的<code>onClick</code>、<code>onChange</code>这些都是合成事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line">  increment = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    console.log(this.state.val) // 输出的是更新前的val --&gt; 0</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.increment&#125;&gt;</span><br><span class="line">        &#123;`Counter is: $&#123;this.state.val&#125;`&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>合成事件中的<code>setState</code>写法比较常见，点击事件里去改变 <code>this.state.val</code> 的状态值，在 <code>increment</code> 事件中打个断点可以看到调用栈，这里我贴一张自己画的流程图：<br><img src="/2017/09/21/React-setState/2.webp" alt=""><br>从 <code>dispatchInteractiveEvent</code> 到 <code>callCallBack</code> 为止，都是对合成事件的处理和执行，从 <code>setState</code> 到 <code>requestWork</code> 是调用 <code>this.setState</code> 的逻辑，这边主要看下  <code>requestWork</code> 这个函数（从 <code>dispatchEvent</code> 到 <code>requestWork</code> 的调用栈是属于 <code>interactiveUpdates$1</code> 的 <code>try</code> 代码块，下文会提到）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function requestWork(root, expirationTime) &#123;</span><br><span class="line">  addRootToSchedule(root, expirationTime);</span><br><span class="line"></span><br><span class="line">  if (isRendering) &#123;</span><br><span class="line">    // Prevent reentrancy. Remaining work will be scheduled at the end of</span><br><span class="line">    // the currently rendering batch.</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (isBatchingUpdates) &#123;</span><br><span class="line">    // Flush work at the end of the batch.</span><br><span class="line">    if (isUnbatchingUpdates) &#123;</span><br><span class="line">      // ...unless we&apos;re inside unbatchedUpdates, in which case we should</span><br><span class="line">      // flush it now.</span><br><span class="line">      nextFlushedRoot = root;</span><br><span class="line">      nextFlushedExpirationTime = Sync;</span><br><span class="line">      performWorkOnRoot(root, Sync, false);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // TODO: Get rid of Sync and use current time?</span><br><span class="line">  if (expirationTime === Sync) &#123;</span><br><span class="line">    performSyncWork();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    scheduleCallbackWithExpiration(expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>requestWork</code> 中有三个if分支，三个分支中有两个方法 <code>performWorkOnRoot</code> 和 <code>performSyncWork</code> ，就是我们默认的update函数，但是在合成事件中，走的是第二个if分支，第二个分支中有两个标识 <code>isBatchingUpdates</code> 和 <code>isUnbatchingUpdates</code> 两个初始值都为  <code>false</code> ，但是在 <code>interactiveUpdates$1</code> 中会把 <code>isBatchingUpdates</code> 设为 <code>true</code> ，下面就是 <code>interactiveUpdates$1</code> 的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function interactiveUpdates$1(fn, a, b) &#123;</span><br><span class="line">  if (isBatchingInteractiveUpdates) &#123;</span><br><span class="line">    return fn(a, b);</span><br><span class="line">  &#125;</span><br><span class="line">  // If there are any pending interactive updates, synchronously flush them.</span><br><span class="line">  // This needs to happen before we read any handlers, because the effect of</span><br><span class="line">  // the previous event may influence which handlers are called during</span><br><span class="line">  // this event.</span><br><span class="line">  if (!isBatchingUpdates &amp;&amp; !isRendering &amp;&amp; lowestPendingInteractiveExpirationTime !== NoWork) &#123;</span><br><span class="line">    // Synchronously flush pending interactive updates.</span><br><span class="line">    performWork(lowestPendingInteractiveExpirationTime, false, null);</span><br><span class="line">    lowestPendingInteractiveExpirationTime = NoWork;</span><br><span class="line">  &#125;</span><br><span class="line">  var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates;</span><br><span class="line">  var previousIsBatchingUpdates = isBatchingUpdates;</span><br><span class="line">  isBatchingInteractiveUpdates = true;</span><br><span class="line">  isBatchingUpdates = true;  // 把requestWork中的isBatchingUpdates标识改为true</span><br><span class="line">  try &#123;</span><br><span class="line">    return fn(a, b);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;</span><br><span class="line">    isBatchingUpdates = previousIsBatchingUpdates;</span><br><span class="line">    if (!isBatchingUpdates &amp;&amp; !isRendering) &#123;</span><br><span class="line">      performSyncWork();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中把 <code>isBatchingUpdates</code> 设为了 <code>true</code> ,导致在 <code>requestWork</code> 方法中， <code>isBatchingUpdates</code> 为 <code>true</code> ，但是 <code>isUnbatchingUpdates</code> 是 <code>false</code> ，而被直接return了。</p><p>那return完的逻辑回到哪里呢，最终正是回到了 <code>interactiveUpdates</code> 这个方法，仔细看一眼，这个方法里面有个<a href="https://link.juejin.im?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fgrammar%2Ferror.html%23toc12" target="_blank" rel="noopener">try finally</a>语法，前端同学这个其实是用的比较少的，简单的说就是会先执行 <code>try</code> 代码块中的语句，然后再执行 <code>finally</code> 中的代码，而 <code>fn(a, b)</code> 是在try代码块中，刚才说到在 <code>requestWork</code> 中被return掉的也就是这个fn（上文提到的 <code>从dispatchEvent</code> 到 <code>requestWork</code> 的一整个调用栈）。</p><p>所以当你在 <code>increment</code> 中调用 <code>setState</code> 之后去console.log的时候，是属于 <code>try</code> 代码块中的执行，但是由于是合成事件，try代码块执行完state并没有更新，所以你输入的结果是更新前的 <code>state</code> 值，这就导致了所谓的”异步”，但是当你的try代码块执行完的时候（也就是你的increment合成事件），这个时候会去执行 <code>finally</code> 里的代码，在 <code>finally</code> 中执行了 <code>performSyncWork</code> 方法，这个时候才会去更新你的 <code>state</code> 并且渲染到UI上。</p><h3 id="二、生命周期函数中的setState"><a href="#二、生命周期函数中的setState" class="headerlink" title="二、生命周期函数中的setState"></a>二、生命周期函数中的<code>setState</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">   console.log(this.state.val) // 输出的还是更新前的值 --&gt; 0</span><br><span class="line"> &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;`Counter is: $&#123;this.state.val&#125;`&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>钩子函数中setState的调用栈：<br><img src="/2017/09/21/React-setState/3.webp" alt=""><br>其实还是和合成事件一样，当 <code>componentDidmount</code> 执行的时候，react内部并没有更新，执行完<code>componentDidmount</code>  后才去 <code>commitUpdateQueue</code> 更新。这就导致你在 <code>componentDidmount</code> 中 <code>setState</code> 完去console.log拿的结果还是更新前的值。</p><h3 id="三、原生事件中的setState"><a href="#三、原生事件中的setState" class="headerlink" title="三、原生事件中的setState"></a>三、原生事件中的<code>setState</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line">  changeValue = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    console.log(this.state.val) // 输出的是更新后的值 --&gt; 1</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    document.body.addEventListener(&apos;click&apos;, this.changeValue, false)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;`Counter is: $&#123;this.state.val&#125;`&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原生事件是指非react合成事件，原生自带的事件监听 <code>addEventListener</code> ，或者也可以用原生js、jq直接 <code>document.querySelector().onclick</code> 这种绑定事件的形式都属于原生事件。<br><img src="/2017/09/21/React-setState/4.webp" alt=""><br>原生事件的调用栈就比较简单了，因为没有走合成事件的那一大堆，直接触发click事件，到 <code>requestWork</code> ,在<code>requestWork</code>里由于 <code>expirationTime === Sync</code> 的原因，直接走了 <code>performSyncWork</code> 去更新，并不像合成事件或钩子函数中被return，所以当你在原生事件中setState后，能同步拿到更新后的state值。</p><h3 id="四、setTimeout中的setState"><a href="#四、setTimeout中的setState" class="headerlink" title="四、setTimeout中的setState"></a>四、setTimeout中的<code>setState</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    setTimeout(_ =&gt; &#123;</span><br><span class="line">      this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">      console.log(this.state.val) // 输出更新后的值 --&gt; 1</span><br><span class="line">    &#125;, 0)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;`Counter is: $&#123;this.state.val&#125;`&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>setTimeout</code> 中去 <code>setState</code> 并不算是一个单独的场景，它是随着你外层去决定的，因为你可以在合成事件中 <code>setTimeout</code> ，可以在钩子函数中 <code>setTimeout</code> ，也可以在原生事件<code>setTimeout</code>，但是不管是哪个场景下，基于<a href="https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D6XRNXXgP_0" target="_blank" rel="noopener">event loop</a>的模型下， <code>setTimeout</code> 中里去 <code>setState</code> 总能拿到最新的state值。</p><p>举个栗子，比如之前的合成事件，由于你是 <code>setTimeout(_ =&gt; { this.setState()}, 0)</code> 是在 <code>try</code> 代码块中,当你 <code>try</code> 代码块执行到 <code>setTimeout</code> 的时候，把它丢到列队里，并没有去执行，而是先执行的 <code>finally</code> 代码块，等 <code>finally</code> 执行完了， <code>isBatchingUpdates</code> 又变为了 <code>false</code> ，导致最后去执行队列里的 <code>setState</code> 时候， <code>requestWork</code> 走的是和原生事件一样的 <code>expirationTime === Sync</code> if分支，所以表现就会和原生事件一样，可以同步拿到最新的state值。</p><h3 id="五、setState中的批量更新"><a href="#五、setState中的批量更新" class="headerlink" title="五、setState中的批量更新"></a>五、<code>setState</code>中的批量更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line">  batchUpdates = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick=&#123;this.batchUpdates&#125;&gt;</span><br><span class="line">        &#123;`Counter is $&#123;this.state.val&#125;`&#125; // 1</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结果最终是1，在 <code>setState</code> 的时候react内部会创建一个 <code>updateQueue</code> ，通过 <code>firstUpdate</code> 、 <code>lastUpdate</code> 、 <code>lastUpdate.next</code> 去维护一个更新的队列，在最终的 <code>performWork</code> 中，相同的key会被覆盖，只会对最后一次的 <code>setState</code> 进行更新，下面是部分实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function createUpdateQueue(baseState) &#123;</span><br><span class="line">  var queue = &#123;</span><br><span class="line">    expirationTime: NoWork,</span><br><span class="line">    baseState: baseState,</span><br><span class="line">    firstUpdate: null,</span><br><span class="line">    lastUpdate: null,</span><br><span class="line">    firstCapturedUpdate: null,</span><br><span class="line">    lastCapturedUpdate: null,</span><br><span class="line">    firstEffect: null,</span><br><span class="line">    lastEffect: null,</span><br><span class="line">    firstCapturedEffect: null,</span><br><span class="line">    lastCapturedEffect: null</span><br><span class="line">  &#125;;</span><br><span class="line">  return queue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function appendUpdateToQueue(queue, update, expirationTime) &#123;</span><br><span class="line">  // Append the update to the end of the list.</span><br><span class="line">  if (queue.lastUpdate === null) &#123;</span><br><span class="line">    // Queue is empty</span><br><span class="line">    queue.firstUpdate = queue.lastUpdate = update;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    queue.lastUpdate.next = update;</span><br><span class="line">    queue.lastUpdate = update;</span><br><span class="line">  &#125;</span><br><span class="line">  if (queue.expirationTime === NoWork || queue.expirationTime &gt; expirationTime) &#123;</span><br><span class="line">    // The incoming update has the earliest expiration of any update in the</span><br><span class="line">    // queue. Update the queue&apos;s expiration time.</span><br><span class="line">    queue.expirationTime = expirationTime;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="看个demo"><a href="#看个demo" class="headerlink" title="看个demo"></a>看个demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123; val: 0 &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    console.log(this.state.val)</span><br><span class="line"></span><br><span class="line">    this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">    console.log(this.state.val)</span><br><span class="line"></span><br><span class="line">    setTimeout(_ =&gt; &#123;</span><br><span class="line">      this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">      console.log(this.state.val);</span><br><span class="line"></span><br><span class="line">      this.setState(&#123; val: this.state.val + 1 &#125;)</span><br><span class="line">      console.log(this.state.val)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;&#123;this.state.val&#125;&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面分析的，钩子函数中的 <code>setState</code> 无法立马拿到更新后的值，所以前两次都是输出0，当执行到 <code>setTimeout</code> 里的时候，前面两个state的值已经被更新，由于 <code>setState</code> 批量更新的策略， <code>this.state.val</code> 只对最后一次的生效，为1，而在 <code>setTimmout</code> 中 <code>setState</code> 是可以同步拿到更新结果，所以 <code>setTimeout</code> 中的两次输出2，3，最终结果就为 <code>0, 0, 2, 3</code> 。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结 :"></a>总结 :</h3><ol><li><strong><code>setState</code> 只在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。</strong></li><li><strong><code>setState</code>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</strong></li><li><strong><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 <code>setState</code> ， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 <code>setState</code> 多个不同的值，在更新时会对其进行合并批量更新。</strong></li></ol><p>以上就是我看了部分代码后的粗浅理解，对源码细节的那块分析的较少，主要是想让大家理解<code>setState</code>在不同的场景，不同的写法下到底发生了什么样的一个过程和结果，希望对大家有帮助，由于是个人的理解和见解，如果哪里有说的不对的地方，欢迎大家一起指出并讨论。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 必知必会</title>
      <link href="/2017/09/11/Git-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2017/09/11/Git-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统。</p><p>参考文章：</p><p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a54386af265da3e3b7a6317" target="_blank" rel="noopener">如何优雅地使用 Git - 掘金</a></p><h2 id="GIT-常见命令学习整理"><a href="#GIT-常见命令学习整理" class="headerlink" title="GIT 常见命令学习整理"></a><a href="https://link.zhihu.com/?target=https%3A//blog.ihoey.com/posts/Git/2017-04-23-git.html" target="_blank" rel="noopener">GIT 常见命令学习整理</a></h2><h2 id="GIT常用命令备忘"><a href="#GIT常用命令备忘" class="headerlink" title="GIT常用命令备忘"></a><a href="https://link.zhihu.com/?target=http%3A//stormzhang.com/git/2014/01/27/git-common-command/" target="_blank" rel="noopener">GIT常用命令备忘</a></h2><h2 id="Git远程操作详解"><a href="#Git远程操作详解" class="headerlink" title="Git远程操作详解"></a><a href="https://link.zhihu.com/?target=https%3A//microzz.com/2017/05/06/git/" target="_blank" rel="noopener">Git远程操作详解</a></h2><h2 id="一篇文章，教你学会Git"><a href="#一篇文章，教你学会Git" class="headerlink" title="一篇文章，教你学会Git"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/599e14875188251240632702" target="_blank" rel="noopener">一篇文章，教你学会Git</a></h2><h2 id="如何在-Git-中使用撤消操作"><a href="#如何在-Git-中使用撤消操作" class="headerlink" title="如何在 Git 中使用撤消操作"></a><a href="https://link.zhihu.com/?target=https%3A//egoist.moe/2015/10/04/how-to-undo-with-git/" target="_blank" rel="noopener">如何在 Git 中使用撤消操作</a></h2><h2 id="git使用中碰到的问题，持续更新"><a href="#git使用中碰到的问题，持续更新" class="headerlink" title="git使用中碰到的问题，持续更新"></a><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/a420344/article/details/51792303" target="_blank" rel="noopener">git使用中碰到的问题，持续更新</a></h2><h2 id="Git-的-4-个阶段的撤销更改"><a href="#Git-的-4-个阶段的撤销更改" class="headerlink" title="Git 的 4 个阶段的撤销更改"></a><a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/akvB2DO_1dpUrf-ol77MwQ" target="_blank" rel="noopener">Git 的 4 个阶段的撤销更改</a></h2><p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a30c1786fb9a045211eb218" target="_blank" rel="noopener">Git提交历史的修改删除合并 - 掘金</a></p><h2 id="IDEA中分支切换error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout"><a href="#IDEA中分支切换error-The-following-untracked-working-tree-files-would-be-overwritten-by-checkout" class="headerlink" title="IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout"></a><a href="https://link.zhihu.com/?target=http%3A//blog.csdn.net/tongxinxiao/article/details/43988773" target="_blank" rel="noopener">IDEA中分支切换error: The following untracked working tree files would be overwritten by checkout</a></h2><pre><code>直接执行git clean -d -fx即可。可能很多人都不明白-d，-fx到底是啥意思，其实git clean -d -fx表示：删除 一些 没有 git add 的 文件；    git clean 参数     -n 显示将要删除的文件和目录；    -x -----删除忽略文件已经对git来说不识别的文件    -d -----删除未被添加到git的路径中的文件    -f -----强制运行    git clean -n    git clean -df    git clean -f</code></pre><p><img src="https://pic3.zhimg.com/v2-81f3b33c3cb53387c97135459b92ab3f_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81f3b33c3cb53387c97135459b92ab3f_hd.jpg" alt=""></p><pre><code>git reflog        //该指令输出详细的操作历史，包括提交，操作，修改等修改注释git commit --amend 或 git commit --amend -m &quot;Fixes bug #42&quot;gitk 字符集编码：git config --global gui.encoding utf-8    //在git GUI中使用UTF-8编码 配置git config --global user.name &quot;ihoey&quot;           # 设置git用户名git config --global user.email &quot;mail@ihoey.com&quot; # 设置git邮箱git config --global color.ui true               # 为true是终端着色git config --global alias.co checkout           # 配置checkout的别名git config --global alias.ci commit             # 配置commit的别名git config --global alias.cm commit             # 配置commit的别名git config --global alias.st status             # 配置status的别名git config --global alias.br branch             # 配置branch的别名git config --global alias.cp cherry-pick        # 配置cherry-pick的别名 git config --global alias.rb rebase            # 配置rebase的别名git config --global core.editor &quot;mate -w&quot;       # 设置Editor使用textmategit config -l                                   # 列举所有配置#用户的git配置文件~/.gitconfigSSH 秘钥ssh-keygen -t rsa -C &quot;mail@ihoey.com&quot;# 连续3个回车。如果不需要密码的话。# 最后得到了两个文件：id_rsa和id_rsa.pub，在~/.ssh/文件夹下面# id_rsa为你的私钥，不可以告诉别人# id_rsa.pub为你的公钥，一般会放在你的服务器做ssh登录，或者放在github上面基本命令创建git仓库 git init添加文件到暂存区 git add fileName / git add .提交文件到仓库 git commit -m &quot;版本提交信息&quot;查看文件提交状态 git status查看文件修改的信息 git diff readme.txtgit help &lt;command&gt;          # 显示command的helpgit show                    # 显示某次提交的内容git show $idgit checkout  -- &lt;file&gt;     # 抛弃工作区修改git checkout  .             # 抛弃工作区修改git add &lt;file&gt;              # 将工作文件修改提交到本地暂存区git add .                   # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt;               # 从版本库中删除文件git rm &lt;file&gt; --cached      # 从版本库中删除文件，但不删除文件git reset &lt;file&gt;            # 从暂存区恢复到工作文件git reset -- .              # 从暂存区恢复到工作文件git reset --hard            # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git reset SHA1 ID           # 恢复指定提交git commit -m &quot;some comments&quot;git revert &lt;$id&gt;            # 恢复某次提交的状态，恢复动作本身也创建了一次提交对象git revert HEAD             # 恢复最后一次提交的状态查看文件git diff &lt;file&gt;                 # 比较当前文件和暂存区文件差异git diffgit diff &lt;$id1&gt; &lt;$id2&gt;          # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt;   # 在两个分支之间比较git diff --staged               # 比较暂存区和版本库差异git diff --cached               # 比较暂存区和版本库差异git diff --stat                 # 仅仅比较统计信息查看提交记录git loggit log &lt;file&gt;      # 查看该文件每次提交记录git log -p &lt;file&gt;   # 查看每次详细修改内容的diffgit log -p -2       # 查看最近两次详细修改内容的diffgit log --stat      # 查看提交统计信息分支管理git branch -l                           # 查看本地分支git branch -r                           # 查看远程分支git branch &lt;new_branch&gt;                 # 创建新的分支git branch -v                           # 查看各个分支最后提交信息git branch --merged                     # 查看已经被合并到当前分支的分支git branch --no-merged                  # 查看尚未被合并到当前分支的分支git checkout &lt;branch&gt;                   # 切换到某个分支git checkout -b &lt;new_branch&gt;            # 创建新的分支，并且切换过去git checkout -b &lt;new_branch&gt; &lt;branch&gt;   # 基于branch创建新的new_branchgit checkout $id       # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git checkout $id -b &lt;new_branch&gt;        # 把某次历史提交记录checkout出来，创建成一个分支git branch -d &lt;branch&gt;                  # 删除某个分支git branch -D &lt;branch&gt;    # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)强行切换分支git checkout -f branch_name强制checkout分支覆盖本地文件git checkout -f branchname分支合并和rebasegit merge &lt;branch&gt;               # 将branch分支合并到当前分支git merge --no-ff &lt;branch&gt;       # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt;       # 将master rebase到branch，相当于：git checkout &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git checkout master &amp;&amp; git merge &lt;branch&gt;</code></pre><ul><li>在我们操作过程中。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit 就可以了。</li><li><p>而rebase 操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行git rebase –continue继续操作，或者git rebase –skip忽略冲突。</p><p>  Git暂存管理<br>  git stash                        # 暂存<br>  git stash pop                    # 恢复暂存<br>  git stash list                   # 列所有stash<br>  git stash apply                  # 恢复暂存的内容<br>  git stash drop                   # 删除暂存区</p><p>  git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区<br>  git stash list：查看储藏队列(Stash lists)<br>  git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes))<br>  git stash clear：清空储藏队列<br>  git stash save “name of the stash”：为储藏设置命名<br>  git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏<br>  git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏)</p><p>  远程分支管理<br>  git pull                         # 抓取远程仓库所有分支更新并合并到本地<br>  git pull –no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并<br>  git fetch origin                 # 抓取远程仓库更新<br>  git merge origin/master          # 将远程主分支合并到本地当前分支<br>  git checkout –track origin/branch     # 跟踪某个远程分支创建相应的本地分支<br>  git checkout -b &lt;local_branch&gt; origin/&lt;remote_branch&gt;  # 基于远程分支创建本地分支，功能同上<br>  git push                         # push所有分支<br>  git push origin master           # 将本地主分支推到远程主分支<br>  git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)<br>  git push origin &lt;local_branch&gt;   # 创建远程分支， origin是远程仓库名<br>  git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支<br>  git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d <branch>)，然后再push删除远程分支</branch></p><p>  git删除远程分支<br>  git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限</p><p>  清空git暂存区<br>  git reset HEAD  //可以清空之前git add 的内容</p><p>  Git远程仓库管理<br>  git remote -v                    # 查看远程服务器地址和仓库名称<br>  git remote show origin           # 查看远程服务器仓库状态<br>  git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ihoey/blog.git     # 添加远程仓库地址<br>  git remote set-url origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:ihoey/blog.git # 设置远程仓库地址(用于修改远程仓库地址)<br>  git remote rm <repository>       # 删除远程仓库</repository></p><p>  创建远程仓库<br>  git clone –bare ihoey.com blog.git     # 用带版本的项目创建纯版本仓库<br>  scp -r my_blog.git <a href="mailto:git@ihoey.com" target="_blank" rel="noopener">git@ihoey.com</a>:~      # 将纯仓库上传到服务器上<br>  mkdir blog.git &amp;&amp; cd blog.git &amp;&amp; git –bare init # 在服务器创建纯仓库<br>  git push -u origin master         # 客户端首次提交<br>  git push -u origin develop        # 首次将本地develop分支提交到远程develop分支，并且track<br>  git remote set-head origin master # 设置远程仓库的HEAD指向master分支</p><p>  设置跟踪远程库和本地库<br>  git branch –set-upstream master origin/master      #master<br>  git branch –set-upstream develop origin/develop    #develop</p><p>  其他命令<br>  mkdir XX    #(创建一个空目录 XX指目录名)<br>  pwd         #显示当前目录的路径。<br>  cat XX      #查看XX文件内容<br>  rm  XX      #删除文件</p></li></ul><p>命令别名设置:</p><pre><code>gitk --all &amp;   //打开git 图形化界面git fetch --all  //刷新工作区    git remote -v  //查看远端地址git checkout -b dbg_master  -t origin/master   //基于远端master分支创建dbg_master分支git merge --squash &lt;branch&gt;：将多次提交合并成一个，然后git add .;git commit -m &quot;XXXXX&quot;;git push origin XXXX...git push                         # push所有分支git push origin master           # 将本地主分支推到远程主分支git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt;   # 创建远程分支， origin是远程仓库名git push origin local-branch     #将当前local-branch 分支推送一个远程local-branch分支，本地分支和远程分支同名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支，将local_branch代码推送到remote_branch分支git push origin :&lt;remote_branch&gt;  #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 对最近一次commit的进行修改：git commit -a –amend Git pull 强制覆盖本地文件  git fetch --all    git reset --hard origin/master   git pullgit remote add origin https://git.oschina.net/duandaoke/os.git要求服务已经建立同名仓库git remote # 显示远程仓库git remote -v # 显示远程仓库详情git remote show origin # 显示 origin 远程库的详情rebase的冲突解决   解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存）       git add -u   //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。   然后执行下面命令继续rebase：      git rebase --continue     //有冲突继续解决，重复这这些步骤，直到rebase完成。   如果中间遇到某个补丁不需要应用，可以用下面命令忽略：      git rebase --skip    如果想回到rebase执行之前的状态，可以执行：      git rebase --abort    //放弃rebase     注：rebase之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。cherry-pick的冲突解决   解决完一个补丁应用的冲突后，执行下面命令标记冲突已解决（也就是把修改内容加入缓存）       git add -u   //注：-u 表示把所有已track的文件的新的修改加入缓存，但不加入新的文件。   然后执行下面命令继续rebase：      git cherry-pick --continue     //有冲突继续解决，重复这这些步骤，直到cherry-pick完成。   如果中间遇到某个补丁不需要应用，可以用下面命令忽略：      git cherry-pick --skip    如果想回到rebase执行之前的状态，可以执行：      git cherry-pick  --abort    //放弃cherry-pick   注：cherry-pick之后，不需要执行commit，也不存在新的修改需要提交，都是git自动完成。       手动编辑冲突的文件，使其内容和master_mlc分支上的内容一致，        然后git add此文件，最后执行git cherry-pick –continue即可。 1、git删除远程分支git push origin ：branch-name //origin前面必须有空格，表示push一个空分支到远程分支，即可删除远程分支。注意：这个操作需要拥有force push的权限2、清空git暂存区git reset HEAD  //可以清空之前git add 的内容git clean命令用来从你的工作目录中删除所有没有tracked过的文件.    git clean经常和git reset --hard一起结合使用. 记住reset只影响被track过的文件, 所以需要clean来删除没有track过的文件. 结合使用这两个命令能让你的工作目录完全回到一个指定的&lt;commit&gt;的状态.用法删除当前目录下没有被track过的文件和文件夹.    git clean -xf下面的例子要删除所有工作目录下面的修改, 包括新添加的文件. 假设你已经提交了一些快照了, 而且做了一些新的开发.git reset --hardgit clean -df运行后, 工作目录和缓存区回到最近一次commit时候一摸一样的状态, git status会告诉你这是一个干净的工作目录, 又是一个新的开始了.git config --global gui.encoding utf-8    //在git GUI中使用UTF-8编码     //git 回滚到之前某一commitgit reset –hard 8ff24a6803173208f3e606e32dfcf82db9ac84d8在使用Git的时候,经过几次提交后,发现需要回退到早些时候的状态.例如: 7edb8524a xxxxxxxxxxxxxxxxxx 83dae5691 xxxxxxxxxxxxxxxxxx 45eadd642 xxxxxxxxxxxxxxxxxx 657834ade xxxxxxxxxxxxxxxxxx假设现在处于7edb8524a 状态,现在我想回退到657834ade时的状态,此时可以 git reset –hard 7edb8524a 然后 git reset –soft 657834ade 会将之间的修改全部进行revert,然后在进行add commit操作就行了.另外权限足够的话,可以从657834ade 拉一个分支出来,然后将远程分支 删除,再将拉出来的分支push到远程仓库上,成为原来的分支,也可以实现回退到 657834ade 的目的.此方法不会保留中间的各种修改信息和状态.根据–soft –mixed –hard，会对working tree和index和HEAD进行重置:    git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息    git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可    git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容已经push对于已经把代码push到线上仓库,你回退本地代码其实也想同时回退线上代码,回滚到某个指定的版本,线上,线下代码保持一致.你要用到下面的命令revertgit revert用于反转提交,执行evert命令时要求工作树必须是干净的.git revert用一个新提交来消除一个历史提交所做的任何修改.revert 之后你的本地代码会回滚到指定的历史版本,这时你再 git push 既可以把线上的代码更新.(这里不会像reset造成冲突的问题)revert 使用,需要先找到你想回滚版本唯一的commit标识代码,可以用 git log 或者在adgit搭建的web环境历史提交记录里查看.git revert c011eb3c20ba6fb38cc94fe5a8dda366a3990c61通常,前几位即可git revert c011eb3git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit看似达到的效果是一样的,其实完全不同.</code></pre><p>合理的命令别名设置可以大大减少输入，有助于提高工作效率，建议遵守下述别名设置：</p><pre><code>git config --global alias.ci commitgit config --global alias.co checkoutgit config --global alias.st statusgit config --global alias.rb rebasegit config --global alias.ll “log --oneline --decorate --color”git config --global alias.lc “log --graph --color”          </code></pre><p>正确的回车换行设置，避免 Unix 和 Windows 下开发的回车换行的转换问题。</p><pre><code>(Windows  下)git config --global core.autocrlf truegit config --global core. safecrlf warn(Linux  下)git config --global core.autocrlf inputgit config --global core. safecrlf warn</code></pre><p>基本命令</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;youremail@example.com&quot;git config --global core.editor &lt;your favorite editor here&gt;Ex: git config --global core.editor vimgit init：初始化一个repo，初始化本地git仓库（创建新仓库）</code></pre><p>Commit 结构</p><pre><code>git status(gst)：查看 repo 状态工作区：.git 目录暂存区工作目录</code></pre><p><img src="https://pic4.zhimg.com/v2-44aed332eb50ca594deeca86186012a8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-44aed332eb50ca594deeca86186012a8_hd.jpg" alt=""></p><pre><code>git add &lt;filename&gt;(ga)：添加一个文件到暂存区git add .(gaa)：添加所有文件到暂存区git add *.js：添加所有后缀为js的文件到暂存区git rm --cached &lt;file&gt;：从暂存区删除一个新文件git commit -m &quot;My first commit&quot;(gcmsg)：创建一次带 message 的提交git commit -v -a(gca)：-v是 verbose 的缩写，会在底部显示差异信息和更多有意义的信息-a 类似于 git add .，会添加所有被修改和删除的文件，但会忽略新创建的文件git help &lt;command&gt;：查看对应命令的帮助手册git log(glg,glgg,glo, glog)：查看项目的提交历史</code></pre><p>暂存区管理</p><pre><code>git reset HEAD &lt;filename&gt;(grh)：从暂存区删除一个被修改的文件git reset HEAD(grh)：从暂存区删除所有被修改的文件git checkout &lt;filename&gt;(gco)：从暂存区删除一个被修改的文件，并撤销文件的更改     //  git checkout .git commit -m &quot;My first commit&quot; --amend：添加文件/更改在暂存区的最后一次提交git commit -v -a --amend(gca!)：添加文件/更改在暂存区的最后一次提交.gitignore：告诉git，哪些文件不被加入版本跟踪可以使用 git add &lt;filename&gt; -f 命令添加一个不被版本跟踪的文件git diff &lt;filename&gt;(gd)：查看基于当前文件的最后一次提交的更改差异git diff (gd)：查看基于所有文件的最后一次提交的更改差异git reset HEAD~2 --soft：从项目提交历史中删除最近两次提交，但不丢弃文件的更改git reset HEAD~2 --hard：从项目提交历史中删除最近两次提交，但会丢弃文件的更改和在(最后两次)提交中创建的新文件git reset &lt;commit&gt; --soft --hard：--soft：将所有被更改的文件回溯到“待提交”状态--hard：commit 之后，对被git追踪的文件的任何更改都被丢弃git reflog：显示包括&quot;被撤销&quot;在内的所有提交git merge &lt;commit hash&gt;：重新提交(restore the commit)git clean -f：删除工作目录中不被git进行版本追踪的文件</code></pre><p>Stashed &amp; BranchesStash</p><pre><code>git stash(gsta)：将所有暂存区的文件移动到“储藏区”，类似于另一种类型的工作区git stash list：查看储藏队列(Stash lists)git stash apply：将最近一次储藏恢复到暂存区(可以用类似 git stash apply stash@{num}(num从0开始计数) 的命令来使用在队列中的任意一个储藏(stashes))git stash clear：清空储藏队列git stash save &quot;name of the stash&quot;：为储藏设置命名git stash pop(gstp)：将最近一次储藏恢复到暂存区并从储藏队列删除此储藏git stash drop(gstd)：从储藏队列删除最近一次储藏(stash@{0})(git stash drop stash@{num} 从储藏队列删除指定储藏)</code></pre><p>Branch</p><pre><code>git checkout -b dev(gco)：创建 dev 分支并从当前分支切换到 dev 分支      //  git checkout -b dbg_master  -t origin/master   //基于master分支创建dbg_master分支git branch(gb)：查看所有分支git checkout master(gcm)：切换到主分支git merge &lt;branch&gt;(gm)：合并分支git rebase master：先将 master 上的更改合并到当前分支，再添加当前分支的更改。如果有冲突，解决冲突后加 --continue 参数继续合并git branch -d &lt;branch&gt;： 删除分支，-D 则强制删除分支git merge &lt;branch&gt; --squash：将多次提交合并成一个，其流程如下：# Go to the `master` branchgit checkout master# Create a temp branchgit checkout -b temp# Merge the feature/x branch into the temp using --squashgit merge feature/x --squash# See the new modifications/files in the Staging Areagit status# Create the unified commitgit commit -m &quot;Add feature/x&quot;# Delete the feature/x branchgit branch -D feature/x</code></pre><ul><li><p>rebase 和 merge 的区别：</p><p>  rebase:<br>  提交历史(的展示)是线性的<br>  缺点：会删除最近一个 commit，然后创建一次新的 commit<br>  如果已提交到远程，不要使用 rebase</p><p>  merge:<br>  提交历史(的展示)是分叉的<br>  对于两个分支的合并，会创建一个次新的 commit</p></li></ul><p>远程仓库管理</p><pre><code>git remote add &lt;name&gt; &lt;url&gt;：添加一个将被追踪的远程仓库git remote rm &lt;name&gt;：移除一个远程仓库git push &lt;remote&gt; &lt;remote-branch&gt;(gp,ggp)：将当前分支的本地 commit 推送到远程仓库git fetch &lt;remote&gt; &lt;remote-branch&gt;：拉取远程仓库的最新 commit 到当前(本地)分支(&lt;remote&gt;/&lt;branch&gt;)，不会合并git pull &lt;remote&gt; &lt;remote-branch&gt;(gl,ggl)：拉取远程仓库的最新 commit 到当前(本地)分支，并自动 mergegit pull --rebase(gup)：以 rebase 的方式进行合并，而不是 merge</code></pre><p>其它有用的命令</p><pre><code>git tag &lt;name&gt;：创建一个 tag(如：v1.3)git push --tags：将本地 tags 推送到远程仓库git push &lt;tag&gt;：推送指定的本地 tag 到远程展示帮助信息git help -g回到远程仓库的状态抛弃本地所有的修改，回到远程仓库的状态。git fetch --all &amp;&amp; git reset --hard origin/master重设第一个commit也就是把所有的改动都重新放回工作区，并清空所有的commit，这样就可以重新提交第一个commit了git update-ref -d HEAD展示工作区和暂存区的不同输出工作区和暂存区的different(不同)。git diff还可以展示本地仓库中任意两个commit之间的文件变动：git diff &lt;commit-id&gt; &lt;commit-id&gt;展示暂存区和最近版本的不同输出暂存区和本地最近的版本(commit)的different(不同)。git diff --cached展示暂存区、工作区和最近版本的不同输出工作区、暂存区 和本地最近的版本(commit)的different(不同)。git diff HEAD快速切换分支git checkout -删除已经合并到master的分支git branch --merged master | grep -v &apos;^\*\|  master&apos; | xargs -n 1 git branch -d展示本地分支关联远程仓库的情况git branch -vv关联远程分支关联之后，git branch -vv就可以展示关联的远程分支名了，同时推送到远程仓库直接：git push，不需要指定远程仓库了。git branch -u origin/mybranch或者在push时加上-u参数git push origin/mybranch -u列出所有本地分支-l参数相当于：localgit branch -l列出所有远程分支-r参数相当于：remotegit branch -r列出本地和远程分支-a参数相当于：allgit branch -a创建并切换到本地分支git checkout -b &lt;branch-name&gt;创建并切换到远程分支git checkout -b &lt;branch-name&gt; -t origin/&lt;branch-name&gt;删除本地分支git branch -d &lt;local-branchname&gt;删除远程分支git push origin --delete &lt;remote-branchname&gt;或者git push origin :&lt;remote-branchname&gt;重命名本地分支git branch -m &lt;new-branch-name&gt;git branch -m &lt;oldbranchname&gt; &lt;newbranchname&gt;：尝试修改git branch -M &lt;oldbranchname&gt; &lt;newbranchname&gt;：强制修改查看标签git tag展示当前分支的最近的taggit describe --tags --abbrev=0本地创建标签git tag &lt;version-number&gt;默认tag是打在最近的一次commit上，如果需要指定commit打tag：$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;推送标签到远程仓库首先要保证本地创建好了标签才可以推送标签到远程仓库：git push origin &lt;local-version-number&gt;一次性推送所有标签，同步到远程仓库：git push origin --tags删除本地标签git tag -d &lt;tag-name&gt;删除远程标签删除远程标签需要先删除本地标签，再执行下面的命令：git push origin :refs/tags/&lt;tag-name&gt;切回到某个标签一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：git checkout -b branch_name tag_name放弃工作区的修改git checkout &lt;file-name&gt;放弃所有修改：git checkout .恢复删除的文件git rev-list -n 1 HEAD -- &lt;file_path&gt; #得到 deleting_commitgit checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt; #回到删除文件 deleting_commit 之前的状态回到某一个commit的状态，并重新增添一个commit  //回退，有记录git revert &lt;commit-id&gt;回到某个commit的状态，并删除后面的commit和revert的区别：reset命令会抹去某个commit id之后的所有commitgit reset &lt;commit-id&gt;修改上一个commit的描述git commit --amend查看commit历史git log查看某段代码是谁写的blame的意思为‘责怪’，你懂的。git blame &lt;file-name&gt;显示本地执行过git命令就像shell的history一样git reflog修改作者名git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos;修改远程仓库的urlgit remote set-url origin &lt;URL&gt;增加远程仓库git remote add origin &lt;remote-url&gt;列出所有远程仓库git remote    //  git remote -v查看两个星期内的改动git whatchanged --since=&apos;2 weeks ago&apos;把A分支的某一个commit，放到B分支上这个过程需要cherry-pick命令，参考git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;给git命令起别名简化命令git config --global alias.&lt;handle&gt; &lt;command&gt;比如：git status 改成 git st，这样可以简化命令git config --global alias.st status存储当前的修改，但不用提交commit详解可以参考廖雪峰老师的git教程git stash保存当前状态，包括untracked的文件untracked文件：新建的文件git stash -u展示所有stashesgit stash list回到某个stash的状态git stash apply &lt;stash@{n}&gt;回到最后一个stash的状态，并删除这个stashgit stash pop删除所有的stashgit stash clear从stash中拿出某个文件的修改git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt;展示所有tracked的文件git ls-files -t展示所有untracked的文件git ls-files --others展示所有忽略的文件git ls-files --others -i --exclude-standard强制删除untracked的文件可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。clean命令，注意两点：clean后，删除的文件无法找回不会影响tracked的文件的改动，只会删除untracked的文件git clean &lt;file-name&gt; -f强制删除untracked的目录可以用来删除新建的目录，注意:这个命令也可以用来删除untracked的文件。详情见上一条git clean &lt;directory-name&gt; -df展示简化的commit历史git log --pretty=oneline --graph --decorate --all把某一个分支到导出成一个文件git bundle create &lt;file&gt; &lt;branch-name&gt;从包中导入分支新建一个分支，分支内容就是上面git bundle create命令导出的内容git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;执行rebase之前自动stashgit rebase --autostash从远程仓库根据ID，拉下某一状态，到本地分支git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;详细展示一行中的修改git diff --word-diff清除gitignore文件中记录的文件git clean -X -f展示所有alias和configs注意： config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的configgit config --local --list (当前目录)git config --global --list (全局)展示忽略的文件git status --ignoredcommit历史中显示Branch1有的，但是Branch2没有commitgit log Branch1 ^Branch2在commit log中显示GPG签名git log --show-signature删除全局设置git config --global --unset &lt;entry-name&gt;新建并切换到新分支上，同时这个分支没有任何commit相当于保存修改，但是重写commit历史git checkout --orphan &lt;branch-name&gt;展示任意分支某一文件的内容git show &lt;branch-name&gt;:&lt;file-name&gt;clone下来指定的单一分支git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git忽略某个文件的改动关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动git update-index --assume-unchanged path/to/file恢复 track 指定文件的改动git update-index --no-assume-unchanged path/to/file忽略文件的权限变化不再将文件的权限变化视作改动git config core.fileMode false展示本地所有的分支的commit最新的放在最上面git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/在commit log中查找相关内容通过grep查找，given-text：所需要查找的字段git log --all --grep=&apos;&lt;given-text&gt;&apos;把暂存区的指定file放到工作区中git reset &lt;file-name&gt;强制推送git push -f &lt;remote-name&gt; &lt;branch-name&gt;列出所有远程分支-r参数相当于：remotegit branch -r更新到本地# 源 + 分支名git pull origin master</code></pre><p>初始化本地git仓库（创建新仓库）</p><pre><code>git init                                               # 初始化 git 项目git init安装好 Git 之后，配置你的资料:# 配置用户名git config --global user.name &quot;Your Real Name&quot;# 配置邮箱地址git config --global user.email you@email.address</code></pre><p>配置用户名</p><pre><code>git config --global user.name &quot;xxx&quot;                       </code></pre><p>配置邮件</p><pre><code>git config --global user.email &quot;xxx@xxx.com&quot;              </code></pre><p>git status等命令自动着色</p><pre><code>git config --global color.ui true                         git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive auto</code></pre><p>clone远程仓库</p><pre><code>git clone git+ssh://git@192.168.53.168/VT.git             </code></pre><p>查看当前版本状态（是否修改）</p><pre><code>git status                                                </code></pre><p>添加xyz文件至index</p><pre><code>git add xyz                                               </code></pre><p>增加当前子目录下所有更改过的文件至index</p><pre><code>git add .                                                 </code></pre><p>提交</p><pre><code>git commit -m &apos;xxx&apos;                                       </code></pre><p>合并上一次提交（用于反复修改）</p><pre><code>git commit --amend -m &apos;xxx&apos;                               </code></pre><p>将add和commit合为一步</p><pre><code>git commit -am &apos;xxx&apos;                                      </code></pre><p>删除index中的文件</p><pre><code>git rm xxx                                                </code></pre><p>递归删除</p><pre><code>git rm -r *                                               </code></pre><p>显示提交日志</p><pre><code>git log                                                   </code></pre><p>显示1行日志 -n为n行</p><pre><code>git log -1                                                </code></pre><p>git log -5</p><p>显示提交日志及相关变动文件</p><pre><code>git log --stat                                            </code></pre><p>git log -p -m</p><p>显示某个提交的详细内容</p><pre><code>git show dfb02e6e4f2f7b573337763e5c0013802e392818         </code></pre><p>可只用commitid的前几位</p><pre><code>git show dfb02                                            </code></pre><p>显示HEAD提交日志</p><pre><code>git show HEAD                                             </code></pre><p>显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</p><pre><code>git show HEAD^                                            </code></pre><p>显示已存在的tag</p><pre><code>git tag                                                   </code></pre><p>增加v2.0的tag</p><pre><code>git tag -a v2.0 -m &apos;xxx&apos;                                  </code></pre><p>显示v2.0的日志及详细内容</p><pre><code>git show v2.0                                             </code></pre><p>显示v2.0的日志</p><pre><code>git log v2.0                                              </code></pre><p>显示所有未添加至index的变更</p><pre><code>git diff                                                  </code></pre><p>显示所有已添加index但还未commit的变更</p><pre><code>git diff --cached                                         </code></pre><p>比较与上一个版本的差异</p><pre><code>git diff HEAD^                                            </code></pre><p>比较与HEAD版本lib目录的差异</p><pre><code>git diff HEAD -- ./lib                                    </code></pre><p>比较远程分支master上有本地分支master上没有的</p><pre><code>git diff origin/master..master                            </code></pre><p>只显示差异的文件，不显示具体内容</p><pre><code>git diff origin/master..master --stat                     </code></pre><p>增加远程定义（用于push/pull/fetch）</p><pre><code>git remote add origin git+ssh://git@192.168.53.168/VT.git </code></pre><p>显示本地分支</p><pre><code>git branch                                                </code></pre><p>显示包含提交50089的分支</p><pre><code>git branch --contains 50089                               </code></pre><p>显示所有分支</p><pre><code>git branch -a                                             </code></pre><p>显示所有原创分支</p><pre><code>git branch -r                                             </code></pre><p>显示所有已合并到当前分支的分支</p><pre><code>git branch --merged                                       </code></pre><p>显示所有未合并到当前分支的分支</p><pre><code>git branch --no-merged                                    </code></pre><p>本地分支改名</p><pre><code>git branch -m master master_copy                          </code></pre><p>从当前分支创建新分支master_copy并检出</p><pre><code>git checkout -b master_copy                               </code></pre><p>上面的完整版</p><pre><code>git checkout -b master master_copy                        </code></pre><p>检出已存在的features/performance分支</p><pre><code>git checkout features/performance                         </code></pre><p>检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</p><pre><code>git checkout --track hotfixes/BJVEP933                    </code></pre><p>检出版本v2.0</p><pre><code>git checkout v2.0                                         </code></pre><p>从远程分支develop创建新本地分支devel并检出</p><pre><code>git checkout -b devel origin/develop                      </code></pre><p>检出head版本的README文件（可用于修改错误回退）</p><pre><code>git checkout -- README                                    </code></pre><p>合并远程master分支至当前分支</p><pre><code>git merge origin/master                                   </code></pre><p>合并提交ff44785404a8e的修改</p><pre><code>git cherry-pick ff44785404a8e                             </code></pre><p>将当前分支push到远程master分支</p><pre><code>git push origin master                                    </code></pre><p>删除远程仓库的hotfixes/BJVEP933分支</p><pre><code>git push origin :hotfixes/BJVEP933                        </code></pre><p>把所有tag推送到远程仓库</p><pre><code>git push --tags                                           </code></pre><p>获取所有远程分支（不更新本地分支，另需merge）</p><pre><code>git fetch                                                 </code></pre><p>获取所有原创分支并清除服务器上已删掉的分支</p><pre><code>git fetch --prune                                         </code></pre><p>获取远程分支master并merge到当前分支</p><pre><code>git pull origin master                                    </code></pre><p>重命名文件README为README2</p><pre><code>git mv README README2                                     </code></pre><p>将当前版本重置为HEAD（通常用于merge失败回退）</p><pre><code>git reset --hard HEAD                                     </code></pre><p>git rebase</p><p>删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</p><pre><code>git branch -d hotfixes/BJVEP933                           </code></pre><p>强制删除分支hotfixes/BJVEP933</p><pre><code>git branch -D hotfixes/BJVEP933                           </code></pre><p>列出git index包含的文件</p><pre><code>git ls-files                                              </code></pre><p>图示当前分支历史</p><pre><code>git show-branch                                           </code></pre><p>图示所有分支历史</p><pre><code>git show-branch --all                                     </code></pre><p>显示提交历史对应的文件修改</p><pre><code>git whatchanged                                           </code></pre><p>撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</p><pre><code>git revert dfb02e6e4f2f7b573337763e5c0013802e392818       </code></pre><p>内部命令：显示某个git对象</p><pre><code>git ls-tree HEAD                                          </code></pre><p>内部命令：显示某个ref对于的SHA1 HASH</p><pre><code>git rev-parse v2.0                                        </code></pre><p>显示所有提交，包括孤立节点</p><pre><code>git reflog                                                </code></pre><p>git show HEAD@{5}</p><p>显示master分支昨天的状态</p><pre><code>git show master@{yesterday}                               </code></pre><p>图示提交日志</p><pre><code>git log --pretty=format:&apos;%h %s&apos; --graph                   git show HEAD~3git show -s --pretty=raw 2be7fcb476</code></pre><p>暂存当前修改，将所有至为HEAD状态</p><pre><code>git stash                                                 </code></pre><p>查看所有暂存</p><pre><code>git stash list                                            </code></pre><p>参考第一次暂存</p><pre><code>git stash show -p stash@{0}                               </code></pre><p>应用第一次暂存</p><pre><code>git stash apply stash@{0}                                 </code></pre><p>文件中搜索文本“delete from”</p><pre><code>git grep &quot;delete from&quot;                                    git grep -e &apos;#define&apos; --and -e SORT_DIRENTgit gcgit fsck</code></pre><hr><ol><li><strong>一定要先测试命令的效果后</strong>，再用于工作环境中，以防造成不能弥补的后果！<strong>到时候别拿着砍刀来找我</strong></li><li>所有的命令都在<code>git version 2.7.4 (Apple Git-66)</code>下测试通过</li><li>统一概念：</li></ol><ul><li>工作区：改动（增删文件和内容）</li><li>暂存区：输入命令：<code>git add 改动的文件名</code>，此次改动就放到了‘暂存区’</li><li>本地仓库(简称：本地)：输入命令：<code>git commit 此次修改的描述</code>，此次改动就放到了’本地仓库’，每个commit，我叫它为一个‘版本’。</li><li>远程仓库(简称：远程)：输入命令：<code>git push 远程仓库</code>，此次改动就放到了‘远程仓库’（GitHub等)</li><li>commit-id：输出命令：<code>git log</code>，最上面那行<code>commit xxxxxx</code>，后面的字符串就是commit-id</li></ul><h2 id="展示帮助信息"><a href="#展示帮助信息" class="headerlink" title="展示帮助信息"></a>展示帮助信息</h2><pre><code>git help -g</code></pre><h2 id="回到远程仓库的状态"><a href="#回到远程仓库的状态" class="headerlink" title="回到远程仓库的状态"></a>回到远程仓库的状态</h2><p>抛弃本地所有的修改，回到远程仓库的状态。</p><pre><code>gitfetch--all&amp;&amp;gitreset--hardorigin/master</code></pre><h2 id="重设第一个commit"><a href="#重设第一个commit" class="headerlink" title="重设第一个commit"></a>重设第一个commit</h2><p>也就是把所有的改动都重新放回工作区，并<strong>清空所有的commit</strong>，这样就可以重新提交第一个commit了</p><pre><code>git update-ref -d HEAD</code></pre><h2 id="展示工作区和暂存区的不同"><a href="#展示工作区和暂存区的不同" class="headerlink" title="展示工作区和暂存区的不同"></a>展示工作区和暂存区的不同</h2><p>输出<strong>工作区</strong>和<strong>暂存区</strong>的different(不同)。</p><pre><code>git diff</code></pre><p>还可以展示本地仓库中任意两个commit之间的文件变动：</p><pre><code>git diff &lt;commit-id&gt; &lt;commit-id&gt;</code></pre><h2 id="展示暂存区和最近版本的不同"><a href="#展示暂存区和最近版本的不同" class="headerlink" title="展示暂存区和最近版本的不同"></a>展示暂存区和最近版本的不同</h2><p>输出<strong>暂存区</strong>和本地最近的版本(commit)的different(不同)。</p><pre><code>git diff --cached</code></pre><h2 id="展示暂存区、工作区和最近版本的不同"><a href="#展示暂存区、工作区和最近版本的不同" class="headerlink" title="展示暂存区、工作区和最近版本的不同"></a>展示暂存区、工作区和最近版本的不同</h2><p>输出<strong>工作区</strong>、<strong>暂存区</strong> 和本地最近的版本(commit)的different(不同)。</p><pre><code>git diff HEAD</code></pre><h2 id="快速切换分支"><a href="#快速切换分支" class="headerlink" title="快速切换分支"></a>快速切换分支</h2><pre><code>git checkout -</code></pre><h2 id="删除已经合并到master的分支"><a href="#删除已经合并到master的分支" class="headerlink" title="删除已经合并到master的分支"></a>删除已经合并到master的分支</h2><pre><code>git branch --merged master| grep -v &apos;^\*\|  master&apos; | xargs -n 1 git branch -d</code></pre><h2 id="展示本地分支关联远程仓库的情况"><a href="#展示本地分支关联远程仓库的情况" class="headerlink" title="展示本地分支关联远程仓库的情况"></a>展示本地分支关联远程仓库的情况</h2><pre><code>gitbranch -vv</code></pre><h2 id="关联远程分支"><a href="#关联远程分支" class="headerlink" title="关联远程分支"></a>关联远程分支</h2><p>关联之后，<code>git branch -vv</code>就可以展示关联的远程分支名了，同时推送到远程仓库直接：<code>git push</code>，不需要指定远程仓库了。</p><pre><code>gitbranch -u origin/mybranch</code></pre><p>或者在push时加上<code>-u</code>参数</p><pre><code>git pushorigin/mybranch -u</code></pre><h2 id="列出所有远程分支"><a href="#列出所有远程分支" class="headerlink" title="列出所有远程分支"></a>列出所有远程分支</h2><p>-r参数相当于：remote</p><pre><code>git branch -r</code></pre><h2 id="列出本地和远程分支"><a href="#列出本地和远程分支" class="headerlink" title="列出本地和远程分支"></a>列出本地和远程分支</h2><p>-a参数相当于：all</p><pre><code>git branch -a</code></pre><h2 id="创建并切换到本地分支"><a href="#创建并切换到本地分支" class="headerlink" title="创建并切换到本地分支"></a>创建并切换到本地分支</h2><pre><code>git checkout -b &lt;branch-name&gt;</code></pre><h2 id="创建并切换到远程分支"><a href="#创建并切换到远程分支" class="headerlink" title="创建并切换到远程分支"></a>创建并切换到远程分支</h2><pre><code>git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;</code></pre><h2 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h2><pre><code>git branch -d &lt;local-branchname&gt;</code></pre><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><pre><code>git pushorigin --delete &lt;remote-branchname&gt;</code></pre><p>或者</p><pre><code>git push origin :&lt;remote-branchname&gt;</code></pre><h2 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h2><pre><code>git branch -m &lt;new-branch-name&gt;</code></pre><h2 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h2><pre><code>git tag</code></pre><p>展示当前分支的最近的tag</p><pre><code>gitdescribe--tags--abbrev=0</code></pre><h2 id="本地创建标签"><a href="#本地创建标签" class="headerlink" title="本地创建标签"></a>本地创建标签</h2><pre><code>git tag&lt;version-number&gt;</code></pre><p>默认tag是打在最近的一次commit上，如果需要指定commit打tag：</p><pre><code>$ git tag -a &lt;version-number&gt; -m &quot;v1.0 发布(描述)&quot; &lt;commit-id&gt;</code></pre><h2 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h2><p>首先要保证本地创建好了标签才可以推送标签到远程仓库：</p><pre><code>git push origin &lt;local-version-number&gt;</code></pre><p>一次性推送所有标签，同步到远程仓库：</p><pre><code>git pushorigin --tags</code></pre><h2 id="删除本地标签"><a href="#删除本地标签" class="headerlink" title="删除本地标签"></a>删除本地标签</h2><pre><code>git tag-d&lt;tag-name&gt;</code></pre><h2 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h2><p>删除远程标签需要<strong>先删除本地标签</strong>，再执行下面的命令：</p><pre><code>git push origin :refs/tags/&lt;tag-name&gt;</code></pre><h2 id="切回到某个标签"><a href="#切回到某个标签" class="headerlink" title="切回到某个标签"></a>切回到某个标签</h2><p>一般上线之前都会打tag，就是为了防止上线后出现问题，方便快速回退到上一版本。下面的命令是回到某一标签下的状态：</p><pre><code>git checkout -b branch_name tag_name</code></pre><h2 id="放弃工作区的修改"><a href="#放弃工作区的修改" class="headerlink" title="放弃工作区的修改"></a>放弃工作区的修改</h2><pre><code>git checkout &lt;file-name&gt;</code></pre><p>放弃所有修改：</p><pre><code>git checkout .</code></pre><h2 id="恢复删除的文件"><a href="#恢复删除的文件" class="headerlink" title="恢复删除的文件"></a>恢复删除的文件</h2><pre><code>git rev-list -n 1 HEAD -- &lt;file_path&gt;#得到 deleting_commitgit checkout &lt;deleting_commit&gt;^ -- &lt;file_path&gt;#回到删除文件 deleting_commit 之前的状态</code></pre><h2 id="以新增一个commit的方式还原某一个commit的修改"><a href="#以新增一个commit的方式还原某一个commit的修改" class="headerlink" title="以新增一个commit的方式还原某一个commit的修改"></a>以新增一个commit的方式还原某一个commit的修改</h2><pre><code>git revert &lt;commit-id&gt;</code></pre><h2 id="回到某个commit的状态，并删除后面的commit"><a href="#回到某个commit的状态，并删除后面的commit" class="headerlink" title="回到某个commit的状态，并删除后面的commit"></a>回到某个commit的状态，并删除后面的commit</h2><p>和revert的区别：reset命令会抹去某个commit id之后的所有commit</p><pre><code>git reset &lt;commit-id&gt;  #默认就是-mixed参数。git reset –mixed HEAD^  #回退至上个版本，它将重置HEAD到另外一个commit,并且重置暂存区以便和HEAD相匹配，但是也到此为止。工作区不会被更改。git reset –soft HEAD~3  #回退至三个版本之前，只回退了commit的信息，暂存区和工作区与回退之前保持一致。如果还要提交，直接commit即可   git reset –hard &lt;commit-id&gt;  #彻底回退到指定commit-id的状态，暂存区和工作区也会变为指定commit-id版本的内容</code></pre><h2 id="修改上一个commit的描述"><a href="#修改上一个commit的描述" class="headerlink" title="修改上一个commit的描述"></a>修改上一个commit的描述</h2><pre><code>git commit--amend</code></pre><h2 id="查看commit历史"><a href="#查看commit历史" class="headerlink" title="查看commit历史"></a>查看commit历史</h2><pre><code>git log</code></pre><h2 id="查看某段代码是谁写的"><a href="#查看某段代码是谁写的" class="headerlink" title="查看某段代码是谁写的"></a>查看某段代码是谁写的</h2><p>blame的意思为‘责怪’，你懂的。</p><pre><code>git blame &lt;file-name&gt;</code></pre><h2 id="显示本地更新过HEAD的git命令记录"><a href="#显示本地更新过HEAD的git命令记录" class="headerlink" title="显示本地更新过HEAD的git命令记录"></a>显示本地更新过HEAD的git命令记录</h2><p>每次更新了HEAD 的git 命令比如 commint、amend、cherry-pick、reset、revert等都会被记录下来（不限分支），就像shell的history一样。<br>这样你可以reset 到任何一次更新了HEAD 的操作之后，而不仅仅是回到当前分支下的某个commit 之后的状态。</p><pre><code>git reflog</code></pre><h2 id="修改作者名"><a href="#修改作者名" class="headerlink" title="修改作者名"></a>修改作者名</h2><pre><code>git commit --amend --author=&apos;Author Name &lt;email@address.com&gt;&apos;</code></pre><h2 id="修改远程仓库的url"><a href="#修改远程仓库的url" class="headerlink" title="修改远程仓库的url"></a>修改远程仓库的url</h2><pre><code>git remote set-urlorigin &lt;URL&gt;</code></pre><h2 id="增加远程仓库"><a href="#增加远程仓库" class="headerlink" title="增加远程仓库"></a>增加远程仓库</h2><pre><code>git remote add origin &lt;remote-url&gt;</code></pre><h2 id="列出所有远程仓库"><a href="#列出所有远程仓库" class="headerlink" title="列出所有远程仓库"></a>列出所有远程仓库</h2><pre><code>git remote</code></pre><h2 id="查看两个星期内的改动"><a href="#查看两个星期内的改动" class="headerlink" title="查看两个星期内的改动"></a>查看两个星期内的改动</h2><pre><code>git whatchanged --since=&apos;2 weeks ago&apos;</code></pre><h2 id="把A分支的某一个commit，放到B分支上"><a href="#把A分支的某一个commit，放到B分支上" class="headerlink" title="把A分支的某一个commit，放到B分支上"></a>把A分支的某一个commit，放到B分支上</h2><p>这个过程需要<code>cherry-pick</code>命令，<a href="http://sg552.iteye.com/blog/1300713#bc2367928" target="_blank" rel="noopener">参考</a></p><pre><code>git checkout &lt;branch-name&gt; &amp;&amp; git cherry-pick &lt;commit-id&gt;</code></pre><h2 id="给git命令起别名"><a href="#给git命令起别名" class="headerlink" title="给git命令起别名"></a>给git命令起别名</h2><p>简化命令</p><pre><code>git config --globalalias.&lt;handle&gt; &lt;command&gt;比如：git status 改成 git st，这样可以简化命令git config --globalalias.st status</code></pre><h2 id="存储当前的修改，但不用提交commit"><a href="#存储当前的修改，但不用提交commit" class="headerlink" title="存储当前的修改，但不用提交commit"></a>存储当前的修改，但不用提交commit</h2><p>详解可以参考<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137602359178794d966923e5c4134bc8bf98dfb03aea3000" target="_blank" rel="noopener">廖雪峰老师的git教程</a></p><pre><code>git stash</code></pre><h2 id="保存当前状态，包括untracked的文件"><a href="#保存当前状态，包括untracked的文件" class="headerlink" title="保存当前状态，包括untracked的文件"></a>保存当前状态，包括untracked的文件</h2><p>untracked文件：新建的文件</p><pre><code>git stash -u</code></pre><h2 id="展示所有stashes"><a href="#展示所有stashes" class="headerlink" title="展示所有stashes"></a>展示所有stashes</h2><pre><code>git stash list</code></pre><h2 id="回到某个stash的状态"><a href="#回到某个stash的状态" class="headerlink" title="回到某个stash的状态"></a>回到某个stash的状态</h2><pre><code>git stash apply &lt;stash@{n}&gt;</code></pre><h2 id="回到最后一个stash的状态，并删除这个stash"><a href="#回到最后一个stash的状态，并删除这个stash" class="headerlink" title="回到最后一个stash的状态，并删除这个stash"></a>回到最后一个stash的状态，并删除这个stash</h2><pre><code>git stash pop</code></pre><h2 id="删除所有的stash"><a href="#删除所有的stash" class="headerlink" title="删除所有的stash"></a>删除所有的stash</h2><pre><code>git stash clear</code></pre><h2 id="从stash中拿出某个文件的修改"><a href="#从stash中拿出某个文件的修改" class="headerlink" title="从stash中拿出某个文件的修改"></a>从stash中拿出某个文件的修改</h2><pre><code>git checkout &lt;stash@{n}&gt; -- &lt;file-path&gt;</code></pre><h2 id="展示所有tracked的文件"><a href="#展示所有tracked的文件" class="headerlink" title="展示所有tracked的文件"></a>展示所有tracked的文件</h2><pre><code>git ls-files -t</code></pre><h2 id="展示所有untracked的文件"><a href="#展示所有untracked的文件" class="headerlink" title="展示所有untracked的文件"></a>展示所有untracked的文件</h2><pre><code>git ls-files--others</code></pre><h2 id="展示所有忽略的文件"><a href="#展示所有忽略的文件" class="headerlink" title="展示所有忽略的文件"></a>展示所有忽略的文件</h2><pre><code>gitls-files--others-i--exclude-standard</code></pre><h2 id="强制删除untracked的文件"><a href="#强制删除untracked的文件" class="headerlink" title="强制删除untracked的文件"></a>强制删除untracked的文件</h2><p>可以用来删除新建的文件。如果不指定文件文件名，则清空所有工作的untracked文件。<code>clean</code>命令，<strong>注意两点</strong>：</p><ol><li>clean后，删除的文件无法找回</li><li><p>不会影响tracked的文件的改动，只会删除untracked的文件</p><p> git clean <file-name> -f</file-name></p></li></ol><h2 id="强制删除untracked的目录"><a href="#强制删除untracked的目录" class="headerlink" title="强制删除untracked的目录"></a>强制删除untracked的目录</h2><p>可以用来删除新建的目录，<strong>注意</strong>:这个命令也可以用来删除untracked的文件。详情见上一条</p><pre><code>git clean &lt;directory-name&gt; -df</code></pre><h2 id="展示简化的commit历史"><a href="#展示简化的commit历史" class="headerlink" title="展示简化的commit历史"></a>展示简化的commit历史</h2><pre><code>gitlog--pretty=oneline--graph--decorate--all</code></pre><h2 id="把某一个分支到导出成一个文件"><a href="#把某一个分支到导出成一个文件" class="headerlink" title="把某一个分支到导出成一个文件"></a>把某一个分支到导出成一个文件</h2><pre><code>git bundle create &lt;file&gt; &lt;branch-name&gt;</code></pre><h2 id="从包中导入分支"><a href="#从包中导入分支" class="headerlink" title="从包中导入分支"></a>从包中导入分支</h2><p>新建一个分支，分支内容就是上面<code>git bundle create</code>命令导出的内容</p><pre><code>git clone repo.bundle &lt;repo-dir&gt; -b &lt;branch-name&gt;</code></pre><h2 id="执行rebase之前自动stash"><a href="#执行rebase之前自动stash" class="headerlink" title="执行rebase之前自动stash"></a>执行rebase之前自动stash</h2><pre><code>git rebase --autostash</code></pre><h2 id="从远程仓库根据ID，拉下某一状态，到本地分支"><a href="#从远程仓库根据ID，拉下某一状态，到本地分支" class="headerlink" title="从远程仓库根据ID，拉下某一状态，到本地分支"></a>从远程仓库根据ID，拉下某一状态，到本地分支</h2><pre><code>git fetch origin pull/&lt;id&gt;/head:&lt;branch-name&gt;</code></pre><h2 id="详细展示一行中的修改"><a href="#详细展示一行中的修改" class="headerlink" title="详细展示一行中的修改"></a>详细展示一行中的修改</h2><pre><code>git diff --word-diff</code></pre><h2 id="清除gitignore文件中记录的文件"><a href="#清除gitignore文件中记录的文件" class="headerlink" title="清除gitignore文件中记录的文件"></a>清除gitignore文件中记录的文件</h2><pre><code>git clean -X -f</code></pre><h2 id="展示所有alias和configs"><a href="#展示所有alias和configs" class="headerlink" title="展示所有alias和configs"></a>展示所有alias和configs</h2><p><strong>注意：</strong> config分为：当前目录（local）和全局（golbal）的config，默认为当前目录的config</p><pre><code>gitconfig--local--list(当前目录)gitconfig--global--list(全局)</code></pre><h2 id="展示忽略的文件"><a href="#展示忽略的文件" class="headerlink" title="展示忽略的文件"></a>展示忽略的文件</h2><pre><code>git status--ignored</code></pre><h2 id="commit历史中显示Branch1有的，但是Branch2没有commit"><a href="#commit历史中显示Branch1有的，但是Branch2没有commit" class="headerlink" title="commit历史中显示Branch1有的，但是Branch2没有commit"></a>commit历史中显示Branch1有的，但是Branch2没有commit</h2><pre><code>git log Branch1 ^Branch2</code></pre><h2 id="在commit-log中显示GPG签名"><a href="#在commit-log中显示GPG签名" class="headerlink" title="在commit log中显示GPG签名"></a>在commit log中显示GPG签名</h2><pre><code>git log--show-signature</code></pre><h2 id="删除全局设置"><a href="#删除全局设置" class="headerlink" title="删除全局设置"></a>删除全局设置</h2><pre><code>git config --global --unset &lt;entry-name&gt;</code></pre><h2 id="新建并切换到新分支上，同时这个分支没有任何commit"><a href="#新建并切换到新分支上，同时这个分支没有任何commit" class="headerlink" title="新建并切换到新分支上，同时这个分支没有任何commit"></a>新建并切换到新分支上，同时这个分支没有任何commit</h2><p>相当于保存修改，但是重写commit历史</p><pre><code>git checkout --orphan &lt;branch-name&gt;</code></pre><h2 id="展示任意分支某一文件的内容"><a href="#展示任意分支某一文件的内容" class="headerlink" title="展示任意分支某一文件的内容"></a>展示任意分支某一文件的内容</h2><pre><code>git show &lt;branch-name&gt;:&lt;file-name&gt;</code></pre><h2 id="clone下来指定的单一分支"><a href="#clone下来指定的单一分支" class="headerlink" title="clone下来指定的单一分支"></a>clone下来指定的单一分支</h2><pre><code>git clone -b &lt;branch-name&gt; --single-branch https://github.com/user/repo.git</code></pre><h2 id="忽略某个文件的改动"><a href="#忽略某个文件的改动" class="headerlink" title="忽略某个文件的改动"></a>忽略某个文件的改动</h2><p>关闭 track 指定文件的改动，也就是 Git 将不会在记录这个文件的改动</p><pre><code>git update-index --assume-unchanged path/to/file</code></pre><p>恢复 track 指定文件的改动</p><pre><code>git update-index --no-assume-unchanged path/to/file</code></pre><h2 id="忽略文件的权限变化"><a href="#忽略文件的权限变化" class="headerlink" title="忽略文件的权限变化"></a>忽略文件的权限变化</h2><p>不再将文件的权限变化视作改动</p><pre><code>git config core.fileMode false</code></pre><h2 id="以最后提交的顺序列出所有Git分支"><a href="#以最后提交的顺序列出所有Git分支" class="headerlink" title="以最后提交的顺序列出所有Git分支"></a>以最后提交的顺序列出所有Git分支</h2><p>最新的放在最上面</p><pre><code>git for-each-ref --sort=-committerdate --format=&apos;%(refname:short)&apos; refs/heads/</code></pre><h2 id="在commit-log中查找相关内容"><a href="#在commit-log中查找相关内容" class="headerlink" title="在commit log中查找相关内容"></a>在commit log中查找相关内容</h2><p>通过grep查找，given-text：所需要查找的字段</p><pre><code>git log --all --grep=&apos;&lt;given-text&gt;&apos;</code></pre><h2 id="把暂存区的指定file放到工作区中"><a href="#把暂存区的指定file放到工作区中" class="headerlink" title="把暂存区的指定file放到工作区中"></a>把暂存区的指定file放到工作区中</h2><p>不添加参数，默认是-mixed</p><pre><code>git reset &lt;file-name&gt;</code></pre><h2 id="强制推送"><a href="#强制推送" class="headerlink" title="强制推送"></a>强制推送</h2><pre><code>git push -f &lt;remote-name&gt; &lt;branch-name&gt;</code></pre><h2 id="长按关注订阅号"><a href="#长按关注订阅号" class="headerlink" title="长按关注订阅号"></a>长按关注订阅号</h2><p><img src="https://static.segmentfault.com/v-5be168e8/global/img/squares.svg" alt="clipboard.png"></p><h2 id="长按进入RDhub群"><a href="#长按进入RDhub群" class="headerlink" title="长按进入RDhub群"></a>长按进入RDhub群</h2><p><img src="https://static.segmentfault.com/v-5be168e8/global/img/squares.svg" alt="clipboard.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS之call和apply,bind的模拟实现</title>
      <link href="/2017/09/02/JS%E4%B9%8Bcall%E5%92%8Capply-bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
      <url>/2017/09/02/JS%E4%B9%8Bcall%E5%92%8Capply-bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>一句话介绍 call：</p><blockquote><p>call() 方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p></blockquote><p>举个例子：</p><pre><code>var foo = {    value: 1};function bar() {    console.log(this.value);}bar.call(foo); // 1</code></pre><p>注意两点：</p><ol><li>call 改变了 this 的指向，指向到 foo</li><li>bar 函数执行了</li></ol><h2 id="模拟实现第一步"><a href="#模拟实现第一步" class="headerlink" title="模拟实现第一步"></a>模拟实现第一步</h2><p>那么我们该怎么模拟实现这两个效果呢？</p><p>试想当调用 call 的时候，把 foo 对象改造成如下：</p><pre><code>var foo = {    value: 1,    bar: function() {        console.log(this.value)    }};foo.bar(); // 1</code></pre><p>这个时候 this 就指向了 foo，是不是很简单呢？</p><p>但是这样却给 foo 对象本身添加了一个属性，这可不行呐！</p><p>不过也不用担心，我们用 delete 再删除它不就好了~</p><p>所以我们模拟的步骤可以分为：</p><ol><li>将函数设为对象的属性</li><li>执行该函数</li><li>删除该函数</li></ol><p>以上个例子为例，就是：</p><pre><code>// 第一步foo.fn = bar// 第二步foo.fn()// 第三步delete foo.fn</code></pre><p>fn 是对象的属性名，反正最后也要删除它，所以起成什么都无所谓。</p><p>根据这个思路，我们可以尝试着去写第一版的 call2 函数：</p><pre><code>// 第一版Function.prototype.call2 = function(context) {    // 首先要获取调用call的函数，用this可以获取    context.fn = this;    context.fn();    delete context.fn;}// 测试一下var foo = {    value: 1};function bar() {    console.log(this.value);}bar.call2(foo); // 1</code></pre><p>正好可以打印 1 哎！是不是很开心！(～￣▽￣)～</p><h2 id="模拟实现第二步"><a href="#模拟实现第二步" class="headerlink" title="模拟实现第二步"></a>模拟实现第二步</h2><p>最一开始也讲了，call 函数还能给定参数执行函数。举个例子：</p><pre><code>var foo = {    value: 1};function bar(name, age) {    console.log(name)    console.log(age)    console.log(this.value);}bar.call(foo, &apos;kevin&apos;, 18);// kevin// 18// 1</code></pre><p>注意：传入的参数并不确定，这可咋办？</p><p>不急，我们可以从 Arguments 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。</p><p>比如这样：</p><pre><code>// 以上个例子为例，此时的arguments为：// arguments = {//      0: foo,//      1: &apos;kevin&apos;,//      2: 18,//      length: 3// }// 因为arguments是类数组对象，所以可以用for循环var args = [];for(var i = 1, len = arguments.length; i &lt; len; i++) {    args.push(&apos;arguments[&apos; + i + &apos;]&apos;);}// 执行后 args为 [foo, &apos;kevin&apos;, 18]</code></pre><p>不定长的参数问题解决了，我们接着要把这个参数数组放到要执行的函数的参数里面去。</p><pre><code>// 将数组里的元素作为多个参数放进函数的形参里context.fn(args.join(&apos;,&apos;))// (O_o)??// 这个方法肯定是不行的啦！！！</code></pre><p>也许有人想到用 ES6 的方法，不过 call 是 ES3 的方法，我们为了模拟实现一个 ES3 的方法，要用到ES6的方法，好像……，嗯，也可以啦。但是我们这次用 eval 方法拼成一个函数，类似于这样：</p><pre><code>eval(&apos;context.fn(&apos; + args +&apos;)&apos;)</code></pre><p>这里 args 会自动调用 Array.toString() 这个方法。</p><p>所以我们的第二版克服了两个大问题，代码如下：</p><pre><code>// 第二版Function.prototype.call2 = function(context) {    context.fn = this;    var args = [];    for(var i = 1, len = arguments.length; i &lt; len; i++) {        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);    }    eval(&apos;context.fn(&apos; + args +&apos;)&apos;);    delete context.fn;}// 测试一下var foo = {    value: 1};function bar(name, age) {    console.log(name)    console.log(age)    console.log(this.value);}bar.call2(foo, &apos;kevin&apos;, 18); // kevin// 18// 1</code></pre><p>(๑•̀ㅂ•́) ✧</p><h2 id="模拟实现第三步"><a href="#模拟实现第三步" class="headerlink" title="模拟实现第三步"></a>模拟实现第三步</h2><p>模拟代码已经完成 80%，还有两个小点要注意：</p><p>1.this 参数可以传 null，当为 null 的时候，视为指向 window</p><p>举个例子：</p><pre><code>var value = 1;function bar() {    console.log(this.value);}bar.call(null); // 1</code></pre><p>虽然这个例子本身不使用 call，结果依然一样。</p><p>2.函数是可以有返回值的！</p><p>举个例子：</p><pre><code>var obj = {    value: 1}function bar(name, age) {    return {        value: this.value,        name: name,        age: age    }}console.log(bar.call(obj, &apos;kevin&apos;, 18));// Object {//    value: 1,//    name: &apos;kevin&apos;,//    age: 18// }</code></pre><p>不过都很好解决，让我们直接看第三版也就是最后一版的代码：</p><pre><code>// 第三版Function.prototype.call2 = function (context) {    var context = context || window;    context.fn = this;    var args = [];    for(var i = 1, len = arguments.length; i &lt; len; i++) {        args.push(&apos;arguments[&apos; + i + &apos;]&apos;);    }    var result = eval(&apos;context.fn(&apos; + args +&apos;)&apos;);    delete context.fn    return result;}// 测试一下var value = 2;var obj = {    value: 1}function bar(name, age) {    console.log(this.value);    return {        value: this.value,        name: name,        age: age    }}bar.call(null); // 2console.log(bar.call2(obj, &apos;kevin&apos;, 18));// 1// Object {//    value: 1,//    name: &apos;kevin&apos;,//    age: 18// }</code></pre><p>到此，我们完成了 call 的模拟实现，给自己一个赞 ｂ（￣▽￣）ｄ</p><h2 id="apply的模拟实现"><a href="#apply的模拟实现" class="headerlink" title="apply的模拟实现"></a>apply的模拟实现</h2><p>apply 的实现跟 call 类似，在这里直接给代码，代码来自于知乎 @郑航的实现：</p><pre><code>Function.prototype.apply = function (context, arr) {    var context = Object(context) || window;    context.fn = this;    var result;    if (!arr) {        result = context.fn();    }    else {        var args = [];        for (var i = 0, len = arr.length; i &lt; len; i++) {            args.push(&apos;arr[&apos; + i + &apos;]&apos;);        }        result = eval(&apos;context.fn(&apos; + args + &apos;)&apos;)    }    delete context.fn    return result;}</code></pre><p><img src="https://pic1.zhimg.com/v2-23784bc5e0ab2bdcb4b879e5d28617c6_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-23784bc5e0ab2bdcb4b879e5d28617c6_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/v2-9374916fd3f03dab5836b9fc4057070a_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-9374916fd3f03dab5836b9fc4057070a_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/v2-7fe454d5cfd72880650f53a4f50c93cd_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-7fe454d5cfd72880650f53a4f50c93cd_hd.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-4f15656852b764a859194a3d7156ea99_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-4f15656852b764a859194a3d7156ea99_hd.jpg" alt=""></p><pre><code>类数组转对象在上面的例子中已经提到了一种类数组转数组的方法，再补充三个：var arrayLike = {0: &apos;name&apos;, 1: &apos;age&apos;, 2: &apos;sex&apos;, length: 3 }// 1. sliceArray.prototype.slice.call(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 2. spliceArray.prototype.splice.call(arrayLike, 0); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 3. ES6 Array.fromArray.from(arrayLike); // [&quot;name&quot;, &quot;age&quot;, &quot;sex&quot;] // 4. applyArray.prototype.concat.apply([], arrayLike)   要说到类数组对象，Arguments 对象就是一个类数组对象。在客户端 JavaScript 中，一些 DOM 方法(document.getElementsByTagName()等)也返回类数组对象。传递参数将参数从一个函数传递到另一个函数// 使用 apply 将 foo 的参数传递给 barfunction foo() {    bar.apply(this, arguments);}function bar(a, b, c) {   console.log(a, b, c);}foo(1, 2, 3)强大的ES6使用ES6的 ... 运算符，我们可以轻松转成数组。function func(...arguments) {    console.log(arguments); // [1, 2, 3]}func(1, 2, 3);</code></pre><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>一句话介绍 bind:</p><blockquote><p>bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )</p></blockquote><p>由此我们可以首先得出 bind 函数的两个特点：</p><ol><li>返回一个函数</li><li>可以传入参数</li></ol><h2 id="返回函数的模拟实现"><a href="#返回函数的模拟实现" class="headerlink" title="返回函数的模拟实现"></a>返回函数的模拟实现</h2><p>从第一个特点开始，我们举个例子：</p><pre><code>var foo = {    value: 1};function bar() {    console.log(this.value);}// 返回了一个函数var bindFoo = bar.bind(foo); bindFoo(); // 1</code></pre><p>关于指定 this 的指向，我们可以使用 call 或者 apply 实现，关于 call 和 apply 的模拟实现，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">《JavaScript深入之call和apply的模拟实现》</a>。我们来写第一版的代码：</p><pre><code>// 第一版Function.prototype.bind2 = function (context) {    var self = this;    return function () {        self.apply(context);    }}</code></pre><h2 id="传参的模拟实现"><a href="#传参的模拟实现" class="headerlink" title="传参的模拟实现"></a>传参的模拟实现</h2><p>接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子：</p><pre><code>var foo = {    value: 1};function bar(name, age) {    console.log(this.value);    console.log(name);    console.log(age);}var bindFoo = bar.bind(foo, &apos;daisy&apos;);bindFoo(&apos;18&apos;);// 1// daisy// 18</code></pre><p>函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age!</p><p>这可咋办？不急，我们用 arguments 进行处理：</p><pre><code>// 第二版Function.prototype.bind2 = function (context) {    var self = this;    // 获取bind2函数从第二个参数到最后一个参数    var args = Array.prototype.slice.call(arguments, 1);    return function () {        // 这个时候的arguments是指bind返回的函数传入的参数        var bindArgs = Array.prototype.slice.call(arguments);        self.apply(context, args.concat(bindArgs));    }}</code></pre><h2 id="构造函数效果的模拟实现"><a href="#构造函数效果的模拟实现" class="headerlink" title="构造函数效果的模拟实现"></a>构造函数效果的模拟实现</h2><p>完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是</p><blockquote><p>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。</p></blockquote><p>也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子：</p><pre><code>var value = 2;var foo = {    value: 1};function bar(name, age) {    this.habit = &apos;shopping&apos;;    console.log(this.value);    console.log(name);    console.log(age);}bar.prototype.friend = &apos;kevin&apos;;var bindFoo = bar.bind(foo, &apos;daisy&apos;);var obj = new bindFoo(&apos;18&apos;);// undefined// daisy// 18console.log(obj.habit);console.log(obj.friend);// shopping// kevin</code></pre><p>注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。</p><p>(哈哈，我这是为我的下一篇文章<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">《JavaScript深入系列之new的模拟实现》</a>打广告)。</p><p>所以我们可以通过修改返回的函数的原型来实现，让我们写一下：</p><pre><code>// 第三版Function.prototype.bind2 = function (context) {    var self = this;    var args = Array.prototype.slice.call(arguments, 1);    var fBound = function () {        var bindArgs = Array.prototype.slice.call(arguments);        // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值        // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性        // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context        self.apply(this instanceof fBound ? this : context, args.concat(bindArgs));    }    // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值    fBound.prototype = this.prototype;    return fBound;}</code></pre><p>如果对原型链稍有困惑，可以查看<a href="https://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">《JavaScript深入之从原型到原型链》</a>。</p><h2 id="构造函数效果的优化实现"><a href="#构造函数效果的优化实现" class="headerlink" title="构造函数效果的优化实现"></a>构造函数效果的优化实现</h2><p>但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转：</p><pre><code>// 第四版Function.prototype.bind2 = function (context) {    var self = this;    var args = Array.prototype.slice.call(arguments, 1);    var fNOP = function () {};    var fBound = function () {        var bindArgs = Array.prototype.slice.call(arguments);        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));    }    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;}</code></pre><p>到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ</p><h2 id="三个小问题"><a href="#三个小问题" class="headerlink" title="三个小问题"></a>三个小问题</h2><p>接下来处理些小问题:</p><p>1.apply 这段代码跟 MDN 上的稍有不同</p><p>在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是：</p><pre><code>self.apply(this instanceof self ? this : context || this, args.concat(bindArgs))</code></pre><p>多了一个关于 context 是否存在的判断，然而这个是错误的！</p><p>举个例子：</p><pre><code>var value = 2;var foo = {    value: 1,    bar: bar.bind(null)};function bar() {    console.log(this.value);}foo.bar() // 2</code></pre><p>以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！</p><p>所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！</p><p>2.调用 bind 的不是函数咋办？</p><p>不行，我们要报错！</p><pre><code>if (typeof this !== &quot;function&quot;) {  throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);}</code></pre><p>3.我要在线上用</p><p>那别忘了做个兼容：</p><pre><code>Function.prototype.bind = Function.prototype.bind || function () {    ……};</code></pre><p>当然最好是用 <a href="https://link.zhihu.com/?target=https%3A//github.com/es-shims/es5-shim" target="_blank" rel="noopener">es5-shim</a> 啦。</p><h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><p>所以最最后的代码就是：</p><pre><code>Function.prototype.bind2 = function (context) {    if (typeof this !== &quot;function&quot;) {      throw new Error(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);    }    var self = this;    var args = Array.prototype.slice.call(arguments, 1);    var fNOP = function () {};    var fBound = function () {        var bindArgs = Array.prototype.slice.call(arguments);        self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));    }    fNOP.prototype = this.prototype;    fBound.prototype = new fNOP();    return fBound;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>async/await 小技巧</title>
      <link href="/2017/08/30/async-await-%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2017/08/30/async-await-%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="async-await-小技巧"><a href="#async-await-小技巧" class="headerlink" title="async/await 小技巧"></a>async/await 小技巧</h1><h2 id="sleep-函数"><a href="#sleep-函数" class="headerlink" title="sleep 函数"></a>sleep 函数</h2><p>以前只接使用 <code>setTimeout</code> 和回调函数实现一个 <code>sleep</code> 会有很多的副作用，用起来很不方便。</p><p>所以让 <code>setTimeout</code> 搭配使用 <code>async/await</code></p><pre><code>constsleep=delay=&gt; {  returnnewPromise(resolve=&gt; {    setTimeout(resolve, delay)  })}constfn=async_=&gt; {  console.log(&apos;starting....&apos;)  awaitsleep(1000)  console.log(&apos;after sleeping for 1 second&apos;)}</code></pre><h2 id="搭配-map-函数"><a href="#搭配-map-函数" class="headerlink" title="搭配 map() 函数"></a>搭配 map() 函数</h2><p>在 <code>map</code> 中引入异步处理:</p><pre><code>constarr= [1,2,3,4,5]constasyncFn=data=&gt; {  // 异步处理函数}constresults=arr.map(asyncnum=&gt; {  awaitasyncFn(num)  return++num})console.log(results)</code></pre><p>代码执行后的结果 <code>[Promise, Promise, Promise, Promise, Promise]</code> 而且 <code>map</code> 函数并不会等异步函数 <code>asyncFn</code> 执行完毕后再返回结果</p><p>既然 <code>async</code> 执行后会返回一个 <code>Promise</code> 对象，所以可以通过 <code>Promise.all</code> 的状态来判断异步函数的状态:</p><pre><code>constarr= [1,2,3,4,5]constasyncFn=data=&gt; {  // 异步处理函数}constp=arr.map(asyncnum=&gt; {  awaitasyncFn(num)  return++num})Promise.all(p).then(results=&gt; {  console.log(results)})</code></pre><p>这样就能正常返回结果 <code>[2, 3, 4, 5, 6]</code></p><h2 id="使用-await-代替-then-函数"><a href="#使用-await-代替-then-函数" class="headerlink" title="使用 await 代替 then() 函数"></a>使用 await 代替 then() 函数</h2><p>上面的例子最后使用了 <code>Promise.all</code>  还是回到了使用回调函数的方式</p><p>这个也很好解决，只需要在外层再加一个 <code>async</code> 函数</p><pre><code>constmain=async_=&gt; {  constresults=awaitPromise.all(arr.map(num=&gt; {    awaitasyncFn()    return++num  }))  console.log(results)}main()</code></pre><h2 id="搭配-reduce-函数"><a href="#搭配-reduce-函数" class="headerlink" title="搭配 reduce() 函数"></a>搭配 reduce() 函数</h2><p>通过引入 <code>async/await</code> 可以把 <code>reduce</code> 扩展成一个按顺序执行异步函数的工具</p><p><code>reduce</code> 用起来很简单:</p><pre><code>constarr= [1,2,3,4,5]constresult=arr.reduce((prev, next) =&gt; {  return prev+next}, 0)console.log(result)</code></pre><p>像 <code>map</code> 函数一样引入 <code>async/await</code> :</p><pre><code>constarr= [1,2,3,4,5]constmain=async_=&gt; {  constresult=awaitarr.reduce(async (prev, next) =&gt; {    consttmp=await prev    return tmp + next  }, Promise.resolve(0))  console.log(result)}main()</code></pre><p>而且还可以在 <code>reduce</code> 内部加入异步函数:</p><pre><code>constarr= [1,2,3,4,5]constmain=async_=&gt; {  constresult=awaitarr.reduce(async (prev, next) =&gt; {    consttmp=await prev    // 异步处理 暂停1sawaitsleep(1000)    console.log(tmp + next)    return tmp + next  }, Promise.resolve(0))}main()</code></pre><p>上述代码会每隔一秒依次打出 1 3 6 10 15</p><p>参考自</p><blockquote><p><a href="http://2ality.com/2016/10/async-function-tips.html" target="_blank" rel="noopener">http://2ality.com/2016/10/async-function-tips.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> async </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用css让一个容器水平垂直居中</title>
      <link href="/2017/08/15/%E7%94%A8css%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/2017/08/15/%E7%94%A8css%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%AE%B9%E5%99%A8%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>阅读目录</p><ul><li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label0" target="_blank" rel="noopener">方法一：position加margin</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label1" target="_blank" rel="noopener">方法二： diaplay:table-cell</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label2" target="_blank" rel="noopener">方法三：position加 transform</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label3" target="_blank" rel="noopener">方法四：flex;align-items: center;justify-content: center</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label4" target="_blank" rel="noopener">方法五：display:flex;margin:auto</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_label5" target="_blank" rel="noopener">方法六：纯position</a></li></ul><p>这种css布局平时用的比较多，也是面试题常出的一个题，网上一搜一大丢，不过还是想自己总结一下。</p><p>这种方法比较多，本文只总结其中的几种，以便加深印象。</p><p>效果图都为这个：</p><p><img src="https://pic1.zhimg.com/v2-cf428b1f71583bc3feeeedcdc87d9e6c_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf428b1f71583bc3feeeedcdc87d9e6c_hd.jpg" alt=""></p><p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h2 id="方法一：position加margin"><a href="#方法一：position加margin" class="headerlink" title="方法一：position加margin"></a>方法一：position加margin</h2><pre><code>/**html**/&lt;div class=&quot;wrap&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;/**css**/.wrap {    width: 200px;    height: 200px;    background: yellow;    position: relative;}.wrap .center {    width: 100px;    height: 100px;    background: green;    margin: auto;    position: absolute;    left: 0;    right: 0;    top: 0;    bottom: 0;}</code></pre><p>兼容性：主流浏览器均支持，IE6不支持</p><p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h2 id="方法二：-diaplay-table-cell"><a href="#方法二：-diaplay-table-cell" class="headerlink" title="方法二： diaplay:table-cell"></a>方法二： diaplay:table-cell</h2><pre><code>&lt;!-- html --&gt;&lt;div class=&quot;wrap&quot;&gt;     &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;/*css*/.wrap{    width: 200px;    height: 200px;    background: yellow;    display: table-cell;    vertical-align: middle;    text-align: center;}.center{    display: inline-block;    vertical-align: middle;    width: 100px;    height: 100px;    background: green;}</code></pre><p>兼容性：由于display:table-cell的原因，IE6\7不兼容</p><p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h2 id="方法三：position加-transform"><a href="#方法三：position加-transform" class="headerlink" title="方法三：position加 transform"></a>方法三：position加 transform</h2><pre><code>&lt;!-- html --&gt;&lt;div class=&quot;wrap&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;/* css */.wrap {    position: relative;    background: yellow;    width: 200px;    height: 200px;}.center {    position: absolute;    background: green;    top:50%;    left:50%;    -webkit-transform:translate(-50%,-50%);    transform:translate(-50%,-50%);    width: 100px;    height: 100px;}</code></pre><p>兼容性：ie9以下不支持 transform，手机端表现的比较好。</p><p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h2 id="方法四：flex-align-items-center-justify-content-center"><a href="#方法四：flex-align-items-center-justify-content-center" class="headerlink" title="方法四：flex;align-items: center;justify-content: center"></a>方法四：flex;align-items: center;justify-content: center</h2><pre><code>&lt;!-- html --&gt;&lt;div class=&quot;wrap&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;/* css */.wrap {    background: yellow;    width: 200px;    height: 200px;    display: flex;     align-items: center;     justify-content: center;}.center {    background: green;    width: 100px;    height: 100px;}</code></pre><p>移动端首选</p><p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h2 id="方法五：display-flex-margin-auto"><a href="#方法五：display-flex-margin-auto" class="headerlink" title="方法五：display:flex;margin:auto"></a>方法五：display:flex;margin:auto</h2><pre><code>&lt;!-- html --&gt;&lt;div class=&quot;wrap&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;/* css */.wrap {    background: yellow;    width: 200px;    height: 200px;    display: flex; }.center {    background: green;    width: 100px;    height: 100px;    margin: auto;}</code></pre><p>移动端首选</p><p><a href="https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xianyulaodi/p/5863305.html%23_labelTop" target="_blank" rel="noopener">回到顶部</a></p><h2 id="方法六：纯position"><a href="#方法六：纯position" class="headerlink" title="方法六：纯position"></a>方法六：纯position</h2><pre><code>&lt;!-- html --&gt;&lt;div class=&quot;wrap&quot;&gt;    &lt;div class=&quot;center&quot;&gt;&lt;/div&gt;&lt;/div&gt;/* css */.wrap {    background: yellow;    width: 200px;    height: 200px;    position: relative;}/**方法一**/.center {    background: green;    position: absolute;    width: 100px;    height: 100px;    left: 50px;    top: 50px; 　　}/**方法二**/.center {    background: green;    position: absolute;    width: 100px;    height: 100px;    left: 50%;    top: 50%;　　margin-left:-50px;　　margin-top:-50px;}　 </code></pre><p>兼容性：适用于所有浏览器</p><p>  方法六中的方法一计算公式如下：</p><p>　　子元素（conter）的left值计算公式：left=(父元素的宽 - 子元素的宽 ) / 2=(200-100) / 2=50px;</p><p>　　子元素（conter）的top值计算公式：top=(父元素的高 - 子元素的高 ) / 2=(200-100) / 2=50px;</p><p>　　方法二计算公式：</p><p>　　left值固定为50%;</p><p>　　子元素的margin-left= -（子元素的宽/2）=-100/2= -50px;</p><p>　　top值也一样，固定为50%</p><pre><code>子元素的margin-top= -（子元素的高/2）=-100/2= -50px;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>为什么Redux 需要 reducers是纯函数？</title>
      <link href="/2017/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88Redux-%E9%9C%80%E8%A6%81-reducers%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9F/"/>
      <url>/2017/07/31/%E4%B8%BA%E4%BB%80%E4%B9%88Redux-%E9%9C%80%E8%A6%81-reducers%E6%98%AF%E7%BA%AF%E5%87%BD%E6%95%B0%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么Redux-需要-reducers是纯函数？"><a href="#为什么Redux-需要-reducers是纯函数？" class="headerlink" title="为什么Redux 需要 reducers是纯函数？"></a>为什么Redux 需要 reducers是纯函数？</h4><p> 这又是一个很厉害的问题了，使用Redux的都知道，reducers会接收上一个state和action作为参数，然后返回一个新的state，这个新的state不能是在原来state基础上的修改。所以经常可以看到以下的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return Object.assign(...)</span><br><span class="line">//或者----------</span><br><span class="line">return &#123;...state,xx:xxx&#125;</span><br></pre></td></tr></table></figure></p><p>其作用，都是为了返回一个全新的对象。</p><p><strong>为什么reducers要求是纯函数(返回全新的对象，不影响原对象)?</strong>  –某面试官</p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>从本质上讲，纯函数的定义如下：不修改函数的输入值，依赖于外部状态（比如数据库，DOM和全局变量），同时对于任何相同的输入有着相同的输出结果。<br>举个例子，下面的add函数不修改变量a或b，同时不依赖外部状态，对于相同的输入始终返回相同的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const add = (a,b) =&gt; &#123;a + b&#125;;</span><br></pre></td></tr></table></figure></p><p>这就是一个纯函数，结果对a、b没有任何影响，回头去看reducer，它符合纯函数的所有特征，所以就是一个纯函数<br>为什么必须是纯函数?<br>先告诉你结果吧，如果在reducer中，在原来的state上进行操作，并返回的话，并不会让React重新渲染。 完全不会有任何变化！<br>接下来看下Redux的源码：<br><img src="https://user-gold-cdn.xitu.io/2018/8/22/165609de895ae1ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。<br>Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。<br>好了，也就是说，从源码的角度来讲，redux要求开发者必须让新的state是全新的对象。那么为什么非要这么麻烦开发者呢？<br>请看下面的例子：尝试比较a和b是否相同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;],</span><br><span class="line">    years: 12,</span><br><span class="line">    ...//省略n项目</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var b = &#123;</span><br><span class="line">    name: &apos;jack&apos;,</span><br><span class="line">    friend: [&apos;sam&apos;,&apos;xiaoming&apos;,&apos;cunsi&apos;],</span><br><span class="line">    years: 13,</span><br><span class="line">    ...//省略n项目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 思路是怎样的？我们需要遍历对象，如果对象的属性是数组，还需要进行递归遍历，去看内容是否一致、是否发生了变化。 这带来的性能损耗是非常巨大的。 有没有更好的办法？<br>有！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//接上面的例子</span><br><span class="line">a === b  //false</span><br></pre></td></tr></table></figure></p><p> 我不要进行深度比较，只是浅比较，引用值不一样(不是同一个对象),那就是不一样的。 这就是redux的reducer如此设计的原因了</p>]]></content>
      
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Node.js的文件路径的一些坑</title>
      <link href="/2017/07/09/Node-js%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/"/>
      <url>/2017/07/09/Node-js%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在写一篇weex的webpack配置，刚刚踩坑了，weekpack中会用到path模块，而对于这个模块，我想抽离出来看一下，因为这个用到的还是比较多的,喜欢的朋友可以点个喜欢，或者去我的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Flaihuamin%252FJS-total" target="_blank" rel="noopener">github</a>点个star也行，谢谢支持，举起小手指点一点哦😯，写的不对的地方，评论拍砖，谢谢。</p><h2 id="node中的路径分类"><a href="#node中的路径分类" class="headerlink" title="node中的路径分类"></a>node中的路径分类</h2><p>node中的路径大致分5类，dirname,filename,process.cwd(),./,../,其中前三个都是绝对路径</p><p>我们先来看一个简单点的例子</p><p>假如，我有一个文件的目录结构如下：</p><pre><code>editor/  - dist/  - src/      - task.js</code></pre><p>然后我们在task.js文件中写入一下代码</p><pre><code>const path = require(&apos;path&apos;);console.log(__dirname);console.log(__filename);console.log(process.cwd());console.log(path.resolve(&apos;./&apos;));</code></pre><p>在editor目录下运行node src/task.js，我们可以看到结果如下：</p><pre><code>/Users/laihuamin/Documents/richEditor/editor/src/Users/laihuamin/Documents/richEditor/editor/src/task.js/Users/laihuamin/Documents/richEditor/editor/Users/laihuamin/Documents/richEditor/editor</code></pre><p>然后我们有可以在src目录下运行这个文件，node task.js,运行结果如下：</p><pre><code>/Users/laihuamin/Documents/richEditor/editor/src/Users/laihuamin/Documents/richEditor/editor/src/task.js/Users/laihuamin/Documents/richEditor/editor/src/Users/laihuamin/Documents/richEditor/editor/src</code></pre><p>对比两个输出结果，我们可以归纳一下几点：</p><p>1.<strong>dirname:返回的是这个文件所在文件夹的位置<br>2.</strong>filename:你运行命令代表的是文件所在的位置，不管你运行什么命令，都是指向文件<br>3.process.cwd():你运行node命令所在文件夹的位置，比如你在src目录下运行，那么就是输出到src为止，下面的同理。</p><hr><p>Node.js中的文件路径大概有 <strong>dirname, </strong>filename, process.cwd(), ./ 或者 ../，前三个都是绝对路径，为了便于比较，./ 和 ../ 我们通过 path.resolve(‘./‘)来转换为绝对路径。<br>简单说一下这几个路径的意思，：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname：    获得当前执行文件所在目录的完整目录名</span><br><span class="line">__filename：   获得当前执行文件的带有完整绝对路径的文件名</span><br><span class="line">process.cwd()：获得当前执行node命令时候的文件夹目录名 </span><br><span class="line">./：           文件所在目录</span><br></pre></td></tr></table></figure></p><p>先看一看我电脑当前的目录结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax/</span><br><span class="line">    -nodejs/</span><br><span class="line">        -1.findLargest.js</span><br><span class="line">        -2.path.js</span><br><span class="line">        -3.fs.js</span><br><span class="line">    -regs</span><br><span class="line">        -regx.js</span><br><span class="line">        -test.txt</span><br></pre></td></tr></table></figure></p><p>在 path.js 里面我们写这些代码，看看输出是什么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">console.log(&apos;__dirname：&apos;, __dirname)</span><br><span class="line">console.log(&apos;__filename：&apos;, __filename)</span><br><span class="line">console.log(&apos;process.cwd()：&apos;, process.cwd())</span><br><span class="line">console.log(&apos;./：&apos;, path.resolve(&apos;./&apos;))</span><br></pre></td></tr></table></figure></p><p>在当前目录下也就是nodejs目录运行<code>node path.js</code>，我们看看输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname：     /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs</span><br><span class="line">__filename：    /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs/2.path.js</span><br><span class="line">process.cwd()： /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs</span><br><span class="line">./：            /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs</span><br></pre></td></tr></table></figure></p><p>然后在 项目根目录ES6-lottery 目录下运行 <code>node syntax/nodejs/2.path.js</code>，我们再来看看输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname：     /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs</span><br><span class="line">__filename：    /Users/jawil/Desktop/nodejs/demo/ES6-lottery/syntax/nodejs/2.path.js</span><br><span class="line">process.cwd()： /Users/jawil/Desktop/nodejs/demo/ES6-lottery</span><br><span class="line">./：            /Users/jawil/Desktop/nodejs/demo/ES6-lottery</span><br></pre></td></tr></table></figure></p><p>答案显而易见？我们可以通过上面的例子对比，暂时得出表面的结论：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname: 总是返回被执行的 js 所在文件夹的绝对路径</span><br><span class="line">__filename: 总是返回被执行的 js 的绝对路径</span><br><span class="line">process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径</span><br><span class="line">./: 跟 process.cwd() 一样，返回 node 命令时所在的文件夹的绝对路径</span><br></pre></td></tr></table></figure></p><h2 id="require-源码解读"><a href="#require-源码解读" class="headerlink" title="require() 源码解读"></a><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">require() 源码解读</a></h2><p><img src="/2017/07/09/Node-js的文件路径的一些坑/1.webp" alt=""></p><p>那么关于 ./ 正确的结论是：</p><blockquote><p>在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。<br>只有在 require() 时才使用相对路径(./, ../)的写法，其他地方一律使用绝对路径，如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 当前目录下</span><br><span class="line"> path.dirname(__filename) + &apos;/path.js&apos;; </span><br><span class="line">// 相邻目录下</span><br><span class="line"> path.resolve(__dirname, &apos;../regx/regx.js&apos;);</span><br></pre></td></tr></table></figure><hr><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>讲完前面三个绝对路径，我倒是挺想来聊聊path这个模块的，这个node模块在很多地方都有应用，所以，对于我们来说，掌握他，对我们以后的发展更有利，不用每次看webpack的配置文件还要去查询一下这个api是干什么用的，很影响我们的效率</p><p><a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fnodejs.org%252Fapi%252Fpath.html" target="_blank" rel="noopener">nodeJS/path</a></p><p>上面那个网站有详细的api，但是我们这里不用都掌握吧，我就讲几个我遇到过的，我觉得webpack等工程配置中会用到的</p><h2 id="path-normalize"><a href="#path-normalize" class="headerlink" title="path.normalize"></a>path.normalize</h2><p>这个方法就是把不规范的路径规范化，比如看下面的例子</p><pre><code>const path = require(&apos;path&apos;);console.log(path.normalize(&apos;/foo/bar//baz/asdf/quux/..&apos;));</code></pre><p>输出结果：</p><pre><code>/foo/bar/baz/asdf</code></pre><h2 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h2><pre><code>const path = require(&apos;path&apos;);console.log(path.join(&apos;src&apos;, &apos;task.js&apos;));const path = require(&apos;path&apos;);console.log(path.join(&apos;dist&apos;, &apos;task.js&apos;));const path = require(&apos;path&apos;);console.log(path.join(&apos;&apos;));</code></pre><p>这么两个的输出结果是：</p><pre><code>src/task.jsdist/task.js.</code></pre><p>他的作用也就显而易见，他有一下几条规则：<br>1.传入的参数是字符串的路径片段，可以是一个，也可以是多个</p><p>2.返回的是一个拼接好的路径，但是根据平台的不同，他会对路径进行不同的规范化，举个例子，Unix系统是”/“，Windows系统是”\“，那么你在两个系统下看到的返回结果就不一样。</p><p>3.如果返回的路径字符串长度为零，那么他会返回一个’.’，代表当前的文件夹。</p><p>4.如果传入的参数中有不是字符串的，那就直接会报错</p><h2 id="path-parse"><a href="#path-parse" class="headerlink" title="path.parse"></a>path.parse</h2><p>我们先来看个例子，在src目录下的task.js写入</p><pre><code>const path = require(&apos;path&apos;);console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor&apos;));</code></pre><p>然后运行node src/task.js之后,输出的结果如下：</p><pre><code>{   root: &apos;/&apos;,  dir: &apos;/Users/laihuamin/Documents/richEditor&apos;,  base: &apos;editor&apos;,  ext: &apos;&apos;,  name: &apos;editor&apos; }</code></pre><p>他返回的是一个对象，那么我们来把这么几个名词熟悉一下：</p><p><img src="https://pic3.zhimg.com/v2-b7c5d496b89fde98f097a4a6e2ba7d03_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b7c5d496b89fde98f097a4a6e2ba7d03_hd.jpg" alt=""></p><p>这个表格应该展示的很形象，但是我们还是来解释一下这些名词：<br>1.root：代表根目录<br>2.dir：代表文件所在的文件夹<br>3.base：代表整一个文件<br>4.name：代表文件名<br>5.ext: 代表文件的后缀名</p><p>那我们根据下面的规则，来看一下下面这个例子，最好自己脑子做一遍</p><pre><code>const path = require(&apos;path&apos;);console.log(path.parse(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));</code></pre><p>输出的结果：</p><pre><code>{   root: &apos;/&apos;,  dir: &apos;/Users/laihuamin/Documents/richEditor/editor/src&apos;,  base: &apos;task.js&apos;,  ext: &apos;.js&apos;,  name: &apos;task&apos; }</code></pre><p>你做对了么？0.0</p><h2 id="path-basename"><a href="#path-basename" class="headerlink" title="path.basename"></a>path.basename</h2><p>那有了前面这个铺垫，想必这个接口猜也能猜的到了。。。。我们看下面这个例子</p><pre><code>const path = require(&apos;path&apos;);console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));</code></pre><p>输出的结果是：</p><pre><code>task.js</code></pre><p>我们还是简单介绍一下，接收两个参数，一个是path,还有一个是ext（可选参数）.</p><pre><code>const path = require(&apos;path&apos;)console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;, &apos;.js&apos;));</code></pre><p>输出结果:</p><pre><code>task</code></pre><h2 id="path-dirname"><a href="#path-dirname" class="headerlink" title="path.dirname"></a>path.dirname</h2><p>这个接口比basename还要简单，我就不多说了，看例子，看结果</p><pre><code>const path = require(&apos;path&apos;);console.log(path.basename(&apos;/Users/laihuamin/Documents/richEditor/editor/src/task.js&apos;));</code></pre><p>输出的结果:</p><pre><code>/Users/laihuamin/Documents/richEditor/editor/src</code></pre><p>注意一下，接收的参数是字符串类型</p><h2 id="path-extname"><a href="#path-extname" class="headerlink" title="path.extname"></a>path.extname</h2><p>这个就是展示文件的扩展名，我们得注意几种情况</p><pre><code>const path = require(&apos;path&apos;);path.extname(&apos;index.html&apos;);path.extname(&apos;index.coffee.md&apos;);path.extname(&apos;index.&apos;);path.extname(&apos;index&apos;);path.extname(&apos;.index&apos;);</code></pre><p>输出的结果是：</p><pre><code>.html.md.&apos;&apos;&apos;&apos;</code></pre><p>自己注意一下这几个情况</p><h2 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h2><p>我们通过下面这几个例子先来熟悉一下：</p><pre><code>const path = require(&apos;path&apos;);console.log(path.resolve(&apos;/foo/bar&apos;, &apos;/bar/faa&apos;, &apos;..&apos;, &apos;a/../c&apos;));</code></pre><p>输出的结果是</p><pre><code>/bar/c</code></pre><p>他就相当于一堆cd操作，我们一步一步看</p><pre><code>cd /foo/bar/    //这是第一步, 现在的位置是/foo/bar/cd /bar/faa     //这是第二步，这里和第一步有区别，他是从/进入的，也就时候根目录，现在的位置是/bar/faacd ..       //第三步，从faa退出来，现在的位置是 /barcd a/../c   //第四步，进入a，然后在推出，在进入c，最后位置是/bar/c</code></pre><p>但是这个操作和cd还是有区别的，这个路径不一定要存在，而且最后的可以是文件</p><h2 id="path-relative"><a href="#path-relative" class="headerlink" title="path.relative"></a>path.relative</h2><p>这个返回的是from到to的相对路径，什么意思呢，我们看下面的例子就知道了.</p><pre><code>const path = require(&apos;path&apos;);console.log(path.relative(&apos;src/bar/baz&apos;, &apos;src/aaa/bbb&apos;));</code></pre><p>输出的结果是：</p><pre><code>../../aaa/bbb</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些比较实用的方法，分享给大家，自己还是老老实实去看weektool的webpack的配置文件了，喜欢的朋友可以点个喜欢，或者去我的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252Flaihuamin%252FJS-total" target="_blank" rel="noopener">github</a>点个star也行，谢谢支持，举起小手指点一点哦😯。</p>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100*100的 canvas 占多少内存</title>
      <link href="/2017/06/04/100-100%E7%9A%84-canvas-%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/"/>
      <url>/2017/06/04/100-100%E7%9A%84-canvas-%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>100*100的 canvas 占多少内存？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实真正的答案是多少我并不清楚，面试过程中面试官也不期待一个准确的答案，而是看你的思考过程。</p><p>如果了解过 Canvas 且做过滤镜相关的工作，可能调用过 <code>imageData = ctx.getImageData(sx, sy, sw, sh);</code> 这个 API。我记得这个 API 返回的是一个 ImageData 数组，包含了 sx, sy, sw, sh 表示的矩形的像素数据。</p><p>而且这个数组是 Uint8 类型的，且四位表示一个像素。</p><p>我在面试的时候只能想起来这些信息。猜想一下，我们在定义颜色的时候就是使用 rgba(r,g,b,a) 四个维度来表示，而且每个像素值就是用十六位 00-ff 表示，即每个维度的范围是 0~255，即 2^8 位，即 1 byte, 也就是 Uint8 能表示的范围。</p><font color="#ff0000"><strong> 所以 100 <em> 100 canvas 占的内存是 100 </em> 100 * 4 bytes = 40,000 bytes。</strong></font><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>这里的答案并不一定准确。</p><h2 id="关于-alpha-的争论"><a href="#关于-alpha-的争论" class="headerlink" title="关于 alpha 的争论"></a>关于 alpha 的争论</h2><p>有同学指出，alpha 不是 0-100 么？我起初也有这样的疑问，不过这篇文章中 <a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FAPI%2FCanvas_API%2FTutorial%2FPixel_manipulation_with_canvas" target="_blank" rel="noopener">developer.mozilla.org/en-US/docs/…</a> 说</p><blockquote><p>The data property returns a Uint8ClampedArray which can be accessed to look at the raw pixel data; each pixel is represented by four one-byte values (red, green, blue, and alpha, in that order; that is, “RGBA” format). Each color component is represented by an integer between 0 and 255.</p></blockquote><p>也就是说即便是 alpha 也是 0-255</p><p>那么如何表示 alpha 呢？</p><p>接下来这段代码中<br><img src="/2017/06/04/100-100的-canvas-占多少内存/166de139a0bb874e.webp" alt=""><br>可以看出，只需要用 0-255 表示 0-100 就可以啦~</p>]]></content>
      
      
      
        <tags>
            
            <tag> canvas </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>(for..in)、Object.keys()和Object.getOwnPropertyNames(),for...of</title>
      <link href="/2017/05/19/for-in-%E3%80%81Object-keys-%E5%92%8CObject-getOwnPropertyNames-for-of/"/>
      <url>/2017/05/19/for-in-%E3%80%81Object-keys-%E5%92%8CObject-getOwnPropertyNames-for-of/</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic2.zhimg.com/v2-8b77517cd30c95a804e67ebf584d888a_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-8b77517cd30c95a804e67ebf584d888a_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/v2-474fc5622ed4a673ef33d34a682250bc_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-474fc5622ed4a673ef33d34a682250bc_hd.jpg" alt=""></p><p>Object.keys（obj），返回一个数组，数组里是该obj可被枚举的所有属性。请看示例：</p><p>示例一：</p><pre><code>function Pasta(grain, width, shape) {          this.grain = grain;          this.width = width;          this.shape = shape;          this.toString = function () {                  return (this.grain + &quot;, &quot; + this.width + &quot;, &quot; + this.shape);          }  }  console.log(Object.keys(Pasta)); //console: []  var spaghetti = new Pasta(&quot;wheat&quot;, 0.2, &quot;circle&quot;);  console.log(Object.keys(spaghetti)); //console: [&quot;grain&quot;, &quot;width&quot;, &quot;shape&quot;, &quot;toString&quot;]</code></pre><p>示例二：</p><pre><code>var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];   console.log(Object.keys(arr)); // console: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]   var obj = { 0 : &quot;a&quot;, 1 : &quot;b&quot;, 2 : &quot;c&quot;};   console.log(Object.keys(obj)); // console: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]   var an_obj = { 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot;};   console.log(Object.keys(an_obj)); // console: [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;]   var my_obj = Object.create({}, { getFoo : { value : function () { return this.foo } } });   my_obj.foo = 1;   console.log(Object.keys(my_obj)); // console: [&quot;foo&quot;]</code></pre><p>js中几种遍历对象的方法，包括for in、Object.keys、Object.getOwnProperty,它们在使用场景方面各有不同。</p><p>for in</p><p>主要用于遍历对象的可枚举属性，包括自有属性、继承自原型的属性</p><pre><code>var obj = {&quot;name&quot;:&quot;Poly&quot;, &quot;career&quot;:&quot;it&quot;}Object.defineProperty(obj, &quot;age&quot;, {value:&quot;forever 18&quot;, enumerable:false});Object.prototype.protoPer1 = function(){console.log(&quot;proto&quot;);};Object.prototype.protoPer2 = 2;console.log(&quot;For In : &quot;);for(var a in obj) console.log(a);</code></pre><p><img src="https://pic4.zhimg.com/v2-07286d25bcdcd379c3da29cf98076e14_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-07286d25bcdcd379c3da29cf98076e14_hd.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/v2-ae93be2db86b326d8c5081a88bcf7636_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-ae93be2db86b326d8c5081a88bcf7636_hd.jpg" alt=""></p><p>Object.keys</p><p>返回一个数组，元素均为对象自有的可枚举属性</p><pre><code>var obj = {&quot;name&quot;:&quot;Poly&quot;, &quot;career&quot;:&quot;it&quot;}Object.defineProperty(obj, &quot;age&quot;, {value:&quot;forever 18&quot;, enumerable:false});Object.prototype.protoPer1 = function(){console.log(&quot;proto&quot;);};Object.prototype.protoPer2 = 2;console.log(&quot;Object.keys:&quot;)console.log(Object.keys(obj));</code></pre><p><img src="https://pic1.zhimg.com/v2-a1f7c5f0d6d306c25660d0087ccd477e_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-a1f7c5f0d6d306c25660d0087ccd477e_hd.jpg" alt=""></p><p><img src="https://pic4.zhimg.com/v2-fd283ee34f31f9aa9133cd96c0ac3fdd_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-fd283ee34f31f9aa9133cd96c0ac3fdd_hd.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/v2-e02bca1186672970087d9a8bc8a5ff08_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-e02bca1186672970087d9a8bc8a5ff08_hd.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-65ab14f08c0821aaddf792402b19aeec_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-65ab14f08c0821aaddf792402b19aeec_hd.jpg" alt=""></p><p>Object.getOwnProperty</p><p>用于返回对象的自有属性，包括可枚举和不可枚举的</p><pre><code>var obj = {&quot;name&quot;:&quot;Poly&quot;, &quot;career&quot;:&quot;it&quot;}Object.defineProperty(obj, &quot;age&quot;, {value:&quot;forever 18&quot;, enumerable:false});Object.prototype.protoPer1 = function(){console.log(&quot;proto&quot;);};Object.prototype.protoPer2 = 2;console.log(&quot;Object.getOwnPropertyNames: &quot;);console.log(Object.getOwnPropertyNames(obj));</code></pre><p><img src="https://pic3.zhimg.com/v2-e58a5ceb8f77c623bd452a5fc8063745_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-e58a5ceb8f77c623bd452a5fc8063745_hd.jpg" alt=""></p><p>for..of</p><pre><code>var obj = {&quot;name&quot;:&quot;Poly&quot;, &quot;career&quot;:&quot;it&quot;}Object.defineProperty(obj, &quot;age&quot;, {value:&quot;forever 18&quot;, enumerable:false});Object.prototype.protoPer1 = function(){console.log(&quot;proto&quot;);};Object.prototype.protoPer2 = 2;console.log(&quot;For of : &quot;);for(var a of Object.entries(obj)) console.log(a);</code></pre><p><img src="https://pic1.zhimg.com/v2-cb632b12eee1e290befbd61a0da022fd_b.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-32223787728e13f239b4f59b0aa64a94_b.jpg" alt=""></p><p><img src="https://pic1.zhimg.com/v2-6ce8346c2e1e4479f49c6acf22292fac_b.jpg" alt=""></p><p><img src="https://pic1.zhimg.com/v2-ec6d7c3be11ccc0101407a2f40ef803a_b.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/v2-84d13fa8dbdace85c39378fd2e9dc09a_b.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> for </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>探索webpack 机制</title>
      <link href="/2017/05/18/%E6%8E%A2%E7%B4%A2webpack-%E6%9C%BA%E5%88%B6/"/>
      <url>/2017/05/18/%E6%8E%A2%E7%B4%A2webpack-%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>本文从简单的例子入手，从打包文件去分析以下三个问题：webpack打包文件是怎样的？如何做到兼容各大模块化方案的？webpack3带来的新特性又是什么？</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>webpack配置</p><pre><code>// webpack.config.jsmodule.exports = {  entry: &apos;./src/index.js&apos;,  output: {    filename: &apos;bundle.js&apos;,    path: path.resolve(__dirname, &apos;dist&apos;)  },};</code></pre><p>简单的js文件</p><pre><code>// src/index.js console.log(&apos;hello world&apos;);</code></pre><p>webpack打包后的代码</p><pre><code>// dist/bundle.js /******/ (function(modules) { // webpackBootstrap/******/     // The module cache/******/     var installedModules = {};/******//******/     // The require function/******/     function __webpack_require__(moduleId) {/******//******/         // Check if module is in cache/******/         if(installedModules[moduleId]) {/******/             return installedModules[moduleId].exports;/******/         }/******/         // Create a new module (and put it into the cache)/******/         var module = installedModules[moduleId] = {/******/             i: moduleId,/******/             l: false,/******/             exports: {}/******/         };/******//******/         // Execute the module function/******/         modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/         // Flag the module as loaded/******/         module.l = true;/******//******/         // Return the exports of the module/******/         return module.exports;/******/     }/******//******//******/     // expose the modules object (__webpack_modules__)/******/     __webpack_require__.m = modules;/******//******/     // expose the module cache/******/     __webpack_require__.c = installedModules;/******//******/     // define getter function for harmony exports/******/     __webpack_require__.d = function(exports, name, getter) {/******/         if(!__webpack_require__.o(exports, name)) {/******/             Object.defineProperty(exports, name, {/******/                 configurable: false,/******/                 enumerable: true,/******/                 get: getter/******/             });/******/         }/******/     };/******//******/     // getDefaultExport function for compatibility with non-harmony modules/******/     __webpack_require__.n = function(module) {/******/         var getter = module &amp;&amp; module.__esModule ?/******/             function getDefault() { return module[&apos;default&apos;]; } :/******/             function getModuleExports() { return module; };/******/         __webpack_require__.d(getter, &apos;a&apos;, getter);/******/         return getter;/******/     };/******//******/     // Object.prototype.hasOwnProperty.call/******/     __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };/******//******/     // __webpack_public_path__/******/     __webpack_require__.p = &quot;&quot;;/******//******/     // Load entry module and return exports/******/     return __webpack_require__(__webpack_require__.s = 0);/******/ })/************************************************************************//******/ ([/* 0 *//***/ (function(module, exports) {console.log(&apos;hello world&apos;);/***/ })/******/ ]);</code></pre><p>一看你就会想，我就一行代码，你给我打包那么多？？？（黑人问号）</p><p>我们来分析一下这部分代码，先精简一下，其实整体就是一个自执行函数，然后传入一个模块数组</p><pre><code>(function(modules) {      //... })([function(module, exports) {     //.. }])</code></pre><p>好了，传入模块数组做了什么(其实注释都很明显了，我只是大概翻译一下）</p><pre><code>/******/ (function(modules) { // webpackBootstrap/******/     // The module cache  缓存已经load过的模块/******/     var installedModules = {};/******//******/     // The require function  引用的函数/******/     function __webpack_require__(moduleId) {/******//******/         // Check if module is in cache 假如在缓存里就直接返回/******/         if(installedModules[moduleId]) {/******/             return installedModules[moduleId].exports;/******/         }/******/         // Create a new module (and put it into the cache) 构造一个模块并放入缓存/******/         var module = installedModules[moduleId] = {/******/             i: moduleId, //模块id/******/             l: false, // 是否已经加载完毕/******/             exports: {} // 对外暴露的内容/******/         };/******//******/         // Execute the module function 传入模块参数，并执行模块/******/         modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);/******//******/         // Flag the module as loaded 标记模块已经加载完毕/******/         module.l = true;/******//******/         // Return the exports of the module 返回模块暴露的内容/******/         return module.exports;/******/     }/******//******//******/     // expose the modules object (__webpack_modules__) 暴露模块数组/******/     __webpack_require__.m = modules;/******//******/     // expose the module cache 暴露缓存数组/******/     __webpack_require__.c = installedModules;/******//******/     // define getter function for harmony exports 为ES6 exports定义getter/******/     __webpack_require__.d = function(exports, name, getter) {/******/         if(!__webpack_require__.o(exports, name)) { // 假如exports本身不含有name这个属性/******/             Object.defineProperty(exports, name, {/******/                 configurable: false,/******/                 enumerable: true,/******/                 get: getter/******/             });/******/         }/******/     };/******//******/     // getDefaultExport function for compatibility with non-harmony modules 解决ES module和Common js module的冲突，ES则返回module[&apos;default&apos;]/******/     __webpack_require__.n = function(module) {/******/         var getter = module &amp;&amp; module.__esModule ?/******/             function getDefault() { return module[&apos;default&apos;]; } :/******/             function getModuleExports() { return module; };/******/         __webpack_require__.d(getter, &apos;a&apos;, getter);/******/         return getter;/******/     };/******//******/     // Object.prototype.hasOwnProperty.call/******/     __webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };/******//******/     // __webpack_public_path__ webpack配置下的公共路径/******/     __webpack_require__.p = &quot;&quot;;/******//******/     // Load entry module and return exports 最后执行entry模块并且返回它的暴露内容/******/     return __webpack_require__(__webpack_require__.s = 0);/******/ })/************************************************************************//******/ ([/* 0 *//***/ (function(module, exports) {console.log(&apos;hello world&apos;);/***/ })/******/ ]);</code></pre><p>整体流程是怎样的呢</p><ul><li>传入module数组</li><li><p>调用<strong>webpack_require</strong>(<strong>webpack_require</strong>.s = 0)</p></li><li><p>构造module对象，放入缓存</p></li><li>调用module,传入相应参数modules[moduleId].call(module.exports, module, module.exports, <strong>webpack_require</strong>); （这里exports会被函数内部的东西修改）</li><li>标记module对象已经加载完毕</li><li><p>返回模块暴露的内容（注意到上面函数传入了module.exports,可以对引用进行修改）</p></li><li><p>模块函数中传入module, module.exports, webpack_require</p></li><li>执行过程中通过对上面三者的引用修改，完成变量暴露和引用</li></ul><h2 id="webpack模块机制是怎样的"><a href="#webpack模块机制是怎样的" class="headerlink" title="webpack模块机制是怎样的"></a>webpack模块机制是怎样的</h2><p>我们可以去官网看下webpack模块</p><blockquote><p><a href="https://link.zhihu.com/?target=https%3A//doc.webpack-china.org/concepts/modules%23-webpack-" target="_blank" rel="noopener">https://doc.webpack-china.org/concepts/modules#-webpack-</a><br>webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：</p></blockquote><ul><li>ES2015 import 语句</li><li>CommonJS require() 语句</li><li>AMD define 和 require 语句</li><li>css/sass/less 文件中的 @import 语句。</li><li>样式(url(…))或 HTML 文件(<img src="/2017/05/18/探索webpack-机制/...">)中的图片链接(image url)</li></ul><p>强大的webpack模块可以兼容各种模块化方案，并且无侵入性(non-opinionated)</p><p>我们可以再编写例子一探究竟</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>修改src/index.js</p><pre><code>var cj = require(&apos;./cj.js&apos;);console.log(&apos;hello world&apos;);cj();</code></pre><p>新增src/cj.js，保持前面例子其他不变</p><pre><code>// src/cj.jsfunction a() {    console.log(&quot;CommonJS&quot;);}module.exports = a;</code></pre><p>再次运行webpack</p><pre><code>/******/ (function(modules) { // webpackBootstrap  //... 省略代码/******/ })/************************************************************************//******/ ([/* 0 *//***/ (function(module, exports, __webpack_require__) {let cj = __webpack_require__(1);console.log(&apos;hello world&apos;);cj();/***/ }),/* 1 *//***/ (function(module, exports) {function a() {    console.log(&quot;CommonJS&quot;);}module.exports = a;/***/ })/******/ ]);</code></pre><p>我们可以看到模块数组多了个引入的文件，然后index.js模块函数多了个参数<strong>webpack_require</strong>，去引用文件（<strong>webpack_require</strong>在上一节有介绍），整体上就是依赖的模块修改了module.exports，然后主模块执行依赖模块，获取exports即可</p><h2 id="ES2015-import"><a href="#ES2015-import" class="headerlink" title="ES2015 import"></a>ES2015 import</h2><p>新增src/es.js</p><pre><code>// src/es.jsexport default function b() {    console.log(&apos;ES Modules&apos;);}</code></pre><p>修改src/index.js</p><pre><code>// src/index.jsimport es from &apos;./es.js&apos;;console.log(&apos;hello world&apos;);es();</code></pre><p>webpack.config.js不变，执行webpack</p><pre><code>/******/ (function(modules) { // webpackBootstrap// ... 省略代码/******/ })/************************************************************************//******/ ([/* 0 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__es_js__ = __webpack_require__(1);console.log(&apos;hello world&apos;);Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;a&quot; /* default */])();/***/ }),/* 1 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;/* harmony export (immutable) */ __webpack_exports__[&quot;a&quot;] = b;function b() {    console.log(&apos;ES Modules&apos;);}/***/ })/******/ ]);</code></pre><p>我们可以看到它们都变成了严格模式，webpack自动采用的</p><p>表现其实跟CommonJS相似，也是传入export然后修改，在主模块再require进来，</p><p>我们可以看到这个</p><pre><code>Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });</code></pre><p>这个干嘛用的？其实就是标记当前的exports是es模块，还记得之前的<strong>webpack_require</strong>.n吗，我们再拿出来看看</p><pre><code>/******/     // getDefaultExport function for compatibility with non-harmony modules 解决ES module和Common js module的冲突，ES则返回module[&apos;default&apos;]/******/     __webpack_require__.n = function(module) {/******/         var getter = module &amp;&amp; module.__esModule ?/******/             function getDefault() { return module[&apos;default&apos;]; } :/******/             function getModuleExports() { return module; };/******/         __webpack_require__.d(getter, &apos;a&apos;, getter);/******/         return getter;/******/     };</code></pre><p>为了避免跟非ES Modules冲突？冲突在哪里呢？<br>其实这部分如果你看到babel转换ES Modules源码就知道了，为了兼容模块，会把ES Modules直接挂在exports.default上，然后加上__esModule属性，引入的时候判断一次是否是转换模块，是则引入module[‘default’]，不是则引入module</p><p>我们再多引入几个ES Modules看看效果</p><pre><code>// src/es.jsexport function es() {    console.log(&apos;ES Modules&apos;);}export function esTwo() {    console.log(&apos;ES Modules Two&apos;);}export function esThree() {    console.log(&apos;ES Modules Three&apos;);}export function esFour() {    console.log(&apos;ES Modules Four&apos;);}</code></pre><p>我们多引入esTwo和esFour，但是不使用esFour</p><pre><code>// src/index.jsimport { es, esTwo, esFour} from &apos;./es.js&apos;;console.log(&apos;hello world&apos;);es();esTwo();</code></pre><p>得出</p><pre><code>/******/ (function(modules) { // webpackBootstrap// .../******/ })/************************************************************************//******/ ([/* 0 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__es_js__ = __webpack_require__(1);console.log(&apos;hello world&apos;);Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;a&quot; /* es */])();Object(__WEBPACK_IMPORTED_MODULE_0__es_js__[&quot;b&quot; /* esTwo */])();/***/ }),/* 1 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;/* harmony export (immutable) */ __webpack_exports__[&quot;a&quot;] = es;/* harmony export (immutable) */ __webpack_exports__[&quot;b&quot;] = esTwo;/* unused harmony export esThree *//* unused harmony export esFour */function es() {    console.log(&apos;ES Modules&apos;);}function esTwo() {    console.log(&apos;ES Modules Two&apos;);}function esThree() {    console.log(&apos;ES Modules Three&apos;);}function esFour() {    console.log(&apos;ES Modules Four&apos;);}/***/ })/******/ ]);</code></pre><p>嗯嗯其实跟前面是一样的，举出这个例子重点在哪里呢，有没有注意到注释中</p><pre><code>/* unused harmony export esThree *//* unused harmony export esFour */</code></pre><p>esThree是我们没有引入的模块，esFour是我们引用但是没有使用的模块，webpack均对它们做了unused的标记，其实这个如果你使用了webpack插件uglify，通过标记，就会把esThree和esFour这两个未使用的代码消除（其实它就是tree-shaking)</p><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>我们再来看看webpack怎么支持AMD</p><p>新增src/amd.js</p><pre><code>// src/amd.jsdefine([],function(){    return {        amd:function(){            console.log(&apos;AMD&apos;);        }    };});</code></pre><p>修改index.js</p><pre><code>// src/index.jsdefine([    &apos;./amd.js&apos;],function(amdModule){    amdModule.amd();});</code></pre><p>得到</p><pre><code>/******/ (function(modules) { // webpackBootstrap// ... 省略代码/******/ })/************************************************************************//******/ ([/* 0 *//***/ (function(module, exports, __webpack_require__) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [    __webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(amdModule){    amdModule.amd();}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));/***/ }),/* 1 *//***/ (function(module, exports, __webpack_require__) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function(){    return {        amd:function(){            console.log(&apos;AMD&apos;);        }    };}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),                __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp; (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));/***/ })/******/ ]);</code></pre><p>先看amd.js整理一下代码</p><pre><code>function(module, exports, __webpack_require__) {    var __WEBPACK_AMD_DEFINE_ARRAY__,        __WEBPACK_AMD_DEFINE_RESULT__;    !(        __WEBPACK_AMD_DEFINE_ARRAY__ = [],        __WEBPACK_AMD_DEFINE_RESULT__ = function() {            return {                amd: function() {                    console.log(&apos;AMD&apos;);                }            };        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp;        (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)    );})</code></pre><p>简单来讲收集define Array然后置入返回函数，根据参数获取依赖</p><blockquote><p>apply对数组拆解成一个一个参数</p></blockquote><p>再看index.js模块部分</p><pre><code>function(module, exports, __webpack_require__) {    var __WEBPACK_AMD_DEFINE_ARRAY__,        __WEBPACK_AMD_DEFINE_RESULT__;    !(        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)],        __WEBPACK_AMD_DEFINE_RESULT__ = function(amdModule) {                amdModule.amd();        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &amp;&amp;         (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)    );}</code></pre><p>其实就是引入了amd.js暴露的{amd:[Function: amd]}</p><h2 id="css-image"><a href="#css-image" class="headerlink" title="css/image?"></a>css/image?</h2><p>css和image也可以成为webpack的模块，这是令人震惊的，这就不能通过普通的hack commonjs或者函数调用简单去调用了，这就是anything to JS，它就需要借助webpack loader去实现了</p><blockquote><p>像css就是转换成一段js代码，通过处理，调用时就是可以用js将这段css插入到style中，image也类似，这部分就不详细阐述了，有兴趣的读者可以深入去研究</p></blockquote><h2 id="webpack3新特性"><a href="#webpack3新特性" class="headerlink" title="webpack3新特性"></a>webpack3新特性</h2><p>我们可以再顺便看下webpack3新特性的表现<br>具体可以看这里<a href="https://link.zhihu.com/?target=https%3A//medium.com/webpack/webpack-3-official-release-15fd2dd8f07b" target="_blank" rel="noopener">https://medium.com/webpack/webpack-3-official-release-15fd2dd8f07b</a></p><h2 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h2><p>我们可以发现模块数组是一个一个独立的函数然后闭包引用webpack主函数的相应内容，每个模块都是独立的，然后带来的结果是在浏览器中执行速度变慢，然后webpack3学习了Closure Compiler和RollupJS这两个工具，连接所有闭包到一个闭包里，放入一个函数，让执行速度更快,并且整体代码体积也会有所缩小</p><p>我们可以实际看一下效果（要注意的是这个特性只支持ES Modules,是不支持CommonJs和AMD的）<br>使用上面的例子，配置webpack.config.js，增加new webpack.optimize.ModuleConcatenationPlugin()</p><pre><code>const path = require(&apos;path&apos;);const webpack = require(&apos;webpack&apos;);module.exports = {  entry: &apos;./src/index.js&apos;,  output: {    filename: &apos;bundle.js&apos;,    path: path.resolve(__dirname, &apos;dist&apos;)  },  module: {  },  plugins: [    new webpack.optimize.ModuleConcatenationPlugin(),  ]};</code></pre><p>打包</p><pre><code>/******/ (function(modules) { // webpackBootstrap// ... 省略代码/******/ })/************************************************************************//******/ ([/* 0 *//***/ (function(module, __webpack_exports__, __webpack_require__) {&quot;use strict&quot;;Object.defineProperty(__webpack_exports__, &quot;__esModule&quot;, { value: true });// CONCATENATED MODULE: ./src/es.jsfunction es() {    console.log(&apos;ES Modules&apos;);}function esTwo() {    console.log(&apos;ES Modules Two&apos;);}function esThree() {    console.log(&apos;ES Modules Three&apos;);}function esFour() {    console.log(&apos;ES Modules Four&apos;);}// CONCATENATED MODULE: ./src/index.js// src/index.jsconsole.log(&apos;hello world&apos;);es();/***/ })/******/ ]);</code></pre><p>我们可以惊喜的发现没有什么require了，它们拼接成了一个函数，good!?</p><h2 id="Magic-Comments"><a href="#Magic-Comments" class="headerlink" title="Magic Comments"></a>Magic Comments</h2><p>code splitting是webpack一个重点特性之一，涉及到要动态引入的时候，webpack可以使用 require.ensure去实现，后来webpack2支持使用了符合 ECMAScript 提案 的 import() 语法，但是它有个不足之处，无法指定chunk的名称chunkName,为了解决这个问题，出现了Magic Comments，支持用注释的方式去指定，如下</p><pre><code>import(/* webpackChunkName: &quot;my-chunk-name&quot; */ &apos;module&apos;);</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>webpack是一个强大的模块打包工具，在处理依赖、模块上都很优秀，本文从bundle.js文件分析出发去探索了不同模块方案的加载机制，初步去理解webpack，并且对webpack3特性进行阐述，当然，webpack还有很多地方需要去探索深究，敬请期待以后的文章吧～</p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的 Promise 对象黑科技</title>
      <link href="/2017/05/03/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-Promise-%E5%AF%B9%E8%B1%A1%E9%BB%91%E7%A7%91%E6%8A%80/"/>
      <url>/2017/05/03/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-Promise-%E5%AF%B9%E8%B1%A1%E9%BB%91%E7%A7%91%E6%8A%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Promise-必知必会（十道题）"><a href="#Promise-必知必会（十道题）" class="headerlink" title="Promise 必知必会（十道题）"></a><a href="https://libin1991.github.io/2018/09/25/Promise-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/" target="_blank" rel="noopener">Promise 必知必会（十道题）</a></h2><h2 id="一、resolve-后的执行情况"><a href="#一、resolve-后的执行情况" class="headerlink" title="一、resolve 后的执行情况"></a>一、resolve 后的执行情况</h2><p>无论是 resolve, reject，都会将函数剩余的代码执行完</p><pre><code>const promise = new Promise((resolve, reject) =&gt; {    console.log(&apos;mark 1&apos;);    resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);    console.log(&apos;mark 2&apos;);});promise.then(result =&gt; {    console.log(result);}).catch(err =&gt; {    console.log(err);});</code></pre><p>相当于：</p><pre><code>const promise = new Promise((resolve, reject) =&gt; {    console.log(&apos;mark 1&apos;);    console.log(&apos;mark 2&apos;);    resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);});promise.then(result =&gt; {    console.log(result);}).catch(err =&gt; {    console.log(err);});</code></pre><p>如果你不想在 resolve 或 reject 后执行剩下的代码段，可以在 resolve 后将其返回<br><img src="https://pic4.zhimg.com/v2-f5b865c8a9df8ce752d057fe177c855e_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-f5b865c8a9df8ce752d057fe177c855e_hd.jpg" alt=""></p><pre><code>const promise = new Promise((resolve, reject) =&gt; {    console.log(&apos;mark 1&apos;);    return resolve(&apos;hello world&apos;);     // reject(&apos;hello world&apos;);    console.log(&apos;mark 2&apos;);             // never be here});promise.then(result =&gt; {    console.log(result);}).catch(err =&gt; {    console.log(err);});</code></pre><h2 id="二、串行执行和并行执行："><a href="#二、串行执行和并行执行：" class="headerlink" title="二、串行执行和并行执行："></a>二、串行执行和并行执行：</h2><ol><li>串行执行：有一堆 Promise 对象，它们的执行顺序是固定的，前一个 promise 执行完后，后一个 promise 才开始执行，比如数据库查询，它们往往有前后的因果关系。</li><li>并行执行：有一堆 Promise 对象，它们的执行顺序是不固定的，没有前后因果关系，可以并发地去执行。</li></ol><p>并行执行很好解决，在 Promise中有 all 这个函数支持, Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。当多个 Promise 实例执行完后才去执行最后新的 Promise 实例。</p><pre><code>const datum = [];for(let i = 0; i &lt; 10; i++) {    datum.push(i);}Promise.all(datum.map(i =&gt; {    return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        console.log(i * 200 + &quot; ms 后执行结束&quot;);        resolve(&quot;第 &quot; + (i + 1) + &quot; 个 Promise 执行结束&quot;);    }, i * 200);    })})).then((data) =&gt; {    console.log(data);});</code></pre><p>如果不使用 Promise.all 这个方法的话，你也可以使用像 ES7 的 async/await</p><pre><code>const asyncFun = async () =&gt; {    const datum = []    for(let i = 0; i &lt; 10; i++) {        datum.push(new Promise((resolve, reject) =&gt; {            setTimeout(() =&gt; {                console.log(i * 200 + &apos;ms 后执行结束&apos;)                resolve(&apos;第 &apos; + (i + 1) + &apos; 个 Promise 执行结束&apos;)            }, i * 200)        }))    }    const result = []    for(let promise of datum) {        result.push(await promise)    }    console.log(result)}asyncFun()</code></pre><p>串行执行：这里提供两种方式</p><pre><code>const datum = [];for(let i = 0; i &lt; 10; i++) {    datum.push(i);}let serial = Promise.resolve();for(let i of datum) {    serial = serial.then(data =&gt; {        console.log(data);    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {        console.log(i * 200 + &quot; ms 后执行结束&quot;);        resolve(&quot;第 &quot; + (i + 1) + &quot; 个 Promise 执行结束&quot;);        }, i * 200);    })        });}</code></pre><p>另外可以使用 reduce 来串行：</p><pre><code>const datum = [];for(let i = 0; i &lt; 10; i++) {    datum.push(i);}datum.reduce((prev, cur) =&gt; {    return prev.then(data =&gt; {    console.log(data);    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {        console.log(cur * 200 + &quot; ms 后执行结束&quot;);        resolve(&quot;第 &quot; + (cur + 1) + &quot; 个 Promise 执行结束&quot;);        }, cur * 200);    })        })}, Promise.resolve(true));</code></pre><h2 id="三、值穿透问题："><a href="#三、值穿透问题：" class="headerlink" title="三、值穿透问题："></a>三、值穿透问题：</h2><pre><code>let promise = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        resolve(&apos;Hello World!&apos;);    }, 1000)});promise.then(&apos;呵呵哒&apos;).then((data) =&gt; {    console.log(data);           // Hello World})</code></pre><p>这是一种值穿透的情况，一般有下面两种情况：<br>promise 已经是 FULFILLED/REJECTED 时，通过 return this 实现的值穿透：<br><img src="https://pic3.zhimg.com/v2-99374235673349f56d708c28511c27d2_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-99374235673349f56d708c28511c27d2_hd.jpg" alt=""></p><pre><code>let promise = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        resolve(&apos;Hello World!&apos;);    }, 1000)});promise.then(() =&gt; {    promise.then().then(null).then(&apos;呵呵哒&apos;).then((res) =&gt; {        console.log(res)    })    promise.catch().catch(null).then(&apos;呵呵哒&apos;).then((res) =&gt; {        console.log(res)     })})</code></pre><p>promise 是 PENDING 时，通过生成新的 promise 加入到父 promise 的 queue，父 promise 有值时调用 callFulfilled-&gt;doResolve 或 callRejected-&gt;doReject（因为 then/catch 传入的参数不是函数）设置子 promise 的状态和值为父 promise 的状态和值。如：<br><img src="https://pic2.zhimg.com/v2-7d3d3728e3b1f90d905d4f4782c1f97a_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7d3d3728e3b1f90d905d4f4782c1f97a_hd.jpg" alt=""></p><pre><code>let promise = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        resolve(&apos;Hello World!&apos;);    }, 1000)});let a = promise.then(&apos;呵呵哒&apos;);a.then(res =&gt; {    console.log(res);});let b = promise.catch(&apos;呵呵哒&apos;);b.then(res =&gt; {    console.log(res);})</code></pre><p>总而言之，当你给 then() 传递一个非函数（比如一个 promise ）值的时候，它实际上会解释为 then(null) ，这会导致之前的 promise 的结果丢失。例如:<br><img src="https://pic1.zhimg.com/v2-14fe675c00c5bc8154d161e3afed0f41_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-14fe675c00c5bc8154d161e3afed0f41_hd.jpg" alt=""></p><pre><code>Promise.resolve(&apos;First Value&apos;).then(Promise.resolve(&apos;Second Value&apos;)).then(null).then((value) =&gt; {    console.log(value)    // First Value})</code></pre><h2 id="四、不要在异步回调函数中使用-throw-Error"><a href="#四、不要在异步回调函数中使用-throw-Error" class="headerlink" title="四、不要在异步回调函数中使用 throw Error"></a>四、不要在异步回调函数中使用 throw Error</h2><p>不仅 reject，抛出的异常也会被作为拒绝状态被 Promise 捕获</p><pre><code>let promise = new Promise((resolve, reject) =&gt; {    reject(&apos;This is an error&apos;);});promise.then(result =&gt; {    console.log(result);}).catch(error =&gt; {    console.log(&apos;handle error: &apos;, error);  //handle error:  Error: This is an error})</code></pre><p>但是，永远不要在回调队列中抛出异常，因为回调队列脱离了运行上下文环境，异常无法被当前作用域捕获。</p><pre><code>let promise = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        throw Error(&apos;This is an error&apos;);    });});promise.then(result =&gt; {    console.log(result);}).catch(error =&gt; {    console.log(&apos;handle error: &apos;, error);  // Error: This is an error});</code></pre><p>简单说来，回调队列指的是 JS 事件循环中的 macrotask 队列，比如 setTimeout setInterval 会插入到 macrotask 中。如果要在回调函数中捕获异常，请使用 reject，永远不要使用 Error。<br>上述的代码应改成：</p><pre><code>let promise = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        reject(&apos;This is an error&apos;);    });});promise.then(result =&gt; {    console.log(result);}).catch(error =&gt; {    console.log(&apos;handle error: &apos;, error);  // Error: This is an error});</code></pre><h2 id="五、then-的第二个参数跟-catch-的区别-【面试常问】"><a href="#五、then-的第二个参数跟-catch-的区别-【面试常问】" class="headerlink" title="五、then 的第二个参数跟 catch 的区别 【面试常问】"></a>五、then 的第二个参数跟 catch 的区别 【面试常问】</h2><p>我们都知道 then 的第二参数跟 catch 用法很像，都是用来进行错误处理的，比如下面这段代码：</p><pre><code>let promise1 = new Promise((resolve, reject) =&gt; {    reject(&apos;this is an error&apos;);});promise1.then(data =&gt; {    console.log(data);}, err =&gt; {    console.log(&apos;handle err:&apos;, err);    // handle err: this is an error});let promise2 = new Promise((resolve, reject) =&gt; {    reject(&apos;this is an error&apos;);});promise2.then(data =&gt; {    console.log(data);}).catch(err =&gt; {    console.log(&apos;handle err:&apos;, err);    // handle err: this is an error});</code></pre><p>当时这两者还是区别的，区别于 then 的第二参数无法处理第一参数函数中的错误。</p><pre><code>let promise1 = Promise.resolve();promise1.then(() =&gt; {    throw Error(&apos;this is a error&apos;);   //UnhandledPromiseRejectionWarning: Unhandled promise rejection}, err =&gt; {    console.log(err);})let promise2 = Promise.resolve();promise2.then(() =&gt; {    throw Error(&apos;this is a error&apos;);  }).catch(err =&gt; {    console.log(&apos;handle err:&apos;, err);    //handle err: Error: this is a error})</code></pre><blockquote><p>当你使用then( resolveHandler, rejectHandler)格式，如果 resolveHandler 自己抛出一个错误 rejectHandler 并不能捕获。第一个 Promise 对象无法处理同级 then 中的函数抛出的异常，所以在一般情况下，最后直接使用 catch 来进行异常捕获比较保险。</p></blockquote><h2 id="六、处理最后-catch-函数中的异常"><a href="#六、处理最后-catch-函数中的异常" class="headerlink" title="六、处理最后 catch 函数中的异常"></a>六、处理最后 catch 函数中的异常</h2><p>一般我们用 catch 来捕捉前面抛出的异常，但是如果试想一下如果最后一个 catch 函数也抛出了异常，应该怎么处理呢?</p><pre><code>let promise = new Promise((resolve, reject) =&gt; {    reject(&apos;Hello World&apos;)});promise.catch((err) =&gt; {    throw(&apos;Unexpected Error&apos;);   // Uncaught (in promise) Unexpected Error})</code></pre><p>面对这样的错误，不管以 then 方法或 catch 方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）这里提供两种思路：</p><ul><li><p>拓展 Promise.prototype 的方法，添加一个 done 函数，将错误抛向全局。</p><p>  window.onerror = (err) =&gt; {</p><pre><code>console.log(err);</code></pre><p>  }<br>  Promise.prototype.done = function (onFulfilled, onRejected) {</p><pre><code>this.then(onFulfilled, onRejected)  .catch(function (reason) {    // 抛出一个全局错误    setTimeout(() =&gt; { throw reason }, 0);  });</code></pre><p>  };<br>  let promise = new Promise((resolve, reject) =&gt; {</p><pre><code>reject(&apos;Hello World&apos;)</code></pre><p>  });</p><p>  promise.catch((err) =&gt; {</p><pre><code>throw(&apos;Unexpected Error&apos;);     // Uncaught Unexpected Error</code></pre><p>  }).done()</p></li></ul><ul><li>在全局添加 unhandledrejection 事件捕获 Promise 异常。</li></ul><p><img src="https://pic3.zhimg.com/v2-b512c7648df6d0d6fefb64d01009c175_b.jpg" alt=""></p><pre><code>window.addEventListener(&quot;unhandledrejection&quot;, (e) =&gt;{    console.log(e.reason)})    let promise = new Promise((resolve, reject) =&gt; {    reject(&apos;Hello World&apos;)});promise.catch((err) =&gt; {    throw(&apos;Unexpected Error&apos;);     // Unexpected Error})</code></pre><h2 id="七、未捕获的错误可以被恢复"><a href="#七、未捕获的错误可以被恢复" class="headerlink" title="七、未捕获的错误可以被恢复"></a>七、未捕获的错误可以被恢复</h2><pre><code>let promise = new Promise((resolve, reject) =&gt; [    reject(&apos;Hello world&apos;)]).then(() =&gt; {    console.log(&apos;resolve&apos;)})setTimeout(() =&gt; {    promise.catch((e) =&gt; {        console.log(e)    }).then(() =&gt; {        console.log(&apos;catch resolve&apos;)    })}, 1000)</code></pre><h2 id="八、resolved-状态的-Promise-不会立即执行"><a href="#八、resolved-状态的-Promise-不会立即执行" class="headerlink" title="八、resolved 状态的 Promise 不会立即执行"></a>八、resolved 状态的 Promise 不会立即执行</h2><pre><code>let i = 0;Promise.resolve(&apos;resolved promise&apos;).then(() =&gt; {    i += 2})console.log(i)  // 0</code></pre><p>即使是 resolve 的 Promise 调用 then 方法也是异步执行。</p><h2 id="九、结合-async-await-编写同步代码"><a href="#九、结合-async-await-编写同步代码" class="headerlink" title="九、结合 async/await 编写同步代码"></a>九、结合 async/await 编写同步代码</h2><ol><li>async/await 函数可以帮助我们彻底摆脱回调地狱的烦恼，用一种同步的方式来编写异步函数。</li><li>await 后面可以接数值，如果是异步请求的话可以接 Thunk 函数和 Promise 对象。</li></ol><p><img src="https://pic4.zhimg.com/v2-3ca5e16c6ba1743725cc92a7a8e5a7e2_b.jpg" alt=""></p><pre><code>const timeout = (ms) =&gt; {    return new Promise((resolve) =&gt; {        setTimeout(() =&gt; {            resolve(ms + &apos; passed&apos;)        }, ms)    })}const asyncFunc =  async () =&gt; {    const value1 = await timeout(2000)    console.log(value1)    const value2 = await timeout(2000)    console.log(value2)}asyncFunc()console.log(&apos;now&apos;)</code></pre><h2 id="十、调用-then-方法返回新的-Promise-对象"><a href="#十、调用-then-方法返回新的-Promise-对象" class="headerlink" title="十、调用 then 方法返回新的 Promise 对象"></a>十、调用 then 方法返回新的 Promise 对象</h2><pre><code>let promise1 = new Promise((resolve) =&gt; {    resolve(&apos;Hello world&apos;)})let promise2 = promise1.then()console.log(promise1 === promise2)    // falseconsole.log(promise1 instanceof Promise)  // trueconsole.log(promise2 instanceof Promise)  // true</code></pre><p>每次调用 then 方法后都会返回一个新的 Promise 对象，并不是返回原本的 Promise 对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>实现一个 Virtual DOM 算法[转]</title>
      <link href="/2017/05/01/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Virtual-DOM-%E7%AE%97%E6%B3%95/"/>
      <url>/2017/05/01/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Virtual-DOM-%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="virtual-dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。"><a href="#virtual-dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。" class="headerlink" title=" virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。"></a><font color="#dd0000"><strong> virtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。</strong></font></h2><h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><ul><li>1 前言</li><li>2 对前端应用状态管理思考</li><li>3 Virtual DOM 算法</li><li>4 算法实现<ul><li>4.1 步骤一：用JS对象模拟DOM树</li><li>4.2 步骤二：比较两棵虚拟DOM树的差异</li><li>4.3 步骤三：把差异应用到真正的DOM树上</li></ul></li><li>5 结语</li><li>6 References</li></ul><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。</p><h2 id="2-对前端应用状态管理的思考"><a href="#2-对前端应用状态管理的思考" class="headerlink" title="2 对前端应用状态管理的思考"></a>2 对前端应用状态管理的思考</h2><p>假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。<br> <img src="/2017/05/01/实现一个-Virtual-DOM-算法/1.png" alt=""><br>这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var sortKey = &quot;new&quot; // 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数</span><br><span class="line">var sortType = 1 // 升序还是逆序</span><br><span class="line">var data = [&#123;...&#125;, &#123;...&#125;, &#123;..&#125;, ..] // 表格数据</span><br></pre></td></tr></table></figure></p><p>用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。</p><p>这样做会导致的后果就是，随着应用程序越来越复杂，需要在JS里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的DOM操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是DOM操作），你需要操作的DOM还是需要操作，只是换了个地方。</p><p>既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看<a href="https://github.com/livoras/blog/issues/11" target="_blank" rel="noopener">这篇介绍</a>）。</p><p>MVVM 可以很好的降低我们维护状态 -&gt; 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染<strong>整个视图</strong>，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在JS里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下<code>innerHTML</code>就完事了。</p><p>听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，<code>input</code>和<code>textarea</code>的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（Backbone就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。</p><p><strong>但是这里要明白和记住这种做法</strong>，因为后面你会发现，<strong>其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更</strong>。</p><p>另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：<strong>维护状态，更新视图</strong>。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。</p><h2 id="3-Virtual-DOM算法"><a href="#3-Virtual-DOM算法" class="headerlink" title="3 Virtual DOM算法"></a>3 Virtual DOM算法</h2><p>DOM是很慢的。如果我们把一个简单的<code>div</code>元素的属性都打印出来，你会看到：<br> <img src="/2017/05/01/实现一个-Virtual-DOM-算法/2.png" alt=""><br>而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。</p><p>相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var element = &#123;</span><br><span class="line">  tagName:&apos;ul&apos;, // 节点标签名</span><br><span class="line">  props: &#123; // DOM的属性，用一个对象存储键值对</span><br><span class="line">    id:&apos;list&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  children: [ // 该节点的子节点</span><br><span class="line">    &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 1&quot;]&#125;,</span><br><span class="line">    &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 2&quot;]&#125;,</span><br><span class="line">    &#123;tagName:&apos;li&apos;, props: &#123;class:&apos;item&apos;&#125;, children: [&quot;Item 3&quot;]&#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面对应的HTML写法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ulid=&apos;list&apos;&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。</p><p>之前的章节所说的，状态变更-&gt;重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。</p><p>但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。</p><p>这就是所谓的 Virtual DOM 算法。包括几个步骤：</p><ol><li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li><li>把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了</li></ol><p>Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。</p><h2 id="4-算法实现"><a href="#4-算法实现" class="headerlink" title="4 算法实现"></a>4 算法实现</h2><h3 id="4-1-步骤一：用JS对象模拟DOM树"><a href="#4-1-步骤一：用JS对象模拟DOM树" class="headerlink" title="4.1 步骤一：用JS对象模拟DOM树"></a>4.1 步骤一：用JS对象模拟DOM树</h3><p>用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点：</p><p>element.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">functionElement (tagName, props, children) &#123;</span><br><span class="line">  this.tagName= tagName</span><br><span class="line">  this.props= props</span><br><span class="line">  this.children= children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports=function (tagName, props, children) &#123;</span><br><span class="line">  returnnewElement(tagName, props, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如上面的 DOM 结构就可以简单的表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var el =require(&apos;./element&apos;)</span><br><span class="line"></span><br><span class="line">var ul =el(&apos;ul&apos;, &#123;id:&apos;list&apos;&#125;, [</span><br><span class="line">  el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 1&apos;]),</span><br><span class="line">  el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 2&apos;]),</span><br><span class="line">  el(&apos;li&apos;, &#123;class:&apos;item&apos;&#125;, [&apos;Item 3&apos;])</span><br><span class="line">])</span><br></pre></td></tr></table></figure></p><p>现在<code>ul</code>只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个<code>ul</code>构建真正的<code>&lt;ul&gt;</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.render=function () &#123;</span><br><span class="line">  var el =document.createElement(this.tagName) // 根据tagName构建var props =this.propsfor (var propName in props) &#123; // 设置节点的DOM属性var propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var children =this.children|| []</span><br><span class="line"></span><br><span class="line">  children.forEach(function (child) &#123;</span><br><span class="line">    var childEl = (child instanceofElement)</span><br><span class="line">      ?child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点:document.createTextNode(child) // 如果字符串，只构建文本节点el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>render</code>方法会根据<code>tagName</code>构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var ulRoot =ul.render()</span><br><span class="line">document.body.appendChild(ulRoot)</span><br></pre></td></tr></table></figure></p><p>上面的<code>ulRoot</code>是真正的DOM节点，把它塞入文档中，这样<code>body</code>里面就有了真正的<code>&lt;ul&gt;</code>的DOM结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ulid=&apos;list&apos;&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 1&lt;/li&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 2&lt;/li&gt;</span><br><span class="line">  &lt;liclass=&apos;item&apos;&gt;Item 3&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>完整代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/element.js" target="_blank" rel="noopener">element.js</a>。</p><h3 id="4-2-步骤二：比较两棵虚拟DOM树的差异"><a href="#4-2-步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="4.2 步骤二：比较两棵虚拟DOM树的差异"></a>4.2 步骤二：比较两棵虚拟DOM树的差异</h3><p>正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比：<br> <img src="/2017/05/01/实现一个-Virtual-DOM-算法/3.png" alt=""><br>上面的<code>div</code>只会和同一层级的<code>div</code>对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p><h4 id="4-2-1-深度优先遍历，记录差异"><a href="#4-2-1-深度优先遍历，记录差异" class="headerlink" title="4.2.1 深度优先遍历，记录差异"></a>4.2.1 深度优先遍历，记录差异</h4><p>在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记：</p><p> <img src="/2017/05/01/实现一个-Virtual-DOM-算法/4.png" alt=""></p><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// diff 函数，对比两棵树functiondiff (oldTree, newTree) &#123;</span><br><span class="line">  var index =0// 当前节点的标志var patches = &#123;&#125; // 用来记录每个节点差异的对象dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  return patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对两棵树进行深度优先遍历functiondfsWalk (oldNode, newNode, index, patches) &#123;</span><br><span class="line">  // 对比oldNode和newNode的不同，记录下来</span><br><span class="line">  patches[index] = [...]</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历子节点functiondiffChildren (oldChildren, newChildren, index, patches) &#123;</span><br><span class="line">  var leftNode =nullvar currentNodeIndex = index</span><br><span class="line">  oldChildren.forEach(function (child, i) &#123;</span><br><span class="line">    var newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp;leftNode.count) // 计算节点的标识? currentNodeIndex +leftNode.count+1: currentNodeIndex +1dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点</span><br><span class="line">    leftNode = child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如，上面的<code>div</code>和新的<code>div</code>有差异，当前的标记是0，那么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;difference&#125;, &#123;difference&#125;, ...] // 用数组存储新旧节点的不同</span><br></pre></td></tr></table></figure></p><p>同理<code>p</code>是<code>patches[1]</code>，<code>ul</code>是<code>patches[3]</code>，类推。</p><h4 id="4-2-2-差异类型"><a href="#4-2-2-差异类型" class="headerlink" title="4.2.2 差异类型"></a>4.2.2 差异类型</h4><p>上面说的节点的差异指的是什么呢？对 DOM 操作可能会：</p><ol><li>替换掉原来的节点，例如把上面的<code>div</code>换成了<code>section</code></li><li>移动、删除、新增子节点，例如上面<code>div</code>的子节点，把<code>p</code>和<code>ul</code>顺序互换</li><li>修改了节点的属性</li><li>对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为<code>Virtual DOM 2</code>。</li></ol><p>所以我们定义了几种差异类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var REPLACE = 0</span><br><span class="line">var REORDER = 1</span><br><span class="line">var PROPS = 2</span><br><span class="line">var TEXT = 3</span><br></pre></td></tr></table></figure></p><p>对于节点替换，很简单。判断新旧节点的<code>tagName</code>和是不是一样的，如果不一样的说明需要替换掉。如<code>div</code>换成<code>section</code>，就记录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">  type:REPALCE,</span><br><span class="line">  node: newNode // el(&apos;section&apos;, props, children)</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>如果给<code>div</code>新增了属性<code>id</code>为<code>container</code>，就记录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">  type:REPALCE,</span><br><span class="line">  node: newNode // el(&apos;section&apos;, props, children)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  type:PROPS,</span><br><span class="line">  props: &#123;</span><br><span class="line">    id:&quot;container&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>如果是文本节点，如上面的文本节点2，就记录下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[2] = [&#123;</span><br><span class="line">  type:TEXT,</span><br><span class="line">  content:&quot;Virtual DOM2&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>那如果把我<code>div</code>的子节点重新排序呢？例如<code>p, ul, div</code>的顺序换成了<code>div, p, ul</code>。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如<code>p</code>和<code>div</code>的<code>tagName</code>不同，<code>p</code>会被<code>div</code>所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。</p><p>这牵涉到两个列表的对比算法，需要另外起一个小节来讨论。</p><h4 id="4-2-3-列表对比算法"><a href="#4-2-3-列表对比算法" class="headerlink" title="4.2.3 列表对比算法"></a>4.2.3 列表对比算法</h4><p>假设现在可以英文字母唯一地标识每一个子节点：<br>旧的节点顺序：</p><pre><code>a b c d e f g h i</code></pre><p>现在对节点进行了删除、插入、移动的操作。新增<code>j</code>节点，删除<code>e</code>节点，移动<code>h</code>节点：<br>新的节点顺序：</p><pre><code>a b c h d f g i j</code></pre><p>现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="noopener">Edition Distance</a>），最常见的解决算法是 <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" target="_blank" rel="noopener">Levenshtein Distance</a>，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考<a href="https://github.com/livoras/list-diff/blob/master/lib/diff.js" target="_blank" rel="noopener">代码</a>。</p><p>我们能够获取到某个父节点的子节点的操作，就可以记录下来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">patches[0] = [&#123;</span><br><span class="line">  type:REORDER,</span><br><span class="line">  moves: [&#123;remove or insert&#125;, &#123;remove or insert&#125;, ...]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></p><p>但是要注意的是，因为<code>tagName</code>是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识<code>key</code>，列表对比的时候，使用<code>key</code>进行对比，这样才能复用老的 DOM 树上的节点。</p><p>这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js" target="_blank" rel="noopener">diff.js</a>。</p><h3 id="4-3-步骤三：把差异应用到真正的DOM树上"><a href="#4-3-步骤三：把差异应用到真正的DOM树上" class="headerlink" title="4.3 步骤三：把差异应用到真正的DOM树上"></a>4.3 步骤三：把差异应用到真正的DOM树上</h3><p>因为步骤一所构建的 JavaScript 对象树和<code>render</code>出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的<code>patches</code>对象中找出当前遍历的节点差异，然后进行 DOM 操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">functionpatch (node, patches) &#123;</span><br><span class="line">  var walker = &#123;index:0&#125;</span><br><span class="line">  dfsWalk(node, walker, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functiondfsWalk (node, walker, patches) &#123;</span><br><span class="line">  var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异var len =node.childNodes?node.childNodes.length:0for (var i =0; i &lt; len; i++) &#123; // 深度遍历子节点var child =node.childNodes[i]</span><br><span class="line">    walker.index++dfsWalk(child, walker, patches)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (currentPatches) &#123;</span><br><span class="line">    applyPatches(node, currentPatches) // 对当前节点进行DOM操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>applyPatches，根据不同类型的差异对当前节点进行 DOM 操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">functionapplyPatches (node, currentPatches) &#123;</span><br><span class="line">  currentPatches.forEach(function (currentPatch) &#123;</span><br><span class="line">    switch (currentPatch.type) &#123;</span><br><span class="line">      caseREPLACE:</span><br><span class="line">        node.parentNode.replaceChild(currentPatch.node.render(), node)</span><br><span class="line">        breakcaseREORDER:</span><br><span class="line">        reorderChildren(node, currentPatch.moves)</span><br><span class="line">        breakcasePROPS:</span><br><span class="line">        setProps(node, currentPatch.props)</span><br><span class="line">        breakcaseTEXT:</span><br><span class="line">        node.textContent=currentPatch.contentbreakdefault:</span><br><span class="line">        thrownewError(&apos;Unknown patch type &apos;+currentPatch.type)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整代码可见 <a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js" target="_blank" rel="noopener">patch.js</a>。</p><h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5 结语"></a>5 结语</h2><p>Virtual DOM 算法主要是实现上面步骤的三个函数：<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/element.js" target="_blank" rel="noopener">element</a>，<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/diff.js" target="_blank" rel="noopener">diff</a>，<a href="https://github.com/livoras/simple-virtual-dom/blob/master/lib/patch.js" target="_blank" rel="noopener">patch</a>。然后就可以实际的进行使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 1. 构建虚拟DOM</span><br><span class="line">var tree =el(&apos;div&apos;, &#123;&apos;id&apos;:&apos;container&apos;&#125;, [</span><br><span class="line">    el(&apos;h1&apos;, &#123;style:&apos;color: blue&apos;&#125;, [&apos;simple virtal dom&apos;]),</span><br><span class="line">    el(&apos;p&apos;, [&apos;Hello, virtual-dom&apos;]),</span><br><span class="line">    el(&apos;ul&apos;, [el(&apos;li&apos;)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 2. 通过虚拟DOM构建真正的DOM</span><br><span class="line">var root =tree.render()</span><br><span class="line">document.body.appendChild(root)</span><br><span class="line"></span><br><span class="line">// 3. 生成新的虚拟DOMvar newTree =el(&apos;div&apos;, &#123;&apos;id&apos;:&apos;container&apos;&#125;, [</span><br><span class="line">    el(&apos;h1&apos;, &#123;style:&apos;color: red&apos;&#125;, [&apos;simple virtal dom&apos;]),</span><br><span class="line">    el(&apos;p&apos;, [&apos;Hello, virtual-dom&apos;]),</span><br><span class="line">    el(&apos;ul&apos;, [el(&apos;li&apos;), el(&apos;li&apos;)])</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 4. 比较两棵虚拟DOM树的不同</span><br><span class="line">var patches =diff(tree, newTree)</span><br><span class="line"></span><br><span class="line">// 5. 在真正的DOM元素上应用变更</span><br><span class="line">patch(root, patches)</span><br></pre></td></tr></table></figure></p><p>当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。</p><p>本文所实现的完整代码存放在 <a href="https://github.com/livoras/simple-virtual-dom" target="_blank" rel="noopener">Github</a>，仅供学习。</p><p>本文所实现的完整代码存放在 <a href="https://github.com/livoras/simple-virtual-dom" target="_blank" rel="noopener">Github</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Virtual DOM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NPM学习笔记整理</title>
      <link href="/2017/04/21/NPM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
      <url>/2017/04/21/NPM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="10个-NPM-使用技巧"><a href="#10个-NPM-使用技巧" class="headerlink" title="10个 NPM 使用技巧"></a><a href="https://github.com/dwqs/blog/issues/40" target="_blank" rel="noopener">10个 NPM 使用技巧</a></h1><h1 id="NPM-学习笔记整理"><a href="#NPM-学习笔记整理" class="headerlink" title="NPM 学习笔记整理"></a><a href="https://blog.ihoey.com/posts/Node/2017-05-10-npm.html" target="_blank" rel="noopener">NPM 学习笔记整理</a></h1><hr><h1 id="什么是-NPM什么是-NPM"><a href="#什么是-NPM什么是-NPM" class="headerlink" title="什么是-NPM什么是 NPM"></a><a href="#什么是-NPM">什么是-NPM</a>什么是 NPM</h1><p><code>npm</code> 之于 <code>Node</code> ，就像 <code>pip</code> 之于 <code>Python</code> , <code>gem</code> 之于 <code>Ruby</code> , <code>composer</code> 之于 <code>PHP</code> 。</p><p><code>npm</code> 是 <code>Node</code> 官方提供的包管理工具，他已经成了 <code>Node</code> 包的标准发布平台，用于 <code>Node</code> 包的发布、传播、依赖控制。<br><code>npm</code> 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p><h1 id="为什么要使用-NPM为什么要使用-NPM"><a href="#为什么要使用-NPM为什么要使用-NPM" class="headerlink" title="为什么要使用-NPM为什么要使用 NPM"></a><a href="#为什么要使用-NPM">为什么要使用-NPM</a>为什么要使用 NPM</h1><p><code>npm</code> 是随同 <code>Node</code> 一起安装的包管理工具，能解决 <code>Node</code> 代码部署上的很多问题，常见的场景有以下几种：</p><ul><li>允许用户从 <code>npm</code> 服务器下载别人编写的第三方包到本地使用。</li><li>允许用户从 <code>npm</code> 服务器下载并安装别人编写的命令行程序到本地使用。</li><li>允许用户将自己编写的包或命令行程序上传到 <code>npm</code> 服务器供别人使用。</li></ul><p><code>npm</code> 的背后，是基于 <code>CouchDB</code> 的一个数据库，详细记录了每个包的信息，包括作者、版本、依赖、授权信息等。它的一个很重要的作用就是：将开发者从繁琐的包管理工作（版本、依赖等）中解放出来，更加专注于功能的开发。</p><h1 id="如何使用-NPM如何使用-NPM"><a href="#如何使用-NPM如何使用-NPM" class="headerlink" title="如何使用-NPM如何使用 NPM"></a><a href="#如何使用-NPM">如何使用-NPM</a>如何使用 NPM</h1><h2 id="安装安装"><a href="#安装安装" class="headerlink" title="安装安装"></a><a href="#安装">安装</a>安装</h2><p><code>npm</code> 不需要单独安装。在安装 <code>Node</code> 的时候，会连带一起安装 <code>npm</code> 。但是，<code>Node</code> 附带的 <code>npm</code> 可能不是最新版本，最后用下面的命令，更新到最新版本。</p><pre><code>$ sudo npm install npm@latest -g</code></pre><p>如果是 Window 系统使用以下命令即可：</p><pre><code>npm install npm -g</code></pre><p>也就是使用 <code>npm</code> 安装自己。之所以可以这样，是因为 <code>npm</code> 本身与 <code>Node</code> 的其他模块没有区别。</p><p>然后，运行下面的命令，查看各种信息。</p><pre><code># 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l</code></pre><h2 id="使用使用"><a href="#使用使用" class="headerlink" title="使用使用"></a><a href="#使用">使用</a>使用</h2><h3 id="npm-initnpm-init"><a href="#npm-initnpm-init" class="headerlink" title="npm-initnpm init"></a><a href="#npm-init">npm-init</a>npm init</h3><p><code>npm init</code> 用来初始化生成一个新的 <code>package.json</code> 文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。<br>如果使用了 <code>-f</code>（代表<code>force</code>）、<code>-y</code>（代表<code>yes</code>），则跳过提问阶段，直接生成一个新的 <code>package.json</code> 文件。</p><pre><code>$ npm init -y</code></pre><h3 id="npm-setnpm-set"><a href="#npm-setnpm-set" class="headerlink" title="npm-setnpm set"></a><a href="#npm-set">npm-set</a>npm set</h3><p><code>npm set</code> 用来设置环境变量</p><pre><code>$ npm set init-author-name &apos;Your name&apos;$ npm set init-author-email &apos;Your email&apos;$ npm set init-author-url &apos;http://yourdomain.com&apos;$ npm set init-license &apos;MIT&apos;</code></pre><p>上面命令等于为 <code>npm init</code> 设置了默认值，以后执行 <code>npm init</code> 的时候，<code>package.json</code>的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的 <code>~/.npmrc</code>文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行 <code>npm config</code>。</p><h3 id="npm-infonpm-info"><a href="#npm-infonpm-info" class="headerlink" title="npm-infonpm info"></a><a href="#npm-info">npm-info</a>npm info</h3><p><code>npm info</code> 命令可以查看每个模块的具体信息。比如，查看 <code>underscore</code> 模块的信息。</p><pre><code>$ npm info underscore</code></pre><p>上面命令返回一个 <code>JavaScript</code> 对象，包含了 <code>underscore</code> 模块的详细信息。这个对象的每个成员，都可以直接从 <code>info</code> 命令查询。</p><pre><code>$ npm info underscore description$ npm info underscore homepage$ npm info underscore version</code></pre><h3 id="npm-searchnpm-search"><a href="#npm-searchnpm-search" class="headerlink" title="npm-searchnpm search"></a><a href="#npm-search">npm-search</a>npm search</h3><p><code>npm search</code> 命令用于搜索 <code>npm</code> 仓库，它后面可以跟字符串，也可以跟正则表达式。</p><pre><code>$ npm search &lt;搜索词&gt;</code></pre><h3 id="npm-listnpm-list"><a href="#npm-listnpm-list" class="headerlink" title="npm-listnpm list"></a><a href="#npm-list">npm-list</a>npm list</h3><p><code>npm list</code> 命令以树形结构列出当前项目安装的所有模块，以及它们依赖的模块。</p><pre><code>$ npm list# 加上 global 参数，会列出全局安装的模块$ npm list -global# npm list 命令也可以列出单个模块$ npm list underscore</code></pre><h3 id="npm-installnpm-install"><a href="#npm-installnpm-install" class="headerlink" title="npm-installnpm install"></a><a href="#npm-install">npm-install</a>npm install</h3><p>使用 <code>npm</code> 安装包的命令格式为：<code>npm [install/i] [package_name]</code></p><h4 id="本地模式和全局模式本地模式和全局模式"><a href="#本地模式和全局模式本地模式和全局模式" class="headerlink" title="本地模式和全局模式本地模式和全局模式"></a><a href="#本地模式和全局模式">本地模式和全局模式</a>本地模式和全局模式</h4><p><code>npm</code> 在默认情况下会从 <a href="http://npmjs.org" target="_blank" rel="noopener">NPM</a> 搜索或下载包，将包安装到当前目录的 <code>node_modules</code> 子目录下。</p><p>如果你熟悉 <code>Ruby</code> 的 <code>gem</code> 或者 <code>Python</code> 的 <code>pip</code> ，你会发现 <code>npm</code> 与它们的行为不同， <code>gem</code> 或 <code>pip</code> 总是以全局模式安装，使包可以供所有的程序使用，而 <code>npm</code> 默认会把包安装到当前目录下。这反映了 <code>npm</code> 不同的设计哲学。如果把包安装到全局，可以提供程序的重复利用程度，避免同样的内容的多分副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 <code>API</code> 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p><p>我们在使用 <code>supervisor</code> 的时候使用了 <code>npm install -g supervisor</code> 命令，就是以全局模式安装 <code>supervisor</code> 。</p><p>这里注意一点的就是， <code>supervisor</code> 必须安装到全局，如果你不安装到全局，错误命令会提示你安装到全局。如果不想安装到默认的全局，也可以自己修改全局路径到当前路径 <code>npm config set prefix &quot;路径&quot;</code> 安装完以后就可以用 <code>supervisor</code> 来启动服务了。<br><code>supervisor</code> 可以帮助你实现这个功能，它会监视你对代码的驱动，并自动重启 <code>Node</code> 。</p><p>一般来说，全局安装只适用于工具模块，比如 <code>eslint</code> 和 <code>gulp</code> 。关于使用全局模式，多数时候并不是因为许多程序都有可能用到了它，为了减少多重副本而使用全局模式，而是因为 <strong>本地模式不会注册 <code>PATH</code> 环境变量</strong>。<br>“本地安装”指的是将一个模块下载到当前项目的 <code>node_modules</code> 子目录，然后只有在项目目录之中，才能调用这个模块。</p><p>本地模式和全局模式的特点如下：<br>模式可通过 require 使用注册 PATH本地模式是否全局模式否是</p><pre><code># 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install -global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt;</code></pre><p><code>npm install</code> 也支持直接输入 <code>Github</code> 代码库地址。</p><pre><code>$ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0</code></pre><p>安装之前，<code>npm install</code> 会先检查，<code>node_modules</code> 目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。</p><p>如果你希望，一个模块不管是否安装过， <code>npm</code> 都要强制重新安装，可以使用 <code>-f</code> 或 <code>--force</code> 参数。</p><pre><code>$ npm install &lt;packageName&gt; --force</code></pre><h4 id="安装不同版本安装不同版本"><a href="#安装不同版本安装不同版本" class="headerlink" title="安装不同版本安装不同版本"></a><a href="#安装不同版本">安装不同版本</a>安装不同版本</h4><p><code>install</code> 命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上 <code>@</code> 和版本号。</p><pre><code>$ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@&quot;&gt;=0.1.0 &lt;0.2.0&quot;</code></pre><p><code>install</code> 命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在 <code>packages.json</code> 文件的哪一项中。</p><blockquote><p>–save：模块名将被添加到 dependencies，可以简化为参数-S。<br>–save-dev：模块名将被添加到 devDependencies，可以简化为参数-D。</p></blockquote><pre><code>$ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D</code></pre><h5 id="dependencies-依赖dependencies-依赖"><a href="#dependencies-依赖dependencies-依赖" class="headerlink" title="dependencies-依赖dependencies 依赖"></a><a href="#dependencies-依赖">dependencies-依赖</a>dependencies 依赖</h5><p>这个可以说是我们 <code>npm</code> 核心一项内容，依赖管理，这个对象里面的内容就是我们这个项目所依赖的 <code>js</code> 模块包。下面这段代码表示我们依赖了 <code>markdown-it</code> 这个包，版本是 <code>^8.1.0</code> ，代表最小依赖版本是 <code>8.1.0</code> ，如果这个包有更新，那么当我们使用 <code>npm install</code> 命令的时候， <code>npm</code> 会帮我们下载最新的包。当别人引用我们这个包的时候，包内的依赖包也会被下载下来。</p><pre><code>&quot;dependencies&quot;: {&quot;markdown-it&quot;: &quot;^8.1.0&quot;}</code></pre><h5 id="devDependencies-开发依赖devDependencies-开发依赖"><a href="#devDependencies-开发依赖devDependencies-开发依赖" class="headerlink" title="devDependencies-开发依赖devDependencies 开发依赖"></a><a href="#devDependencies-开发依赖">devDependencies-开发依赖</a>devDependencies 开发依赖</h5><p>在我们开发的时候会用到的一些包，只是在开发环境中需要用到，但是在别人引用我们包的时候，不会用到这些内容，放在 <code>devDependencies</code> 的包，在别人引用的时候不会被 <code>npm</code> 下载。</p><pre><code>&quot;devDependencies&quot;: {&quot;autoprefixer&quot;: &quot;^6.4.0&quot;,&quot;babel-preset-es2015&quot;: &quot;^6.0.0&quot;,&quot;babel-preset-stage-2&quot;: &quot;^6.0.0&quot;,&quot;babel-register&quot;: &quot;^6.0.0&quot;,&quot;webpack&quot;: &quot;^1.13.2&quot;,&quot;webpack-dev-middleware&quot;: &quot;^1.8.3&quot;,&quot;webpack-hot-middleware&quot;: &quot;^2.12.2&quot;,&quot;webpack-merge&quot;: &quot;^0.14.1&quot;,&quot;highlightjs&quot;: &quot;^9.8.0&quot;}</code></pre><p>当你有了一个完整的 <code>package.json</code>文件的时候，就可以让人一眼看出来，这个模块的基本信息，和这个模块所需要依赖的包。我们可以通过 <code>npm install</code> 就可以很方便的下载好这个模块所需要的包。</p><p><code>npm install</code> 默认会安装 <code>dependencies</code> 字段和 <code>devDependencies</code> 字段中的所有模块，如果使用 <code>--production</code> 参数，可以只安装 <code>dependencies</code> 字段的模块。</p><pre><code>$ npm install --production# 或者$ NODE_ENV=production npm install</code></pre><p>一旦安装了某个模块，就可以在代码中用 <code>require</code> 命令加载这个模块。</p><pre><code>var backbone = require(&apos;backbone&apos;)console.log(backbone.VERSION)</code></pre><h3 id="npm-runnpm-run"><a href="#npm-runnpm-run" class="headerlink" title="npm-runnpm run"></a><a href="#npm-run">npm-run</a>npm run</h3><p><code>npm</code> 不仅可以用于模块管理，还可以用于执行脚本。<code>package.json</code> 文件有一个 <code>scripts</code> 字段，可以用于指定脚本命令，供 <code>npm</code> 直接调用。<br><code>package.json</code> 文件内容：</p><pre><code>{&quot;name&quot;: &quot;myproject&quot;,&quot;devDependencies&quot;: {&quot;jshint&quot;: &quot;latest&quot;,&quot;browserify&quot;: &quot;latest&quot;,&quot;mocha&quot;: &quot;latest&quot;  },&quot;scripts&quot;: {&quot;lint&quot;: &quot;jshint **.js&quot;,&quot;test&quot;: &quot;mocha test/&quot;  }}</code></pre><h4 id="scripts-脚本scripts-脚本"><a href="#scripts-脚本scripts-脚本" class="headerlink" title="scripts-脚本scripts 脚本"></a><a href="#scripts-脚本">scripts-脚本</a>scripts 脚本</h4><p>顾名思义，就是一些脚本代码，可以通过 <code>npm run script-key</code> 来调用，例如在这个 <code>package.json</code> 的文件夹下使用 <code>npm run dev</code> 就相当于运行了 <code>node build/dev-server.js</code> 这一段代码。使用 <code>scripts</code> 的目的就是为了把一些要执行的代码合并到一起，使用 npm run 来快速的运行，方便省事。<br><code>npm run</code> 是 <code>npm run-script</code> 的缩写，一般都使用前者，但是后者可以更好的反应这个命令的本质。</p><pre><code>// 脚本&quot;scripts&quot;: {&quot;dev&quot;: &quot;node build/dev-server.js&quot;,&quot;build&quot;: &quot;node build/build.js&quot;,&quot;docs&quot;: &quot;node build/docs.js&quot;,&quot;build-docs&quot;: &quot;npm run docs &amp; git checkout gh-pages &amp; xcopy /sy dist\\* . &amp; git add . &amp; git commit -m &apos;auto-pages&apos; &amp; git push &amp; git checkout master&quot;,&quot;build-publish&quot;: &quot;rmdir /S /Q lib &amp; npm run build &amp;git add . &amp; git commit -m auto-build &amp; npm version patch &amp; npm publish &amp; git push&quot;,&quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;}</code></pre><p><code>npm run</code> 如果不加任何参数，直接运行，会列出 <code>package.json</code> 里面所有可以执行的脚本命令。<br><code>npm</code> 内置了两个命令简写， <code>npm test</code> 等同于执行 <code>npm run test</code> ，<code>npm start</code> 等同于执行 <code>npm run start</code>。</p><pre><code>&quot;build&quot;: &quot;npm run build-js &amp;&amp; npm run build-css&quot;</code></pre><p>上面的写法是先运行 <code>npm run build-js</code> ，然后再运行 <code>npm run build-css</code> ，两个命令中间用 <code>&amp;&amp;</code> 连接。如果希望两个命令同时平行执行，它们中间可以用 <code>&amp;</code> 连接。</p><p>写在 <code>scripts</code> 属性中的命令，也可以在 <code>node_modules/.bin</code> 目录中直接写成 <code>bash</code> 脚本。下面是一个 <code>bash</code> 脚本。</p><pre><code>#!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js</code></pre><p>假定上面的脚本文件名为 <code>build.sh</code> ，并且权限为可执行，就可以在 <code>scripts</code> 属性中引用该文件。</p><pre><code>&quot;build-js&quot;: &quot;bin/build.sh&quot;</code></pre><h3 id="pre-和-post-脚本pre-和-post-脚本"><a href="#pre-和-post-脚本pre-和-post-脚本" class="headerlink" title="pre-和-post-脚本pre- 和 post- 脚本"></a><a href="#pre-和-post-脚本">pre-和-post-脚本</a>pre- 和 post- 脚本</h3><p><code>npm run</code> 为每条命令提供了 <code>pre-</code> 和 <code>post-</code> 两个钩子（ <code>hook</code> ）。以 <code>npm run lint</code> 为例，执行这条命令之前， <code>npm</code> 会先查看有没有定义 <code>prelint</code> 和 <code>postlint</code> 两个钩子，如果有的话，就会先执行 <code>npm run prelint</code> ，然后执行 <code>npm run lint</code> ，最后执行 <code>npm run postlint</code> 。</p><pre><code>{&quot;name&quot;: &quot;myproject&quot;,&quot;devDependencies&quot;: {&quot;eslint&quot;: &quot;latest&quot;&quot;karma&quot;: &quot;latest&quot;  },&quot;scripts&quot;: {&quot;lint&quot;: &quot;eslint --cache --ext .js --ext .jsx src&quot;,&quot;test&quot;: &quot;karma start --log-leve=error karma.config.js --single-run=true&quot;,&quot;pretest&quot;: &quot;npm run lint&quot;,&quot;posttest&quot;: &quot;echo &apos;Finished running tests&apos;&quot;  }}</code></pre><p>上面代码是一个 <code>package.json</code> 文件的例子。如果执行 <code>npm test</code>，会按下面的顺序执行相应的命令。</p><ol><li><code>pretest</code></li><li><code>test</code></li><li><code>posttest</code></li></ol><p>如果执行过程出错，就不会执行排在后面的脚本，即如果 <code>prelint</code> 脚本执行出错，就不会接着执行 <code>lint</code> 和 <code>postlint</code> 脚本。</p><h3 id="npm-binnpm-bin"><a href="#npm-binnpm-bin" class="headerlink" title="npm-binnpm bin"></a><a href="#npm-bin">npm-bin</a>npm bin</h3><p><code>npm bin</code> 命令显示相对于当前目录的，<code>Node</code> 模块的可执行脚本所在的目录（即 <code>.bin</code> 目录）。</p><pre><code># 项目根目录下执行$ npm bin./node_modules/.bin</code></pre><h1 id="创建全局链接创建全局链接"><a href="#创建全局链接创建全局链接" class="headerlink" title="创建全局链接创建全局链接"></a><a href="#创建全局链接">创建全局链接</a>创建全局链接</h1><p><code>npm</code> 提供了一个有趣的命令 <code>npm link</code>，它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 <code>require</code> 使用。但通过 <code>npm link</code> 命令可以打破这一限制。举个例子，我们已经通过 <code>npm install -g express</code> 安装了 <code>express</code> ，这时在工程的目录下运行命令：<code>npm link express ./node_modules/express -&gt; /user/local/lib/node_modules/express</code><br>我们可以在 <code>node_modules</code> 子目录中发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当做本地包来使用了。<br>除了将全局的包链接到本地以外，使用 <code>npm link</code> 命令还可以将本地的包链接到全局。使用方法是在包目录（<code>package.json</code> 所在目录）中运行 <code>npm link</code> 命令。如果我们要开发一个包，利用这种方法可以非常方便地在不同的工程间进行测试。</p><h1 id="创建包创建包"><a href="#创建包创建包" class="headerlink" title="创建包创建包"></a><a href="#创建包">创建包</a>创建包</h1><p>包是在模块基础上更深一步的抽象，<code>Node</code> 的包类似于 <code>C/C++</code> 的函数库或者 <code>Java</code> 、<code>.Net</code> 的类库。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。<code>Node</code> 根据 <code>CommonJS</code> 规范实现了包机制，开发了 <code>npm</code> 来解决包的发布和获取需求。<br><code>Node</code> 的包是一个目录，其中包含了一个 <code>JSON</code> 格式的包说明文件 <code>package.json</code>。严格符合 <code>CommonJS</code> 规范的包应该具备以下特征：</p><ul><li><code>package.json</code> 必须在包的顶层目录下；</li><li>二进制文件应该在 <code>bin</code> 目录下；</li><li><code>JavaScript</code> 代码应该在 <code>lib</code> 目录下；</li><li>文档应该在 <code>doc</code> 目录下；</li><li>单元测试应该在 <code>test</code> 目录下。</li></ul><p><code>Node</code> 对包的要求并没有这么严格，只要顶层目录下有 <code>package.json</code>，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 <code>CommonJS</code> 规范。</p><p>我们也可以把文件夹封装为一个模块，即所谓的包。包通常是一些模块的集合，在模块的基础上提供了更高层的抽象，相当于提供了一些固定接口的函数库。通过定制 <code>package.json</code>，我们可以创建更复杂，更完善，更符合规范的包用于发布。</p><p><code>Node</code> 在调用某个包时，会首先检查包中 <code>packgage.json</code> 文件的 <code>main</code> 字段，将其作为包的接口模块，如果 <code>package.json</code> 或 <code>main</code> 字段不存在，会尝试寻找 index.js 或 index.node 作为包的接口。</p><p><code>package.json</code> 是 <code>CommonJS</code> 规定的用来描述包的文件，完全符合规范的 <code>package.json</code> 文件应该含有以下字段：<br>name: 包的名字，必须是唯一的，由小写英文字母、数字和下划线组成，不能包含空格。<br>description: 包的简要说明。<br>version: 符合语义化版本识别规范的版本字符串。<br>keywords: 关键字数组，通常用于搜索。<br>maintainers: 维护者数组，每个元素要包含 <code>name</code> 、 <code>email</code>(可选)、 <code>web</code>(可选)字段。<br>contributors: 贡献者数组，格式与 <code>maintainers</code> 相同。包的作者应该是贡献者数组的第一个元素。<br>bugs: 提交 <code>bug</code> 的地址，可以是网址或者电子邮件地址。<br>licenses: 许可证数组，每个元素要包含 <code>type</code> （许可证的名称）和 url（链接到许可证文本的地址）字段。<br>repositories: 仓库托管地址数组，每个元素要包含 <code>type</code> （仓库的类型，如 git）、URL（仓库的地址）和 path（相对于仓库的路径，可选）字段。<br>dependencies: 包的依赖，一个关联数组，由包名称和版本号组成。</p><h1 id="包的发布包的发布"><a href="#包的发布包的发布" class="headerlink" title="包的发布包的发布"></a><a href="#包的发布">包的发布</a>包的发布</h1><p>通过使用 <code>npm init</code> 可以根据交互式回答产生一个符合标准的 <code>package.json</code>。创建一个 <code>index.js</code> 作为包的接口,一个简单的包就制作完成了。<br>在发布前,我们还需要获得一个账号用于今后维护自己的包,使用 <code>npm adduser</code> 根据提示完成账号的创建<br>完成后可以使用 <code>npm whoami</code> 检测是否已经取得了账号。<br>接下来,在 <code>package.json</code> 所在目录下运行 <code>npm publish</code>，稍等片刻就可以完成发布了，打开浏览器，访问 <a href="http://search.npmjs.org/" target="_blank" rel="noopener">NPM搜索</a> 就可以找到自己刚刚发布的包了。现在我们可以在世界的任意一台计算机上使用 <code>npm install neveryumodule</code> 命令来安装它。<br>如果你的包将来有更新,只需要在 <code>package.json</code> 文件中修改 <code>version</code> 字段,然后重新使用 <code>npm publish</code>命令就行了。<br>如果你对已发布的包不满意，可以使用 <code>npm unpublish</code> 命令来取消发布。</p><p><em>需要说明的是： <code>json</code> 文件不能有注释</em></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package.json 好处</span><br><span class="line"> 1.以json文件格式定义项目所依赖的包；</span><br><span class="line"> 2.确定每个包的使用版本；</span><br><span class="line"> 3.项目构建可重复，多人协助公用一套基础代码；</span><br><span class="line"> 4.npm init 初始化 【必须含有的两个：name 和 version】</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;name&quot;: &quot;react-redux-webpack&quot;,</span><br><span class="line">     &quot;version&quot;: &quot;1.1.0&quot;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">devDependencies    ：开发环境和测试环境所依赖的包列表</span><br><span class="line">dependencies       ：在生产环境使用的依赖包列表</span><br><span class="line"></span><br><span class="line">    dependencies下记录的是项目在运行时必须依赖的插件，常见的例如react jquery等，即及时项目打包好了、上线了，</span><br><span class="line">   这些也是需要用的，否则程序无法正常执行。</span><br><span class="line">    devDependencies下记录的是项目在开发过程中使用的插件，例如这里我们开发过程中需要使用webpack打包，</span><br><span class="line">    而我在工作中使用fis3打包，但是一旦项目打包发布、上线了之后，webpack和fis3就都没有用了，可卸磨杀驴。</span><br><span class="line"></span><br><span class="line">本地安装 npm install --save|--save-dev 分别写入  dependencies|devDependencies 中；</span><br><span class="line">简写：     npm i -S pkg      |  npm i -D pkg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">包（package)和模块（module）</span><br><span class="line">包：package.json 文件所描述的文件夹或者文件，符合CommonJS规范</span><br><span class="line">模块：任何被node.js中的require所载入的文件</span><br><span class="line"></span><br><span class="line">~ 会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本，但是不包括1.3.0</span><br><span class="line">^ 会匹配最新的大版本依赖包，比如^1.2.3会匹配所有1.x.x的包，包括1.3.0，但是不包括2.0.0</span><br><span class="line">* 这意味着安装最新版本的依赖包</span><br><span class="line"></span><br><span class="line">常用命令:</span><br><span class="line">    npm init -y    //强制生成</span><br><span class="line">npm init //在项目中引导创建一个package.json文件</span><br><span class="line">npm search mkdir   //寻找包使用npm search命令</span><br><span class="line">npm help //查看某条命令的详细帮助 </span><br><span class="line">npm root //查看包的安装路径</span><br><span class="line">npm config //管理npm的配置路径</span><br><span class="line">npm prefix -g   //查看全局安装的包位置  -g全局</span><br><span class="line">npm cache  //管理模块的缓存 ,可以使用下面命令，偶尔清楚一下缓存：      eg: npm cache clean</span><br><span class="line">npm info webpack   //查看webpack 版本信息</span><br><span class="line">npm install pkg //安装模块 简写：npm i pkg   ,带版本:  npm install underscore@1.8.2</span><br><span class="line">npm uninstall //卸载模块   eg: npm uninstall webpack</span><br><span class="line">npm update   // 更新模块   npm update underscore</span><br><span class="line">npm outdated  //检查模块是否已经过时</span><br><span class="line">npm ls   //查看安装的模块 </span><br><span class="line">npm list  //可以查看全局路径下的所有包    eg:   npm list --global</span><br><span class="line">          //也可以使用--depth=0来缩短返回的结果   eg:     npm list -g --depth=0</span><br><span class="line">npm stop  //停止模块</span><br><span class="line">npm restart  //重新启动模块</span><br><span class="line">npm test //测试模块 </span><br><span class="line">npm version //查看模块版本</span><br><span class="line">npm publish //发布模块</span><br><span class="line"></span><br><span class="line">简写:</span><br><span class="line">npm i – 安装包</span><br><span class="line">npm i -g – 安装包到全局下</span><br><span class="line">npm un – 删除本地下包</span><br><span class="line">npm up – 更新包</span><br><span class="line">npm t – 运行测试</span><br><span class="line">npm ls – 罗列已经安装包</span><br><span class="line">npm ll or npm la – 罗列包时显示额外信息</span><br><span class="line"></span><br><span class="line">    npm i express momemt lodash mongoose  webpack   //也可以一次安装多个包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    yarn cache clean   //删除电脑上所有 yarn 安装的缓存</span><br><span class="line">    yarn   //命令安装项目相关依赖</span><br><span class="line">    yarn cache dir //获取缓存文件夹地址</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>简化版的vue-router</title>
      <link href="/2017/04/18/%E7%AE%80%E5%8C%96%E7%89%88%E7%9A%84vue-router/"/>
      <url>/2017/04/18/%E7%AE%80%E5%8C%96%E7%89%88%E7%9A%84vue-router/</url>
      
        <content type="html"><![CDATA[<p>本文旨在介绍<code>vue-router</code>的实现思路，并动手实现一个简化版的<code>vue-router</code>。<br>我们先来看一下一般项目中对<code>vue-router</code>最基本的一个使用，可以看到，这里定义了四个路由组件,我们只要在根<code>vue</code>实例中注入该<code>router</code>对象就可以使用了.</p><pre><code>import VueRouter from&apos;vue-router&apos;;import Home from&apos;@/components/Home&apos;;import A from&apos;@/components/A&apos;;import B from&apos;@/components/B&apos;import C from&apos;@/components/C&apos;Vue.use(VueRouter)export default new VueRouter.Router({  // mode: &apos;history&apos;,  routes: [    {      path: &apos;/&apos;,      component: Home    },    {      path: &apos;/a&apos;,      component: A    },    {      path: &apos;/b&apos;,      component: B    },    {      path: &apos;/c&apos;,      component: C    }  ]})</code></pre><p><code>vue-router</code>提供两个全局组件，<code>router-view</code>和<code>router-link</code>，前者是用于路由组件的占位，后者用于点击时跳转到指定路由。此外组件内部可以通过<code>this.$router.push</code>,<code>this.$rouer.replace</code>等api实现路由跳转。本文将实现上述两个全局组件以及<code>push</code>和<code>replace</code>两个api，调用的时候支持<code>params</code>传参，并且支持<code>hash</code>和<code>history</code>两种模式，忽略其余api、嵌套路由、异步路由、<code>abstract</code>路由以及导航守卫等高级功能的实现，这样有助于理解<code>vue-router</code>的核心原理。本文的最终代码不建议在生产环境使用，只做一个学习用途，下面我们就来一步步实现它。</p><h3 id="install实现"><a href="#install实现" class="headerlink" title="install实现"></a>install实现</h3><p>任何一个<code>vue</code>插件都要实现一个<code>install</code>方法，通过<code>Vue.use</code>调用插件的时候就是在调用插件的<code>install</code>方法，那么路由的<code>install</code>要做哪些事情呢？首先我们知道 我们会用<code>new</code>关键字生成一个<code>router</code>实例，就像前面的代码实例一样，然后将其挂载到根<code>vue</code>实例上，那么作为一个全局路由，我们当然需要在各个组件中都可以拿到这个<code>router</code>实例。另外我们使用了全局组件<code>router-view</code>和<code>router-link</code>，由于<code>install</code>会接收到<code>Vue</code>构造函数作为实参，方便我们调用<code>Vue.component</code>来注册全局组件。因此，在<code>install</code>中主要就做两件事，给各个组件都挂载<code>router</code>实例，以及实现<code>router-view</code>和<code>router-link</code>两个全局组件。下面是代码：</p><pre><code>const install = (Vue) =&gt; {  if (this._Vue) {    return;  };  Vue.mixin({    beforeCreate() {      if (this.$options &amp;&amp; this.$options.router) {        this._routerRoot = this;        this._router = this.$options.router;        Vue.util.defineReactive(this, &apos;_routeHistory&apos;, this._router.history)      } else {        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this      }      Object.defineProperty(this, &apos;$router&apos;, {        get() {          returnthis._routerRoot._router;        }      })      Object.defineProperty(this, &apos;$route&apos;, {        get() {          return {            current: this._routerRoot._routeHistory.current,            ...this._routerRoot._router.route          };        }      })    }  });  Vue.component(&apos;router-view&apos;, {    render(h) { ... }  })  Vue.component(&apos;router-link&apos;, {        props: {      to: String,      tag: String,    },    render(h) { ... }  })  this._Vue = Vue;}</code></pre><p>这里的<code>this</code>代表的就是<code>vue-router</code>对象，它有两个属性暴露出来供外界调用，一个是<code>install</code>，一个是<code>Router</code>构造函数，这样可以保证插件的正确安装以及路由实例化。我们先忽略<code>Router</code>构造函数，来看<code>install</code>，上面代码中的<code>this._Vue</code>是个开始没有定义的属性，他的目的是防止多次安装。我们使用<code>Vue.mixin</code>对每个组件的<code>beforeCreate</code>钩子做全局混入，目的是让每个组件实例共享<code>router</code>实例，即通过<code>this.$router</code>拿到路由实例，通过<code>this.$route</code>拿到路由状态。需要重点关注的是这行代码：</p><pre><code>Vue.util.defineReactive(this, &apos;_routeHistory&apos;, this._router.history)</code></pre><p>这行代码利用<code>vue</code>的响应式原理，对根<code>vue</code>实例注册了一个<code>_routeHistory</code>属性，指向路由实例的<code>history</code>对象，这样<code>history</code>也变成了响应式的。因此一旦路由的<code>history</code>发生变化，用到这个值的组件就会触发<code>render</code>函数重新渲染，这里的组件就是<code>router-view</code>。从这里可以窥察到<code>vue-router</code>实现的一个基本思路。上述的代码中对于两个全局组件的<code>render</code>函数的实现，因为会依赖于<code>router</code>对象，我们先放一放，稍后再来实现它们，下面我们分析一下<code>Router</code>构造函数。</p><h3 id="Router构造函数"><a href="#Router构造函数" class="headerlink" title="Router构造函数"></a>Router构造函数</h3><p>经过刚才的分析，我们知道<code>router</code>实例需要有一个<code>history</code>对象，需要一个保存当前路由状态的对象<code>route</code>，另外很显然还需要接受路由配置表<code>routes</code>，根据<code>routes</code>需要一个路由映射表<code>routerMap</code>来实现组件搜索，还需要一个变量<code>mode</code>判断是什么模式下的路由，需要实现<code>push</code>和<code>replace</code>两个api，代码如下：</p><pre><code>const Router = function (options) {  this.routes = options.routes; // 存放路由配置this.mode = options.mode || &apos;hash&apos;;  this.route = Object.create(null), // 生成路由状态this.routerMap = createMap(this.routes) // 生成路由表this.history = new RouterHistory(); // 实例化路由历史对象this.init(); // 初始化}Router.prototype.push = (options) =&gt; { ... }Router.prototype.replace = (options) =&gt; { ... }Router.prototype.init = () =&gt; { ... }</code></pre><p>我们看一下路由表<code>routerMap</code>的实现，由于不考虑嵌套等其他情况，实现很简单，如下：</p><pre><code>const createMap = (routes) =&gt; {  let resMap = Object.create(null);  routes.forEach(route =&gt; {    resMap[route[&apos;path&apos;]] = route[&apos;component&apos;];  })  return resMap;}</code></pre><p><code>RouterHistory</code>的实现也很简单，根据前面分析，我们只需要一个<code>current</code>属性就可以，如下：</p><pre><code>const RouterHistory = function (mode) {  this.current = null; }</code></pre><p>有了路由表和<code>history</code>，<code>router-view</code>的实现就很容易了，如下：</p><pre><code>Vue.component(&apos;router-view&apos;, {    render(h) {      let routerMap = this._self.$router.routerMap;      return h(routerMap[this._self.$route.current])    }  })</code></pre><p>这里的<code>this</code>是一个<code>renderProxy</code>实例，他有一个属性<code>_self</code>可以拿到当前的组件实例，进而访问到<code>routerMap</code>，可以看到路由实例<code>history</code>的<code>current</code>本质上就是我们配置的路由表中的<code>path</code>。</p><p>接下来我们看一下<code>Router</code>要做哪些初始化工作。对于<code>hash</code>路由而言，url上<code>hash</code>值的改变不会引起页面刷新，但是可以触发一个<code>hashchange</code>事件。由于路由<code>history.current</code>初始为<code>null</code>，因此匹配不到任何一个路由，所以会导致页面刷新加载不出任何路由组件。基于这两点，在<code>init</code>方法中，我们需要实现对页面加载完成的监听，以及<code>hash</code>变化的监听。对于<code>history</code>路由，为了实现浏览器前进后退时准确渲染对应组件，还要监听一个<code>popstate</code>事件。代码如下:</p><pre><code>Router.prototype.init = function () {  if (this.mode === &apos;hash&apos;) {    fixHash()    window.addEventListener(&apos;hashchange&apos;, () =&gt; {      this.history.current = getHash();    })    window.addEventListener(&apos;load&apos;, () =&gt; {      this.history.current = getHash();    })  }  if (this.mode === &apos;history&apos;) {    removeHash(this);    window.addEventListener(&apos;load&apos;, () =&gt; {      this.history.current = location.pathname;    })    window.addEventListener(&apos;popstate&apos;, (e) =&gt; {      if (e.state) {        this.history.current = e.state.path;      }    })  }}</code></pre><p>当启用<code>hash</code>模式的时候，我们要检测url上是否存在<code>hash</code>值，没有的话强制赋值一个默认<code>path</code>，<code>hash</code>路由时会根据<code>hash</code>值作为<code>key</code>来查找路由表。<code>fixHash</code>和<code>getHash</code>实现如下：</p><pre><code>const fixHash = () =&gt; {  if (!location.hash) {    location.hash = &apos;/&apos;;  }}const getHash = () =&gt; {  return location.hash.slice(1) || &apos;/&apos;;}</code></pre><p>这样在刷新页面和<code>hash</code>改变的时候，<code>current</code>可以得到赋值和更新，页面能根据<code>hash</code>值准确渲染路由。<code>history</code>模式也是一样的道理，只是它通过<code>location.pathname</code>作为<code>key</code>搜索路由组件，另外<code>history</code>模式需要去除url上可能存在的<code>hash</code>,<code>removeHash</code>实现如下：</p><pre><code>const removeHash = (route) =&gt; {  let url = location.href.split(&apos;#&apos;)[1]  if (url) {    route.current = url;    history.replaceState({}, null, url)  }}</code></pre><p>我们可以看到当浏览器后退的时候，<code>history</code>模式会触发<code>popstate</code>事件，这个时候是通过<code>state</code>状态去获取<code>path</code>的，那么<code>state</code>状态从哪里来呢，答案是从<code>window.history</code>对象的<code>pushState</code>和<code>replaceState</code>而来，这两个方法正好可以用来实现<code>router</code>的<code>push</code>方法和<code>replace</code>方法，我们看一下这里它们的实现：</p><pre><code>Router.prototype.push = (options) =&gt; {  this.history.current = options.path;  if (this.mode === &apos;history&apos;) {    history.pushState({      path: options.path    }, null, options.path);  } elseif (this.mode === &apos;hash&apos;) {    location.hash = options.path;  }  this.route.params = {    ...options.params  }}Router.prototype.replace = (options) =&gt; {  this.history.current = options.path;  if (this.mode === &apos;history&apos;) {    history.replaceState({      path: options.path    }, null, options.path);  } elseif (this.mode === &apos;hash&apos;) {    location.replace(`#${options.path}`)  }  this.route.params = {    ...options.params  }}</code></pre><p><code>pushState</code>和<code>replaceState</code>能够实现改变url的值但不引起页面刷新，从而不会导致新请求发生，<code>pushState</code>会生成一条历史记录而<code>replaceState</code>不会，后者只是替换当前url。在这两个方法执行的时候将<code>path</code>存入<code>state</code>，这就使得<code>popstate</code>触发的时候可以拿到路径从而触发组件渲染了。我们在组件内按照如下方式调用，会将<code>params</code>写入<code>router</code>实例的<code>route</code>属性中，从而在跳转后的组件<code>B</code>内通过<code>this.$route.params</code>可以访问到传参。</p><pre><code>this.$router.push({    path: &apos;/b&apos;,    params: {      id: 55    } });</code></pre><h3 id="router-link实现"><a href="#router-link实现" class="headerlink" title="router-link实现"></a>router-link实现</h3><p><code>router-view</code>的实现很简单，前面已经说过。最后，我们来看一下<code>router-link</code>的实现,先放上代码：</p><pre><code>Vue.component(&apos;router-link&apos;, {        props: {      to: String,      tag: String,    },    render(h) {      let mode = this._self.$router.mode;      let tag = this.tag || &apos;a&apos;;      let routerHistory = this._self.$router.history;      return h(tag, {        attrs: tag === &apos;a&apos; ? {          href: mode === &apos;hash&apos; ? &apos;#&apos; + this.to : this.to,        } : {},        on: {          click: (e) =&gt; {            if (this.to === routerHistory.current) {              e.preventDefault();              return;            }            routerHistory.current = this.to;            switch (mode) {              case&apos;hash&apos;:                if (tag === &apos;a&apos;) return;                location.hash = this.to;                break;              case&apos;history&apos;:                history.pushState({                  path: this.to                }, null, this.to);                break;              default:            }            e.preventDefault();          }        },        style: {          cursor: &apos;pointer&apos;        }      }, this.$slots.default)    }  })</code></pre><p><code>router-link</code>可以接受两个属性，<code>to</code>表示要跳转的路由路径，<code>tag</code>表示<code>router-link</code>要渲染的标签名，默认<code>a</code>为标签。如果是<code>a</code>标签，我们为其添加一个<code>href</code>属性。我们给标签绑定<code>click</code>事件，如果检测到本次跳转为当前路由的话什么都不做直接返回，并且阻止默认行为，否则根据<code>to</code>更换路由。<code>hash</code>模式下并且是<code>a</code>标签时候可以直接利用浏览器的默认行为完成url上<code>hash</code>的替换，否者重新为<code>location.hash</code>赋值。<code>history</code>模式下则利用<code>pushState</code>去更新url。</p><p>以上实现就是一个简单的vue-router.</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise 必知必会</title>
      <link href="/2017/04/02/Promise-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
      <url>/2017/04/02/Promise-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="你不知道的-Promise-对象黑科技"><a href="#你不知道的-Promise-对象黑科技" class="headerlink" title="你不知道的 Promise 对象黑科技"></a><a href="https://zhuanlan.zhihu.com/p/30735250" target="_blank" rel="noopener">你不知道的 Promise 对象黑科技</a></h2><p>Promise 想必大家都十分熟悉，想想就那么几个 api，可是你真的了解 Promise 吗？本文根据 Promise 的一些知识点总结了十道题，看看你能做对几道。</p><p>以下 promise 均指代 Promise 实例，环境是 Node.js。</p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {  console.log(1)  resolve()  console.log(2)})promise.then(() =&gt; {  console.log(3)})console.log(4)</code></pre><p>运行结果：</p><pre><code>1243</code></pre><p>解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    resolve(&apos;success&apos;)  }, 1000)})console.log(promise)promise  .then(() =&gt; {    console.log(promise)    throw new Error(&apos;error!!!&apos;)  })  .catch(err =&gt; {    console.log(promise)  })</code></pre><p>运行结果：</p><pre><code>Promise { &lt;pending&gt; }Promise { &apos;success&apos; }Promise { &apos;success&apos; }</code></pre><p>解释：promise 有 3 种状态：pending、fulfilled 和 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。</p><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {  resolve(&apos;success1&apos;)  reject(&apos;error&apos;)  resolve(&apos;success2&apos;)})promise  .then((res) =&gt; {    console.log(&apos;then: &apos;, res)  })  .catch((err) =&gt; {    console.log(&apos;catch: &apos;, err)  })</code></pre><p>运行结果：</p><pre><code>then: success1</code></pre><p>解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。</p><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><pre><code>Promise.resolve(1)  .then((res) =&gt; {    console.log(res)    return 2  })  .catch((err) =&gt; {    return 3  })  .then((res) =&gt; {    console.log(res)  })</code></pre><p>运行结果：</p><pre><code>12</code></pre><p>解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。</p><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><pre><code>const promise = new Promise((resolve, reject) =&gt; {  setTimeout(() =&gt; {    console.log(&apos;once&apos;)    resolve(&apos;success&apos;)  }, 1000)})const start = Date.now()promise.then((res) =&gt; {  console.log(res, Date.now() - start)})promise.then((res) =&gt; {  console.log(res, Date.now() - start)})</code></pre><p>运行结果：</p><pre><code>oncesuccess 1005success 1007</code></pre><p>解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</p><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><pre><code>Promise.resolve()  .then(() =&gt; {    return new Error(&apos;error!!!&apos;)  })  .then((res) =&gt; {    console.log(&apos;then: &apos;, res)  })  .catch((err) =&gt; {    console.log(&apos;catch: &apos;, err)  })</code></pre><p>运行结果：</p><pre><code>then: Error: error!!!    at Promise.resolve.then (...)    at ...</code></pre><p>解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：</p><ol><li>return Promise.reject(new Error(‘error!!!’))</li><li>throw new Error(‘error!!!’)</li></ol><p>因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。</p><h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><pre><code>const promise = Promise.resolve()  .then(() =&gt; {    return promise  })promise.catch(console.error)</code></pre><p>运行结果：</p><pre><code>TypeError: Chaining cycle detected for promise #&lt;Promise&gt;    at &lt;anonymous&gt;    at process._tickCallback (internal/process/next_tick.js:188:7)    at Function.Module.runMain (module.js:667:11)    at startup (bootstrap_node.js:187:16)    at bootstrap_node.js:607:3</code></pre><p>解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：</p><pre><code>process.nextTick(function tick () {  console.log(&apos;tick&apos;)  process.nextTick(tick)})</code></pre><h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><pre><code>Promise.resolve(1)  .then(2)  .then(Promise.resolve(3))  .then(console.log)</code></pre><p>运行结果：</p><pre><code>1</code></pre><p>解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</p><h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><pre><code>Promise.resolve()  .then(function success (res) {    throw new Error(&apos;error&apos;)  }, function fail1 (e) {    console.error(&apos;fail1: &apos;, e)  })  .catch(function fail2 (e) {    console.error(&apos;fail2: &apos;, e)  })</code></pre><p>运行结果：</p><pre><code>fail2: Error: error    at success (...)    at ...</code></pre><p>解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以：</p><pre><code>Promise.resolve()  .then(function success1 (res) {    throw new Error(&apos;error&apos;)  }, function fail1 (e) {    console.error(&apos;fail1: &apos;, e)  })  .then(function success2 (res) {  }, function fail2 (e) {    console.error(&apos;fail2: &apos;, e)  })</code></pre><h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><pre><code>process.nextTick(() =&gt; {  console.log(&apos;nextTick&apos;)})Promise.resolve()  .then(() =&gt; {    console.log(&apos;then&apos;)  })setImmediate(() =&gt; {  console.log(&apos;setImmediate&apos;)})console.log(&apos;end&apos;)</code></pre><p>运行结果：</p><pre><code>endnextTickthensetImmediate</code></pre><p>解释：process.nextTick 和 promise.then 都属于 microtasks，而 setImmediate 属于 macrotasks，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotasks）之间都会执行 microtasks，事件循环的开始会先执行一次 microtasks。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ES6实现自己的 Promise</title>
      <link href="/2017/03/02/ES6-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-Promise/"/>
      <url>/2017/03/02/ES6-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84-Promise/</url>
      
        <content type="html"><![CDATA[<h2 id="一、JavaScript异步编程背景"><a href="#一、JavaScript异步编程背景" class="headerlink" title="一、JavaScript异步编程背景"></a>一、JavaScript异步编程背景</h2><p>从去年ES2015发布至今，已经过去了一年多，ES2015发布的新的语言特性中最为流行的也就莫过于Promise了，Promise使得如今JavaScript异步编程如此轻松惬意，甚至慢慢遗忘了曾经那不堪回首的痛楚。其实从JavaScript诞生，JavaScript中的异步编程就已经出现，例如点击鼠标、敲击键盘这些事件的处理函数都是异步的，时间到了2009年，Node.js横空出世，在整个Node.js的实现中，将回调模式的异步编程机制发挥的淋漓尽致，Node的流行也是的越来越多的JavaScripter开始了异步编程，但是回调模式的副作用也慢慢展现在人们眼前，错误处理不够优雅以及嵌套回调带来的“回调地狱”。这些副作用使得人们从回调模式的温柔乡中慢慢清醒过来，开始寻找更为优雅的异步编程模式，路漫漫其修远兮、吾将上下而求索。时间到了2015年，Promise拯救那些苦苦探索的先驱。行使它历史使命的时代似乎已经到来。</p><p>每个事物的诞生有他的历史使命，更有其历史成因，促进其被那些探索的先驱们所发现。了解nodejs或者熟悉浏览器的人都知道，JavaScript引擎是基于事件循环或单线程这两个特性的。更为甚者在浏览器中，更新UI(也就是浏览器重绘、重拍页面布局)和执行JavaScript代码也在一个单线程中，可想而知，一个线程就相当于只有一条马路，如果一辆马车抛锚在路上了阻塞了马路，那么别的马车也就拥堵在了那儿，这个单线程容易被阻塞是一个道理，单线程也只能允许某一时间点只能够执行一段代码。同时，JavaScript没有想它的哥哥姐姐们那么财大气粗，像Java或者C++，一个线程不够，那么再加一个线程，这样就能够同时执行多段代码了，但是这样就会带来的隐患就是状态不容易维护，JavaScript选择了单线程非阻塞式的方式，也就是异步编程的方式，就像上面的马车抛锚在了路上，那么把马车推到路边的维修站，让其他马车先过去，等马车修好了再回到马路上继续行驶，这就是单线程非阻塞方式。正如Promise的工作方式一样，通过Promise去向服务器发起一个请求，毕竟请求有网络开销，不可能马上就返回请求结果的，这个时候Promise就处于pending状态，但是其并不会阻塞其他代码的执行，当请求返回时，修改Promise状态为fulfilled或者rejected（失败请求）。同时执行绑定到这两个状态上面的“处理函数”。这就是异步编程的模式，也就是Promise兢兢业业的工作方式，在下面一个部分将详细讨论Promise。</p><h2 id="二、Promise基础"><a href="#二、Promise基础" class="headerlink" title="二、Promise基础"></a>二、Promise基础</h2><p>怎么一句话解释Promise呢？Promise可以代指那些尚未完成的一些操作，但是其在未来的某个时间会返回某一特定的结果。</p><p>当创建一个Promise实例后，其代表一个未知的值，在将来的某个时间会返回一个成功的返回值，或者失败的返回值，我们可以为这些返回值添加处理函数，当值返回时，处理函数被调用。Promise总是处于下面三种状态之一：</p><ul><li>pending： Promise的初始状态，也就是未被fulfilled或者rejected的状态。</li><li>fulfilled： 意味着promise代指的操作已经成功完成。</li><li>rejected：意味着promise代指的操作由于某些原因失败。</li></ul><p>一个处于pending状态的promise可能由于某个成功返回值而发展为fulfilled状态，也有可能因为某些错误而进入rejected状态，无论是进入fulfilled状态或者rejected状态，绑定到这两种状态上面的处理函数就会被执行。并且进入fulfilled或者rejected状态也就不能再返回pending状态了。<br><img src="https://pic4.zhimg.com/v2-cf3e4ae1a35caad7c2d8d7bdd8c763d2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-cf3e4ae1a35caad7c2d8d7bdd8c763d2_hd.jpg" alt=""></p><h2 id="三、边学边写"><a href="#三、边学边写" class="headerlink" title="三、边学边写"></a>三、边学边写</h2><p>上面说了那么多，其实都是铺垫。接下来我们就开始实现自己的Promise对象。go go go！！！</p><h2 id="第一步：Promise构造函数"><a href="#第一步：Promise构造函数" class="headerlink" title="第一步：Promise构造函数"></a>第一步：Promise构造函数</h2><p>Promise有三种状态，pending、fulfilled、rejected。</p><pre><code>const PENDING = &apos;PENDING&apos; // Promise 的 初始状态const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态</code></pre><p>有了三种状态后，那么我们怎么创建一个Promise实例呢？</p><blockquote><p>const promise = new Promise(executor) // 创建Promise的语法</p></blockquote><p>通过上面生成promise语法我们知道，Promise实例是调用Promise构造函数通过new操作符生成的。这个构造函数我们可以先这样写：</p><pre><code>class Promise {    constructor(executor) {        this.status = PENDING // 创建一个promise时，首先进行状态初始化。pending        this.result = undefined // result属性用来缓存promise的返回结果，可以是成功的返回结果，或失败的返回结果    }}</code></pre><p>我们可以看到上面构造函数接受的参数executor。它是一个函数，并且接受其他两个函数（resolve和reject）作为参数，当resolve函数调用后，promise的状态转化为fulfilled，并且执行成功返回的处理函数（不用着急后面会说到怎么添加处理函数）。当reject函数调用后，promise状态转化为rejected，并且执行失败返回的处理函数。</p><p>现在我们的代码大概是这样的：</p><pre><code>class Promise {    constructor(executor) {        this.status = PENDING         this.result = undefined        executor(data =&gt; resolveProvider(this, data), err =&gt; rejectProvider(this, err))    }}function resolveProvider(promise, data) {    if (promise.status !== PENDING) return false    promise.status = FULFILLED}function rejectProvider(promise, data) {    if (promise.status !== PENDING) return false    promise.status = FULFILLED}</code></pre><p>Dont Repeat Yourselt！！！我们可以看到上面代码后面两个函数基本相同，其实我们可以把它整合成一个函数，在结合高阶函数的使用。</p><pre><code>const statusProvider = (promise, status) =&gt; data =&gt; {    if (promise.status !== PENDING) return false    promise.status = status    promise.result = data}class Promise {    constructor(executor) {        this.status = PENDING         this.result = undefined        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))    }}</code></pre><p>现在我们的代码就看上去简洁多了。</p><h2 id="第二步：为Promise添加处理函数"><a href="#第二步：为Promise添加处理函数" class="headerlink" title="第二步：为Promise添加处理函数"></a>第二步：为Promise添加处理函数</h2><p>其实通过 <code>new Promise(executor)</code>已经可以生成一个Promise实例了，甚至我们可以通过传递到executor中的resolve和reject方法来改变promise状态，但是！现在的promise依然没啥卵用！！！因为我们并没有给它添加成功和失败返回的处理函数。</p><p>首先我们需要给我们的promise增加两个属性，successListener和failureListener用来分别缓存成功处理函数和失败处理函数。</p><pre><code>class Promise {    constructor(executor) {        this.status = PENDING         this.successListener = []         this.failureListener = []        this.result = undefined        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))    }}</code></pre><p>怎么添加处理函数呢？ECMASCRIPT标准中说到，我们可以通过promise原型上面的then方法为promise添加成功处理函数和失败处理函数，可以通过catch方法为promise添加失败处理函数。</p><pre><code>const statusProvider = (promise, status) =&gt; data =&gt; {    if (promise.status !== PENDING) return false    promise.status = status    promise.result = data    switch(status) {        case FULFILLED: return promise.successListener.forEach(fn =&gt; fn(data))        case REJECTED: return promise.failurelistener.forEach(fn =&gt; fn(data))    }}class Promise {    constructor(executor) {        this.status = PENDING        this.successListener = []        this.failurelistener = []        this.result = undefined        executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))    }    /**     * Promise原型上面的方法     */    then(...args) {        switch (this.status) {            case PENDING: {                this.successListener.push(args[0])                this.failurelistener.push(args[1])                break            }            case FULFILLED: {                args[0](this.result)                break            }            case REJECTED: {                args[1](this.result)            }        }    }    catch(arg) {        return this.then(undefined, arg)    }}</code></pre><p>我们现在的Promise基本初具雏形了。甚至可以运用到一些简单的场景中了。举个例子。</p><pre><code>/*创建一个延时resolve的pormise*/new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; resolve(5), 2000)}).then(data =&gt; console.log(data)) // 5/*创建一个及时resolve的promise*/new Promise((resolve, reject) =&gt; resolve(5)).then(data =&gt; console.log(data)) // 5/*链式调用then方法还不能够使用！*/new Promise(resolve=&gt; resolve(5)).then(data =&gt; data).then(data =&gt; console.log(data))// Uncaught TypeError: Cannot read property &apos;then&apos; of undefined</code></pre><h2 id="第三步：Promise的链式调用"><a href="#第三步：Promise的链式调用" class="headerlink" title="第三步：Promise的链式调用"></a>第三步：Promise的链式调用</h2><p>Promise需要实现链式调用，我们需要再次回顾下then方法的定义：</p><blockquote><p>then方法为pormise添加成功和失败的处理函数，同时then方法返回一个新的promise对象，这个新的promise对象resolve处理函数的返回值，或者当没有提供处理函数时直接resolve原始的值。</p></blockquote><p>可以看出，promise能够链式调用归功于then方法返回一个全新的promise，并且resolve处理函数的返回值，当然，如果then方法的处理函数本身就返回一个promise，那么久不用我们自己手动生成一个promise了。了解了这些，就开始动手写代码了。</p><pre><code>const isPromise = object =&gt; object &amp;&amp; object.then &amp;&amp; typeof object.then === &apos;function&apos;const noop = () =&gt; {}const statusProvider = (promise, status) =&gt; data =&gt; {    // 同上面代码}class Promise {    constructor(executor) {        // 同上面代码    }    then(...args) {        const child = new this.constructor(noop)        const handler = fn =&gt; data =&gt; {            if (typeof fn === &apos;function&apos;) {                const result = fn(data)                if (isPromise(result)) {                    Object.assign(child, result)                } else {                    statusProvider(child, FULFILLED)(result)                }               } else if(!fn) {                statusProvider(child, this.status)(data)            }        }        switch (this.status) {            case PENDING: {                this.successListener.push(handler(args[0]))                this.failurelistener.push(handler(args[1]))                break            }            case FULFILLED: {                handler(args[0])(this.result)                break            }            case REJECTED: {                handler(args[1])(this.result)                break            }        }        return child    }    catch(arg) {        return this.then(undefined, arg)    }}</code></pre><p>首先我们写了一个isPromise方法，用于判断一个对象是否是promise。就是判断对象是否有一个<code>then</code>方法，免责声明为了实现上的简单，我们不区分thenable和promise的区别，但是我们应该是知道。所有的promise都是thenable的，而并不是所有的thenable对象都是promise。（thenable对象是指带有一个then方法的对象，该then方法其实就是一个executor。）isPromise的作用就是用于判断then方法返回值是否是一个promise，如果是promise，就直接返回该promise，如果不是，就新生成一个promise并返回该promise。</p><p>由于需要链式调用，我们对successListener和failureListener中处理函数进行了重写，并不是直接push进去then方法接受的参数函数了，因为then方法需要返回一个promise，所以当then方法里面的处理函数被执行的同时，我们也需要对then方法返回的这个promise进行处理，要么resolve，要么reject掉。当然，大部分情况都是需要resolve掉的，只有当then方法没有添加第二个参数函数，同时调用then方法的promise就是rejected的时候，才需要把then方法返回的pormise进行reject处理，也就是调用<code>statusProvider(child, REJECTED)(data)</code>.</p><p>toy Promise实现的完整代码：</p><pre><code>const PENDING = &apos;PENDING&apos; // Promise 的 初始状态const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态const isPromise = object =&gt; object &amp;&amp; object.then &amp;&amp; typeof object.then === &apos;function&apos;const noop = () =&gt; {}const statusProvider = (promise, status) =&gt; data =&gt; {    if (promise.status !== PENDING) return false    promise.status = status    promise.result = data    switch(status) {        case FULFILLED: return promise.successListener.forEach(fn =&gt; fn(data))        case REJECTED: return promise.failurelistener.forEach(fn =&gt; fn(data))    }}class Promise {    constructor(executor) {        this.status = PENDING        this.successListener = []        this.failurelistener = []        this.result = undefined         executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))    }    /**     * Promise原型上面的方法     */    then(...args) {        const child = new this.constructor(noop)        const handler = fn =&gt; data =&gt; {            if (typeof fn === &apos;function&apos;) {                const result = fn(data)                if (isPromise(result)) {                    Object.assign(child, result)                } else {                    statusProvider(child, FULFILLED)(result)                }               } else if(!fn) {                statusProvider(child, this.status)(data)            }        }        switch (this.status) {            case PENDING: {                this.successListener.push(handler(args[0]))                this.failurelistener.push(handler(args[1]))                break            }            case FULFILLED: {                handler(args[0])(this.result)                break            }            case REJECTED: {                handler(args[1])(this.result)                break            }        }        return child    }    catch(arg) {        return this.then(undefined, arg)    }}</code></pre><h2 id="四、怎么让我们的toy-Promise变强健"><a href="#四、怎么让我们的toy-Promise变强健" class="headerlink" title="四、怎么让我们的toy Promise变强健"></a>四、怎么让我们的toy Promise变强健</h2><ol><li>在ECMAScript标准中，Promise构造函数上面还提供了一些静态方法，比如<code>Promise.resolve</code>、<code>Promise.reject</code>、<code>Promsie.all</code>、<code>Promise.race</code>。当我们有了上面的基础实现后，为我们的toy Promise添加上面这些新的功能一定能让其更加实用。</li><li>在我们的基本实现中，我们并没有区分thenable对象，其实<code>Promise.resolve</code>和<code>then</code>方法都可以接受一个thenable对象，并把该thenable对象转化为一个promise对象，如果想让我们的toy Promise用于生产的话，这也是要考虑的。</li><li>为了让我们的toy Promise变得更强壮，我们需要拥有强健的错误处理机制，比如验证executor必须是一个函数、then方法的参数只能是函数或者undefined或null，又比如executor和then方法中抛出的错误并不能够被window.onerror监测到，而只能够通过错误处理函数来处理，这也是需要考虑的因素。</li><li>如果我们的Promise polyfill是考虑支持多平台，那么首要考虑的就是浏览器环境或Node.js环境，其实在这两个平台，原生Promise都是支持两个事件的。就拿浏览器端举例：</li></ol><ul><li><code>unhandledrejection</code>: 在一个事件循环中，如果我们没有对promise返回的错误进行处理，那么就会在window对象上面触发该事件。</li><li><code>rejectionhandled</code>:如果在一个事件循环后，我们才去对promise返回的错误进行处理，那么就会在window对象上面监听到此事件。</li></ul><p>关于这两个事件以及node.js平台上面类似的事件请参考Nicholas C. Zakas新书</p><p>Promise能够很棒的处理异步编程，要想学好它我认为最好的方法就是亲自动手去实现一个自己的Promise。</p><p>完整code：</p><pre><code>/** * 2016.09.19 */const PENDING = &apos;PENDING&apos; // Promise 的初始状态const FULFILLED = &apos;FULFILLED&apos; // Promise 成功返回后的状态const REJECTED = &apos;REJECTED&apos; // Promise 失败后的状态const isThenable = data =&gt; data &amp;&amp; data.then &amp;&amp; typeof data.then === &apos;function&apos;const isPromise = object =&gt; isThenable(object) &amp;&amp; (&apos;catch&apos; in object) &amp;&amp; typeof object.catch === &apos;function&apos;const noop = () =&gt; {}const range = n =&gt; n === 0 ? [] : [n, ...range(n - 1)]// resolve functionconst statusProvider = (promise, status) =&gt; data =&gt; {    if (promise.status !== PENDING) return false    promise.status = status    promise.result = data    promise.listeners[status].forEach(fn =&gt; fn(data))}class APromise {    constructor(executor) {        if (typeof executor !== &apos;function&apos;) {            throw new TypeError(`Promise resolver ${executor.toString()} is not a function`)        }        this.status = PENDING        this.listeners = {            FULFILLED: [],            REJECTED: []        }        this.result = undefined        try {            executor(statusProvider(this, FULFILLED), statusProvider(this, REJECTED))        } catch (e) {            statusProvider(this, REJECTED)(e)        }    }    // prototype method    then(...args) {        const child = new this.constructor(noop)        const handler = fn =&gt; data =&gt; {            if (typeof fn === &apos;function&apos;) {                try {                    const result = fn(data)                    if (isThenable(result)) {                        isPromise(result) ? Object.assign(child, result) : Object.assign(child, new this.constructor(result.then))                    } else {                        statusProvider(child, FULFILLED)(result)                    }                } catch (e) {                    statusProvider(child, REJECTED)(e)                }            } else if (!fn) {                statusProvider(child, this.status)(data)            }        }        switch (this.status) {            case PENDING: {                this.listeners[FULFILLED].push(handler(args[0]))                this.listeners[REJECTED].push(handler(args[1]))                break            }            case FULFILLED: {                handler(args[0])(this.result)                break            }            case REJECTED: {                handler(args[1])(this.result)                break            }        }        return child    }    catch(arg) {        return this.then(undefined, arg)    }}APromise.resolve = data =&gt; {    if (isPromise(data)) return data    return isThenable(data) ? new APromise(data.then) : new APromise((resolve, reject) =&gt; resolve(data))}APromise.reject = err =&gt; new APromise((resolve, reject) =&gt; reject(err))APromise.all = promises =&gt; {    const length = promises.length    const result = new APromise(noop)    let count = 0    const values = range(length)    promises.forEach((p, i) =&gt; {        p.then(data =&gt; {            values[i] = data            count++            if (count === length) statusProvider(result, FULFILLED)(values)        }, statusProvider(result, REJECTED))    })    return result}APromise.race = promises =&gt; {    const result = new APromise(noop)    promises.forEach((p, i) =&gt; {        p.then(statusProvider(result, FULFILLED), statusProvider(result, REJECTED))    })    return result}export default APromise</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> promise </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS类型判断</title>
      <link href="/2017/02/03/JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
      <url>/2017/02/03/JS%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="先看typeof"><a href="#先看typeof" class="headerlink" title="先看typeof"></a>先看typeof</h2><pre><code>&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;        &lt;/style&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            var a;            console.log(&quot;1:&quot; + typeof a);            var b = null;            console.log(&quot;2:&quot; + typeof b);            var c = undefined;            console.log(&quot;3:&quot; + typeof c);            var d = new Object;            console.log(&quot;4:&quot; + typeof d);            var e = function() {};            console.log(&quot;5:&quot; + typeof e);            var f = {};            console.log(&quot;6:&quot; + typeof f);            var g = &apos;&apos;;            console.log(&quot;7:&quot; + typeof g);            var h = [];            console.log(&quot;8:&quot; + typeof h);            var i = true;            console.log(&quot;9:&quot; + typeof i);            var j = 123;            console.log(&quot;10:&quot; + typeof j);            var k = NaN;            console.log(&quot;11:&quot; + typeof k);            var l = /^[-+]?\d+$/;            console.log(&quot;12:&quot; + typeof l);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>按照上面的打印结果,总结出下面要注意的几点</p><ul><li>typeof (引用类型) 除了函数, 都是 ‘object’,比如 typeof /123/</li><li>typeof null 为’object’</li><li>typeof undefined 为 ‘undefined’,通常, 如果使用两等号, null == undefined 为真.</li><li><p>转换为数字的常见用法 “10”-0或+”10”, 如果没有转换成功,返回NaN,由于NaN 的一个特性: NaN != NaN,故判断转换成功与否的常见做法: (这也是我参见 jQuery的源码发现的,jQuery源码读100遍都不为过)</p><p>(“10x” - 0) == (“10x” - 0);<br>// 结果为假!   </p></li></ul><p><img src="https://pic3.zhimg.com/v2-6f58d81de68683e272adaf7c340aa518_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-6f58d81de68683e272adaf7c340aa518_hd.jpg" alt=""></p><h2 id="再看看constructor-和-instanceof"><a href="#再看看constructor-和-instanceof" class="headerlink" title="再看看constructor 和 instanceof"></a>再看看constructor 和 instanceof</h2><pre><code>instanceof 用于判断一个变量是否某个对象的实例,或用于判断一个变量是否某个对象的实例；constructor 用于判断一个变量的原型，constructor 属性返回对创建此对象的数组函数的引用。Javascript中对象的prototype属性的解释是:返回对象类型原型的引用。&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            console.log(&quot;----------------Number---------------&quot;);            var A = 123;            console.log(A instanceof Number); //false            console.log(A.constructor == Number); //true            console.log(A.constructor);            console.log(&quot;----------------String---------------&quot;);            var B = &quot;javascript&quot;;            console.log(B instanceof String); //false            console.log(B.constructor == String); //true            console.log(B.constructor);            console.log(&quot;----------------Boolean---------------&quot;);            var C = true;            console.log(C instanceof Boolean); //false            console.log(C.constructor == Boolean); //true            console.log(C.constructor);            console.log(&quot;----------------null---------------&quot;);            var D = null;            console.log(D instanceof Object); //false            //console.log(D.constructor == null); //报错            //console.log(D.constructor); //报错            console.log(&quot;----------------undefined---------------&quot;);            var E = undefined;            //console.log(E instanceof undefined); // //报错            //console.log(E.constructor == undefined); //报错            //console.log(E.constructor); //报错            console.log(&quot;----------------function---------------&quot;);            var F = function() {};            console.log(F instanceof Function);            console.log(F.constructor == Function);            console.log(F.constructor);            console.log(&quot;----------------new function---------------&quot;);            function SB() {};            var G = new SB();            console.log(G instanceof SB);            console.log(G.constructor == SB);            console.log(G.constructor);            console.log(&quot;----------------new Object---------------&quot;);            var H = new Object;            console.log(H instanceof Object);            console.log(H.constructor == Object);            console.log(H.constructor);            console.log(&quot;-----------------Array--------------&quot;);            var I = [];            console.log(I instanceof Array);            console.log(I.constructor == Array);            console.log(I.constructor);            console.log(&quot;-----------------JSON--------------&quot;);            var J = {                &quot;good&quot;: &quot;js&quot;,                &quot;node&quot;: &quot;very good&quot;            };            console.log(J instanceof Object);            console.log(J.constructor == Object);            console.log(J.constructor);        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://pic4.zhimg.com/v2-21d3ca864773ef451c189c0fd954f14a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-21d3ca864773ef451c189c0fd954f14a_hd.jpg" alt=""></p><h2 id="再看看-toString-call-obj"><a href="#再看看-toString-call-obj" class="headerlink" title="再看看{}.toString.call(obj)"></a>再看看{}.toString.call(obj)</h2><pre><code>&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            console.log({}.toString.call(1));            console.log({}.toString.call(&quot;11&quot;));            console.log({}.toString.call(/123/));            console.log({}.toString.call({}));            console.log({}.toString.call(function() {}));            console.log({}.toString.call([]));            console.log({}.toString.call(true));            console.log({}.toString.call(new Date()));            console.log({}.toString.call(new Error()));            console.log({}.toString.call(null));            console.log({}.toString.call(undefined));            console.log(String(null));            console.log(String(undefined));        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://pic1.zhimg.com/v2-2d04b5646ab716650f46286dd0be9747_b.jpg" alt=""></p><h2 id="使用jQuery中的方法-type"><a href="#使用jQuery中的方法-type" class="headerlink" title="使用jQuery中的方法$.type()"></a>使用jQuery中的方法$.type()</h2><p>现在看看jQuery是怎么做的</p><pre><code>// 先申明一个对象,目的是用来做映射var class2type = {};// 申明一个core_toString() 的方法,得到最原始的toString() 方法,因为在很多对象中,toStrintg() 已经被重写 var core_toString() = class2type.toString;// 这里为 toStrintg() 后的结果和类型名做一个映射,申明一个core_toString() 后的结果,而值就是类型名jQuery.each(&quot;Boolean Number String Function Array Date RegExp Object Error&quot;.split(&quot; &quot;), function(i, name) {    class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();});&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot; /&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot; &gt;&lt;/script&gt;        &lt;title&gt;Document&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            console.log($.type(1));            console.log($.type(&quot;11&quot;));            console.log($.type(/123/));            console.log($.type({}));            console.log($.type(function() {}));            console.log($.type([]));            console.log($.type(true));            console.log($.type(new Date()));            console.log($.type(new Error()));            console.log($.type(null));            console.log($.type(undefined));            console.log(String(null));            console.log(String(undefined));        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://pic3.zhimg.com/v2-05899b1b3bcf02e58f2eb987ef69594a_b.jpg" alt=""></p><p>上面的打印结果与</p><pre><code>class2type[ &quot;[object &quot; + name + &quot;]&quot; ] = name.toLowerCase();</code></pre><p>不谋而合!</p><p>这是jQuery.type 的核心方法</p><pre><code>type: function( obj ) {    if ( obj == null ) {        return String( obj );    }    // Support: Safari &lt;= 5.1 (functionish RegExp)    return typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?        class2type[ core_toString.call(obj) ] || &quot;object&quot; :        typeof obj;},</code></pre><blockquote><p>注意,为什么把 null 或者 undefined 单独讨论呢,因为 在一些版本浏览器中<br>console.log(core_toString.call(null));<br>console.log(core_toString.call(undefined));</p></blockquote><pre><code>这是会报错的!如果是对象类型,另:由于 在一些低版本的浏览器中,typeof /123/ 会返回的是 &quot;function&quot; 而不是 &quot;object&quot;,所以这里要判断是否是函数,要明白 这里的 typeof obj === function 不是为了函数讨论的,因为函数本身就可以通过typeof 来得到类型.typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot; ?        class2type[ core_toString.call(obj) ]</code></pre><p>就直接返回class2type 中键值对的结果,,如果不是,那么一定就是基本类型, 通过 typeof 就可以啦.</p><pre><code>class2type[ core_toString.call(obj) ] || &quot;object&quot; :// 这是防止一些未知情况的,如果未取到,就返回object</code></pre><h2 id="但是-jQuery-type-有一个很大的缺陷"><a href="#但是-jQuery-type-有一个很大的缺陷" class="headerlink" title="但是 jQuery.type 有一个很大的缺陷"></a>但是 jQuery.type 有一个很大的缺陷</h2><p>这是一个自定义类型</p><pre><code>function Person() {    this.name = &apos;pawn&apos;;}var p = new Person();console.log($.type(p));console.log({}.toString.call(p));</code></pre><blockquote><p>// 注意,这里会打印 [object Object],通过上面的方法,无法得到精确的自定义类型<br>这也是 它的一个大缺陷了!</p></blockquote><p><img src="https://pic3.zhimg.com/v2-32ad7e97fff63ad11925460861e4ef9e_b.jpg" alt=""></p><p>下面,我们通过构造函数的方式来获取精确类型</p><h2 id="通过构造函数来获取类型"><a href="#通过构造函数来获取类型" class="headerlink" title="通过构造函数来获取类型"></a>通过构造函数来获取类型</h2><p>在理解这个方法之前,需要理解两个点</p><p>prorotype 原型属性</p><pre><code>我们知道,任何对象或者函数都直接或者间接的继承自Object 或者 Function， （其实最终Function 是继承自 Object 的，这属于原型链的知识了，见下图）。那么，任何一个对象都具有原型对象 __proto__ (这个对象只在chrome 和 firefox 暴露，但是在其他浏览器中也是存在的)，这个原型对象就是这个对象的构造函数的原型属性(这里可能有点绕,直接上图).</code></pre><p><img src="https://pic4.zhimg.com/v2-9a1d9c8359714d86fdac5b90d36547ac_b.jpg" alt=""></p><p>由于 任何函数都具有 原型属性prototype,并且这个原型属性具有一个默认属性 constructor,它是这个函数的引用,看下面的代码</p><pre><code>function Person(){     this.name = &apos;pawn&apos;; } console.log(Person.prototype.constructor === Person);   //true</code></pre><p>发现,这两个东西其实一个东西</p><p>但是,在某些情况下,需要这么写</p><pre><code>function Person(){     this.name = &apos;pawn&apos;; } Person.protype = {     XX: ... ,     xx: ... ,     ... }</code></pre><p>这么做,就会覆盖原本的 protype 方法,那么construcor 就不存在了,这是,必须要显示的申明这个对象，</p><h2 id="construction-Person-这句话非常重要，作用是修正this指向"><a href="#construction-Person-这句话非常重要，作用是修正this指向" class="headerlink" title="construction: Person, 这句话非常重要，作用是修正this指向"></a>construction: Person, 这句话非常重要，作用是修正this指向</h2><pre><code>Person.protype = {     construction: Person,   //这句话的作用是修正this指向     XX: ... ,     xx: ... ,     ... }</code></pre><p>在jQuery的中,就是这么做的,</p><pre><code>jQuery.fn = jQuery.prototype = {   constructor: jQuery,   init: function( selector, context, rootjQuery ) {       var match, elem;</code></pre><blockquote><p>关于 jQuery对象封装的方式 也是非常值得研究</p></blockquote><p><img src="https://pic4.zhimg.com/v2-720d122b9b125559f5fb75f2178b25f9_b.jpg" alt=""></p><p>注意,这里已经不是熟悉 [object Object],而是 已经重写了.</p><p>也就是,如果调用一个函数的toString() 方法.那么就会打印这个函数的函数体.</p><p><img src="https://pic3.zhimg.com/v2-b6640c61635718af42b8fb7ce00daf63_b.jpg" alt=""></p><p>如何通过构造函数来获得变量的类型?</p><p>判断是否是基本类型</p><pre><code>var getType = function(obj){     if(obj == null){        return String(obj);     }     if(typeof obj === &apos;object&apos; || typeof obj === &apos;fucntion&apos;){         ...     }else{         // 如果不是引用类型,那么就是基本类型         return typeof obj     } }</code></pre><p>如果是对象或者函数类型</p><pre><code>function Person(){     this.name = &apos;pawn&apos;; } var p = new Person(); console.log(p.constructor);   //返回function Person(){...}</code></pre><p>现在要做的事 : 如何将Person 提取出来呢?<br>毋庸置疑,字符串切割那一套肯定可以办到,但是太 low 啦!<br>这里,我使用正则将Person提取出来</p><pre><code>var regex = /function\s(.+?)\(/function Person(){  this.name = &apos;pawn&apos;; } var p = new Person(); var c = p.constructor var regex = /function\s(.+?)\(/; console.log(&apos;|&apos; + regex.exec(c)[1] + &apos;|&apos;);</code></pre><p><img src="https://pic1.zhimg.com/v2-798dac45bc14f57445c3f12c53a95856_b.jpg" alt=""></p><p>其实,除了上面的正则,每个函数还有一个name属性,返回函数名,但是ie8 是不支持的.</p><p>因此上面的代码可以写为:</p><pre><code>var getType = function(obj){    if(obj == null){        return String(obj);    }    if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){         var constructor = obj.constructor;        if(constructor &amp;&amp; constructor.name){            return constructor.name;        }        var regex = /function\s(.+?)\(/;        return regex.exec(c)[1];    }else{        // 如果不是引用类型,那么就是基本;类型        return typeof obj;    }};</code></pre><p>但是上面的代码太丑啦,将其简化</p><p>简化</p><pre><code>var getType = function(obj){    if(obj == null){        return String(obj);    }    if(typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos;){         return obj.constructor &amp;&amp; obj.constructor.name.toLowerCase() ||           /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase();    }else{        // 如果不是引用类型,那么就是基本类型        return typeof obj;    }};</code></pre><p>还是比较麻烦,继续简化</p><pre><code>var getType = function(obj){    if(obj == null){       return String(obj);    }    return typeof obj === &apos;object&apos; || typeof obj === &apos;function&apos; ?      obj.constructor &amp;&amp; obj.constructor.name &amp;&amp; obj.constructor.name.toLowerCase() ||          /function\s(.+?)\(/.exec(obj.constructor)[1].toLowerCase():      typeof obj;};</code></pre><p>好了,已经全部弄完了,写个代码测试一下:</p><pre><code>function Person(){    this.name = &apos;pawn&apos;;}var p = new Person();console.log(getType(p));console.log(getType(1));console.log(getType(&quot;a&quot;));console.log(getType(false));console.log(getType(/123/));console.log(getType({}));console.log(getType(function(){}));console.log(getType(new Date()));console.log(getType(new Error()));console.log(getType( null));console.log(getType( undefined));</code></pre><p><img src="https://pic2.zhimg.com/v2-45d3c3f08f70b60b05ed1c8885a5ada8_b.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-fe845739a4f557bdf52bc85f1e7a2823_b.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/v2-0cb813f94a182e42c1214445bf96abf3_b.jpg" alt=""></p><p><img src="https://pic3.zhimg.com/v2-e97820f7d32bab80b31beee769505529_b.jpg" alt=""></p><h2 id="1-有时会看到Object-prototype-toString-call"><a href="#1-有时会看到Object-prototype-toString-call" class="headerlink" title="1.有时会看到Object.prototype.toString.call()"></a>1.有时会看到Object.prototype.toString.call()</h2><p><img src="https://pic1.zhimg.com/v2-2c236d4c9534822e61fca4fcab53cf40_b.jpg" alt=""></p><h2 id="2-toString-是一个怎样的方法-他定义在哪里？"><a href="#2-toString-是一个怎样的方法-他定义在哪里？" class="headerlink" title="2.toString()是一个怎样的方法,他定义在哪里？"></a>2.toString()是一个怎样的方法,他定义在哪里？</h2><p><img src="https://pic2.zhimg.com/v2-462bb123e83ec081f7fffca86dd9baee_b.jpg" alt=""></p><h2 id="3-call-apply-bind可以吗？"><a href="#3-call-apply-bind可以吗？" class="headerlink" title="3.call.apply.bind可以吗？"></a>3.call.apply.bind可以吗？</h2><p><img src="https://pic4.zhimg.com/v2-f396bb49abd0ca789e28d1741aa6360f_b.jpg" alt=""></p><h2 id="4-为神马要去call呢？用-Object-prototype-toString-call-obj-而不用-obj-toString-呢？"><a href="#4-为神马要去call呢？用-Object-prototype-toString-call-obj-而不用-obj-toString-呢？" class="headerlink" title="4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？"></a>4.为神马要去call呢？用 Object.prototype.toString.call(obj) 而不用 obj.toString() 呢？</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function A(){                this.say=function(){                    console.log(&quot;我是1&quot;);                }            }            function B(){                this.say=function(){                    console.log(&quot;我是2&quot;);                }            }            var a=new A();            var b=new B();            a.say.call(b);    //我是1        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;script type=&quot;text/javascript&quot;&gt;            function A(){                this.name=&apos;SB&apos;;                this.say=function(){                    console.log(&quot;我是1&quot;);                }            }            function B(){                A.call(this);   //B继承A，重写say方法                this.say=function(){                    console.log(&quot;我是2&quot;);                }            }            var a=new A();            var b=new B();            console.log(b.name);  //SB            b.say();         //我是2            a.say.call(b);    //我是1        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="就是怕你重写了toString-所以才要用object-最原始的他toString-所以才去call。"><a href="#就是怕你重写了toString-所以才要用object-最原始的他toString-所以才去call。" class="headerlink" title="就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。"></a>就是怕你重写了toString,所以才要用object 最原始的他toString,所以才去call。</h2><h2 id="5-Object-prototype-toString方法的原理是什么？"><a href="#5-Object-prototype-toString方法的原理是什么？" class="headerlink" title="5.Object.prototype.toString方法的原理是什么？"></a>5.Object.prototype.toString方法的原理是什么？</h2><p>参考链接：<a href="https://link.zhihu.com/?target=http%3A//www.jb51.net/article/79941.htm" target="_blank" rel="noopener">http://www.jb51.net/article/79941.htm</a></p><p>在JavaScript中,想要判断某个对象值属于哪种内置类型,最靠谱的做法就是通过Object.prototype.toString方法.</p><p>12var arr = [];console.log(Object.prototype.toString.call(arr)) //“[object Array]”</p><p>本文要讲的就是,toString方法是如何做到这一点的,原理是什么.</p><p>ECMAScript 3</p><p>在ES3中,Object.prototype.toString方法的规范如下:</p><p>115.2.4.2 Object.prototype.toString()</p><p>在toString方法被调用时,会执行下面的操作步骤:</p><ol><li><p>获取this对象的[[Class]]属性的值.</p></li><li><p>计算出三个字符串”[object “, 第一步的操作结果Result(1), 以及 “]”连接后的新字符串.</p></li><li><p>返回第二步的操作结果Result(2).</p></li></ol><p>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的</p><p>[[Class]]一个字符串值,表明了该对象的类型.</p><p>然后给了一段解释:</p><p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2).</p><p>也就是说,把Object.prototype.toString方法返回的字符串,去掉前面固定的”[object “和后面固定的”]”,就是内部属性[[class]]的值,也就达到了判断对象类型的目的.jQuery中的工具方法$.type(),就是干这个的.</p><p>在ES3中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有10种.分别是:”Array”, “Boolean”, “Date”, “Error”, “Function”, “Math”, “Number”, “Object”, “RegExp”, “String”.</p><p>ECMAScript 5</p><p>在ES5.1中,除了规范写的更详细一些以外,Object.prototype.toString方法和[[class]]内部属性的定义上也有一些变化,Object.prototype.toString方法的规范如下:</p><p>15.2.4.2 Object.prototype.toString ( )</p><p>在toString方法被调用时,会执行下面的操作步骤:</p><p>如果this的值为undefined,则返回”[object Undefined]”.</p><p>如果this的值为null,则返回”[object Null]”.</p><p>让O成为调用ToObject(this)的结果.</p><p>让class成为O的内部属性[[Class]]的值.</p><p>返回三个字符串”[object “, class, 以及 “]”连接后的新字符串.</p><p>可以看出,比ES3多了1,2,3步.第1,2步属于新规则,比较特殊,因为”Undefined”和”Null”并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this的值才会保持undefined或null,非严格模式下会自动成为全局对象).第3步并不算是新规则,因为在ES3的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来.ES5中,[[Class]]属性的解释更加详细:</p><p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值(查看 15.2.4.2).</p><p>和ES3对比一下,第一个差别就是[[class]]内部属性的值多了两种,成了12种,一种是arguments对象的[[class]]成了”Arguments”,而不是以前的”Object”,还有就是多个了全局对象JSON,它的[[class]]值为”JSON”.第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这12种值冲突,不过在支持ES3的浏览器中,貌似也没有发现哪些宿主对象故意使用那10个值.</p><p>ECMAScript 6</p><p>ES6目前还只是工作草案,但能够肯定的是,[[class]]内部属性没有了,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的:</p><p>内部属性属性值描述<br>[[NativeBrand]]枚举NativeBrand的一个成员.该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型.</p><p>[[NativeBrand]]属性的解释:</p><p>[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的ECMAScript原生对象.只有在表10中明确指出的对象类型才有[[NativeBrand]]内部属性.</p><p>表10 — [[NativeBrand]]内部属性的值</p><p>属性值对应类型<br>NativeFunctionFunction objects<br>NativeArrayArray objects<br>StringWrapperString objects<br>BooleanWrapperBoolean objects<br>NumberWrapperNumber objects<br>NativeMathThe Math object<br>NativeDateDate objects<br>NativeRegExpRegExp objects<br>NativeErrorError objects<br>NativeJSONThe JSON object<br>NativeArgumentsArguments objects<br>NativePrivateNamePrivate Name objects</p><p>可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]].同时,Object.prototype.toString方法的规范也改成了下面这样:</p><p>15.2.4.2 Object.prototype.toString ( )</p><p>在toString方法被调用时,会执行下面的操作步骤:</p><p>如果this的值为undefined,则返回”[object Undefined]”.</p><p>如果this的值为null,则返回”[object Null]”.</p><p>让O成为调用ToObject(this)的结果.</p><p>如果O有[[NativeBrand]]内部属性,让tag成为表29中对应的值.</p><p>否则</p><p>让hasTag成为调用O的[[HasProperty]]内部方法后的结果,参数为@@toStringTag.</p><p>如果hasTag为false,则让tag为”Object”.</p><p>否则,</p><p>让tag成为调用O的[[Get]]内部方法后的结果,参数为@@toStringTag.</p><p>如果tag是一个abrupt completion,则让tag成为NormalCompletion(“???”).</p><p>让tag成为tag.[[value]].</p><p>如果Type(tag)不是字符串,则让tag成为”???”.</p><p>如果tag的值为”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”,或</p><p>者”String”中的任一个,则让tag成为字符串”~”和tag当前的值连接后的结果.</p><p>返回三个字符串”[object “, tag, and “]”连接后的新字符串.</p><p>表29 — [[NativeBrand]] 标志值</p><p>[[NativeBrand]]值标志值<br>NativeFunction”Function”<br>NativeArray”Array”<br>StringWrapper”String”<br>BooleanWrapper”Boolean”<br>NumberWrapper”Number”<br>NativeMath”Math”<br>NativeDate”Date”<br>NativeRegExp”RegExp”<br>NativeError”Error”<br>NativeJSON”JSON”<br>NativeArguments”Arguments”</p><p>可以看到,在规范上有了很大的变化,不过对于普通用户来说,貌似感觉不到.</p><p>也许你发现了,ES6里的新类型Map,Set等,都没有在表29中.它们在执行toString方法的时候返回的是什么?</p><p>console.log(Object.prototype.toString.call(Map())) //“[object Map]”</p><p>console.log(Object.prototype.toString.call(Set())) //“[object Set]”</p><p>其中的字符串”Map”是怎么来的呢:</p><p>15.14.5.13 Map.prototype.@@toStringTag</p><p>@@toStringTag 属性的初始值为字符串”Map”.</p><p>由于ES6的规范还在制定中,各种相关规定都有可能改变,所以如果想了解更多细节.看看下面这两个链接,现在只需要知道的是:[[class]]没了,使用了更复杂的机制.</p><p>以上所述是小编给大家分享的JavaScript中Object.prototype.toString方法的原理，希望对大家有所帮助！</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> 类型判断 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题</title>
      <link href="/2017/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2017/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="转自腾讯前端面试篇（一）"><a href="#转自腾讯前端面试篇（一）" class="headerlink" title="转自腾讯前端面试篇（一）"></a>转自<a href="https://juejin.im/post/5c19c1b6e51d451d1e06c163" target="_blank" rel="noopener">腾讯前端面试篇（一）</a></h3><h3 id="JS-总结之对象"><a href="#JS-总结之对象" class="headerlink" title="JS 总结之对象"></a><a href="https://juejin.im/post/5c19b3f7f265da61620d5631" target="_blank" rel="noopener">JS 总结之对象</a></h3><p>一.有一个类如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">functionPerson(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">let p = new Person(&apos;Tom&apos;);</span><br></pre></td></tr></table></figure></p><ol><li><code>p.__proto__</code>等于什么？</li></ol><p><strong>答案：</strong><br>Person.prototype</p><ol start="2"><li><code>Person.__proto</code>等于什么？</li></ol><p><strong>答案：</strong><br>Function.prototype</p><p><strong>解析：</strong></p><p>1，2两问其实问的是同一个问题，都是考察原型链相关的知识，我们只需要记住一句话就可以迎刃而解。实例的<strong>proto</strong>属性（原型）等于其构造函数的prototype属性。实例p的构造函数为Person，而Person的构造函数为Function，结果就一目了然了。</p><p><strong>触类旁通</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;&#125;,</span><br><span class="line">    F = function()&#123;&#125;;</span><br><span class="line">Object.prototype.a = &apos;value a&apos;;</span><br><span class="line">Function.prototype.b = &apos;value b&apos;;</span><br><span class="line"></span><br><span class="line">console.log(foo.a)   </span><br><span class="line">console.log(foo.b)    </span><br><span class="line">console.log(F.a)      </span><br><span class="line">console.log(F.b)</span><br></pre></td></tr></table></figure></p><p>这里就不给答案了，大家自己分析一下，然后再去控制台运行一下吧！冬天到了，动动手，暖一暖，有木有觉得笔者还是相当的贴心的！！！</p><ol start="3"><li>若将题干改为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">functionPerson(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    return name;</span><br><span class="line">&#125;</span><br><span class="line">let p = new Person(&apos;Tom&apos;);</span><br></pre></td></tr></table></figure></li></ol><p>实例化Person过程中，Person返回什么（或者p等于什么）？</p><p><strong>答案：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;name: &apos;Tom&apos;&#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li>若将题干改为<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">functionPerson(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">let p = new Person(&apos;Tom&apos;);</span><br></pre></td></tr></table></figure></li></ol><p>实例化Person过程中，Person返回什么（或者p等于什么）？</p><p><strong>答案：</strong></p><pre><code>{}</code></pre><p><strong>解析</strong></p><blockquote><p>构造函数不需要显示的返回值。使用new来创建对象(调用构造函数)时，如果return的是非对象(数字、字符串、布尔类型等)会忽而略返回值;如果return的是对象，则返回该对象(注：若return null也会忽略返回值）。</p></blockquote><ol start="5"><li>typeof和instanceof的区别</li></ol><p><strong>答案：</strong></p><blockquote><p>在 JavaScript 中，判断一个变量的类型尝尝会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。</p></blockquote><blockquote><p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。<br>语法：object instanceof constructor<br>参数：object（要检测的对象.）constructor（某个构造函数）<br>描述：instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p></blockquote><p>答案是我整理后的，可能觉得我回答的并不准确，面试官又举了一个例子给我。</p><ol start="6"><li>如果Student inherit from Person（Student类继承Person，需是基于原型的继承），let s = new Student(‘Lily’)，那么s instanceof Person返回什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">functionPerson (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">functionStudent () &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = Person.prototype;</span><br><span class="line">Student.prototype.constructor = Student;</span><br><span class="line"></span><br><span class="line">let s = new Student(&apos;Tom&apos;);</span><br><span class="line">console.log(s instanceof Person); // 返回 true</span><br></pre></td></tr></table></figure></li></ol><p><strong>答案：</strong><br>true</p><ol start="7"><li>new和instanceof的内部机制</li></ol><p><strong>答案</strong></p><blockquote><ol><li>创建一个新对象，同时继承对象类的原型，即Person.prototype；</li><li>执行对象类的构造函数，同时该实例的属性和方法被this所引用，即this指向新构造的实例；</li><li>如果构造函数return了一个新的“对象”，那么这个对象就会取代整个new出来的结果。如果构造函数没有return对象，那么就会返回步骤1所创建的对象，即隐式返回this。（一般情况下构造函数不会返回任何值，不过在一些特殊情况下，如果用户想覆盖这个值，可以选择返回一个普通的对象来覆盖。）</li></ol></blockquote><p>用代码来阐述<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// let p = new Person()let p = (function () &#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    obj.__proto__ = Person.prototype;</span><br><span class="line">    </span><br><span class="line">    // 其他赋值语句...return obj;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><p>下面通过代码阐述instanceof的内部机制，假设现在有 x instanceof y 一条语句，则其内部实际做了如下判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while(x.__proto__!==null) &#123;</span><br><span class="line">    if(x.__proto__===y.prototype) &#123;</span><br><span class="line">        returntrue;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    x.__proto__ = x.__proto__.proto__;</span><br><span class="line">&#125;</span><br><span class="line">if(x.__proto__==null) &#123;returnfalse;&#125;</span><br></pre></td></tr></table></figure></p><p>x会一直沿着隐式原型链<strong>proto</strong>向上查找直到<code>x.__proto__.__proto__......===y.prototype</code>为止，如果找到则返回true，也就是x为y的一个实例。否则返回false，x不是y的实例。</p><p><strong>触类旁通</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">functionF() &#123;&#125;</span><br><span class="line">functionO() &#123;&#125;</span><br><span class="line"></span><br><span class="line">O.prototype = new F();</span><br><span class="line">var obj = new O();</span><br><span class="line"></span><br><span class="line">console.log(obj instanceof O); // trueconsole.log(obj instanceof F); // trueconsole.log(obj.__proto__ === O.prototype); // trueconsole.log(obj.__proto__.__proto__ === F.prototype); // true</span><br></pre></td></tr></table></figure></p><p>根据new 的内部机制改写上面代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">functionF() &#123;&#125;</span><br><span class="line">functionO() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var obj = (function () &#123;</span><br><span class="line">    var obj1 = &#123;&#125;;</span><br><span class="line">    obj1.__proto__ = F.prototype; // new F();</span><br><span class="line">    O.prototype = obj1; // O.prototype = new F();</span><br><span class="line">    obj.__proto__ = O.prototype; // new O();</span><br><span class="line">    obj.__proto__ = obj1;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>结合instanceof内部机制很容易得出正确答案。</p><p>如果稍微调整一下代码顺序，结果将迥然不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">functionF() &#123;&#125;</span><br><span class="line">functionO() &#123;&#125;</span><br><span class="line"></span><br><span class="line">var obj = new O();</span><br><span class="line">O.prototype = new F();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(obj instanceof O); // falseconsole.log(obj instanceof F); // falseconsole.log(obj.__proto__ === O.prototype); // falseconsole.log(obj.__proto__.__proto__ === F.prototype); // false</span><br></pre></td></tr></table></figure></p><p>具体原因，请读者自行分析，如果还是有疑问，可以在评论区提出！</p><p>其实上面很多问题都是考察原型链相关的知识，这里给出一张必须理解的原型链图，原谅我盗了一张图。<br><img src="https://user-gold-cdn.xitu.io/2018/12/18/167c0772297e4ff8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>问到这里我的脑袋已经有点浆糊了，原谅我太菜了！！</p><p>8.下面代码输出什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(i)</span><br><span class="line">    &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>答案:</strong> 10个10</p><p>若要输出从0到9，怎么办？</p><p><strong>答案:</strong><br>将var改为let，或者使用闭包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用闭包for(var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    (function (i) &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            console.log(i)</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="9"><li>刚刚我们用到了箭头函数，说一下箭头函数This指向问题？</li></ol><p><strong>答案：</strong><br>默认指向在定义它时,它所处的对象,而不是执行时的对象,定义它的时候,可能环境是window（即继承父级的this）。</p><p>如果对This还有不清楚的地方，可以参考我的另一篇文章<a href="https://juejin.im/post/5c049e6de51d45471745eb98" target="_blank" rel="noopener">彻底理解JavaScript中的this</a>。</p><ol start="10"><li>for…in迭代和for…of有什么区别？</li></ol><p><strong>答案：</strong><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fc43f418d6bf0" target="_blank" rel="noopener">for…in和for…of的区别</a></p><p>11.说一下你对generator的了解？</p><p><strong>答案：</strong> 建议大家查看<a href="https://link.juejin.im?target=http%3A%2F%2Fes6.ruanyifeng.com%2F%23docs%2Fgenerator" target="_blank" rel="noopener">阮一峰老师的generator相关章节</a></p><p>12.使用过flex布局吗？flex-grow和flex-shrink属性有什么用？</p><p><strong>答案：</strong> flex-grow：项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink：项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p>想彻底理解flex，可以查看<a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F07%2Fflex-grammar.html" target="_blank" rel="noopener">阮一峰老师的Flex布局教程：语法篇</a></p><ol start="13"><li>说一下macrotask 和 microtask？并说出下面代码的运行结果。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">console.log(&apos;a&apos;);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;b&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(&apos;c&apos;);</span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;d&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">.then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;e&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;f&apos;);</span><br></pre></td></tr></table></figure></li></ol><p><strong>答案：</strong> 输出结果为 acfdeb，而关于macrotask和microtask可以继续留意笔者后篇文章，亦可自行搜索。不过可以看一下盗的一张图。<br><img src="https://user-gold-cdn.xitu.io/2018/12/19/167c42db26d145d1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ol start="14"><li>Http请求中的keep-alive有了解吗。</li></ol><p><strong>答案：</strong></p><blockquote><p>在http早期，每个http请求都要求打开一个tpc socket连接，并且使用一次之后就断开这个tcp连接。<br>使用keep-alive可以改善这种状态，即在一次TCP连接中可以持续发送多份数据而不会断开连接。通过使用keep-alive机制，可以减少tcp连接建立次数，也意味着可以减少TIME_WAIT状态连接，以此提高性能和提高httpd服务器的吞吐率(更少的tcp连接意味着更少的系统内核调用,socket的accept()和close()调用)。<br>但是，keep-alive并不是免费的午餐,长时间的tcp连接容易导致系统资源无效占用。配置不当的keep-alive，有时比重复利用连接带来的损失还更大。所以，正确地设置keep-alive timeout时间非常重要。</p></blockquote><ol start="15"><li>React中的controlled component 和 uncontrolled component区别（受控组件和不受控组件）。</li></ol><p><strong>答案：</strong> ： 请查阅React官网<a href="https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Fforms.html" target="_blank" rel="noopener">受控组件</a>，<a href="https://link.juejin.im?target=https%3A%2F%2Freact.docschina.org%2Fdocs%2Funcontrolled-components.html" target="_blank" rel="noopener">非受控组件</a></p><ol start="16"><li>了解过react-router内部实现机制吗？</li></ol><p><strong>答案：</strong>请看这篇文章<a href="https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Ftangzhl%2Farticle%2Fdetails%2F79696055" target="_blank" rel="noopener">react-router的实现原理</a></p><p>17.数组扁平化处理：实现一个flatten方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Examplelet givenArr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];</span><br><span class="line">let outputArr = [1,2,2,3,4,5,5,6,7,8,9,11,12,12,13,14,10]</span><br><span class="line"></span><br><span class="line">// 实现flatten方法使得</span><br><span class="line">flatten(givenArr)——&gt;outputArr</span><br></pre></td></tr></table></figure></p><p>年轻的我是用递归实现的QAQ，我的答案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">functionflatten(arr)&#123;</span><br><span class="line">    var res = [];</span><br><span class="line">    for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(Array.isArray(arr[i]))&#123;</span><br><span class="line">            res = res.concat(flatten(arr[i]));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            res.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实你还可以这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">functionflatten(arr)&#123;</span><br><span class="line">    return arr.reduce(function(prev,item)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(item)?flatten(item):item);</span><br><span class="line">    &#125;,[]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以使用ES6拓展运算符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionflatten(arr)&#123;</span><br><span class="line">    while(arr.some(item=&gt;Array.isArray(item))&#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>18.如果在17问的前提下，要做去重和排序处理又该怎么做（不用给出具体代码）。</p><p><strong>答案：</strong>最好封装一个数组方法的类，该类包含flatten(扁平化)、sort(排序)和unique(去重)等方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript进阶提高必读</title>
      <link href="/2016/12/31/JavaScript%E8%BF%9B%E9%98%B6%E6%8F%90%E9%AB%98%E5%BF%85%E8%AF%BB/"/>
      <url>/2016/12/31/JavaScript%E8%BF%9B%E9%98%B6%E6%8F%90%E9%AB%98%E5%BF%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="冴羽写博客的地方"><a href="#冴羽写博客的地方" class="headerlink" title="冴羽写博客的地方"></a><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">冴羽写博客的地方</a></h2><h2 id="vue源码-内部运行机制剖析"><a href="#vue源码-内部运行机制剖析" class="headerlink" title="vue源码-内部运行机制剖析"></a><a href="https://github.com/DIVIBEAR/vue" target="_blank" rel="noopener">vue源码-内部运行机制剖析</a></h2><h2 id="进度"><a href="#进度" class="headerlink" title="进度"></a>进度</h2><p>JavaScript深入系列 15 篇已完结。</p><p>JavaScript专题系列 20 篇已完结。</p><p>underscore 系列 8 篇已完结。</p><h2 id="深入系列目录"><a href="#深入系列目录" class="headerlink" title="深入系列目录"></a>深入系列目录</h2><ol><li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScirpt深入之从原型到原型链</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="noopener">JavaScript深入之词法作用域和动态作用域</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript深入之执行上下文栈</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript深入之变量对象</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/6" target="_blank" rel="noopener">JavaScript深入之作用域链</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">JavaScript深入之从ECMAScript规范解读this</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/8" target="_blank" rel="noopener">JavaScript深入之执行上下文</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">JavaScript深入之闭包</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/10" target="_blank" rel="noopener">JavaScript深入之参数按值传递</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/14" target="_blank" rel="noopener">JavaScript深入之类数组对象与arguments</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/15" target="_blank" rel="noopener">JavaScript深入之创建对象的多种方式以及优缺点</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/16" target="_blank" rel="noopener">JavaScript深入之继承的多种方式以及优缺点</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/17" target="_blank" rel="noopener">JavaScript深入系列15篇正式完结！</a></li></ol><h2 id="专题系列目录"><a href="#专题系列目录" class="headerlink" title="专题系列目录"></a>专题系列目录</h2><ol><li><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">JavaScript专题之跟着underscore学防抖</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">JavaScript专题之跟着underscore学节流</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/27" target="_blank" rel="noopener">JavaScript专题之数组去重</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/28" target="_blank" rel="noopener">JavaScript专题之类型判断(上)</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/30" target="_blank" rel="noopener">JavaScript专题之类型判断(下)</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/32" target="_blank" rel="noopener">JavaScript专题之深浅拷贝</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/33" target="_blank" rel="noopener">JavaScript专题之从零实现jQuery的extend</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/35" target="_blank" rel="noopener">JavaScript专题之如何求数组的最大值和最小值</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/36" target="_blank" rel="noopener">JavaScript专题之数组扁平化</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/37" target="_blank" rel="noopener">JavaScript专题之学underscore在数组中查找指定元素</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/40" target="_blank" rel="noopener">JavaScript专题之jQuery通用遍历方法each的实现</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/41" target="_blank" rel="noopener">JavaScript专题之如何判断两个对象相等</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/42" target="_blank" rel="noopener">JavaScript专题之函数柯里化</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/43" target="_blank" rel="noopener">JavaScript专题之偏函数</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/44" target="_blank" rel="noopener">JavaScript专题之惰性函数</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/45" target="_blank" rel="noopener">JavaScript专题之函数组合</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/46" target="_blank" rel="noopener">JavaScript专题之函数记忆</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/49" target="_blank" rel="noopener">JavaScript专题之递归</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/51" target="_blank" rel="noopener">JavaScript专题之乱序</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/52" target="_blank" rel="noopener">JavaScript专题之解读 v8 排序源码</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/53" target="_blank" rel="noopener">JavaScript专题系列20篇正式完结！</a></li></ol><h2 id="underscore-系列目录"><a href="#underscore-系列目录" class="headerlink" title="underscore 系列目录"></a>underscore 系列目录</h2><ol><li><a href="https://github.com/mqyqingfeng/Blog/issues/56" target="_blank" rel="noopener">underscore 系列之如何写自己的 underscore</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/57" target="_blank" rel="noopener">underscore 系列之链式调用</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/58" target="_blank" rel="noopener">underscore 系列之内部函数 cb 和 optimizeCb</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/60" target="_blank" rel="noopener">underscore 系列之内部函数 restArgs</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/62" target="_blank" rel="noopener">underscore 系列之防冲突与 Utility Functions</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/63" target="_blank" rel="noopener">underscore 系列之实现一个模板引擎(上)</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/70" target="_blank" rel="noopener">underscore 系列之实现一个模板引擎(下)</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/77" target="_blank" rel="noopener">underscore 系列之字符实体与 _.escape</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/79" target="_blank" rel="noopener">underscore 的源码该如何阅读？</a></li></ol><h2 id="ES6-系列目录"><a href="#ES6-系列目录" class="headerlink" title="ES6 系列目录"></a>ES6 系列目录</h2><ol><li><a href="https://github.com/mqyqingfeng/Blog/issues/82" target="_blank" rel="noopener">ES6 系列之 let 和 const</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/84" target="_blank" rel="noopener">ES6 系列之模板字符串</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/85" target="_blank" rel="noopener">ES6 系列之箭头函数</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/87" target="_blank" rel="noopener">ES6 系列之模拟实现 Symbol 类型</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/90" target="_blank" rel="noopener">ES6 系列之迭代器与 for of</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/91" target="_blank" rel="noopener">ES6 系列之模拟实现一个 Set 数据结构</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/92" target="_blank" rel="noopener">ES6 系列之 WeakMap</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/98" target="_blank" rel="noopener">ES6 系列之我们来聊聊 Promise</a></li><li><a href="https://github.com/mqyqingfeng/Blog/issues/99" target="_blank" rel="noopener">ES6 系列之 Generator 的自动执行</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 模块化解析</title>
      <link href="/2016/12/22/JavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/12/22/JavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="WEB-前端模块化都有什么？"><a href="#WEB-前端模块化都有什么？" class="headerlink" title="WEB 前端模块化都有什么？"></a><a href="https://juejin.im/post/5bf4f6515188251a8266038b" target="_blank" rel="noopener">WEB 前端模块化都有什么？</a></h3><p>随着 JavasScript 语言逐渐发展，JavaScript 应用从简单的表单验证，到复杂的网站交互，再到服务端，移动端，PC 客户端的语言支持。JavaScript 应用领域变的越来越广泛，工程代码变得越来越庞大，代码的管理变得越来越困难，于是乎 JavaScript 模块化方案在社区中应声而起，其中一些优秀的模块化方案，逐渐成为 JavaScript 的语言规范，下面我们就 JavaScript 模块化这个话题展开讨论，本文的主要包含以几部分内容。</p><ul><li>什么是模块</li><li>为什么需要模块化</li><li>JavaScript 模块化之 CommonJS</li><li>JavaScript 模块化之 AMD</li><li>JavaScript 模块化之 CMD</li><li>JavaScript 模块化之 ES Module</li><li>总结</li></ul><ol><li>根据平台划分</li></ol><table><thead><tr><th style="text-align:left">平台</th><th style="text-align:center">规范</th><th style="text-align:right">特性</th></tr></thead><tbody><tr><td style="text-align:left">浏览器</td><td style="text-align:center">AMD、CMD</td><td style="text-align:right">存在网络瓶颈，使用异步加载</td></tr><tr><td style="text-align:left">非浏览器</td><td style="text-align:center">CommonJS</td><td style="text-align:right">直接操作 IO，同步加载</td></tr></tbody></table><table><thead><tr><th>特性</th><th style="text-align:left">规范</th></tr></thead><tbody><tr><td>同步加载</td><td style="text-align:left">CommonJS</td></tr><tr><td>异步加载</td><td style="text-align:left">AMD、CMD</td></tr></tbody></table><table><thead><tr><th style="text-align:left">规范</th><th style="text-align:center">约束条件</th><th style="text-align:right">代表作</th></tr></thead><tbody><tr><td style="text-align:left">AMD</td><td style="text-align:center">依赖前置</td><td style="text-align:right">requirejs</td></tr><tr><td style="text-align:left">CMD</td><td style="text-align:center">就近依赖</td><td style="text-align:right">seajs</td></tr></tbody></table><h2 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h2><p>模块，又称构件，是能够单独命名并独立地完成一定功能的程序语句的集合 (即程序代码和数据结构的集合体)。它具有两个基本的特征：外部特征和内部特征。外部特征是指模块跟外部环境联系的接口 (即其他模块或程序调用该模块的方式，包括有输入输出参数、引用的全局变量) 和模块的功能，内部特征是指模块的内部环境具有的特点 (即该模块的局部数据和程序代码)。简而言之，模块就是一个具有独立作用域，对外暴露特定功能接口的代码集合。</p><h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><p>首先让我们回到过去，看看原始 JavaScript 模块文件的写法。</p><pre><code>// add.jsfunctionadd(a, b) {  return a + b;}// decrease.jsfunctiondecrease(a, b) {  return a - b;}// formula.jsfunctionsquare_difference(a, b) {  return add(a, b) * decrease(a, b);}</code></pre><p>上面我们在三个 JavaScript 文件里面，实现了几个功能函数。其中，第三个功能函数需要依赖第一个和第二个 JavaScript 文件的功能函数，所以我们在使用的时候，一般会这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">    &lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script src=&quot;add.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;decrease.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;formula.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;!--使用--&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">       var result = square_difference(3, 4);</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这样的管理方式会造成以下几个问题：</span><br><span class="line"></span><br><span class="line">- 模块的引入顺序可能会出错</span><br><span class="line">- 会污染全局变量</span><br><span class="line">- 模块之间的依赖关系不明显</span><br><span class="line"></span><br><span class="line">基于上述的原因，就有了对上述问题的解决方案，即是 JavaScript 模块化规范，目前主流的有 CommonJS，AMD，CMD，ES6 Module 这四种规范。</span><br><span class="line"></span><br><span class="line">## Javascript 模块化之 CommonJS</span><br><span class="line"></span><br><span class="line">CommonJS 规范的主要内容有，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中，下面讲述一下 NodeJs 中 CommonJS 的模块化机制。</span><br><span class="line"></span><br><span class="line">### 使用方式</span><br><span class="line"></span><br><span class="line">    // 模块定义 add.jsmodule.eports.add = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // 模块定义 decrease.jsmodule.exports.decrease = function(a, b) &#123;</span><br><span class="line">      return a - b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    // formula.js,模块使用，利用 require() 方法加载模块,require 导出的即是 module.exports 的内容const add = require(&quot;./add.js&quot;).add;</span><br><span class="line">    const decrease = require(&quot;./decrease.js&quot;).decrease;</span><br><span class="line">    module.exports.square_difference = function(a, b) &#123;</span><br><span class="line">      return add(a, b) * decrease(a, b);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### exports 和 module.exports</span><br><span class="line"></span><br><span class="line">exports 和 module.exports 是指向同一个东西的变量，即是 module.exports = exports = &#123;&#125;，所以你也可以这样导出模块</span><br><span class="line"></span><br><span class="line">    //add.js</span><br><span class="line">    exports.add = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是如果直接修改 exports 的指向是无效的，例如:</span><br><span class="line"></span><br><span class="line">    // add.js</span><br><span class="line">    exports = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    // main.jsvar add = require(&quot;./add.js&quot;);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">此时得到的 add 是一个空对象，因为 require 导入的是，对应模块的 module.exports 的内容，在上面的代码中，虽然一开始 exports = module.exports，但是当执行如下代码的时候，其实就将 exports 指向了 function,而 module.exports 的内容并没有改变，所以这个模块的导出为空对象。</span><br><span class="line"></span><br><span class="line">    exports = function(a, b) &#123;</span><br><span class="line">      return a + b;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">### CommonJS 在 NodeJs 中的模块加载机制</span><br><span class="line"></span><br><span class="line">以下根据 [NodeJs 中 CommonJS 模块加载源码](https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fnodejs%2Fnode%2Fblob%2Fmaster%2Flib%2Finternal%2Fmodules%2Fcjs%2Floader.js) 来分析 NodeJS 中模块的加载机制。</span><br><span class="line"></span><br><span class="line">在 NodeJs 中引入模块 (require)，需要经历如下 3 个步骤：</span><br><span class="line"></span><br><span class="line">1. 路径分析</span><br><span class="line">2. 文件定位</span><br><span class="line">3. 编译执行</span><br><span class="line"></span><br><span class="line">与前端浏览器会缓存静态脚本文件以提高性能一样，NodeJs 对引入过的模块都会进行缓存，以减少二次引入时的开销。不同的是，浏览器仅缓存文件，而在 NodeJs 中缓存的是编译和执行后的对象。</span><br><span class="line"></span><br><span class="line">#### 路径分析 + 文件定位</span><br><span class="line"></span><br><span class="line">其流程如下图所示：</span><br><span class="line">#### 模块编译</span><br><span class="line"></span><br><span class="line">在定位到文件后，首先会检查该文件是否有缓存，有的话直接读取缓存，否则，会新创建一个 Module 对象，其定义如下：</span><br><span class="line"></span><br><span class="line">    functionModule(id, parent) &#123;</span><br><span class="line">      this.id = id; // 模块的识别符，通常是带有绝对路径的模块文件名。this.exports = &#123;&#125;; // 表示模块对外输出的值this.parent = parent; // 返回一个对象，表示调用该模块的模块。if (parent &amp;&amp; parent.children) &#123;</span><br><span class="line">        this.parent.children.push(this);</span><br><span class="line">      &#125;</span><br><span class="line">      this.filename = null;</span><br><span class="line">      this.loaded = false; // 返回一个布尔值，表示模块是否已经完成加载。this.childrent = []; // 返回一个数组，表示该模块要用到的其他模块。</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">require 操作代码如下所示：</span><br><span class="line"></span><br><span class="line">    Module.prototype.require = function(id) &#123;</span><br><span class="line">      // 检查模块标识符if (typeof id !== &quot;string&quot;) &#123;</span><br><span class="line">        thrownew ERR_INVALID_ARG_TYPE(&quot;id&quot;, &quot;string&quot;, id);</span><br><span class="line">      &#125;</span><br><span class="line">      if (id === &quot;&quot;) &#123;</span><br><span class="line">        thrownew ERR_INVALID_ARG_VALUE(&quot;id&quot;, id, &quot;must be a non-empty string&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      // 调用模块加载方法return Module._load(id, this, /* isMain */false);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">接下来是解析模块路径，判断是否有缓存，然后生成 Module 对象：</span><br><span class="line"></span><br><span class="line">    Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">      if (parent) &#123;</span><br><span class="line">        debug(&quot;Module._load REQUEST %s parent: %s&quot;, request, parent.id);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 解析文件名var filename = Module._resolveFilename(request, parent, isMain);</span><br><span class="line">    </span><br><span class="line">      var cachedModule = Module._cache[filename];</span><br><span class="line">    </span><br><span class="line">      // 判断是否有缓存，有的话返回缓存对象的 exportsif (cachedModule) &#123;</span><br><span class="line">        updateChildren(parent, cachedModule, true);</span><br><span class="line">        return cachedModule.exports;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 判断是否为原生核心模块，是的话从内存加载if (NativeModule.nonInternalExists(filename)) &#123;</span><br><span class="line">        debug(&quot;load native module %s&quot;, request);</span><br><span class="line">        return NativeModule.require(filename);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 生成模块对象varmodule = new Module(filename, parent);</span><br><span class="line">    </span><br><span class="line">      if (isMain) &#123;</span><br><span class="line">        process.mainModule = module;</span><br><span class="line">        module.id = &quot;.&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      // 缓存模块对象</span><br><span class="line">      Module._cache[filename] = module;</span><br><span class="line">    </span><br><span class="line">      // 加载模块</span><br><span class="line">      tryModuleLoad(module, filename);</span><br><span class="line">    </span><br><span class="line">      returnmodule.exports;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">tryModuleLoad 的代码如下所示：</span><br></pre></td></tr></table></figure></p><pre><code>functiontryModuleLoad(module, filename) {  var threw = true;  try {    // 调用模块实例load方法module.load(filename);    threw = false;  } finally {    if (threw) {      // 如果加载出错，则删除缓存delete Module._cache[filename];    }  }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模块对象执行载入操作 module.load 代码如下所示：</span><br></pre></td></tr></table></figure><pre><code>Module.prototype.load = function(filename) {  debug(&quot;load %j for module %j&quot;, filename, this.id);  assert(!this.loaded);  this.filename = filename;  // 解析路径this.paths = Module._nodeModulePaths(path.dirname(filename));  // 判断扩展名，并且默认为 .js 扩展var extension = path.extname(filename) || &quot;.js&quot;;  // 判断是否有对应格式文件的处理函数， 没有的话，扩展名改为 .jsif (!Module._extensions[extension]) extension = &quot;.js&quot;;  // 调用相应的文件处理方法，并传入模块对象  Module._extensions[extension](this, filename);  this.loaded = true;  // 处理 ES Moduleif (experimentalModules) {    if (asyncESM === undefined) lazyLoadESM();    const ESMLoader = asyncESM.ESMLoader;    const url = pathToFileURL(filename);    const urlString = `${url}`;    const exports = this.exports;    if (ESMLoader.moduleMap.has(urlString) !== true) {      ESMLoader.moduleMap.set(        urlString,        new ModuleJob(ESMLoader, url, async () =&gt; {          const ctx = createDynamicModule([&quot;default&quot;], url);          ctx.reflect.exports.default.set(exports);          return ctx;        })      );    } else {      const job = ESMLoader.moduleMap.get(urlString);      if (job.reflect) job.reflect.exports.default.set(exports);    }  }};</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在这里同步读取模块，再执行编译操作：</span><br></pre></td></tr></table></figure><pre><code>Module._extensions[&quot;.js&quot;] = function(module, filename) {  // 同步读取文件var content = fs.readFileSync(filename, &quot;utf8&quot;);  // 编译代码module._compile(stripBOM(content), filename);};</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编译过程主要做了以下的操作：</span><br><span class="line"></span><br><span class="line">1. 将 JavaScript 代码用函数体包装，隔离作用域，例如：</span><br></pre></td></tr></table></figure><pre><code>exports.add = (function(a, b) {  return a + b;}</code></pre><p><code>`</code><br>会被转换为</p><pre><code>(  function(exports, require, modules, __filename, __dirname) {    exports.add = function(a, b) {      return a + b;    };  });</code></pre><ol><li><p>执行函数，注入模块对象的 exports 属性，require 全局方法，以及对象实例，<strong>filename, </strong>dirname，然后执行模块的源码。</p></li><li><p>返回模块对象 exports 属性。</p></li></ol><h2 id="JavaScript-模块化之-AMD"><a href="#JavaScript-模块化之-AMD" class="headerlink" title="JavaScript 模块化之 AMD"></a>JavaScript 模块化之 AMD</h2><p>AMD, Asynchronous Module Definition，即异步模块加载机制，它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句都定义在一个回调函数中，等到依赖加载完成之后，这个回调函数才会运行。</p><p>AMD 的诞生，就是为了解决这两个问题：</p><ol><li>实现 JavaScript 文件的异步加载，避免网页失去响应</li><li><p>管理模块之间的依赖性，便于代码的编写和维护</p><p> // 模块定义<br>  define(id?: String, dependencies?: String[], factory: Function|Object);</p></li></ol><p>id 是模块的名字，它是可选的参数。</p><p>dependencies 指定了所要依赖的模块列表，它是一个数组，也是可选的参数。每个依赖的模块的输出都将作为参数一次传入 factory 中。如果没有指定 dependencies，那么它的默认值是 [“require”, “exports”, “module”]。</p><p>factory 是最后一个参数，它包裹了模块的具体实现，它是一个函数或者对象。如果是函数，那么它的返回值就是模块的输出接口或值，如果是对象，此对象应该为模块的输出值。</p><p>举个例子：</p><pre><code>// 模块定义，add.jsdefine(function() {  let add = function(a, b) {    return a + b;  };  return add;});// 模块定义，decrease.jsdefine(function() {  let decrease = function(a, b) {    return a - b;  };  return decrease;});// 模块定义，square.jsdefine([&quot;./add&quot;, &quot;./decrease&quot;], function(add, decrease) {  let square = function(a, b) {    return add(a, b) * decrease(a, b);  };  return square;});// 模块使用，主入口文件 main.jsrequire([&quot;square&quot;], function(math) {  console.log(square(6, 3));});</code></pre><p>这里用实现了 AMD 规范的 RequireJS 来分析，RequireJS 源码较为复杂，这里只对异步模块加载原理做一个分析。在加载模块的过程中， RequireJS 会调用如下函数：</p><pre><code>/** * * @param {Object} context the require context to find state. * @param {String} moduleName the name of the module. * @param {Object} url the URL to the module. */req.load = function(context, moduleName, url) {  var config = (context &amp;&amp; context.config) || {},    node;  // 判断是否为浏览器if (isBrowser) {    // 根据模块名称和 url 创建一个 Script 标签    node = req.createNode(config, moduleName, url);    node.setAttribute(&quot;data-requirecontext&quot;, context.contextName);    node.setAttribute(&quot;data-requiremodule&quot;, moduleName);    // 对不同的浏览器 Script 标签事件监听做兼容处理if (      node.attachEvent &amp;&amp;      !(        node.attachEvent.toString &amp;&amp;        node.attachEvent.toString().indexOf(&quot;[native code&quot;) &lt; 0      ) &amp;&amp;      !isOpera    ) {      useInteractive = true;      node.attachEvent(&quot;onreadystatechange&quot;, context.onScriptLoad);    } else {      node.addEventListener(&quot;load&quot;, context.onScriptLoad, false);      node.addEventListener(&quot;error&quot;, context.onScriptError, false);    }    // 设置 Script 标签的 src 属性为模块路径    node.src = url;    if (config.onNodeCreated) {      config.onNodeCreated(node, config, moduleName, url);    }    currentlyAddingScript = node;    // 将 Script 标签插入到页面中if (baseElement) {      head.insertBefore(node, baseElement);    } else {      head.appendChild(node);    }    currentlyAddingScript = null;    return node;  } elseif (isWebWorker) {    try {      //In a web worker, use importScripts. This is not a very//efficient use of importScripts, importScripts will block until//its script is downloaded and evaluated. However, if web workers//are in play, the expectation is that a build has been done so//that only one script needs to be loaded anyway. This may need//to be reevaluated if other use cases become common.// Post a task to the event loop to work around a bug in WebKit// where the worker gets garbage-collected after calling// importScripts(): https://webkit.org/b/153317      setTimeout(function() {}, 0);      importScripts(url);      //Account for anonymous modules      context.completeLoad(moduleName);    } catch (e) {      context.onError(        makeError(          &quot;importscripts&quot;,          &quot;importScripts failed for &quot; + moduleName + &quot; at &quot; + url,          e,          [moduleName]        )      );    }  }};// 创建异步 Script 标签req.createNode = function(config, moduleName, url) {  var node = config.xhtml    ? document.createElementNS(&quot;http://www.w3.org/1999/xhtml&quot;, &quot;html:script&quot;)    : document.createElement(&quot;script&quot;);  node.type = config.scriptType || &quot;text/javascript&quot;;  node.charset = &quot;utf-8&quot;;  node.async = true;  return node;};</code></pre><p>可以看出，这里主要是根据模块的 Url，创建了一个异步的 Script 标签，并将模块 id 名称添加到的标签的 data-requiremodule 上，再将这个 Script 标签添加到了 html 页面中。同时为 Script 标签的 load 事件添加了处理函数，当该模块文件被加载完毕的时候，就会触发 context.onScriptLoad。我们在 onScriptLoad 添加断点，可以看到页面结构如下图所示:<br> 由图可以看到，Html 中添加了一个 Script 标签，这也就是异步加载模块的原理。</p><h2 id="JavaScript-模块化之-CMD"><a href="#JavaScript-模块化之-CMD" class="headerlink" title="JavaScript 模块化之 CMD"></a>JavaScript 模块化之 CMD</h2><p>CMD (Common Module Definition) 通用模块定义，CMD 在浏览器端的实现有 SeaJS， 和 RequireJS 一样，SeaJS 加载原理也是动态创建异步 Script 标签。二者的区别主要是依赖写法上不同，AMD 推崇一开始就加载所有的依赖，而 CMD 则推崇在需要用的地方才进行依赖加载。</p><pre><code>// ADM 在执行以下代码的时候，RequireJS 会首先分析依赖数组，然后依次加载，直到所有加载完毕再执行回到函数define([&quot;add&quot;, &quot;decrease&quot;], function(add, decrease) {  let result1 = add(9, 7);  let result2 = decrease(9, 7);  console.log(result1 * result2);});// CMD 在执行以下代码的时候， SeaJS 会首先用正则匹配出代码里面所有的 require 语句，拿到依赖，然后依次加载，加载完成再执行回调函数define(function(require) {  let add = require(&quot;add&quot;);  let result1 = add(9, 7);  let add = require(&quot;decrease&quot;);  let result2 = decrease(9, 7);  console.log(result1 * result2);});</code></pre><h2 id="JavaScript-模块化之-ES-Module"><a href="#JavaScript-模块化之-ES-Module" class="headerlink" title="JavaScript 模块化之 ES Module"></a>JavaScript 模块化之 ES Module</h2><p>ES Module 是在 ECMAScript 6 中引入的模块化功能。模块功能主要由两个命令构成，分别是 export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p><p>其使用方式如下:</p><pre><code>// 模块定义 add.jsexportfunctionadd(a, b) {  return a + b;}// 模块使用 main.jsimport { add } from&quot;./add.js&quot;;console.log(add(1, 2)); // 3</code></pre><p>下面讲述几个较为重要的点。</p><h3 id="export-和-export-default"><a href="#export-和-export-default" class="headerlink" title="export 和 export default"></a>export 和 export default</h3><p>在一个文件或模块中，export 可以有多个，export default 仅有一个, export 类似于具名导出，而 default 类似于导出一个变量名为 default 的变量。同时在 import 的时候，对于 export 的变量，必须要用具名的对象去承接，而对于 default，则可以任意指定变量名，例如：</p><pre><code>// a.jsexportvar a = 2; exportvar b = 3 ;// main.js 在导出的时候必须要用具名变量 a, b 且以解构的方式得到导出变量import {a, b} from&apos;a.js&apos;// √ a= 2, b = 3import a from&apos;a.js&apos;// x// b.js export default 方式const a = 3exportdefault a // 注意不能 export default const a = 3 ,因为这里 default 就相当于一个变量名// 导出import b form &apos;b.js&apos;// √import c form &apos;b.js&apos;// √ 因为 b 模块导出的是 default，对于导出的default，可以用任意变量去承接</code></pre><h3 id="ES-Module-模块加载和导出过程"><a href="#ES-Module-模块加载和导出过程" class="headerlink" title="ES Module 模块加载和导出过程"></a>ES Module 模块加载和导出过程</h3><p>以如下代码为例子：</p><pre><code>// counter.jsexportlet count = 5// display.jsexportfunctionrender() {   console.log(&apos;render&apos;) } // main.jsimport { counter } from&apos;./counter.js&apos;; import { render } from&apos;./display.js&apos; ......// more code</code></pre><p>在模块加载模块的过程中，主要经历以下几个步骤：</p><h4 id="构建-Construction"><a href="#构建-Construction" class="headerlink" title="构建 (Construction)"></a>构建 (Construction)</h4><p>这个过程执行查找，下载，并将文件转化为模块记录 (Module record)。所谓的模块记录是指一个记录了对应模块的语法树，依赖信息，以及各种属性和方法 (这里不是很明白)。同样也是在这个过程对模块记录进行了缓存的操作，下图是一个模块记录表：</p><p>下图是缓存记录表：</p><h4 id="实例化-Instantiation"><a href="#实例化-Instantiation" class="headerlink" title="实例化 (Instantiation)"></a>实例化 (Instantiation)</h4><p>这个过程会在内存中开辟一个存储空间 (此时还没有填充值)，然后将该模块所有的 export 和 import 了该模块的变量指向这个内存，这个过程叫做链接。其写入 export 示意图如下所示：<br> 然后是链接 import，其示意图如下所示：</p><h4 id="赋值-Evaluation"><a href="#赋值-Evaluation" class="headerlink" title="赋值(Evaluation)"></a>赋值(Evaluation)</h4><p>这个过程会执行模块代码，并用真实的值填充上一阶段开辟的内存空间，此过程后 import 链接到的值就是 export 导出的真实值。</p><p>根据上面的过程我们可以知道。ES Module 模块 export 和 import 其实指向的是同一块内存，但有一个点需要注意的是，import 处不能对这块内存的值进行修改，而 export 可以，其示意图如下：</p><h2 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h2><ol><li><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。?CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。<br>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</p></li><li><p>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p></li></ol><h2 id="CMD与AMD区别"><a href="#CMD与AMD区别" class="headerlink" title="CMD与AMD区别"></a>CMD与AMD区别</h2><ul><li>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。</li><li>AMD依赖前置，js可以方便知道依赖模块是谁，立即加载；</li><li>而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要对目前主流的 JavaScript 模块化方案 CommonJs，AMD，CMD, ES Module 进行了学习和了解，并对其中最有代表性的模块化实现 (NodeJs，RequireJS，SeaJS，ES6) 做了一个简单的分析。对于服务端的模块而言，由于其模块都是存储在本地的，模块加载方便，所以通常是采用同步读取文件的方式进行模块加载。而对于浏览器而言，其模块一般是存储在远程网络上的，模块的下载是一个十分耗时的过程，所以通常是采用动态异步脚本加载的方式加载模块文件。另外，无论是客户端还是服务端的 JavaScript 模块化实现，都会对模块进行缓存，以此减少二次加载的开销。</p>]]></content>
      
      
      
        <tags>
            
            <tag> amd </tag>
            
            <tag> cmd </tag>
            
            <tag> CommonJS </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Node.js技巧</title>
      <link href="/2016/11/12/Node-js%E6%8A%80%E5%B7%A7/"/>
      <url>/2016/11/12/Node-js%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="将node-js的终端输出重定向到浏览器控制台中"><a href="#将node-js的终端输出重定向到浏览器控制台中" class="headerlink" title="将node.js的终端输出重定向到浏览器控制台中"></a><a href="https://blog.suisuijiang.com/in-nodejs-realize-code-hot-reload-function/" target="_blank" rel="noopener">将node.js的终端输出重定向到浏览器控制台中</a></h1><p>使用过webpack做前端的朋友大概知道, webpack有个dev-server功能, 支持在代码发生改动时自动的重启代码, 简称hot-reload. 这一特性极大地促进了开发效率, 所以下面我们通过编写代码来实现这个特性.</p><h2 id="创建开发目录"><a href="#创建开发目录" class="headerlink" title="创建开发目录"></a>创建开发目录</h2><p>首先创建一个<code>src</code>目录, 后面我们将监视<code>src</code>目录中的代码改动, 在<code>src</code>目录创建<code>app.js</code>做程序入口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//*app.js</span><br><span class="line">console.log(&apos;app.js&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="使用chokidar监视目录"><a href="#使用chokidar监视目录" class="headerlink" title="使用chokidar监视目录"></a>使用chokidar监视目录</h2><p><a href="https://www.npmjs.com/package/chokidar" target="_blank" rel="noopener">chokidar</a>是一个小巧的文件监视库, 它可以获取到目录中文件的改动/新增/删除等事件. 在项目根目录创建<code>development.js</code>, <code>development.js</code>代码如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// *development.js*    </span><br><span class="line">&apos;use strict&apos;</span><br><span class="line"></span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const chokidar = require(&apos;chokidar&apos;);</span><br><span class="line"></span><br><span class="line">const watcher = chokidar.watch(path.join(__dirname, &apos;/src&apos;));</span><br><span class="line"></span><br><span class="line">watcher.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    watcher.on(&apos;change&apos;, (path) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;&lt;---- watched file change, do something ----&gt;&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watcher.on(&apos;add&apos;, (path) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;&lt;---- watched new file add, do something ----&gt;&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    watcher.on(&apos;unlink&apos;, (path) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">console.log(&apos;&lt;---- watched file remove, do something ----&gt;&apos;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>执行<code>npm install --save chokidar</code>安装’chokidar’组件, 并执行<code>node development.js</code>运行程序, 尝试修改<code>app.js</code>的内容, 尝试在<code>src</code>目录中新建文件并删除新建的文件, 会看到如下所示输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//*console log*</span><br><span class="line"></span><br><span class="line">    ⇒  node development.js</span><br><span class="line">    </span><br><span class="line">    &lt;---- watched file change, do something ----&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;---- watched new file add, do something ----&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;---- watched file remove, do something ----&gt;</span><br></pre></td></tr></table></figure></p><h2 id="引入程序并在发生改动时重启"><a href="#引入程序并在发生改动时重启" class="headerlink" title="引入程序并在发生改动时重启"></a>引入程序并在发生改动时重启</h2><p>由于主进程被用来监视文件了, 所以我们要把主程序运行在子进程中, 当代码发生改动时, 我们可以结束这个子进程并创建新的子进程. 创建进程需要使用<a href="https://nodejs.org/api/child_process.html" target="_blank" rel="noopener">child_process</a>模块, 代码如下所示:</p><p><em>创建子进程, 启动主程序</em><br>···<br>    let appIns = cp.fork(path.join(__dirname, ‘../src/app.js’));<br>···<br><em>发生改动时杀死子进程并重启</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appIns.kill(&apos;SIGINT&apos;);</span><br><span class="line"></span><br><span class="line">appIns = cp.fork(require(&apos;path&apos;).join(__dirname, &apos;../src/app.js&apos;));</span><br></pre></td></tr></table></figure></p><p><em>监听SIGINT信息, 终止进程</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;SIGINT&apos;, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    process.exit(0);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>完整代码如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// *development.js*</span><br><span class="line"></span><br><span class="line">    &apos;use strict&apos;</span><br><span class="line">    </span><br><span class="line">    const path = require(&apos;path&apos;);</span><br><span class="line">    </span><br><span class="line">    const cp = require(&apos;child_process&apos;);</span><br><span class="line">    </span><br><span class="line">    const chokidar = require(&apos;chokidar&apos;);</span><br><span class="line">    </span><br><span class="line">    const watcher = chokidar.watch(path.join(__dirname, &apos;/src&apos;));</span><br><span class="line">    </span><br><span class="line">    let appIns = cp.fork(path.join(__dirname, &apos;/src/app.js&apos;));</span><br><span class="line">    </span><br><span class="line">    watcher.on(&apos;ready&apos;, () =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">        watcher.on(&apos;change&apos;, (path) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    console.log(&apos;&lt;---- watched file change, do something ----&gt;&apos;);</span><br><span class="line">    </span><br><span class="line">            appIns = reload(appIns);</span><br><span class="line">    </span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        watcher.on(&apos;add&apos;, (path) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    console.log(&apos;&lt;---- watched new file add, do something ----&gt;&apos;);</span><br><span class="line">    </span><br><span class="line">            appIns = reload(appIns);</span><br><span class="line">    </span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">        watcher.on(&apos;unlink&apos;, (path) =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    console.log(&apos;&lt;---- watched file remove, do something ----&gt;&apos;);</span><br><span class="line">    </span><br><span class="line">            appIns = reload(appIns);</span><br><span class="line">    </span><br><span class="line">        &#125;);</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    process.on(&apos;SIGINT&apos;, () =&gt; &#123;</span><br><span class="line">    </span><br><span class="line">        process.exit(0);</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    functionreload(appIns) &#123;</span><br><span class="line">    </span><br><span class="line">        appIns.kill(&apos;SIGINT&apos;);</span><br><span class="line">    </span><br><span class="line">    return cp.fork(require(&apos;path&apos;).join(__dirname, &apos;/src/app.js&apos;));</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>执行<code>node development.js</code>运行, 尝试修改<code>app.js</code>, 改为<code>console.log(&#39;app.js changed&#39;);</code>, 将看到如下输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*console log*</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ⇒  node development.js</span><br><span class="line">    </span><br><span class="line">    app.js</span><br><span class="line">    </span><br><span class="line">    &lt;---- watched file change, do something ----&gt;</span><br><span class="line">    </span><br><span class="line">    app.js changed</span><br></pre></td></tr></table></figure></p><p>尝试在<code>src</code>目录中创建<code>a.js</code>, 并修改<code>app.js</code>使其输出<code>a.js</code>内容, 这里不在粘贴输出, 请自行尝试.</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>可以看到该实现方法十分简单, 并且适用于任何node.js开发场景, 譬如常用的express, koa后端接口开发.</p><p>感谢您的阅读, 欢迎留言指导讨论.</p><h1 id="将node-js的终端输出重定向到浏览器控制台中-1"><a href="#将node-js的终端输出重定向到浏览器控制台中-1" class="headerlink" title="将node.js的终端输出重定向到浏览器控制台中"></a><a href="https://blog.suisuijiang.com/node-js-console-log-redirect-to-browser/" target="_blank" rel="noopener">将node.js的终端输出重定向到浏览器控制台中</a></h1><p>在编写node.js代码时, 我们经常会临时的打印变量来查看内容, 对于一些基本的数据类型, 比如: <code>Number</code>, <code>String</code>, <code>Boolean</code>, 并没有什么问题, 但是当打印<code>Object</code>类型时, 如果该<code>Object</code>变量具有大量的属性, 我们会得到一个超长的输出内容, 有的时候甚至会超出终端缓冲区大小, 非常不利于观察结果. </p><p>使用过chrome浏览器开发者工具的朋友应该发现了, chrome的console会折叠<code>Object</code>值, 并且可以随意打开查看, 十分方便.</p><p> <img src="/2016/11/12/Node-js技巧/1.png" alt=""></p><h2 id="将输出重定向"><a href="#将输出重定向" class="headerlink" title="将输出重定向"></a>将输出重定向</h2><p>在这里, 我们使用开源组件<a href="https://www.npmjs.com/package/node-monkey" target="_blank" rel="noopener">node-monkey</a>, <code>node-monkey</code>是一款在浏览器对node.js程序进行debug和性能分析的工具.</p><p>执行<code>npm install --save node_monkey</code>安装组件.</p><p>在你的程序入口添加如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&apos;node-monkey&apos;).start()</span><br></pre></td></tr></table></figure></p><p>运行你的程序, 可以看到终端中的输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*console log*</span><br><span class="line"></span><br><span class="line">    ⇒  node app.js</span><br><span class="line">    </span><br><span class="line">       info  - socket.io started</span><br><span class="line">    </span><br><span class="line">    ------------------</span><br><span class="line">    </span><br><span class="line">    NodeMonkey started</span><br><span class="line">    </span><br><span class="line">    To inspect output, open a browser to: http://127.0.0.1:50500</span><br><span class="line">    </span><br><span class="line">    ------------------</span><br></pre></td></tr></table></figure></p><p>打开浏览器访问<code>http://127.0.0.1:50500</code>, 打开浏览器的控制台, 可以看到你的程序的输出内容.</p><p> <img src="/2016/11/12/Node-js技巧/2.png" alt=""></p><p><code>node-monkey</code>默认关联了<code>console.log</code>, <code>console.warn</code>, <code>console.error</code>输出函数, <code>127.0.0.1:50500</code>是<code>node-monkey</code>的默认地址, 可以通过在<code>start()</code>中传入参数来修改.</p><h2 id="自动打开浏览器"><a href="#自动打开浏览器" class="headerlink" title="自动打开浏览器"></a>自动打开浏览器</h2><p>有个小工具可以让我们自动打开默认浏览器并跳转到指定地址, 免去手动输入的过程.</p><p>安装<code>opener</code>, 执行<code>npm install --save opener</code></p><p>在上述所添加的代码下方加上如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;opener&quot;)(&apos;http://127.0.0.1:50500&apos;);</span><br></pre></td></tr></table></figure></p><p>重新运行你的程序, 启动<code>node-money</code>后就自动打开到指定页面了.</p><p><code>node-monkey</code>还有其它可用的功能, 您可以查询文档研究它的妙用.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>26个精选的JavaScript面试问题</title>
      <link href="/2016/10/31/26%E4%B8%AA%E7%B2%BE%E9%80%89%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
      <url>/2016/10/31/26%E4%B8%AA%E7%B2%BE%E9%80%89%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在JavaScript中，在两个不同类型之间的转换叫做<code>coercion</code>。在JavaScript中有两种形式：显示转换和隐式转换。</p><p>下面是一个显示转换的例子：</p><pre><code>var a = &quot;42&quot;;var b = Number( a );a;              // &quot;42&quot;b;              // 42 -- the number!</code></pre><p>下面是一个隐式转换的例子：</p><pre><code>var a = &quot;42&quot;;var b = a * 1;  // &quot;42&quot; implicitly coerced to 42 herea;              // &quot;42&quot;b;              // 42 -- the number!</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.fullstack.cafe%2F" target="_blank" rel="noopener">FullStack.Cafe</a></p><h3 id="Q2-JavaScript中的作用域是怎样的？"><a href="#Q2-JavaScript中的作用域是怎样的？" class="headerlink" title="Q2: JavaScript中的作用域是怎样的？"></a>Q2: JavaScript中的作用域是怎样的？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐</p></blockquote><p>在JavaScript中，每一个函数都有各自的作用域(<code>scope</code>)。作用域可以理解为是一个变量的集合以及相应的如何访问它的规则。只有在函数内部的变量才可以访问到该函数域的变量。</p><p>在同一个作用域内部，变量名必须要唯一。作用域可以嵌套。在最内部的作用域中，可以访问任何外部的作用域中的变量。</p><h3 id="Q3-请解释JavaScript中的相等判断"><a href="#Q3-请解释JavaScript中的相等判断" class="headerlink" title="Q3: 请解释JavaScript中的相等判断"></a>Q3: 请解释JavaScript中的相等判断</h3><blockquote><p>话题: JavaScript<br>难度: ⭐</p></blockquote><p>JavaScript中的相等判断有严格判断和带隐式转换的判断两种：</p><ul><li>严格判断(strict comparision): 比如<code>===</code>，比较的时候不会隐式转换类型；</li><li><p>抽象判断(abstract comparasion)：比如<code>==</code>，比较的时候会隐式转换类型。</p><p>  var a = “42”;<br>  var b = 42;</p><p>  a == b;         // true<br>  a === b;        // false</p></li></ul><p>一些简单的规则：</p><ul><li>如果两边都是布尔类型的值，使用<code>===</code>;</li><li>如果两边是0,<code>&quot;&quot;</code>,<code>[]</code>，使用<code>===</code>;</li><li>所有其它类型，使用<code>==</code>是安全的。而且在很多情况下会简化代码、增加可读性。</li></ul><h3 id="Q4-请解释什么叫做回调函数并提供一个简单的例子"><a href="#Q4-请解释什么叫做回调函数并提供一个简单的例子" class="headerlink" title="Q4: 请解释什么叫做回调函数并提供一个简单的例子"></a>Q4: 请解释什么叫做回调函数并提供一个简单的例子</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p>回调函数是一个函数，它被作为参数传入另一个函数，当某些操作结束后，该函数被调用。下面是一个简单的例子，当数组被修改后，调用回调函数打印一行日志。</p><pre><code>functionmodifyArray(arr, callback) {  // do something to arr here  arr.push(100);  // then execute the callback function that was passed  callback();}var arr = [1, 2, 3, 4, 5];modifyArray(arr, function() {  console.log(&quot;array has been modified&quot;, arr);});</code></pre><h3 id="Q5-“use-strict”到底有何用处？"><a href="#Q5-“use-strict”到底有何用处？" class="headerlink" title="Q5: “use strict”到底有何用处？"></a>Q5: “use strict”到底有何用处？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p><code>use strict</code>放在文件的顶部或则函数的第一行来启动更加严格的检查来避免失误引起的错误。比如，下面的代码会抛出错误：</p><pre><code>functiondoSomething(val) {  &quot;use strict&quot;;   x = val + 10;}</code></pre><p>因为x没有定义，如果使用了<code>use strict</code>，x是不会被当做全局的变量来看待。下面的代码修复了这个BUG：</p><pre><code>functiondoSomething(val) {  &quot;use strict&quot;;   var x = val + 10;}</code></pre><h3 id="Q6-请解释Null和Undefined"><a href="#Q6-请解释Null和Undefined" class="headerlink" title="Q6: 请解释Null和Undefined"></a>Q6: 请解释Null和Undefined</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p>JavaScript和TypeScript有两个最基本的类型<code>null</code>和<code>undefined</code>。它们的含义是不同的：</p><ul><li>如果还没有被初始化，则是<code>undefined</code>;</li><li>如果不可用，则可以用<code>null</code>来表示；</li></ul><h3 id="Q7-请实现如下函数"><a href="#Q7-请实现如下函数" class="headerlink" title="Q7: 请实现如下函数"></a>Q7: 请实现如下函数</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><pre><code>var addSix = createBase(6);addSix(10); // returns 16addSix(21); // returns 27</code></pre><p><code>addSix</code>是一个函数，也就是说createBase函数的返回是一个函数。</p><pre><code>functioncreateBase(baseNumber) {  returnfunction(N) {    // we are referencing baseNumber here even though it was declared// outside of this function. Closures allow us to do this in JavaScriptreturn baseNumber + N;  }}var addSix = createBase(6);addSix(10);addSix(21);</code></pre><h3 id="Q8-请解释JavaScript中的值和类型"><a href="#Q8-请解释JavaScript中的值和类型" class="headerlink" title="Q8: 请解释JavaScript中的值和类型"></a>Q8: 请解释JavaScript中的值和类型</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p>下面是JavaScript内置的可用类型：</p><ul><li>string</li><li>number</li><li>boolean</li><li>null和undefined</li><li>object</li><li>symbol (ES6的新语法)</li></ul><h3 id="Q9-请解释事件冒泡以及如何阻止它？"><a href="#Q9-请解释事件冒泡以及如何阻止它？" class="headerlink" title="Q9: 请解释事件冒泡以及如何阻止它？"></a>Q9: 请解释事件冒泡以及如何阻止它？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p>事件冒泡的概念是指：在最内层的元素上绑定的事件被触发后，会按照嵌套的层次由内向外逐步触发。因此，点击某个孩子节点可能会触发父节点的事件。</p><p>一个阻止事件冒泡的办法就是使用<code>event.stopPropagation()</code>，在IE&lt;9的浏览器上使用<code>event.cancelBubble()</code>。</p><p>来源：<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkennymkchan" target="_blank" rel="noopener">github.com/kennymkchan</a></p><h3 id="Q10-请解释JavaScript中的let关键字"><a href="#Q10-请解释JavaScript中的let关键字" class="headerlink" title="Q10. 请解释JavaScript中的let关键字"></a>Q10. 请解释JavaScript中的let关键字</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p>ES6允许你使用let关键字来申明块作用域(<code>{...}</code>)的变量。</p><p>来源: <a href="https://link.juejin.im?target=github.com%2Fgetify" target="_blank" rel="noopener">github.com/getify</a></p><h3 id="Q11-如何检查一个数字是否是整数？"><a href="#Q11-如何检查一个数字是否是整数？" class="headerlink" title="Q11: 如何检查一个数字是否是整数？"></a>Q11: 如何检查一个数字是否是整数？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p>一个最简单的方法是判断除以1的余数是否为0.</p><pre><code>functionisInt(num) {  return num % 1 === 0;}console.log(isInt(4)); // trueconsole.log(isInt(12.2)); // falseconsole.log(isInt(0.3)); // false</code></pre><p>来源: <a href="https://link.juejin.im?target=coderbyte.com" target="_blank" rel="noopener">coderbyte.com</a></p><h3 id="Q12-什么叫IIFEs-Immediately-Invoked-Function-Expressions"><a href="#Q12-什么叫IIFEs-Immediately-Invoked-Function-Expressions" class="headerlink" title="Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)?"></a>Q12: 什么叫IIFEs(Immediately Invoked Function Expressions)?</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p>IIFE叫做立即执行表达式，顾名思义，该表达式一被创建就立即执行。</p><pre><code>(functionIIFE(){    console.log( &quot;Hello!&quot; );})();// &quot;Hello!&quot;</code></pre><p>该方法常用语避免污染全局的命名空间，因为所以在IIFE中使用的变量外部都无法访问。</p><p>来源: <a href="https://link.juejin.im?target=stackoverflow.com" target="_blank" rel="noopener">stackoverflow.com</a></p><h3 id="Q13-如果比较JavaScript中的两个对象？"><a href="#Q13-如果比较JavaScript中的两个对象？" class="headerlink" title="Q13: 如果比较JavaScript中的两个对象？"></a>Q13: 如果比较JavaScript中的两个对象？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐</p></blockquote><p>两个非基本类型的值，比如对象(包括函数和数组)都是通过引用的形式来访问。如果直接通过<code>==</code>和<code>===</code>来判断，那么只会简单的判断其引用地址是否相同，而不是它们实际对应的值。</p><p>如果数组和字符串做比较，那么数组会通过逗号拼接转换为字符串。通过等号判断的时候，两个相同的数组不会相等，但是和相同数据的字符串比较反而相等。</p><pre><code>var a = [1,2,3];var b = [1,2,3];var c = &quot;1,2,3&quot;;a == c;     // trueb == c;     // truea == b;     // false</code></pre><p>如果要深度比较，可以使用第三方库，比如<code>deep-equal</code>或则你自己实现一个比较算法。</p><h3 id="Q14-请解释ES5和ES6的不同点"><a href="#Q14-请解释ES5和ES6的不同点" class="headerlink" title="Q14: 请解释ES5和ES6的不同点"></a>Q14: 请解释ES5和ES6的不同点</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐</p></blockquote><ul><li>ECMAScript 5 (ES5): 第5个ECMAScript版本，于2009年标准化。该标准几乎所有的浏览器都完全支持。</li><li>ECMAScript 6 (ES6)/ECMAScript 2015 (ES2015):  第6个ECMAScript版本，于2015年标准化。目前各大浏览器还只是部分支持。</li></ul><p>接下来介绍它们主要的区别：</p><ul><li><p>箭头函数和字符串嵌入：</p><p>  const greetings = (name) =&gt; {</p><pre><code>return`hello ${name}`;</code></pre><p>  }</p></li></ul><p>甚至：</p><pre><code>const greetings = name =&gt;`hello ${name}`;</code></pre><ul><li><p>常量声明(Const): 如同其它编程语言中的常量一样，但又有不同。这里的<code>const</code>代表了<code>constant reference</code>。也就是说，你可以修改其指向的对象的值。但是你不能修改其reference的值。</p><p>  const NAMES = [];<br>  NAMES.push(“Jim”);<br>  console.log(NAMES.length === 1); // true<br>  NAMES = [“Steve”, “John”]; // error</p></li><li><p>块作用域变量：ES6中的新关键字<code>let</code>允许允许开发者将变量的作用域限定在块级别。不会像<code>var</code>一样变量提升。</p></li><li><p>参数默认值：允许在函数定义的时候指定默认的值。</p><p>  // Basic syntaxfunctionmultiply (a, b = 2) {</p><pre><code>return a * b;</code></pre><p>  }<br>  multiply(5); // 10</p></li><li><p>类定义和继承</p></li></ul><p>ES6开始支持定义类(使用<code>class</code>关键字)，构造函数(使用<code>constructor</code>关键字)，和<code>extend</code>关键字来实现继承。</p><ul><li>for-of操作</li></ul><p><code>for...of</code>语句用来迭代访问一个对象的所有属性。</p><ul><li><p>Spread操作符：用于对象合并</p><p>  const obj1 = { a: 1, b: 2 }<br>  const obj2 = { a: 2, c: 3, d: 4}<br>  const obj3 = {…obj1, …obj2}</p></li></ul><ul><li><p>Promise: Promises提供了一个处理异步操作的方法。你可以用回调函数来实现，但是Promise更加简洁和可读。</p><p>  const isGreater = (a, b) =&gt; {</p><pre><code>returnnewPromise ((resolve, reject) =&gt; {  if(a &gt; b) {    resolve(true)  } else {    reject(false)  }  })</code></pre><p>  }<br>  isGreater(1, 2)</p><pre><code>.then(result =&gt; {  console.log(&apos;greater&apos;)})</code></pre><p>   .catch(result =&gt; {</p><pre><code>console.log(&apos;smaller&apos;)</code></pre><p>   })</p></li></ul><ul><li><p>模块的export和import。</p><p>  const myModule = { x: 1, y: () =&gt; { console.log(‘This is ES5’) }}<br>  exportdefault myModule;</p></li></ul><pre><code>import myModule from&apos;./myModule&apos;;</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fdev.to%2Faershov24%2Fundefined" target="_blank" rel="noopener">Bulby.io</a></p><h3 id="Q15-请解释undefined和not-defined的区别"><a href="#Q15-请解释undefined和not-defined的区别" class="headerlink" title="Q15: 请解释undefined和not defined的区别"></a>Q15: 请解释<code>undefined</code>和<code>not defined</code>的区别</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐</p></blockquote><p>在JavaScript中，如果你尝试使用不存在的还未申明的变量，JavaScript会抛出错误<code>var name is not defined</code>。但是如果你用<code>typeof</code>来查看其类型，会返回<code>undefined</code>。</p><p>我们先来澄清一下声明和定义的区别：<code>var x</code>是一个声明，因为你并没有定义其具体的值，你只是声明其存在性。</p><pre><code>var x; // declaring xconsole.log(x); //output: undefined</code></pre><p><code>var x = 1</code>同时兼具声明和定义，我们也可以叫它初始化。在JavaScript中，每一个变量和函数声明都会被提升到顶部。</p><p>如果我们访问一个声明了但是未定义的变量，会返回<code>undefined</code>。</p><pre><code>var x; // Declarationif(typeof x === &apos;undefined&apos;) // Will return true</code></pre><blockquote><p>访问一个未声明未定义的变量，会返回not defined错误。</p></blockquote><pre><code>console.log(y);  // Output: ReferenceError: y is not defined</code></pre><p>来源: <a href="https://link.juejin.im?target=http%3A%2F%2Fstackoverflow.com%2Fquestions%2F20822022%2Fjavascript-variable-definition-declaration" target="_blank" rel="noopener">stackoverflow.com</a></p><h3 id="Q16-匿名函数和命名函数的区别？"><a href="#Q16-匿名函数和命名函数的区别？" class="headerlink" title="Q16: 匿名函数和命名函数的区别？"></a>Q16: 匿名函数和命名函数的区别？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐</p></blockquote><pre><code>var foo = function() { // anonymous function assigned to variable foo// ..};var x = functionbar(){ // named function (bar) assigned to variable x // ..};foo(); // actual function executionx();</code></pre><p>译者补充：匿名函数如果不赋值给某个变量，则无法被调用了；命名函数再次被赋值不是多此一举么。</p><h3 id="Q17-JavaScript中闭包是什么？请提供一个例子"><a href="#Q17-JavaScript中闭包是什么？请提供一个例子" class="headerlink" title="Q17: JavaScript中闭包是什么？请提供一个例子"></a>Q17: JavaScript中闭包是什么？请提供一个例子</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><p>闭包是一个定义在其它函数(父函数)里面的函数，它拥有对父函数里面变量的访问权。闭包拥有如下三个作用域的访问权：</p><ul><li>自身的作用域</li><li>父作用域</li><li><p>全局作用域</p><p>  var globalVar = “abc”;</p><p>  // Parent self invoking function<br>  (functionouterFunction (outerArg) { // begin of scope outerFunction// Variable declared in outerFunction function scopevar outerFuncVar = ‘x’;    </p><pre><code>// Closure self-invoking function(functioninnerFunction (innerArg) { // begin of scope innerFunction// variable declared in innerFunction function scopevar innerFuncVar = &quot;y&quot;;  console.log(             &quot;outerArg = &quot; + outerArg + &quot;\n&quot; +    &quot;outerFuncVar = &quot; + outerFuncVar + &quot;\n&quot; +    &quot;innerArg = &quot; + innerArg + &quot;\n&quot; +    &quot;innerFuncVar = &quot; + innerFuncVar + &quot;\n&quot; +    &quot;globalVar = &quot; + globalVar);// end of scope innerFunction})(5); // Pass 5 as parameter// end of scope outerFunction</code></pre><p>  })(7); // Pass 7 as parameter</p></li></ul><p><code>innerFunction</code>是一个闭包，定义在<code>outerFunction</code>中，它可以访问<code>outerFunction</code>作用域的所有变量。当然，它还可以访问全局变量。</p><p>输出结果如下：</p><pre><code>outerArg = 7outerFuncVar = xinnerArg = 5innerFuncVar = yglobalVar = abc</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fganqqwerty%2F123-Essential-JavaScript-Interview-Question%2Fblob%2Fmaster%2FREADME.md" target="_blank" rel="noopener">github.com/ganqqwerty</a></p><h3 id="Q18-在JavaScript中如何创建私有变量？"><a href="#Q18-在JavaScript中如何创建私有变量？" class="headerlink" title="Q18: 在JavaScript中如何创建私有变量？"></a>Q18: 在JavaScript中如何创建私有变量？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><p>你可以通过在函数中声明变量来创建私有变量。因为在函数中，外部无法直接访问。</p><pre><code>functionfunc() {  var priv = &quot;secret code&quot;;}console.log(priv); // throws error</code></pre><p>为了访问该变量，可以构造一个帮助函数来返回该值。</p><pre><code>functionfunc() {  var priv = &quot;secret code&quot;;  returnfunction() {    return priv;  }}var getPriv = func();console.log(getPriv()); // =&gt; secret code</code></pre><p>来源:<a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p><h3 id="Q19-请解释原型模式-Prototype-Design-Pattern"><a href="#Q19-请解释原型模式-Prototype-Design-Pattern" class="headerlink" title="Q19: 请解释原型模式(Prototype Design Pattern)"></a>Q19: 请解释原型模式(Prototype Design Pattern)</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><p>原型模式会创建一个新的对象，但不是创建一个未初始化的对象，而是通过拷贝原型链上的值或则被拷贝对象的值来完成初始化。传统的语言很少使用原型模式，但是JavaScript作为一个基于原型的语言，使用原型模式来创建新的对象。</p><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.dofactory.com%2Fjavascript%2Fprototype-design-pattern" target="_blank" rel="noopener">dofactory.com</a></p><h3 id="Q20-判断给定的字符串是否同态-isomorphic"><a href="#Q20-判断给定的字符串是否同态-isomorphic" class="headerlink" title="Q20: 判断给定的字符串是否同态(isomorphic)"></a>Q20: 判断给定的字符串是否同态(isomorphic)</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><p>首先介绍什么叫做同态：两个字符串，如果A字符串中的每一个字符都可以在B字符串中找到唯一对应，并且顺序一一对应；如果存在这样的函数，那么A和B同态。</p><ul><li><code>paper</code>和<code>title</code>同态</li><li><code>egg</code>和<code>sad</code>不同态</li><li><p><code>dgg</code>和<code>add</code>同态</p><p>  isIsomorphic(“egg”, ‘add’); // true<br>  isIsomorphic(“paper”, ‘title’); // true<br>  isIsomorphic(“kick”, ‘side’); // falsefunctionisIsomorphic(firstString, secondString) {</p><pre><code>// Check if the same length. If not, they cannot be isomorphicif (firstString.length !== secondString.length) returnfalsevar letterMap = {};for (var i = 0; i &lt; firstString.length; i++) {  var letterA = firstString[i],      letterB = secondString[i];  // If the letter does not exist, create a map and map it to the value// of the second letterif (letterMap[letterA] === undefined) {    letterMap[letterA] = letterB;  } elseif (letterMap[letterA] !== letterB) {    // Eles if letterA already exists in the map, but it does not map to// letterB, that means that A is mapping to more than one letter.returnfalse;  }}// If after iterating through and conditions are satisfied, return true.// They are isomorphicreturntrue;</code></pre><p>  }</p></li></ul><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fkennymkchan%2Finterview-questions-in-javascript" target="_blank" rel="noopener">github.com/kennymkchan</a></p><h3 id="Q21-Transpiling代表了什么意思？"><a href="#Q21-Transpiling代表了什么意思？" class="headerlink" title="Q21: Transpiling代表了什么意思？"></a>Q21: <code>Transpiling</code>代表了什么意思？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><p><code>Transpiling</code>是<code>transforming + compiling</code>的合成词。对于一些新的语法，浏览器还不支持。最好的办法就是将其变换到旧的等价的代码，这个过程通常叫做<code>transpiling</code>。</p><p>典型的，你可以在<code>build</code>的过程中加入<code>transpiler</code>，就如同<code>code linter</code>和<code>minifier</code>一样。</p><p>已经有很多知名的transpilers可供使用：</p><ul><li>Babel: 将ES6编译到ES5</li><li>Traceur：将ES6,ES7等编译到ES5</li></ul><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS%2Fblob%2Fmaster%2Fup%2520%2526%2520going%2Fch2.md" target="_blank" rel="noopener">You Don’t Know JS, Up &amp;going</a></p><h3 id="Q22-this关键字如何工作？请提供一些例子"><a href="#Q22-this关键字如何工作？请提供一些例子" class="headerlink" title="Q22: this关键字如何工作？请提供一些例子"></a>Q22: <code>this</code>关键字如何工作？请提供一些例子</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><p>在JavaScript中，this总是指向函数的“拥有者”(也就是指向该函数的对象)，或则拥有该函数的对象。</p><pre><code>functionfoo() {    console.log( this.bar );}var bar = &quot;global&quot;;var obj1 = {    bar: &quot;obj1&quot;,    foo: foo};var obj2 = {    bar: &quot;obj2&quot;};foo();          // &quot;global&quot;obj1.foo();     // &quot;obj1&quot;foo.call( obj2 );  // &quot;obj2&quot;new foo();       // undefined</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.quirksmode.org%2Fjs%2Fthis.html" target="_blank" rel="noopener">quirksmode.org</a></p><h3 id="Q23-如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。"><a href="#Q23-如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。" class="headerlink" title="Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。"></a>Q23: 如何为Array对象添加你自定义的函数，使得如下代码可以正常工作。</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><pre><code>var arr = [1, 2, 3, 4, 5];var avg = arr.average();console.log(avg);</code></pre><p>JavaScript是一个基于原型的语言。也就是说对象之间通过原型链接，并继承其函数。为了给Array对象添加函数，我们可以修改其原型定义<code>Array prorotype</code>。</p><pre><code>Array.prototype.average = function() {  // calculate sumvar sum = this.reduce(function(prev, cur) { return prev + cur; });  // return sum divided by number of elementsreturn sum / this.length;}var arr = [1, 2, 3, 4, 5];var avg = arr.average();console.log(avg); // =&gt; 3</code></pre><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p><h3 id="Q24-JavaScript中提升-hoisting-是什么意思？"><a href="#Q24-JavaScript中提升-hoisting-是什么意思？" class="headerlink" title="Q24: JavaScript中提升(hoisting)是什么意思？"></a>Q24: JavaScript中提升(hoisting)是什么意思？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><p>提升(hoisting)是指JavaScript的解释器将所有的变量和函数声明都提升到该作用域的顶部，有两种提升类型：</p><ul><li>变量提升</li><li>函数提升</li></ul><p>在一个作用域中通过声明的变量和函数在整个作用域中都可以使用。</p><pre><code>var a = 2;foo();                 // works because `foo()`// declaration is &quot;hoisted&quot;functionfoo() {    a = 3;    console.log( a );   // 3var a;             // declaration is &quot;hoisted&quot;// to the top of `foo()`}console.log( a );   // 2</code></pre><p>虽然<code>foo()</code>函数在后面定义，但是在前面也可以调用。</p><h3 id="Q25-如下代码会返回什么结果？"><a href="#Q25-如下代码会返回什么结果？" class="headerlink" title="Q25: 如下代码会返回什么结果？"></a>Q25: 如下代码会返回什么结果？</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐</p></blockquote><pre><code>0.1 + 0.2 === 0.3</code></pre><p>不要惊讶，其结果是false。因为浮点数在系统内的精确度问题，0.1+0.2的结果并不是0.3，而是0.30000000000000004。<br>要避免这个问题的方法是指定返回结果的小数位数。</p><p>来源: <a href="https://link.juejin.im?target=https%3A%2F%2Fcoderbyte.com%2Falgorithm%2F10-common-javascript-interview-questions" target="_blank" rel="noopener">coderbyte.com</a></p><h3 id="Q26-请描述一下揭示模式-Revealing-Module-Pattern"><a href="#Q26-请描述一下揭示模式-Revealing-Module-Pattern" class="headerlink" title="Q26: 请描述一下揭示模式(Revealing Module Pattern)"></a>Q26: 请描述一下揭示模式(Revealing Module Pattern)</h3><blockquote><p>话题: JavaScript<br>难度: ⭐⭐⭐⭐⭐</p></blockquote><p><strong>Module pattern</strong>的一个变种是<code>Revealing Module Pattern</code>。该设计模式的目的是做到很好的代码隔离，只是将需要对外公开的变量和函数暴露出来。一个直接的实现如下所示：</p><pre><code>var Exposer = (function() {  var privateVariable = 10;  var privateMethod = function() {    console.log(&apos;Inside a private method!&apos;);    privateVariable++;  }  var methodToExpose = function() {    console.log(&apos;This is a method I want to expose!&apos;);  }  var otherMethodIWantToExpose = function() {    privateMethod();  }  return {      first: methodToExpose,      second: otherMethodIWantToExpose  };})();Exposer.first();        // Output: This is a method I want to expose!Exposer.second();       // Output: Inside a private method!Exposer.methodToExpose; // undefined</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CommonJS,AMD,CMD,ES6 </title>
      <link href="/2016/10/25/CommonJS-AMD-CMD-ES6/"/>
      <url>/2016/10/25/CommonJS-AMD-CMD-ES6/</url>
      
        <content type="html"><![CDATA[<p>CommonJS,AMD,CMD,ES6</p><p>commonJS用同步的方式加载模块。在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，限于网络原因，更合理的方案是使用异步加载。</p><p>CMD是另一种js模块化方案，它与AMD很类似，不同点在于：AMD 推崇依赖前置、提前执行，CMD推崇依赖就近、延迟执行。此规范其实是在sea.js推广过程中产生的。</p><pre><code>/** AMD写法 **/define([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;], function(a, b, c, d, e, f) {      // 等于在最前面声明并初始化了要用到的所有模块    a.doSomething();    if (false) {        // 即便没用到某个模块 b，但 b 还是提前执行了        b.doSomething()    } });/** CMD写法 **/define(function(require, exports, module) {    var a = require(&apos;./a&apos;); //在需要时申明    a.doSomething();    if (false) {        var b = require(&apos;./b&apos;);        b.doSomething();    }}); </code></pre><p>ES6 模块是动态引用:ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。</p><p>ES6 模块与 CommonJS 模块的差异</p><ol><li><font color="#ff0000">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</font>,<strong>CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</strong><br>ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</li><li><font color="#ff0000"> CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</font></li><li><font color="#ff0000">运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。<br>编译时加载: ES6模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。<br>CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</font></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> amd </tag>
            
            <tag> cmd </tag>
            
            <tag> CommonJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS正则表达式Regex</title>
      <link href="/2016/10/01/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegex/"/>
      <url>/2016/10/01/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8FRegex/</url>
      
        <content type="html"><![CDATA[<blockquote><p>名余曰正则兮，字余曰灵均。</p></blockquote><p><code>Regular Expressions</code>翻译成中文叫正则表达式。也不知道是谁翻译过来的，听起来就很严肃。似乎翻译成<code>通用表达式</code>更能传达其精髓，如果你不怕梦见屈原的话。</p><p>为什么叫通用表达式？因为它有一套和编程语言无关的文本匹配规则。很多语言都实现了正则表达式的文本匹配引擎，只不过在功能集合上略有不同。</p><p>我们要记住的是三点：</p><p>其一，正则表达式是用来提取文本的。</p><p>其二，正则表达式的表达能力强大到令人发指。</p><p>其三，正则表达式的语法对初学者不友好。</p><p>另外，本专题只涉及JavaScript语言的正则表达式，其他语言的规则可能略有不同。</p><p>我还为各位读者准备了一副宣传语，应该能让你心动(点赞)吧？</p><blockquote><p>学一门前端工具，几年就过时了。学正则表达式，受用一辈子。</p></blockquote><h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>什么叫普通字符？</p><p>当我们写<code>a</code>的时候，我们指的就是<code>a</code>；当我们写<code>爱</code>的时候，我们指的就是<code>爱</code>。</p><pre><code>&apos;hello 😀 regex&apos;.match(/😀/);// [&quot;😀&quot;, index: 6, input: &quot;hello 😀 regex&quot;, groups: undefined]复制代码</code></pre><p>这就是普通字符，它在正则中的含义就是检索它本身。除了正则规定的部分字符外，其余的都是普通字符，包括各种人类语言，包括emoji，只要能够表达为字符串。</p><h2 id="开始与结束"><a href="#开始与结束" class="headerlink" title="开始与结束"></a>开始与结束</h2><p><code>^</code>字符的英文是<code>caret</code>，翻译成中文是<code>脱字符</code>。不要问我，又不是我翻译的。它在正则中属于元字符，通常代表的意义是文本的开始。说通常是因为当它在字符组中<code>[^abc]</code>另有含义。</p><p>什么叫文本的开始？就是如果它是正则主体的第一个符号，那紧跟着它的字符必须是被匹配文本的第一个字符。</p><pre><code>&apos;regex&apos;.match(/^r/);// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码</code></pre><p>问题来了，如果<code>^</code>不是正则的第一个符号呢？</p><pre><code>&apos;regex&apos;.match(/a^r/);// null复制代码</code></pre><p>所以呀，关于它有三点需要注意：</p><ul><li>作为匹配文本开始元字符的时候必须是正则主体的第一个符号，否则正则无效。</li><li>它匹配的是一个位置，而不是具体的文本。</li><li>它在其他规则中有另外的含义。</li></ul><p><code>$</code>字符与<code>^</code>正好相反。它代表文本的结束，并且没有其他含义(其实是有的，但不是在正则主体内)。同样，它必须是正则主体的最后一个符号。</p><pre><code>&apos;regex&apos;.match(/x$/);// [&quot;x&quot;, index: 4, input: &quot;regex&quot;, groups: undefined]复制代码</code></pre><p><code>^</code>与<code>$</code>特殊的地方在于它匹配的是一个位置。位置不像字符，它看不见，所以更不容易理解。</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>我们现在已经知道<code>$</code>匹配文本的结束位置，它是元字符。但是如果我想匹配<code>$</code>本身呢？匹配一个美元符号的需求再常见不过了吧。所以我们得将它贬为庶民。</p><p><code>\</code>反斜杠就是干这个的。</p><pre><code>&apos;price: $3.6&apos;.match(/\$[0-9]+\.[0-9]+$/);// [&quot;$3.6&quot;, index: 7, input: &quot;price: $3.6&quot;, groups: undefined]复制代码</code></pre><p>上面的例子有点超纲了，超纲的部分先不管。</p><p>你可以认为<code>\</code>也是一个元字符，它跟在另一个元字符后面，就能还原它本来的含义。</p><p>如果有两个<code>\</code>呢？那就是转义自身了。如果有三个<code>\</code>呢？我们得分成两段去理解。以此类推。</p><p>普通字符前面跟了一个<code>\</code>是什么效果？首先它们是一个整体，然后普通字符转义后还是普通字符。</p><h2 id="带反斜杠的元字符"><a href="#带反斜杠的元字符" class="headerlink" title="带反斜杠的元字符"></a>带反斜杠的元字符</h2><p>一般来说，普通字符前面带反斜杠还是普通字符，但是有一些普通字符，带反斜杠后反而变成了元字符。</p><p>要怪只能怪计算机领域的常用符号太少了。<br>元字符含义\b匹配一个单词边界(boundary)\B匹配一个非单词边界\d匹配一个数字字符(digit)\D匹配一个非数字字符\s匹配一个空白字符(space)\S匹配一个非空白字符\w匹配一个字母或者一个数字或者一个下划线(word)\W匹配一个字母、数字和下划线之外的字符<br>你这么聪明，肯定一眼就看出来，大写代表反义。对，就是这么好记。</p><h4 id="b元字符"><a href="#b元字符" class="headerlink" title="\b元字符"></a>\b元字符</h4><p><code>\b</code>匹配的也是一个位置，而不是一个字符。单词和空格之间的位置，就是所谓单词边界。</p><pre><code>&apos;hello regex&apos;.match(/\bregex$/);// [&quot;regex&quot;, index: 6, input: &quot;hello regex&quot;, groups: undefined]&apos;hello regex&apos;.match(/\Bregex$/);// null复制代码</code></pre><p>所谓单词边界，对中文等其他语言是无效的。</p><pre><code>&apos;jiangshuying gaoyuanyuan huosiyan&apos;.match(/\bgaoyuanyuan\b/);// [&quot;gaoyuanyuan&quot;, index: 13, input: &quot;jiangshuying gaoyuanyuan huosiyan&quot;, groups: undefined]&apos;江疏影 高圆圆 霍思燕&apos;.match(/\b高圆圆\b/);// null复制代码</code></pre><p>所以<code>\b</code>翻译一下就是<code>^\w|\w$|\W\w|\w\W</code>。</p><h4 id="d元字符"><a href="#d元字符" class="headerlink" title="\d元字符"></a>\d元字符</h4><p><code>\d</code>匹配一个数字，注意，这里的数字不是指JavaScript中的数字类型，因为文本全是字符串。它指的是代表数字的字符。</p><pre><code>&apos;123&apos;.match(/\d/);// [&quot;1&quot;, index: 0, input: &quot;123&quot;, groups: undefined]复制代码</code></pre><h4 id="s元字符"><a href="#s元字符" class="headerlink" title="\s元字符"></a>\s元字符</h4><p><code>\s</code>匹配一个空白字符。</p><p>这里需要解释一下什么是空白字符。</p><p>空白字符不是空格，它是空格的超集。很多人说它是<code>\f\n\r\t\v</code>的总和，其中<code>\f</code>是换页符，<code>\n</code>是换行符，<code>\r</code>是回车符，<code>\t</code>是水平制表符，<code>\v</code>是垂直制表符。是这样么？</p><pre><code>&apos;a b&apos;.match(/\w\s\w/);// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]&apos;a b&apos;.match(/\w\f\w/);// null&apos;a b&apos;.match(/\w\n\w/);// null&apos;a b&apos;.match(/\w\r\w/);// null&apos;a b&apos;.match(/\w\t\w/);// null&apos;a b&apos;.match(/\w\v\w/);// null&apos;a b&apos;.match(/\w \w/);// [&quot;a b&quot;, index: 0, input: &quot;a b&quot;, groups: undefined]复制代码</code></pre><p>这样说的人，明显是没有做过实验。其实正确的写法是<code>空格\f\n\r\t\v</code>的总和，集合里面包含一个空格，可千万别忽略了。诶，难道空格在正则中的写法就是<code>空一格</code>么，是的，就是这样随意。</p><p>这个集合中很多都是不可打印字符，估计只有<code>\n</code>是我们的老朋友。所以，如果不需要区分空格和换行的话，那就大胆的用<code>\s</code>吧。</p><h4 id="w元字符"><a href="#w元字符" class="headerlink" title="\w元字符"></a>\w元字符</h4><p><code>\w</code>匹配一个字母或者一个数字或者一个下划线。为什么要将它们放一起？想一想JavaScript中的变量规则，包括很多应用的用户名都只能是这三样，所以把它们放一起挺方便的。</p><p>不过要注意，字母指的是26个英文字母，其他的不行。</p><pre><code>&apos;正则&apos;.match(/\w/);// null复制代码</code></pre><h4 id="负阴抱阳"><a href="#负阴抱阳" class="headerlink" title="负阴抱阳"></a>负阴抱阳</h4><p>如果我们将大写和小写的带反斜杠的元字符组合在一起，就能匹配任何字符。是的，不针对任何人。</p><pre><code>&apos;@regex&apos;.match(/[\s\S]/);// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码</code></pre><p>方括号的含义我们先按下不表。</p><h2 id="道生一"><a href="#道生一" class="headerlink" title="道生一"></a>道生一</h2><p><code>.</code>在正则中的含义仙风道骨，它匹配换行符之外的任意单个字符。</p><p>如果文本不存在换行符，那么<code>.</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p><p>如果文本存在换行符，那么<code>(.|\n)</code>和<code>[\b\B]</code>和<code>[\d\D]</code>和<code>[\s\S]</code>和<code>[\w\W]</code>是等价的。</p><pre><code>&apos;@regex&apos;.match(/./);// [&quot;@&quot;, index: 0, input: &quot;@regex&quot;, groups: undefined]复制代码</code></pre><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><p>前面我们一直在强调，一个元字符只匹配一个字符。即便强大如<code>.</code>它也只能匹配一个。</p><p>那匹配<code>gooooogle</code>的正则是不是得写成<code>/gooooogle/</code>呢？</p><p>正则冷笑，并向你发射一个蔑视。</p><p>如果匹配的模式有重复，我们可以声明它重复的次数。<br>量词含义?重复零次或者一次+重复一次或者多次，也就是至少一次*重复零次或者多次，也就是任意次数{n}重复n次{n,}重复n次或者更多次{n,m}重复n次到m次之间的次数，包含n次和m次<br>有三点需要注意：</p><ul><li><p><code>?</code>在诸如匹配http协议的时候非常有用，就像这样：<code>/http(s)?/</code>。它在正则中除了是量词还有别的含义，后面会提到。</p></li><li><p>我们习惯用<code>/.*/</code>来匹配若干对我们没有价值的文本，它的含义是<code>若干除换行符之外的字符</code>。比如我们需要文本两头的格式化信息，中间是什么无所谓，它就派上用场了。不过它的性能可不好。</p></li><li><p><code>{n,m}</code>之间不能有空格，空格在正则中是有含义的。</p></li></ul><p>关于量词最令人困惑的是：它重复什么？</p><p>它重复紧贴在它前面的某个集合。第一点，必须是紧贴在它前面；第二点，重复一个集合。最常见的集合就是一个字符，当然正则中有一些元字符能够将若干字符变成一个集合，后面会讲到。</p><pre><code>&apos;gooooogle&apos;.match(/go{2,5}gle/);// [&quot;gooooogle&quot;, index: 0, input: &quot;gooooogle&quot;, groups: undefined]复制代码</code></pre><p>如果一个量词紧贴在另一个量词后面会怎样？</p><pre><code>&apos;gooooogle&apos;.match(/go{2,5}+gle/);// Uncaught SyntaxError: Invalid regular expression: /go{2,5}+gle/: Nothing to repeat复制代码</code></pre><h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>前面提到量词不能紧跟在另一个量词后面，马上要👋👋打脸了。</p><pre><code>&apos;https&apos;.match(/http(s)?/);// [&quot;https&quot;, &quot;s&quot;, index: 0, input: &quot;https&quot;, groups: undefined]&apos;https&apos;.match(/http(s)??/);// [&quot;http&quot;, undefined, index: 0, input: &quot;https&quot;, groups: undefined]复制代码</code></pre><p>然而，我的脸是这么好打的？</p><p>紧跟在<code>?</code>后面的<code>?</code>它不是一个量词，而是一个模式切换符，从贪婪模式切换到非贪婪模式。</p><p>贪婪模式在正则中是默认的模式，就是在既定规则之下匹配尽可能多的文本。因为正则中有量词，它的重复次数可能是一个区间，这就有了取舍。</p><p>紧跟在量词之后加上<code>?</code>就可以开启非贪婪模式。怎么省事怎么来。</p><p>这里的要点是，<code>?</code>必须紧跟着量词，否则的话它自己就变成量词了。</p><h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>正则中的普通字符只能匹配它自己。如果我要匹配一个普通字符，但是我不确定它是什么，怎么办？</p><pre><code>&apos;grey or gray&apos;.match(/gr[ae]y/);// [&quot;grey&quot;, index: 0, input: &quot;grey or gray&quot;, groups: undefined]复制代码</code></pre><p>方括号在正则中表示一个区间，我们称它为字符组。</p><p>首先，字符组中的字符集合只是所有的可选项，最终它只能匹配一个字符。</p><p>然后，字符组是一个独立的世界，元字符不需要转义。</p><pre><code>&apos;$&apos;.match(/[$&amp;@]/);// [&quot;$&quot;, index: 0, input: &quot;$&quot;, groups: undefined]复制代码</code></pre><p>最后，有两个字符在字符组中有特殊含义。</p><p><code>^</code>在字符组中表示取反，不再是文本开始的位置了。</p><pre><code>&apos;regex&apos;.match(/[^abc]/);// [&quot;r&quot;, index: 0, input: &quot;regex&quot;, groups: undefined]复制代码</code></pre><p>如果我就要<code>^</code>呢？前面已经讲过了，转义。</p><p><code>-</code>本来是一个普通字符，在字符组中摇身一变成为连字符。</p><pre><code>&apos;13&apos;.match(/[1-9]3/);// [&quot;13&quot;, index: 0, input: &quot;13&quot;, groups: undefined]复制代码</code></pre><p>连字符的意思是匹配范围在它的左边字符和右边字符之间。</p><p>如果我这样呢？</p><pre><code>&apos;abc-3&apos;.match(/[0-z]/);// [&quot;a&quot;, index: 0, input: &quot;abc-3&quot;, groups: undefined]复制代码&apos;xyz-3&apos;.match(/[0-c]/);// [&quot;3&quot;, index: 4, input: &quot;xyz-3&quot;, groups: undefined]复制代码&apos;xyz-3&apos;.match(/[0-$]/);// Uncaught SyntaxError: Invalid regular expression: /[0-$]/: Range out of order in character class复制代码</code></pre><p>发现什么了没有？只有两种字符是可以用连字符的：英文字母和数字。而且英文字母可以和数字连起来，英文字母的顺序在后面。这和扑克牌<code>1 2 3 4 5 6 7 8 9 10 J Q K</code>是一个道理。</p><h2 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h2><p>我们已经知道量词是怎么回事了，我们也知道量词只能重复紧贴在它前面的字符。</p><p>如果我要重复的是一串字符呢？</p><pre><code>&apos;i love you very very very much&apos;.match(/i love you very +much/);// null&apos;i love you very very very much&apos;.match(/i love you v+e+r+y+ +much/);// null复制代码</code></pre><p>这样肯定是不行的。是时候请圆括号出山了。</p><pre><code>&apos;i love you very very very much&apos;.match(/i love you (very )+much/);// [&quot;i love you very very very much&quot;, &quot;very &quot;, index: 0, input: &quot;i love you very very very much&quot;, groups: undefined]复制代码</code></pre><p>圆括号的意思是将它其中的字符集合打包成一个整体，然后量词就可以操作这个整体了。这和方括号的效果是完全不一样的。</p><p>而且默认的，圆括号的匹配结果是可以捕获的。</p><h4 id="正则内捕获"><a href="#正则内捕获" class="headerlink" title="正则内捕获"></a>正则内捕获</h4><p>现在我们有一个需求，匹配<code>&lt;div&gt;</code>标签。</p><pre><code>&apos;&lt;div&gt;hello regex&lt;/div&gt;&apos;.match(/&lt;div&gt;.*&lt;\/div&gt;/);// [&quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, index: 0, input: &quot;&lt;div&gt;hello regex&lt;/div&gt;&quot;, groups: undefined]复制代码</code></pre><p>这很简单。但如果我要匹配的是任意标签，包括自定义的标签呢？</p><pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;([a-zA-Z]+)&gt;.*&lt;\/\1&gt;/);// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: undefined]复制代码</code></pre><p>这时候就要用到正则的捕获特性。正则内捕获使用<code>\数字</code>的形式，分别对应前面的圆括号捕获的内容。这种捕获的引用也叫<strong>反向引用</strong>。</p><p>我们来看一个更复杂的情况：</p><pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&apos;.match(/&lt;((A|a)pp)&gt;(hello regex)+&lt;\/\1&gt;&lt;p&gt;\2&lt;\/p&gt;&lt;p&gt;\3&lt;\/p&gt;/);// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, &quot;App&quot;, &quot;A&quot;, &quot;hello regex&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&lt;p&gt;A&lt;/p&gt;&lt;p&gt;hello regex&lt;/p&gt;&quot;, groups: undefined]复制代码</code></pre><p>如果有嵌套的圆括号，那么捕获的引用是先递归的，然后才是下一个顶级捕获。</p><h4 id="正则外捕获"><a href="#正则外捕获" class="headerlink" title="正则外捕获"></a>正则外捕获</h4><pre><code>&apos;@abc&apos;.match(/@(abc)/);// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]RegExp.$1;// &quot;abc&quot;复制代码</code></pre><p>没错，<code>RegExp</code>就是构造正则的构造函数。如果有捕获组，它的实例属性<code>$数字</code>会显示对应的引用。</p><p>如果有多个正则呢？</p><pre><code>&apos;@abc&apos;.match(/@(abc)/);// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@xyz&apos;.match(/@(xyz)/);// [&quot;@xyz&quot;, &quot;xyz&quot;, index: 0, input: &quot;@xyz&quot;, groups: undefined]RegExp.$1;// &quot;xyz&quot;复制代码</code></pre><p><code>RegExp</code>构造函数的引用只显示最后一个正则的捕获。</p><p>另外还有一个字符串实例方法也支持正则捕获的引用，它就是<code>replace</code>方法。</p><pre><code>&apos;hello **regex**&apos;.replace(/\*{2}(.*)\*{2}/, &apos;&lt;strong&gt;$1&lt;/strong&gt;&apos;);// &quot;hello &lt;strong&gt;regex&lt;/strong&gt;&quot;复制代码</code></pre><p>实际上它才是最常用的引用捕获的方式。</p><h4 id="捕获命名"><a href="#捕获命名" class="headerlink" title="捕获命名"></a>捕获命名</h4><blockquote><p>这是ES2018的新特性。</p></blockquote><p>使用<code>\数字</code>引用捕获必须保证捕获组的顺序不变。现在开发者可以给捕获组命名了，有了名字以后，引用起来更加确定。</p><pre><code>&apos;&lt;App&gt;hello regex&lt;/App&gt;&apos;.match(/&lt;(?&lt;tag&gt;[a-zA-Z]+)&gt;.*&lt;\/\k&lt;tag&gt;&gt;/);// [&quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, &quot;App&quot;, index: 0, input: &quot;&lt;App&gt;hello regex&lt;/App&gt;&quot;, groups: {tag: &quot;App&quot;}]复制代码</code></pre><p>在捕获组内部最前面加上<code>?&lt;key&gt;</code>，它就被命名了。使用<code>\k&lt;key&gt;</code>语法就可以引用已经命名的捕获组。</p><p>是不是很简单？</p><p>通常情况下，开发者只是想在正则中将某些字符当成一个整体看待。捕获组很棒，但是它做了额外的事情，肯定需要额外的内存占用和计算资源。于是正则又有了非捕获组的概念。</p><pre><code>&apos;@abc&apos;.match(/@(abc)/);// [&quot;@abc&quot;, &quot;abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]&apos;@abc&apos;.match(/@(?:abc)/);// [&quot;@abc&quot;, index: 0, input: &quot;@abc&quot;, groups: undefined]复制代码</code></pre><p>只要在圆括号内最前面加上<code>?:</code>标识，就是告诉正则引擎：我只要这个整体，不需要它的引用，你就别费劲了。从上面的例子也可以看出来，<code>match</code>方法返回的结果有些许不一样。</p><p>个人观点：我觉得正则的捕获设计应该反过来，默认不捕获，加上<code>?:</code>标识后才捕获。因为大多数时候开发者是不需要捕获的，但是它又懒得加<code>?:</code>标识，会有些许性能浪费。</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>有时候开发者需要在正则中使用<code>或者</code>。</p><pre><code>&apos;高圆圆&apos;.match(/陈乔恩|高圆圆/);// [&quot;高圆圆&quot;, index: 0, input: &quot;高圆圆&quot;, groups: undefined]复制代码</code></pre><p><code>|</code>就代表<code>或者</code>。字符组其实也是一个多选结构，但是它们俩有本质区别。字符组最终只能匹配一个字符，而分支匹配的是左边所有的字符或者右边所有的字符。</p><p>我们来看一个例子：</p><pre><code>&apos;我喜欢高圆圆&apos;.match(/我喜欢陈乔恩|高圆圆/);// [&quot;高圆圆&quot;, index: 3, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码</code></pre><p>因为<code>|</code>是将左右两边一切两半，然后匹配左边或者右边。所以上面的正则显然达不到我们想要的效果。这个时候就需要一个东西来缩小分支的范围。诶，你可能已经想到了：</p><pre><code>&apos;我喜欢高圆圆&apos;.match(/我喜欢(?:陈乔恩|高圆圆)/);// [&quot;我喜欢高圆圆&quot;, index: 0, input: &quot;我喜欢高圆圆&quot;, groups: undefined]复制代码</code></pre><p>没错，就是圆括号。</p><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>正则中有一些元字符，它不匹配字符，而是匹配一个位置。比如之前提到的<code>^</code>和<code>$</code>。<code>^</code>的意思是说这个位置应该是文本开始的位置。</p><p>正则还有一些比较高级的匹配位置的语法，它匹配的是：在这个位置之前或之后应该有什么内容。</p><p>零宽(zero-width)是什么意思？指的就是它匹配一个位置，本身没有宽度。</p><p>断言(assertion)是什么意思？指的是一种判断，断言之前或之后应该有什么或应该没有什么。</p><h4 id="零宽肯定先行断言"><a href="#零宽肯定先行断言" class="headerlink" title="零宽肯定先行断言"></a>零宽肯定先行断言</h4><p>所谓的肯定就是判断有什么，而不是判断没有什么。</p><p>而先行指的是向前看(lookahead)，断言的这个位置是为前面的规则服务的。</p><p>语法很简单：圆括号内最左边加上<code>?=</code>标识。</p><pre><code>&apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)/);// [&quot;Java&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码</code></pre><p>上面匹配的是四个字母，这四个字母要满足以下条件：紧跟着的应该是<code>Script</code>字符串，而且<code>Script</code>字符串应该是单词的结尾部分。</p><p>所以，零宽肯定先行断言的意思是：现在有一段正则语法，用这段语法去匹配给定的文本。但是，满足条件的文本不仅要匹配这段语法，紧跟着它的必须是一个位置，这个位置又必须满足一段正则语法。</p><p>说的再直白点，我要匹配一段文本，但是这段文本后面必须紧跟着另一段特定的文本。零宽肯定先行断言就是一个界碑，我要满足前面和后面所有的条件，但是我只要前面的文本。</p><p>我们来看另一种情况：</p><pre><code>&apos;CoffeeScript JavaScript javascript&apos;.match(/\b\w{4}(?=Script\b)\w+/);// [&quot;JavaScript&quot;, index: 13, input: &quot;CoffeeScript JavaScript javascript&quot;, groups: undefined]复制代码</code></pre><p>上面的例子更加直观，零宽肯定先行断言已经匹配过<code>Script</code>一次了，后面的<code>\w+</code>却还是能匹配<code>Script</code>成功，足以说明它的<code>零宽</code>特性。它为紧贴在它前面的规则服务，并且不影响后面的匹配规则。</p><h4 id="零宽肯定后行断言"><a href="#零宽肯定后行断言" class="headerlink" title="零宽肯定后行断言"></a>零宽肯定后行断言</h4><p>先行是向前看，那后行就是向后看(lookbehind)咯。</p><p>语法是圆括号内最左边加上<code>?&lt;=</code>标识。</p><pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍\S+/);// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码</code></pre><p>一个正则可以有多个断言：</p><pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)霍.+?(?=\s|$)/);// [&quot;霍思燕&quot;, index: 14, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码</code></pre><h4 id="零宽否定先行断言"><a href="#零宽否定先行断言" class="headerlink" title="零宽否定先行断言"></a>零宽否定先行断言</h4><p>肯定是判断有什么，否定就是判断没有什么咯。</p><p>语法是圆括号内最左边加上<code>?!</code>标识。</p><pre><code>&apos;TypeScript Perl JavaScript&apos;.match(/\b\w{4}(?!Script\b)/);// [&quot;Perl&quot;, index: 11, input: &quot;TypeScript Perl JavaScript&quot;, groups: undefined]复制代码</code></pre><h4 id="零宽否定后行断言"><a href="#零宽否定后行断言" class="headerlink" title="零宽否定后行断言"></a>零宽否定后行断言</h4><p>语法是圆括号最左边加上<code>?&lt;!</code>标识。</p><pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;!演员)霍\S+/);// [&quot;霍去病&quot;, index: 8, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]复制代码</code></pre><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>正则表达式除了主体语法，还有若干可选的模式修饰符。</p><p>写法就是将修饰符安插在正则主体的尾巴上。比如这样：<code>/abc/gi</code>。</p><h4 id="g修饰符"><a href="#g修饰符" class="headerlink" title="g修饰符"></a>g修饰符</h4><p><code>g</code>是<code>global</code>的缩写。默认情况下，正则从左向右匹配，只要匹配到了结果就会收工。<code>g</code>修饰符会开启全局匹配模式，找到所有匹配的结果。</p><pre><code>&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/);// [&quot;高圆圆&quot;, index: 2, input: &quot;演员高圆圆 将军霍去病 演员霍思燕&quot;, groups: undefined]&apos;演员高圆圆 将军霍去病 演员霍思燕&apos;.match(/(?&lt;=演员)\S+/g);// [&quot;高圆圆&quot;, &quot;霍思燕&quot;]复制代码</code></pre><h4 id="i修饰符"><a href="#i修饰符" class="headerlink" title="i修饰符"></a>i修饰符</h4><p><code>i</code>是<code>ignoreCase</code>的缩写。默认情况下，<code>/z/</code>是无法匹配<code>Z</code>的，所以我们有时候不得不这样写：<code>/[a-zA-Z]/</code>。<code>i</code>修饰符可以全局忽略大小写。</p><p>很多时候我们不在乎文本是大写、小写还是大小写混写，这个修饰符还是很有用的。</p><pre><code>&apos;javascript is great&apos;.match(/JavaScript/);// null&apos;javascript is great&apos;.match(/JavaScript/i);// [&quot;javascript&quot;, index: 0, input: &quot;javascript is great&quot;, groups: undefined]复制代码</code></pre><h4 id="m修饰符"><a href="#m修饰符" class="headerlink" title="m修饰符"></a>m修饰符</h4><p><code>m</code>是<code>multiline</code>的缩写。这个修饰符有特定起作用的场景：它要和<code>^</code>和<code>$</code>搭配起来使用。默认情况下，<code>^</code>和<code>$</code>匹配的是文本的开始和结束，加上<code>m</code>修饰符，它们的含义就变成了行的开始和结束。</p><pre><code>`abcxyz`.match(/xyz/);// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]`abcxyz`.match(/^xyz$/);// null`abcxyz`.match(/^xyz$/m);// [&quot;xyz&quot;, index: 5, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码</code></pre><h4 id="y修饰符"><a href="#y修饰符" class="headerlink" title="y修饰符"></a>y修饰符</h4><blockquote><p>这是ES2015的新特性。</p></blockquote><p><code>y</code>是<code>sticky</code>的缩写。<code>y</code>修饰符有和<code>g</code>修饰符重合的功能，它们都是全局匹配。所以重点在<code>sticky</code>上，怎么理解这个<code>粘连</code>呢？</p><p><code>g</code>修饰符不挑食，匹配完一个接着匹配下一个，对于文本的位置没有要求。但是<code>y</code>修饰符要求必须从文本的开始实施匹配，因为它会开启全局匹配，匹配到的文本的下一个字符就是下一次文本的开始。这就是所谓的粘连。</p><pre><code>&apos;a bag with a tag has a mag&apos;.match(/\wag/g);// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]&apos;a bag with a tag has a mag&apos;.match(/\wag/y);// null&apos;bagtagmag&apos;.match(/\wag/y);// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]&apos;bagtagmag&apos;.match(/\wag/gy);// [&quot;bag&quot;, &quot;tag&quot;, &quot;mag&quot;]复制代码</code></pre><p>有人肯定发现了猫腻：你不是说<code>y</code>修饰符是全局匹配么？看上面的例子，单独一个<code>y</code>修饰符用match方法怎么并不是全局匹配呢？</p><p>诶，这里说来就话长了。</p><p>长话短说呢，就涉及到<code>y</code>修饰符的本质是什么。它的本质有二：</p><ul><li>全局匹配(先别着急打我)。</li><li>从文本的<code>lastIndex</code>位置开始新的匹配。lastIndex是什么？它是正则表达式的一个属性，如果是全局匹配，它用来标注下一次匹配的起始点。这才是粘连的本质所在。</li></ul><p>不知道你们发现什么了没有：<strong>lastIndex是正则表达式的一个属性</strong>。而上面例子中的match方法是作用在字符串上的，都没有lastIndex属性，休怪人家工作不上心。</p><pre><code>const reg = /\wag/y;reg.exec(&apos;bagtagmag&apos;);// [&quot;bag&quot;, index: 0, input: &quot;bagtagmag&quot;, groups: undefined]reg.exec(&apos;bagtagmag&apos;);// [&quot;tag&quot;, index: 3, input: &quot;bagtagmag&quot;, groups: undefined]reg.exec(&apos;bagtagmag&apos;);// [&quot;mag&quot;, index: 6, input: &quot;bagtagmag&quot;, groups: undefined]复制代码</code></pre><p>咱们换成正则方法exec，多次执行，正则的lastIndex在变，匹配的结果也在变。全局匹配无疑了吧。</p><h4 id="s修饰符"><a href="#s修饰符" class="headerlink" title="s修饰符"></a>s修饰符</h4><blockquote><p>这是ES2018的新特性。</p></blockquote><p><code>s</code>不是<code>dotAll</code>的缩写。<code>s</code>修饰符要和<code>.</code>搭配使用，默认情况下，<code>.</code>匹配除了换行符之外的任意单个字符，然而它还没有强大到无所不能的地步，所以正则索性给它开个挂。</p><p><code>s</code>修饰符的作用就是让<code>.</code>可以匹配任意单个字符。</p><p><code>s</code>是<code>singleline</code>的缩写。</p><pre><code>`abcxyz`.match(/c.x/);// null`abcxyz`.match(/c.x/s);// [&quot;c↵x&quot;, index: 3, input: &quot;↵abc↵xyz↵&quot;, groups: undefined]复制代码</code></pre><h4 id="u修饰符"><a href="#u修饰符" class="headerlink" title="u修饰符"></a>u修饰符</h4><blockquote><p>这是ES2015的新特性。</p></blockquote><p><code>u</code>是<code>unicode</code>的缩写。有一些Unicode字符超过一个字节，正则就无法正确的识别它们。<code>u</code>修饰符就是用来处理这些不常见的情况的。</p><pre><code>&apos;𠮷&apos;.match(/^.$/);// null&apos;𠮷&apos;.match(/^.$/u);// [&quot;𠮷&quot;, index: 0, input: &quot;𠮷&quot;, groups: undefined]复制代码</code></pre><p><code>𠮷</code>念<code>jí</code>，与<code>吉</code>同义。</p><p>笔者对Unicode认识尚浅，这里不过多展开。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Regex </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端代码异常监控实战</title>
      <link href="/2016/09/16/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%88%98/"/>
      <url>/2016/09/16/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="把前端监控做到极致-掘金"><a href="#把前端监控做到极致-掘金" class="headerlink" title="把前端监控做到极致 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a52f138f265da3e5b32a41b" target="_blank" rel="noopener">把前端监控做到极致 - 掘金</a></h2><h2 id="线上压缩代码-定位错误-掘金"><a href="#线上压缩代码-定位错误-掘金" class="headerlink" title="线上压缩代码-定位错误 - 掘金"></a><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5a4f6886518825734216b352" target="_blank" rel="noopener">线上压缩代码-定位错误 - 掘金</a></h2><p>生产环境没有source-map文件，上报的错误都不好定位，这里实现一个简单的错误定位脚本</p><p>1、获取压缩代码错误信息（行数、列数、错误信息，错误文件）</p><h2 id="这里通过控制台看错误信息"><a href="#这里通过控制台看错误信息" class="headerlink" title="这里通过控制台看错误信息"></a>这里通过控制台看错误信息</h2><pre><code>window.addEventListener(&apos;error&apos;, function (e) {    console.debug(&apos;lineno: &apos;, e.lineno, &apos; colno: &apos;, e.colno)    console.debug(&apos;errorMessage:&apos;, e.message)    console.debug(&apos;errorFile:&apos;, e.filename)}, true)</code></pre><p>我们写一段错误的代码（single.vue的片段）</p><pre><code>method: {   test (option) {        const data = option.test        const dataTest = option.data.test        return data + dataTest    }}, created () {    // 设置异步错误的原因是，同步的错误会被vue捕获    setTimeout(() =&gt; {        this.test({          testOption: 1        })    }, 300)}</code></pre><p>在浏览器中运行，报错结果如下<br><img src="https://pic4.zhimg.com/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c3b8a3d91b6ee6040dbf18e06ec3431a_hd.jpg" alt=""></p><p>得到错误信息：</p><ul><li>错误行数：1</li><li>错误列数：59236</li><li>错误信息：cannot read property ‘test’ of undefined</li><li>错误文件：0.0a77f.js</li></ul><p>2、定位错误的node脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">## 安装依赖source-map</span><br><span class="line"></span><br><span class="line"> npm install source-map</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    node脚本如下（map/index.js）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> // 读取文件</span><br><span class="line">var fs = require(&apos;fs&apos;)</span><br><span class="line">// souceMap处理文件</span><br><span class="line">var SourceMapConsumer = require(&apos;source-map&apos;).SourceMapConsumer</span><br><span class="line">// 启动构建进程（已构建则不需要）</span><br><span class="line">var exec = require(&apos;child_process&apos;).exec</span><br><span class="line"></span><br><span class="line">var lineno = process.argv[2] || 0   // 第一个参数为行数</span><br><span class="line">var columnno = process.argv[3] || 0 // 第二个参数为列数</span><br><span class="line">var fileName = process.argv[4] || &apos;&apos; // 第三个参数为错误文件（错误文件名就好）</span><br><span class="line"></span><br><span class="line">// 构建有map的线上代码</span><br><span class="line">// node build onlineMap为构建命令</span><br><span class="line">exec(&apos;node build onlineMap&apos;, function () &#123;</span><br><span class="line"> // 读取错误文件的map文件</span><br><span class="line"> var consumer = new SourceMapConsumer(fs.readFileSync(&apos;./dist/&apos; + fileName + &apos;.map&apos;, &apos;utf8&apos;))</span><br><span class="line">  // 输出map的错误信息</span><br><span class="line">  console.log(consumer.originalPositionFor(&#123;</span><br><span class="line">    line: +lineno,      // +是为了转化为数字</span><br><span class="line">    column: +columnno</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line">`</span><br><span class="line"></span><br><span class="line">    运行node脚本</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"> node map 1 59236 0.0a77f.js</span><br></pre></td></tr></table></figure></p><blockquote><p>效果如下：</p></blockquote><p><img src="https://pic1.zhimg.com/v2-cf68e7b673405c90fe024bf48dfb42c7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-cf68e7b673405c90fe024bf48dfb42c7_hd.jpg" alt=""></p><p>结合控制台输出的信息，就可以定位到错误代码了</p><p>我们再来看一下，给代码开启source-map，看错误信息是否一致</p><p><img src="https://pic3.zhimg.com/v2-5319b431cef161a0a07ba46f8b0e6a02_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-5319b431cef161a0a07ba46f8b0e6a02_hd.jpg" alt=""><br>错误代码的位置定位是准确的，证明可行。</p><p>3、后续扩展思路</p><h2 id="目前实现的是比较简单的脚本，所以存在一些问题："><a href="#目前实现的是比较简单的脚本，所以存在一些问题：" class="headerlink" title="目前实现的是比较简单的脚本，所以存在一些问题："></a>目前实现的是比较简单的脚本，所以存在一些问题：</h2><ul><li>需要当前构建内容和线上是一致的</li><li>操作比较繁琐</li></ul><p>优化思路如下：</p><p><img src="https://pic4.zhimg.com/v2-a8b63ecc364c66c8bf4bbec9880f8c23_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a8b63ecc364c66c8bf4bbec9880f8c23_hd.jpg" alt=""></p><p>后续优化慢慢补充~</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在对公司的前端代码脚本错误进行排查，试图降低 JS Error 的错误量，结合自己之前的经验对这方面内容进行了实践并总结，下面就此谈谈我对前端代码异常监控的一些见解。</p><p>本文大致围绕下面几点展开讨论：</p><ol><li>JS 处理异常的方式</li><li>上报方式</li><li>异常监控上报常见问题</li></ol><h2 id="JS-异常处理"><a href="#JS-异常处理" class="headerlink" title="JS 异常处理"></a>JS 异常处理</h2><p>对于 Javascript 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。</p><ol><li>当前代码块将作为一个任务压入任务队列中，JS 线程会不断地从任务队列中提取任务执行。</li><li>当任务执行过程中出现异常，且异常没有捕获处理，则会一直沿着调用栈一层层向外抛出，最终终止当前任务的执行。</li><li><p>JS 线程会继续从任务队列中提取下一个任务继续执行。</p> <script>   error   console.log('永远不会执行'); </script> <script>   console.log('我继续执行') </script></li></ol><p><img src="https://pic2.zhimg.com/v2-7a136ce7674914bcd7b7f42986d0c5bc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7a136ce7674914bcd7b7f42986d0c5bc_hd.jpg" alt=""></p><p>在对脚本错误进行上报之前，我们需要对异常进行处理，程序需要先感知到脚本错误的发生，然后再谈异常上报。</p><p>脚本错误一般分为两种：语法错误，运行时错误。</p><p>下面就谈谈几种异常监控的处理方式：</p><h2 id="try-catch-异常处理"><a href="#try-catch-异常处理" class="headerlink" title="try-catch 异常处理"></a>try-catch 异常处理</h2><p>try-catch 在我们的代码中经常见到，通过给代码块进行 try-catch 进行包装后，当代码块发生出错时 catch 将能捕捉到错误的信息，页面也将可以继续执行。</p><p>但是 try-catch 处理异常的能力有限，只能捕获捉到运行时非异步错误，对于语法错误和异步错误就显得无能为力，捕捉不到。</p><h2 id="示例：运行时错误"><a href="#示例：运行时错误" class="headerlink" title="示例：运行时错误"></a>示例：运行时错误</h2><pre><code>try {  error    // 未定义变量 } catch(e) {  console.log(&apos;我知道错误了&apos;);  console.log(e);}</code></pre><p><img src="https://pic3.zhimg.com/v2-dc8ba7e4b9e56127799c11b46cf7068d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-dc8ba7e4b9e56127799c11b46cf7068d_hd.jpg" alt=""></p><p>然而对于语法错误和异步错误就捕捉不到了。</p><h2 id="示例：语法错误"><a href="#示例：语法错误" class="headerlink" title="示例：语法错误"></a>示例：语法错误</h2><pre><code>try {  var error = &apos;error&apos;；   // 大写分号} catch(e) {  console.log(&apos;我感知不到错误&apos;);  console.log(e);}</code></pre><p><img src="https://pic3.zhimg.com/v2-8ddf6acf0f42c4b08ba8b73798b863a0_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8ddf6acf0f42c4b08ba8b73798b863a0_hd.jpg" alt=""></p><p>一般语法错误在编辑器就会体现出来，常表现的错误信息为： Uncaught SyntaxError: Invalid or unexpected token xxx 这样。但是这种错误会直接抛出异常，常使程序崩溃，一般在编码时候容易观察得到。</p><h2 id="示例：异步错误"><a href="#示例：异步错误" class="headerlink" title="示例：异步错误"></a>示例：异步错误</h2><pre><code>try {  setTimeout(() =&gt; {    error        // 异步错误  })} catch(e) {  console.log(&apos;我感知不到错误&apos;);  console.log(e);}</code></pre><p><img src="https://pic4.zhimg.com/v2-0ed67a00e3c7762e74975bebbbc88274_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-0ed67a00e3c7762e74975bebbbc88274_hd.jpg" alt=""></p><p>除非你在 setTimeout 函数中再套上一层 try-catch，否则就无法感知到其错误，但这样代码写起来比较啰嗦。</p><h2 id="window-onerror-异常处理"><a href="#window-onerror-异常处理" class="headerlink" title="window.onerror 异常处理"></a>window.onerror 异常处理</h2><p>window.onerror 捕获异常能力比 try-catch 稍微强点，无论是异步还是非异步错误，onerror 都能捕获到运行时错误。</p><p>示例：运行时同步错误</p><pre><code>/** * @param {String}  msg    错误信息 * @param {String}  url    出错文件 * @param {Number}  row    行号 * @param {Number}  col    列号 * @param {Object}  error  错误详细信息 */ window.onerror = function (msg, url, row, col, error) {  console.log(&apos;我知道错误了&apos;);  console.log({    msg,  url,  row, col, error  })  return true;};error;</code></pre><p>示例：异步错误</p><pre><code>window.onerror = function (msg, url, row, col, error) {  console.log(&apos;我知道异步错误了&apos;);  console.log({    msg,  url,  row, col, error  })  return true;};setTimeout(() =&gt; {  error;});</code></pre><p><img src="https://pic3.zhimg.com/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-8bfdbb4ef72e1fe0ee29f42708d1184d_hd.jpg" alt=""></p><p>然而 window.onerror 对于语法错误还是无能为力，所以我们在写代码的时候要尽可能避免语法错误的，不过一般这样的错误会使得整个页面崩溃，还是比较容易能够察觉到的。</p><p>在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p><p>需要注意的是，window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx。</p><p><img src="https://pic3.zhimg.com/v2-875235a4876ea8429f12e7aaf2f19588_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-875235a4876ea8429f12e7aaf2f19588_hd.jpg" alt=""></p><p>关于 window.onerror 还有两点需要值得注意</p><ol><li>对于 onerror 这种全局捕获，最好写在所有 JS 脚本的前面，因为你无法保证你写的代码是否出错，如果写在后面，一旦发生错误的话是不会被 onerror 捕获到的。</li><li>另外 onerror 是无法捕获到网络异常的错误。</li></ol><p>当我们遇到 <code>&lt;img src=&quot;./404.png&quot;&gt;</code> 报 404 网络请求异常的时候，onerror 是无法帮助我们捕获到异常的。</p><pre><code>&lt;script&gt;  window.onerror = function (msg, url, row, col, error) {    console.log(&apos;我知道异步错误了&apos;);    console.log({      msg,  url,  row, col, error    })    return true;  };&lt;/script&gt;&lt;img src=&quot;./404.png&quot;&gt;</code></pre><p><img src="https://pic3.zhimg.com/v2-81341c443f078b6526e0c6031dd40953_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-81341c443f078b6526e0c6031dd40953_hd.jpg" alt=""></p><p>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p><pre><code>&lt;script&gt;window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {  console.log(&apos;我知道 404 错误了&apos;);  console.log(    msg, url, row, col, error  );  return true;}, true);&lt;/script&gt;&lt;img src=&quot;./404.png&quot; alt=&quot;&quot;&gt;</code></pre><p><img src="https://pic4.zhimg.com/v2-6d1c1196acd800a4a4475ee6847ee82a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6d1c1196acd800a4a4475ee6847ee82a_hd.jpg" alt=""></p><p>这点知识还是需要知道，要不然用户访问网站，图片 CDN 无法服务，图片加载不出来而开发人员没有察觉就尴尬了。</p><h2 id="Promise-错误"><a href="#Promise-错误" class="headerlink" title="Promise 错误"></a>Promise 错误</h2><p>通过 Promise 可以帮助我们解决异步回调地狱的问题，但是一旦 Promise 实例抛出异常而你没有用 catch 去捕获的话，onerror 或 try-catch 也无能为力，无法捕捉到错误。</p><pre><code>window.addEventListener(&apos;error&apos;, (msg, url, row, col, error) =&gt; {  console.log(&apos;我感知不到 promise 错误&apos;);  console.log(    msg, url, row, col, error  );}, true);Promise.reject(&apos;promise error&apos;);new Promise((resolve, reject) =&gt; {  reject(&apos;promise error&apos;);});new Promise((resolve) =&gt; {  resolve();}).then(() =&gt; {  throw &apos;promise error&apos;});</code></pre><p><img src="https://pic4.zhimg.com/v2-1ce580bb2344474b1df1517f2d11aa40_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-1ce580bb2344474b1df1517f2d11aa40_hd.jpg" alt=""></p><p>虽然在写 Promise 实例的时候养成最后写上 catch 函数是个好习惯，但是代码写多了就容易糊涂，忘记写 catch。</p><p>所以如果你的应用用到很多的 Promise 实例的话，特别是你在一些基于 promise 的异步库比如 axios 等一定要小心，因为你不知道什么时候这些异步请求会抛出异常而你并没有处理它，所以你最好添加一个 Promise 全局异常捕获事件 <strong>unhandledrejection</strong>。</p><pre><code>window.addEventListener(&quot;unhandledrejection&quot;, function(e){  e.preventDefault()  console.log(&apos;我知道 promise 的错误了&apos;);  console.log(e.reason);  return true;});Promise.reject(&apos;promise error&apos;);new Promise((resolve, reject) =&gt; {  reject(&apos;promise error&apos;);});new Promise((resolve) =&gt; {  resolve();}).then(() =&gt; {  throw &apos;promise error&apos;});</code></pre><p><img src="https://pic2.zhimg.com/v2-115d494f26e4f8e2172e1f3b4cb6094f_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-115d494f26e4f8e2172e1f3b4cb6094f_hd.jpg" alt=""></p><p>当然，如果你的应用没有做 Promise 全局异常处理的话，那很可能就像某乎首页这样：</p><p><img src="https://pic2.zhimg.com/v2-37c6bc3763c147a4c97bdde688a59a5c_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-37c6bc3763c147a4c97bdde688a59a5c_hd.jpg" alt=""></p><h2 id="异常上报方式"><a href="#异常上报方式" class="headerlink" title="异常上报方式"></a>异常上报方式</h2><p>监控拿到报错信息之后，接下来就需要将捕捉到的错误信息发送到信息收集平台上，常用的发送形式主要有两种:</p><ol><li>通过 Ajax 发送数据</li><li>动态创建 img 标签的形式</li></ol><p>实例 - 动态创建 img 标签进行上报</p><pre><code>function report(error) {  var reportUrl = &apos;http://xxxx/report&apos;;  new Image().src = reportUrl + &apos;error=&apos; + error;}</code></pre><h2 id="监控上报常见问题"><a href="#监控上报常见问题" class="headerlink" title="监控上报常见问题"></a>监控上报常见问题</h2><p>下述例子我全部放在我的 github 上，读者可以自行查阅，后面不再赘述。</p><pre><code>git clone https://github.com/happylindz/blog.gitcd blog/code/jserror/npm install</code></pre><h2 id="Script-error-脚本错误是什么"><a href="#Script-error-脚本错误是什么" class="headerlink" title="Script error 脚本错误是什么"></a>Script error 脚本错误是什么</h2><p>因为我们在线上的版本，经常做静态资源 CDN 化，这就会导致我们常访问的页面跟脚本文件来自不同的域名，这时候如果没有进行额外的配置，就会容易产生 Script error。</p><p><img src="https://pic3.zhimg.com/v2-840f71bf7014767132b47ad2c6a37238_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-840f71bf7014767132b47ad2c6a37238_hd.jpg" alt=""></p><p>可通过 <code>npm run nocors</code> 查看效果。</p><p>Script error 是浏览器在同源策略限制下产生的，浏览器处于对安全性上的考虑，当页面引用非同域名外部脚本文件时中抛出异常的话，此时本页面是没有权利知道这个报错信息的，取而代之的是输出 Script error 这样的信息。</p><p><img src="https://pic2.zhimg.com/v2-fc3941d89716f96374576d0426ff4ccb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-fc3941d89716f96374576d0426ff4ccb_hd.jpg" alt=""></p><p>这样做的目的是避免数据泄露到不安全的域中，举个简单的例子，</p><pre><code>&lt;script src=&quot;xxxx.com/login.html&quot;&gt;&lt;/script&gt;</code></pre><p>上面我们并没有引入一个 js 文件，而是一个 html，这个 html 是银行的登录页面，如果你已经登录了，那 login 页面就会自动跳转到 <code>Welcome xxx...</code>，如果未登录则跳转到 <code>Please Login...</code>，那么报错也会是 <code>Welcome xxx... is not defined，Please Login... is not defined</code>，通过这些信息可以判断一个用户是否登录他的帐号，给入侵者提供了十分便利的判断渠道，这是相当不安全的。</p><p>介绍完背景后，那么我们应该去解决这个问题？</p><p>首先可以想到的方案肯定是同源化策略，将 JS 文件内联到 html 或者放到同域下，虽然能简单有效地解决 script error 问题，但是这样无法利用好文件缓存和 CDN 的优势，不推荐使用。正确的方法应该是从根本上解决 script error 的错误。</p><h2 id="跨源资源共享机制-CORS"><a href="#跨源资源共享机制-CORS" class="headerlink" title="跨源资源共享机制( CORS )"></a>跨源资源共享机制( CORS )</h2><p>首先为页面上的 script 标签添加 crossOrigin 属性</p><pre><code>// http://localhost:8080/index.html&lt;script&gt;  window.onerror = function (msg, url, row, col, error) {    console.log(&apos;我知道错误了，也知道错误信息&apos;);    console.log({      msg,  url,  row, col, error    })    return true;  };&lt;/script&gt;&lt;script src=&quot;http://localhost:8081/test.js&quot; crossorigin&gt;&lt;/script&gt;// http://localhost:8081/test.jssetTimeout(() =&gt; {  console.log(error);});</code></pre><p>当你修改完前端代码后，你还需要额外给后端在响应头里加上 <code>Access-Control-Allow-Origin: localhost:8080</code>，这里我以 Koa 为例。</p><pre><code>const Koa = require(&apos;koa&apos;);const path = require(&apos;path&apos;);const cors = require(&apos;koa-cors&apos;);const app = new Koa();app.use(cors());app.use(require(&apos;koa-static&apos;)(path.resolve(__dirname, &apos;./public&apos;)));app.listen(8081, () =&gt; {  console.log(&apos;koa app listening at 8081&apos;)});</code></pre><p><img src="https://pic1.zhimg.com/v2-9717062e56340cef40ee67b438b2ba95_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-9717062e56340cef40ee67b438b2ba95_hd.jpg" alt=""></p><p>读者可通过 <code>npm run cors</code> 详细的跨域知识我就不展开了，有兴趣可以看看我之前写的文章：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p><p>你以为这样就完了吗？并没有，下面就说一些 Script error 你不常遇见的点：</p><p>我们都知道 JSONP 是用来跨域获取数据的，并且兼容性良好，在一些应用中仍然会使用到，所以你的项目中可能会用这样的代码：</p><pre><code>// http://localhost:8080/index.htmlwindow.onerror = function (msg, url, row, col, error) {  console.log(&apos;我知道错误了，但不知道错误信息&apos;);  console.log({    msg,  url,  row, col, error  })  return true;};function jsonpCallback(data) {  console.log(data);}const url = &apos;http://localhost:8081/data?callback=jsonpCallback&apos;;const script = document.createElement(&apos;script&apos;);script.src = url;document.body.appendChild(script);</code></pre><p>因为返回的信息会当做脚本文件来执行，一旦返回的脚本内容出错了，也是无法捕捉到错误的信息。</p><p><img src="https://pic4.zhimg.com/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-01afbf8a4ba1fc4fdd9a22b884f9a8d8_hd.jpg" alt=""></p><p>解决办法也不难，跟之前一样，在添加动态添加脚本的时候加上 crossOrigin，并且在后端配上相应的 CORS 字段即可.</p><pre><code>const script = document.createElement(&apos;script&apos;);script.crossOrigin = &apos;anonymous&apos;;script.src = url;document.body.appendChild(script);</code></pre><p>读者可以通过 <code>npm run jsonp</code> 查看效果</p><p><img src="https://pic4.zhimg.com/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-ab0b67a7e6b5afabf281b792ca2d6bd2_hd.jpg" alt=""></p><p>知道原理之后你可能会觉得没什么，不就是给每个动态生成的脚本添加 crossOrigin 字段嘛，但是在实际工程中，你可能是面向很多库来编程，比如使用 jQuery，Seajs 或者 webpack 来异步加载脚本，许多库封装了异步加载脚本的能力，以 jQeury 为例你可能是这样来触发异步脚本。</p><pre><code>$.ajax({  url: &apos;http://localhost:8081/data&apos;,  dataType: &apos;jsonp&apos;,  success: (data) =&gt; {    console.log(data);  }})</code></pre><p>假如这些库中没有提供 crossOrigin 的能力的话(jQuery jsonp 可能有，假装你不知道)，那你只能去修改人家写的源代码了，所以我这里提供一个思路，就是去劫持 document.createElement，从根源上去为每个动态生成的脚本添加 crossOrigin 字段。</p><pre><code>document.createElement = (function() {  const fn = document.createElement.bind(document);  return function(type) {    const result = fn(type);    if(type === &apos;script&apos;) {      result.crossOrigin = &apos;anonymous&apos;;    }    return result;  }})();window.onerror = function (msg, url, row, col, error) {  console.log(&apos;我知道错误了，也知道错误信息&apos;);  console.log({    msg,  url,  row, col, error  })  return true;};$.ajax({  url: &apos;http://localhost:8081/data&apos;,  dataType: &apos;jsonp&apos;,  success: (data) =&gt; {    console.log(data);  }})</code></pre><p>效果也是一样的，读者可以通过 <code>npm run jsonpjq</code> 来查看效果：</p><p><img src="https://pic4.zhimg.com/v2-30d51a96cdb3286edd1e5a88e9f794bb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-30d51a96cdb3286edd1e5a88e9f794bb_hd.jpg" alt=""></p><p>这样重写 createElement 理论上没什么问题，但是入侵了原本的代码，不保证一定不会出错，在工程上还是需要多尝试下看看再使用，可能存在兼容性上问题，如果你觉得会出现什么问题的话也欢迎留言讨论下。</p><p>关于 Script error 的问题就写到这里，如果你理解了上面的内容，基本上绝大部分的 Script error 都能迎刃而解。</p><h2 id="window-onerror-能否捕获-iframe-的错误"><a href="#window-onerror-能否捕获-iframe-的错误" class="headerlink" title="window.onerror 能否捕获 iframe 的错误"></a>window.onerror 能否捕获 iframe 的错误</h2><p>当你的页面有使用 iframe 的时候，你需要对你引入的 iframe 做异常监控的处理，否则一旦你引入的 iframe 页面出现了问题，你的主站显示不出来，而你却浑然不知。</p><p>首先需要强调，父窗口直接使用 window.onerror 是无法直接捕获，如果你想要捕获 iframe 的异常的话，有分好几种情况。</p><p>如果你的 iframe 页面和你的主站是同域名的话，直接给 iframe 添加 onerror 事件即可。</p><pre><code>&lt;iframe src=&quot;./iframe.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;script&gt;  window.frames[0].onerror = function (msg, url, row, col, error) {    console.log(&apos;我知道 iframe 的错误了，也知道错误信息&apos;);    console.log({      msg,  url,  row, col, error    })    return true;  };&lt;/script&gt;</code></pre><p>读者可以通过 <code>npm run iframe</code> 查看效果：</p><p><img src="https://pic2.zhimg.com/v2-3edcb5686e27ab11f5f3c9c1644986d0_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-3edcb5686e27ab11f5f3c9c1644986d0_hd.jpg" alt=""></p><p>如果你嵌入的 iframe 页面和你的主站不是同个域名的，但是 iframe 内容不属于第三方，是你可以控制的，那么可以通过与 iframe 通信的方式将异常信息抛给主站接收。与 iframe 通信的方式有很多，常用的如：postMessage，hash 或者 name 字段跨域等等，这里就不展开了，感兴趣的话可以看：<a href="https://link.zhihu.com/?target=https%3A//github.com/happylindz/blog/issues/3" target="_blank" rel="noopener">跨域，你需要知道的全在这里</a></p><p>如果是非同域且网站不受自己控制的话，除了通过控制台看到详细的错误信息外，没办法捕获，这是出于安全性的考虑，你引入了一个百度首页，人家页面报出的错误凭啥让你去监控呢，这会引出很多安全性的问题。</p><h2 id="压缩代码如何定位到脚本异常位置"><a href="#压缩代码如何定位到脚本异常位置" class="headerlink" title="压缩代码如何定位到脚本异常位置"></a>压缩代码如何定位到脚本异常位置</h2><p>线上的代码几乎都经过了压缩处理，几十个文件打包成了一个并丑化代码，当我们收到 <code>a is not defined</code> 的时候，我们根本不知道这个变量 a 究竟是什么含义，此时报错的错误日志显然是无效的。</p><p>第一想到的办法是利用 sourcemap 定位到错误代码的具体位置，详细内容可以参考：<a href="https://link.zhihu.com/?target=https%3A//github.com/joeyguo/blog/issues/14" target="_blank" rel="noopener">Sourcemap 定位脚本错误</a></p><p>另外也可以通过在打包的时候，在每个合并的文件之间添加几行空格，并相应加上一些注释，这样在定位问题的时候很容易可以知道是哪个文件报的错误，然后再通过一些关键词的搜索，可以快速地定位到问题的所在位置。</p><h2 id="收集异常信息量太多，怎么办"><a href="#收集异常信息量太多，怎么办" class="headerlink" title="收集异常信息量太多，怎么办"></a>收集异常信息量太多，怎么办</h2><p>如果你的网站访问量很大，假如网页的 PV 有 1kw，那么一个必然的错误发送的信息就有 1kw 条，我们可以给网站设置一个采集率：</p><pre><code>Reporter.send = function(data) {  // 只采集 30%  if(Math.random() &lt; 0.3) {    send(data)      // 上报错误信息  }}</code></pre><p>这个采集率可以通过具体实际的情况来设定，方法多样化，可以使用一个随机数，也可以具体根据用户的某些特征来进行判定。</p><h3 id="错误上报的方法："><a href="#错误上报的方法：" class="headerlink" title="错误上报的方法："></a>错误上报的方法：</h3><ul><li>一：Ajax上传，Ajax上报就是在上文注释错误捕获的地方发起Ajax请求，来向服务器发送错误信息。</li><li>二：利用Image对象发送信息(new Image()).src=”<a href="http://post.error.com?data=xxx&quot;" target="_blank" rel="noopener">http://post.error.com?data=xxx&quot;</a></li><li>跨域js文件错误是否可以捕获：<br>   答案是可以，错误提示是   script error<br>解决办法，跨域js文件获取是有限制的，如果想获取其他域下的js错误需要在script标签里添加crossorigin属性，然后服务器端要设置header(‘Access-Control-Allow-Origin: *’),或者 指定域名。</li></ul><p>上面差不多是我对前端代码监控的一些理解，说起来容易，但是一旦在工程化运用，难免需要考虑到兼容性等种种问题，读者可以通过自己的具体情况进行调整，前端代码异常监控对于我们的网站的稳定性起着至关重要的作用。如若文中所有不对的地方，还望指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 错误监控 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript函数柯里化</title>
      <link href="/2016/08/14/JavaScript%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
      <url>/2016/08/14/JavaScript%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h2><h2 id="官方的说法"><a href="#官方的说法" class="headerlink" title="官方的说法"></a>官方的说法</h2><p>在计算机科学中，<a href="http://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%259F%25AF%25E9%2587%258C%25E5%258C%2596" target="_blank" rel="noopener">柯里化</a>（英语：<code>Currying</code>），又译为<code>卡瑞化</code>或<code>加里化</code>，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。这个技术由<code>克里斯托弗·斯特雷奇</code>以逻辑学家<code>哈斯凯尔·加里</code>命名的，尽管它是<code>Moses Schönfinkel</code>和<code>戈特洛布·弗雷格发明的</code>。</p><p>在直觉上，柯里化声称如果你固定某些参数，你将得到接受余下参数的一个函数。</p><p>在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的<code>lambda</code>演算中，研究带有多个参数的函数的方式。</p><p>函数柯里化的对偶是<code>Uncurrying</code>，一种使用匿名单参数函数来实现多参数函数的方法。</p><h2 id="方便的理解"><a href="#方便的理解" class="headerlink" title="方便的理解"></a>方便的理解</h2><blockquote><p>Currying概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。</p></blockquote><p>如果我们需要实现一个求三个数之和的函数：</p><pre><code>function add(x, y, z) {  return x + y + z;}console.log(add(1, 2, 3)); // 6var add = function(x) {  return function(y) {    return function(z) {      return x + y + z;    }  }}var addOne = add(1);var addOneAndTwo = addOne(2);var addOneAndTwoAndThree = addOneAndTwo(3);console.log(addOneAndTwoAndThree);</code></pre><p>这里我们定义了一个<code>add</code>函数，它接受一个参数并返回一个新的函数。调用<code>add</code>之后，返回的函数就通过闭包的方式记住了<code>add</code>的第一个参数。一次性地调用它实在是有点繁琐，好在我们可以使用一个特殊的<code>curry</code>帮助函数（<code>helper function</code>）使这类函数的定义和调用更加容易。</p><p>用<code>ES6</code>的箭头函数，我们可以将上面的<code>add</code>实现成这样：</p><pre><code>const add = x =&gt; y =&gt; z =&gt; x + y + z;</code></pre><p>好像使用箭头函数更清晰了许多。</p><h2 id="偏函数？"><a href="#偏函数？" class="headerlink" title="偏函数？"></a>偏函数？</h2><p>来看这个函数：</p><pre><code>function ajax(url, data, callback) {  // ..}</code></pre><p>有这样的一个场景：我们需要对多个不同的接口发起<code>HTTP</code>请求，有下列两种做法：</p><ul><li>在调用<code>ajax()</code>函数时，传入全局<code>URL</code>常量。</li><li>创建一个已经预设<code>URL</code>实参的函数引用。</li></ul><p>下面我们创建一个新函数，其内部仍然发起<code>ajax()</code>请求，此外在等待接收另外两个实参的同时，我们手动将<code>ajax()</code>第一个实参设置成你关心的<code>API</code>地址。</p><p>对于第一种做法，我们可能产生如下调用方式：</p><pre><code>function ajaxTest1(data, callback) {  ajax(&apos;http://www.test.com/test1&apos;, data, callback);}function ajaxTest2(data, callback) {  ajax(&apos;http://www.test.com/test2&apos;, data, callback);}</code></pre><p>对于这两个类似的函数，我们还可以提取出如下的模式：</p><pre><code>function beginTest(callback) {  ajaxTest1({    data: GLOBAL_TEST_1,  }, callback);}</code></pre><p>相信您已经看到了这样的模式：我们在函数调用现场（<code>function call-site</code>），将实参应用（<code>apply</code>） 于形参。如你所见，我们一开始仅应用了部分实参 —— 具体是将实参应用到<code>URL</code>形参 —— 剩下的实参稍后再应用。</p><p>上述概念即为偏函数的定义，偏函数一个减少函数参数个数的过程；这里的参数个数指的是希望传入的形参的数量。我们通过<code>ajaxTest1()</code>把原函数<code>ajax()</code>的参数个数从<code>3</code>个减少到了<code>2</code>个。</p><p>我们这样定义一个<code>partial()</code>函数：</p><pre><code>function partial(fn, ...presetArgs) {  return function partiallyApplied(...laterArgs) {    return fn(...presetArgs, ...laterArgs);  }}</code></pre><p><code>partial()</code>函数接收<code>fn</code>参数，来表示被我们偏应用实参（<code>partially apply</code>）的函数。接着，<code>fn</code>形参之后，<code>presetArgs</code>数组收集了后面传入的实参，保存起来稍后使用。</p><p>我们创建并<code>return</code>了一个新的内部函数（为了清晰明了，我们把它命名为<code>partiallyApplied(..)</code>），该函数中，<code>laterArgs</code>数组收集了全部实参。</p><p>使用箭头函数，则更为简洁：</p><pre><code>var partial =  (fn, ...presetArgs) =&gt;    (...laterArgs) =&gt;      fn(...presetArgs, ...laterArgs);</code></pre><p>使用偏函数的这种模式，我们重构之前的代码：</p><pre><code>function ajax(url, data, callback) {  // ..}var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);var ajaxTest2 = partial(ajax, &apos;http://www.test.com/test1&apos;);</code></pre><p>再次思考<code>beginTest()</code>函数，我们使用<code>partial()</code>来重构它应该怎么做呢？</p><pre><code>function ajax(url, data, callback) {  // ..}// 版本1var beginTest = partial(ajax, &apos;http://www.test.com/test1&apos;, {  data: GLOBAL_TEST_1,});// 版本2var ajaxTest1 = partial(ajax, &apos;http://www.test.com/test1&apos;);var beginTest = partial(ajaxTest1, {  data: GLOBAL_TEST_1,});</code></pre><h2 id="一次传一个"><a href="#一次传一个" class="headerlink" title="一次传一个"></a>一次传一个</h2><p>相信你已经在上述例子中看到了版本2比起版本1的优势所在了，没错，柯里化就是：将一个带有多个参数的函数转换为一次一个的函数的过程。每次调用函数时，它只接受一个参数，并返回一个函数，直到传递所有参数为止。</p><blockquote><p>The process of converting a function that takes multiple arguments into a function that takes them one at a time.</p><p>Each time the function is called it only accepts one argument and returns a function that takes one argument until all arguments are passed.</p></blockquote><p>假设我们已经创建了一个柯里化版本的<code>ajax()</code>函数<code>curriedAjax()</code>：</p><pre><code>curriedAjax(&apos;http://www.test.com/test1&apos;)  ({    data: GLOBAL_TEST_1,  })  (function callback(data) {    // dosomething  });</code></pre><p>我们将三次调用分别拆解开来，这也许有助于我们理解整个过程：</p><pre><code>var ajaxTest1 = curriedAjax(&apos;http://www.test.com/test1&apos;);var beginTest = ajaxTest1({  data: GLOBAL_TEST_1,});var ajaxCallback = beginTest(function callback(data) {  // dosomething});</code></pre><h2 id="实现柯里化"><a href="#实现柯里化" class="headerlink" title="实现柯里化"></a>实现柯里化</h2><p>那么，我们如何来实现一个自动的柯里化的函数呢？</p><pre><code>var currying = function(fn) {  var args = [];  return function() {    if (arguments.length === 0) {      return fn.apply(this, args); // 没传参数时，调用这个函数    } else {      [].push.apply(args, arguments); // 传入了参数，把参数保存下来      return arguments.callee; // 返回这个函数的引用    }  }}</code></pre><p>调用上述<code>currying()</code>函数：</p><pre><code>var cost = (function() {  var money = 0;  return function() {    for (var i = 0; i &lt; arguments.length; i++) {      money += arguments[i];    }    return money;  }})();var cost = currying(cost);cost(100); // 传入了参数，不真正求值cost(200); // 传入了参数，不真正求值cost(300); // 传入了参数，不真正求值console.log(cost()); // 求值并且输出600</code></pre><p>上述函数是我之前的<a href="http://link.zhihu.com/?target=https%3A//github.com/xingbofeng/JavaScript-design-patterns/blob/master/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0/ch3-%25E9%2597%25AD%25E5%258C%2585%25E5%2592%258C%25E9%25AB%2598%25E9%2598%25B6%25E5%2587%25BD%25E6%2595%25B0.md%23currying" target="_blank" rel="noopener">JavaScript设计模式与开发实践读书笔记之闭包与高阶函数</a>所写的<code>currying</code>版本，现在仔细思考后发现仍旧有一些问题。</p><blockquote><p>我们在使用柯里化时，要注意同时为函数预传的参数的情况。</p></blockquote><p>因此把上述柯里化函数更改如下：</p><pre><code>var currying = function(fn) {  var args = Array.prototype.slice.call(arguments, 1);  return function() {    if (arguments.length === 0) {      return fn.apply(this, args); // 没传参数时，调用这个函数    } else {      [].push.apply(args, arguments); // 传入了参数，把参数保存下来      return arguments.callee; // 返回这个函数的引用    }  }}</code></pre><p>使用实例：</p><pre><code>var cost = (function() {  var money = 0;  return function() {    for (var i = 0; i &lt; arguments.length; i++) {      money += arguments[i];    }    return money;  }})();var cost = currying(cost, 100);cost(200); // 传入了参数，不真正求值cost(300); // 传入了参数，不真正求值console.log(cost()); // 求值并且输出600</code></pre><p>你可能会觉得每次都要在最后调用一下不带参数的<code>cost()</code>函数比较麻烦，并且在<code>cost()</code>函数都要使用<code>arguments</code>参数不符合你的预期。我们知道函数都有一个<code>length</code>属性，表明函数期望接受的参数个数。因此我们可以充分利用预传参数的这个特点。</p><p>借鉴自<a href="http://link.zhihu.com/?target=https%3A//github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">mqyqingfeng</a>：</p><pre><code>function sub_curry(fn) {  var args = [].slice.call(arguments, 1);  return function() {    return fn.apply(this, args.concat([].slice.call(arguments)));  };}function curry(fn, length) {  length = length || fn.length;  var slice = Array.prototype.slice;  return function() {    if (arguments.length &lt; length) {      var combined = [fn].concat(slice.call(arguments));      return curry(sub_curry.apply(this, combined), length - arguments.length);    } else {      return fn.apply(this, arguments);    }  };}</code></pre><p>在上述函数中，我们在currying的返回函数中，每次把<code>arguments.length</code>和<code>fn.length</code>作比较，一旦<code>arguments.length</code>达到了<code>fn.length</code>的数量，我们就去调用<code>fn</code>(<code>return fn.apply(this, arguments);</code>)</p><p>验证：</p><pre><code>var fn = curry(function(a, b, c) {  return [a, b, c];});fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre><h2 id="bind方法的实现"><a href="#bind方法的实现" class="headerlink" title="bind方法的实现"></a>bind方法的实现</h2><p>使用柯里化，能够很方便地借用<code>call()</code>或者<code>apply()</code>实现<code>bind()</code>方法的<code>polyfill</code>。</p><pre><code>Function.prototype.bind = Function.prototype.bind || function(context) {  var me = this;  var args = Array.prototype.slice.call(arguments, 1);  return function() {    var innerArgs = Array.prototype.slice.call(arguments);    var finalArgs = args.concat(innerArgs);    return me.apply(contenxt, finalArgs);  }}</code></pre><p>上述函数有的问题在于不能兼容构造函数。我们通过判断this指向的对象的原型属性，来判断这个函数是否通过<code>new</code>作为构造函数调用，来使得上述<code>bind</code>方法兼容构造函数。</p><p><a href="http://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind() by MDN</a>如下说到：</p><blockquote><p>绑定函数适用于用new操作符 new 去构造一个由目标函数创建的新的实例。当一个绑定函数是用来构建一个值的，原来提供的 this 就会被忽略。然而, 原先提供的那些参数仍然会被前置到构造函数调用的前面。</p></blockquote><p>这是<a href="http://link.zhihu.com/?target=https%3A//book.douban.com/subject/10733304/" target="_blank" rel="noopener">基于MVC的JavaScript Web富应用开发</a>的<code>bind()</code>方法实现：</p><pre><code>Function.prototype.bind = function(oThis) {  if (typeof this !== &quot;function&quot;) {    throw new TypeError(&quot;Function.prototype.bind - what is trying to be bound is not callable&quot;);  }  var aArgs = Array.prototype.slice.call(arguments, 1),    fToBind = this,    fNOP = function() {},    fBound = function() {      return fToBind.apply(        this instanceof fNOP &amp;&amp; oThis ? this : oThis || window,        aArgs.concat(Array.prototype.slice.call(arguments))      );    };  fNOP.prototype = this.prototype;  fBound.prototype = new fNOP();  return fBound;};</code></pre><h2 id="反柯里化（uncurrying）"><a href="#反柯里化（uncurrying）" class="headerlink" title="反柯里化（uncurrying）"></a>反柯里化（uncurrying）</h2><p>可能遇到这种情况：拿到一个柯里化后的函数，却想要它柯里化之前的版本，这本质上就是想将类似<code>f(1)(2)(3)</code>的函数变回类似<code>g(1,2,3)</code>的函数。</p><p>下面是简单的<code>uncurrying</code>的实现方式：</p><pre><code>function uncurrying(fn) {  return function(...args) {    var ret = fn;    for (let i = 0; i &lt; args.length; i++) {      ret = ret(args[i]); // 反复调用currying版本的函数    }    return ret; // 返回结果  };}</code></pre><blockquote><p>注意，不要以为uncurrying后的函数和currying之前的函数一模一样，它们只是行为类似！</p></blockquote><pre><code>var currying = function(fn) {  var args = Array.prototype.slice.call(arguments, 1);  return function() {    if (arguments.length === 0) {      return fn.apply(this, args); // 没传参数时，调用这个函数    } else {      [].push.apply(args, arguments); // 传入了参数，把参数保存下来      return arguments.callee; // 返回这个函数的引用    }  }}function uncurrying(fn) {  return function(...args) {    var ret = fn;    for (let i = 0; i &lt; args.length; i++) {      ret = ret(args[i]); // 反复调用currying版本的函数    }    return ret; // 返回结果  };}var cost = (function() {  var money = 0;  return function() {    for (var i = 0; i &lt; arguments.length; i++) {      money += arguments[i];    }    return money;  }})();var curryingCost = currying(cost);var uncurryingCost = uncurrying(curryingCost);console.log(uncurryingCost(100, 200, 300)()); // 600</code></pre><h2 id="柯里化或偏函数有什么用？"><a href="#柯里化或偏函数有什么用？" class="headerlink" title="柯里化或偏函数有什么用？"></a>柯里化或偏函数有什么用？</h2><p>无论是柯里化还是偏应用，我们都能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。</p><p>另一个最能体现柯里化应用的的是，当函数只有一个形参时，我们能够比较容易地组合它们（<code>单一职责原则（Single responsibility principle）</code>）。因此，如果一个函数最终需要三个实参，那么它被柯里化以后会变成需要三次调用，每次调用需要一个实参的函数。当我们组合函数时，这种单元函数的形式会让我们处理起来更简单。</p><p>归纳下来，主要为以下常见的三个用途：</p><ul><li>延迟计算</li><li>参数复用</li><li>动态生成函数</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 柯里化 </tag>
            
            <tag> 函数式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5的Websocket</title>
      <link href="/2016/08/08/HTML5%E7%9A%84Websocket/"/>
      <url>/2016/08/08/HTML5%E7%9A%84Websocket/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>先请来TA的邻居：*<br>http：无状态、基于tcp请求/响应模式的应用层协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么）tcp：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) 传输层协议。（看啊，大阅兵，如此规整有秩序）</li></ul></blockquote><h2 id="为什么要引入Websocket："><a href="#为什么要引入Websocket：" class="headerlink" title="为什么要引入Websocket："></a>为什么要引入Websocket：</h2><blockquote><p>RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。</p></blockquote><p>long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。</p><p><img src="https://pic3.zhimg.com/v2-b900392bfe564de524ec5460a2b5d235_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-b900392bfe564de524ec5460a2b5d235_hd.jpg" alt=""></p><p>从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。</p><p>这个时候，Websocket出现了。</p><h2 id="Websocket是什么："><a href="#Websocket是什么：" class="headerlink" title="Websocket是什么："></a>Websocket是什么：</h2><blockquote><p>RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。</p></blockquote><p>对，划重点：双向通信</p><p>Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以主动向客户端推送消息。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。</p><p>其特点：</p><p>（1）握手阶段采用 HTTP 协议，默认端口是80和443</p><p>（2）建立在TCP协议基础之上，和http协议同属于应用层</p><p>（4）可以发送文本，也可以发送二进制数据</p><p>（5）没有同源限制，客户端可以与任意服务器通信</p><p>（6）协议标识符是ws（如果加密，为wss），如ws://localhost:8023</p><p>简单来说，Websocket协议分为两部分：握手和数据传输。</p><p><img src="https://pic2.zhimg.com/v2-5b1e92b99d352ba977f69cbe28604ecf_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5b1e92b99d352ba977f69cbe28604ecf_hd.jpg" alt=""></p><h2 id="Websocket-API："><a href="#Websocket-API：" class="headerlink" title="Websocket API："></a>Websocket API：</h2><blockquote><p>这里是指客户端 API。</p></blockquote><h2 id="WebSocket-构造函数"><a href="#WebSocket-构造函数" class="headerlink" title="WebSocket 构造函数"></a>WebSocket 构造函数</h2><ol><li><code>通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。</code></li><li><code>const ws =`</code>new<code></code>WebSocket(‘ws://localhost:8023’);`</li></ol><h2 id="Websocket事件"><a href="#Websocket事件" class="headerlink" title="Websocket事件"></a>Websocket事件</h2><ol><li><code>WebSocket`</code>是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。`</li></ol><p>open:</p><p>服务端响应WebSocket连接请求，就会触发open事件。onopen是响应的回调函数。</p><p><code>// 连接请求open事件处理：</code></p><pre><code>ws.onopen=e=&gt;{   console.log(&apos;Connection success&apos;);   ws.send(`Hello ${e}`);};</code></pre><p>如果要指定多个回调函数，可以使用addEventListener方法。</p><pre><code>ws.addEventListener(&apos;open&apos;, e =&gt; { ws.send(`Hello ${e}`);});</code></pre><p>当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。</p><p>Message:</p><p>收到服务器数据，会触发消息事件，onmessage是响应的回调函数。如下：</p><pre><code>// 接受文本消息的事件处理：ws.onmessage = e =&gt; {const data = e.data;if (typeof data === &quot;string&quot;) {       console.log(&quot;Received string message &quot;,data);} else if (data instanceof Blob) {       console.log(&quot;Received blob message &quot;, data);}};</code></pre><p>服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。</p><p>Error</p><p>发生错误会触发error事件, onerror是响应的回调函数, 会导致连接关闭。</p><pre><code>//异常处理ws.onerror = e =&gt; {   console.log(&quot;WebSocket Error: &quot; , e);   handleErrors(e);};</code></pre><p>当连接关闭时触发close事件，对应onclose方法，连接关闭之后，服务端和客户端就不能再通信。</p><p>WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧）</p><pre><code>//关闭连接处理ws.onclose = e =&gt; {const code = e.code;const reason = e.reason;   console.log(&quot;Connection close&quot;, code, reason);};</code></pre><h2 id="WebSocket-方法："><a href="#WebSocket-方法：" class="headerlink" title="WebSocket 方法："></a>WebSocket 方法：</h2><blockquote><p>WebSocket 对象有两个方法：send 和 close</p></blockquote><p>send:</p><p>客户端和服务器建立连接后，可以调用send方法去发送消息。</p><pre><code>//发送一个文本消息ws.send(&quot;this is websocket&quot;);</code></pre><p>在open事件的回调中调用send()方法传送数据：</p><pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;);ws.onopen = e =&gt; {   console.log(&apos;Connection success&apos;);   ws.send(`Hello ${e}`);};</code></pre><p>如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState.</p><p>close</p><p>close方法用来关闭连接。调用close方法后，将不能发送数据。close方法可以传入两个可选的参数，code 和reason, 以告诉服务端为什么终止连接。</p><pre><code>ws.close();//1000是状态码，代表正常结束。ws.close(1000, &quot;Closing normally&quot;);</code></pre><h2 id="WebSocket-属性"><a href="#WebSocket-属性" class="headerlink" title="WebSocket 属性"></a>WebSocket 属性</h2><ul><li>readyState：</li></ul><p>readyState值表示连接状态，是只读属性。它有以下四个值：</p><blockquote><p>WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开</p></blockquote><p>除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。</p><pre><code>function bindEventHandler(data) {if (ws.readyState === WebSocket.OPEN) {       ws.send(data);} else {//do something}} </code></pre><p>bufferedAmount：</p><p>当客户端传输大量数据时，浏览器会缓存将要流出的数据，bufferedAmount属性可判断有多少字节的二进制数据没有发送出去，发送是否结束。</p><pre><code>ws.onopen = function () {   setInterval( function() {//缓存未满的时候发送if (ws.bufferedAmount &lt; 1024 * 5) {           ws.send(data);}}, 2000);};</code></pre><p>protocol：</p><p>protocol代表客户端使用的WebSocket协议。当握手协议未成功，这个属性是空。</p><ul><li>接下来，我们说说握手阶段过程。*</li></ul><p>当我们创建Websocket实例对象与服务器建立连接时，</p><pre><code>const ws = new WebSocket(&apos;ws://localhost:8023&apos;)；</code></pre><p>首先客户端向服务器发起一个握手请求，其请求报文的内容如下：</p><pre><code>GET /game HTTP/1.1Host: 10.242.17.102:8023Cache-Control: no-cacheUpgrade: websocketConnection: UpgradeSec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==Sec-WebSocket-Protocol: gameSec-WebSocket-Version: 10Origin: http://192.168.185.16Accept-Encoding: gzip, deflate, sdchAccept-Language: zh-CN,zh;q=0.8</code></pre><p>从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。</p><ul><li>Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。</li><li>Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信</li><li>Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议</li><li>Sec-WebSocket-Version: 通知服务器所使用的协议版本</li></ul><p>服务器响应：</p><pre><code>当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。 HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ=</code></pre><ul><li>101 状态码，表示要转换协议啦</li><li>Upgrde: 通知客户端将要升级成Websocket协议</li><li>Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。</li></ul><p><img src="https://pic4.zhimg.com/v2-05e821d0db32cf8cb5ebf51625870cb1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-05e821d0db32cf8cb5ebf51625870cb1_hd.jpg" alt=""></p><p>至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Websocket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>移动端H5页面返回并且刷新页面</title>
      <link href="/2016/07/25/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E9%A1%B5%E9%9D%A2%E8%BF%94%E5%9B%9E%E5%B9%B6%E4%B8%94%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/"/>
      <url>/2016/07/25/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E9%A1%B5%E9%9D%A2%E8%BF%94%E5%9B%9E%E5%B9%B6%E4%B8%94%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>项目中的需求：点击浏览器中的返回按钮，要让页面重新加载资源。因为这部分的资源每次去加载的内容都不一样，如果返回的时候，还是看到原先的内容，那做这个内容块的意义就很小了；而如果用户看完了这部分内容，再返回来的时候，这个地方换成了新的内容，这样就能体现这部分的价值了。</p><p>而对于浏览器来说，大部分浏览器的返回是直接使用缓存的，不会执行任何的javascript代码。原因：部分浏览器在后退时不会触发onload事件，這是HTML5世代浏览器新增的特性之一——Back-Forward Cache(简称bfcache)</p><p><strong>什么是bfcache？</strong></p><p>bfcache，即back-forward cache，可称为“往返缓存”，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存不仅保存页面数据，还保存了DOM和JS的状态，实际上是将整个页面都保存在内存里。如果页面位于bfcache中，那么再次打开该页面就不会触发onload事件</p><h3 id="pageshow事件"><a href="#pageshow事件" class="headerlink" title="pageshow事件"></a>pageshow事件</h3><p>这个事件在用户浏览网页时触发，pageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， pageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发。</p><h3 id="pagehide事件"><a href="#pagehide事件" class="headerlink" title="pagehide事件"></a>pagehide事件</h3><p>该事件会在用户离开网页时触发。离开网页有多种方式。如点击一个链接，刷新页面，提交表单，关闭浏览器等。pagehide 事件有时可以替代 unload事件，但 unload 事件触发后无法缓存页面。</p><h3 id="persisted属性"><a href="#persisted属性" class="headerlink" title="persisted属性"></a>persisted属性</h3><p>pageshow事件和pagehide事件的event对象还包含一个名为persisted的布尔值属性。</p><ul><li>对于pageshow事件，如果页面是从bfcache中加载的，则这个属性的值为true；否则，这个属性的值为false。</li><li>对于pagehide事件，如果页面在卸载之后被保存在bfcache中，则这个属性的值为true；否则，这个属性的值为false。</li></ul><p>不同的浏览器在对当前窗口‘打开’历史记录中的前一个页面的表现上并不统一，这和浏览器的实现以及页面本身的设置有关系。</p><p><strong>解决方案：</strong></p><p><strong>javascript监听pageshow事件阻止页面进入bfcache</strong></p><pre><code> window.addEventListener(&apos;pageshow&apos;, function (e) {     if (e.persisted) {         window.location.reload()     }})</code></pre><p>在uc和微信中测试通过，但是在某些安卓手机自带的浏览器中无效。</p><p><strong>javascript监听pagehide事件阻止页面进入bfcache</strong></p><pre><code>window.addEventListener(&apos;pagehide&apos;, function (e) {    var dom = document.body;    dom.children.remove();    setTimeout(function () {        dom.appendChild(&quot;&lt;script type=&apos;text/javascript&apos;&gt;window.location.reload();&lt;\/script&gt;&quot;);    });});</code></pre><p><strong>设置meta标签，清除页面缓存</strong></p><pre><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt;&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;</code></pre><p>Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下<br>Public指示响应可被任何缓存区缓存<br>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。<br>注：有些情况下设置清除缓存也没有起到作用，我自己做的这个h5页面就没有起到效果。具体情况还是要具体分析。</p><p><strong>我遇到的情况：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;content&quot;&gt;</span><br><span class="line">     &lt;iframe id=&quot;iframe&quot; src=&quot;https://cpu.baidu.com/xx/xx/xxx&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这个iframe中的地址每次刷新页面都会有不同的内容推送给用户。进入iframe中的内容之后，按返回按钮返回来想进行页面自动刷新，为的就是让用户看到新的内容。</p><p>做法：</p><p>使用pageshow进行整个页面刷新</p><pre><code>window.addEventListener(&apos;pageshow&apos;, function (e) {    if (e.persisted) {        window.location.reload()    }})</code></pre><p>这样可以实现。</p><p>后面又觉得不妥，没有因为这个小部分而进行整个页面刷新，想到了另一种思路：因为这个iframe中的内容是动态的，可以对其进行定时器设置，如下：</p><pre><code>let iframe = document.getElementById(&apos;iframe&apos;)setInterval(() =&gt; {    iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);},15000)</code></pre><p>这样也可以实现自己的功能。</p><p>最后可以结合一下：</p><pre><code>let iframe = document.getElementById(&apos;iframe&apos;)window.addEventListener(&apos;pageshow&apos;, function (e) {    if (e.persisted) {        iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);    }})</code></pre><p>这样做也有好处，可以避免使用定时器，对网页的性能也是比较好。但是这个方法在返回的时候，可以看到iframe里面内容的重新加载，会有一个时间间隙。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>跨域，你需要知道的全在这里</title>
      <link href="/2016/05/21/%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%A8%E5%9C%A8%E8%BF%99%E9%87%8C/"/>
      <url>/2016/05/21/%E8%B7%A8%E5%9F%9F%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%A8%E5%9C%A8%E8%BF%99%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<p>最近在面试的时候常被问到如何解决跨域的问题，看了网上的一些文章后，许多文章并没有介绍清楚，经常使读者(我)感到困惑，所以今天我整理一下常用的跨域技巧，写这篇关于跨域的文章目的在于：</p><ol><li>介绍常见的跨域的解决方案以及其优缺点</li><li>模拟实际的跨域场景，在每种方案后给出一个简单的实例，能够让读者和我一起敲代码，直观地理解这些跨域技巧</li></ol><p>如果觉得本文有帮助，可以点 star 鼓励下，本文所有代码都可以从 github 仓库下载，读者可以按照下述打开:</p><pre><code>git clone https://github.com/happylindz/blog.gitcd blog/code/crossOrigin/yarn</code></pre><p>建议你 clone 下来，方便你阅读代码，跟我一起测试。</p><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>使用过 Ajax 的同学都知道其便利性，可以在不向服务端提交完整页面的情况下，实现局部刷新，在当今 SPA 应用普遍使用，但是浏览器处于对安全方面的考虑，不允许跨域调用其它页面的对象，这对于我们在注入 iframe 或是 ajax 应用上带来不少麻烦。</p><p>简单来说，只有当协议，域名，端口号相同的时候才算是同一个域名，否则，均认为需要做跨域处理。</p><p><img src="https://pic4.zhimg.com/v2-5fa29773fc875bf58e4513fdba402bf0_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-5fa29773fc875bf58e4513fdba402bf0_hd.jpg" alt=""></p><h2 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h2><p>今天一共介绍七种常用的跨域技巧，关于跨域技巧大致可以分为 iframe 跨域和 API 跨域请求。</p><p>下面就先介绍三种 API 跨域的方法:</p><h2 id="1-JSONP："><a href="#1-JSONP：" class="headerlink" title="1. JSONP："></a>1. JSONP：</h2><p>只要说到跨域，就必须聊到 JSONP，JSONP 全称为：JSON with padding，可用于解决老版本浏览器的跨域数据访问问题。</p><p>由于 web 页面上调用 js 文件不受浏览器同源策略的影响，所以通过 script 标签可以进行跨域请求：</p><ol><li>首先前端需要先设置好回调函数，并将其作为 url 的参数。</li><li>服务端接收到请求后，通过该参数获取到回调函数名，并将数据放在参数中将其返回</li><li>收到结果后因为是 script 标签，所以浏览器会当做是脚本进行运行，从而达到跨域获取数据的目的</li></ol><p>jsonp 之所以能够跨域的关键在于页面调用 JS 脚本是不受同源策略的影响，相当于向后端发起一条 http 请求，跟后端约定好函数名，后端拿到函数名，动态计算出返回结果并返回给前端执行 JS 脚本，相当于是一种 “动态 JS 脚本”</p><p>接下来我们通过一个实例来尝试：</p><p>后端逻辑：</p><pre><code>// jsonp/server.jsconst url = require(&apos;url&apos;);require(&apos;http&apos;).createServer((req, res) =&gt; {    const data = {        x: 10    };    // 拿到回调函数名    const callback = url.parse(req.url, true).query.callback;    console.log(callback);    res.writeHead(200);    res.end(`${callback}(${JSON.stringify(data)})`);}).listen(3000, &apos;127.0.0.1&apos;);console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);</code></pre><p>前端逻辑：</p><pre><code>// jsonp/index.html&lt;script&gt;    function jsonpCallback(data) {        alert(&apos;获得 X 数据:&apos; + data.x);    }&lt;/script&gt;&lt;script src=&quot;http://127.0.0.1:3000?callback=jsonpCallback&quot;&gt;&lt;/script&gt;</code></pre><p>然后在终端开启服务：</p><p>之所以能用脚本指令，是因为我在 package.json 里面设置好了脚本命令：</p><pre><code>{  // 输入 yarn jsonp 等于 &quot;node ./jsonp/server.js &amp; http-server ./jsonp&quot;  &quot;scripts&quot;: {    &quot;jsonp&quot;: &quot;node ./jsonp/server.js &amp; http-server ./jsonp&quot;,    &quot;cors&quot;: &quot;node ./cors/server.js &amp; http-server ./cors&quot;,    &quot;proxy&quot;: &quot;node ./serverProxy/server.js&quot;,    &quot;hash&quot;: &quot;http-server ./hash/client/ -p 8080 &amp; http-server ./hash/server/ -p 8081&quot;,    &quot;name&quot;: &quot;http-server ./name/client/ -p 8080 &amp; http-server ./name/server/ -p 8081&quot;,    &quot;postMessage&quot;: &quot;http-server ./postMessage/client/ -p 8080 &amp; http-server ./postMessage/server/ -p 8081&quot;,    &quot;domain&quot;: &quot;http-server ./domain/client/ -p 8080 &amp; http-server ./domain/server/ -p 8081&quot;  },  // ...}yarn jsonp// 因为端口 3000 和 8080 分别属于不同域名下// 在 localhost:3000 查看效果，即可收到后台返回的数据 10</code></pre><p>打开浏览器访问 <code>localhost:8080</code> 即可看到获取到的数据。</p><p><img src="https://pic2.zhimg.com/v2-1bd48c160110899a8ad7e08e56d36560_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-1bd48c160110899a8ad7e08e56d36560_hd.jpg" alt=""></p><p>至此，通过 JSONP 跨域获取数据已经成功了，但是通过这种方式也存在着一定的优缺点：</p><p>优点：</p><ol><li>它不像XMLHttpRequest 对象实现 Ajax 请求那样受到同源策略的限制</li><li>兼容性很好，在古老的浏览器也能很好的运行</li><li>不需要 XMLHttpRequest 或 ActiveX 的支持；并且在请求完毕后可以通过调用 callback 的方式回传结果。</li></ol><p>缺点：</p><ol><li>它支持 GET 请求而不支持 POST 等其它类行的 HTTP 请求。</li><li>它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面或 iframe 之间进行数据通信的问题</li><li>无法捕获 Jsonp 请求时的连接异常，只能通过超时进行处理</li></ol><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS:"></a>CORS:</h2><p>CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 ajax 只能同源使用的限制。</p><p>CORS 需要浏览器和服务器同时支持才可以生效，对于开发者来说，CORS 通信与同源的 ajax 通信没有差别，代码完全一样。浏览器一旦发现 ajax 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p><p>前端逻辑很简单，只要正常发起 ajax 请求即可:</p><pre><code>// cors/index.html&lt;script&gt;    const xhr = new XMLHttpRequest();    xhr.open(&apos;GET&apos;, &apos;http://127.0.0.1:3000&apos;, true);    xhr.onreadystatechange = function() {        if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) {            alert(xhr.responseText);        }    }    xhr.send(null);&lt;/script&gt;</code></pre><p>这似乎跟一次正常的异步 ajax 请求没有什么区别，关键是在服务端收到请求后的处理：</p><pre><code>// cors/server.jsrequire(&apos;http&apos;).createServer((req, res) =&gt; {    res.writeHead(200, {        &apos;Access-Control-Allow-Origin&apos;: &apos;http://localhost:8080&apos;,        &apos;Content-Type&apos;: &apos;text/html;charset=utf-8&apos;,    });    res.end(&apos;这是你要的数据：1111&apos;);}).listen(3000, &apos;127.0.0.1&apos;);console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);</code></pre><p>关键是在于设置相应头中的 Access-Control-Allow-Origin，该值要与请求头中 Origin 一致才能生效，否则将跨域失败。</p><p>然后我们执行命令：<code>yarn cors</code> 打开浏览器访问 <code>localhost:3000</code> 即可看到效果：</p><p><img src="https://pic2.zhimg.com/v2-13ee0a40a998948019749da80e1d259a_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-13ee0a40a998948019749da80e1d259a_hd.jpg" alt=""></p><p>成功的关键在于 Access-Control-Allow-Origin 是否包含请求页面的域名，如果不包含的话，浏览器将认为这是一次失败的异步请求，将会调用 xhr.onerror 中的函数。</p><p>CORS 的优缺点：</p><ol><li>使用简单方便，更为安全</li><li>支持 POST 请求方式</li><li>CORS 是一种新型的跨域问题的解决方案，存在兼容问题，仅支持 IE 10 以上</li></ol><p>这里只是对 CORS 做一个简单的介绍，如果想更详细地了解其原理的话，可以看看下面这篇文章：</p><p><a href="https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解 - 阮一峰的网络日志</a></p><h2 id="3-服务端代理："><a href="#3-服务端代理：" class="headerlink" title="3. 服务端代理："></a>3. 服务端代理：</h2><p>服务器代理，顾名思义，当你需要有跨域的请求操作时发送请求给后端，让后端帮你代为请求，然后最后将获取的结果发送给你。</p><p>假设有这样的一个场景，你的页面需要获取 <a href="https://link.zhihu.com/?target=https%3A//cnodejs.org/api" target="_blank" rel="noopener">CNode：Node.js专业中文社区</a> 论坛上一些数据，如通过 <code>https://cnodejs.org/api/v1/topics</code>，当时因为不同域，所以你可以将请求后端，让其对该请求代为转发。</p><p>代码如下：</p><pre><code>// serverProxy/server.jsconst url = require(&apos;url&apos;);const http = require(&apos;http&apos;);const https = require(&apos;https&apos;);const server = http.createServer((req, res) =&gt; {    const path = url.parse(req.url).path.slice(1);    if(path === &apos;topics&apos;) {        https.get(&apos;https://cnodejs.org/api/v1/topics&apos;, (resp) =&gt; {            let data = &quot;&quot;;            resp.on(&apos;data&apos;, chunk =&gt; {                data += chunk;            });            resp.on(&apos;end&apos;, () =&gt; {                res.writeHead(200, {                    &apos;Content-Type&apos;: &apos;application/json; charset=utf-8&apos;                });                res.end(data);            });        })            }}).listen(3000, &apos;127.0.0.1&apos;);console.log(&apos;启动服务，监听 127.0.0.1:3000&apos;);</code></pre><p>通过代码你可以看出，当你访问 <code>http://127.0.0.1:3000/topics</code> 的时候，服务器收到请求，会代你发送请求 <code>https://cnodejs.org/api/v1/topics</code> 最后将获取到的数据发送给浏览器。</p><p>启动服务 <code>yarn proxy</code> 并访问 <code>http://localhost:3000/topics</code> 即可看到效果：<br><img src="https://pic1.zhimg.com/v2-a14f2dd5cfd124187cabff0fdfabe5a9_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-a14f2dd5cfd124187cabff0fdfabe5a9_hd.jpg" alt=""></p><p>跨域请求成功。纯粹的获取跨域获取后端数据的请求的方式已经介绍完了，另外介绍四种通过 iframe 跨域与其它页面通信的方式。</p><h2 id="location-hash："><a href="#location-hash：" class="headerlink" title="location.hash："></a>location.hash：</h2><p>在 url 中，<code>http://www.baidu.com#helloworld</code> 的 “#helloworld” 就是 location.hash，改变 hash 值不会导致页面刷新，所以可以利用 hash 值来进行数据的传递，当然数据量是有限的。</p><p>假设 <code>localhost:8080</code> 下有文件 index.html 要和 <code>localhost:8081</code> 下的 data.html 传递消息，index.html 首先创建一个隐藏的 iframe，iframe 的 src 指向 <code>localhost:8081/data.html</code>，这时的 hash 值就可以做参数传递。</p><pre><code>// hash/client/index.html 对应 localhost:8080/index.html&lt;script&gt;    let ifr = document.createElement(&apos;iframe&apos;);    ifr.style.display = &apos;none&apos;;    ifr.src = &quot;http://localhost:8081/data.html#data&quot;;    document.body.appendChild(ifr);    function checkHash() {        try {            let data = location.hash ? location.hash.substring(1) : &apos;&apos;;            console.log(&apos;获得到的数据是：&apos;, data);        }catch(e) {        }    }    window.addEventListener(&apos;hashchange&apos;, function(e) {        console.log(&apos;获得的数据是：&apos;, location.hash.substring(1));    });&lt;/script&gt;</code></pre><p>data.html 收到消息后通过 parent.location.hash 值来修改 index.html 的 hash 值，从而达到数据传递。</p><pre><code>// hash/server/data.html 对应 localhost:8081/data.html&lt;script&gt;    switch(location.hash) {        case &quot;#data&quot;:            callback();            break;    }    function callback() {        const data = &quot;data.html 的数据&quot;        try {            parent.location.hash = data;        }catch(e) {            // ie, chrome 下的安全机制无法修改 parent.location.hash            // 所以要利用一个中间的代理 iframe             var ifrproxy = document.createElement(&apos;iframe&apos;);            ifrproxy.style.display = &apos;none&apos;;            ifrproxy.src = &apos;http://localhost:8080/proxy.html#&apos; + data;     // 该文件在 client 域名的域下            document.body.appendChild(ifrproxy);        }    }&lt;/script&gt;</code></pre><p>由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于 <code>localhost:8080</code> 域名下的一个代理 iframe 的 proxy.html 页面</p><pre><code>// hash/client/proxy.html 对应 localhost:8080/proxy.html&lt;script&gt;    parent.parent.location.hash = self.location.hash.substring(1);&lt;/script&gt;</code></pre><p>之后启动服务 <code>yarn hash</code>，即可在 <code>localhost:8080</code> 下观察到：</p><p><img src="https://pic2.zhimg.com/v2-278b33c730dc9aaf499f172424adde00_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-278b33c730dc9aaf499f172424adde00_hd.jpg" alt=""></p><p>当然这种方法存在着诸多的缺点：</p><ol><li>数据直接暴露在了 url 中</li><li>数据容量和类型都有限等等</li></ol><h2 id="window-name"><a href="#window-name" class="headerlink" title="window.name:"></a>window.name:</h2><p>window.name（一般在 js 代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，这里要注意的是每个 iframe 都有包裹它的 window，而这个 window 是 top window 的子窗口，而它自然也有 window.name 的属性，window.name 属性的神奇之处在于 name 值在不同的页面（甚至不同域名）加载后依旧存在（如果没修改则值不会变化），并且可以支持非常长的 name 值（2MB）。</p><p>举个简单的例子：</p><p>你在某个页面的控制台输入：</p><pre><code>window.name = &quot;Hello World&quot;window.location = &quot;http://www.baidu.com&quot;</code></pre><p>页面跳转到了百度首页，但是 window.name 却被保存了下来，还是 Hello World，跨域解决方案似乎可以呼之欲出了：</p><p>前端逻辑：</p><pre><code>// name/client/index.html 对应 localhost:8080/index.html &lt;script&gt;    let data = &apos;&apos;;    const ifr = document.createElement(&apos;iframe&apos;);    ifr.src = &quot;http://localhost:8081/data.html&quot;;    ifr.style.display = &apos;none&apos;;    document.body.appendChild(ifr);    ifr.onload = function() {        ifr.onload = function() {            data = ifr.contentWindow.name;            console.log(&apos;收到数据:&apos;, data);        }        ifr.src = &quot;http://localhost:8080/proxy.html&quot;;    }&lt;/script&gt;</code></pre><p>数据页面：</p><pre><code>// name/server/data.html 对应 localhost:8081/data.html&lt;script&gt;    window.name = &quot;data.html 的数据!&quot;;&lt;/script&gt;</code></pre><p><code>localhost:8080index.html</code> 在请求数据端 <code>localhost:8081/data.html</code> 时，我们可以在该页面新建一个 iframe，该 iframe 的 src 指向数据端地址(利用 iframe 标签的跨域能力)，数据端文件设置好 window.name 的值。</p><p>但是由于 index.html 页面与该页面 iframe 的 src 如果不同源的话，则无法操作 iframe 里的任何东西，所以就取不到 iframe 的 name 值，所以我们需要在 data.html 加载完后重新换个 src 去指向一个同源的 html 文件，或者设置成 ‘about:blank;’ 都行，这时候我只要在 index.html 相同目录下新建一个 proxy.html 的空页面即可。如果不重新指向 src 的话直接获取的 window.name 的话会报错：</p><p><img src="https://pic2.zhimg.com/v2-7bd77f4df4565cd258bbeeed28515152_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-7bd77f4df4565cd258bbeeed28515152_hd.jpg" alt=""></p><p>之后运行 <code>yarn name</code> 即可看到效果：</p><p><img src="https://pic4.zhimg.com/v2-4dcf4a5d25982ce71bdbe6f14af4620c_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-4dcf4a5d25982ce71bdbe6f14af4620c_hd.jpg" alt=""></p><h2 id="6-postMessage"><a href="#6-postMessage" class="headerlink" title="6.postMessage"></a>6.postMessage</h2><p>postMessage 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能，使用起来也特别简单。</p><p>前端逻辑：</p><pre><code>// postMessage/client/index.html 对应 localhost:8080/index.html&lt;iframe src=&quot;http://localhost:8081/data.html&quot; style=&apos;display: none;&apos;&gt;&lt;/iframe&gt;&lt;script&gt;    window.onload = function() {        let targetOrigin = &apos;http://localhost:8081&apos;;        window.frames[0].postMessage(&apos;index.html 的 data!&apos;, targetOrigin);    }    window.addEventListener(&apos;message&apos;, function(e) {        console.log(&apos;index.html 接收到的消息:&apos;, e.data);    });&lt;/script&gt;</code></pre><p>创建一个 iframe，使用 iframe 的一个方法 postMessage 可以想 <code>http://localhost:8081/data.html</code> 发送消息，然后监听 message，可以获得其文档发来的消息。</p><p>数据端逻辑：</p><pre><code>// postMessage/server/data.html 对应 localhost:8081/data.html&lt;script&gt;    window.addEventListener(&apos;message&apos;, function(e) {        if(e.source != window.parent) {            return;        }        let data = e.data;        console.log(&apos;data.html 接收到的消息:&apos;, data);        parent.postMessage(&apos;data.html 的 data!&apos;, e.origin);    });&lt;/script&gt;</code></pre><p>启动服务：<code>yarn postMessage</code> 并打开浏览器访问：</p><p><img src="https://pic1.zhimg.com/v2-62c2ff153980a18ddd08110cd41cfde4_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-62c2ff153980a18ddd08110cd41cfde4_hd.jpg" alt=""></p><p>对 postMessage 感兴趣的详细内容可以看看教程：</p><p><a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/PostMessage/6373972%3Ffr%3Daladdin" target="_blank" rel="noopener">PostMessage_百度百科</a><a href="https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">Window.postMessage()</a></p><h2 id="7-document-domain"><a href="#7-document-domain" class="headerlink" title="7.document.domain"></a>7.document.domain</h2><p>对于主域相同而子域不同的情况下，可以通过设置 document.domain 的办法来解决，具体做法是可以在 <code>http://www.example.com/index.html</code> 和 <code>http://sub.example.com/data.html</code> 两个文件分别加上 <code>document.domain = &quot;example.com&quot;</code> 然后通过 index.html 文件创建一个 iframe，去控制 iframe 的 window，从而进行交互，当然这种方法只能解决主域相同而二级域名不同的情况，如果你异想天开的把 script.example.com 的 domain 设为 qq.com 显然是没用的，那么如何测试呢？</p><p>测试的方式稍微复杂点，需要安装 nginx 做域名映射，如果你电脑没有安装 nginx，请先去安装一下: <a href="https://link.zhihu.com/?target=http%3A//nginx.org/" target="_blank" rel="noopener">nginx</a></p><p>前端逻辑：</p><pre><code>// domain/client/index.html 对应 sub1.example.com/index.html&lt;script&gt;    document.domain = &apos;example.com&apos;;    let ifr = document.createElement(&apos;iframe&apos;);    ifr.src = &apos;http://sub2.example.com/data.html&apos;;    ifr.style.display = &apos;none&apos;;    document.body.append(ifr);    ifr.onload = function() {        let win = ifr.contentWindow;        alert(win.data);    }&lt;/script&gt;</code></pre><p>数据端逻辑：</p><pre><code>// domain/server/data 对应 sub2.example.com/data.html&lt;script&gt;    document.domain = &apos;example.com&apos;;    window.data = &apos;data.html 的数据！&apos;;&lt;/script&gt;</code></pre><p>打开操作系统下的 hosts 文件：mac 是位于 /etc/hosts 文件，并添加：</p><pre><code>127.0.0.1 sub1.example.com127.0.0.1 sub2.example.com</code></pre><p>之后打开 nginx 的配置文件：/usr/local/etc/nginx/nginx.conf，并在 http 模块里添加，记得输入 nginx 启动 nginx 服务：</p><pre><code>/usr/local/etc/nginx/nginx.confhttp {    // ...    server {        listen 80;        server_name sub1.example.com;        location / {            proxy_pass http://127.0.0.1:8080/;        }    }    server {        listen 80;        server_name sub2.example.com;        location / {            proxy_pass http://127.0.0.1:8081/;        }    }    // ...}</code></pre><p>相当于是讲 <code>sub1.example.com</code> 和 <code>sub2.example.com</code> 这些域名地址指向本地 <code>127.0.0.1:80</code>，然后用 nginx 做反向代理分别映射到 8080 和 8081 端口。</p><p>这样访问 <code>sub1(2).example.com</code> 等于访问 <code>127.0.0.1:8080(1)</code></p><p>启动服务 <code>yarn domain</code> 访问浏览器即可看到效果：</p><p><img src="https://pic2.zhimg.com/v2-19277c077856648ca1d593f44afadf6e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-19277c077856648ca1d593f44afadf6e_hd.jpg" alt=""></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>前面七种跨域方式我已经全部讲完，其实讲道理，常用的也就是前三种方式，后面四种更多时候是一些小技巧，虽然在工作中不一定会用到，但是如果你在面试过程中能够提到这些跨域的技巧，无疑在面试官的心中是一个加分项。</p><p>上面阐述方法的时候可能有些讲的不明白，希望在阅读的过程中建议你跟着我敲代码，当你打开浏览器看到结果的时候，你也就能掌握到这种方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端性能监控：window.performance</title>
      <link href="/2016/04/23/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%9Awindow-performance/"/>
      <url>/2016/04/23/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%EF%BC%9Awindow-performance/</url>
      
        <content type="html"><![CDATA[<p><a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/2014/WD-navigation-timing-2-20140325/" target="_blank" rel="noopener">window.performance</a> 是W3C性能小组引入的新的API，目前IE9以上的浏览器都支持。一个performance对象的完整结构如下图所示：</p><h2 id="Window-performance"><a href="#Window-performance" class="headerlink" title="Window.performance"></a>Window.performance</h2><p>虽然叫 <code>Timing API</code> 但是用起来却是 <code>window.performance</code></p><pre><code>// 兼容性写法const performance = window.performance ||                       window.msPerformance ||                       window.webkitPerformance;</code></pre><p>memory字段代表JavaScript对内存的占用。</p><h2 id="performance-memory-内存"><a href="#performance-memory-内存" class="headerlink" title="performance.memory(内存)"></a>performance.memory(内存)</h2><ul><li>usedJSHeapSize<br>JS 对象（包括V8引擎内部对象）占用的内存</li><li>totalJSHeapSize<br>可使用的内存</li><li>jsHeapSizeLimit<br>内存大小限制</li></ul><p><img src="https://pic4.zhimg.com/v2-f4a0fa5f8a8a1c4ef07f83d0f393fd9a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-f4a0fa5f8a8a1c4ef07f83d0f393fd9a_hd.jpg" alt=""></p><h2 id="performance-navigation-我从哪里来"><a href="#performance-navigation-我从哪里来" class="headerlink" title="performance.navigation(我从哪里来)"></a>performance.navigation(我从哪里来)</h2><ul><li>redirectCount<br>如果有重定向的话，页面通过几次重定向跳转而来</li><li><p>type</p></li><li><p>0 即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</p></li><li>1 即 TYPE_RELOAD 通过 window.location.reload() 刷新的页面</li><li>2 即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</li><li>255 即 TYPE_UNDEFINED 非以上方式进入的页面</li></ul><p>navigation字段统计的是一些网页导航相关的数据：</p><ol><li>redirectCount:重定向的数量（只读），但是这个接口有同源策略限制，即仅能检测同源的重定向；</li><li>type 返回值应该是0,1,2 中的一个。分别对应三个枚举值:</li></ol><ul><li>0 : TYPE_NAVIGATE (用户通过常规导航方式访问页面，比如点一个链接，或者一般的get方式)</li><li>1 : TYPE_RELOAD (用户通过刷新，包括JS调用刷新接口等方式访问页面)</li><li>2 : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面)</li></ul><p>最重要的是timing字段的统计数据，它包含了网络、解析等一系列的时间数据。</p><h2 id="performance-timing-时间"><a href="#performance-timing-时间" class="headerlink" title="performance.timing(时间)"></a>performance.timing(时间)</h2><p><img src="https://pic4.zhimg.com/v2-a9f7be2c5aaa973e405bd0b8da7e6890_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-a9f7be2c5aaa973e405bd0b8da7e6890_hd.jpg" alt=""></p><p>2.2.1 timing API</p><p>timing的整体结构如上图所示：</p><p><img src="https://pic2.zhimg.com/v2-95d9e0f1ff8257f3c007045c6a2d07bb_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-95d9e0f1ff8257f3c007045c6a2d07bb_hd.jpg" alt=""></p><p>各字段的含义如下：</p><ul><li>startTime：有些浏览器实现为<a href="https://link.zhihu.com/?target=https%3A//msdn.microsoft.com/en-us/library/ff974724%28v%3Dvs.85%29.aspx" target="_blank" rel="noopener">navigationStart</a>，代表浏览器开始unload前一个页面文档的开始时间节点。比如我们当前正在浏览baidu.com，在地址栏输入google.com并回车，浏览器的执行动作依次为：unload当前文档（即<a href="https://link.zhihu.com/?target=http%3A//baidu.com" target="_blank" rel="noopener">http://baidu.com</a>）-&gt;请求下一文档（即<a href="https://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="noopener">http://google.com</a>）。navigationStart的值便是触发unload当前文档的时间节点。</li></ul><p>如果当前文档为空，则navigationStart的值等于fetchStart。</p><ul><li>redirectStart和redirectEnd：如果页面是由redirect而来，则redirectStart和redirectEnd分别代表redirect开始和结束的时间节点；</li><li>unloadEventStart和unloadEventEnd：如果前一个文档和请求的文档是同一个域的，则unloadEventStart和unloadEventEnd分别代表浏览器unload前一个文档的开始和结束时间节点。否则两者都等于0；</li><li>fetchStart是指在浏览器发起任何请求之前的时间值。在fetchStart和domainLookupStart之间，浏览器会检查当前文档的缓存；</li><li>domainLookupStart和domainLookupEnd分别代表DNS查询的开始和结束时间节点。如果浏览器没有进行DNS查询（比如使用了cache），则两者的值都等于fetchStart；</li><li>connectStart和connectEnd分别代表TCP建立连接和连接成功的时间节点。如果浏览器没有进行TCP连接（比如使用持久化连接webscoket），则两者都等于domainLookupEnd；</li><li>secureConnectionStart：可选。如果页面使用HTTPS，它的值是安全连接握手之前的时刻。如果该属性不可用，则返回undefined。如果该属性可用，但没有使用HTTPS，则返回0；</li><li>requestStart代表浏览器发起请求的时间节点，请求的方式可以是请求服务器、缓存、本地资源等；</li><li>responseStart和responseEnd分别代表浏览器收到从服务器端（或缓存、本地资源）响应回的第一个字节和最后一个字节数据的时刻；</li><li>domLoading代表浏览器开始解析html文档的时间节点。我们知道IE浏览器下的document有readyState属性，domLoading的值就等于readyState改变为loading的时间节点；</li><li>domInteractive代表浏览器解析html文档的状态为interactive时的时间节点。domInteractive并非DOMReady，它早于DOMReady触发，代表html文档解析完毕（即dom tree创建完成）但是内嵌资源（比如外链css、js等）还未加载的时间点；</li><li>domContentLoadedEventStart：代表DOMContentLoaded事件触发的时间节点：</li></ul><p>页面文档完全加载并解析完毕之后,会触发DOMContentLoaded事件，HTML文档不会等待样式文件,图片文件,子框架页面的加载(load事件可以用来检测HTML页面是否完全加载完毕(fully-loaded))。</p><ul><li>domContentLoadedEventEnd：代表DOMContentLoaded事件完成的时间节点，此刻用户可以对页面进行操作，也就是jQuery中的domready时间；</li><li>domComplete：html文档完全解析完毕的时间节点；</li><li>loadEventStart和loadEventEnd分别代表onload事件触发和结束的时间节点</li></ul><p>2.2.2 计算性能指标</p><p>可以使用Navigation.timing 统计到的时间数据来计算一些页面性能指标，比如DNS查询耗时、白屏时间、domready等等。如下：</p><ul><li>DNS查询耗时 = domainLookupEnd - domainLookupStart</li><li>TCP链接耗时 = connectEnd - connectStart</li><li>request请求耗时 = responseEnd - responseStart</li><li>解析dom树耗时 = domComplete - domInteractive</li><li>白屏时间 = domloadng - fetchStart</li><li>domready时间 = domContentLoadedEventEnd - fetchStart</li><li><p>onload时间 = loadEventEnd - fetchStart</p><p>  所以根据上面的时间点，我们可以计算常规的性能值，如下：<br>  （使用该api时需要在页面完全加载完成之后才能使用，最简单的办法是在window.onload事件中读取各种数据，因为很多值必须在页面完全加载之后才能得出。）</p><p>  var timing = window.performance &amp;&amp; window.performance.timing;<br>  var navigation = window.performance &amp;&amp; window.performance.navigation;</p></li></ul><pre><code>重定向次数：var redirectCount = navigation &amp;&amp; navigation.redirectCount;跳转耗时：var redirect = timing.redirectEnd - timing.redirectStart;APP CACHE 耗时：var appcache = Math.max(timing.domainLookupStart - timing.fetchStart, 0);DNS 解析耗时：var dns = timing.domainLookupEnd - timing.domainLookupStart;TCP 链接耗时：var conn = timing.connectEnd - timing.connectStart;等待服务器响应耗时（注意是否存在cache）：var request = timing.responseStart - timing.requestStart;内容加载耗时（注意是否存在cache）:var response = timing.responseEnd - timing.responseStart;总体网络交互耗时，即开始跳转到服务器资源下载完成：var network = timing.responseEnd - timing.navigationStart;渲染处理：var processing = (timing.domComplete || timing.domLoading) - timing.domLoading;抛出 load 事件：var load = timing.loadEventEnd - timing.loadEventStart;总耗时：var total = (timing.loadEventEnd || timing.loadEventStart || timing.domComplete || timing.domLoading) - timing.navigationStart;可交互：var active = timing.domInteractive - timing.navigationStart;请求响应耗时，即 T0，注意cache：var t0 = timing.responseStart - timing.navigationStart;首次出现内容，即 T1：var t1 = timing.domLoading - timing.navigationStart;内容加载完毕，即 T3：var t3 = timing.loadEventEnd - timing.navigationStart;</code></pre><p>2.2.3 Resource timing API</p><p>Resource timing API是用来统计静态资源相关的时间信息，详细的内容请参考<a href="https://link.zhihu.com/?target=https%3A//www.w3.org/TR/resource-timing/" target="_blank" rel="noopener">W3C Resource timing</a>。这里我们只介绍performance.getEntries方法，它可以获取页面中每个静态资源的请求，【以百度移动版首页的logo为例】如下：</p><p>比较有用的几个属性：</p><pre><code>name：资源的链接initiatorType: 初始类型（注意这个类型并不准确，例如在css中的图片资源会这个值显示css，所以还是推荐用name中的后缀名）duration: 资源的总耗时（包括等待时长，请求时长，响应时长 相当于responseEnd - startTime）transferSize: 转换后的文件大小(略大于encodedBodySize, 为什么我取这个呢，因为这个值是和chrome的devtool Network里的size一致) </code></pre><p><img src="https://pic4.zhimg.com/v2-cff2a7e449c4e6260c2cb8fa0b18c948_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-cff2a7e449c4e6260c2cb8fa0b18c948_hd.jpg" alt=""></p><p>可以看到performance.getEntries返回一个数组，数组的每个元素代表对应的静态资源的信息，比如上图展示的第一个元素对应的资源类型initiatorType是图片img，请求花费的时间就是duration的值。</p><p>关于Resource timing API的使用场景，感兴趣的同学可以深入研究。</p><p><img src="https://pic2.zhimg.com/v2-23c6a6e3744a117368fbd9b0789867ff_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-23c6a6e3744a117368fbd9b0789867ff_hd.jpg" alt=""></p><pre><code>;(function() {    handleAddListener(&apos;load&apos;, getTiming)    function handleAddListener(type, fn) {        if(window.addEventListener) {            window.addEventListener(type, fn)        } else {            window.attachEvent(&apos;on&apos; + type, fn)        }    }    function getTiming() {        try {            var time = performance.timing;            var timingObj = {};            var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;            if(loadTime &lt; 0) {                setTimeout(function() {                    getTiming();                }, 200);                return;            }            timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000;            timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000;            timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000;            timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000;            timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000;            timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000;            timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000;            timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;            timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000;            timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]);            for(item in timingObj) {                console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;);            }            console.log(performance.timing);        } catch(e) {            console.log(timingObj)            console.log(performance.timing);        }    }})();&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;utf-8&quot; /&gt;        &lt;title&gt;&lt;/title&gt;        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt;        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;//cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css&quot; /&gt;        &lt;script src=&quot;&quot;&gt;&lt;/script&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://pic2.zhimg.com/v2-23c6a6e3744a117368fbd9b0789867ff_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-23c6a6e3744a117368fbd9b0789867ff_hd.jpg" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> performance </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>eval() 和 new Function() 执行JS代码</title>
      <link href="/2016/02/28/eval-%E5%92%8C-new-Function-%E6%89%A7%E8%A1%8CJS%E4%BB%A3%E7%A0%81/"/>
      <url>/2016/02/28/eval-%E5%92%8C-new-Function-%E6%89%A7%E8%A1%8CJS%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a = &apos;global scope&apos;</span><br><span class="line">function b()&#123;</span><br><span class="line">   var a = &apos;local scope&apos;</span><br><span class="line">   eval(&apos;console.log(a)&apos;)   //local scope</span><br><span class="line">   ;(new Function(&apos;&apos;,&apos;console.log(a)&apos;))()  //global scope</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">b()</span><br><span class="line"> </span><br><span class="line">local scope</span><br><span class="line">global scope</span><br></pre></td></tr></table></figure><blockquote><p>eval中的代码执行时的作用域为当前作用域。它可以访问到函数中的局部变量。</p></blockquote><blockquote><p>new Function中的代码执行时的作用域为全局作用域，不论它的在哪个地方调用的。所以它访问的是全局变量a。它根本无法访问b函数内的局部变量。</p></blockquote><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p>以 str 的方式运行 JavaScript 代码，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; var a = 12;</span><br><span class="line">&gt; eval( &apos;a+5&apos; );</span><br><span class="line">&gt; 17</span><br></pre></td></tr></table></figure></p><p>注意语句上下文 eval()的解析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eval( &apos;&#123; foo: 123 &#125;&apos; );</span><br><span class="line">&gt; 123</span><br><span class="line">&gt; eval( &apos;(&#123; foo: 123 &#125;)&apos; );</span><br><span class="line">&gt; &#123; foo: 123 &#125;</span><br></pre></td></tr></table></figure></p><h3 id="严格模式下的-eval"><a href="#严格模式下的-eval" class="headerlink" title="严格模式下的 eval()"></a>严格模式下的 eval()</h3><p>对于 eval()，理应当在严格模式下使用。在松散模式下运行代码会在当前的作用域中创建局部变量：</p><pre><code>function f(){        eval( &apos;var foo = 1&apos; );       console.log( foo ); // 1    } </code></pre><p>严格模式下就不会出现该情况。但是，运行代码仍然具有读写当前作用域中变量的权限。你需要通过间接调用 eval() 来阻止这种权限。</p><h3 id="全局作用域下间接执行-eval-有两种调用-eval-的方式："><a href="#全局作用域下间接执行-eval-有两种调用-eval-的方式：" class="headerlink" title="全局作用域下间接执行 eval() 有两种调用 eval() 的方式："></a>全局作用域下间接执行 eval() 有两种调用 eval() 的方式：</h3><ol><li>直接方式：通过直接调用名为 “eval” 的函数。</li><li><p>间接方式：使用其他的一些方式。（通过 call 调用，将其以其他名字作为 window 下的一个方法存储，在那里进行调用） 之前已经看过，在当前作用域直接使用 eval 执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x = &apos;global&apos;; </span><br><span class="line">   function directEval()&#123;</span><br><span class="line">       &apos;use strict&apos;;</span><br><span class="line">        var x = &apos;local&apos;;</span><br><span class="line">        console.log( eval(&apos;x&apos;) ); // local</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 反之，在全局作用域中间接调用 eval。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var x = &apos;global&apos;; </span><br><span class="line">function indirectEval()&#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    var x = &apos;local&apos;;</span><br><span class="line">    // 不同方式调用 call </span><br><span class="line">    console.log( eval.call(null, &apos;x&apos;) ); // global</span><br><span class="line">    console.log( window.eval(&apos;x&apos;) ); // global</span><br><span class="line">    console.log( (1,eval)(&apos;x&apos;) ); // global (1)</span><br><span class="line">    var xeval = eval;</span><br><span class="line">    console.log( xeval(&apos;x&apos;) ); // global</span><br><span class="line">    var obj = &#123; eval: eval &#125;</span><br><span class="line">    console.log( obj.eval(&apos;x&apos;) ); // global</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>说明：当你通过一个名称来引用一个变量的时候，其初始值为一个所谓的引用，数据结构分为两部分： </p><ol><li>基础是指向存储变量的值的数据结构。 </li><li>引用名是变量的名称<br>在一个函数调用 eval 的时候，该函数的调用操作符（括号）遇到一个对 eval 的引用可以确定被调用函数的名称。所以此时函数会触发一个直接的 eval 调用。当然你可以不给调用操作符引用来强制间接调用 eval。这是由于在操作符运行之前获取引用的值来实现的。在 （1）标注的那一行，逗号操作符为我们实现的这点。这个运算符运行了第一个运算元并返回了第二个运算元的结果。运算结果总是返回 值 的，意味着引用已经被解析。 间接的运行代码总是松散的。这是由于代码被独立的在当前环境中运行的结果。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function strictFunc()&#123; </span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">    var code = &apos;(function()&#123; return this; &#125;())&apos;;</span><br><span class="line">    var result = eval.call( null, code );</span><br><span class="line">    console.log( result !== undefined ); // true sloppy mode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="new-Function"><a href="#new-Function" class="headerlink" title="new Function()"></a>new Function()</h2><p>Function 构造函数的函数签名。<br>new Function( param1, param2, …, paramN,funcBody );<br>它创建一个包含0个或者过个参数名为 param1 等的函数，函数体为 funcBody。相当于如下方式创建函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function ( (param1), (param2), ..., (paramN) )&#123; </span><br><span class="line">        (funcBody)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&apos;x&apos;, &apos;y&apos;, &apos;return x+y&apos;); </span><br><span class="line">f( 3, 4 )</span><br></pre></td></tr></table></figure><p>与间接 eval 调用类似，newFunction() 创建的函数作用域也是全局的。 </p><pre><code>var x = &apos;global&apos;; function strictFunc(){   &apos;use strict&apos;;   var x = &apos;local&apos;;   var f = new Function(&apos;return x&apos;);   console.log( f() ); //global} </code></pre><p>以下的函数也是默认松散模式 </p><pre><code>function strictFunc(){     &apos;use strict&apos;;    var sl = newFunction( &apos;return this&apos; );    console.log( sl() !== undefined ); // true, sloppy modevar st = newFunction( &apos;&quot;use strict&quot;; return this;&apos; );    console.log( st() !== undefined ); // true, strict mode} </code></pre><ol><li>eval() 对比 new Function()<font color="#ff0000">一般来说，使用 new Function() 运行代码比 eval() 更为好一些：函数的参数提供了清晰的接口来运行代码，而没有必要使用较为笨拙的语法来间接的调用 eval() 确保代码只能访问自己的和全局的变量。</font></li><li>最佳实践<br><font color="#ff0000">通常：避免使用 eval() 和 new Function() 。动态运行代码不但速度较慢，还有潜在的安全风险。一般都可以找到更好地替代方案。</font><br>你也不应该使用 eval() 或者 newFunction() 来解析 JSON格式的数据。那也是不安全的。要么使用 ECMAScript 5 内置的对JSON的支持方法，要么使用一个类库。<br>合理使用实例。依旧有一些较为合理，对 eval() 和 newFunction() 使用较为高级的：配置函数数据（JSON 不允许），模板库，解析，命令行和模块系统。 </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>防抖和节流原理分析</title>
      <link href="/2016/02/11/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2016/02/11/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>窗口的resize、scroll、输入框内容校验等操作时，如果这些<strong>操作处理函数</strong>是较为复杂或页面频繁重渲染等操作时，在这种情况下如果事件触发的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来<strong>减少触发的频率</strong>，同时又不影响实际效果。</p><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>debounce（防抖），简单来说就是防止抖动。</p><p>当持续触发事件时，debounce 会<strong>合并事件且不会去触发事件</strong>，<strong>当一定时间内没有触发再这个事件时，才真正去触发事件</strong>。</p><h3 id="非立即执行版"><a href="#非立即执行版" class="headerlink" title="非立即执行版"></a>非立即执行版</h3><p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><pre><code>const debounce = (func, wait, ...args) =&gt; {  let timeout;  return function(){    const context = this;    if (timeout) clearTimeout(timeout);    timeout = setTimeout(() =&gt; {      func.apply(context, args)    },wait);  }}</code></pre><p>如此调用：</p><pre><code>content.onmousemove = debounce(count,1000);</code></pre><h3 id="立即执行版"><a href="#立即执行版" class="headerlink" title="立即执行版"></a>立即执行版</h3><p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p><pre><code>const debounce = (func, wait, ...args) =&gt; {  let timeout;  return function(){    const context = this;    if (timeout) cleatTimeout(timeout);    let callNow = !timeout;    timeout = setTimeout(() =&gt; {      timeout = null;    },wait)    if(callNow) func.apply(context,args)   }}</code></pre><h3 id="结合版"><a href="#结合版" class="headerlink" title="结合版"></a>结合版</h3><pre><code>/** * @desc 函数防抖 * @param func 函数 * @param wait 延迟执行毫秒数 * @param immediate true 表立即执行，false 表非立即执行 */functiondebounce(func,wait,immediate) {    var timeout;    returnfunction () {        var context = this;        var args = arguments;        if (timeout) clearTimeout(timeout);        if (immediate) {            var callNow = !timeout;            timeout = setTimeout(function(){                timeout = null;            }, wait)            if (callNow) func.apply(context, args)        }        else {            timeout = setTimeout(function(){                func.apply(context, args)            }, wait);        }    }}</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>throttle（节流），当持续触发事件时，<strong>保证隔间时间触发一次事件</strong>。</p><p>持续触发事件时，throttle 会合并一定时间内的事件，并在该时间结束时真正去触发一次事件。</p><h3 id="时间戳版"><a href="#时间戳版" class="headerlink" title="时间戳版"></a>时间戳版</h3><p>在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。</p><pre><code>const throttle = (func, wait, ...args) =&gt; {  let pre = 0;  returnfunction(){    const context = this;    let now = Date.now();    if (now - pre &gt;= wait){       func.apply(context, args);       pre = Date.now();    }  }}</code></pre><h3 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版"></a>定时器版</h3><p>在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p><pre><code>const throttle = (func, wait, ...args) =&gt; {  let timeout;  return function(){    const context = this;    if(!timeout){      timeout = setTimeout(() =&gt; {        timeout = null;        func.apply(context,args);      },wait)    }  }}</code></pre><h3 id="结合版-1"><a href="#结合版-1" class="headerlink" title="结合版"></a>结合版</h3><p>其实时间戳版和定时器版的节流函数的区别就是，时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。</p><pre><code>/** * @desc 函数节流 * @param func 函数 * @param wait 延迟执行毫秒数 * @param type 1 表时间戳版，2 表定时器版 */functionthrottle(func, wait ,type) {    if(type===1){        var previous = 0;    }elseif(type===2){        var timeout;    }    returnfunction() {        var context = this;        var args = arguments;        if(type===1){            var now = Date.now();            if (now - previous &gt; wait) {                func.apply(context, args);                previous = now;            }        }elseif(type===2){            if (!timeout) {                timeout = setTimeout(function() {                    timeout = null;                    func.apply(context, args)                }, wait)            }        }    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 防抖 </tag>
            
            <tag> 节流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>defer和async的区别</title>
      <link href="/2016/01/25/defer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2016/01/25/defer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>先来试个一句话解释仨，当浏览器碰到 <code>script</code> 脚本的时候：</p><ol><li><code>&lt;script src=&quot;&quot;&gt;&lt;/script&gt;</code></li></ol><p>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 <code>script</code> 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><ol start="2"><li><code>&lt;script async src=&quot;&quot;&gt;&lt;/script&gt;</code></li></ol><p>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）。</p><ol start="3"><li><code>&lt;script defer src=&quot;&quot;&gt;&lt;/script&gt;</code></li></ol><p>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成。</p><p>然后从实用角度来说呢，首先把所有脚本都丢到 <code>&lt;/body&gt;</code> 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p><p>接着，我们来看一张图咯：</p><p><img src="/2016/01/25/defer和async的区别/1.png" alt=""></p><h4 id="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】"><a href="#蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表-HTML-解析。【JS-解析会阻塞HTML解析】" class="headerlink" title="蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】"></a>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。【JS 解析会阻塞HTML解析】</h4><p>此图告诉我们以下几个要点：</p><ol><li>defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li><li>它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的</li><li>关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li><li>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li><li>仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FastClick-源码解析</title>
      <link href="/2016/01/22/FastClick-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2016/01/22/FastClick-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(function() &#123;</span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line">//构造函数</span><br><span class="line">function FastClick(layer, options) &#123;</span><br><span class="line">var oldOnClick;</span><br><span class="line">options = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">//是否开始追踪click事件</span><br><span class="line">this.trackingClick = false;</span><br><span class="line"></span><br><span class="line">//存储第一次按下时间戳</span><br><span class="line">this.trackingClickStart = 0;</span><br><span class="line"></span><br><span class="line">//目标元素</span><br><span class="line">this.targetElement = null;</span><br><span class="line"></span><br><span class="line">//存放坐标值X</span><br><span class="line">this.touchStartX = 0;</span><br><span class="line"></span><br><span class="line">//存放坐标值Y</span><br><span class="line">this.touchStartY = 0;</span><br><span class="line"></span><br><span class="line">//主要hack iOS4下的一个怪异问题</span><br><span class="line">this.lastTouchIdentifier = 0;</span><br><span class="line"></span><br><span class="line">//用于区分是click还是Touchmove，若出点移动超过该值则视为touchmove</span><br><span class="line">this.touchBoundary = options.touchBoundary || 10;</span><br><span class="line"></span><br><span class="line">// 绑定了FastClick的元素，一般是是body</span><br><span class="line">this.layer = layer;</span><br><span class="line"></span><br><span class="line">//双击最小点击时间差</span><br><span class="line">this.tapDelay = options.tapDelay || 200;</span><br><span class="line"></span><br><span class="line">//长按最大时间</span><br><span class="line">this.tapTimeout = options.tapTimeout || 700;</span><br><span class="line"></span><br><span class="line">//如果是属于不需要处理的元素类型，则直接返回</span><br><span class="line">if(FastClick.notNeeded(layer)) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//语法糖，兼容一些用不了 Function.prototype.bind 的旧安卓</span><br><span class="line">//所以后面不走 layer.addEventListener(&apos;click&apos;, this.onClick.bind(this), true);</span><br><span class="line">function bind(method, context) &#123;</span><br><span class="line">return function() &#123;</span><br><span class="line">return method.apply(context, arguments);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var methods = [&apos;onMouse&apos;, &apos;onClick&apos;, &apos;onTouchStart&apos;, &apos;onTouchMove&apos;, &apos;onTouchEnd&apos;, &apos;onTouchCancel&apos;];</span><br><span class="line">var context = this;</span><br><span class="line">for(var i = 0, l = methods.length; i &lt; l; i++) &#123;</span><br><span class="line">context[methods[i]] = bind(context[methods[i]], context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//安卓则做额外处理</span><br><span class="line">if(deviceIsAndroid) &#123;</span><br><span class="line">layer.addEventListener(&apos;mouseover&apos;, this.onMouse, true);</span><br><span class="line">layer.addEventListener(&apos;mousedown&apos;, this.onMouse, true);</span><br><span class="line">layer.addEventListener(&apos;mouseup&apos;, this.onMouse, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer.addEventListener(&apos;click&apos;, this.onClick, true);</span><br><span class="line">layer.addEventListener(&apos;touchstart&apos;, this.onTouchStart, false);</span><br><span class="line">layer.addEventListener(&apos;touchmove&apos;, this.onTouchMove, false);</span><br><span class="line">layer.addEventListener(&apos;touchend&apos;, this.onTouchEnd, false);</span><br><span class="line">layer.addEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false);</span><br><span class="line"></span><br><span class="line">// 兼容不支持 stopImmediatePropagation 的浏览器(比如 Android 2)</span><br><span class="line">if(!Event.prototype.stopImmediatePropagation) &#123;</span><br><span class="line">layer.removeEventListener = function(type, callback, capture) &#123;</span><br><span class="line">var rmv = Node.prototype.removeEventListener;</span><br><span class="line">if(type === &apos;click&apos;) &#123;</span><br><span class="line">rmv.call(layer, type, callback.hijacked || callback, capture);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">rmv.call(layer, type, callback, capture);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">layer.addEventListener = function(type, callback, capture) &#123;</span><br><span class="line">var adv = Node.prototype.addEventListener;</span><br><span class="line">if(type === &apos;click&apos;) &#123;</span><br><span class="line">//留意这里 callback.hijacked 中会判断 event.propagationStopped 是否为真来确保（安卓的onMouse事件）只执行一次</span><br><span class="line">//在 onMouse 事件里会给 event.propagationStopped 赋值 true</span><br><span class="line">adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) &#123;</span><br><span class="line">if(!event.propagationStopped) &#123;</span><br><span class="line">callback(event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;), capture);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">adv.call(layer, type, callback, capture);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果layer直接在DOM上写了 onclick 方法，那我们需要把它替换为 addEventListener 绑定形式</span><br><span class="line">if(typeof layer.onclick === &apos;function&apos;) &#123;</span><br><span class="line">oldOnClick = layer.onclick;</span><br><span class="line">layer.addEventListener(&apos;click&apos;, function(event) &#123;</span><br><span class="line">oldOnClick(event);</span><br><span class="line">&#125;, false);</span><br><span class="line">layer.onclick = null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.</span><br><span class="line"> *</span><br><span class="line"> * @type boolean</span><br><span class="line"> */</span><br><span class="line">var deviceIsWindowsPhone = navigator.userAgent.indexOf(&quot;Windows Phone&quot;) &gt;= 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Android requires exceptions.</span><br><span class="line"> *</span><br><span class="line"> * @type boolean</span><br><span class="line"> */</span><br><span class="line">var deviceIsAndroid = navigator.userAgent.indexOf(&apos;Android&apos;) &gt; 0 &amp;&amp; !deviceIsWindowsPhone;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * iOS requires exceptions.</span><br><span class="line"> *</span><br><span class="line"> * @type boolean</span><br><span class="line"> */</span><br><span class="line">var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) &amp;&amp; !deviceIsWindowsPhone;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * iOS 4 requires an exception for select elements.</span><br><span class="line"> *</span><br><span class="line"> * @type boolean</span><br><span class="line"> */</span><br><span class="line">var deviceIsIOS4 = deviceIsIOS &amp;&amp; (/OS 4_\d(_\d)?/).test(navigator.userAgent);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * iOS 6.0-7.* requires the target element to be manually derived</span><br><span class="line"> *</span><br><span class="line"> * @type boolean</span><br><span class="line"> */</span><br><span class="line">var deviceIsIOSWithBadTarget = deviceIsIOS &amp;&amp; (/OS [6-7]_\d/).test(navigator.userAgent);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * BlackBerry requires exceptions.</span><br><span class="line"> *</span><br><span class="line"> * @type boolean</span><br><span class="line"> */</span><br><span class="line">var deviceIsBlackBerry10 = navigator.userAgent.indexOf(&apos;BB10&apos;) &gt; 0;</span><br><span class="line"></span><br><span class="line">//判断元素是否要保留穿透功能</span><br><span class="line">FastClick.prototype.needsClick = function(target) &#123;</span><br><span class="line">switch(target.nodeName.toLowerCase()) &#123;</span><br><span class="line"></span><br><span class="line">// disabled的input</span><br><span class="line">case &apos;button&apos;:</span><br><span class="line">case &apos;select&apos;:</span><br><span class="line">case &apos;textarea&apos;:</span><br><span class="line">if(target.disabled) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">case &apos;input&apos;:</span><br><span class="line"></span><br><span class="line">// file组件必须通过原生click事件点击才有效</span><br><span class="line">if((deviceIsIOS &amp;&amp; target.type === &apos;file&apos;) || target.disabled) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">break;</span><br><span class="line">case &apos;label&apos;:</span><br><span class="line">case &apos;iframe&apos;:</span><br><span class="line">case &apos;video&apos;:</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//元素带了名为“bneedsclick”的class也返回true</span><br><span class="line">return(/\bneedsclick\b/).test(target.className);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//判断给定元素是否需要通过合成click事件来模拟聚焦</span><br><span class="line">FastClick.prototype.needsFocus = function(target) &#123;</span><br><span class="line">switch(target.nodeName.toLowerCase()) &#123;</span><br><span class="line">case &apos;textarea&apos;:</span><br><span class="line">return true;</span><br><span class="line">case &apos;select&apos;:</span><br><span class="line">return !deviceIsAndroid; //iOS下的select得走穿透点击才行</span><br><span class="line">case &apos;input&apos;:</span><br><span class="line">switch(target.type) &#123;</span><br><span class="line">case &apos;button&apos;:</span><br><span class="line">case &apos;checkbox&apos;:</span><br><span class="line">case &apos;file&apos;:</span><br><span class="line">case &apos;image&apos;:</span><br><span class="line">case &apos;radio&apos;:</span><br><span class="line">case &apos;submit&apos;:</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return !target.disabled &amp;&amp; !target.readOnly;</span><br><span class="line">default:</span><br><span class="line">//带有名为“bneedsfocus”的class则返回true</span><br><span class="line">return(/\bneedsfocus\b/).test(target.className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//合成一个click事件并在指定元素上触发</span><br><span class="line">FastClick.prototype.sendClick = function(targetElement, event) &#123;</span><br><span class="line">var clickEvent, touch;</span><br><span class="line"></span><br><span class="line">// 在一些安卓机器中，得让页面所存在的 activeElement（聚焦的元素，比如input）失焦，否则合成的click事件将无效</span><br><span class="line">if(document.activeElement &amp;&amp; document.activeElement !== targetElement) &#123;</span><br><span class="line">document.activeElement.blur();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">touch = event.changedTouches[0];</span><br><span class="line"></span><br><span class="line">// 合成(Synthesise) 一个 click 事件</span><br><span class="line">// 通过一个额外属性确保它能被追踪（tracked）</span><br><span class="line">clickEvent = document.createEvent(&apos;MouseEvents&apos;);</span><br><span class="line">clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);</span><br><span class="line">clickEvent.forwardedTouchEvent = true; // fastclick的内部变量，用来识别click事件是原生还是合成的</span><br><span class="line">targetElement.dispatchEvent(clickEvent); //立即触发其click事件</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FastClick.prototype.determineEventType = function(targetElement) &#123;</span><br><span class="line"></span><br><span class="line">//安卓设备下 Select 无法通过合成的 click 事件被展开，得改为 mousedown</span><br><span class="line">if(deviceIsAndroid &amp;&amp; targetElement.tagName.toLowerCase() === &apos;select&apos;) &#123;</span><br><span class="line">return &apos;mousedown&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return &apos;click&apos;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//设置元素聚焦事件</span><br><span class="line">FastClick.prototype.focus = function(targetElement) &#123;</span><br><span class="line">var length;</span><br><span class="line"></span><br><span class="line">// 组件建议通过setSelectionRange(selectionStart, selectionEnd)来设定光标范围（注意这样还没有聚焦</span><br><span class="line">// 要等到后面触发 sendClick 事件才会聚焦）</span><br><span class="line">// 另外 iOS7 下有些input元素(比如 date datetime month) 的 selectionStart 和 selectionEnd 特性是没有整型值的，</span><br><span class="line">// 导致会抛出一个关于 setSelectionRange 的模糊错误，它们需要改用 focus 事件触发</span><br><span class="line">if(deviceIsIOS &amp;&amp; targetElement.setSelectionRange &amp;&amp; targetElement.type.indexOf(&apos;date&apos;) !== 0 &amp;&amp; targetElement.type !== &apos;time&apos; &amp;&amp; targetElement.type !== &apos;month&apos;) &#123;</span><br><span class="line">length = targetElement.value.length;</span><br><span class="line">targetElement.setSelectionRange(length, length);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//直接触发其focus事件</span><br><span class="line">targetElement.focus();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 检查target是否一个滚动容器里的子元素，如果是则给它加个标记</span><br><span class="line"> */</span><br><span class="line">FastClick.prototype.updateScrollParent = function(targetElement) &#123;</span><br><span class="line">var scrollParent, parentElement;</span><br><span class="line"></span><br><span class="line">scrollParent = targetElement.fastClickScrollParent;</span><br><span class="line"></span><br><span class="line">// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the</span><br><span class="line">// target element was moved to another parent.</span><br><span class="line">if(!scrollParent || !scrollParent.contains(targetElement)) &#123;</span><br><span class="line">parentElement = targetElement;</span><br><span class="line">do &#123;</span><br><span class="line">if(parentElement.scrollHeight &gt; parentElement.offsetHeight) &#123;</span><br><span class="line">scrollParent = parentElement;</span><br><span class="line">targetElement.fastClickScrollParent = parentElement;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentElement = parentElement.parentElement;</span><br><span class="line">&#125; while (parentElement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 给滚动容器加个标志fastClickLastScrollTop，值为其当前垂直滚动偏移</span><br><span class="line">if(scrollParent) &#123;</span><br><span class="line">scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回目标元素</span><br><span class="line"> */</span><br><span class="line">FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) &#123;</span><br><span class="line"></span><br><span class="line">// 一些较老的浏览器，target 可能会是一个文本节点，得返回其DOM节点</span><br><span class="line">if(eventTarget.nodeType === Node.TEXT_NODE) &#123;</span><br><span class="line">return eventTarget.parentNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return eventTarget;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FastClick.prototype.onTouchStart = function(event) &#123;</span><br><span class="line">var targetElement, touch, selection;</span><br><span class="line"></span><br><span class="line">// 多指触控的手势则忽略</span><br><span class="line">if(event.targetTouches.length &gt; 1) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">targetElement = this.getTargetElementFromEventTarget(event.target); //一些较老的浏览器，target 可能会是一个文本节点，得返回其DOM节点</span><br><span class="line">touch = event.targetTouches[0];</span><br><span class="line"></span><br><span class="line">if(deviceIsIOS) &#123; //IOS处理</span><br><span class="line"></span><br><span class="line">// 若用户已经选中了一些内容（比如选中了一段文本打算复制），则忽略</span><br><span class="line">selection = window.getSelection();</span><br><span class="line">if(selection.rangeCount &amp;&amp; !selection.isCollapsed) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!deviceIsIOS4) &#123; //是否IOS4</span><br><span class="line"></span><br><span class="line">//怪异特性处理——若click事件回调打开了一个alert/confirm，用户下一次tap页面的其它地方时，新的touchstart和touchend</span><br><span class="line">//事件会拥有同一个touch.identifier（新的 touch event 会跟上一次触发alert点击的 touch event 一样），</span><br><span class="line">//为避免将新的event当作之前的event导致问题，这里需要禁用默认事件</span><br><span class="line">//另外chrome的开发工具启用&apos;Emulate touch events&apos;后，iOS UA下的 identifier 会变成0，所以要做容错避免调试过程也被禁用事件了</span><br><span class="line">if(touch.identifier &amp;&amp; touch.identifier === this.lastTouchIdentifier) &#123;</span><br><span class="line">event.preventDefault();</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.lastTouchIdentifier = touch.identifier;</span><br><span class="line"></span><br><span class="line">// 如果target是一个滚动容器里的一个子元素(使用了 -webkit-overflow-scrolling: touch) ，而且满足:</span><br><span class="line">// 1) 用户非常快速地滚动外层滚动容器</span><br><span class="line">// 2) 用户通过tap停止住了这个快速滚动</span><br><span class="line">// 这时候最后的&apos;touchend&apos;的event.target会变成用户最终手指下的那个元素</span><br><span class="line">// 所以当快速滚动开始的时候，需要做检查target是否滚动容器的子元素，如果是，做个标记</span><br><span class="line">// 在touchend时检查这个标记的值（滚动容器的scrolltop）是否改变了，如果是则说明页面在滚动中，需要取消fastclick处理</span><br><span class="line">this.updateScrollParent(targetElement);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.trackingClick = true; //做个标志表示开始追踪click事件了</span><br><span class="line">this.trackingClickStart = event.timeStamp; //标记下touch事件开始的时间戳</span><br><span class="line">this.targetElement = targetElement;</span><br><span class="line"></span><br><span class="line">//标记touch起始点的页面偏移值</span><br><span class="line">this.touchStartX = touch.pageX;</span><br><span class="line">this.touchStartY = touch.pageY;</span><br><span class="line"></span><br><span class="line">// this.lastClickTime 是在 touchend 里标记的事件时间戳</span><br><span class="line">// this.tapDelay 为常量 200 （ms）</span><br><span class="line">// 此举用来避免 phantom 的双击（200ms内快速点了两次）触发 click</span><br><span class="line">// 反正200ms内的第二次点击会禁止触发点击的默认事件</span><br><span class="line">if((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123;</span><br><span class="line">event.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//判断是否移动了</span><br><span class="line">//this.touchBoundary是常量，值为10</span><br><span class="line">//如果touch已经移动了10个偏移量单位，则应当作为移动事件处理而非click事件</span><br><span class="line">FastClick.prototype.touchHasMoved = function(event) &#123;</span><br><span class="line">var touch = event.changedTouches[0],</span><br><span class="line">boundary = this.touchBoundary;</span><br><span class="line"></span><br><span class="line">if(Math.abs(touch.pageX - this.touchStartX) &gt; boundary || Math.abs(touch.pageY - this.touchStartY) &gt; boundary) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FastClick.prototype.onTouchMove = function(event) &#123;</span><br><span class="line">//不是需要被追踪click的事件则忽略</span><br><span class="line">if(!this.trackingClick) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果target突然改变了，或者用户其实是在移动手势而非想要click</span><br><span class="line">// 则应该清掉this.trackingClick和this.targetElement，告诉后面的事件你们也不用处理了</span><br><span class="line">if(this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) &#123;</span><br><span class="line">this.trackingClick = false;</span><br><span class="line">this.targetElement = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//找到label标签所映射的组件，方便让用户点label的时候直接激活该组件</span><br><span class="line">FastClick.prototype.findControl = function(labelElement) &#123;</span><br><span class="line"></span><br><span class="line">// 有缓存则直接读缓存着的</span><br><span class="line">if(labelElement.control !== undefined) &#123;</span><br><span class="line">return labelElement.control;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取指向的组件</span><br><span class="line">if(labelElement.htmlFor) &#123;</span><br><span class="line">return document.getElementById(labelElement.htmlFor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 没有for属性则激活页面第一个组件（labellable 元素）</span><br><span class="line">return labelElement.querySelector(&apos;button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FastClick.prototype.onTouchEnd = function(event) &#123;</span><br><span class="line">var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;</span><br><span class="line"></span><br><span class="line">if(!this.trackingClick) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 避免 phantom 的双击（200ms内快速点了两次）触发 click</span><br><span class="line">// 我们在 ontouchstart 里已经做过一次判断了（仅仅禁用默认事件），这里再做一次判断</span><br><span class="line">if((event.timeStamp - this.lastClickTime) &lt; this.tapDelay) &#123;</span><br><span class="line">this.cancelNextClick = true; //该属性会在 onMouse 事件中被判断，为true则彻底禁用事件和冒泡</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//this.tapTimeout是常量，值为700</span><br><span class="line">//识别是否为长按事件，如果是（大于700ms）则忽略</span><br><span class="line">if((event.timeStamp - this.trackingClickStart) &gt; this.tapTimeout) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 得重置为false，避免input事件被意外取消</span><br><span class="line">// 例子见 https://github.com/ftlabs/fastclick/issues/156</span><br><span class="line">this.cancelNextClick = false;</span><br><span class="line"></span><br><span class="line">this.lastClickTime = event.timeStamp; //标记touchend时间，方便下一次的touchstart做双击校验</span><br><span class="line"></span><br><span class="line">trackingClickStart = this.trackingClickStart;</span><br><span class="line">//重置 this.trackingClick 和 this.trackingClickStart</span><br><span class="line">this.trackingClick = false;</span><br><span class="line">this.trackingClickStart = 0;</span><br><span class="line"></span><br><span class="line">// iOS 6.0-7.*版本下有个问题 —— 如果layer处于transition或scroll过程，event所提供的target是不正确的</span><br><span class="line">// 所以咱们得重找 targetElement（这里通过 document.elementFromPoint 接口来寻找）</span><br><span class="line">if(deviceIsIOSWithBadTarget) &#123; //iOS 6.0-7.*版本</span><br><span class="line">touch = event.changedTouches[0]; //手指离开前的触点</span><br><span class="line"></span><br><span class="line">// 有些情况下 elementFromPoint 里的参数是预期外/不可用的, 所以还得避免 targetElement 为 null</span><br><span class="line">targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;</span><br><span class="line">// target可能不正确需要重找，但fastClickScrollParent是不会变的</span><br><span class="line">targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">targetTagName = targetElement.tagName.toLowerCase();</span><br><span class="line">if(targetTagName === &apos;label&apos;) &#123; //是label则激活其指向的组件</span><br><span class="line">forElement = this.findControl(targetElement);</span><br><span class="line">if(forElement) &#123;</span><br><span class="line">this.focus(targetElement);</span><br><span class="line">//安卓直接返回（无需合成click事件触发，因为点击和激活元素不同，不存在点透）</span><br><span class="line">if(deviceIsAndroid) &#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">targetElement = forElement;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if(this.needsFocus(targetElement)) &#123; //非label则识别是否需要focus的元素</span><br><span class="line"></span><br><span class="line">//手势停留在组件元素时长超过100ms，则置空this.targetElement并返回</span><br><span class="line">//（而不是通过调用this.focus来触发其聚焦事件，走的原生的click/focus事件触发流程）</span><br><span class="line">//这也是为何文章开头提到的问题中，稍微久按一点（超过100ms）textarea是可以把光标定位在正确的地方的原因</span><br><span class="line">//另外iOS下有个意料之外的bug——如果被点击的元素所在文档是在iframe中的，手动调用其focus的话，</span><br><span class="line">//会发现你往其中输入的text是看不到的（即使value做了更新），so这里也直接返回</span><br><span class="line">if((event.timeStamp - trackingClickStart) &gt; 100 || (deviceIsIOS &amp;&amp; window.top !== window &amp;&amp; targetTagName === &apos;input&apos;)) &#123;</span><br><span class="line">this.targetElement = null;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.focus(targetElement);</span><br><span class="line">this.sendClick(targetElement, event); //立即触发其click事件，而无须等待300ms</span><br><span class="line"></span><br><span class="line">//iOS4下的 select 元素不能禁用默认事件（要确保它能被穿透），否则不会打开select目录</span><br><span class="line">//有时候 iOS6/7 下（VoiceOver开启的情况下）也会如此</span><br><span class="line">if(!deviceIsIOS || targetTagName !== &apos;select&apos;) &#123;</span><br><span class="line">this.targetElement = null;</span><br><span class="line">event.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(deviceIsIOS &amp;&amp; !deviceIsIOS4) &#123;</span><br><span class="line"></span><br><span class="line">// 滚动容器的垂直滚动偏移改变了，说明是容器在做滚动而非点击，则忽略</span><br><span class="line">scrollParent = targetElement.fastClickScrollParent;</span><br><span class="line">if(scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看元素是否无需处理的白名单内（比如加了名为“needsclick”的class）</span><br><span class="line">// 不是白名单的则照旧预防穿透处理，立即触发合成的click事件</span><br><span class="line">if(!this.needsClick(targetElement)) &#123;</span><br><span class="line">event.preventDefault();</span><br><span class="line">this.sendClick(targetElement, event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FastClick.prototype.onTouchCancel = function() &#123;</span><br><span class="line">this.trackingClick = false;</span><br><span class="line">this.targetElement = null;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//用于决定是否允许穿透事件（触发layer的click默认事件）</span><br><span class="line">FastClick.prototype.onMouse = function(event) &#123;</span><br><span class="line"></span><br><span class="line">// touch事件一直没触发</span><br><span class="line">if(!this.targetElement) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(event.forwardedTouchEvent) &#123; //触发的click事件是合成的</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 编程派生的事件所对应元素事件可以被允许</span><br><span class="line">// 确保其没执行过 preventDefault 方法（event.cancelable 不为 true）即可</span><br><span class="line">if(!event.cancelable) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要做预防穿透处理的元素，或者做了快速（200ms）双击的情况</span><br><span class="line">if(!this.needsClick(this.targetElement) || this.cancelNextClick) &#123;</span><br><span class="line">//停止当前默认事件和冒泡</span><br><span class="line">if(event.stopImmediatePropagation) &#123;</span><br><span class="line">event.stopImmediatePropagation();</span><br><span class="line">&#125; else &#123;</span><br><span class="line"></span><br><span class="line">// 不支持 stopImmediatePropagation 的设备(比如Android 2)做标记，</span><br><span class="line">// 确保该事件回调不会执行（见126行）</span><br><span class="line">event.propagationStopped = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取消事件和冒泡</span><br><span class="line">event.stopPropagation();</span><br><span class="line">event.preventDefault();</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//允许穿透</span><br><span class="line">return true;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//click事件常规都是touch事件衍生来的，也排在touch后面触发。</span><br><span class="line">//对于那些我们在touch事件过程没有禁用掉默认事件的event来说，我们还需要在click的捕获阶段进一步</span><br><span class="line">//做判断决定是否要禁掉点击事件（防穿透）</span><br><span class="line">FastClick.prototype.onClick = function(event) &#123;</span><br><span class="line">var permitted;</span><br><span class="line"></span><br><span class="line">// 如果还有 trackingClick 存在，可能是某些UI事件阻塞了touchEnd 的执行</span><br><span class="line">if(this.trackingClick) &#123;</span><br><span class="line">this.targetElement = null;</span><br><span class="line">this.trackingClick = false;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 依旧是对 iOS 怪异行为的处理 —— 如果用户点击了iOS模拟器里某个表单中的一个submit元素</span><br><span class="line">// 或者点击了弹出来的键盘里的“Go”按钮，会触发一个“伪”click事件（target是一个submit-type的input元素）</span><br><span class="line">if(event.target.type === &apos;submit&apos; &amp;&amp; event.detail === 0) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">permitted = this.onMouse(event);</span><br><span class="line"></span><br><span class="line">if(!permitted) &#123; //如果点击是被允许的，将this.targetElement置空可以确保onMouse事件里不会阻止默认事件</span><br><span class="line">this.targetElement = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//没有多大意义</span><br><span class="line">return permitted;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//销毁Fastclick所注册的监听事件。是给外部实例去调用的</span><br><span class="line">FastClick.prototype.destroy = function() &#123;</span><br><span class="line">var layer = this.layer;</span><br><span class="line"></span><br><span class="line">if(deviceIsAndroid) &#123;</span><br><span class="line">layer.removeEventListener(&apos;mouseover&apos;, this.onMouse, true);</span><br><span class="line">layer.removeEventListener(&apos;mousedown&apos;, this.onMouse, true);</span><br><span class="line">layer.removeEventListener(&apos;mouseup&apos;, this.onMouse, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">layer.removeEventListener(&apos;click&apos;, this.onClick, true);</span><br><span class="line">layer.removeEventListener(&apos;touchstart&apos;, this.onTouchStart, false);</span><br><span class="line">layer.removeEventListener(&apos;touchmove&apos;, this.onTouchMove, false);</span><br><span class="line">layer.removeEventListener(&apos;touchend&apos;, this.onTouchEnd, false);</span><br><span class="line">layer.removeEventListener(&apos;touchcancel&apos;, this.onTouchCancel, false);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//是否没必要使用到 Fastclick 的检测</span><br><span class="line">FastClick.notNeeded = function(layer) &#123;</span><br><span class="line">var metaViewport;</span><br><span class="line">var chromeVersion;</span><br><span class="line">var blackberryVersion;</span><br><span class="line">var firefoxVersion;</span><br><span class="line"></span><br><span class="line">// 不支持触摸的设备</span><br><span class="line">if(typeof window.ontouchstart === &apos;undefined&apos;) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取Chrome版本号，若非Chrome则返回0</span><br><span class="line">chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];</span><br><span class="line"></span><br><span class="line">if(chromeVersion) &#123;</span><br><span class="line"></span><br><span class="line">if(deviceIsAndroid) &#123; //安卓</span><br><span class="line">metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line"></span><br><span class="line">if(metaViewport) &#123;</span><br><span class="line">// 安卓下，带有 user-scalable=&quot;no&quot; 的 meta 标签的 chrome 是会自动禁用 300ms 延迟的，所以无需 Fastclick</span><br><span class="line">if(metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">// 安卓Chrome 32 及以上版本，若带有 width=device-width 的 meta 标签也是无需 FastClick 的</span><br><span class="line">if(chromeVersion &gt; 31 &amp;&amp; document.documentElement.scrollWidth &lt;= window.outerWidth) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 其它的就肯定是桌面级的 Chrome 了，更不需要 FastClick 啦</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(deviceIsBlackBerry10) &#123; //黑莓，和上面安卓同理，就不写注释了</span><br><span class="line">blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);</span><br><span class="line"></span><br><span class="line">if(blackberryVersion[1] &gt;= 10 &amp;&amp; blackberryVersion[2] &gt;= 3) &#123;</span><br><span class="line">metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line"></span><br><span class="line">if(metaViewport) &#123;</span><br><span class="line">if(metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(document.documentElement.scrollWidth &lt;= window.outerWidth) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 带有 -ms-touch-action: none / manipulation 特性的 IE10 会禁用双击放大，也没有 300ms 时延</span><br><span class="line">if(layer.style.msTouchAction === &apos;none&apos; || layer.style.touchAction === &apos;manipulation&apos;) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Firefox检测，同上</span><br><span class="line">firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];</span><br><span class="line"></span><br><span class="line">if(firefoxVersion &gt;= 27) &#123;</span><br><span class="line"></span><br><span class="line">metaViewport = document.querySelector(&apos;meta[name=viewport]&apos;);</span><br><span class="line">if(metaViewport &amp;&amp; (metaViewport.content.indexOf(&apos;user-scalable=no&apos;) !== -1 || document.documentElement.scrollWidth &lt;= window.outerWidth)) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IE11 推荐使用没有“-ms-”前缀的 touch-action 样式特性名</span><br><span class="line">if(layer.style.touchAction === &apos;none&apos; || layer.style.touchAction === &apos;manipulation&apos;) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FastClick.attach = function(layer, options) &#123;</span><br><span class="line">return new FastClick(layer, options);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">if(typeof define === &apos;function&apos; &amp;&amp; typeof define.amd === &apos;object&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line"></span><br><span class="line">// AMD. Register as an anonymous module.</span><br><span class="line">define(function() &#123;</span><br><span class="line">return FastClick;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; else if(typeof module !== &apos;undefined&apos; &amp;&amp; module.exports) &#123;</span><br><span class="line">module.exports = FastClick.attach;</span><br><span class="line">module.exports.FastClick = FastClick;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">window.FastClick = FastClick;</span><br><span class="line">&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line">&lt;title&gt;Demo&lt;/title&gt;</span><br><span class="line">&lt;script src=&quot;./fastclick.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">div &#123;</span><br><span class="line">width: 200px;</span><br><span class="line">background: red;Y</span><br><span class="line">margin: 0 auto;</span><br><span class="line">height: 200px;</span><br><span class="line">color: wheat;</span><br><span class="line">font-size: 25px;</span><br><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;main&quot;&gt;FastClick&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">FastClick.attach(document.body);</span><br><span class="line">document.getElementById(&quot;main&quot;).addEventListener(&quot;click&quot;, function(event) &#123;</span><br><span class="line">console.log(event.target.innerText)</span><br><span class="line">&#125;, false)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> fastclick </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅说 XSS 和 CSRF</title>
      <link href="/2015/09/29/%E6%B5%85%E8%AF%B4-XSS-%E5%92%8C-CSRF/"/>
      <url>/2015/09/29/%E6%B5%85%E8%AF%B4-XSS-%E5%92%8C-CSRF/</url>
      
        <content type="html"><![CDATA[<p>在 Web 安全领域中，XSS 和 CSRF 是最常见的攻击方式。本文将会简单介绍 XSS 和 CSRF 的攻防问题。</p><blockquote><p>声明：本文的示例仅用于演示相关的攻击原理</p></blockquote><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>XSS，即 Cross Site Script，中译是跨站脚本攻击；其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。</p><p>XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。</p><p>攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。</p><p>XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。</p><h4 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h4><p>反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。</p><p>看一个示例。我先准备一个如下的静态页：</p><p><a href="https://user-images.githubusercontent.com/7871813/42720000-30a9b93a-8752-11e8-879b-edd8519f4e3e.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720000-30a9b93a-8752-11e8-879b-edd8519f4e3e.png" alt="反射型xss1"></a></p><p>恶意链接的地址指向了 <code>localhost:8001/?q=111&amp;p=222</code>。然后，我再启一个简单的 Node 服务处理恶意链接的请求：</p><pre><code>consthttp=require(&apos;http&apos;);functionhandleReequest(req, res) {    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);    res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;});    res.write(&apos;&lt;script&gt;alert(&quot;反射型 XSS 攻击&quot;)&lt;/script&gt;&apos;);    res.end();}constserver=newhttp.Server();server.listen(8001, &apos;127.0.0.1&apos;);server.on(&apos;request&apos;, handleReequest);</code></pre><p>当用户点击恶意链接时，页面跳转到攻击者预先准备的页面，会发现在攻击者的页面执行了 js 脚本：</p><p><a href="https://user-images.githubusercontent.com/7871813/42720046-ee5a3f40-8752-11e8-8cc5-8b464414864a.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720046-ee5a3f40-8752-11e8-8cc5-8b464414864a.png" alt="执行脚本"></a></p><p>这样就产生了反射型 XSS 攻击。攻击者可以注入任意的恶意脚本进行攻击，可能注入恶作剧脚本，或者注入能获取用户隐私数据(如cookie)的脚本，这取决于攻击者的目的。</p><h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4><p>存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。</p><p>比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</p><p>举一个示例。</p><p>先准备一个输入页面：</p><pre><code>&lt;input type=&quot;text&quot; id=&quot;input&quot;&gt;&lt;button id=&quot;btn&quot;&gt;Submit&lt;/button&gt;   &lt;script&gt;    const input = document.getElementById(&apos;input&apos;);    const btn = document.getElementById(&apos;btn&apos;);    let val;    input.addEventListener(&apos;change&apos;, (e) =&gt; {        val = e.target.value;    }, false);    btn.addEventListener(&apos;click&apos;, (e) =&gt; {        fetch(&apos;http://localhost:8001/save&apos;, {            method: &apos;POST&apos;,            body: val        });    }, false);&lt;/script&gt;     </code></pre><p>启动一个 Node 服务监听 <code>save</code> 请求。为了简化，用一个变量来保存用户的输入：</p><pre><code>consthttp=require(&apos;http&apos;);let userInput =&apos;&apos;;functionhandleReequest(req, res) {    constmethod=req.method;    res.setHeader(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);    res.setHeader(&apos;Access-Control-Allow-Headers&apos;, &apos;Content-Type&apos;)    if (method ===&apos;POST&apos;&amp;&amp;req.url===&apos;/save&apos;) {        let body =&apos;&apos;;        req.on(&apos;data&apos;, chunk=&gt; {            body += chunk;        });        req.on(&apos;end&apos;, () =&gt; {            if (body) {                userInput = body;            }            res.end();        });    } else {        res.writeHead(200, {&apos;Content-Type&apos;:&apos;text/html; charset=UTF-8&apos;});        res.write(userInput);        res.end();    }}constserver=newhttp.Server();server.listen(8001, &apos;127.0.0.1&apos;);server.on(&apos;request&apos;, handleReequest);</code></pre><p>当用户点击提交按钮将输入信息提交到服务端时，服务端通过 <code>userInput</code> 变量保存了输入内容。当用户通过 <code>http://localhost:8001/${id}</code> 访问时，服务端会返回与 <code>id</code> 对应的内容(本示例简化了处理)。如果用户输入了恶意脚本内容，则其他用户访问该内容时，恶意脚本就会在浏览器端执行：</p><p><a href="https://user-images.githubusercontent.com/7871813/42720476-eb71a5c8-8759-11e8-8763-eb08b3480201.gif" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42720476-eb71a5c8-8759-11e8-8763-eb08b3480201.gif" alt="存储型xss"></a></p><h4 id="基于DOM"><a href="#基于DOM" class="headerlink" title="基于DOM"></a>基于DOM</h4><p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。</p><p>看如下代码：</p><pre><code>&lt;h2&gt;XSS: &lt;/h2&gt;&lt;inputtype=&quot;text&quot;id=&quot;input&quot;&gt;&lt;buttonid=&quot;btn&quot;&gt;Submit&lt;/button&gt;&lt;divid=&quot;div&quot;&gt;&lt;/div&gt;&lt;script&gt;constinput=document.getElementById(&apos;input&apos;);constbtn=document.getElementById(&apos;btn&apos;);constdiv=document.getElementById(&apos;div&apos;);let val;input.addEventListener(&apos;change&apos;, (e) =&gt; {        val =e.target.value;    }, false);btn.addEventListener(&apos;click&apos;, () =&gt; {div.innerHTML=`&lt;ahref=${val}&gt;testLink&lt;/a&gt;`    }, false);&lt;/script&gt;</code></pre><p>点击 <code>Submit</code> 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：</p><pre><code>&apos;&apos; onclick=alert(/xss/)</code></pre><p>用户提交之后，页面代码就变成了：</p><pre><code>&lt;ahrefonlick=&quot;alert(/xss/)&quot;&gt;testLink&lt;/a&gt;</code></pre><p>此时，用户点击生成的链接，就会执行对应的脚本：</p><p><a href="https://user-images.githubusercontent.com/7871813/42721109-cb7ce572-8766-11e8-96d9-9ada8a787827.gif" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42721109-cb7ce572-8766-11e8-96d9-9ada8a787827.gif" alt="dom-xss"></a></p><h3 id="XSS-攻击的防范"><a href="#XSS-攻击的防范" class="headerlink" title="XSS 攻击的防范"></a>XSS 攻击的防范</h3><p>现在主流的浏览器内置了防范 XSS 的措施，例如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">CSP</a>。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。</p><h4 id="HttpOnly-防止劫取-Cookie"><a href="#HttpOnly-防止劫取-Cookie" class="headerlink" title="HttpOnly 防止劫取 Cookie"></a>HttpOnly 防止劫取 Cookie</h4><p>HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。</p><p>上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。</p><h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p><strong>不要相信用户的任何输入。</strong> 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。</p><p>在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 <code>&lt;</code>，<code>&gt;</code> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。</p><p>而在一些前端框架中，都会有一份 <code>decodingMap</code>， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <code>&lt;</code>，<code>&gt;</code>，<code>script</code>，防止 XSS 攻击：</p><pre><code>// vuejs 中的 decodingMap// 在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉const decodingMap = {  &apos;&amp;lt;&apos;: &apos;&lt;&apos;,  &apos;&amp;gt;&apos;: &apos;&gt;&apos;,  &apos;&amp;quot;&apos;: &apos;&quot;&apos;,  &apos;&amp;amp;&apos;: &apos;&amp;&apos;,  &apos;&amp;#10;&apos;: &apos;\n&apos;}</code></pre><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 <a href="https://github.com/punkave/sanitize-html" target="_blank" rel="noopener">sanitize-html</a> 对输出内容进行有规则的过滤之后再输出到页面中。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。</p><p>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>在举例子之前，先说说浏览器的 Cookie 策略。</p><h3 id="浏览器的-Cookie-策略"><a href="#浏览器的-Cookie-策略" class="headerlink" title="浏览器的 Cookie 策略"></a>浏览器的 Cookie 策略</h3><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>个性化设置（如用户自定义设置、主题等）</li></ul><p>而浏览器所持有的 Cookie 分为两种：</p><ul><li>Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。</li><li><p>Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。</p><p>  res.setHeader(‘Set-Cookie’, [‘mycookie=222’, ‘test=3333; expires=Sat, 21 Jul 2018 00:00:00 GMT;’]);</p></li></ul><p>上述代码创建了两个 Cookie：<code>mycookie</code> 和 <code>test</code>，前者属于会话期 Cookie，后者则属于持久性 Cookie。当我们去查看 Cookie 相关的属性时，不同的浏览器对会话期 Cookie 的 <code>Expires</code> 属性值会不一样：</p><p>Firefox：</p><p><a href="https://user-images.githubusercontent.com/7871813/42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733717-fe5c16fe-8868-11e8-979b-37aaf8311375.png" alt="firefox cookie"></a></p><p>Chrome:</p><p><a href="https://user-images.githubusercontent.com/7871813/42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733724-1e22c6ae-8869-11e8-9f84-0fbc2d2fdeb7.png" alt="chrome cookie"></a></p><p>此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 <code>donmain</code> 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。</p><h3 id="通过-Cookie-进行-CSRF-攻击"><a href="#通过-Cookie-进行-CSRF-攻击" class="headerlink" title="通过 Cookie 进行 CSRF 攻击"></a>通过 Cookie 进行 CSRF 攻击</h3><p>假设有一个 bbs 站点：<code>http://www.c.com</code>，当登录后的用户发起如下 GET 请求时，会删除 ID 指定的帖子：</p><pre><code>http://www.c.com:8002/content/delete/:id</code></pre><p>如发起 <code>http://www.c.com:8002/content/delete/87343</code> 请求时，会删除 id 为 87343 的帖子。当用户登录之后，会设置如下 cookie：</p><pre><code>res.setHeader(&apos;Set-Cookie&apos;, [&apos;user=22333; expires=Sat, 21 Jul 2018 00:00:00 GMT;&apos;]);</code></pre><p><a href="https://user-images.githubusercontent.com/7871813/42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42733982-62308f16-886e-11e8-9c59-c3b0352b0002.png" alt="user"></a></p><p><code>user</code> 对应的值是用户 ID。然后构造一个页面 A：</p><pre><code>&lt;p&gt;CSRF 攻击者准备的网站：&lt;/p&gt;&lt;img src=&quot;http://www.c.com:8002/content/delete/87343&quot;&gt;</code></pre><p>页面 A 使用了一个 <code>img</code> 标签，其地址指向了删除用户帖子的链接：</p><p><a href="https://user-images.githubusercontent.com/7871813/42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42734074-38bc206c-8870-11e8-8f93-2aa5c39d245e.png" alt="A"></a></p><p>可以看到，当登录用户访问攻击者的网站时，会向 <code>www.c.com</code> 发起一个删除用户帖子的请求。此时若用户在切换到 <code>www.c.com</code> 的帖子页面刷新，会发现ID 为 87343 的帖子已经被删除。</p><p>由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。</p><p>但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。</p><h3 id="CSRF-攻击的防范"><a href="#CSRF-攻击的防范" class="headerlink" title="CSRF 攻击的防范"></a>CSRF 攻击的防范</h3><p>当前，对 CSRF 攻击的防范措施主要有如下几种方式。</p><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。</p><p>从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。</p><p>但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。</p><h4 id="Referer-Check"><a href="#Referer-Check" class="headerlink" title="Referer Check"></a>Referer Check</h4><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。</p><p>比如，如果用户要删除自己的帖子，那么先要登录 <code>www.c.com</code>，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 <code>http://www.c.com</code>；当请求是从 <code>www.a.com</code> 发起时，Referer 的值是 <code>http://www.a.com</code> 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 <code>www.c.com</code> 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。</p><p>针对上文的例子，可以在服务端增加如下代码：</p><pre><code>if (req.headers.referer!==&apos;http://www.c.com:8002/&apos;) {    res.write(&apos;csrf 攻击&apos;);    return;}</code></pre><p><a href="https://user-images.githubusercontent.com/7871813/42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png" target="_blank" rel="noopener"><img src="https://user-images.githubusercontent.com/7871813/42734407-0f4c0728-8876-11e8-8565-21f89b01f6f0.png" alt="referer check"></a></p><p>Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。</p><h4 id="添加-token-验证"><a href="#添加-token-验证" class="headerlink" title="添加 token 验证"></a>添加 token 验证</h4><p>CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了 XSS 和 CSRF 的攻击原理和防御措施。当然，在 Web 安全领域，除了这两种常见的攻击方式，也存在这 SQL 注入等其它攻击方式，这不在本文的讨论范围之内，如果你对其感兴趣，可以阅读<a href="https://zhuanlan.zhihu.com/p/23569276" target="_blank" rel="noopener">SQL注入技术专题</a>的专栏详细了解相关信息。最后，总结一下 XSS 攻击和 CSRF 攻击的常见防御措施：</p><ol><li>防御 XSS 攻击</li></ol><ul><li>HttpOnly 防止劫取 Cookie</li><li>用户的输入检查</li><li>服务端的输出检查</li></ul><ol start="2"><li>防御 CSRF 攻击</li></ol><ul><li>验证码</li><li>Referer Check</li><li>Token 验证</li></ul><p>&lt;完&gt;</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Cross-site_scripting" target="_blank" rel="noopener">Cross-site scripting</a></li><li><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html" target="_blank" rel="noopener">CSRF 攻击的应对之道</a></li><li>《白帽子讲 Web 安全》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> xss </tag>
            
            <tag> csrf </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端常见跨域解决方案</title>
      <link href="/2015/09/22/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2015/09/22/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a>什么是跨域？</h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p><p>广义的跨域：</p><pre><code>1.) 资源跳转： A链接、重定向、表单提交2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</code></pre><p>其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p><p>什么是同源策略？<br>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><pre><code>1.) Cookie、LocalStorage 和 IndexDB 无法读取2.) DOM 和 Js对象无法获得3.) AJAX 请求不能发送</code></pre><h2 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h2><pre><code>URL                                      说明                    是否允许通信http://www.domain.com/a.jshttp://www.domain.com/b.js         同一域名，不同文件或路径           允许http://www.domain.com/lab/c.jshttp://www.domain.com:8000/a.jshttp://www.domain.com/b.js         同一域名，不同端口                不允许http://www.domain.com/a.jshttps://www.domain.com/b.js        同一域名，不同协议                不允许http://www.domain.com/a.jshttp://192.168.4.12/b.js           域名和域名对应相同ip              不允许http://www.domain.com/a.jshttp://x.domain.com/b.js           主域相同，子域不同                不允许http://domain.com/c.jshttp://www.domain1.com/a.jshttp://www.domain2.com/b.js        不同域名                         不允许</code></pre><h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p><h2 id="一、-通过jsonp跨域"><a href="#一、-通过jsonp跨域" class="headerlink" title="一、 通过jsonp跨域"></a>一、 通过jsonp跨域</h2><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p><p>1.）原生实现：</p><pre><code>&lt;script&gt;    var script = document.createElement(&apos;script&apos;);    script.type = &apos;text/javascript&apos;;    // 传参并指定回调执行函数为onBack    script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&apos;;    document.head.appendChild(script);    // 回调执行函数    function onBack(res) {        alert(JSON.stringify(res));    } &lt;/script&gt;</code></pre><p>服务端返回如下（返回时即执行全局函数）：</p><pre><code>onBack({&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;})</code></pre><p>2.）jquery ajax：</p><pre><code>$.ajax({    url: &apos;http://www.domain2.com:8080/login&apos;,    type: &apos;get&apos;,    dataType: &apos;jsonp&apos;,  // 请求方式为jsonp    jsonpCallback: &quot;onBack&quot;,    // 自定义回调函数名    data: {}});</code></pre><p>3.）vue.js：</p><pre><code>this.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;, {    params: {},    jsonp: &apos;onBack&apos;}).then((res) =&gt; {    console.log(res); })</code></pre><p>后端node.js代码示例：</p><pre><code>var querystring = require(&apos;querystring&apos;);var http = require(&apos;http&apos;);var server = http.createServer();server.on(&apos;request&apos;, function(req, res) {    var params = qs.parse(req.url.split(&apos;?&apos;)[1]);    var fn = params.callback;    // jsonp返回设置    res.writeHead(200, { &apos;Content-Type&apos;: &apos;text/javascript&apos; });    res.write(fn + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;);    res.end();});server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;);</code></pre><p>jsonp缺点：只能实现get一种请求。</p><h2 id="二、-document-domain-iframe跨域"><a href="#二、-document-domain-iframe跨域" class="headerlink" title="二、 document.domain + iframe跨域"></a>二、 document.domain + iframe跨域</h2><p>此方案仅限主域相同，子域不同的跨域应用场景。</p><p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p><p>1.）父窗口：(<a href="https://link.zhihu.com/?target=http%3A//www.domain.com/a.html%29" target="_blank" rel="noopener">http://www.domain.com/a.html)</a></p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    document.domain = &apos;domain.com&apos;;    var user = &apos;admin&apos;;&lt;/script&gt;</code></pre><p>2.）子窗口：(<a href="https://link.zhihu.com/?target=http%3A//child.domain.com/b.html%29" target="_blank" rel="noopener">http://child.domain.com/b.html)</a></p><pre><code>&lt;script&gt;    document.domain = &apos;domain.com&apos;;    // 获取父窗口中变量    alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);&lt;/script&gt;</code></pre><h2 id="三、-location-hash-iframe跨域"><a href="#三、-location-hash-iframe跨域" class="headerlink" title="三、 location.hash + iframe跨域"></a>三、 location.hash + iframe跨域</h2><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p><p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p><p>1.）a.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/a.html%29" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&apos;iframe&apos;);    // 向b.html传hash值    setTimeout(function() {        iframe.src = iframe.src + &apos;#user=admin&apos;;    }, 1000);    // 开放给同域c.html的回调方法    function onCallback(res) {        alert(&apos;data from c.html ---&gt; &apos; + res);    }&lt;/script&gt;</code></pre><p>2.）b.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain2.com/b.html%29" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;    var iframe = document.getElementById(&apos;iframe&apos;);    // 监听a.html传来的hash值，再传给c.html    window.onhashchange = function () {        iframe.src = iframe.src + location.hash;    };&lt;/script&gt;</code></pre><p>3.）c.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/c.html%29" target="_blank" rel="noopener">http://www.domain1.com/c.html)</a></p><pre><code>&lt;script&gt;    // 监听b.html传来的hash值    window.onhashchange = function () {        // 再通过操作同域a.html的js回调，将结果传回        window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;));    };&lt;/script&gt;</code></pre><h2 id="四、-window-name-iframe跨域"><a href="#四、-window-name-iframe跨域" class="headerlink" title="四、 window.name + iframe跨域"></a>四、 window.name + iframe跨域</h2><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p><p>1.）a.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/a.html%29" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p><pre><code>var proxy = function(url, callback) {    var state = 0;    var iframe = document.createElement(&apos;iframe&apos;);    // 加载跨域页面    iframe.src = url;    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name    iframe.onload = function() {        if (state === 1) {            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据            callback(iframe.contentWindow.name);            destoryFrame();        } else if (state === 0) {            // 第1次onload(跨域页)成功后，切换到同域代理页面            iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;;            state = 1;        }    };    document.body.appendChild(iframe);    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）    function destoryFrame() {        iframe.contentWindow.document.write(&apos;&apos;);        iframe.contentWindow.close();        document.body.removeChild(iframe);    }};// 请求跨域b页面数据proxy(&apos;http://www.domain2.com/b.html&apos;, function(data){    alert(data);});</code></pre><p>2.）proxy.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/proxy.html%29" target="_blank" rel="noopener">http://www.domain1.com/proxy….</a><br>中间代理页，与a.html同域，内容为空即可。</p><p>3.）b.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain2.com/b.html%29" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p><pre><code>&lt;script&gt;    window.name = &apos;This is domain2 data!&apos;;&lt;/script&gt;</code></pre><p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h2 id="五、-postMessage跨域"><a href="#五、-postMessage跨域" class="headerlink" title="五、 postMessage跨域"></a>五、 postMessage跨域</h2><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p><p>1.）a.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain1.com/a.html%29" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a></p><pre><code>&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;&lt;script&gt;           var iframe = document.getElementById(&apos;iframe&apos;);    iframe.onload = function() {        var data = {            name: &apos;aym&apos;        };        // 向domain2传送跨域数据        iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;);    };    // 接受domain2返回数据    window.addEventListener(&apos;message&apos;, function(e) {        alert(&apos;data from domain2 ---&gt; &apos; + e.data);    }, false);&lt;/script&gt;</code></pre><p>2.）b.html：(<a href="https://link.zhihu.com/?target=http%3A//www.domain2.com/b.html%29" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a></p><pre><code>&lt;script&gt;    // 接收domain1的数据    window.addEventListener(&apos;message&apos;, function(e) {        alert(&apos;data from domain1 ---&gt; &apos; + e.data);        var data = JSON.parse(e.data);        if (data) {            data.number = 16;            // 处理后再发回domain1            window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;);        }    }, false);&lt;/script&gt;</code></pre><h2 id="六、-跨域资源共享（CORS）"><a href="#六、-跨域资源共享（CORS）" class="headerlink" title="六、 跨域资源共享（CORS）"></a>六、 跨域资源共享（CORS）</h2><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p><p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p><h2 id="1、-前端设置："><a href="#1、-前端设置：" class="headerlink" title="1、 前端设置："></a>1、 前端设置：</h2><p>1.）原生ajax</p><pre><code>// 前端设置是否带cookiexhr.withCredentials = true;</code></pre><p>示例代码：</p><pre><code>var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);xhr.send(&apos;user=admin&apos;);xhr.onreadystatechange = function() {    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {        alert(xhr.responseText);    }};</code></pre><p>2.）jQuery ajax</p><pre><code>$.ajax({    ...   xhrFields: {       withCredentials: true    // 前端设置是否带cookie   },   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie    ...});</code></pre><p>3.）vue框架<br>在vue-resource封装的ajax组件中加入以下代码：</p><pre><code>Vue.http.options.credentials = true</code></pre><h2 id="2、-服务端设置："><a href="#2、-服务端设置：" class="headerlink" title="2、 服务端设置："></a>2、 服务端设置：</h2><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><p>1.）Java后台：</p><pre><code>/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;);  // 若有端口需写全（协议+域名+端口）response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</code></pre><p>2.）Nodejs后台示例：</p><pre><code>var http = require(&apos;http&apos;);var server = http.createServer();var qs = require(&apos;querystring&apos;);server.on(&apos;request&apos;, function(req, res) {    var postData = &apos;&apos;;    // 数据块接收中    req.addListener(&apos;data&apos;, function(chunk) {        postData += chunk;    });    // 数据接收完毕    req.addListener(&apos;end&apos;, function() {        postData = qs.parse(postData);        // 跨域后台设置        res.writeHead(200, {            &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;,     // 后端允许发送Cookie            &apos;Access-Control-Allow-Origin&apos;: &apos;http://www.domain1.com&apos;,    // 允许访问的域（协议+域名+端口）            &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取cookie        });        res.write(JSON.stringify(postData));        res.end();    });});server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;);</code></pre><h2 id="七、-nginx代理跨域"><a href="#七、-nginx代理跨域" class="headerlink" title="七、 nginx代理跨域"></a>七、 nginx代理跨域</h2><h2 id="1、-nginx配置解决iconfont跨域"><a href="#1、-nginx配置解决iconfont跨域" class="headerlink" title="1、 nginx配置解决iconfont跨域"></a>1、 nginx配置解决iconfont跨域</h2><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><pre><code>location / {  add_header Access-Control-Allow-Origin *;}</code></pre><h2 id="2、-nginx反向代理接口跨域"><a href="#2、-nginx反向代理接口跨域" class="headerlink" title="2、 nginx反向代理接口跨域"></a>2、 nginx反向代理接口跨域</h2><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：</p><pre><code>#proxy服务器server {    listen       81;    server_name  www.domain1.com;    location / {        proxy_pass   http://www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    }}</code></pre><p>1.) 前端代码示例：</p><pre><code>var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);xhr.send();</code></pre><p>2.) Nodejs后台示例：</p><pre><code>var http = require(&apos;http&apos;);var server = http.createServer();var qs = require(&apos;querystring&apos;);server.on(&apos;request&apos;, function(req, res) {    var params = qs.parse(req.url.substring(2));    // 向前台写cookie    res.writeHead(200, {        &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取    });    res.write(JSON.stringify(params));    res.end();});server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;);</code></pre><h2 id="八、-Nodejs中间件代理跨域"><a href="#八、-Nodejs中间件代理跨域" class="headerlink" title="八、 Nodejs中间件代理跨域"></a>八、 Nodejs中间件代理跨域</h2><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p><h2 id="1、-非vue框架的跨域（2次跨域）"><a href="#1、-非vue框架的跨域（2次跨域）" class="headerlink" title="1、 非vue框架的跨域（2次跨域）"></a>1、 非vue框架的跨域（2次跨域）</h2><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p><p>1.）前端代码示例：</p><pre><code>var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true);xhr.send();</code></pre><p>2.）中间件服务器：</p><pre><code>var express = require(&apos;express&apos;);var proxy = require(&apos;http-proxy-middleware&apos;);var app = express();app.use(&apos;/&apos;, proxy({    // 代理跨域目标接口    target: &apos;http://www.domain2.com:8080&apos;,    changeOrigin: true,    // 修改响应头信息，实现跨域并允许带cookie    onProxyRes: function(proxyRes, req, res) {        res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;);        res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);    },    // 修改响应信息中的cookie域名    cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改}));app.listen(3000);console.log(&apos;Proxy server is listen at port 3000...&apos;);</code></pre><p>3.）Nodejs后台同（六：nginx）</p><h2 id="2、-vue框架的跨域（1次跨域）"><a href="#2、-vue框架的跨域（1次跨域）" class="headerlink" title="2、 vue框架的跨域（1次跨域）"></a>2、 vue框架的跨域（1次跨域）</h2><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><p>webpack.config.js部分配置：</p><pre><code>module.exports = {    entry: {},    module: {},    ...    devServer: {        historyApiFallback: true,        proxy: [{            context: &apos;/login&apos;,            target: &apos;http://www.domain2.com:8080&apos;,  // 代理跨域目标接口            changeOrigin: true,            cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改        }],        noInfo: true    }}</code></pre><h2 id="九、-WebSocket协议跨域"><a href="#九、-WebSocket协议跨域" class="headerlink" title="九、 WebSocket协议跨域"></a>九、 WebSocket协议跨域</h2><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用<a href="https://link.zhihu.com/?target=http%3A//Socket.io" target="_blank" rel="noopener">http://Socket.io</a>，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p><p>1.）前端代码：</p><pre><code>&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;&lt;script&gt;var socket = io(&apos;http://www.domain2.com:8080&apos;);// 连接成功处理socket.on(&apos;connect&apos;, function() {    // 监听服务端消息    socket.on(&apos;message&apos;, function(msg) {        console.log(&apos;data from server: ---&gt; &apos; + msg);     });    // 监听服务端关闭    socket.on(&apos;disconnect&apos;, function() {         console.log(&apos;Server socket has closed.&apos;);     });});document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() {    socket.send(this.value);};&lt;/script&gt;</code></pre><p>2.）Nodejs socket后台：</p><pre><code>var http = require(&apos;http&apos;);var socket = require(&apos;socket.io&apos;);// 启http服务var server = http.createServer(function(req, res) {    res.writeHead(200, {        &apos;Content-type&apos;: &apos;text/html&apos;    });    res.end();});server.listen(&apos;8080&apos;);console.log(&apos;Server is running at port 8080...&apos;);// 监听socket连接socket.listen(server).on(&apos;connection&apos;, function(client) {    // 接收信息    client.on(&apos;message&apos;, function(msg) {        client.send(&apos;hello：&apos; + msg);        console.log(&apos;data from client: ---&gt; &apos; + msg);    });    // 断开处理    client.on(&apos;disconnect&apos;, function() {        console.log(&apos;Client socket has closed.&apos;);     });}); </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 中的 this !</title>
      <link href="/2015/08/31/JavaScript-%E4%B8%AD%E7%9A%84-this/"/>
      <url>/2015/08/31/JavaScript-%E4%B8%AD%E7%9A%84-this/</url>
      
        <content type="html"><![CDATA[<p>在 js 中，this 这个上下文总是变化莫测，很多时候出现 bug 总是一头雾水，其实，只要分清楚不同的情况下如何执行就 ok 了。</p><p><img src="https://pic4.zhimg.com/v2-3068deaab983c4e925d5b325985ce9e9_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3068deaab983c4e925d5b325985ce9e9_hd.jpg" alt=""></p><h2 id="全局执行"><a href="#全局执行" class="headerlink" title="全局执行"></a>全局执行</h2><p>首先，我们在全局环境中看看它的 this 是什么：</p><p>first. 浏览器：</p><pre><code>console.log(this);// Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}</code></pre><p>可以看到打印出了 window 对象；</p><p>second. node：</p><pre><code>console.log(this);// global</code></pre><p>可以看到打印出了 global 对象；</p><p>总结：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。</p><h2 id="函数中执行"><a href="#函数中执行" class="headerlink" title="函数中执行"></a>函数中执行</h2><h2 id="纯粹的函数调用"><a href="#纯粹的函数调用" class="headerlink" title="纯粹的函数调用"></a>纯粹的函数调用</h2><p>这是最普通的函数使用方法了：</p><pre><code>function test() {  console.log(this);};test();// Window {speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…}</code></pre><p>我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象；</p><p>严格模式 ‘use strict’;</p><p>如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为：</p><pre><code>&apos;use strict&apos;;function test() {  console.log(this);};test();// undefined</code></pre><p>当然，把它放在一个立即执行函数中会更好，避免了污染全局：</p><pre><code>(function (){  &quot;use strict&quot;;　console.log(this);})();// undefined</code></pre><h2 id="作为对象的方法调用"><a href="#作为对象的方法调用" class="headerlink" title="作为对象的方法调用"></a>作为对象的方法调用</h2><p>当一个函数被当作一个对象的方法调用的时候：</p><pre><code>var obj = {  name: &apos;qiutc&apos;,  foo: function() {    console.log(this.name);  }}obj.foo();// &apos;qiutc&apos;</code></pre><p>这时候，this 指向当前的这个对象；</p><p>当然，我们还可以这么做：</p><pre><code>function test() {  console.log(this.name);}var obj = {  name: &apos;qiutc&apos;,  foo: test}obj.foo();// &apos;qiutc&apos;</code></pre><p>同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 test ，它只是一个函数名，函数的引用，它指向这个函数，当 foo = test，foo 同样也指向了这个函数。</p><p>如果把对象的方法赋值给一个变量，然后直接调用这个变量呢：</p><pre><code>var obj = {  name: &apos;qiutc&apos;,  foo: function() {    console.log(this);  }}var test = obj.foo;test();// Window</code></pre><p>可以看到，这时候 this 执行了全局，当我们把 test = obj.foo ，test 直接指向了一个函数的引用，这时候，其实和 obj 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，this 指向全局对象。</p><p>一些坑</p><p>我们经常在回调函数里面会遇到一些坑：</p><pre><code>var obj = {  name: &apos;qiutc&apos;,  foo: function() {    console.log(this);  },  foo2: function() {    console.log(this);   //Object {name: &quot;qiutc&quot;...}    setTimeout(this.foo, 1000);   // window 对象  }}obj.foo2();</code></pre><p><img src="https://pic1.zhimg.com/v2-2099857fcaab02a66d655f172d12cf82_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-2099857fcaab02a66d655f172d12cf82_hd.jpg" alt=""></p><p>执行这段代码我们会发现两次打印出来的 this 是不一样的：</p><p>关于setTimeout的this指向：<a href="https://link.zhihu.com/?target=https%3A//www.talkingcoder.com/article/6356947525374513523" target="_blank" rel="noopener">https://www.talkingcoder.com/article/6356947525374513523</a></p><pre><code>第一次是 foo2 中直接打印 this，这里指向 obj 这个对象，我们毋庸置疑；</code></pre><p>但是在 setTimeout 中执行的 this.foo，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑；<br>其实，setTimeout 也只是一个函数而已，函数必然有可能需要参数，我们把 this.foo 当作一个参数传给 setTimeout 这个函数，就像它需要一个 fun 参数，在传入参数的时候，其实做了个这样的操作 fun = this.foo，看到没有，这里我们直接把 fun 指向 this.foo 的引用；执行的时候其实是执行了 fun() 所以已经和 obj 无关了，它是被当作普通函数直接调用的，因此 this 指向全局对象。</p><p>这个问题是很多异步回调函数中普遍会碰到的；</p><p>解决</p><p>为了解决这个问题，我们可以利用 闭包 的特性来处理：</p><pre><code>var obj = {  name: &apos;qiutc&apos;,  foo: function() {    console.log(this);  },  foo2: function() {    console.log(this);    var _this = this;    setTimeout(function() {      console.log(this);  // Window      console.log(_this);  // Object {name: &quot;qiutc&quot;}    }, 1000);  }}obj.foo2();</code></pre><p>可以看到直接用 this 仍然是 Window；因为 foo2 中的 this 是指向 obj，我们可以先用一个变量 _this 来储存，然后在回调函数中使用 _this，就可以指向当前的这个对象了；</p><p>setTimeout 的另一个坑</p><p>之前啊说过，如果直接执行回调函数而没有绑定作用域，那么它的 this 是指向全局对象(window)，在严格模式下会指向 undefined，然而在 setTimeout 中的回调函数在严格模式下却表现出不同：</p><pre><code>&apos;use strict&apos;;function foo() {  console.log(this);}setTimeout(foo, 1);// window</code></pre><p>按理说我们加了严格模式，foo 调用也没有指定 this，应该是出来 undefined，但是这里仍然出现了全局对象，难道是严格模式失效了吗？</p><p>并不，即使在严格模式下，setTimeout 方法在调用传入函数的时候，如果这个函数没有指定了的 this，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 foo.apply(window) 而非 foo()；</p><p>当然，如果我们在传入函数的时候已经指定 this，那么就不会被注入全局对象，比如： setTimeout(foo.bind(obj), 1);；</p><p><a href="https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code" target="_blank" rel="noopener">http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code</a></p><h2 id="作为一个构造函数使用"><a href="#作为一个构造函数使用" class="headerlink" title="作为一个构造函数使用"></a>作为一个构造函数使用</h2><p>在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 new 这个关键字：</p><pre><code>function Person(name) {  this.name = name;  console.log(this);}var p = new Person(&apos;qiutc&apos;);// Person {name: &quot;qiutc&quot;}</code></pre><p>我们可以看到当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象；</p><p>当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局：</p><pre><code>function Person(name) {  this.name = name;  console.log(this);}var p = Person(&apos;qiutc&apos;);// Window</code></pre><p>其区别在于，如何调用函数（new）。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 this 的指向了，还记得在上文中（作为对象的方法调用-一些坑-解决）我们使用闭包来解决 this 的指向问题吗，如果用上了箭头函数就可以更完美的解决了：</p><pre><code>var obj = {  name: &apos;qiutc&apos;,  foo: function() {    console.log(this);  },  foo2: function() {    console.log(this);    setTimeout(() =&gt; {      console.log(this);  // Object {name: &quot;qiutc&quot;}    }, 1000);  }}obj.foo2();</code></pre><p>可以看到，在 setTimeout 执行的函数中，本应该打印出在 Window，但是在这里 this 却指向了 obj，原因就在于，给 setTimeout 传入的函数（参数）是一个箭头函数：</p><blockquote><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p></blockquote><p>根据例子我们理解一下这句话：<br>在 obj.foo2() 执行的时候，当前的 this 指向 obj；在执行 setTimeout 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 this 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 this，也就是 obj.foo2 中的 this，即 obj；所以在执行箭头函数的时候，它的 this -&gt; obj.foo2 中的 this -&gt; obj；</p><p>简单来说， 箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。</p><h2 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call, apply, bind"></a>call, apply, bind</h2><p>在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向：</p><ul><li>call</li></ul><p>fun.call(thisArg[, arg1[, arg2[, …]]])</p><p>它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，后面的参数是执行函数需要传入的参数；</p><ul><li>apply</li></ul><p>fun.apply(thisArg[, [arg1, arg2, …]])</p><p>它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）；</p><ul><li>bind</li></ul><p>var foo = fun.bind(thisArg[, arg1[, arg2[, …]]]);</p><p>它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数；</p><p>这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this），我们以 call 函数为例；</p><p>为一个普通函数指定 this</p><pre><code>var obj = {  name: &apos;qiutc&apos;};function foo() {  console.log(this);}foo.call(obj);// Object {name: &quot;qiutc&quot;}</code></pre><p>可以看到，在执行 foo.call(obj) 的时候，函数内的 this 指向了 obj 这个对象，成功；</p><p>为对象中的方法指定一个 this</p><pre><code>var obj = {  name: &apos;qiutc&apos;,  foo: function () {    console.log(this);  }}var obj2 = {  name: &apos;tcqiu222222&apos;};obj.foo.call(obj2);// Object {name: &quot;tcqiu222222&quot;}</code></pre><p>可以看到，执行函数的时候这里的 this 指向了 obj2，成功；</p><p>为构造函数指定 this</p><pre><code>function Person(name) {  this.name = name;  console.log(this);}var obj = {  name: &apos;qiutc2222222&apos;};var p = new Person.call(obj, &apos;qiutc&apos;);// Uncaught TypeError: Person.call is not a constructor(…)</code></pre><p>这里报了个错，原因是我们去 new 了 Person.call 函数，而非 Person ，这里的函数不是一个构造函数；</p><p>换成 bind 试试：</p><pre><code>function Person(name) {  this.name = name;  console.log(this);}var obj = {  name: &apos;qiutc2222222&apos;};var Person2 = Person.bind(obj);var p = new Person2(&apos;qiutc&apos;);// Person {name: &quot;qiutc&quot;}console.log(obj);// Object {name: &quot;qiutc2222222&quot;}</code></pre><p>打印出来的是 Person 实例化出来的对象，而和 obj 没有关系，而 obj 也没有发生变化，说明，我们给 Person 指定 this 上下文并没有生效；</p><p>因此可以得出： 使用 bind 给一个构造函数指定 this，在 new 这个构造函数的时候，bind 函数所指定的 this 并不会生效；</p><p>当然 bind 不仅可以指定 this ，还能传入参数，我们来试试这个操作：</p><pre><code>function Person(name) {  this.name = name;  console.log(this);}var obj = {  name: &apos;qiutc2222222&apos;};var Person2 = Person.bind(obj, &apos;qiutc111111&apos;);var p = new Person2(&apos;qiutc&apos;);// Person {name: &quot;qiutc111111&quot;}</code></pre><p>可以看到，虽然指定 this 不起作用，但是传入参数还是起作用了；</p><p>为箭头函数指定 this</p><p>我们来定义一个全局下的箭头函数，因此这个箭头函数中的 this 必然会指向全局对象，如果用 call 方法改变 this 呢：</p><pre><code>var afoo = (a) =&gt; {  console.log(a);  console.log(this);}afoo(1);// 1// Windowvar obj = {  name: &apos;qiutc&apos;};afoo.call(obj, 2);// 2// Window</code></pre><p>可以看到，这里的 call 指向 this 的操作并没有成功，所以可以得出： 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this。</p><p>只要记住箭头函数大法好，不变的 this。</p><p>Function.prototype.call</p><ul><li>格式:fx.call( thisArg [，arg1，arg2，… ] );</li></ul><ol><li><p>call的传参个数不限,第一个数表示调用函数(fx)函数体内this的指向.从第二个参数开始依次按序传入函数.</p><p> var age = 40;<br> var xiaoMing = {</p><pre><code>age:30</code></pre><p> };<br> var xiaoLi = {</p><pre><code>age: 20</code></pre><p> };<br> var getAge = function(){</p><pre><code>console.log(this.age);</code></pre><p> };<br>  getAge.call( xiaoMing );  //30 表示函数this指向xiaoMing<br> getAge.call(xiaoLi);  //20  表示函数this指向xiaoLi<br> getAge.call(undefined);//40  getAge.call(undefined)==getAge.call(null)<br> getAge.call(null);//40<br> getAge(); //40</p></li></ol><p>如果我们传入fx.call()的第一个参数数为null,那么表示函数fx体内this指向宿主对象,在浏览器是Window对象,这也解释了getAge.call(undefined);//40。</p><p>在此基础我们可以理解为 getAge()相当于getAge.call(null/undefined),扩展到所有函数,<br>fx()==fx.call(null) == fx.call(undefined)</p><p>值得注意的是严格模式下有点区别: this指向null</p><pre><code>var getAge = function(){&apos;use strict&apos;console.log(this.age);};getAge(null);//报错 age未定义</code></pre><p>再来理解this的使用</p><p>this的常用场景:</p><ul><li><p>this位于一个对象的方法内,此时this指向该对象</p><p>  var name = ‘window’;</p><p>  var Student = {</p><pre><code>name : &apos;kobe&apos;,getName: function () {    console.log(this == Student); //true    console.log(this.name);  //kobe}</code></pre><p>  }</p><p>  Student.getName();</p><p>  var name = ‘window’;<br>  var Student = {</p><pre><code>name : &apos;kobe&apos;,getName: function () {            var name=100;    console.log(this == Student); //true    console.log(this.name);  //kobe}</code></pre><p>  }<br>  Student.getName();   //getName取得是Student 的name</p></li></ul><ul><li><p>this位于一个普通的函数内,表示this指向全局对象,(浏览器是window)</p><p>  var name = ‘window’;</p><p>  var getName = function () {</p><pre><code>var name = &apos;kobe&apos;;  //迷惑性而已return this.name;</code></pre><p>  }</p><p>  console.log(  getName() ); //window</p></li></ul><ul><li><p>this使用在构造函数(构造器)里面,表示this指向的是那个返回的对象.</p><p>  var name = ‘window’;<br>  //构造器<br>  var Student = function () {</p><pre><code>this.name = &apos;student&apos;;</code></pre><p>  }</p><p>  var s1 = new Student();<br>  console.log(s1.name);  //student</p></li></ul><p>注意: 如果构造器返回的也是一个Object的对象(其他类型this指向不变遵循之前那个规律),这时候this指的是返回的这个Objec.</p><pre><code>var name = &apos;window&apos;;//构造器var Student = function () {    this.name = &apos;student&apos;;    return {        name: &apos;boyStudent&apos;    }}var s1 = new Student();console.log(s1.name);  //boyStudent</code></pre><ul><li><p>this指向失效问题</p><p>  var name = ‘window’;</p><p>  var Student = {</p><pre><code>name : &apos;kobe&apos;,getName: function () {            console.log(this.name);  }</code></pre><p>  }</p><p>  Student.getName(); // kobe<br>  var s1 = Student.getName;<br>  s1(); //window</p></li></ul><p>原因: 此时s1是一个函数</p><pre><code>function () {                console.log(this.name);      }</code></pre><p>对一个基本的函数,前面提过this在基本函数中指的是window.</p><ul><li>在开发中我们经常使用的this缓存法 ,缓存当前作用域下this到另外一个环境域下使用</li></ul><blockquote><p>最后理解apply的用法 Function.prototype.apply</p></blockquote><p>格式: fx.apply(thisArg [，argArray] ); // 参数数组，argArray</p><ol><li>apply与call的作用是一样的,只是传参方式不同,</li><li><p>apply接受两个参数,第一个也是fx函数体内this的指向,用法与call第一个参数一致.第二个参数是数组或者类数组,apply就是把这个数组元素传入函数fx.</p><p> var add = function (a ,b ,c) {</p><pre><code>console.log(a +b +c);</code></pre><p> }</p><p> add.apply(null , [1,2,3]); // 6</p></li></ol><p>再吃透这个题目就ok</p><pre><code>var a=10;var foo={  a:20,  bar:function(){      var a=30;      return this.a;    }}foo.bar()//20(foo.bar)()//20(foo.bar=foo.bar)()//10(foo.bar,foo.bar)()//10</code></pre><p>上题注解：</p><h2 id="时刻牢记：作用域链查找遵循”就近原则”；"><a href="#时刻牢记：作用域链查找遵循”就近原则”；" class="headerlink" title="时刻牢记：作用域链查找遵循”就近原则”；"></a>时刻牢记：作用域链查找遵循”就近原则”；</h2><h2 id="this谁调用就指向谁。"><a href="#this谁调用就指向谁。" class="headerlink" title="this谁调用就指向谁。"></a>this谁调用就指向谁。</h2><pre><code>var a=10;var foo={  a:20,  bar:function(){      var a=30;  //this 指向 foo  ：console.log( this == foo) //true      return this.a;    }}foo.bar()   //20// foo.bar()    // foo调用，this指向foo , 此时的 this 指的是foo，所以是20 (foo.bar)()//20//第一步：(function(){   var a=30;    return this.a;})()    //作用域链向上查找,this 指向外一层的对象foo(foo.bar=foo.bar)()//10foo.bar=foo.bar,【睁大眼睛，是单等号赋值】就是普通的复制,一个匿名函数赋值给一个全局变量,你可以把右边的foo.bar换成b,即(b = foo.bar)(),博客里面【this指向失效问题】说过普通的函数里面的this指向window,自然this.a == 10(foo.bar,foo.bar)()  //逗号表达式//10//(foo.bar,foo.bar)是一个小括号表达式,小括号表达式会依次创建两个匿名函数,并返回最后一个的匿名函数值,(foo.bar,foo.bar) 得到的是这个函数 function(){     var a=30;     console.log( this == foo); //如果不是很了解this的指向就加这个代码进行检测     return this.a;   } ,这个是匿名函数,匿名函数的this指的是widnow,那么this.a = 10this可谓是JavaScript中的开发神器，使用得当的话不仅有事半功倍的效果，而且代码的逼格也更高。但是既然是神器，如果你没有足够的功力的话，那么就不要使用它，否则就有可能自毁身亡。曾几何时，我偶然得到这个神器，之后，，，自残，，，自残，，，再自残...再自残了那么多次后，终于可以拥有强大功力持此神器行走江湖了。接下来，我就为大家来传授传说中神器的使用秘诀。咳咳。。入正题。this是什么？this表示当前运行方法的主体。注意：函数中的this指向和当前函数在哪定义的话或者在哪执行都没有任何的关系。为啥这样说，请仔细阅读下面的秘籍大全。神器秘籍大全：秘籍一：自制行函数里面的this永远都是windowvar inner = &quot;window&quot;;var obj = {inner : &quot;obj&quot;,          fn : (function () {console.log(this.inner)})()}上面浏览器在运行该程序时，会自动运行obj.fn里面的方法，因为obj.fn是一个自制行函数，当执行该函数时，程序会输出window。额，为什么输出不是obj？因为人家规定自制行函数里面的this是window,所以其实this.inner就是window.inner，因此这个inner是定义在全局变量的，它的值是&quot;window&quot;。秘籍二：元素绑定事件驱动方法运行，方法里的this表示当前绑定的元素var oDiv = document.getElementsByTagName(&quot;div&quot;)[0];oDiv.onclick=function(){    console.log(this);   //当用鼠标点击该元素，则输出oDiv元素的集合 };这个好理解，元素绑定某个行为执行的方法，就相当于把这个方法也绑定在这个元素上，所以this也就指向元素本身。秘籍三：方法执行，看方法名前面是否有&quot;.&quot;，有的话&quot;.&quot;前面是谁this就是谁，没有的话this就是windowvar obj={fn:fn};function fn(){console.log(this)}fn.prototype.aa=function(){console.log(this)};var f=new fn;fn();  //window..obj.fn(); //Object..fn.prototype.aa(); //fn.prototypef.aa(); //f记住此秘籍！！！秘籍四：在构造函数模式中,函数体中的this是当前类的一个实例function Fn(){    this.x = 100;    console.log(this);  // 实例 f}var f = new Fn;构造函数生成的实例，故构造函数里的this当然是指向当前这个实例了。秘籍五（大招）：call/apply来改变this的指向var oDiv = document.getElementsByTagName(&quot;div&quot;)[0];function fn() {    console.log(this);}fn.call(oDiv);fn.call(oDiv); //执行这个语句后，fn里面的this指向oDiv元素，applay用法与call类似。此大招一出来，上面四个秘籍都无效了。</code></pre><h2 id="五个典型的-JavaScript-面试题"><a href="#五个典型的-JavaScript-面试题" class="headerlink" title="五个典型的 JavaScript 面试题"></a>五个典型的 JavaScript 面试题</h2><h2 id="问题1-范围（Scope）"><a href="#问题1-范围（Scope）" class="headerlink" title="问题1: 范围（Scope）"></a>问题1: 范围（Scope）</h2><p>思考以下代码：<br><img src="https://pic4.zhimg.com/v2-3427ee7904e86825dc800f37b5dd76a1_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-3427ee7904e86825dc800f37b5dd76a1_hd.jpg" alt=""></p><p>控制台（console）会打印出什么？</p><p>答案</p><p>上述代码会打印出5。</p><p>这个问题的陷阱就是，在立即执行函数表达式（IIFE）中，有两个命名，但是其中变量是通过关键词var来声明的。这就意味着a是这个函数的局部变量。与此相反，b是在全局作用域下的。</p><p>这个问题另一个陷阱就是，在函数中他没有使用”严格模式” (‘use strict’;)。如果 严格模式 开启，那么代码就会报出未捕获引用错误（Uncaught ReferenceError）：b没有定义。记住，严格模式要求你在需要使用全局变量时，明确地引用该变量。因此，你需要像下面这么写：<br><img src="https://pic3.zhimg.com/v2-d2990958fbb99d5fe5b7c2f99fd67fc1_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-d2990958fbb99d5fe5b7c2f99fd67fc1_hd.jpg" alt=""></p><h2 id="问题2-创建-“原生（native）”-方法"><a href="#问题2-创建-“原生（native）”-方法" class="headerlink" title="问题2: 创建 “原生（native）” 方法"></a>问题2: 创建 “原生（native）” 方法</h2><p>在String对象上定义一个repeatify函数。这个函数接受一个整数参数，来明确字符串需要重复几次。这个函数要求字符串重复指定的次数。举个例子：<br><img src="https://pic2.zhimg.com/v2-9a26df01a60f8a3020e339a2cdc022dc_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-9a26df01a60f8a3020e339a2cdc022dc_hd.jpg" alt=""></p><p>应该打印出hellohellohello.</p><p>答案</p><p>一种可能的实现如下所示：<br><img src="https://pic3.zhimg.com/v2-323205969d7c319efb3257e962fc0e13_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-323205969d7c319efb3257e962fc0e13_hd.jpg" alt=""></p><p>这个问题测试了开发人员对于JavaScript中继承的掌握，以及prototype这个属性。这也验证了开发人员是否有能力扩展原生数据类型的功能（虽然不应该这么做）。</p><p>这个问题的另一个重点是验证你是否意识到并知道如何避免覆盖已经存在的函数。这可以通过在自定义函数之前判断该函数是否存在来做到。<br><img src="https://pic3.zhimg.com/v2-145aeeefc3c8949329552b22fa9434b3_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-145aeeefc3c8949329552b22fa9434b3_hd.jpg" alt=""></p><p>当你需要为旧浏览器实现向后兼容的函数时，这一技巧十分有用。</p><h2 id="问题3-变量提升（Hoisting）"><a href="#问题3-变量提升（Hoisting）" class="headerlink" title="问题3: 变量提升（Hoisting）"></a>问题3: 变量提升（Hoisting）</h2><p>执行以下代码会有什么结果？为什么？<br><img src="https://pic2.zhimg.com/v2-76ce0e2d75c2302991e408d087476a59_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-76ce0e2d75c2302991e408d087476a59_hd.jpg" alt=""></p><p>答案</p><p>这段代码的执行结果是 undefined 和 2。</p><p>这个结果的原因是，变量和函数都被提升了（hoisted）。因此，在a被打印的时候，它已经在函数作用域中存在（即它已经被声明了），但是它的值依然是 undefined。换言之，上述代码和以下代码是等价的。<br><img src="https://pic4.zhimg.com/v2-e5d341549dabe574215e26dbf0535ae8_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-e5d341549dabe574215e26dbf0535ae8_hd.jpg" alt=""></p><h2 id="问题4-this-在-JavaScript-中是如何工作的"><a href="#问题4-this-在-JavaScript-中是如何工作的" class="headerlink" title="问题4: this 在 JavaScript 中是如何工作的"></a>问题4: this 在 JavaScript 中是如何工作的</h2><p>以下代码的结果是什么？请解释你的答案。<br><img src="https://pic4.zhimg.com/v2-c7109c7158a7800b48c57ce5fcfd889a_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-c7109c7158a7800b48c57ce5fcfd889a_hd.jpg" alt=""></p><p>答案</p><p>上面的代码打印出 Aurelio De Rosa 和 John Doe。原因是在 JavaScript 中，一个函数的上下文环境，也就是this关键词所引用对象，是依赖于函数是如何被调用的，而不是依赖于函数如何被定义的。</p><p>在第一个 console.log() 调用中， getFullname() 是作为 obj.prop 的函数被调用的。因此，这里的上下文环境指向后者并且函数返回this对象的 fullname 属性。相反，当 getFullname() 被赋为test变量的值时，那个语境指向全局对象(window)。这是因为，test被隐式设置为全局对象的属性。因此，函数调用返回 window 的 fullname 属性值，在此段代码中，这个值是通过第一行赋值语句设置的。</p><h2 id="问题5-call-和-apply"><a href="#问题5-call-和-apply" class="headerlink" title="问题5: call() 和 apply()"></a>问题5: call() 和 apply()</h2><p>修复上一个问题，让最后一个 console.log() 打印出 Aurelio De Rosa。</p><p>答案</p><p>要解决这个问题，可以通过为函数 call() 或者 apply() 强制函数调用的上下文环境。如果你不知道 call() 和 apply() 之间的区别，我推荐阅读文章“ function.call 和 function.apply 之间有和区别?”。在以下代码中，我会用 call()，但是在这里，用 apply() 也可以获得相同的结果：<br><img src="https://pic4.zhimg.com/v2-6dd929db46959a48071adb146a84ba56_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-6dd929db46959a48071adb146a84ba56_hd.jpg" alt=""></p><h2 id="常见面试："><a href="#常见面试：" class="headerlink" title="常见面试："></a>常见面试：</h2><pre><code>下面列举一些简单的实例 总结一下this的一些用法：1.方法中的this会指向当前执行该方法的对象 如：var name = &quot;window&quot;var Tom = {  name:&quot;Tom&quot;;  show:function(){alert(this.name)}}Tom.show();   //Tom2.方法中的this不会指向声明它的对象 如下var Bob={  name:&quot;Bob&quot;,  show:function(){alert(this.name);}  };var Tom={  name:&quot;Tom&quot;,  show:Bob.show  };Tom.show() ;   //Tom因为尽管alert(this.name)是在Bob对象环境中声明的但该方法是由Tom对象调用执行所以this总是会指向当前执行的对象，而不是声明的对象3.将方法复制给变量时，执行时仍然会以Tom对象区调用该方法var name=&quot;window&quot;;var Tom={  name:&quot;Tom&quot;.  show:function(){alert(this.name)}  };var fun=Tom.show();fun();              //Tom可以看出赋值后再调用，并不影响调用其方法的对象4.将对象赋值给变量后，再调用方法，执行的对象仍然是Tomvar name=&quot;window&quot;;var Tom={  name:&quot;Tom&quot;,  show:function(){alert(this.name)},  wait:function(){             var that=this;             that.show();         }  };Tom.wait();  //Tom这里that赋值了当前执行的对象，并让它继续调用show，所以show方法中alert(this.name)自然而然的指向了Tom可以把上面的 &quot;that赋值对象 然后调用方法&quot; 这个过程看做成执行对象的延迟，就是让Tom加班的意思 5.另一种 指明调用方法的对象 的办法 如下：var name = &quot;window&quot;;var Bob= {    name:&quot;Bob&quot;,    show:function(){alert(this.name);}    }; var Tom= {name: &quot;Tom&quot;}; Bob.show();                   //Bob Bob.show.apply();             //window Bob.show.apply(Tom);          //Tom 当然call()也差不多类似6.下面来个特殊的例子var name=&quot;window&quot;;var Tom={  name:&quot;Tom&quot;,  show:function(){alert(this.name)},  wait:function(){             var fun=this.show;             fun();         }  };Tom.wait();  //window上面也是赋值方法后，再调用，可是执行的对象却改成了window对象解释：在函数体内把方法赋值给变量再调用会导致对象更改为Window对象执行fun时，可以看做是一种方法调用的延迟行为，延迟调用方法会使得执行的对象变为全局对象也就是window对象下面我们来看看其他几种延迟方式，导致对象被更改为window的例子7.匿名函数的延迟var name=&quot;window&quot;;var Tom={  name:&quot;Tom&quot;,  show:function(){alert(this.name)},  wait:function(){!function(call){call();}(this.show)}  }Tom.wait();    //Window8.setTimeout、setInterval函数延迟这里只以setTimeout为例子var name=&quot;window&quot;;var Tom={  name:&quot;Tom&quot;,  show:function(){alert(this.name)},  wait:function(){setTimeout(this.show,1000)}  }Tom.wait();    //window9. 在延迟的环境下 尝试让Tom加班（对象也跟着延迟）var name=&quot;window&quot;;var Tom={  name:&quot;Tom&quot;,show:function(){alert(this.name)},wait:function(){setTimeout(Tom.show,1000)}  }Tom.wait();    //window  上面中this对象改成了Tom，尝试让Tom加班，但是结果仍然为Window对象因为Tom.show放在第一个参数里，延迟的执行使得执行的对象变为window对象而不再是Tom对象，如何让执行对象Tom在延迟当不被变更呢？下面给你答案 10.虽然延迟会导致方法的执行对象被更改为Window 但也有办法防止执行对象更改 如下var name=&quot;window&quot;var  Tom ={      name : &quot;Tom&quot;,      show : function(){alert(this.name);},      wait:  function(){    var that=this;    setTimeout(function(){that.show()},1000)}            }Tom.wait();    //Tom 如果不能理解上面的代码，你就当做Tom对象也跟着函数一起延迟就好了而第9个例子没有成功延迟，是因为没有变量保存对象使得执行对象没有跟着延迟11.eval函数的延迟对于eval比较特殊在eval环境下，执行的对象就是当前作用域的对象 如下var name=&quot;window&quot;;var Bob={  name:&quot;Bob&quot;,  showName: function(){ eval(&quot;alert(this.name)&quot;); }  };Bob.showName(); //Bob12.eval函数的环境下，不会受到延迟而影响函数执行的对象之所以eval特殊是因为eval不受延迟的影响var name=&quot;window&quot;;var that;var Tom={  name:&quot;Tom&quot;,  show:function(){alert(this.name)},  wait:function(){that=this;setTimeout(&quot;that.show()&quot;,1000)}  }Tom.wait();    //Tom也许你会觉得上面的代码没有eval函数的身影其实setTimeout函数的第一个参数就是eval环境他会指向当前执行作用域的执行对象，忽略延迟方法延迟调用如果能把上面12个例子都理解了，那么this将成为你的一把有力的刀，挥舞在你代码中当然如果不能理解，那么像闭包一样 尽量的少用！</code></pre><p>函数是JavaScript世界里的第一公民，换句话来说，就是我们如果可以精通JavaScript函数的使用，那么对JavaScript的运用可以更游刃有余了。熟悉JavaScript的人应该都知道，同样的函数，以不同的方式调用的话，受影响最大的应该是  this 。下面我们来说说JavaScript函数的各种调用模式。</p><p>一、普通函数的调用模式</p><p>　　所谓普通函数的调用模式，也是JavaScript函数的最简单的一种调用模式，直接就是函数名后接一个  ()  实现调用，看下面代码：</p><pre><code>function func(){    console.log(this === window);  //true}func();</code></pre><p>　　上面代码，我们用function关键字声明了一个 func 函数，并且在函数体内打印 this===window，然后我们直接调用函数func，我们可以看到控制台是直接打印出 true ，也就是说，函数的这种普通调用模式，函数体内的  this  是指向全局环境 window 的。不清楚这点的同学，可以能会遇到这样的一个bug：</p><pre><code>var color = &apos;gg&apos;;var obj = {    color : &apos;red&apos;,    show : function(){        function func1(){            console.log(this.color);  //gg        }        func1();    }}obj.show(); </code></pre><p>　　我们在全局环境下声明了一个变量 color 和一个对象 obj ，在对象 obj 里面我们还声明了一个 color 属性 为 ‘red’，一个 show 方法。而且在 show 方法里面呢，我们还声明了一个函数 func1 并且调用了 func1，func1 的作用是打印 this.color。最后我们运行代码  obj.show();   调用obj里面的show方法。不清楚函数的普通调用模式的特点的同学可能会认为此时在控制台答应出来的会是  ‘red’ 。实际上此时在控制台答应出来的应该是  gg  。因为函数  func1  的调用模式是 普通函数调用模式（即使它是在  obj  的  show  方法里面调用的），所以此时函数体内的  this  是指向 全局环境window 的，所以就打印了全局环境下的变量  color 。</p><p>　　可能有些同学会问：如果我们希望  func1  函数打印出来的是 ‘red’ 呢，应该怎么改？其实很简单，因为  obj.color  才是 ‘red’ ，所以我们只需要把  指向  obj  的  this 引入到函数 func1  里面就行了： </p><pre><code>var color = &apos;gg&apos;;var obj = {    color : &apos;red&apos;,    show : function(){        var that = this;        function func1(){            console.log(that.color);  //red        }        func1();    }}obj.show();var color = &apos;gg&apos;;var obj = {    color : &apos;red&apos;,    show : function(){        var func1=function(){            console.log(this.color);  //red        }.bind(this);        func1();    }}obj.show();</code></pre><p>　　在上面的代码中，因为  show  里面的   this  指向   obj   的，所以我们在  show  里面声明一个变量  that = this;用来把指向  obj  的  this  引入到  func1 中，然后再把 func1 函数体内的  this.color  改为  that.color ,此时在控制台打印出来的就是我们想要的 ‘red’ 了。</p><p>　　可能现在又有同学会问：为什么   show   里面的  this  是指向  obj 的呢？这就是我们要说的JavaScript函数的第二种调用模式：方法调用模式</p><p>二、方法调用模式</p><p>　　方法调用模式，简单来说就是把一个 JavaScript函数作为一个对象的方法来调用，当一个函数被保存为一个对象的属性是，我们就把它称为方法，例如上文的  obj  对象里的  show  ，当一个方法被调用时，函数体里面的   this  就会绑定到这个对象，例如上文的 show 里面的  this  。方法调用模式也很容易辨别：obj.show()，对象名 . 属性名 () ；代码的话可以参考上文的  obj  代码 ，博主就不多写了。记住：方法的调用是可以在函数体内通过  this  访问自己所属的那个对象的。</p><p>三、构造器调用模式</p><p>博主认为构造器调用模式是相对于其他模式来说较为复杂点的调用模式了。通过关键字  new  可以把一个函数作为构造器来调用。关键字  new  可以改变函数的返回值：</p><pre><code>function func2(name){    this.name = name;}name;   //undefined//普通函数调用模式var foo = func2(&apos;afei&apos;);foo;  //undefinedname;   //afei//构造器调用模式var bar = new func2(&apos;lizefei&apos;);bar.__proto__ === func2.prototype;  //truebar;  //{name:&apos;lizefei&apos;}bar.name;  //&apos;lizefei&apos;</code></pre><p>　　在上示代码中我们声明了一个函数 func2 ，分别用两种不同的调用模式去调用它。因为函数  func2  并没有显式返回值，所以作为普通函数去调用时，它什么也没有返回，所以  foo  的值是  undefined  。因为普通调用模式的   this   是指向 全局环境   window  的，所以  func2(‘afei’);  后，全局环境下就多了一个  name 变量且等于 ‘afei’。</p><p>　　func2  作为构造器调用时，我们可以看到，它返回的是一个对象，因为关键字  new  使得函数在调用是发生了如下的特殊变化：</p><ol><li>　　创建了一个新对象，而且这个新对象是链接到 func2  的  prototype  属性的</li><li>　　把函数里的  this  指向了这个新对象</li><li>　　如果没有显式的返回值，新对象作为构造器func2的返回值进行返回（所以bar 是 {name:’lizefei’}）</li></ol><p>这样子我们就可以看出构造器的作用：通过函数的调用来初始化新创建出来的对象。在JavaScript的面向对象编程里面，这个可是相当重要的。</p><p>　　因为在函数的声明上，在未来作为构造器调用的函数和普通函数的声明没什么区别，所以导致后来的开发者很容易因为调用模式的错误导致程序出问题。所以开发者们都默契地约定，用来做构造器调用的函数的函数名的第一个字符应该大写，例如：Person，People。这样子后来的开发者一看到函数名就知道要用构造器调用模式调用此函数了。</p><p>四、使用apply()和call()方法调用</p><p>　　这种调用的模式是为了更灵活控制函数运行的上下文环境而诞生的。简单的说就是为了灵活控制函数体内  this  的值。</p><p>　　apply 和 call这两个方法的第一个参数都是要传递被函数上下文的对象（简单点说就是要绑定给函数  this  的对象）。其他参数就有所不同了：</p><p>　　apply方法的第二个参数是一个数组，数组里面的值将作为函数调用的参数；</p><p>　　call方法，从第二个参数起（包括第二个参数），剩下的参数都是作为函数调用的参数；</p><p>　　让我们看看栗子：</p><pre><code>var obj = {    name :&apos;afei&apos;}function say(ag1,ag2){    console.log(ag1+&apos;:&apos;+ag2+&quot; &quot;+ this.name);}say.apply(obj,[&apos;apply方法&apos;,&apos;hello&apos;]); //apply方法:hello afeisay.call(obj,&apos;call方法&apos;,&apos;hi&apos;); //call方法:hi afei</code></pre><p>　　正如栗子所示，我们把对象 obj  作为函数  say  的上下文来调用函数  say  ，所以函数里的  this  是指向 对象  obj  的。在apply方法里，我们通过数组  [‘apply方法’,’hello’]  给  say  方法传递了两个参数（’apply方法’ 和 ‘hello’），所以打印出来是：  apply方法:hello afei。</p><p>　　同理  call 也是一样，而且函数传递的方式通过上面的代码也一目了然我，博主就不多做解释了。</p><p>　　另外，博主还听说apply和call这两个方法除了传递参数的方式不一样，执行的速度还是apply 比 call 要快呢。不过博主就没有实验过。</p><p>五、总结</p><p>　　在JavaScript里面，函数只要的调用模式就是这几种了（在ES6里面还有一种很奇怪很特殊的函数调用模式，叫做’标签模板‘，在这里博主也不多说了，有空另更），只要掌握了这几种主要的调用模式，那么日后再也不用担心  this 的值变来变去了。</p><p>　　上文如果有漏的、有错误的地方，望各位小伙伴指出，小弟虚心向学。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS中的this的七种使用场景</title>
      <link href="/2015/08/30/JS%E4%B8%AD%E7%9A%84this%E7%9A%84%E4%B8%83%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2015/08/30/JS%E4%B8%AD%E7%9A%84this%E7%9A%84%E4%B8%83%E7%A7%8D%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p>Javascript 中的 this，有时候让人迷惑，所以总结了一下关于this指向的问题。</p><p>在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。</p><blockquote><p>因为 this 的取值是函数执行上下文(context)的一部分，每次调用函数，都会产生一个新的执行上下文环境。当代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。</p></blockquote><h2 id="关于-this-的取值，大体上可以分为以下七种情况："><a href="#关于-this-的取值，大体上可以分为以下七种情况：" class="headerlink" title="关于 this 的取值，大体上可以分为以下七种情况："></a>关于 this 的取值，大体上可以分为以下七种情况：</h2><blockquote><p>由于严格模式下，禁止this指向全局对象，所以以下示例均运行在非严格模式下</p></blockquote><h2 id="情况一：全局-amp-调用普通函数"><a href="#情况一：全局-amp-调用普通函数" class="headerlink" title="情况一：全局 &amp; 调用普通函数"></a>情况一：全局 &amp; 调用普通函数</h2><p>在全局环境中，this 永远指向 window。</p><pre><code>console.log(this === window);     //true</code></pre><p>普通函数在调用时候(注意不是构造函数，前面不加 new)，其中的 this 也是指向 window。</p><pre><code>var x = 10;function foo(){    console.log(this);     //Window    console.log(this.x);   //10}foo();</code></pre><h2 id="情况二：构造函数"><a href="#情况二：构造函数" class="headerlink" title="情况二：构造函数"></a>情况二：构造函数</h2><p>所谓的构造函数就是由一个函数 new 出来的对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。</p><pre><code>function Foo(){    this.x = 10;    console.log(this);    //Foo {x:10}}var foo = new Foo();console.log(foo.x);      //10</code></pre><p>上述代码，如果函数作为构造函数使用，那么其中的 this 就代表它即将 new 出来的对象。</p><p>但是如果直接调用 Foo 函数，而不是 new Foo()，那就变成情况1，这时候 Foo() 就变成普通函数。</p><pre><code>function Foo(){    this.x = 10;    console.log(this);    //Window}var foo = Foo();</code></pre><h2 id="情况三：对象方法"><a href="#情况三：对象方法" class="headerlink" title="情况三：对象方法"></a>情况三：对象方法</h2><p>如果函数作为对象的方法时，方法中的 this 指向该对象。</p><pre><code>var obj = {    x: 10,    foo: function () {        console.log(this);        //Object        console.log(this.x);      //10    }};obj.foo();</code></pre><p>注意：若是在对象方法中定义函数，那么情况就不同了。</p><pre><code>var obj = {    x: 10,    foo: function () {        function f(){            console.log(this);      //Window            console.log(this.x);    //undefined        }        f();    }}obj.foo();</code></pre><p>可以这么理解：函数 f 虽然是在 obj.foo 内部定义的，但它仍然属于一个普通函数，this 仍指向 window。</p><p>在这里，如果想要调用上层作用域中的变量 obj.x，可以使用 self 缓存外部 this 变量。</p><pre><code>var obj = {    x: 10,    foo: function () {        var self = this;        function f(){            console.log(self);      //{x: 10}            console.log(self.x);    //10        }        f();    }}obj.foo();</code></pre><p>如果 foo 函数不作为对象方法被调用：</p><pre><code>var obj = {    x: 10,    foo: function () {        console.log(this);       //Window        console.log(this.x);     //undefined    }};var fn = obj.foo;fn();</code></pre><p>obj.foo 被赋值给一个全局变量，并没有作为 obj 的一个属性被调用，那么此时 this 的值是 window。</p><h2 id="情况四：构造函数-prototype-属性"><a href="#情况四：构造函数-prototype-属性" class="headerlink" title="情况四：构造函数 prototype 属性"></a>情况四：构造函数 prototype 属性</h2><pre><code>function Foo(){    this.x = 10;}Foo.prototype.getX = function () {    console.log(this);        //Foo {x: 10, getX: function}    console.log(this.x);      //10}var foo = new Foo();foo.getX();</code></pre><p>在 Foo.prototype.getX 函数中，this 指向的 foo 对象。不仅仅如此，即便是在整个原型链中，this 代表的也是当前对象的值。</p><h2 id="情况五：函数用-call、apply或者-bind-调用。"><a href="#情况五：函数用-call、apply或者-bind-调用。" class="headerlink" title="情况五：函数用 call、apply或者 bind 调用。"></a>情况五：函数用 call、apply或者 bind 调用。</h2><pre><code>var obj = {    x: 10}function foo(){    console.log(this);     //{x: 10}    console.log(this.x);   //10}foo.call(obj);foo.apply(obj);foo.bind(obj)();</code></pre><p>当一个函数被 call、apply 或者 bind 调用时，this 的值就取传入的对象的值。</p><h2 id="情况六：DOM-event-this"><a href="#情况六：DOM-event-this" class="headerlink" title="情况六：DOM event this"></a>情况六：DOM event this</h2><p>在一个 HTML DOM 事件处理程序里，this 始终指向这个处理程序所绑定的 HTML DOM 节点：</p><pre><code>function Listener(){       document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;, this.handleClick);     //这里的 this 指向 Listener 这个对象。不是强调的是这里的 this}Listener.prototype.handleClick = function (event) {    console.log(this);    //&lt;div id=&quot;foo&quot;&gt;&lt;/div&gt;}var listener = new Listener();document.getElementById(&apos;foo&apos;).click();</code></pre><p>这个很好理解，就相当于是给函数传参，使 handleClick 运行时上下文改变了，相当于下面这样的代码：</p><pre><code>var obj = {    x: 10,    fn: function() {        console.log(this);         //Window        console.log(this.x);       //undefined    }};function foo(fn) {    fn();} foo(obj.fn);</code></pre><p>你也可以用通过 bind 切换上下文:</p><pre><code>function  Listener(){    document.getElementById(&apos;foo&apos;).addEventListener(&apos;click&apos;,this.handleClick.bind(this));      }Listener.prototype.handleClick = function (event) {    console.log(this);    //Listener {}}var listener = new Listener();document.getElementById(&apos;foo&apos;).click();</code></pre><p>前六种情况其实可以总结为： this 指向调用该方法的对象。</p><h2 id="情况七：箭头函数中的-this"><a href="#情况七：箭头函数中的-this" class="headerlink" title="情况七：箭头函数中的 this"></a>情况七：箭头函数中的 this</h2><p>当使用箭头函数的时候，情况就有所不同了：箭头函数内部的 this 是词法作用域，由上下文确定。</p><pre><code>var obj = {    x: 10,    foo: function() {        var fn = () =&gt; {            return () =&gt; {                return () =&gt; {                    console.log(this);      //Object {x: 10}                    console.log(this.x);    //10                }            }        }        fn()()();    }}obj.foo();</code></pre><p>现在，箭头函数完全修复了 this 的指向，this 总是指向词法作用域，也就是外层调用者 obj。</p><p>如果使用箭头函数，以前的这种 hack 写法：</p><pre><code>var self = this;</code></pre><p>就不再需要了。</p><pre><code>var obj = {    x: 10,    foo: function() {        var fn = () =&gt; {            return () =&gt; {                return () =&gt; {                    console.log(this);    // Object {x: 10}                    console.log(this.x);  //10                }            }        }        fn.bind({x: 14})()()();        fn.call({x: 14})()();    }}obj.foo();</code></pre><p>由于 this 在箭头函数中已经按照词法作用域绑定了，所以，用 call()或者 apply()调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>强大的margin负边距</title>
      <link href="/2015/08/01/%E5%BC%BA%E5%A4%A7%E7%9A%84margin%E8%B4%9F%E8%BE%B9%E8%B7%9D/"/>
      <url>/2015/08/01/%E5%BC%BA%E5%A4%A7%E7%9A%84margin%E8%B4%9F%E8%BE%B9%E8%B7%9D/</url>
      
        <content type="html"><![CDATA[<p>css中的负边距(negative margin)是布局中的一个常用技巧，只要运用得合理常常会有意想不到的效果。很多特殊的css布局方法都依赖于负边距，所以掌握它的用法对于前端的同学来说，那是必须的。本文非常基础，老鸟可以略过。</p><p>左和右的负边距对元素宽度的影响</p><p>负边距不仅能影响元素在文档流中的位置，还能增加元素的宽度！</p><p>这个作用能实现的前提是：该元素没有设定width属性（当然width:auto是可以的）。</p><p>比如下图的黑灰色部分是一个块状元素，它没有设定宽度。它被包裹在一个宽度为400px,且水平居中的父元素中。</p><p><img src="https://pic3.zhimg.com/v2-d7053213fb80015b97e243fae474124a_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-d7053213fb80015b97e243fae474124a_hd.jpg" alt=""></p><p>现在给这个元素的设一个margin-right:-100px;</p><p><img src="https://pic3.zhimg.com/v2-a3037b974494cdbe0c92d4c90af69f80_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-a3037b974494cdbe0c92d4c90af69f80_hd.jpg" alt=""></p><p>我们看到它的宽度的确变长100px;然后再给它设一个margin-left:-100px;</p><p><img src="https://pic1.zhimg.com/v2-444d4e67d5804bfcbcd4991948889bdb_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-444d4e67d5804bfcbcd4991948889bdb_hd.jpg" alt=""></p><p>我们看到它变得更宽了。</p><p>负的margin会改变元素的宽度，这的确很让人费解，如果说负边距会改变元素在文档流中的位置还是很好理解的话，那改变宽度这种现象还真的蛮让人不可思议的。</p><p>那这货有什么用途呢？我就举一个例子吧。<br><img src="https://pic2.zhimg.com/v2-ee54fb10005457120458e7823fc83d29_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-ee54fb10005457120458e7823fc83d29_hd.jpg" alt=""></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;        &lt;title&gt;浮动两端对齐&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            ul,            li {                margin: 0;                padding: 0;            }            h2 {                clear: both;                font-size: 1.2em;            }            .justify {                width: 320px;                /* 1行3个li，li之间距离10px = 100px*3 + 10px*2 */                overflow: hidden;                margin: 10px;                border: 1px solid #999999;            }            .justify ul {                width: 330px;                /* 可容纳下3列的宽度 */                margin-bottom: -10px;                /* 隐藏掉最下面一行的margin-bottom */                overflow: hidden;                zoom: 1;                /* 触发IE的Layout */            }            *+html .justify ul {                margin-bottom: 0;                /* 针对IE7中最后1行li的margin-bottom失效 */            }            .justify li {                display: inline;                float: left;                list-style: none;                width: 100px;                height: 100px;                margin: 0 10px 10px 0;                background: #EEEEEE;            }            .margin ul {                width: auto;                margin: 0 -10px -10px 0;            }            .col-2 {                width: 210px;            }            .col-4 {                width: 430px;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;            &lt;a href=&quot;http://www.ddcat.net/blog/?p=1199&quot; title=&quot;回到猫窝Blog&quot;&gt;回到猫窝Blog&lt;/a&gt;        &lt;/div&gt;        &lt;h1&gt;浮动两端对齐&lt;/h1&gt;        &lt;h2&gt;ul定宽&lt;/h2&gt;        &lt;div class=&quot;justify&quot;&gt;            &lt;ul&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;中间&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;中间&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;中间&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;h2&gt;ul使用负margin值&lt;/h2&gt;        &lt;div class=&quot;justify margin&quot;&gt;            &lt;ul&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;中间&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;中间&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;中间&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;h2&gt;两列&lt;/h2&gt;        &lt;div class=&quot;justify margin col-2&quot;&gt;            &lt;ul&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;                &lt;li&gt;靠左边&lt;/li&gt;                &lt;li&gt;靠右边&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;h2&gt;四列&lt;/h2&gt;        &lt;div class=&quot;justify margin col-4&quot;&gt;            &lt;ul&gt;                &lt;li&gt;1&lt;/li&gt;                &lt;li&gt;2&lt;/li&gt;                &lt;li&gt;3&lt;/li&gt;                &lt;li&gt;4&lt;/li&gt;                &lt;li&gt;5&lt;/li&gt;                &lt;li&gt;6&lt;/li&gt;                &lt;li&gt;7&lt;/li&gt;                &lt;li&gt;8&lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;        &lt;div&gt;            &lt;a href=&quot;http://www.ddcat.net/blog/?p=1199&quot; title=&quot;回到猫窝Blog&quot;&gt;回到猫窝Blog&lt;/a&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://pic2.zhimg.com/v2-5c529ec117f663aaacc2030c14423321_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-5c529ec117f663aaacc2030c14423321_hd.jpg" alt=""><img src="https://pic3.zhimg.com/v2-3255d3a67bca63a51e1407f982e2432b_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-3255d3a67bca63a51e1407f982e2432b_hd.jpg" alt=""><br>一个负的margin-right,相当于把ul的宽度增加了10px.</p><p>负边距对浮动元素的影响</p><p>负边距对浮动元素的影响与负边距对文档流中元素的影响其实是差不多的。文档流中元素的位置由文档流的走向决定，浮动的元素也可以看成有一个“浮动流”存在，不过浮动流既可以向左，也可以向右。</p><p>比如下图是三个向左浮动的元素，宽高都是100px：</p><p><img src="https://pic2.zhimg.com/v2-1de5e1221b518a74b0606c221cd421f1_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-1de5e1221b518a74b0606c221cd421f1_hd.jpg" alt=""></p><p>现在把它们都设一个margin-right:-50px; 然后会变成这样子：</p><p><img src="https://pic4.zhimg.com/v2-b0b46b0eff5e6f19a4addafe0d670e85_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-b0b46b0eff5e6f19a4addafe0d670e85_hd.jpg" alt=""></p><p>我们看到后面的元素叠到了前面的元素上。</p><p>再看下面的图：</p><p><img src="https://pic3.zhimg.com/v2-21b3ac21b68d64bdb604b825d00343ce_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-21b3ac21b68d64bdb604b825d00343ce_hd.jpg" alt=""></p><p>我们把浏览器缩小了，然后因为宽度不够，元素3掉下来了。我们给元素3设一个margin-left:-80px;看看会怎么样</p><p><img src="https://pic1.zhimg.com/v2-ee169d733bb4ce86b2c42de5ebf61bb7_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-ee169d733bb4ce86b2c42de5ebf61bb7_hd.jpg" alt=""></p><p>这时我们看到元素3上去了，而且还覆盖了元素2的一部分。继续元素3设为margin-left:-100px</p><p><img src="https://pic4.zhimg.com/v2-73ff48691bcf79125064218d71d6134f_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-73ff48691bcf79125064218d71d6134f_hd.jpg" alt=""></p><p>这时元素3完全覆盖住了元素2,当元素3设为：margin-left:-200px时：</p><p><img src="https://pic4.zhimg.com/v2-fcc5dd42f3e8df550341c5af6a00fcfb_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-fcc5dd42f3e8df550341c5af6a00fcfb_hd.jpg" alt=""></p><p>我们看到元素3继续向左移动并覆盖住了元素1。</p><p>现在想必大家都明白了负边距对浮动元素位置的影响了吧。所以那些说得很好听的什么圣杯布局、双飞翼布局啊什么的，都是利用这个原理实现的。就是某个元素虽然是写在了后面，但可以通过负边距让它在浏览器显示的时候是在前面的。这个以后可以再慢慢讲。</p><p>负边距对绝对定位元素的影响</p><p>绝对定位的元素定义的top、right、bottom、left等值是元素自身的边界到最近的已定位的祖先元素的距离，这个元素自身的边界指的就是margin定义的边界，所以，如果margin为正的时候，那它的边界是向外扩的，如果margin为负的时候，则它的边界是向里收的。利用这点，就有了经典的利用绝对定位来居中的方法：</p><p><img src="https://pic4.zhimg.com/v2-dffb7a1006cc4f494125e196595e79db_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-dffb7a1006cc4f494125e196595e79db_hd.jpg" alt=""></p><p>看下效果：</p><p><img src="https://pic3.zhimg.com/v2-61da203d81eb5f79ac55ca7811a35ff2_b.jpg" alt=""><img src="https://pic3.zhimg.com/80/v2-61da203d81eb5f79ac55ca7811a35ff2_hd.jpg" alt=""></p><p>但该方法的缺点是必须要知道要居中元素的高度和宽度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>requestAnimationFrame</title>
      <link href="/2015/07/08/requestAnimationFrame/"/>
      <url>/2015/07/08/requestAnimationFrame/</url>
      
        <content type="html"><![CDATA[<p>在Web应用中，实现动画效果的方法比较多，JavaScript 中可以通过定时器 setTimeout 来实现，css3 可以使用 transition 和 animation 来实现，html5 中的 canvas 也可以实现。除此之外，html5 还提供一个专门用于请求动画的 API，即  requestAnimationFrame（rAF），顾名思义就是 “请求动画帧”<strong>。 </strong>为了深入理解  rAF 背后的原理（后文的 rAF 均指的是 requestAnimationFrame），我们首先需要了解一下与之相关的几个概念：</p><h3 id="屏幕绘制频率"><a href="#屏幕绘制频率" class="headerlink" title="屏幕绘制频率"></a>屏幕绘制频率</h3><p>即图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，它的单位是赫兹(Hz)。 对于一般笔记本电脑，这个频率大概是60Hz， 可以在桌面上 右键 &gt; 屏幕分辨率 &gt; 高级设置 &gt; 监视器 中查看和设置。这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响，原则上设置成让眼睛看着舒适的值都行。</p><p>市面上常见的显示器有两种，即 <strong>CRT </strong>和 <strong>LCD</strong>， CRT 就是传统显示器，LCD 就是我们常说的液晶显示器。</p><p>CRT 是一种使用阴极射线管的显示器，屏幕上的图形图像是由一个个因电子束击打而发光的荧光点组成，由于显像管内荧光粉受到电子束击打后发光的时间很短，所以电子束必须不断击打荧光粉使其持续发光。<strong>电子束每秒击打荧光粉的次数就是屏幕绘制频率。</strong></p><p>而对于 LCD 来说，则不存在绘制频率的问题，因为 LCD 中每个像素都在持续不断地发光，直到不发光的电压改变并被送到控制器中，所以 LCD 不会有电子束击打荧光粉而引起的闪烁现象。</p><p>因此，<strong>当你对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率正在不断的更新屏幕上的图像</strong>。为什么你感觉不到这个变化？ 那是因为人的眼睛有<strong>视觉停留效应</strong>，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了，这中间只间隔了16.7ms(1000/60≈16.7)， 所以会让你误以为屏幕上的图像是静止不动的。而屏幕给你的这种感觉是对的，试想一下，如果刷新频率变成1次/秒，屏幕上的图像就会出现严重的闪烁，这样就很容易引起眼睛疲劳、酸痛和头晕目眩等症状。</p><h3 id="CSS-动画原理"><a href="#CSS-动画原理" class="headerlink" title="CSS 动画原理"></a>CSS 动画原理</h3><p>根据上面的原理我们知道，你眼前所看到图像正在以每秒 60 次的频率绘制，由于频率很高，所以你感觉不到它在绘制。而 <strong>动画本质就是要让人眼看到图像被绘制而引起变化的视觉效果，这个变化要以连贯的、平滑的方式进行过渡。</strong> 那怎么样才能做到这种效果呢？ </p><p>60Hz 的屏幕每 16.7ms 绘制一次，如果在屏幕每次绘制前，将元素的位置向左移动一个像素，即1px，这样一来，屏幕每次绘制出来的图像位置都比前一个要差1px，你就会看到图像在移动；而由于人眼的视觉停留效应，当前位置的图像停留在大脑的印象还没消失，紧接着图像又被移到了下一个位置，这样你所看到的效果就是，图像在流畅的移动。这就是视觉效果上形成的动画。 </p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h3><p>理解了上面的概念以后，我们不难发现，setTimeout 其实就是通过设置一个间隔时间来不断的改变图像的位置，从而达到动画效果的。但我们会发现，利用 seTimeout 实现的动画在某些低端机上会出现卡顿、抖动的现象。 这种现象的产生有两个原因：</p><ul><li>setTimeout 的执行时间并不是确定的。在JavaScript中， setTimeout 任务被放进了异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列里的任务是否需要开始执行，所以 <strong>setTimeout 的实际执行时机一般要比其设定的时间晚一些。</strong></li><li>刷新频率受 <strong>屏幕分辨率 </strong>和 <strong>屏幕尺寸 </strong>的影响，不同设备的屏幕绘制频率可能会不同，而 setTimeout 只能设置一个固定的时间间隔，这个时间不一定和屏幕的刷新时间相同。</li></ul><p>以上两种情况都会导致 setTimeout 的执行步调和屏幕的刷新步调不一致，从而引起<strong>丢帧</strong>现象。 那为什么步调不一致就会引起丢帧呢？ </p><p>首先要明白，setTimeout 的执行只是在内存中对元素属性进行改变，这个变化必须要等到屏幕下次绘制时才会被更新到屏幕上。如果两者的步调不一致，就可能会导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素。假设屏幕每隔16.7ms刷新一次，而setTimeout 每隔10ms设置图像向左移动1px， 就会出现如下绘制过程：</p><ul><li>第    0  ms：屏幕未绘制，  等待中，setTimeout 也未执行，等待中；</li><li>第   10 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置元素属性 left=1px；</li><li>第 16.7 ms：屏幕开始绘制，屏幕上的元素向左移动了 1px， setTimeout 未执行，继续等待中；</li><li>第   20 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=2px;</li><li>第   30 ms：屏幕未绘制，等待中，setTimeout 开始执行并设置 left=3px;</li><li>第33.4 ms：屏幕开始绘制，屏幕上的元素向左移动了 3px， setTimeout 未执行，继续等待中；</li><li>…</li></ul><p>从上面的绘制过程中可以看出，屏幕没有更新 left=2px 的那一帧画面，元素直接从left=1px 的位置跳到了 left=3px 的的位置，这就是丢帧现象，这种现象就会引起动画卡顿。</p><h3 id="rAF"><a href="#rAF" class="headerlink" title="rAF"></a>rAF</h3><p>与 setTimeout 相比，rAF 最大的优势是 <strong>由系统来决定回调函数的执行时机。</strong>具体一点讲就是，<strong>系统每次绘制之前会主动调用 rAF 中的回调函数</strong>，如果系统绘制率是 60Hz，那么回调函数就每16.7ms 被执行一次，如果绘制频率是75Hz，那么这个间隔时间就变成了 1000/75=13.3ms。换句话说就是，rAF 的执行步伐跟着系统的绘制频率走。<strong>它能保证回调函数在屏幕每一次的绘制间隔中只被执行一次</strong>，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p><p>这个API的调用很简单，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var progress = 0;</span><br><span class="line">//回调函数</span><br><span class="line">function render() &#123;</span><br><span class="line">    progress += 1; //修改图像的位置</span><br><span class="line"> </span><br><span class="line">    if (progress &lt; 100) &#123;</span><br><span class="line">           //在动画没有结束前，递归渲染</span><br><span class="line">           window.requestAnimationFrame(render);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//第一帧渲染</span><br><span class="line">window.requestAnimationFrame(render);</span><br></pre></td></tr></table></figure></p><p>除此之外，rAF 还有以下两个优势：</p><blockquote><p><strong>CPU节能</strong>：使用 setTimeout 实现的动画，当页面被隐藏或最小化时，setTimeout 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，而且还浪费 CPU 资源。而 rAF 则完全不同，当页面处理未激活的状态下，该页面的屏幕绘制任务也会被系统暂停，因此跟着系统步伐走的 rAF 也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了 CPU 开销。</p></blockquote><blockquote><p><strong>函数节流</strong>：在高频率事件(resize,scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，使用 rAF 可保证每个绘制间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销。一个绘制间隔内函数执行多次时没有意义的，因为显示器每16.7ms 绘制一次，多次绘制并不会在屏幕上体现出来。</p></blockquote><h3 id="优雅降级"><a href="#优雅降级" class="headerlink" title="优雅降级"></a>优雅降级</h3><p>由于 rAF 目前还存在兼容性问题，而且不同的浏览器还需要带不同的前缀。因此需要通过优雅降级的方式对 rAF 进行封装，优先使用高级特性，然后再根据不同浏览器的情况进行回退，直止只能使用 setTimeout 的情况，因此可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.requestAnimFrame = (function()&#123;</span><br><span class="line">  return  window.requestAnimationFrame       ||</span><br><span class="line">          window.webkitRequestAnimationFrame ||</span><br><span class="line">          window.mozRequestAnimationFrame    ||</span><br><span class="line">          function( callback )&#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">          &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>但这种写法没有考虑 cancelAnimationFrame 的兼容性，并且不是所有的设备绘制时间间隔都是1000/60，下面的代码是比较全的一个 polyfill，详情介绍请参考： <a href="https://github.com/darius/requestAnimationFrame" target="_blank" rel="noopener">requestAnimationFrame</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if (!Date.now)</span><br><span class="line">    Date.now = function() &#123; return new Date().getTime(); &#125;;</span><br><span class="line"> </span><br><span class="line">(function() &#123;</span><br><span class="line">    &apos;use strict&apos;;</span><br><span class="line">     </span><br><span class="line">    var vendors = [&apos;webkit&apos;, &apos;moz&apos;];</span><br><span class="line">    for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) &#123;</span><br><span class="line">        var vp = vendors[i];</span><br><span class="line">        window.requestAnimationFrame = window[vp+&apos;RequestAnimationFrame&apos;];</span><br><span class="line">        window.cancelAnimationFrame = (window[vp+&apos;CancelAnimationFrame&apos;]</span><br><span class="line">                                   || window[vp+&apos;CancelRequestAnimationFrame&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy</span><br><span class="line">        || !window.requestAnimationFrame || !window.cancelAnimationFrame) &#123;</span><br><span class="line">        var lastTime = 0;</span><br><span class="line">        window.requestAnimationFrame = function(callback) &#123;</span><br><span class="line">            var now = Date.now();</span><br><span class="line">            var nextTime = Math.max(lastTime + 16, now);</span><br><span class="line">            return setTimeout(function() &#123; callback(lastTime = nextTime); &#125;,</span><br><span class="line">                              nextTime - now);</span><br><span class="line">        &#125;;</span><br><span class="line">        window.cancelAnimationFrame = clearTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> requestAnimationFrame </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法的时间复杂度和空间复杂度</title>
      <link href="/2015/06/22/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2015/06/22/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>1 - 算法</p><p>算法的定义是这样的：解题方案的准确而完善的描述，是一系列解决问题的清晰指令。巴拉巴拉的，虽然是一小句但还是不想看（题外话：有时候吧专业名词记下来面试的时候还是挺有用的），其实就是解决一个问题的完整性描述。只不过这个描述就可能是用不同的方式或者说是“语言”了。</p><p>2 - 算法的效率</p><p>既然算法是解决问题的描述，那么就像一千个人眼中有一千个阿姆雷特他大姨夫一样，解决同一个问题的办法也是多种多样的，只是在这过程中我们所使用/消耗的时间或者时间以外的代价（计算机消耗的则为内存了）不一样。为了更快、更好、更强的发扬奥利奥..哦不，提高算法的效率。所以很多时候一个优秀的算法就在于它与其他实现同一个问题的算法相比，在时间或空间（内存）或者时间和空间（内存）上都得到明显的降低。</p><p>所以呢，算法的效率主要由以下两个复杂度来评估：</p><blockquote><p>时间复杂度：评估执行程序所需的时间。可以估算出程序对处理器的使用程度。<br>空间复杂度：评估执行程序所需的存储空间。可以估算出程序对计算机内存的使用程度。</p></blockquote><p>设计算法时，时间复杂度要比空间复杂度更容易出问题，所以一般情况一下我们只对时间复杂度进行研究。一般面试或者工作的时候没有特别说明的话，复杂度就是指时间复杂度。</p><p>2.0 - 时间复杂度</p><p>接下来我们还需要知道另一个概念：时间频度。这个时候你可能会说：“不是说好一起学算法吗，这些东东是什么？赠品吗？”。非也非也，这是非卖品。</p><p>因为一个算法执行所消耗的时间理论上是不能算出来的，没错正是理论上，so我们任然可以在程序中测试获得。但是我们不可能又没必要对每个算法进行测试，只需要知道大概的哪个算法执行所花费的时间多，哪个花费的时间少就行了。如果一个算法所花费的时间与算法中代码语句执行次数成正比，那么那个算法执行语句越多，它的花费时间也就越多。我们把一个算法中的语句执行次数称为时间频度。通常（ps:很想知道通常是谁）用<code>T(n)</code>表示。</p><p>在时间频度<code>T(n)</code>中，n又代表着问题的规模，当n不断变化时，<code>T(n)</code>也会不断地随之变化。为了了解这个变化的规律，时间复杂度这一概念就被引入了。一般情况下算法基础本操作的重复执行次数为问题规模n的某个函数，用也就是时间频度<code>T(n)</code>。如果有某个辅助函数<code>f(n)</code>，当趋于无穷大的时候，<code>T(n)/f(n)</code>的极限值是不为零的某个常数，那么<code>f(n)</code>是<code>T(n)</code>的同数量级函数，记作<code>T(n)=O(f(n))</code>，被称为算法的渐进时间复杂度，又简称为时间复杂度。</p><p>2.1 - 大O表示法</p><p>用O(n)来体现算法时间复杂度的记法被称作大O表示法</p><p>一般我们我们评估一个算法都是直接评估它的最坏的复杂度。</p><p>大O表示法<code>O(f(n))</code>中的<code>f(n)</code>的值可以为1、n、logn、n^2 等，所以我们将O(1)、O(n)、O(logn)、O( n^2 )分别称为常数阶、线性阶、对数阶和平方阶。下面我们来看看推导大O阶的方法：</p><p>推导大O阶</p><p>推导大O阶有一下三种规则：</p><ol><li>用常数1取代运行时间中的所有加法常数</li><li>只保留最高阶项</li><li>去除最高阶的常数</li></ol><p>举好多栗子</p><ul><li><p>常数阶</p><p>  let sum = 0, n = 10; // 语句执行一次<br>  let sum = (1+n)*n/2; // 语句执行一次<br>  console.log(<code>The sum is : ${sum}</code>) //语句执行一次 </p></li></ul><p>这样的一段代码它的执行次数为 3 ，然后我们套用规则1，则这个算法的时间复杂度为O(1)，也就是常数阶。</p><ul><li><p>线性阶</p><p>  let i =0; // 语句执行一次<br>  while (i &lt; n) { // 语句执行n次 </p><pre><code>console.log(`Current i is ${i}`); //语句执行n次i++; // 语句执行n次</code></pre><p>  }</p></li></ul><p>这个算法中代码总共执行了 3n + 1次，根据规则 2-&gt;3，因此该算法的时间复杂度是O(n)。</p><ul><li><p>对数阶</p><p>  let number = 1; // 语句执行一次<br>  while (number &lt; n) { // 语句执行logn次</p><pre><code>number *= 2; // 语句执行logn次</code></pre><p>  }</p></li></ul><p>上面的算法中，number每次都放大两倍，我们假设这个循环体执行了m次，那么<code>2^m = n</code>即<code>m = logn</code>，所以整段代码执行次数为1 + 2*logn，则<code>f(n) = logn</code>，时间复杂度为O(logn)。</p><ul><li><p>平方阶</p><p>  for (let i = 0; i &lt; n; i++) { // 语句执行n次 </p><pre><code>for (let j = 0; j &lt; n; j++) { // 语句执行n^2次    console.log(&apos;I am here!&apos;); // 语句执行n^2}</code></pre><p>  }</p></li></ul><p>上面的嵌套循环中，代码共执行 2*n^2 + n，则<code>f(n) = n^2</code>。所以该算法的时间复杂度为O(n^2 )</p><p>常见时间复杂度的比较</p><p>常见的时间复杂度函数相信大家在大学中都已经见过了，这里也不多做解释了：</p><p>O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n²)&lt;O(n³)&lt;O(2ⁿ)&lt;O(n!)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从你在浏览器输入一个网址....</title>
      <link href="/2015/06/01/%E4%BB%8E%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80.../"/>
      <url>/2015/06/01/%E4%BB%8E%E4%BD%A0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BD%91%E5%9D%80.../</url>
      
        <content type="html"><![CDATA[<h2 id="从你在浏览器输入一个网址…"><a href="#从你在浏览器输入一个网址…" class="headerlink" title="从你在浏览器输入一个网址…"></a><a href="https://zhuanlan.zhihu.com/p/30621272" target="_blank" rel="noopener">从你在浏览器输入一个网址…</a></h2><p>我们在面试的时候或许经常会被问到：</p><blockquote><p>从你在浏览器输入一个网址到网页内容完全被展示的这段时间内，都发生了什么事情？</p></blockquote><p>确实是个老生常谈的问题，但问题的答案并不是唯一的，或许在三五年前，这个问题还会有一个「相对」标准的答案。</p><ol><li>浏览器在接收到这个请求时，会开启一个单独的线程来处理这个请求，首先要判断用户输入是否为合法或合理的 URL 地址，是否为 HTTP 协议请求，如果是那就进入下一步</li><li>浏览器的浏览器引擎将对此 URL 进行分析加载</li><li>通过 DNS 解析域名获取该网站地址对应的 IP 地址，查询完成后连同浏览器的 Cookie、 userAgent 等信息向网站目的 IP 发出 GET 请求。</li><li>接下来就是经典的「三次握手」，HTTP 协议会话，浏览器客户端向 Web 服务器发送报文，进行通讯和数据传输。</li><li>进入网站的后端服务，如 Tomcat、Apache 等，还有近几年流行的 Node.js 服务器，这些服务器上部署着应用代码，语言有很多，如 Java、 PHP、 C++、 C# 和 Javascript 等。</li><li>服务器根据 URL 执行相应的后端应用逻辑，整理数据组装成一个完整的 HTML 数据返回给浏览器，期间会使用到「服务器缓存」或「数据库」内的内容。</li><li>浏览器接收到返回信息后先判读此 HTML 文件是否存在本地缓存，如果不存在或不可用，则下载此 HTML 文件（200状态码），如果可用（未过期），则走浏览器缓存（304返回码）。「强缓存（200返回码）不在考虑范围」</li><li>浏览器的渲染引擎在拿到 HTML 文件后，便开始解析构建 DOM 数，并根据 HTML 中的标记请求下载指定的 MIME 类型文件（如 CSS、 JavaScript 脚本等），同时使用&amp;设置缓存等内容。</li><li>渲染引擎根据 CSS 样式规则将 DOM 树扩充为渲染树，然后进行重排、重绘。</li><li>如果含有 JS 文件将会执行，进行 Dom 操作、缓存读存、时间绑定等操作。最终页面将被展示在浏览器上。</li></ol><p>此答案精简的概括了「后端为主的 MVC 模式」及早期 Web 应用的浏览器相应的全过程。那，前端技术发展到现在，「前后端分离」「中间件直出」和「MNV*模式」也已问世，再谈及此问题，答案会有不同。</p><p>就以「前后端分离」为例，在上方答案的第4步后，紧接着就不会直接进入后端服务器了。而会被 HTTP 和反向代理服务器，如 Ngnix，代替。</p><ul><li>前置步骤1、2、3、4</li><li>Ngnix 在接收到 HTTP（80端口）或 HTTPS（443端口）后，根据 URL 做服务器分发，分发（rewrite）到后端服务器或静态资源服务器，首页请求基本是静态服务器，返回一个静态的 HTML 文件</li><li>步骤7、8、9</li><li>执行 JS 脚本，异步 ajax、 fetch 发起 POST、 GET 请求，重新进入 Ngnix 分发，此次分发到后端服务器，步骤5、6，然后返回一个 xml 或 json 格式的信息，一般含有 code（返回码）、result（依赖信息）</li><li>最后根据返回码执行不同的 js 逻辑，增删改页面元素，此时可能会发生重排或重汇。首页加载结束。</li></ul><p>以上步骤可以发现，浏览器可能会触发重绘两次，极易发生「白屏」或「页面抖动」，为了解决这个问题「中间件直出」的模式应运而生。另外为了扩充大前端的阵营，吸纳 IOS 和 Android，Google又设计了「MNV*模式」，典型代表就是 ReactNative，但此模式已经脱离了浏览器的范畴，此处就不再做扩展。</p><p>以上讨论的渲染过程中使用到了较多的浏览器功能，如用户地址栏输入框、网络请求、浏览器文档解析、渲染引擎渲染网页、 JavaScript 引擎执行js脚本、客户端存储等。 接下来我们介绍下浏览器的基本结构组成。</p><h2 id="浏览器的结构组成"><a href="#浏览器的结构组成" class="headerlink" title="浏览器的结构组成"></a>浏览器的结构组成</h2><p>浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储） 如下图：</p><p><img src="https://pic1.zhimg.com/v2-47101c25a44a21a25f3123a88c623b15_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-47101c25a44a21a25f3123a88c623b15_hd.jpg" alt=""></p><ul><li>用户界面－包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了页面显示窗口之外的其他部分</li><li>浏览器引擎－可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心</li><li>渲染引擎－解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎</li><li>网络－用来完成网络调用或资源下载的模块</li><li>UI 后端－用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的效果也不同</li><li>JS解释器－用来解释执行JS脚本的模块，如 V8 引擎</li><li>数据存储－浏览器在硬盘中保存 cookie、localStorage等各种数据，可通过浏览器引擎提供的API进行调用</li></ul><p>作为前端开发人员，我们需要重点理解渲染引擎的工作原理，灵活应用数据存储技术，在实际项目开发中会经常涉及到这两个部分，尤其是在做项目性能优化时，理解浏览器渲染引擎尤为重要。而其他部分则是由各种浏览器自行管理的，开发者能控制的地方较少。今天我们就围绕这两个重点其中的一个部分「浏览器渲染引擎」进行展开</p><h2 id="浏览器渲染引擎"><a href="#浏览器渲染引擎" class="headerlink" title="浏览器渲染引擎"></a>浏览器渲染引擎</h2><p>浏览器渲染引擎是由各大浏览器厂商依照 W3C 标准自行实现的，也被称之为「浏览器内核」。</p><p>目前，市面上使用的主流浏览器内核有5类：Trident、Gecko、Presto、Webkit、Blink。</p><p>Trident：俗称 IE 内核，也被叫做 MSHTML 引擎，目前在使用的浏览器为 IE11-，以及各种国产多核浏览器中的IE兼容模式。另外Edge 浏览器不再使用 MSHTML 引擎，而是使用类全新的引擎 EdgeHTML。</p><p>Gecko：俗称 Firefox 内核，Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。</p><p>Presto：Opera 前内核，为啥说是前内核呢？因为 Opera12.17 以后便拥抱了 Google Chrome 的 Blink 内核，此内核就没了寄托</p><p>Webkit：Safari 内核也是 Chrome 内核原型，主要是 Safari 浏览器在使用的内核，也是特性上表现较好的浏览器内核。也被大量使用在移动端浏览器上。</p><p>Blink： 由Google和Opera Software开发的浏览器排版引擎，在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器 中使用。Blink 其实是 WebKit 的一个分支，添加了一些优化的新特性，例如跨进程的 iframe，将 DOM 移入 JavaScript 中来提高 JavaScript 对 DOM 的访问速度等，目前较多的移动端应用内嵌的浏览器内核也渐渐开始采用 Blink。</p><h2 id="渲染引擎的工作流程"><a href="#渲染引擎的工作流程" class="headerlink" title="渲染引擎的工作流程"></a>渲染引擎的工作流程</h2><p>浏览器渲染引擎重要的工作就是将 HTML 和 CSS 文档解析组合最终渲染到浏览器窗口上。如下图所示，渲染引擎在接受到 HTML 文件后主要进行了以下操作：解析 HTML 构建 DOM 树 -&gt; 构建渲染树 -&gt; 渲染树布局 -&gt; 渲染树绘制。</p><p><img src="https://pic2.zhimg.com/v2-898d192f36fcc9c8843ec9d89f112bde_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-898d192f36fcc9c8843ec9d89f112bde_hd.jpg" alt=""></p><p>解析 HTML 构建 DOM 树时渲染引擎会将 HTML 文件的便签元素解析成多个 DOM 元素对象节点，并且将这些对象根据父子关系组成一个树结构。同时 CSS 文件被解析成 CSS规则表，然后将每条 CSS 规则按照「从右向左」的方式在 DOM 树上进行逆向匹配，生成一个具有样式规则描述的 DOM 渲染树。接下来就是将渲染树进行布局、绘制的过程。首先根据 DOM 渲染树上的样式规则，对 DOM 元素进行大小和位置的定位，关键属性如<code>position;width;margin;padding;top;border;...</code>，接下来在根据元素样式规则中的<code>color;background;shadow;...</code>规则进行 DOM 的绘制。</p><p>另外，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><p>再者，需要注意的是，在浏览器渲染完首屏页面后，如果对 DOM 进行操作会引起浏览器引擎对 DOM 渲染树的重新布局和重新绘制，我们叫做「重排」和「重绘」，由于重排和重绘是前后依赖的关系，所以重绘发生时未必会触发渲染引擎的重排，但是如果发生了重排就必然会触发重绘操作，这样带来的性能损害就是巨大的。因此我们在做性能优化的时候应该遵循「避免重排；减少重绘」的原则。</p><h2 id="不同浏览器内核间的差异"><a href="#不同浏览器内核间的差异" class="headerlink" title="不同浏览器内核间的差异"></a>不同浏览器内核间的差异</h2><p>在不同的浏览器内核下， 浏览器页面渲染的流程略有不同</p><p><img src="https://pic2.zhimg.com/v2-d29985fb1443ee3dc499a2b974f52c0e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-d29985fb1443ee3dc499a2b974f52c0e_hd.jpg" alt=""></p><p><img src="https://pic2.zhimg.com/v2-17090b8745e504fd6877dfa6f5950422_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-17090b8745e504fd6877dfa6f5950422_hd.jpg" alt=""></p><p>上面两幅图分别是 Webkit 和 Geoko 内核渲染 DOM 的工作流程，对比可以看出，两者流程的区别主要在于 CSS 样式表的解析时机，Webkit 内核下，HTML 和 CSS 文件的解析是同步的，而 Geoko 内核下，CSS 文件需要等到 HTML 文件解析成内容 Sink 后才进行解析。</p><p>另外两者的不同还有描述术语，除此之外两者的流程就基本相同了，其中最重要的三个部分就是 「HTML 的解析」「CSS 的解析」「渲染树的生成」。这三个部分的原理内容就比较深，涉及到「词法分析」「语法分析」「转换」「解释」等数据结构的内容，比较枯燥，一般我们了解到这里就够了，不过想深入了解的同学可以阅读此篇译文，<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fblog.csdn.net%252Fu010794365%252Farticle%252Fdetails%252F77982768" target="_blank" rel="noopener">浏览器的工作原理</a>，里面详细的解释了以上三个部分的流程和关系。此处就不再多做赘述了。</p><h2 id="关于-CSS-规则的匹配"><a href="#关于-CSS-规则的匹配" class="headerlink" title="关于 CSS 规则的匹配"></a>关于 CSS 规则的匹配</h2><p>上面我们提到过， CSS 规则是按照「从右向左」的方式在 DOM 树上进行逆向匹配的，最终生成一个具有样式规则描述的 DOM 渲染树。</p><p>但是你知道为什么要「从右向左」做逆向匹配码？</p><p>我们重新回到【webkit 内核工作流程】图</p><p><img src="https://pic2.zhimg.com/v2-d29985fb1443ee3dc499a2b974f52c0e_b.jpg" alt=""><img src="https://pic2.zhimg.com/80/v2-d29985fb1443ee3dc499a2b974f52c0e_hd.jpg" alt=""></p><p>CSS 规则匹配是发生在webkit引擎的「Attachment」过程中，浏览器要为每个 DOM Tree 中的元素扩充 CSS 样式规则（匹配 Style Rules）。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。</p><p>我们来举一个最简单的栗子：</p><pre><code>&lt;template&gt;&lt;div&gt;  &lt;div class=&quot;t&quot;&gt;    &lt;span&gt;test&lt;/span&gt;    &lt;p&gt;test&lt;/p&gt;  &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;div{ color: #000; }div .t span{ color: red; }div .t p{color: blue; }&lt;/style&gt;</code></pre><p>此处我们有一个 html 元素 和一个 style 元素，两者需要做遍历匹配</p><p><img src="https://pic1.zhimg.com/v2-727bdb01745d4f9692a5f7a8678e62e2_b.jpg" alt=""><img src="https://pic1.zhimg.com/80/v2-727bdb01745d4f9692a5f7a8678e62e2_hd.jpg" alt=""></p><p>此处会有 4*3 个匹配项，如果做正向匹配，在遇到 <code>&lt;span&gt;</code> 标签匹配 <code>div .t p{ color: red; }</code>到匹配项时，显然时不通过到，计算机首先要找到<code>&lt;span&gt;</code> 标签到父标签和祖父标签，判断他们是否满足<code>div .t</code>的规则，然后在匹配<code>&lt;span&gt;</code>是否为<code>p</code>标签，此处匹配不成功，此处就产生了三次浪费。</p><p>如果时逆向匹配，那么第一次对比<code>&lt;span&gt;</code>是否为<code>p</code>标签便可排除此规则，效率更高。</p><p>如果将 HTML 结构变复杂，CSS 规则表变庞大，那么，「逆向匹配」的优势就远大于「正向匹配」了，因为匹配的情况远远低于不匹配的情况。同时如果在选择器结尾加上通配符「*」，那么「逆向匹配」的优势就大打折扣，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。</p><p>极限了想，如果我们的样式表不存在嵌套关系，如下：</p><pre><code>&lt;template&gt;&lt;div&gt;  &lt;div&gt;    &lt;span class=&quot;div_t_span&quot;&gt;test&lt;/span&gt;    &lt;p class=&quot;div_t_p&quot;&gt;test&lt;/p&gt;  &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;style&gt;div{ color: #000; }.div_t_span{ color: red; }.div_t_p{color: blue; }&lt;/style</code></pre><p>那么引擎的「Attachment」过程将得到极大的精简，效率也是可想而知的，这就是为什么「微信小程序」样式表不建议使用关系行写法的原因。</p><h2 id="相关的性能优化"><a href="#相关的性能优化" class="headerlink" title="相关的性能优化"></a>相关的性能优化</h2><p>由以上介绍，我们大致可以在案例中看到同浏览器渲染引擎相关的可行优化点。</p><p>大致为以下几种</p><ol><li>减少 JS 加载对 Dom 渲染的影响：将 JS 文件放在 HTML 文档后加载，或者使用异步的方式加载 JS 代码</li><li>避免重排，减少重绘：在做css动画的时候减少使用 width、 margin、 padding等影响 CSS 布局对规则，可以使用 CSS3 的 transform 代替</li><li>减少使用关系型样式表的写法：直接使用唯一的类名即可最大限度的提升渲染效率</li><li>减少 DOM 的层级：减少无意义的dom 层级可以减少 渲染引擎 Attachment 过程中的匹配计算量</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS等比例缩放的盒子</title>
      <link href="/2015/05/19/CSS%E7%AD%89%E6%AF%94%E4%BE%8B%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9B%92%E5%AD%90/"/>
      <url>/2015/05/19/CSS%E7%AD%89%E6%AF%94%E4%BE%8B%E7%BC%A9%E6%94%BE%E7%9A%84%E7%9B%92%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>你肯定已经知道，对于一个 img 元素而言，你可以单独地修改它的 width 或者 height 属性来设置它的大小，同时图片的比例还能够保持不变。</p><p>如下图所示，最上面是原始大小的图片，下面两张则分别是设置了 width: 50% 和 height: 50% 属性后的样子。</p><p><img src="https://pic4.zhimg.com/v2-7d10c44225e25e1929ef517567b2494e_b.jpg" alt=""><img src="https://pic4.zhimg.com/80/v2-7d10c44225e25e1929ef517567b2494e_hd.jpg" alt=""></p><p>可以看到把宽度设置为了原来的一半的同时，图片的高度并不是保持原来的大小，而是相应的也变成了原来的一半，使得图片仍能够保持原有的比例。同理把高度设成原来的一半也如此。</p><p>作为对照，我们看看单独修改其他元素的宽和高会产生什么样的效果：</p><p><img src="https://pic2.zhimg.com/v2-cc30532f26d4295a7e0462953833552f_b.jpg" alt=""></p><p>上图最左边的蓝色矩形是原始的 div 元素，之后两个分别是对其设置了 width: 50% 和 height: 50% 属性后的样子。可见与 img 元素不同，单独设置 div 元素的宽度（高度）时，对应的高度（宽度）并不会改变，从而导致元素的比例发生变化。这一结果相信每个稍微对前端有些了解的同学都能猜到。但是究竟是什么导致了同样的属性用于 img 和 div 后会产生不同的结果呢？</p><p>img 在元素分类中属于 replaced （被替换的）元素。replaced 元素表示这个元素内容的显示不是由 CSS 控制的。换句话说，对于 img 元素而言，图片的内容并不是由 CSS 定义的，而是通过其 src 属性指向的资源决定的。很多 replaced 元素来都会有自己的固有尺寸（Intrinsic dimension），img 也不例外<a href="https://link.zhihu.com/?target=https%3A//w3ctech.com/topic/1483%23fn1" target="_blank" rel="noopener">1</a>。当 img 的高度改变后，浏览器会计算出其缩放比例，而当元素的宽度是 auto（即默认值）时，浏览器则以原始宽度 * 缩放比例来作为元素的新宽度。从而使得 img 元素的比例始终保持一致。</p><p>然而这都并不是这篇文章讨论的重点。（那位同学请不要说脏话，不文明</p><p>重点是什么？重点就是题目：实现等比例缩放的盒子。</p><p>在响应式设计逐渐成为主流的今天，流式布局这个词即使放在一两年前也绝算不得是个新鲜词汇。下面是一个布局实例：</p><p><img src="https://pic2.zhimg.com/v2-2779b8fa48f397ead12b687f02268f79_b.jpg" alt=""></p><p>上图中每个蓝色的矩形分别对应一个 div 元素，每个元素的宽度占窗口宽度的四分之一（图示中为了演示方便给每个元素加了边距效果）。如果不做额外处理，当窗口宽度变小时上图的页面会变为如下所示：</p><p><img src="https://pic1.zhimg.com/v2-2c13b3a8546f34fba43822499db2795b_b.jpg" alt=""></p><p>可见每个元素的宽度进行了缩放，但高度并没有变化，看起来并不是很协调。所以有些场景下我们需要实现当窗口宽度缩放时，使得元素宽度自适应的同时，保证每个元素的宽高比例不变。</p><p>很多同学在我话还没讲完时，就已经纷纷掏出 JavaScript 大锤着手实现了起来。然而这个系列文章的标题是《你不知道的 CSS》，自然不会介绍 CSS 实现不了这种打自己脸的需求，而且就此例而言，使用 JavaScript 实现效果并不好，绑定 onresize 事件后在拖拽时某些星座的朋友会察觉出来些许卡顿（你试试便知），而且在 JavaScript 加载完成前是看不出效果的。</p><p>其实用 CSS 可以很容易地实现这样的效果，用的属性也是我们每个工作日和周末（如果加班的话）都会用到的：padding-bottom。padding-bottom 有一个让人很容易忽略的特性是当它的值是百分比形式时，百分比的基数是其所在元素的父元素的宽度而不是高度（同 padding-left 和 padding-right 一样）。这样解决方案也就非常明显了：</p><ol><li>将元素的 height 设成 0，使得元素的高度等于 padding-bottom；</li><li>合理设置 padding-bottom 的值。比如每个元素的 width 是 25%，现在想让元素的高度始终保持为其宽度的两倍，则 padding-bottom 的值应该设置为 50%。</li></ol><p>结果如下图所示：</p><p><img src="https://pic3.zhimg.com/v2-7b00baecc0fe2eac37eb4515b29314b4_b.jpg" alt=""></p><p>相应的代码可以参见：<a href="https://link.zhihu.com/?target=http%3A//jsfiddle.net/luin/25BbH/7/" target="_blank" rel="noopener">http://jsfiddle.net/luin/25BbH/7/</a>。</p><p>然而至此，这篇文章还没完。肯定会有很多同学疑惑既然 height 被设成了 0，那么如果元素的 overflow 为 hidden，里面的文字会不会因为超出了元素高度而被隐藏呢？</p><p>答案是不会。根据 CSS 2.1 规范<a href="https://link.zhihu.com/?target=https%3A//w3ctech.com/topic/1483%23fn2" target="_blank" rel="noopener">2</a>，overflow 只会对处于 padding edge 外面的内容生效，即只有超出了 padding 区域的内容才会被 overflow 属性隐藏掉。</p><ol><li>其实有一点例外的情况是当 img 的图片是 svg 时，它是没有固有尺寸的。 <a href="https://link.zhihu.com/?target=https%3A//w3ctech.com/topic/1483%23ffn1" target="_blank" rel="noopener">↩</a></li><li><p><a href="https://link.zhihu.com/?target=http%3A//www.w3.org/TR/CSS2/visufx.html" target="_blank" rel="noopener">http://www.w3.org/TR/CSS2/visufx.html</a><a href="https://link.zhihu.com/?target=https%3A//w3ctech.com/topic/1483%23ffn2" target="_blank" rel="noopener">↩</a></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            .item {                float: left;                width: 21%;                margin: 10px 2%;                height: 0;                padding-bottom: 33.98%;                background-color: #dbe0e4;            }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ajax与Comet</title>
      <link href="/2015/04/26/Ajax%E4%B8%8EComet/"/>
      <url>/2015/04/26/Ajax%E4%B8%8EComet/</url>
      
        <content type="html"><![CDATA[<h3 id="服务器有新消息主动推送给客户端浏览器"><a href="#服务器有新消息主动推送给客户端浏览器" class="headerlink" title="服务器有新消息主动推送给客户端浏览器"></a><a href="https://www.cnblogs.com/study-everyday/p/6140498.html" target="_blank" rel="noopener">服务器有新消息主动推送给客户端浏览器</a></h3><blockquote><p>下述内存主要讲述了《JavaScript高级程序设计（第3版）》第21章关于“Ajax与Comet”。</p></blockquote><p><strong>Ajax（Asynchronous JavaScript + XML的简写）</strong>可以向服务器请求数据而无需卸载（刷新）页面，带来更好的用户体验。<br><strong>Ajax技术的核心是XMLHttpRequest对象（简称XHR）。</strong></p><h3 id="一、XMLHttpRequest对象"><a href="#一、XMLHttpRequest对象" class="headerlink" title="一、XMLHttpRequest对象"></a>一、XMLHttpRequest对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/* 兼容IE早期版本 */</span><br><span class="line">function createXHR()&#123;</span><br><span class="line">    if (typeof XMLHttpRequest != &quot;undefined&quot;)&#123;</span><br><span class="line">        return new XMLHttpRequest();</span><br><span class="line">    &#125; else if (typeof ActiveXObject != &quot;undefined&quot;)&#123;    // 适用于IE7之前的版本</span><br><span class="line">        if (typeof arguments.callee.activeXString != &quot;string&quot;)&#123;</span><br><span class="line">            var versions = [&quot;MSXML2.XMLHttp.6.0&quot;, &quot;MSXML2.XMLHttp.3.0&quot;,</span><br><span class="line">                            &quot;MSXML2.XMLHttp&quot;],</span><br><span class="line">                i, len;</span><br><span class="line"></span><br><span class="line">            for (i=0,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    new ActiveXObject(versions[i]);</span><br><span class="line">                    arguments.callee.activeXString = versions[i];</span><br><span class="line">                    break;</span><br><span class="line">                &#125; catch (ex)&#123;</span><br><span class="line">                    //skip</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ActiveXObject(arguments.callee.activeXString);</span><br><span class="line">    &#125; else &#123;  // XHR对象和ActiveX对象都不存在，则抛出错误 </span><br><span class="line">        throw new Error(&quot;No XHR object available.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-XHR的用法"><a href="#1-XHR的用法" class="headerlink" title="1. XHR的用法"></a>1. XHR的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;请求的类型get|post等&quot;, &quot;请求的URL&quot;, &quot;是否异步发送请求&quot;);</span><br></pre></td></tr></table></figure><p><strong>说明：</strong><br>（1）URL相对于执行代码的当前页面（当然也可以使用绝对路径）<br>（2）open()方法并不会真正发送请求，而只是启动一个请求以备发送<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(&quot;请求主体发送的数据&quot;);</span><br></pre></td></tr></table></figure></p><p><strong>说明：</strong><br>（1）如果不需要通过请求主体发送数据（比如get请求），则必须传入null，因为这个参数对有些浏览器来说是必需的<br>（2）调用send()之后，请求就会被分派到服务器</p><p><strong>补充</strong>：xhr.open()方法为“false”，即同步请求，JavaScript代码会等到服务器响应后再继续执行；否则，继续执行后续代码。</p><p>在收到服务器响应后，相应的数据会自动填充XHR对象的属性。</p><ul><li>responseText：作为响应主体被返回的文本</li><li>responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM文档</li><li>status：响应的HTTP状态</li><li>statusText：HTTP状态的说明<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 为确保接收到适当的响应 200:成功；304:资源未被修改</span><br><span class="line">if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>说明</strong>：<br>（1）有的浏览器会错误的报告成功状态码为204<br>（2）无论内容类型是什么，响应主体的内容都会保存到responseText属性中；而对于XML数据而言，responseXML同时也将被赋值，否则其值为null</p><p><strong>对于异步请求，可以检测XHR对象的readyState属性，该属性表示请求/响应过程的当前活动阶段</strong></p><ul><li>0：未初始化。尚未调用open()方法</li><li>1：启动。已经调用open()方法，但尚未调用send()方法</li><li>2：发送。已经调用send()方法，但尚未接收到响应</li><li>3：接收。已经接收到部分响应数据</li><li>4：完成。已经接收全部响应数据，而且已经可以在客户端使用了。</li></ul><p>readyState属性的值发生变化，都会触发<strong>readystatechange</strong>事件。可以利用这个事件来检测每次状态变化后<strong>readyState</strong>的值。不过，<em>必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。</em></p><pre><code>var xhr = createXHR();        xhr.onreadystatechange = function(event){    // 不要使用this，作用域会产生问题，在部分浏览器中会执行失败    if (xhr.readyState == 4){        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){            console.log(xhr.responseText);        } else {            console.log(&quot;Request was unsuccessful: &quot; + xhr.status);        }    }};xhr.open(&quot;get&quot;, &quot;example.txt&quot;, true);xhr.send(null);</code></pre><p>在接收到响应数据之前可以调用abort()方法来取消异步请求：</p><pre><code>xhr.abort();xhr =null; // 解除引用，释放内存</code></pre><h4 id="2-HTTP头部信息"><a href="#2-HTTP头部信息" class="headerlink" title="2. HTTP头部信息"></a>2. HTTP头部信息</h4><p><strong>setRequestHeader()</strong>：设置自定义的请求头信息。必须在调用open()方法之后且调用send()方法之前调用。<br><strong>getResponseHeader() getAllResponseHeaders()</strong>：可以获取指定（全部）响应头信息。</p><pre><code>var xhr = createXHR();        xhr.onreadystatechange = function(){};xhr.open(&quot;get&quot;, &quot;example.php&quot;, true);xhr.setRequestHeader(&quot;MyHeader&quot;, &quot;MyValue&quot;);xhr.send(null);</code></pre><h4 id="3-GET请求"><a href="#3-GET请求" class="headerlink" title="3. GET请求"></a>3. GET请求</h4><p><strong>open()</strong>方法的URL尾部的查询字符串必须经过正确的编码</p><pre><code>functionaddURLParam(url, name, value) {    url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;);    url += encodeURIComponent(name) + &quot;=&quot; + encodeURIComponent(value);    return url;}var url = &quot;http://test.com&quot;;url = addURLParam(url, &quot;uid&quot; , 5);url = addURLParam(url, &quot;siteid&quot;, 123);  // &quot;http://test.com?uid=5&amp;siteid=123&quot;xhr.open(&quot;get&quot;, url, true);xhr.send(null);</code></pre><h4 id="4-POST请求"><a href="#4-POST请求" class="headerlink" title="4. POST请求"></a>4. POST请求</h4><p>POST请求将数据作为请求的主体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/* 序列化表单 */</span><br><span class="line">function serialize(form)&#123;        </span><br><span class="line">    var parts = new Array();</span><br><span class="line">    var field = null;</span><br><span class="line"></span><br><span class="line">    for (var i=0, len=form.elements.length; i &lt; len; i++)&#123;</span><br><span class="line">        field = form.elements[i];</span><br><span class="line"></span><br><span class="line">        switch(field.type)&#123;</span><br><span class="line">            case &quot;select-one&quot;:</span><br><span class="line">            case &quot;select-multiple&quot;:</span><br><span class="line">                for (var j=0, optLen = field.options.length; j &lt; optLen; j++)&#123;</span><br><span class="line">                    var option = field.options[j];</span><br><span class="line">                    if (option.selected)&#123;</span><br><span class="line">                        var optValue = &quot;&quot;;</span><br><span class="line">                        if (option.hasAttribute)&#123;</span><br><span class="line">                            optValue = (option.hasAttribute(&quot;value&quot;) ? </span><br><span class="line">                                        option.value : option.text);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            optValue = (option.attributes[&quot;value&quot;].specified ? </span><br><span class="line">                                        option.value : option.text);</span><br><span class="line">                        &#125;</span><br><span class="line">                        parts.push(encodeURIComponent(field.name) + &quot;=&quot; + </span><br><span class="line">                                   encodeURIComponent(optValue));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case undefined:     //fieldset</span><br><span class="line">            case &quot;file&quot;:        //file input</span><br><span class="line">            case &quot;submit&quot;:      //submit button</span><br><span class="line">            case &quot;reset&quot;:       //reset button</span><br><span class="line">            case &quot;button&quot;:      //custom button</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case &quot;radio&quot;:       //radio button</span><br><span class="line">            case &quot;checkbox&quot;:    //checkbox</span><br><span class="line">                if (!field.checked)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                /* falls through */              </span><br><span class="line">            default:</span><br><span class="line">                parts.push(encodeURIComponent(field.name) + &quot;=&quot; + </span><br><span class="line">                    encodeURIComponent(field.value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    return parts.join(&quot;&amp;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* 发送请求 */</span><br><span class="line">function submitData()&#123;</span><br><span class="line">    var xhr = createXHR();        </span><br><span class="line">    xhr.onreadystatechange = function(event)&#123;</span><br><span class="line">        if (xhr.readyState == 4)&#123;</span><br><span class="line">            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">                alert(xhr.responseText);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                alert(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);</span><br><span class="line">    // 表单提交的内容类型</span><br><span class="line">    xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">    var form = document.getElementById(&quot;user-info&quot;);   </span><br><span class="line">    // 请求主体为数据         </span><br><span class="line">    xhr.send(serialize(form));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、XMLHttpRequest-2级"><a href="#二、XMLHttpRequest-2级" class="headerlink" title="二、XMLHttpRequest 2级"></a>二、XMLHttpRequest 2级</h3><p>XMLHttpRequest 1级只是把已有的XHR对象的实现细节描述了出来。而XMLHttpRequest 2级则进一步发展了XHR。并非所有浏览器都完整地实现了XMLHttpRequest 2级规范，但所有浏览器都实现了它规定的部分内容。</p><h4 id="1-FormData"><a href="#1-FormData" class="headerlink" title="1. FormData"></a>1. FormData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 创建FormData对象</span><br><span class="line">var data=new FormData();</span><br><span class="line">data.append(&quot;name&quot;, &quot;ligang&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 用表单元素填充</span><br><span class="line">xhr.open(&quot;post&quot;, &quot;postexample.php&quot;, true);</span><br><span class="line">var form = document.getElementById(&quot;user-info&quot;);</span><br><span class="line">// 使用FormData的方便之处在于不必明确地在XHR对象上设置请求头。</span><br><span class="line">// xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.send(new FormData(form));</span><br></pre></td></tr></table></figure><h4 id="2-超时设定"><a href="#2-超时设定" class="headerlink" title="2. 超时设定"></a>2. 超时设定</h4><p>IE8为XHR对象添加了一个timeout属性，表示请求在等待响应多少毫秒后就终止。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);</span><br><span class="line">xhr.timeout = 60 * 1000;</span><br><span class="line">xhr.ontimeout = function()&#123;</span><br><span class="line">    alert(&quot;Request did not return in a second.&quot;);</span><br><span class="line">&#125;;        </span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></p><p>对于其他浏览器的兼容做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;get&quot;, &quot;timeout.php&quot;, true);</span><br><span class="line">xhr.onreadystatechange = function(event)&#123;if (xhr.readyState == 4)&#123;</span><br><span class="line">        // 清除定时器</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">            console.log(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 设置超时时间 1分钟</span><br><span class="line">var timeout = setTimeout(function() &#123;</span><br><span class="line">    xmlHttpRequest.abort();</span><br><span class="line">    xmlHttpRequest = null;</span><br><span class="line">&#125;, 60 * 1000);</span><br><span class="line">xmlHttpRequest.send(null);</span><br></pre></td></tr></table></figure></p><h4 id="3-overrideMimeType-方法"><a href="#3-overrideMimeType-方法" class="headerlink" title="3. overrideMimeType()方法"></a>3. overrideMimeType()方法</h4><p>重写XHR响应的MIME类型，<em>必须在send()方法之前</em>。</p><p>如果，服务器返回的MIME类型是text/plain，但数据中实际包含的是XML。根据MIME类型，responseXML属性中仍然是null。此时，通过<strong>overrideMimeType()</strong>方法，可以保证把响应当作XML而非纯文本来处理（即，responseXML中被赋值）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;text.php&quot;, true);</span><br><span class="line">xhr.overrideMimeType(&quot;text/xml&quot;);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></p><h3 id="三、进度事件"><a href="#三、进度事件" class="headerlink" title="三、进度事件"></a>三、进度事件</h3><p>6个进度事件：</p><ul><li>loadstart：在接收到响应数据的第一个字节时触发。</li><li>progress：在接收响应期间持续不断地触发。</li><li>error：在请求发生错误时触发。</li><li>abort：在因为调用abort()方法而终止时触发。</li><li>load：在接收到完整的响应数据时触发。</li><li>loadend：在通信完成或者触发error、abort或load事件后触发。<br><img src="/2015/04/26/Ajax与Comet/20160419113844270.png" alt="图 进度事件"></li></ul><h4 id="1-load事件"><a href="#1-load事件" class="headerlink" title="1. load事件"></a>1. load事件</h4><p>可以代替readystatechagne事件。其处理程序会接收到一个event对象，其target属性指向XHR对象实例，因而可以访问到XHR对象的所有方法和属性。然而，并非所有浏览器都实现了事件对象。</p><h4 id="2-progress事件"><a href="#2-progress事件" class="headerlink" title="2. progress事件"></a>2. progress事件</h4><p>其处理程序会接收一个event对象，其target属性指向XHR对象实例，但包含着三个额外的属性</p><ul><li>lengthComputable：是一个表示进度信息是否可用的布尔值</li><li>position：表示已经接收的字节数</li><li>totalSize：根据content-length响应头确定的预期字节数<br><strong>注意</strong>：<em>其必须在调用open()方法之前添加</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var xhr = createXHR();        </span><br><span class="line">xhr.onload = function(event)&#123;</span><br><span class="line">    // event.target存在兼容性问题，所以只能使用xhr</span><br><span class="line">    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) ||  xhr.status == 304)&#123;</span><br><span class="line">        console.log(xhr.responseText);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.onprogress = function(event)&#123;</span><br><span class="line">    var divStatus = document.getElementById(&quot;status&quot;);</span><br><span class="line">    if (event.lengthComputable)&#123;</span><br><span class="line">        divStatus.innerHTML = &quot;Received &quot; + event.position + &quot; of &quot; + event.totalSize + &quot; bytes&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.open(&quot;get&quot;, &quot;altevents.php&quot;, true);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure></li></ul><h3 id="四、跨源资源共享"><a href="#四、跨源资源共享" class="headerlink" title="四、跨源资源共享"></a>四、跨源资源共享</h3><p><strong>CORS（Cross-Origin Resource Sharing）</strong>背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。</p><p>在发送请求时，给其附加一个额外的Origin头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。</p><pre><code>Origin: http://www.test.com</code></pre><p>如果服务认为这个请求可以接受，在Access-Control-Allow-Origin头部中回发相同的源信息（如果是公共资源，可以回发”*”）。</p><pre><code>Access-Control-Allow-Origin: http://www.test.com</code></pre><p><strong>注意</strong>：请求和响应都不包含cookie信息。</p><h4 id="1-IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。"><a href="#1-IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。" class="headerlink" title="1. IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。"></a>1. IE中实现CORS：XDR（XDomainRequest），所有的XDR请求都是异步的，不能创建同步请求。其使用方法类似于XHR。</h4><h4 id="2-其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open-方法传入绝对地址。支持同步请求。"><a href="#2-其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open-方法传入绝对地址。支持同步请求。" class="headerlink" title="2. 其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open()方法传入绝对地址。支持同步请求。"></a>2. 其他浏览器对CORS的实现：通过XMLHttpRequest对象实现对CORS的原生支持。只需给open()方法传入绝对地址。支持同步请求。</h4><p>跨域XHR对象的安全限制： </p><p>（1）不能使用setRequestHeader()设置自定义头部。 </p><p>（2）不能发送和接收cookie。 </p><p>（3）调用getAllResponseHeaders()方法总会返回空字符串。</p><p><strong>建议</strong>：访问本地资源，最好使用相对URL；访问远程资源，使用绝对URL。</p><h4 id="3-跨浏览器的CORS"><a href="#3-跨浏览器的CORS" class="headerlink" title="3. 跨浏览器的CORS"></a>3. 跨浏览器的CORS</h4><pre><code>functioncreateCORSRequest(method, url){var xhr = new XMLHttpRequest();    if (&quot;withCredentials&quot;in xhr){    // 检测XHR是否支持CORS的简单方式，就是检测是否存在withCredentials属性        xhr.open(method, url, true);    } elseif (typeof XDomainRequest != &quot;undefined&quot;){    // IE XDR        xhr = new XDomainRequest();        xhr.open(method, url);    } else {        xhr = null;    }    return xhr;}var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/xdr.php&quot;);if (request){    request.onload = function(){//do something with request.responseText    };    request.send();}</code></pre><h3 id="五、其他跨域技术"><a href="#五、其他跨域技术" class="headerlink" title="五、其他跨域技术"></a>五、其他跨域技术</h3><p>利用DOM中能够执行跨域请求的功能，在不依赖XHR对象的情况下也能发送某种请求，其不需要修改服务器端代码。</p><h4 id="1-图像Ping"><a href="#1-图像Ping" class="headerlink" title="1. 图像Ping"></a>1. 图像Ping</h4><p><code>&lt;img&gt;</code>标签，可以从任何网页中加载图像，无需关注是否跨域。这也是广告跟踪浏览量的主要方式。 </p><p>图像Ping是与服务器进行简单、单向的跨域通信的一种方式。浏览器得不到任何具体的数据。但通过监听load和error事件，可以知道响应是什么时间接收到的。</p><pre><code>var img = new Image();img.onload = img.error = function() {    console.log(&quot;Done!&quot;);};img.src = &quot;http://www.test.com/getImage?id=1&quot;;</code></pre><p><strong>缺点</strong>: </p><p>（1）只能发送Get请求 </p><p>（2）无法访问服务器的响应文本</p><h4 id="2-JSONP（JSON-with-padding）"><a href="#2-JSONP（JSON-with-padding）" class="headerlink" title="2. JSONP（JSON with padding）"></a>2. JSONP（JSON with padding）</h4><p>两部分组成：回调函数和数据。 </p><p>回调函数是当响应到来时应该在页面调用的函数。回到函数的名字一般是在请求中指定的。而数据是传入回调函数中的JSON数据。 </p><p>JSONP是通过动态<code>&lt;script&gt;</code>元素来使用的</p><pre><code>function handleResponse(response){    alert(&quot;You&apos;re at IP address &quot; + response.ip + &quot;, which is in &quot; + response.city + &quot;, &quot; + response.region_name);}var script = document.createElement(&quot;script&quot;);script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;document.body.insertBefore(script, document.body.firstChild);</code></pre><p><strong>优点</strong>：能够直接访问响应文本，支持在浏览器与服务器之间双向通信。<br><strong>缺点</strong>： </p><p>（1）JSONP是从其他域中加载代码执行，其安全性无法确保。 </p><p>（2）不能很容易的确定JSONP请求是否失败。</p><h4 id="3-Comet"><a href="#3-Comet" class="headerlink" title="3. Comet"></a>3. Comet</h4><p>更高级的Ajax技术，服务器向页面推送数据。 </p><p>Comet 本质上和 C/S 中的通信并不一样，它是通过长连接来模拟推送的。也就是说，在没有数据的时候，这个连接挂起，直到有数据来了（推送），服务器端返回响应，该连接结束，客户端的 JS 重新建立下一个等待连接。</p><p>这种方式并不像 C/S 通信建立长期使用的通道，只是长期“等待”而已，避免了在数据更新频率不大的情况下轮询的开销：试想如果五分钟才一次更新，那么轮询方式在此期间几秒钟就要发生一次请求&amp;响应，而这些请求响应都是没有价值的，因为它们并没有传输有用数据。Comet 避免的是这方面的浪费，不再有空请求，因为挂起的连接直到数据更新了才结束。</p><p>性能方面，对于数据量不大但需要实时更新的应用来说，Comet 能更有效利用连接，同时因为没有轮询的心跳频率，Comet 会比轮询更加实时——因为只消耗响应的网络传输时间。</p><p>但是 Comet 本身并不能在数据传输方面提供比轮询更高的效率，仅仅避免了轮询的空请求浪费。所以 Comet 和 web socket 之类的通讯方式差距还是有的。</p><p>大型网站的应用方面，知乎、QQ 邮箱都有用到 Comet，还有新浪微博的私信（聊天）。使用 Comet 主要需要是服务器端的支持，因为使用长连接，所以要有一定负载量一般得使用异步的网络框架，Python 的 tornado、gevent 和 JavaScript 的 node.js 都是此列。</p><p>两种实现Comet的方式：长轮询和流。<br><img src="/2015/04/26/Ajax与Comet/20160419114753780.png" alt="Ajax与Comet-Comet长轮询"></p><p>（1）长轮询：页面发起一个到服务器的请求，然后服务器一直保持连接打开，直到有数据可发送。发送完数据之后，浏览器关闭连接，随即又发起一个到服务器的新请求。【区别：短轮询，服务器立即发送响应，无论是否有效，而长轮询是等待发送响应。】</p><p>（2）HTTP流：生命周期内只使用一个HTTP连接。浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。</p><pre><code>/** * progress：接收数据时调用的函数 * finished：关闭连接时调用的函数 */function createStreamingClient(url, progress, finished){ var xhr = new XMLHttpRequest(),        received = 0;    xhr.open(&quot;get&quot;, url, true);    xhr.onreadystatechange = function(){var result;        if (xhr.readyState == 3){            //get only the new data and adjust counter            result = xhr.responseText.substring(received);            received += result.length;            //call the progress callback            progress(result);        } elseif (xhr.readyState == 4){            finished(xhr.responseText);        }    };    xhr.send(null);    return xhr;}var client = createStreamingClient(&quot;streaming.php&quot;,function(data){alert(&quot;Received: &quot; + data);}, function(data){alert(&quot;Done!&quot;);});</code></pre><p>服务器发送事件：SSE和事件流</p><h4 id="4-Web-Sockets"><a href="#4-Web-Sockets" class="headerlink" title="4. Web Sockets"></a>4. Web Sockets</h4><p>目标是在一个单独的持久连接上提供全双工、双向通信。 </p><p>优点：能够在客户端和服务器之间发送非常少量的数据，而不必担心HTTP那样字节级的开销。 </p><p>缺点：制定协议的时间比制定JavaScript API的时间还要长。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 必须给WebSocket构造函数传入绝对URL</span><br><span class="line">var socket = new WebSocket(&quot;ws://www.example.com/server.php&quot;);</span><br><span class="line">// 向服务器发送数据（只能发送纯文本，其他数据需要序列化）</span><br><span class="line">socket.send(&quot;Hello&quot;);</span><br><span class="line">// 接收服务器的响应数据</span><br><span class="line">socket.onmessage = function(event) &#123;</span><br><span class="line">    var data = event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>其他事件：</p><ul><li>open：在成功建立连接时触发。</li><li>error：在发生错误时触发，连接不能持续。</li><li>close：在连接关闭时触发。</li></ul><p><strong>注意</strong>：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p><h3 id="jQuery-comet-js"><a href="#jQuery-comet-js" class="headerlink" title="jQuery.comet.js"></a>jQuery.comet.js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">jQuery.comet = &#123;</span><br><span class="line"></span><br><span class="line">    fetching: false,</span><br><span class="line">    settings: &#123;&#125;,</span><br><span class="line">    url: &apos;&apos;,</span><br><span class="line">    bound: &#123;&#125;,</span><br><span class="line">    connect: function(url, options) &#123;</span><br><span class="line">        jQuery.comet.settings = jQuery.extend(&#123;</span><br><span class="line">            timeout: 60000,</span><br><span class="line">            onError: null,</span><br><span class="line">            requestMethod: &apos;GET&apos;,</span><br><span class="line">            typeAttr: &apos;type&apos;,</span><br><span class="line">            dataAttr: &apos;data&apos;</span><br><span class="line">        &#125;, options);</span><br><span class="line">        jQuery.comet.url = url;</span><br><span class="line">        jQuery.comet.fetch();</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    fetch: function() &#123;</span><br><span class="line">        if (jQuery.comet.fetching)</span><br><span class="line">            return;</span><br><span class="line"></span><br><span class="line">        jQuery.comet.fetching = true;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type: jQuery.comet.settings.requestMethod,</span><br><span class="line">            url: jQuery.comet.url,</span><br><span class="line">        </span><br><span class="line">            async: true,</span><br><span class="line">            cache: true,</span><br><span class="line">            timeout: jQuery.comet.settings.timeout,</span><br><span class="line">            ifModified: true,</span><br><span class="line">        </span><br><span class="line">            success: function(data) &#123;</span><br><span class="line">                jQuery.comet.fetching = false;</span><br><span class="line">                jQuery.comet.handle_update(data);</span><br><span class="line">                setTimeout(jQuery.comet.fetch, 1);</span><br><span class="line">            &#125;,</span><br><span class="line">            error: function(XMLHttpRequest, textStatus, errorThrown) &#123;</span><br><span class="line">                jQuery.comet.fetching = false;</span><br><span class="line">                if (textStatus == &apos;timeout&apos;) &#123;</span><br><span class="line">                    jQuery.comet.fetch()</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (jQuery.comet.settings.onError != null) &#123;</span><br><span class="line">                        jQuery.comet.settings.onError(XMLHttpRequest, textStatus, errorThrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                    setTimeout(jQuery.comet.fetch, 10000);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    handle_update: function(update) &#123;</span><br><span class="line">        type = null;</span><br><span class="line">        data = update;</span><br><span class="line">        </span><br><span class="line">        if (update[jQuery.comet.settings.typeAttr]) &#123;</span><br><span class="line">            type = update[jQuery.comet.settings.typeAttr];</span><br><span class="line">        &#125;</span><br><span class="line">        if (update[jQuery.comet.settings.dataAttr]) &#123;</span><br><span class="line">            data = update[jQuery.comet.settings.dataAttr];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        jQuery(document).trigger(type + &quot;.comet&quot;, [data, type]);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> Comet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS content属性</title>
      <link href="/2015/04/17/CSS-content%E5%B1%9E%E6%80%A7/"/>
      <url>/2015/04/17/CSS-content%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>css博大精深，很多属性，往往都是看似熟悉，但是似乎又不能将其特性和用法完整地说出来。</p><p>content属性，的确是很眼熟，也许很多童鞋和我一样，和它初次见面，是在清除浮动的时候：</p><pre><code>.clearfix:after{    content: &quot;.&quot;;    display: block;    height: 0;    clear: both;    visibility: hidden}</code></pre><p>如上所示，content 属性与 :before 及 :after 伪元素配合使用，并可以接受一个字符串作为值。</p><p>然而，除了字符串之外，还能接受什么样的值呢？</p><h2 id="定义和用法"><a href="#定义和用法" class="headerlink" title="定义和用法"></a>定义和用法</h2><blockquote><p>content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容。</p><p>该属性用于定义元素之前或之后放置的生成内容。默认是行内内容，不过可以用属性 display 控制。</p></blockquote><h2 id="可能的值"><a href="#可能的值" class="headerlink" title="可能的值"></a>可能的值</h2><p>none、normal、inherit、string、url()、attr()、[no-]open-quote、[no-]close-quote、counter[s]</p><p>其中none、normal、inherit这三个和大多数属性类似，故不做介绍。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>string是常见的，上面清除浮动的例子，就是其中之一。</p><h3 id="url"><a href="#url" class="headerlink" title="url()"></a>url()</h3><p>url的用法，和background属性有点类似，可以接受一个图片url。不一样的是，content属性无法控制图片的大小。</p><pre><code>&lt;div class=&quot;logo&quot;&gt;Google&lt;/div&gt;.logo:before{    content: url(https://www.google.com/images/branding/googlelogo/1x/googlelogo_color_272x92dp.png);}</code></pre><p><img src="/2015/04/17/CSS-content属性/1.jpg" alt=""></p><h3 id="attr"><a href="#attr" class="headerlink" title="attr"></a>attr</h3><p>attr，顾名思义，就是将content内容设置为对应元素的某一属性。</p><pre><code>&lt;p&gt;    &lt;span data-text=&apos;半&apos;&gt;半&lt;/span&gt;    &lt;span data-text=&apos;边&apos;&gt;边&lt;/span&gt;    &lt;span data-text=&apos;效&apos;&gt;效&lt;/span&gt;    &lt;span data-text=&apos;果&apos;&gt;果&lt;/span&gt;&lt;/p&gt;span{    font-size: 100px;    font-weight: bold;    position: relative;    color: #000;}span:before{    content: attr(data-text);    color: #F00;    position: absolute;    left: 0;    top: 0;    width: 50%;    overflow: hidden;}</code></pre><p><img src="/2015/04/17/CSS-content属性/2.png" alt=""></p><h3 id="quote-·-引号"><a href="#quote-·-引号" class="headerlink" title="quote · 引号"></a>quote · 引号</h3><p>[no-]open-quote、[no-]close-quote，这四个值，常用于给元素前后加上引号，配合quotes 属性一起使用。</p><pre><code>&lt;p&gt;鲁迅曾经说过: &lt;span&gt;能用CSS解决的问题就不要使用JS。&lt;span&gt;呵呵，谁说的？&lt;span class=&quot;no-quote&quot;&gt;呵呵，谁说的？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;span {    quotes: &apos;“&apos;&apos;”&apos;&apos;‘&apos;&apos;’&apos;&apos;&quot;&apos;&apos;&quot;&apos;;}span:before {     content: open-quote;}span:after {    content: close-quote;}.no-quote:after{    content: no-close-quote;}</code></pre><p>其中，quotes属性定义要使用的引号。两两一组，前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。如此类推。</p><p>需要注意的是，只有当伪元素:before设置content的值为open-quote才会有效果。</p><p><img src="/2015/04/17/CSS-content属性/3.png" alt=""></p><h3 id="counter-s-·-计数器"><a href="#counter-s-·-计数器" class="headerlink" title="counter[s] · 计数器"></a>counter[s] · 计数器</h3><p>这是一个很强大的东西，不妨先来体验一下其强大的力量，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;strong&gt;请选择你所使用的技术：&lt;/strong&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item1&quot;&gt;&lt;label for=&quot;item1&quot;&gt;PHP&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item2&quot;&gt;&lt;label for=&quot;item2&quot;&gt;Javascript&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item3&quot;&gt;&lt;label for=&quot;item3&quot;&gt;Java&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item4&quot;&gt;&lt;label for=&quot;item4&quot;&gt;HTML&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item5&quot;&gt;&lt;label for=&quot;item5&quot;&gt;CSS&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item6&quot;&gt;&lt;label for=&quot;item6&quot;&gt;nodejs&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;input type=&quot;checkbox&quot; id=&quot;item7&quot;&gt;&lt;label for=&quot;item7&quot;&gt;go&lt;/label&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">总共选择了 &lt;strong class=&quot;total&quot;&gt;&lt;/strong&gt; 项！</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ol&#123;</span><br><span class="line">counter-reset: n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input:checked &#123;</span><br><span class="line">counter-increment: n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.total:after &#123;</span><br><span class="line">content: counter(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2015/04/17/CSS-content属性/4.png" alt=""><br>与其搭配使用的，还有counter-reset、counter-increment两个属性。</p><h4 id="counter-reset"><a href="#counter-reset" class="headerlink" title="counter-reset"></a>counter-reset</h4><p>用来标识计数器的作用域，值包括两部分：第一部分为计数器的名字；第二部分为计数器的起始值，默认为0。此外，counter-reset还可以同时声明多个计数器</p><pre><code>counter-reset: n 0counter-reset: n 2 counter-reset: n 0 m 0 p 0</code></pre><h4 id="counter-increment"><a href="#counter-increment" class="headerlink" title="counter-increment"></a>counter-increment</h4><p>用来表明计数器实际用到的范围，值包括两部分：第一部分为计数器的名字；第二部分为计数器的递增的值，默认为1。如：</p><pre><code>counter-increment: n 2counter-increment: n -1 /*递减*/</code></pre><p>那counter和counters有什么不一样呢？</p><h4 id="counter"><a href="#counter" class="headerlink" title="counter()"></a>counter()</h4><p>counter方法可以接收两个参数。第一个是计数器的名字，必填；第二个是计数器的样式，也就是list-style-type，其支持的关键字值，就是list-style-type支持的那些值，比如disc | circle | square之类等等。</p><pre><code>content: counter(n)content: counter(m, circle)</code></pre><h4 id="counters"><a href="#counters" class="headerlink" title="counters()"></a>counters()</h4><p>counters方法主要用于嵌套计数，可以接收三个参数。第一个是计数器的名字，必填；第二个是字符串，用于嵌套计数的分隔符，如1.1中的“.”；第三个参数是计数器的样式，与counter一样。其中，前两个参数为必填</p><pre><code>content: counters(n, &apos;-&apos;);</code></pre><p>说了这么多，还是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;none&lt;/li&gt;</span><br><span class="line">&lt;li&gt;normal&lt;/li&gt;</span><br><span class="line">&lt;li&gt;inherit&lt;/li&gt;</span><br><span class="line">&lt;li&gt;string&lt;/li&gt;</span><br><span class="line">&lt;li&gt;url&lt;/li&gt;</span><br><span class="line">&lt;li&gt;attr&lt;/li&gt;</span><br><span class="line">&lt;li&gt;quote</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;open-quote&lt;/li&gt;</span><br><span class="line">&lt;li&gt;close-quote&lt;/li&gt;</span><br><span class="line">&lt;li&gt;no-open-quote&lt;/li&gt;</span><br><span class="line">&lt;li&gt;no-close-quote&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;counter[s]</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;counter&lt;/li&gt;</span><br><span class="line">&lt;li&gt;counters&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ul&#123;</span><br><span class="line">   counter-reset: n;</span><br><span class="line">&#125;</span><br><span class="line">li&#123;</span><br><span class="line">   list-style-type: none;</span><br><span class="line">counter-increment: n;</span><br><span class="line">&#125;</span><br><span class="line">li:before&#123;</span><br><span class="line">content: counters(n, &apos;-&apos;) &apos;.&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2015/04/17/CSS-content属性/5.jpg" alt=""></p><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><p>那具体怎么用呢，给大家举个栗子，前段时间刚好用到的，给按钮实现提示功能，就是鼠标放上去后，出来个小提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">  &lt;a href=&quot;#&quot; class=&quot;btn&quot; data-tip=&quot;点击作答&quot;&gt;一个按钮&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.btn &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  padding: 5px 20px;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  background-color: #6495ed;</span><br><span class="line">  color: #fff;</span><br><span class="line">  font-size: 14px;</span><br><span class="line">  text-decoration: none;</span><br><span class="line">  text-align: center;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.btn::before &#123;</span><br><span class="line">  content: attr(data-tip);</span><br><span class="line">  width: 80px;</span><br><span class="line">  padding: 5px 10px;</span><br><span class="line">  border-radius: 4px;</span><br><span class="line">  background-color: #000;</span><br><span class="line">  color: #ccc;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: -30px;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%);</span><br><span class="line">  text-align: center;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  transition: all .3s;</span><br><span class="line">&#125;</span><br><span class="line">.btn::after &#123;</span><br><span class="line">  content: &apos;&apos;;</span><br><span class="line">  border: 8px solid transparent;</span><br><span class="line">  border-top: 8px solid #000;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: -3px;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%); </span><br><span class="line">  opacity: 0;</span><br><span class="line">  transition: all .3s;</span><br><span class="line">&#125;</span><br><span class="line">.btn:hover::before &#123;</span><br><span class="line">  top: -40px;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br><span class="line">.btn:hover::after &#123;</span><br><span class="line">  top: -13px;</span><br><span class="line">  opacity: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2015/04/17/CSS-content属性/1.png" alt=""></p><p> 当然attr()还可以获取更多的其他属性，比如a标签里的href属性等，更多的用法大家自行尝试吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>十大经典排序算法</title>
      <link href="/2015/01/02/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2015/01/02/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><p>十种常见排序算法可以分为两大类：</p><blockquote><p><strong>非线性时间比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。<br><strong>线性时间非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 </p></blockquote><p><img src="/2015/01/02/十大经典排序算法/849589-20180402132530342-980121409.png" alt=""></p><h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20180402133438219-1946132192.png" alt=""></p><p><strong>相关概念</strong></p><blockquote><p><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。<br><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。<br><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。<br><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 </p></blockquote><h3 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h4 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h4><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><strong>1.2 动图演示</strong></p><p><img src="/2015/01/02/十大经典排序算法/849589-20171015223238449-2146169197.gif" alt=""></p><h4 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">            if (arr[j] &gt; arr[j+1]) &#123;        // 相邻元素两两对比</span><br><span class="line">                var temp = arr[j+1];        // 元素交换</span><br><span class="line">                arr[j+1] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h3><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h4 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a><strong>2.2 动图演示</strong></h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015224719590-1433219824.gif" alt=""></p><h4 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     // 寻找最小的数</span><br><span class="line">                minIndex = j;                 // 将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h4><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h3 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h4 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h4 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015225645277-1151100000.gif" alt=""></p><h4 id="3-2-代码实现"><a href="#3-2-代码实现" class="headerlink" title="3.2 代码实现"></a>3.2 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function insertionSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    var preIndex, current;</span><br><span class="line">    for (var i = 1; i &lt; len; i++) &#123;</span><br><span class="line">        preIndex = i - 1;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + 1] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + 1] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h4><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h3><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><h4 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h4><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20180331170017421-364506073.gif" alt=""></p><h4 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap = 1;</span><br><span class="line">    while (gap &lt; len / 3) &#123;          // 动态定义间隔序列</span><br><span class="line">        gap = gap * 3 + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123;</span><br><span class="line">        for (var i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            for (var j = i-gap; j &gt; 0 &amp;&amp; arr[j]&gt; temp; j-=gap) &#123;</span><br><span class="line">                arr[j + gap] = arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j + gap] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h4><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版）》的合著者Robert Sedgewick提出的。　</p><h3 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h4 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015230557043-37375010.gif" alt=""></p><h4 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(arr) &#123;  // 采用自上而下的递归方法</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    if (len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle = Math.floor(len / 2),</span><br><span class="line">        left = arr.slice(0, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function merge(left, right) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line"> </span><br><span class="line">    while (left.length&gt;0 &amp;&amp; right.length&gt;0) &#123;</span><br><span class="line">        if (left[0] &lt;= right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h4><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><h3 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015230936371-1413523412.gif" alt=""></p><h4 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr, left, right) &#123;</span><br><span class="line">    var len = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left = typeof left != &apos;number&apos; ? 0 : left,</span><br><span class="line">        right = typeof right != &apos;number&apos; ? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex-1);</span><br><span class="line">        quickSort(arr, partitionIndex+1, right);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function partition(arr, left ,right) &#123;     // 分区操作</span><br><span class="line">    var pivot = left,                      // 设定基准值（pivot）</span><br><span class="line">        index = pivot + 1;</span><br><span class="line">    for (var i = index; i &lt;= right; i++) &#123;</span><br><span class="line">        if (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - 1);</span><br><span class="line">    return index-1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015231308699-356134237.gif" alt=""></p><h4 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">var len;    // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"> </span><br><span class="line">function buildMaxHeap(arr) &#123;   // 建立大顶堆</span><br><span class="line">    len = arr.length;</span><br><span class="line">    for (var i = Math.floor(len/2); i &gt;= 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function heapify(arr, i) &#123;     // 堆调整</span><br><span class="line">    var left = 2 * i + 1,</span><br><span class="line">        right = 2 * i + 2,</span><br><span class="line">        largest = i;</span><br><span class="line"> </span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (largest != i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"> </span><br><span class="line">    for (var i = arr.length - 1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h3><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h4 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015231740840-6968181.gif" alt=""></p><h4 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket = new Array(maxValue + 1),</span><br><span class="line">        sortedIndex = 0;</span><br><span class="line">        arrLen = arr.length,</span><br><span class="line">        bucketLen = maxValue + 1;</span><br><span class="line"> </span><br><span class="line">    for (var i = 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    for (var j = 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] = j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h4><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h3 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><h4 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h4><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><h4 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015232107090-1920702011.png" alt=""></p><h4 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length === 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    var i;</span><br><span class="line">    var minValue = arr[0];</span><br><span class="line">    var maxValue = arr[0];</span><br><span class="line">    for (i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue = arr[i];                // 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue = arr[i];                // 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5</span><br><span class="line">    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  </span><br><span class="line">    var buckets = new Array(bucketCount);</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] = [];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    arr.length = 0;</span><br><span class="line">    for (i = 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j = 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><h3 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h3><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h4 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h4 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h4><p><img src="/2015/01/02/十大经典排序算法/849589-20171015232453668-1397662527.gif" alt=""> </p><h4 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// LSD Radix Sort</span><br><span class="line">var counter = [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod = 10;</span><br><span class="line">    var dev = 1;</span><br><span class="line">    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123;</span><br><span class="line">        for(var j = 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket = parseInt((arr[j] % mod) / dev);</span><br><span class="line">            if(counter[bucket]==null) &#123;</span><br><span class="line">                counter[bucket] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos = 0;</span><br><span class="line">        for(var j = 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value = null;</span><br><span class="line">            if(counter[j]!=null) &#123;</span><br><span class="line">                while ((value = counter[j].shift()) != null) &#123;</span><br><span class="line">                      arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h4><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript核武库</title>
      <link href="/2015/01/01/JavaScript%E6%A0%B8%E6%AD%A6%E5%BA%93/"/>
      <url>/2015/01/01/JavaScript%E6%A0%B8%E6%AD%A6%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>以下是个人总结，也有一些是copy大神的，现在放到一起，方便以后查阅（有不对的地方，还望大家能够提出，我会尽快加以改正）。</p><h2 id="强制转boolean"><a href="#强制转boolean" class="headerlink" title="!!强制转boolean"></a>!!强制转<code>boolean</code></h2><p>根据真值，假值 判断，返回<code>true</code>，<code>false</code>假值：  0     “”  null   undefined  false NaN</p><pre><code>例如：var nu=null;var nul=&quot;&quot;;var str=&quot;abcd&quot;;console.log(!!nu)     // false;console.log(!!nul)    // false;console.log(!!str)    // true;</code></pre><h2 id="obj-强制转Number"><a href="#obj-强制转Number" class="headerlink" title="+obj 强制转Number"></a>+obj 强制转<code>Number</code></h2><p> 将对象强制转<code>number</code>,如果是纯数字的“88”字符串，可转为<code>number</code></p><pre><code>var a=&quot;88&quot;;console.log(+a)   =&gt;88//但是如果是混合类型的字符串，则会转为NaNvar b=&quot;1606e&quot;;console.log(+b)  =&gt; NaN</code></pre><h2 id="强制取整"><a href="#强制取整" class="headerlink" title="~~ 强制取整"></a>~~ 强制取整</h2><pre><code>~~ 12.34 12~~ 12.88 12</code></pre><h2 id="不可靠的undefined-可靠的void-0"><a href="#不可靠的undefined-可靠的void-0" class="headerlink" title="不可靠的undefined 可靠的void 0"></a>不可靠的<code>undefined</code> 可靠的<code>void 0</code></h2><p>在<code>JavaScript</code>中，假设我们想判断一个是否是 <code>undefined</code>，那么我们通常会这样写：</p><pre><code>if(a === undefined){  dosomething}</code></pre><p>//但是在<code>javascript</code>中，<code>undefined</code>是不可靠的</p><p>例如：<br>当undefined在函数内，并且是在局部变量是可以赋上值</p><pre><code>function foo2(){ var undefined=1; console.log(undefined)}foo2();  =&gt;1;</code></pre><p>但是当在函数内定义一个全局变量，并不能给赋上值</p><pre><code>var undefined;function foo2(){undefined=1; console.log(undefined)}foo2()  // undefinedvoid 0或者 void (0)：</code></pre><p>最常见的用法是通过<code>void 0</code> 运算来获得 <code>undefined</code>，表达式为 0 时的运算开销最小：<br>那在以后需要判断值为<code>undefined</code>的时候，可以直接用<code>void 0</code>或者<code>void (0)</code></p><h2 id="字符串也是有length属性的！"><a href="#字符串也是有length属性的！" class="headerlink" title="字符串也是有length属性的！"></a>字符串也是有<code>length</code>属性的！</h2><p>我们知道所有的<code>array</code>都是有<code>length</code>,属性，就算事空数组，<code>length</code> 是0，那么字符串有没有呢？接下来我们来验证一下：</p><pre><code>var str=&quot;sdfsd5565s6dfsd65sd6+d5fd5&quot;;console.log(str.length)      // 26</code></pre><p>结果是有的，所以我们在判断类型时，不能单纯拿有没有<code>length</code>属性来判断是不是数组了，我们可以用下面的方法：</p><pre><code>var obj=[1,2] ;console.log(toString.call(obj) === &apos;[object Array]&apos;);</code></pre><h2 id="生成一个随机数组-创建数组，sort排序"><a href="#生成一个随机数组-创建数组，sort排序" class="headerlink" title="生成一个随机数组(创建数组，sort排序)"></a>生成一个随机数组(创建数组，<code>sort</code>排序)</h2><p>在项目中有时候我们需要一个随机打乱的数组，那么下面我们来实现以下：<br>先来创建一个数组：</p><pre><code>var arr=[];for(var i=0;i&lt;10;i++){   arr.push(i)}console.log(arr)    //  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>接下来我们来打乱它：</p><pre><code>arr.sort(()=&gt;{ return Math.random() - 0.5})                 // [1, 0, 2, 3, 4, 6, 8, 5, 7, 9] </code></pre><p>第二种打乱方法：</p><pre><code>arr.sort((a,b)=&gt;{　　　return a&gt;Math.random()*10;})               //  [1, 2, 0, 6, 4, 3, 8, 9, 7, 5]</code></pre><p>我们以前的正常排序是这样的：</p><pre><code>arr.sort(function(a,b){   return b-a});</code></pre><p>解析：<br>先说正常的排序：<br>a,b表示数组中的任意两个元素，若<code>return &gt; 0</code> b前a后；<code>reutrn &lt; 0</code> a前b后；<code>a=b</code>时存在浏览器兼容 ，<br><code>a-b</code>输出从小到大排序，<code>b-a</code>输出从大到小排序。<br>然后再说我们打乱的方法：<br>创建数组不用说，接下来就是用js的sort方法 来实现，<code>Math.random()</code>实现一个随机<code>0-1</code>之间的小数 然后再减去<code>0.5</code>，这时就会根据return比较后得到的值排，所以说就会生成不是正常从大到小或者从小到大的排序。</p><p>第二个打乱的方法同样是遵循<code>sort</code>的方法，将<code>a,b</code>传进去 然后和随机数做比较，关于比较的方法不太清楚。</p><h2 id="去除前后、前、后-所有空格"><a href="#去除前后、前、后-所有空格" class="headerlink" title="去除前后、前、后 所有空格"></a>去除前后、前、后 所有空格</h2><p> 这是专门为去除空格写的一套方法，适用于各种情况，所有空格,前后空格，前空格，后空格。</p><p>var strr=”    1 ad dertasdf sdfASDFDF DFG SDFG    “<br>//  type 1-所有空格  2-前后空格  3-前空格 4-后空格</p><pre><code>function trim(str,type){    switch (type){        case 1:return str.replace(/\s+/g,&quot;&quot;);        case 2:return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);        case 3:return str.replace(/(^\s*)/g, &quot;&quot;);        case 4:return str.replace(/(\s*$)/g, &quot;&quot;);        default:return str;    }}console.log( trim(strr,1))      //  &quot;1addertasdfsdfASDFDFDFGSDFG&quot;</code></pre><p>解析：<br>  这个方法用的是正则的匹配格式,后面我会把正则单独拿出来总结一个系列，敬请期待！！！</p><pre><code>\s ： 空格符，Tab,换页符，换行符  \S ： 非\s的所有内容  /g :  全局匹配  ^  :  匹配在行首  $  :  匹配在行尾  +  ： 重复次数&gt;0  *  ： 重复次数&gt;=0  |  :  或者</code></pre><p><code>replace(a,b)</code>： 方法用于在字符创中用一些字符替换另一些字符, 会传入两个值，将逗号前面的值<code>a</code>替换成逗号后面的值<code>b</code></p><h2 id="字母大小写切换（正则匹配，replace）"><a href="#字母大小写切换（正则匹配，replace）" class="headerlink" title="字母大小写切换（正则匹配，replace）"></a>字母大小写切换（正则匹配，<code>replace</code>）</h2><p>这个方法主要是给一些需要大小写转换提供的方法，主要有首字母大写，首字母小写，大小写转换，全部转大写和全部转小写。</p><pre><code>type：　　1:首字母大写　　2：首页母小写　　3：大小写转换　　4：全部大写　　5：全部小写</code></pre><p>原始字符串：</p><pre><code>var str=&quot;sdfwwerasfddffddeerAasdgFegqer&quot;;function changeCase(str,type) {   //这个函数是第三个大小写转换的方法    function ToggleCase(str) {        var itemText = &quot;&quot;        str.split(&quot;&quot;).forEach(                function (item) {                 // 判断循环字符串中每个字符是否以a-z之间开头的并且重复大于0次                    if (/^([a-z]+)/.test(item)) {                    //  如果是小写，转换成大写                        itemText += item.toUpperCase();                    }                //  判断循环字符串中每个字符是否以A-Z之间开头的并且重复大于0次                    else if (/^([A-Z]+)/.test(item)) {                   //   如果是大写，转换成小写                        itemText += item.toLowerCase();                    }                    else{                  //  如果都不符合，返回其本身                        itemText += item;                    }                });        return itemText;    }  //下面主要根据传入的type值来匹配各个场景    switch (type) {         //当匹配        case 1:            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {                 //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer                return v1.toUpperCase() + v2.toLowerCase();            });        case 2:            return str.replace(/^(\w)(\w+)/, function (v, v1, v2) {                //v=验证本身  v1=s ; v2=dfwwerasfddffddeerAasdgFegqer                return v1.toLowerCase() + v2.toUpperCase();            });        case 3:            return ToggleCase(str);        case 4:            return str.toUpperCase();        case 5:            return str.toLowerCase();        default:            return str;    }} console.log(changeCase(str,1)) =&gt;SdfwwerasfddffddeerAasdgFegqer</code></pre><p>解析：</p><pre><code>split：用于把一个字符串分割成字符串数组\w: 数字0-9或字母a-z及A-Z,或下划线\W: 非\w，除以上的特殊符号等   toUpperCase：转大写toLowerCase：转小写replace第二个参数可以是函数，函数的参数中，第一个是本身，第二个是正则匹配内容，第三个匹配剩下的内容</code></pre><p>下面我们就通过小实验来验证一下：<br>网上有说replace是可以有4个参数的，但是我并没有验证到第四个代表的意义，前三个已经验证，第一个参数为验证本身，第二个正则匹配结果，第三为第二个匹配完剩下的值。</p><h2 id="循环n次传入的字符串str为传入随意字符串，count为循环的次数"><a href="#循环n次传入的字符串str为传入随意字符串，count为循环的次数" class="headerlink" title="循环n次传入的字符串str为传入随意字符串，count为循环的次数"></a>循环n次传入的字符串<code>str</code>为传入随意字符串，<code>count</code>为循环的次数</h2><pre><code>var str=&quot;abc&quot;; var number=555;function repeatStr(str, count) {    //声明一个空字符串，用来保存生成后的新字符串    var text = &apos;&apos;;    //循环传入的count值，即循环的次数    for (var i = 0; i &lt; count; i++) {       //循环一次就把字符串+到我们事先准备好的空字符串上        text += str;    }    return text;}  console.log(repeatStr(str, 3))         // &quot;abcabcabc&quot;  console.log(repeatStr(number, 3))      // &quot;555555555&quot;</code></pre><p>解析：根据count循环的次数，在循环体内复制，return 返回+=后的值</p><h2 id="查找字符串的A内容替换成B内容"><a href="#查找字符串的A内容替换成B内容" class="headerlink" title="查找字符串的A内容替换成B内容"></a>查找字符串的A内容替换成B内容</h2><pre><code>let str=&quot;abacdasdfsd&quot; function replaceAll(str,AFindText,ARepText){   raRegExp = new RegExp(AFindText,&quot;g&quot;);   return str.replace(raRegExp,ARepText);}console.log(replaceAll(str,&quot;a&quot;,&quot;x&quot;))  // xbxcdxsdfsdstr：需要编辑的字符串本身AFindText:需要替换的内容ARepText:被替换成的内容</code></pre><p>解析：创建正则，匹配内容，替换</p><h2 id="检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"><a href="#检测常用格式，邮箱，手机号，名字，大写，小写-在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证" class="headerlink" title="检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证"></a>检测常用格式，邮箱，手机号，名字，大写，小写,在表单验证时，我们经常会需要去验证一些内容，举例几个常用的验证</h2><pre><code>function checkType (str, type) {    switch (type) {        case &apos;email&apos;:            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);        case &apos;phone&apos;:            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);        case &apos;tel&apos;:            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);        case &apos;number&apos;:            return /^[0-9]$/.test(str);        case &apos;english&apos;:            return /^[a-zA-Z]+$/.test(str);        case &apos;chinese&apos;:            return /^[\u4E00-\u9FA5]+$/.test(str);        case &apos;lower&apos;:            return /^[a-z]+$/.test(str);        case &apos;upper&apos;:            return /^[A-Z]+$/.test(str);        default :            return true;    }}console.log(checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;))   //false</code></pre><p>解析：</p><pre><code>checkType (&apos;hjkhjhT&apos;,&apos;lower&apos;)&apos;需要验证的字符串&apos;，&apos;匹配的格式&apos;email：验证邮箱phone：验证手机号tel：验证座机号number：验证数字english：验证英文字母chinese：验证中文字lower：验证小写upper：验证大写</code></pre><p>JS返回浏览器历史第一页：</p><p><a href="https://link.zhihu.com/?target=https%3A//www.xiejiahe.com/detail/5a18f8f5c7431c02ef43bca9" target="_blank" rel="noopener">JS返回浏览器历史第一页</a></p><p>我在浏览器控制台敲了 window.history 其实我想看看还有哪些API，他输出了以下信息，我看到length 这个属性让我眼前一亮，其他2个我不关心。</p><pre><code>{    length: 2,    scrollRestoration: &quot;auto&quot;,    state: null}</code></pre><p>我尝试用length 去回退， 不成功！</p><pre><code>window.history.go(-2);</code></pre><p>我再尝试用length去减1, 成功了， 我猜应该是跟新标签页有关吧。 那我不管了，我已经有答案了</p><pre><code>window.history.go(-1);</code></pre><p>最后代码</p><pre><code>var historyLen = window.history;window.history.go(-(historyLen - 1));</code></pre><p>测试了3个浏览器， 都是第一次打开浏览器测试</p><pre><code>Chrome 会直接返回到新标签页Safari 我这里测试是返回到百度，可能是我的设置问题Firefox 直接关闭浏览器 </code></pre><p>作为战斗在业务一线的前端，要想少加班，就要想办法提高工作效率。这里提一个小点，我们在业务开发过程中，经常会重复用到<code>日期格式化</code>、<code>url参数转对象</code>、<code>浏览器类型判断</code>、<code>节流函数</code>等一类函数，这些工具类函数，基本上在每个项目都会用到，为避免不同项目多次复制粘贴的麻烦，我们可以统一封装，发布到<code>npm</code>，以提高开发效率。</p><p>这里，笔者已经封装并发布了自己的武器库 <a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener">outils</a>，如果你对本项目感兴趣，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。当然你也可以在本项目的基础上封装自己的武器库。</p><p>常用函数汇总</p><h2 id="这里先分类整理下，之前项目中多次用到的工具函数。"><a href="#这里先分类整理下，之前项目中多次用到的工具函数。" class="headerlink" title="这里先分类整理下，之前项目中多次用到的工具函数。"></a>这里先分类整理下，之前项目中多次用到的工具函数。</h2><h2 id="1-Array"><a href="#1-Array" class="headerlink" title="1.Array"></a>1.Array</h2><h2 id="1-1-arrayEqual"><a href="#1-1-arrayEqual" class="headerlink" title="1.1 arrayEqual"></a>1.1 arrayEqual</h2><pre><code>/** *  * @desc 判断两个数组是否相等 * @param {Array} arr1  * @param {Array} arr2  * @return {Boolean} */ function arrayEqual(arr1, arr2) {    if (arr1 === arr2) return true;    if (arr1.length != arr2.length) return false;    for (var i = 0; i &lt; arr1.length; ++i) {        if (arr1[i] !== arr2[i]) return false;    }    return true;}</code></pre><h2 id="2-Class"><a href="#2-Class" class="headerlink" title="2.Class"></a>2.Class</h2><h2 id="2-1-addClass"><a href="#2-1-addClass" class="headerlink" title="2.1 addClass"></a>2.1 addClass</h2><pre><code>/** *  * @desc   为元素添加class * @param  {HTMLElement} ele  * @param  {String} cls  */ var hasClass = require(&apos;./hasClass&apos;);function addClass(ele, cls) {    if (!hasClass(ele, cls)) {        ele.className += &apos; &apos; + cls;    }}</code></pre><p>2.2 hasClass</p><pre><code>/** *  * @desc 判断元素是否有某个class * @param {HTMLElement} ele  * @param {String} cls  * @return {Boolean} */ function hasClass(ele, cls) {    return (new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;)).test(ele.className);}</code></pre><p>2.3 removeClass</p><pre><code>/** *  * @desc 为元素移除class * @param {HTMLElement} ele  * @param {String} cls  */ var hasClass = require(&apos;./hasClass&apos;);function removeClass(ele, cls) {    if (hasClass(ele, cls)) {        var reg = new RegExp(&apos;(\\s|^)&apos; + cls + &apos;(\\s|$)&apos;);        ele.className = ele.className.replace(reg, &apos; &apos;);    }}</code></pre><h2 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h2><h2 id="3-1-getCookie"><a href="#3-1-getCookie" class="headerlink" title="3.1 getCookie"></a>3.1 getCookie</h2><pre><code>/** *  * @desc 根据name读取cookie * @param  {String} name  * @return {String} */ function getCookie(name) {    var arr = document.cookie.replace(/\s/g, &quot;&quot;).split(&apos;;&apos;);    for (var i = 0; i &lt; arr.length; i++) {        var tempArr = arr[i].split(&apos;=&apos;);        if (tempArr[0] == name) {            return decodeURIComponent(tempArr[1]);        }    }    return &apos;&apos;;}</code></pre><p>3.2 removeCookie</p><pre><code>var setCookie = require(&apos;./setCookie&apos;);/** *  * @desc 根据name删除cookie * @param  {String} name  */ function removeCookie(name) {    // 设置已过期，系统会立刻删除cookie    setCookie(name, &apos;1&apos;, -1);}</code></pre><p>3.3 setCookie</p><pre><code>/** *  * @desc  设置Cookie * @param {String} name  * @param {String} value  * @param {Number} days  */ function setCookie(name, value, days) {    var date = new Date();    date.setDate(date.getDate() + days);    document.cookie = name + &apos;=&apos; + value + &apos;;expires=&apos; + date;}</code></pre><h2 id="4-Device"><a href="#4-Device" class="headerlink" title="4.Device"></a>4.Device</h2><h2 id="4-1-getExplore"><a href="#4-1-getExplore" class="headerlink" title="4.1 getExplore"></a>4.1 getExplore</h2><pre><code>/** *  * @desc 获取浏览器类型和版本 * @return {String}  */ function getExplore() {    var sys = {},        ua = navigator.userAgent.toLowerCase(),        s;    (s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:        (s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :        (s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :        (s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :        (s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :        (s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :        (s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;    // 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie)    if (sys.edge) return (&apos;EDGE: &apos; + sys.edge)    if (sys.firefox) return (&apos;Firefox: &apos; + sys.firefox)    if (sys.chrome) return (&apos;Chrome: &apos; + sys.chrome)    if (sys.opera) return (&apos;Opera: &apos; + sys.opera)    if (sys.safari) return (&apos;Safari: &apos; + sys.safari)    return &apos;Unkonwn&apos;}</code></pre><p>4.2 getOS</p><pre><code>/** *  * @desc 获取操作系统类型 * @return {String}  */ function getOS() {    var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;;    var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;;    var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;;    if (/mac/i.test(appVersion)) return &apos;MacOSX&apos; if (/win/i.test(appVersion)) return &apos;windows&apos; if (/linux/i.test(appVersion)) return &apos;linux&apos; if (/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos; if (/android/i.test(userAgent)) return &apos;android&apos; if (/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos;}</code></pre><h2 id="5-Dom"><a href="#5-Dom" class="headerlink" title="5.Dom"></a>5.Dom</h2><h2 id="5-1-getScrollTop"><a href="#5-1-getScrollTop" class="headerlink" title="5.1 getScrollTop"></a>5.1 getScrollTop</h2><pre><code>/** *  * @desc 获取滚动条距顶部的距离 */ function getScrollTop() {    return (document.documentElement &amp;&amp; document.documentElement.scrollTop) || document.body.scrollTop;}</code></pre><p>5.2 offset</p><pre><code>/** *  * @desc  获取一个元素的距离文档(document)的位置，类似jQ中的offset() * @param {HTMLElement} ele  * @returns { {left: number, top: number} } */ function offset(ele) {    var pos = {        left: 0,        top: 0    };    while (ele) {        pos.left += ele.offsetLeft;        pos.top += ele.offsetTop;        ele = ele.offsetParent;    };    return pos;}</code></pre><h2 id="5-3-scrollTo"><a href="#5-3-scrollTo" class="headerlink" title="5.3 scrollTo"></a>5.3 scrollTo</h2><pre><code>var getScrollTop = require(&apos;./getScrollTop&apos;);var setScrollTop = require(&apos;./setScrollTop&apos;);var requestAnimFrame = (function () {    return window.requestAnimationFrame ||        window.webkitRequestAnimationFrame ||        window.mozRequestAnimationFrame ||        function (callback) {            window.setTimeout(callback, 1000 / 60);        };})();/** *  * @desc  在${duration}时间内，滚动条平滑滚动到${to}指定位置 * @param {Number} to  * @param {Number} duration  */ function scrollTo(to, duration) {    if (duration &lt; 0) {        setScrollTop(to);        return    }    var diff = to - getScrollTop();    if (diff === 0) return var step = diff / duration * 10;    requestAnimationFrame(        function () {            if (Math.abs(step) &gt; Math.abs(diff)) {                setScrollTop(getScrollTop() + diff);                return;            }            setScrollTop(getScrollTop() + step);            if (diff &gt; 0 &amp;&amp; getScrollTop() &gt;= to || diff &lt; 0 &amp;&amp; getScrollTop() &lt;= to) {                return;            }            scrollTo(to, duration - 16);        });}</code></pre><h2 id="5-4-setScrollTop"><a href="#5-4-setScrollTop" class="headerlink" title="5.4 setScrollTop"></a>5.4 setScrollTop</h2><pre><code>/** *  * @desc 设置滚动条距顶部的距离 */ function setScrollTop(value) {    window.scrollTo(0, value);    return value;}</code></pre><h2 id="6-Keycode"><a href="#6-Keycode" class="headerlink" title="6.Keycode"></a>6.Keycode</h2><h2 id="6-1-getKeyName"><a href="#6-1-getKeyName" class="headerlink" title="6.1 getKeyName"></a>6.1 getKeyName</h2><pre><code>var keyCodeMap = {    8: &apos;Backspace&apos;,    9: &apos;Tab&apos;,    13: &apos;Enter&apos;,    16: &apos;Shift&apos;,    17: &apos;Ctrl&apos;,    18: &apos;Alt&apos;,    19: &apos;Pause&apos;,    20: &apos;Caps Lock&apos;,    27: &apos;Escape&apos;,    32: &apos;Space&apos;,    33: &apos;Page Up&apos;,    34: &apos;Page Down&apos;,    35: &apos;End&apos;,    36: &apos;Home&apos;,    37: &apos;Left&apos;,    38: &apos;Up&apos;,    39: &apos;Right&apos;,    40: &apos;Down&apos;,    42: &apos;Print Screen&apos;,    45: &apos;Insert&apos;,    46: &apos;Delete&apos;,    48: &apos;0&apos;,    49: &apos;1&apos;,    50: &apos;2&apos;,    51: &apos;3&apos;,    52: &apos;4&apos;,    53: &apos;5&apos;,    54: &apos;6&apos;,    55: &apos;7&apos;,    56: &apos;8&apos;,    57: &apos;9&apos;,    65: &apos;A&apos;,    66: &apos;B&apos;,    67: &apos;C&apos;,    68: &apos;D&apos;,    69: &apos;E&apos;,    70: &apos;F&apos;,    71: &apos;G&apos;,    72: &apos;H&apos;,    73: &apos;I&apos;,    74: &apos;J&apos;,    75: &apos;K&apos;,    76: &apos;L&apos;,    77: &apos;M&apos;,    78: &apos;N&apos;,    79: &apos;O&apos;,    80: &apos;P&apos;,    81: &apos;Q&apos;,    82: &apos;R&apos;,    83: &apos;S&apos;,    84: &apos;T&apos;,    85: &apos;U&apos;,    86: &apos;V&apos;,    87: &apos;W&apos;,    88: &apos;X&apos;,    89: &apos;Y&apos;,    90: &apos;Z&apos;,    91: &apos;Windows&apos;,    93: &apos;Right Click&apos;,    96: &apos;Numpad 0&apos;,    97: &apos;Numpad 1&apos;,    98: &apos;Numpad 2&apos;,    99: &apos;Numpad 3&apos;,    100: &apos;Numpad 4&apos;,    101: &apos;Numpad 5&apos;,    102: &apos;Numpad 6&apos;,    103: &apos;Numpad 7&apos;,    104: &apos;Numpad 8&apos;,    105: &apos;Numpad 9&apos;,    106: &apos;Numpad *&apos;,    107: &apos;Numpad +&apos;,    109: &apos;Numpad -&apos;,    110: &apos;Numpad .&apos;,    111: &apos;Numpad /&apos;,    112: &apos;F1&apos;,    113: &apos;F2&apos;,    114: &apos;F3&apos;,    115: &apos;F4&apos;,    116: &apos;F5&apos;,    117: &apos;F6&apos;,    118: &apos;F7&apos;,    119: &apos;F8&apos;,    120: &apos;F9&apos;,    121: &apos;F10&apos;,    122: &apos;F11&apos;,    123: &apos;F12&apos;,    144: &apos;Num Lock&apos;,    145: &apos;Scroll Lock&apos;,    182: &apos;My Computer&apos;,    183: &apos;My Calculator&apos;,    186: &apos;;&apos;,    187: &apos;=&apos;,    188: &apos;,&apos;,    189: &apos;-&apos;,    190: &apos;.&apos;,    191: &apos;/&apos;,    192: &apos;`&apos;,    219: &apos;[&apos;,    220: &apos;\\&apos;,    221: &apos;]&apos;,    222: &apos;\&apos;&apos;};/** * @desc 根据keycode获得键名 * @param  {Number} keycode  * @return {String} */ function getKeyName(keycode) {    if (keyCodeMap[keycode]) {        return keyCodeMap[keycode];    } else {        console.log(&apos;Unknow Key(Key Code:&apos; + keycode + &apos;)&apos;);        return &apos;&apos;;    }};</code></pre><h2 id="7-Object"><a href="#7-Object" class="headerlink" title="7.Object"></a>7.Object</h2><h2 id="7-1-deepClone"><a href="#7-1-deepClone" class="headerlink" title="7.1 deepClone"></a>7.1 deepClone</h2><pre><code>/** * @desc 深拷贝，支持常见类型 * @param {Any} values */ function deepClone(values) {    var copy;    // Handle the 3 simple types, and null or undefined if (null == values || &quot;object&quot; != typeof values) return values;    // Handle Date if (values instanceof Date) {        copy = new Date();        copy.setTime(values.getTime());        return copy;    }    // Handle Array if (values instanceof Array) {        copy = [];        for (var i = 0, len = values.length; i &lt; len; i++) {            copy[i] = deepClone(values[i]);        }        return copy;    }    // Handle Object if (values instanceof Object) {        copy = {};        for (var attr in values) {            if (values.hasOwnProperty(attr)) copy[attr] = deepClone(values[attr]);        }        return copy;    }    throw new Error(&quot;Unable to copy values! Its type isn&apos;t supported.&quot;);}</code></pre><h2 id="7-2-isEmptyObject"><a href="#7-2-isEmptyObject" class="headerlink" title="7.2 isEmptyObject"></a>7.2 isEmptyObject</h2><pre><code>/** *  * @desc   判断`obj`是否为空 * @param  {Object} obj * @return {Boolean} */ function isEmptyObject(obj) {    if (!obj || typeof obj !== &apos;object&apos; || Array.isArray(obj))        return false return !Object.keys(obj).length}</code></pre><h2 id="8-Random"><a href="#8-Random" class="headerlink" title="8.Random"></a>8.Random</h2><h2 id="8-1-randomColor"><a href="#8-1-randomColor" class="headerlink" title="8.1 randomColor"></a>8.1 randomColor</h2><pre><code>/** *  * @desc 随机生成颜色 * @return {String}  */ function randomColor() {    return &apos;#&apos; + (&apos;00000&apos; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).slice(-6);}</code></pre><h2 id="8-2-randomNum"><a href="#8-2-randomNum" class="headerlink" title="8.2 randomNum"></a>8.2 randomNum</h2><pre><code>/** *  * @desc 生成指定范围随机数 * @param  {Number} min  * @param  {Number} max  * @return {Number}  */ function randomNum(min, max) {    return Math.floor(min + Math.random() * (max - min));}</code></pre><h2 id="9-Regexp"><a href="#9-Regexp" class="headerlink" title="9.Regexp"></a>9.Regexp</h2><h2 id="9-1-isEmail"><a href="#9-1-isEmail" class="headerlink" title="9.1 isEmail"></a>9.1 isEmail</h2><pre><code>/** *  * @desc   判断是否为邮箱地址 * @param  {String}  str * @return {Boolean}  */ function isEmail(str) {    return /\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*/.test(str);}</code></pre><h2 id="9-2-isIdCard"><a href="#9-2-isIdCard" class="headerlink" title="9.2 isIdCard"></a>9.2 isIdCard</h2><pre><code>/** *  * @desc  判断是否为身份证号 * @param  {String|Number} str  * @return {Boolean} */ function isIdCard(str) {    return /^(^[1-9]\d{7}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])\d{3}$)|(^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[Xx])$)$/.test(str)}</code></pre><h2 id="9-3-isPhoneNum"><a href="#9-3-isPhoneNum" class="headerlink" title="9.3 isPhoneNum"></a>9.3 isPhoneNum</h2><pre><code>/** *  * @desc   判断是否为手机号 * @param  {String|Number} str  * @return {Boolean}  */ function isPhoneNum(str) {    return /^(0|86|17951)?(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$/.test(str)}</code></pre><h2 id="9-4-isUrl"><a href="#9-4-isUrl" class="headerlink" title="9.4 isUrl"></a>9.4 isUrl</h2><pre><code>/** *  * @desc   判断是否为URL地址 * @param  {String} str  * @return {Boolean} */ function isUrl(str) {    return /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&amp;//=]*)/i.test(str);}</code></pre><h2 id="10-String"><a href="#10-String" class="headerlink" title="10.String"></a>10.String</h2><h2 id="10-1-digitUppercase"><a href="#10-1-digitUppercase" class="headerlink" title="10.1 digitUppercase"></a>10.1 digitUppercase</h2><pre><code>/** *  * @desc   现金额转大写 * @param  {Number} n  * @return {String} */ function digitUppercase(n) {    var fraction = [&apos;角&apos;, &apos;分&apos;];    var digit = [        &apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;,        &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos;    ];    var unit = [        [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;],        [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;]    ];    var head = n &lt; 0 ? &apos;欠&apos; : &apos;&apos;;    n = Math.abs(n);    var s = &apos;&apos;;    for (var i = 0; i &lt; fraction.length; i++) {        s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;);    }    s = s || &apos;整&apos;;    n = Math.floor(n);    for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) {        var p = &apos;&apos;;        for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) {            p = digit[n % 10] + unit[1][j] + p;            n = Math.floor(n / 10);        }        s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s;    }    return head + s.replace(/(零.)*零元/, &apos;元&apos;)        .replace(/(零.)+/g, &apos;零&apos;)        .replace(/^整$/, &apos;零元整&apos;);};</code></pre><h2 id="11-Support"><a href="#11-Support" class="headerlink" title="11.Support"></a>11.Support</h2><h2 id="11-1-isSupportWebP"><a href="#11-1-isSupportWebP" class="headerlink" title="11.1 isSupportWebP"></a>11.1 isSupportWebP</h2><pre><code>/** *  * @desc 判断浏览器是否支持webP格式图片 * @return {Boolean}  */ function isSupportWebP() {    return !![].map &amp;&amp; document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0;}</code></pre><h2 id="12-Time"><a href="#12-Time" class="headerlink" title="12.Time"></a>12.Time</h2><h2 id="12-1-formatPassTime"><a href="#12-1-formatPassTime" class="headerlink" title="12.1 formatPassTime"></a>12.1 formatPassTime</h2><pre><code>/** * @desc   格式化${startTime}距现在的已过时间 * @param  {Date} startTime  * @return {String} */ function formatPassTime(startTime) {    var currentTime = Date.parse(new Date()),        time = currentTime - startTime,        day = parseInt(time / (1000 * 60 * 60 * 24)),        hour = parseInt(time / (1000 * 60 * 60)),        min = parseInt(time / (1000 * 60)),        month = parseInt(day / 30),        year = parseInt(month / 12);    if (year) return year + &quot;年前&quot; if (month) return month + &quot;个月前&quot; if (day) return day + &quot;天前&quot; if (hour) return hour + &quot;小时前&quot; if (min) return min + &quot;分钟前&quot; else return &apos;刚刚&apos;}</code></pre><h2 id="12-2-formatRemainTime"><a href="#12-2-formatRemainTime" class="headerlink" title="12.2 formatRemainTime"></a>12.2 formatRemainTime</h2><pre><code>/** *  * @desc   格式化现在距${endTime}的剩余时间 * @param  {Date} endTime   * @return {String} */ function formatRemainTime(endTime) {    var startDate = new Date(); //开始时间 var endDate = new Date(endTime); //结束时间 var t = endDate.getTime() - startDate.getTime(); //时间差 var d = 0,        h = 0,        m = 0,        s = 0;    if (t &gt;= 0) {        d = Math.floor(t / 1000 / 3600 / 24);        h = Math.floor(t / 1000 / 60 / 60 % 24);        m = Math.floor(t / 1000 / 60 % 60);        s = Math.floor(t / 1000 % 60);    }    return d + &quot;天 &quot; + h + &quot;小时 &quot; + m + &quot;分钟 &quot; + s + &quot;秒&quot;;}</code></pre><h2 id="13-Url"><a href="#13-Url" class="headerlink" title="13.Url"></a>13.Url</h2><h2 id="13-1-parseQueryString"><a href="#13-1-parseQueryString" class="headerlink" title="13.1 parseQueryString"></a>13.1 parseQueryString</h2><pre><code>/** *  * @desc   url参数转对象 * @param  {String} url  default: window.location.href * @return {Object}  */ function parseQueryString(url) {    url = url == null ? window.location.href : url    var search = url.substring(url.lastIndexOf(&apos;?&apos;) + 1)    if (!search) {        return {}    }    return JSON.parse(&apos;{&quot;&apos; + decodeURIComponent(search).replace(/&quot;/g, &apos;\\&quot;&apos;).replace(/&amp;/g, &apos;&quot;,&quot;&apos;).replace(/=/g, &apos;&quot;:&quot;&apos;) + &apos;&quot;}&apos;)}</code></pre><h2 id="13-2-stringfyQueryString"><a href="#13-2-stringfyQueryString" class="headerlink" title="13.2 stringfyQueryString"></a>13.2 stringfyQueryString</h2><pre><code>/** *  * @desc   对象序列化 * @param  {Object} obj  * @return {String} */ function stringfyQueryString(obj) {    if (!obj) return &apos;&apos;;    var pairs = [];    for (var key in obj) {        var value = obj[key];        if (value instanceof Array) {            for (var i = 0; i &lt; value.length; ++i) {                pairs.push(encodeURIComponent(key + &apos;[&apos; + i + &apos;]&apos;) + &apos;=&apos; + encodeURIComponent(value[i]));            }            continue;        }        pairs.push(encodeURIComponent(key) + &apos;=&apos; + encodeURIComponent(obj[key]));    }    return pairs.join(&apos;&amp;&apos;);}</code></pre><h2 id="14-Function"><a href="#14-Function" class="headerlink" title="14.Function"></a>14.Function</h2><h2 id="14-1-throttle"><a href="#14-1-throttle" class="headerlink" title="14.1 throttle"></a>14.1 throttle</h2><pre><code>/** * @desc   函数节流。 * 适用于限制`resize`和`scroll`等函数的调用频率 * * @param  {Number}    delay          0 或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。 * @param  {Boolean}   noTrailing     可选，默认为false。 *                                    如果noTrailing为true，当节流函数被调用，每过`delay`毫秒`callback`也将执行一次。 *                                    如果noTrailing为false或者未传入，`callback`将在最后一次调用节流函数后再执行一次. *                                    （延迟`delay`毫秒之后，节流函数没有被调用,内部计数器会复位） * @param  {Function}  callback       延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的， *                                    执行去节流功能时，调用`callback`。 * @param  {Boolean}   debounceMode   如果`debounceMode`为true，`clear`在`delay`ms后执行。 *                                    如果debounceMode是false，`callback`在`delay` ms之后执行。 * * @return {Function}  新的节流函数 */ function throttle(delay, noTrailing, callback, debounceMode) {    // After wrapper has stopped being called, this timeout ensures that // `callback` is executed at the proper times in `throttle` and `end` // debounce modes. var timeoutID;    // Keep track of the last time `callback` was executed. var lastExec = 0;    // `noTrailing` defaults to falsy. if (typeof noTrailing !== &apos;boolean&apos;) {        debounceMode = callback;        callback = noTrailing;        noTrailing = undefined;    }    // The `wrapper` function encapsulates all of the throttling / debouncing // functionality and when executed will limit the rate at which `callback` // is executed. function wrapper() {        var self = this;        var elapsed = Number(new Date()) - lastExec;        var args = arguments;        // Execute `callback` and update the `lastExec` timestamp. function exec() {            lastExec = Number(new Date());            callback.apply(self, args);        }        // If `debounceMode` is true (at begin) this is used to clear the flag // to allow future `callback` executions. function clear() {            timeoutID = undefined;        }        if (debounceMode &amp;&amp; !timeoutID) {            // Since `wrapper` is being called for the first time and // `debounceMode` is true (at begin), execute `callback`.            exec();        }        // Clear any existing timeout. if (timeoutID) {            clearTimeout(timeoutID);        }        if (debounceMode === undefined &amp;&amp; elapsed &gt; delay) {            // In throttle mode, if `delay` time has been exceeded, execute // `callback`.            exec();        } else if (noTrailing !== true) {            // In trailing throttle mode, since `delay` time has not been // exceeded, schedule `callback` to execute `delay` ms after most // recent execution. // // If `debounceMode` is true (at begin), schedule `clear` to execute // after `delay` ms. // // If `debounceMode` is false (at end), schedule `callback` to // execute after `delay` ms.            timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);        }    }    // Return the wrapper function. return wrapper;};</code></pre><h2 id="14-2-debounce"><a href="#14-2-debounce" class="headerlink" title="14.2 debounce"></a>14.2 debounce</h2><pre><code>/** * @desc 函数防抖  * 与throttle不同的是，debounce保证一个函数在多少毫秒内不再被触发，只会执行一次， * 要么在第一次调用return的防抖函数时执行，要么在延迟指定毫秒后调用。 * @example 适用场景：如在线编辑的自动存储防抖。 * @param  {Number}   delay         0或者更大的毫秒数。 对于事件回调，大约100或250毫秒（或更高）的延迟是最有用的。 * @param  {Boolean}  atBegin       可选，默认为false。 *                                  如果`atBegin`为false或未传入，回调函数则在第一次调用return的防抖函数后延迟指定毫秒调用。                                    如果`atBegin`为true，回调函数则在第一次调用return的防抖函数时直接执行 * @param  {Function} callback      延迟毫秒后执行的函数。`this`上下文和所有参数都是按原样传递的， *                                  执行去抖动功能时，，调用`callback`。 * * @return {Function} 新的防抖函数。 */ var throttle = require(&apos;./throttle&apos;);function debounce(delay, atBegin, callback) {    return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);};</code></pre><p>封装</p><p>除了对上面这些常用函数进行封装， 最重要的是支持合理化的引入，这里我们使用<code>webpack</code>统一打包成<code>UMD</code> 通用模块规范，支持<code>webpack</code>、<code>RequireJS</code>、<code>SeaJS</code>等模块加载器，亦或直接通过<code>&lt;script&gt;</code>标签引入。</p><p>但这样，还是不能让人满意。因为完整引入整个库，略显浪费，我们不可能用到所有的函数。那么，就支持按需引入吧</p><p>1.目录结构说明</p><pre><code>│  .babelrc│  .gitignore│  .travis.yml│  LICENSE│  package.json│  README.md│  setCookie.js  // 拷贝到根路径的函数模块，方便按需加载│  setScrollTop.js│  stringfyQueryString.js│   ...│   ...│  ├─min│      outils.min.js  // 所有函数统一打包生成的全量压缩包│      ├─script  // 本项目开发脚本目录│      build.js  // 打包构建脚本│      test.js  // 测试脚本│      webpack.conf.js  // webpack打包配置文件│      ├─src // 源码目录│  │  index.js  // webpack入口文件│  │  │  ├─array│  │      │  ├─class│  │      │  ├─cookie│  │      │  ├─device│  │      │  ├─dom│  │      │  ├─keycode│  │      │  ├─object│  │      │  ├─random│  │      │  ├─regexp│  │      │  ├─string│  │      │  ├─support│  │      │  ├─time│  │      │  └─url│          └─test // 测试用例目录    │  array.test.js    │  class.test.js    │  cookie.test.js    │  device.test.js    │  dom.test.js    │  index.html    │  keycode.test.js    │  object.test.js    │  random.test.js    │  regexp.test.js    │  string.test.js    │  support.test.js    │  time.test.js    │  url.test.js    │      └─_lib // 测试所用到的第三方库            mocha.css            mocha.js            power-assert.js</code></pre><p>2.构建脚本</p><p>这里主要说明一下项目中<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fbuild.js" target="_blank" rel="noopener"> build.js </a>的构建过程<br>第一步，构建全量压缩包，先删除<code>min</code>目录中之前的<code>outils.min.js</code>，后通过<code>webpack</code>打包并保存新的压缩包至<code>min</code>目录中：</p><pre><code>...... ...... // 删除旧的全量压缩包 rm(path.resolve(rootPath, &apos;min&apos;, `${pkg.name}.min.js`), err =&gt; {     if (err) throw (err)     webpack(config, function (err, stats) {         if (err) throw (err)         building.stop()         process.stdout.write(stats.toString({             colors: true,             modules: false,             children: false,             chunks: false,             chunkModules: false         }) + &apos;\n\n&apos;)         resolve()         console.log(chalk.cyan(&apos;  Build complete.\n&apos;))     }) }) ...... ......</code></pre><p>第二步，拷贝函数模块至根目录，先删除根目录中之前的函数模块，后拷贝<code>src</code>下面一层目录的所有<code>js</code>文件至根目录。这么做的目的是，拷贝到根路径，在引入的时候，直接<code>require(&#39;outils/&lt;方法名&gt;&#39;)</code>即可，缩短引入的路径，也算是提高点效率。</p><pre><code>// 替换模块文件    ......    ......    // 先删除根目录中之前的函数模块    rm(&apos;*.js&apos;, err =&gt; {        if (err) throw (err)        let folderList = fs.readdirSync(path.resolve(rootPath, &apos;src&apos;))        folderList.forEach((item, index) =&gt; {            // 拷贝`src`下面一层目录的所有`js`文件至根目录            copy(`src/${item}/*.js`, rootPath, function (err, files) {                if (err) throw err;                if (index === folderList.length - 1) {                    console.log(chalk.cyan(&apos;  Copy complete.\n&apos;))                    copying.stop()                }            })        })    })    ......    ......</code></pre><p>3.书写测试用例</p><p>俗话说，不写测试用例的前端不是一个好程序员。那就不能怂，就是干。</p><p>但是因为时间关系，本项目暂时通过项目中的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Ftest.js" target="_blank" rel="noopener"> test.js </a>，启动了一个<code>koa</code>静态服务器，来加载<code>mocha</code>网页端的测试页面，让笔者书写项目时，可以在本地对函数功能进行测试。<br>但是后续将使用<code>travis-ci</code>配合<code>Github</code>来做持续化构建，自动发布到<code>npm</code>。改用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>做单元测试，使用<code>Coverage</code>测试覆盖率。这一部分，后续更新。</p><p>这里给大家推荐一个好用的断言库<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252Fpackage%252Fpower-assert" target="_blank" rel="noopener"> power-assert </a>，这个库记住<code>assert(value, [message])</code>一个API就基本无敌，从此再也不用担心记不住断言库的API。</p><p>本项目的所有测试用例都在<code>test</code>目录下，大家可以作一定参考。</p><p>更新：单元测试，已使用<code>karma</code>，<code>mocha</code>，<code>power-assert</code>，使用<code>Coverage</code>测试覆盖率，并集成<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Ftravis-ci.org%252F" target="_blank" rel="noopener"> travis-ci </a>配合<code>Github</code>来做持续化构建，可以参考本项目的<code>travis</code>配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252F.travis.yml" target="_blank" rel="noopener"> .travis.yml </a>和<code>karma</code>的配置文件<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fscript%252Fkarma.conf.js" target="_blank" rel="noopener"> karma.conf.js </a>。</p><blockquote><p>发布</p></blockquote><p>首先放到<code>Github</code>托管一下，当然你也可以直接<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252F" target="_blank" rel="noopener">fork</a>本项目，然后再加入你自己的函数。<br>以笔者项目，举个栗子:</p><p>1.添加自己的函数</p><p>在<code>src</code>目录下，新建分类目录或者选择一个分类，在子文件夹中添加函数模块文件（建议一个小功能保存为一个JS文件）。</p><pre><code>/** *  * @desc   判断是否NaN * @param  {Any} value  * @return {Boolean} */ function isNaN(value) {        return value !== value;};modules.export = isNaN</code></pre><p>然后记得在src/index.js文件中暴露isNaN函数</p><p>2.单元测试</p><p>在<code>test</code>文件新建测试用例</p><pre><code>describe(&apos;#isNaN()&apos;, function () {    it(`outils.isNaN(NaN) should return true`, function () {        assert(outils.isNaN(NaN))    })    it(`outils.isNaN(&apos;value&apos;) should return false`, function () {        assert.notEqual(outils.isNaN(NaN))    })})</code></pre><p>然后记得在<code>test/index.html</code>中引入之前创建的测试用例脚本。</p><p>3.测试并打包</p><p>执行<code>npm run test</code>，看所有的测试用例是否通过。如果没有问题，执行<code>npm run build</code>构建，之后提交到个人的 github 仓库即可。</p><p>4.发布到<code>npm</code></p><p>在<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>注册账号，修改本地<code>package.json</code>中的<code>name</code>、<code>version</code>、<code>author</code>等信息，最后<code>npm publish</code>就大功告成了。<br>注意：向<code>npm</code>发包，要把镜像源切到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.npmjs.com%252F" target="_blank" rel="noopener"> www.npmjs.com </a>，使用<code>cnpm</code>等第三方镜像源会报错。</p><p>使用</p><p>1.浏览器</p><p>直接下载<code>min</code>目录下的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fblob%252Fmaster%252Fmin%252Foutils.min.js" target="_blank" rel="noopener"> outils.min.js </a>，通过<code>&lt;script&gt;</code>标签引入。</p><pre><code>&lt;script src=&quot;outils.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var OS = outils.getOS()  &lt;/script&gt;</code></pre><p>注意： 本仓库代码会持续更新，如果你需要不同版本的增量压缩包或源码，请到<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Freleases" target="_blank" rel="noopener"> github Release </a>页面下载对应版本号的代码。</p><p>2.Webpack、RequireJS、SeaJS等模块加载器</p><p>先使用<code>npm</code>安装<code>outils</code>。</p><pre><code>$ npm install --save-dev outils// 完整引入 const outils = require(&apos;outils&apos;)const OS = outils.getOS()推荐使用方法 // 按需引入require(&apos;outils/&lt;方法名&gt;&apos;) const getOS = require(&apos;outils/getOS&apos;)const OS = getOS()</code></pre><p>当然，你的开发环境有<code>babel</code>编译<code>ES6</code>语法的话，也可以这样使用：</p><pre><code>import getOS from &apos;outils/getOS&apos; // 或 import { getOS } from &quot;outils&quot;;</code></pre><p>总结</p><p>这里只是简单封装，发布到<code>npm</code>上，省去下次复制粘贴的功夫，或者直接Goole的时间。如果笔者的库中，没有你常用的函数，或者你有更好的建议，欢迎来本项目的<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils%252Fissues" target="_blank" rel="noopener"> Github Issues </a>交流，如果觉得不错，欢迎<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> star </a>本项目。</p><p>当然，更好的建议是<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fgithub.com%252FproYang%252Foutils" target="_blank" rel="noopener"> fork </a>本项目，或者直接新建自己的项目，添加自己 想要的 、常用的 、记不住的 函数，甚至是可以抽象出来的功能，封装成自己顺手、熟悉的库。 这样才能打造出你自己的武器库，瞬间提高你的单兵作战（开发）能力。</p><h2 id="libraries-：https-github-com-wuxianqiang-libraries"><a href="#libraries-：https-github-com-wuxianqiang-libraries" class="headerlink" title="libraries ：https://github.com/wuxianqiang/libraries"></a>libraries ：<a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries" target="_blank" rel="noopener">https://github.com/wuxianqiang/libraries</a></h2><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectcreate%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.create()函数</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADstringtrim%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中String.trim()函数</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarrayreduce%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.reduce()函数</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADobjectkeys%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Object.keys()函数</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADfunctionbind%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Function.bind()函数</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFecmascript5%25E4%25B8%25ADarraymap%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿ECMAScript5中Array.map()函数</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFmathmax%25E6%2596%25B9%25E6%25B3%2595%25E4%25B8%258D%25E5%25AE%259A%25E5%25AE%259E%25E5%258F%2582%25E5%2587%25BD%25E6%2595%25B0" target="_blank" rel="noopener">仿Math.max()方法实现</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFstringmatch%25E6%2596%25B9%25E6%25B3%2595%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">仿String.match()方法实现</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%25BFhtml5%25E7%259A%2584classlist%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">仿HTML5的classList属性实现</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2587%25BD%25E6%2595%25B0%25E7%259A%2584%25E5%2590%258D%25E5%25AD%2597" target="_blank" rel="noopener">仿Function.name属性实现</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E5%25B1%2582%25E7%25A5%2596%25E5%2585%2588%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n层祖先元素</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%2585%2584%25E5%25BC%259F%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个兄弟元素</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25BF%2594%25E5%259B%259E%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25ACn%25E4%25B8%25AA%25E5%25AD%2590%25E4%25BB%25A3%25E5%2585%2583%25E7%25B4%25A0" target="_blank" rel="noopener">返回元素的第n个子代元素</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB1" target="_blank" rel="noopener">原生JS实现CSS动画之震动</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%258E%259F%25E7%2594%259Fjs%25E5%25AE%259E%25E7%258E%25B0css%25E5%258A%25A8%25E7%2594%25BB2" target="_blank" rel="noopener">原生JS实现CSS动画之隐藏</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E6%2595%25B0%25E7%25BB%2584%25E4%25B8%25AD%25E6%259F%25A5%25E6%2589%25BE%25E6%2589%2580%25E6%259C%2589%25E5%2587%25BA%25E7%258E%25B0%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E6%2596%25B9%25E6%25B3%2595" target="_blank" rel="noopener">在数组中查找所有出现的元素方法</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E6%258D%25AE%25E7%25B1%25BB%25E5%259E%258B%25E6%25A3%2580%25E6%25B5%258B%25E7%2589%25B9%25E6%25AE%258A%25E6%2583%2585%25E5%2586%25B5%25E7%2589%25B9%25E6%25AE%258A%25E5%25A4%2584%25E7%2590%2586" target="_blank" rel="noopener">数据类型检测之特殊情况特殊处理</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0outerhtml%25E5%25B1%259E%25E6%2580%25A7" target="_blank" rel="noopener">使用innerHTML实现outerHTML属性</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258F%2592%25E5%2585%25A5%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">插入节点</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2580%2592%25E5%25BA%258F%25E6%258E%2592%25E5%2588%2597%25E5%25AD%2590%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">倒序排列子节点</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E6%25BB%259A%25E5%258A%25A8%25E6%259D%25A1%25E7%259A%2584%25E4%25BD%258D%25E7%25BD%25AE" target="_blank" rel="noopener">查询窗口滚动条的位置</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25AA%2597%25E5%258F%25A3%25E7%259A%2584%25E8%25A7%2586%25E5%258F%25A3%25E5%25B0%25BA%25E5%25AF%25B8" target="_blank" rel="noopener">查询窗口的视口尺寸</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%25A1%25A8%25E6%25A0%25BC%25E7%259A%2584%25E8%25A1%258C%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">表格的行排序</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E7%2594%259F%25E6%2588%2590%25E7%259B%25AE%25E5%25BD%2595%25E8%25A1%25A8" target="_blank" rel="noopener">生成目录表</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2595%25B0%25E7%25BB%2584%25E5%258E%25BB%25E9%2587%258D" target="_blank" rel="noopener">数组去重</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%2586%2592%25E6%25B3%25A1%25E6%258E%2592%25E5%25BA%258F" target="_blank" rel="noopener">冒泡排序</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BB%258Eurl%25E8%25A7%25A3%25E6%259E%2590%25E5%258F%2582%25E6%2595%25B0" target="_blank" rel="noopener">从URL解析参数</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E8%258E%25B7%25E5%258F%2596%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E7%259A%2584%25E5%2585%2583%25E7%25B4%25A0%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">获取纯文本的元素内容</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%2589%258B%25E5%2586%2599%25E4%25B8%2580%25E4%25B8%25AAjsonp%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">手写一个JSONP实现</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E8%25AF%25A2%25E7%25BA%25AF%25E6%2596%2587%25E6%259C%25AC%25E5%25BD%25A2%25E5%25BC%258F%25E7%259A%2584%25E5%2586%2585%25E5%25AE%25B9" target="_blank" rel="noopener">查询纯文本形式的内容</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%259F%25A5%25E6%2589%25BE%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E5%2590%258E%25E4%25BB%25A3%25E4%25B8%25AD%25E8%258A%2582%25E7%2582%25B9%25E4%25B8%25AD%25E7%259A%2584%25E6%2589%2580%25E6%259C%2589text%25E8%258A%2582%25E7%2582%25B9" target="_blank" rel="noopener">查找元素的后代中节点中的所有Text节点</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8innerhtml%25E5%25AE%259E%25E7%258E%25B0insertadjacenthtml" target="_blank" rel="noopener">使用innerHTML实现insertAdjacentHTML</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E6%258B%2596%25E6%258B%25BD" target="_blank" rel="noopener">拖拽</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8%25E8%25B0%25B7%25E6%25AD%258C%25E5%259C%25B0%25E5%259B%25BE%25E4%25B8%258A%25E6%2598%25BE%25E7%25A4%25BA%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E4%25BF%25A1%25E6%2581%25AF" target="_blank" rel="noopener">在谷歌地图上显示地理位置信息</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8%25E6%2589%2580%25E6%259C%2589%25E5%259C%25B0%25E7%2590%2586%25E4%25BD%258D%25E7%25BD%25AE%25E7%2589%25B9%25E6%2580%25A7" target="_blank" rel="noopener">使用所有地理位置特性</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BC%2598%25E9%259B%2585%25E7%259A%2584%25E5%259B%25BE%25E7%2589%2587%25E7%25BF%25BB%25E8%25BD%25AC%25E5%25AE%259E%25E7%258E%25B0" target="_blank" rel="noopener">优雅的图片翻转实现</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E5%25A4%259A%25E8%25BE%25B9%25E5%25BD%25A2" target="_blank" rel="noopener">使用canvas绘制多边形</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E4%25BD%25BF%25E7%2594%25A8canvas%25E7%25BB%2598%25E5%2588%25B6%25E9%259B%25AA%25E8%258A%25B1" target="_blank" rel="noopener">使用canvas绘制雪花</a></li><li><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23%25E5%259C%25A8web-worker%25E4%25B8%25AD%25E5%258F%2591%25E8%25B5%25B7%25E5%2590%258C%25E6%25AD%25A5xmlhtttprequest" target="_blank" rel="noopener">在Web Worker中发起同步XMLHtttpRequest</a></li></ul><h2 id="仿ECMAScript5中Object-create-函数"><a href="#仿ECMAScript5中Object-create-函数" class="headerlink" title="仿ECMAScript5中Object.create()函数"></a>仿ECMAScript5中Object.create()函数</h2><pre><code>function inherit(obj) {            if (obj === null) throw TypeError();            if (Object.create) return Object.create(obj);            var t = typeof obj;            if (t !== &quot;object&quot; &amp;&amp; t !== &quot;function&quot;) throw TypeError();            function Fn() {};            Fn.prototype = obj;            return new Fn();        }</code></pre><h2 id="仿ECMAScript5中String-trim-函数"><a href="#仿ECMAScript5中String-trim-函数" class="headerlink" title="仿ECMAScript5中String.trim()函数"></a>仿ECMAScript5中String.trim()函数</h2><pre><code>String.prototype.mytrim = function () {            String.prototype.trim || function () {                if (!this) return this; //空字符串不做处理                return this.replace(/^\s+|\s+$/g, &quot;&quot;) //使用正则表达式经行空格替换            }        }</code></pre><h2 id="仿ECMAScript5中Array-reduce-函数"><a href="#仿ECMAScript5中Array-reduce-函数" class="headerlink" title="仿ECMAScript5中Array.reduce()函数"></a>仿ECMAScript5中Array.reduce()函数</h2><pre><code>var reduce = Array.prototype.reduce ? function (ary, fn, initial) {            if (arguments.length &gt; 2) { //如果reduce()方法存在的话                return ary.reduce(fn, initial); //如果传入了一个初始值            } else {                return ary.reduce(fn); //否则初始值            }        } : function (ary, fn, initial) { //以特定的初始值开始，否则第一个值取自ary            var i = 0,                len = ary.length,                accumulator;            if (arguments.length &gt; 2) {                accumulator = initial;            } else { //找到数组中第一个已经定义的索引                if (len == 0) throw TypeError();                while (i &lt; len) {                    if (i in ary) {                        accumulator = ary[i++];                        break;                    } else {                        i++;                    }                }                if (i == len) throw TypeError();            }            while (i &lt; len) { //对于数组中剩下的元素依次调用fn                if (i in ary) {                    accumulator = fn.call(undefined, accumulator, ary[i], i, ary)                }                i++;            }            return accumulator;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="在数组中查找所有出现的元素方法"><a href="#在数组中查找所有出现的元素方法" class="headerlink" title="在数组中查找所有出现的元素方法"></a>在数组中查找所有出现的元素方法</h2><pre><code>function findAll(ary, ele) {            var results = [],                len = ary.length,                pos = 0;            while (pos &lt; len) {                pos = ary.indexOf(ele, pos);                if (pos === -1) break;                results.push(pos);                pos++;            }            return results;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="数据类型检测，特殊情况特殊处理"><a href="#数据类型检测，特殊情况特殊处理" class="headerlink" title="数据类型检测，特殊情况特殊处理"></a>数据类型检测，特殊情况特殊处理</h2><pre><code>function classOf(obj) {            if (obj === null) return &quot;Null&quot;;            if (obj === undefined) return &apos;Undefined&apos;;            return Object.prototype.toString.call(obj).slice(8, -1);        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="仿ECMAScript5中Object-keys-函数"><a href="#仿ECMAScript5中Object-keys-函数" class="headerlink" title="仿ECMAScript5中Object.keys()函数"></a>仿ECMAScript5中Object.keys()函数</h2><pre><code>function keys(obj) {            if (typeof obj !== &quot;object&quot;) {                throw TypeError();            }            var result = [];            for (var prop in obj) {                if (obj.hasOwnProperty(prop)) {                    result.push(prop);                }            }            return result;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="仿Math-max方法（不定实参函数）"><a href="#仿Math-max方法（不定实参函数）" class="headerlink" title="仿Math.max方法（不定实参函数）"></a>仿Math.max方法（不定实参函数）</h2><pre><code>function max() {            var max = Number.NEGATIVE_INFINITY;            for (var i = 0; i &lt; arguments.length; i++) {                if (arguments[i] &gt; max) max = arguments[i];            }            return max;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="仿ECMAScript5中Function-bind-函数"><a href="#仿ECMAScript5中Function-bind-函数" class="headerlink" title="仿ECMAScript5中Function.bind()函数"></a>仿ECMAScript5中Function.bind()函数</h2><pre><code>if (!Function.prototype.bind) {            Function.prototype.bind = function (obj) {                var self = this,                    boundArgs = arguments;                return function () {                    var args = [],                        i;                    for (i = 1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);                    for (i = 1; i &lt; arguments.length; i++) args.push(arguments[i]);                    return self.apply(obj, args);                }            }        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="仿ECMAScript5中Array-map-函数"><a href="#仿ECMAScript5中Array-map-函数" class="headerlink" title="仿ECMAScript5中Array.map()函数"></a>仿ECMAScript5中Array.map()函数</h2><pre><code>var map = Array.prototype.map ? function (ary, fn) {            return ary.map(fn);        } : function (ary, fn) {            var results = [];            for (var i = 0, len = ary.length; i &lt; len; i++) {                if (i in ary) {                    results[i] = fn.call(null, ary[i], i, ary);                }            }            return results;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><pre><code>Array.prototype.unique = function unique() {            var obj = {};            for (var i = 0; i &lt; this.length; i++) {                var current = this[i];                if (obj[current] === current) {                    current = this[this.length - 1];                    this.length--;                    i--;                    continue;                }                obj[current] = current            }            obj = null;            return this;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><pre><code>Array.prototype.bubbleSort = function bubbleSort() {            var temp = null;            for (var i = 0; i &lt; this.length - 1; i++) {                for (var k = 0; k &lt; this.length - 1 - i; k++) {                    if (this[k] &gt; this[k + 1]) {                        temp = this[k];                        this[k] = this[k + 1];                        this[k + 1] = temp;                    }                }            }            return this;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="仿String-match-方法实现"><a href="#仿String-match-方法实现" class="headerlink" title="仿String.match()方法实现"></a>仿String.match()方法实现</h2><pre><code>String.prototype.mymatch = function (reg) {         var ary = [];         var res = reg.exec(this);         while (res) {            ary.push(res[0]);            res = reg.exec(this);         }         return ary;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="返回元素的第n层祖先元素"><a href="#返回元素的第n层祖先元素" class="headerlink" title="返回元素的第n层祖先元素"></a>返回元素的第n层祖先元素</h2><pre><code>/**        *返回元素ele的第n层祖先元素，如果不存在此类祖先或祖先不是Element，        *（例如Document或者DocumentFragment）则返回null        *如果n为0，则返回e本身。如果n为1（或省略），则返回其父元素        *如果n为2，则返回其祖父元素，依次类推        */        function parent(ele, n) {            if (n === nudefined) n = 1;            while (n-- &amp;&amp; ele) {                ele = ele.parentNode;            }            if (!ele || ele.nodeTope !== 1) return null;            return ele;        }</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="返回元素的第n个兄弟元素"><a href="#返回元素的第n个兄弟元素" class="headerlink" title="返回元素的第n个兄弟元素"></a>返回元素的第n个兄弟元素</h2><pre><code>/** *返回元素ele的第n个兄弟元素 *如果n为正，返回后续的第n个兄弟元素 *如果n为负，返回前面的第n个兄弟元素 *如果n为零，返回ele本身 */function sibling(ele, n) {    while (ele &amp;&amp; n !== 0) { //如果ele未定义，即刻返回它        if (n &gt; 0) { //查找后续的兄弟元素            if (ele.nextElementSibling) {                ele = ele.nextElementSibling;            } else {                for (ele = ele.nextSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;            }            n--;        } else { //查找前面的兄弟元素            if (ele.previousElementSibing) {                ele = ele.previousElementSibling;            } else {                for (ele = ele.previousSibling; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;            }            n++;        }    }    return ele;}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="返回元素的第n个子代元素"><a href="#返回元素的第n个子代元素" class="headerlink" title="返回元素的第n个子代元素"></a>返回元素的第n个子代元素</h2><pre><code>/** *返回元素ele的第n代子元素，如果不存在则为null *负值n代表从后往前计数。0表示第一个子元素，而-1代表最后一个，-2代表倒数第二个，依次类推 */function child(ele, n) {    if (ele.children) { //如果children数组存在        if (n &lt; 0) n += ele.children.length; //转换负的n为数组索引        if (n &lt; 0) return null; //如果它仍然为负，说明没有子元素        return ele.children[n]; //返回指定的子元素    }    //如果e没有children数组，找到第一个子元素并向前数，或找到最后一个子元素并往回数    if (n &gt;= 0) { //n非负：从第一个子元素向前数        //找到元素e的第一个子元素        if (ele.firstElementChild) {            ele = ele.firstElementChild;        } else {            for (ele = ele.firstChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.nextSibling) /*空循环*/;        }        return sibling(ele, n); //返回第一个子元素的第n个兄弟元素    } else { //n为负：从最后一个子元素往回数        if (ele.lastElementChild) {            ele = ele.lastElementChild;        } else {            for (ele = ele.lastChild; ele &amp;&amp; ele.nodeType !== 1; ele = ele.previousSibling) /*空循环*/;        }        return sibling(ele, n + 1); //+1来转化最后1个子元素为最后1个兄弟元素    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="表格的行排序"><a href="#表格的行排序" class="headerlink" title="表格的行排序"></a>表格的行排序</h2><pre><code>//根据指定表格每行第n个单元格的值，对第一个＜tbody＞中的行进行排序//如果存在comparator函数则使用它，否则按字母表顺序比较function sortrows(table, n, comparator) {    var tbody = table.tBodies[0]; //第一个＜tbody＞，可能是隐式创建的    var rows = tbody.getElementsByTagName(&quot;tr&quot;); //tbody中的所有行    rows = Array.prototype.slice.call(rows, 0); //真实数组中的快照    //基于第n个＜td＞元素的值对行排序    rows.sort(function (row1, row2) {        var cell1 = row1.getElementsByTagName(&quot;td&quot;)[n]; //获得第n个单元格        var cell2 = row2.getElementsByTagName(&quot;td&quot;)[n]; //两行都是        var val1 = cell1.textContent || cell1.innerText; //获得文本内容        var val2 = cell2.textContent || cell2.innerText; //两单元格都是        if (comparator) return comparator(val1, val2); //进行比较        if (val1 &lt; val2) {            return -1;        } else if (val1 &gt; val2) {            return 1;        } else {            return 0;        }    }); //在tbody中按它们的顺序把行添加到最后    //这将自动把它们从当前位置移走，故没必要预先删除它们    //如果＜tbody＞还包含了除了＜tr＞的任何其他元素，这些节点将会悬浮到顶部位置    for (var i = 0; i &lt; rows.length; i++) tbody.appendChild(rows[i]);}//查找表格的＜th＞元素（假设只有一行），让它们可单击，//以便单击列标题，按该列对行排序function makeSortable(table) {    var headers = table.getElementsByTagName(&quot;th&quot;);    for (var i = 0; i &lt; headers.length; i++) {        (function (n) { //嵌套函数来创建本地作用域            headers[i].onclick = function () {                sortrows(table, n);            };        }(i)); //将i的值赋给局部变量n    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="生成目录表"><a href="#生成目录表" class="headerlink" title="生成目录表"></a>生成目录表</h2><pre><code>/** * *这个模块注册一个可在页面加载完成后自动运行的匿名函数。当执行这个函数时会去文档中查找 *id为&quot;TOC&quot;的元素。如果这个元素不存在，就创建一个元素 * *生成的TOC目录应当具有自己的CSS样式。整个目录区域的样式className设置为&quot;TOCEntry&quot; *同样我们为不同层级的目录标题定义不同的样式。＜h1＞标签生成的标题 *className为&quot;TOCLevel1&quot;，＜h2＞标签生成的标题className为&quot;TOCLevel2&quot;，以此类推 *段编号的样式为&quot;TOCSectNum&quot; * *完整的CSS样式代码如下: * *#TOC{border:solid black 1px;margin:10px;padding:10px;} *.TOCEntry{font-family:sans-serif;} *.TOCEntry a{text-decoration:none;} *.TOCLevel1{font-size:16pt;font-weight:bold;} *.TOCLevel2{font-size:12pt;margin-left:.5in;} *.TOCSectNum:after{content:&quot;:&quot;;} * *这段代码的最后一行表示每个段编号之后都有一个冒号和空格符。要想隐藏段编号， *请使用这行代码： *.TOCSectNum{display:none} * **/(function () { //匿名函数定义了一个局部作用域    //查找TOC容器元素    //如果不存在，则在文档开头处创建一个    var toc = document.getElementById(&quot;TOC&quot;);    if (!toc) {        toc = document.createElement(&quot;div&quot;);        toc.id = &quot;TOC&quot;;        document.body.insertBefore(toc, document.body.firstChild);    }    //查找所有的标题元素    var headings;    if (document.querySelectorAll) //我们是否能用这个简单的方法？        headings = document.querySelectorAll(&quot;h1,h2,h3,h4,h5,h6&quot;);    else //否则，查找方法稍微麻烦一些        headings = findHeadings(document.body, []); //递归遍历document的body，查找标题元素    function findHeadings(root, sects) {        for (var c = root.firstChild; c != null; c = c.nextSibling) {            if (c.nodeType !== 1) continue;            if (c.tagName.length == 2 &amp;&amp; c.tagName.charAt(0) == &quot;H&quot;)                sects.push(c);            else                findHeadings(c, sects);        }        return sects;    }    //初始化一个数组来保持跟踪章节号    var sectionNumbers = [0, 0, 0, 0, 0, 0]; //现在，循环已找到的标题元素    for (var h = 0; h &lt; headings.length; h++) {        var heading = headings[h]; //跳过在TOC容器中的标题元素        if (heading.parentNode == toc) continue; //判定标题的级别        var level = parseInt(heading.tagName.charAt(1));        if (isNaN(level) || level &lt; 1 || level &gt; 6) continue; //对于该标题级别增加sectionNumbers对应的数字        //重置所有标题比它级别低的数字为零        sectionNumbers[level - 1]++;        for (var i = level; i &lt; 6; i++) sectionNumbers[i] = 0; //现在，将所有标题级别的章节号组合产生一个章节号， 如2 .3 .1        var sectionNumber = sectionNumbers.slice(0, level).join(&quot;.&quot;) //为标题级别增加章节号        //把数字放在＜span＞中，使得其可以用样式修饰        var span = document.createElement(&quot;span&quot;);        span.className = &quot;TOCSectNum&quot;;        span.innerHTML = sectionNumber;        heading.insertBefore(span, heading.firstChild); //用命名的锚点将标题包起来，以便为它增加链接        var anchor = document.createElement(&quot;a&quot;);        anchor.name = &quot;TOC&quot; + sectionNumber;        heading.parentNode.insertBefore(anchor, heading);        anchor.appendChild(heading); //现在为该节创建一个链接        var link = document.createElement(&quot;a&quot;);        link.href = &quot;#TOC&quot; + sectionNumber; //链接的目标地址        link.innerHTML = heading.innerHTML; //链接文本与实际标题一致        //将链接放在一个div中，div用基于级别名字的样式修饰        var entry = document.createElement(&quot;div&quot;);        entry.className = &quot;TOCEntry TOCLevel&quot; + level;        entry.appendChild(link); //该div添加到TOC容器中        toc.appendChild(entry);    }}());</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="从URL解析参数"><a href="#从URL解析参数" class="headerlink" title="从URL解析参数"></a>从URL解析参数</h2><pre><code>/* *这个函数用来解析来自URL的查询串中的name=value参数对 *它将name=value对存储在一个对象的属性中，并返回该对象 *这样来使用它 * *var args=urlArgs();//从URL中解析参数 *var q=args.q||&quot;&quot;;//如果参数定义了的话就使用参数；否则使用一个默认值 *var n=args.n?parseInt(args.n):10; */function urlArgs() {    var args = {}; //定义一个空对象    var query = location.search.substring(1); //查找到查询串，并去掉&apos;?&apos;    var pairs = query.split(&quot;&amp;&quot;); //根据&quot;&amp;&quot;符号将查询字符串分隔开    for (var i = 0; i &lt; pairs.length; i++) { //对于每个片段        var pos = pairs[i].indexOf(&apos;=&apos;); //查找&quot;name=value&quot;        if (pos == -1) continue; //如果没有找到的话，就跳过        var name = pairs[i].substring(0, pos); //提取name        var value = pairs[i].substring(pos + 1); //提取value        value = decodeURIComponent(value); //对value进行解码        args[name] = value; //存储为属性    }    return args; //返回解析后的参数}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="获取纯文本的元素内容"><a href="#获取纯文本的元素内容" class="headerlink" title="获取纯文本的元素内容"></a>获取纯文本的元素内容</h2><pre><code>/** *一个参数，返回元素的textContent或innerText *两个参数，用value参数的值设置元素的textContent或innerText */function textContent(element, value) {    var content = element.textContent; //检测textContent是否有定义    if (value === undefined) { //没传递value，因此返回当前文本        if (content !== undefined) {            return content;        } else {            return element.innerText;        }    } else { //传递了value，因此设置文本        if (content !== undefined) {            element.textContent = value;        } else {            element.innerText = value;        }    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="手写一个JSONP实现"><a href="#手写一个JSONP实现" class="headerlink" title="手写一个JSONP实现"></a>手写一个JSONP实现</h2><pre><code>//根据指定的URL发送一个JSONP请求//然后把解析得到的响应数据传递给回调函数//在URL中添加一个名为jsonp的查询参数，用于指定该请求的回调函数的名称function getJSONP(url, callback) { //为本次请求创建一个唯一的回调函数名称    var cbnum = &quot;cb&quot; + getJSONP.counter++; //每次自增计数器    var cbname = &quot;getJSONP.&quot; + cbnum; //作为JSONP函数的属性    //将回调函数名称以表单编码的形式添加到URL的查询部分中    //使用jsonp作为参数名，一些支持JSONP的服务    //可能使用其他的参数名，比如callback    if (url.indexOf(&quot;?&quot;) === -1) //URL没有查询部分        url += &quot;?jsonp=&quot; + cbname; //作为查询部分添加参数    else //否则        url += &quot;＆jsonp=&quot; + cbname; //作为新的参数添加它    //创建script元素用于发送请求    var script = document.createElement(&quot;script&quot;); //定义将被脚本执行的回调函数    getJSONP[cbnum] = function (response) {        try {            callback(response); //处理响应数据        } finally { //即使回调函数或响应抛出错误            delete getJSONP[cbnum]; //删除该函数            script.parentNode.removeChild(script); //移除script元素        }    }; //立即触发HTTP请求    script.src = url; //设置脚本的URL    document.body.appendChild(script); //把它添加到文档中}getJSONP.counter = 0; //用于创建唯一回调函数名称的计数器</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><pre><code>//将child节点插入到parent中，使其成为第n个子节点function insertAt(parent, child, n) {    if (n &lt; 0 || n &gt; parent.childNodes.length) {        throw new Error(&quot;invalid index&quot;);    } else if (n == parent.childNodes.length) {        parent.appendChild(child);    } else {        parent.insertBefore(child, parent.childNodes[n]);    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="使用innerHTML实现outerHTML属性"><a href="#使用innerHTML实现outerHTML属性" class="headerlink" title="使用innerHTML实现outerHTML属性"></a>使用innerHTML实现outerHTML属性</h2><pre><code>//为那些不支持它的浏览器实现outerHTML属性//假设浏览器确实支持innerHTML，并有个可扩展的Element.prototype，//并且可以定义getter和setter(function () { //如果outerHTML存在，则直接返回    if (document.createElement(&quot;div&quot;).outerHTML) return; //返回this所引用元素的外部HTML    function outerHTMLGetter() {        var container = document.createElement(&quot;div&quot;); //虚拟元素        container.appendChild(this.cloneNode(true)); //复制到该虚拟节点        return container.innerHTML; //返回虚拟节点的innerHTML    }    //用指定的值设置元素的外部HTML    function outerHTMLSetter(value) { //创建一个虚拟元素，设置其内容为指定的值        var container = document.createElement(&quot;div&quot;);        container.innerHTML = value; //将虚拟元素中的节点全部移动到文档中        while (container.firstChild) //循环，直到container没有子节点为止            this.parentNode.insertBefore(container.firstChild, this); //删除所被取代的节点        this.parentNode.removeChild(this);    }    //现在使用这两个函数作为所有Element对象的outerHTML属性的getter和setter    //如果它存在则使用ES5的Object.defineProperty()方法，    //否则，退而求其次，使用__defineGetter__()和__defineSetter__()    if (Object.defineProperty) {        Object.defineProperty(Element.prototype, &quot;outerHTML&quot;, {            get: outerHTMLGetter,            set: outerHTMLSetter,            enumerable: false,            configurable: true        });    } else {        Element.prototype.__defineGetter__(&quot;outerHTML&quot;, outerHTMLGetter);        Element.prototype.__defineSetter__(&quot;outerHTML&quot;, outerHTMLSetter);    }}());</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="倒序排列子节点"><a href="#倒序排列子节点" class="headerlink" title="倒序排列子节点"></a>倒序排列子节点</h2><pre><code>//倒序排列节点n的子节点function reverse(n) { //创建一个DocumentFragment作为临时容器    var f = document.createDocumentFragment(); //从后至前循环子节点，将每一个子节点移动到文档片段中    //n的最后一个节点变成f的第一个节点，反之亦然    //注意，给f添加一个节点，该节点自动地会从n中删除    while (n.lastChild) f.appendChild(n.lastChild); //最后，把f的所有子节点一次性全部移回n中    n.appendChild(f);}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="查询窗口滚动条的位置"><a href="#查询窗口滚动条的位置" class="headerlink" title="查询窗口滚动条的位置"></a>查询窗口滚动条的位置</h2><pre><code>//以一个对象的x和y属性的方式返回滚动条的偏移量function getScrollOffsets(w) { //使用指定的窗口，如果不带参数则使用当前窗口    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用    if (w.pageXOffset != null) return {        x: w.pageXOffset,        y: w.pageYOffset    }; //对标准模式下的IE（或任何浏览器）    var d = w.document;    if (document.compatMode == &quot;CSS1Compat&quot;)        return {            x: d.documentElement.scrollLeft,            y: d.documentElement.scrollTop        }; //对怪异模式下的浏览器    return {        x: d.body.scrollLeft,        y: d.body.scrollTop    };}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="查询窗口的视口尺寸"><a href="#查询窗口的视口尺寸" class="headerlink" title="查询窗口的视口尺寸"></a>查询窗口的视口尺寸</h2><pre><code>//作为一个对象的w和h属性返回视口的尺寸function getViewportSize(w) { //使用指定的窗口，如果不带参数则使用当前窗口    w = w || window; //除了IE 8及更早的版本以外，其他浏览器都能用    if (w.innerWidth != null) return {        w: w.innerWidth,        h: w.innerHeight    }; //对标准模式下的IE（或任何浏览器）    var d = w.document;    if (document.compatMode == &quot;CSS1Compat&quot;)        return {            w: d.documentElement.clientWidth,            h: d.documentElement.clientHeight        }; //对怪异模式下的浏览器    return {        w: d.body.clientWidth,        h: d.body.clientWidth    };}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="返回函数的名字"><a href="#返回函数的名字" class="headerlink" title="返回函数的名字"></a>返回函数的名字</h2><pre><code>Function.prototype.getName = function () {    return this.name || this.toString().match(/function\s*(\w*)\s*\(/)[1];}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="原生JS实现CSS动画1"><a href="#原生JS实现CSS动画1" class="headerlink" title="原生JS实现CSS动画1"></a>原生JS实现CSS动画1</h2><pre><code>//将e转化为相对定位的元素，使之左右&quot;震动&quot;//第一个参数可以是元素对象或者元素的id//如果第二个参数是函数，以e为参数，它将在动画结束时调用//第三个参数指定e震动的距离，默认是5像素//第四个参数指定震动多久，默认是500毫秒function shake(e, oncomplete, distance, time) { //句柄参数    if (typeof e === &quot;string&quot;) e = document.getElementById(e);    if (!time) time = 500;    if (!distance) distance = 5;    var originalStyle = e.style.cssText; //保存e的原始style    e.style.position = &quot;relative&quot;; //使e相对定位    var start = (new Date()).getTime(); //注意，动画的开始时间    animate(); //动画开始    //函数检查消耗的时间，并更新e的位置    //如果动画完成，它将e还原为原始状态    //否则，它更新e的位置，安排它自身重新运行    function animate() {        var now = (new Date()).getTime(); //得到当前时间        var elapsed = now - start; //从开始以来消耗了多长时间？        var fraction = elapsed / time; //是总时间的几分之几？        if (fraction &lt; 1) { //如果动画未完成            //作为动画完成比例的函数，计算e的x位置            //使用正弦函数将完成比例乘以4pi            //所以，它来回往复两次            var x = distance * Math.sin(fraction * 4 * Math.PI);            e.style.left = x + &quot;px&quot;; //在25毫秒后或在总时间的最后尝试再次运行函数            //目的是为了产生每秒40帧的动画            setTimeout(animate, Math.min(25, time - elapsed));        } else { //否则，动画完成            e.style.cssText = originalStyle //恢复原始样式            if (oncomplete) oncomplete(e); //调用完成后的回调函数        }    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="原生JS实现CSS动画2"><a href="#原生JS实现CSS动画2" class="headerlink" title="原生JS实现CSS动画2"></a>原生JS实现CSS动画2</h2><pre><code>function fadeOut(e, oncomplete, time) {    if (typeof e === &quot;string&quot;) e = document.getElementById(e);    if (!time) time = 500; //使用Math.sqrt作为一个简单的“缓动函数”来创建动画    //精巧的非线性：一开始淡出得比较快，然后缓慢了一些    var ease = Math.sqrt;    var start = (new Date()).getTime(); //注意：动画开始的时间    animate(); //动画开始    function animate() {        var elapsed = (new Date()).getTime() - start; //消耗的时间        var fraction = elapsed / time; //总时间的几分之几？        if (fraction &lt; 1) { //如果动画未完成            var opacity = 1 - ease(fraction); //计算元素的不透明度            e.style.opacity = String(opacity); //设置在e上            setTimeout(animate, //调度下一帧                Math.min(25, time - elapsed));        } else { //否则，动画完成            e.style.opacity = &quot;0&quot;; //使e完全透明            if (oncomplete) oncomplete(e); //调用完成后的回调函数        }    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="仿HTML5的classList属性"><a href="#仿HTML5的classList属性" class="headerlink" title="仿HTML5的classList属性"></a>仿HTML5的classList属性</h2><pre><code>/* *如果e有classList属性则返回它。否则，返回一个为e模拟DOMTokenList API的对象 *返回的对象有contains()、add()、remove()、toggle()和toString()等方法 *来检测和修改元素e的类集合。如果classList属性是原生支持的， *返回的类数组对象有length和数组索引属性。模拟DOMTokenList不是类数组对象， *但是它有一个toArray()方法来返回一个含元素类名的纯数组快照 */function classList(e) {    if (e.classList) return e.classList; //如果e.classList存在，则返回它    else return new CSSClassList(e); //否则，就伪造一个}//CSSClassList是一个模拟DOMTokenList的JavaScript类function CSSClassList(e) {    this.e = e;} //如果e.className包含类名c则返回true否则返回falseCSSClassList.prototype.contains = function (c) { //检查c是否是合法的类名    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //首先是常规检查    var classes = this.e.className;    if (!classes) return false; //e不含类名    if (classes === c) return true; //e有一个完全匹配的类名    //否则，把c自身看做一个单词，利用正则表达式搜索c    //\b在正则表达式里代表单词的边界    return classes.search(&quot;\\b&quot; + c + &quot;\\b&quot;) != -1;}; //如果c不存在，将c添加到e.className中CSSClassList.prototype.add = function (c) {    if (this.contains(c)) return; //如果存在，什么都不做    var classes = this.e.className;    if (classes &amp;&amp; classes[classes.length - 1] != &quot;&quot;)        c = &quot;&quot; + c; //如果需要加一个空格    this.e.className += c; //将c添加到className中}; //将在e.className中出现的所有c都删除CSSClassList.prototype.remove = function (c) { //检查c是否是合法的类名    if (c.length === 0 || c.indexOf(&quot; &quot;) != -1)        throw new Error(&quot;Invalid class name:&apos;&quot; + c + &quot;&apos;&quot;); //将所有作为单词的c和多余的尾随空格全部删除    var pattern = new RegExp(&quot;\\b&quot; + c + &quot;\\b\\s*&quot;, &quot;g&quot;);    this.e.className = this.e.className.replace(pattern, &quot;&quot;);}; //如果c不存在，将c添加到e.className中，并返回true//否则，将在e.className中出现的所有c都删除，并返回falseCSSClassList.prototype.toggle = function (c) {    if (this.contains(c)) { //如果e.className包含c        this.remove(c); //删除它        return false;    } else { //否则        this.add(c); //添加它        return true;    }}; //返回e.className本身CSSClassList.prototype.toString = function () {    return this.e.className;}; //返回在e.className中的类名CSSClassList.prototype.toArray = function () {    return this.e.className.match(/\b\w+\b/g) || [];};</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="查询纯文本形式的内容"><a href="#查询纯文本形式的内容" class="headerlink" title="查询纯文本形式的内容"></a>查询纯文本形式的内容</h2><pre><code>/** *一个参数，返回元素的textContent或innerText *两个参数，用value参数的值设置元素的textContent或innerText */function textContent(element, value) {    var content = element.textContent; //检测textContent是否有定义    if (value === undefined) { //没传递value，因此返回当前文本        if (content !== undefined) return content;        else return element.innerText;    } else { //传递了value，因此设置文本        if (content !== undefined) element.textContent = value;        else element.innerText = value;    }}</code></pre><p>textContent属性在除了IE的所有当前的浏览器中都支持。在IE中，可以用Element的innerText属性来代替。 <a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="查找元素的后代中节点中的所有Text节点"><a href="#查找元素的后代中节点中的所有Text节点" class="headerlink" title="查找元素的后代中节点中的所有Text节点"></a>查找元素的后代中节点中的所有Text节点</h2><pre><code>//返回元素e的纯文本内容，递归进入其子元素//该方法的效果类似于textContent属性function textContent(e) {    var child, type, s = &quot;&quot;; //s保存所有子节点的文本    for (child = e.firstChild; child != null; child = child.nextSibling) {        type = child.nodeType;        if (type === 3 || type === 4) //Text和CDATASection节点            s += child.nodeValue;        else if (type === 1) //递归Element节点            s += textContent(child);    }    return s;}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="使用innerHTML实现insertAdjacentHTML"><a href="#使用innerHTML实现insertAdjacentHTML" class="headerlink" title="使用innerHTML实现insertAdjacentHTML()"></a>使用innerHTML实现insertAdjacentHTML()</h2><pre><code>//本模块为不支持它的浏览器定义了Element.insertAdjacentHTML//还定义了一些可移植的HTML插入函数，它们的名字比insertAdjacentHTML更符合逻辑：//Insert.before()、Insert.after()、Insert.atStart()和Insert.atEnd()var Insert = (function () { //如果元素有原生的insertAdjacentHTML，    //在4个函数名更明了的HTML插入函数中使用它    if (document.createElement(&quot;div&quot;).insertAdjacentHTML) {        return {            before: function (e, h) {                e.insertAdjacentHTML(&quot;beforebegin&quot;, h);            },            after: function (e, h) {                e.insertAdjacentHTML(&quot;afterend&quot;, h);            },            atStart: function (e, h) {                e.insertAdjacentHTML(&quot;afterbegin&quot;, h);            },            atEnd: function (e, h) {                e.insertAdjacentHTML(&quot;beforeend&quot;, h);            }        };    }    //否则，无原生的insertAdjacentHTML    //实现同样的4个插入函数，并使用它们来定义insertAdjacentHTML    //首先，定义一个工具函数，传入HTML字符串，返回一个DocumentFragment，    //它包含了解析后的HTML的表示    function fragment(html) {        var elt = document.createElement(&quot;div&quot;); //创建空元素        var frag = document.createDocumentFragment(); //创建空文档片段        elt.innerHTML = html; //设置元素内容        while (elt.firstChild) //移动所有的节点            frag.appendChild(elt.firstChild); //从elt到frag        return frag; //然后返回frag    }    var Insert = {        before: function (elt, html) {            elt.parentNode.insertBefore(fragment(html), elt);        },        after: function (elt, html) {            elt.parentNode.insertBefore(fragment(html), elt.nextSibling);        },        atStart: function (elt, html) {            elt.insertBefore(fragment(html), elt.firstChild);        },        atEnd: function (elt, html) {            elt.appendChild(fragment(html));        }    }; //基于以上函数实现insertAdjacentHTML    Element.prototype.insertAdjacentHTML = function (pos, html) {        switch (pos.toLowerCase()) {            case &quot;beforebegin&quot;:                return Insert.before(this, html);            case &quot;afterend&quot;:                return Insert.after(this, html);            case &quot;afterbegin&quot;:                return Insert.atStart(this, html);            case &quot;beforeend&quot;:                return Insert.atEnd(this, html);        }    };    return Insert; //最后返回4个插入函数}());</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><pre><code>/** *Drag.js：拖动绝对定位的HTML元素 * *这个模块定义了一个drag()函数，它用于mousedown事件处理程序的调用 *随后的mousemove事件将移动指定元素，mouseup事件将终止拖动 *这些实现能同标准和IE两种事件模型一起工作 * *参数： * *elementToDrag：接收mousedown事件的元素或某些包含元素 *它必须是定位的元素,元素的样式必须是行内样式 *它的style.left和style.top值将随着用户的拖动而改变 * *event：mousedown事件对象 **/function drag(elementToDrag, event) { //初始鼠标位置，转换为文档坐标    var startX = event.clientX;    var startY = event.clientY; //在文档坐标下，待拖动元素的初始位置    //因为elementToDrag是绝对定位的，    //所以我们可以假设它的offsetParent就是文档的body元素    var origX = parseFloat(elementToDrag.style.left);    var origY = parseFloat(elementToDrag.style.top); //计算mousedown事件和元素左上角之间的距离    //我们将它另存为鼠标移动的距离    if (document.addEventListener) { //标准事件模型        //在document对象上注册捕获事件处理程序        document.addEventListener(&quot;mousemove&quot;, moveHandler, true);        document.addEventListener(&quot;mouseup&quot;, upHandler, true);    } else if (document.attachEvent) { //用于IE5～8的IE事件模型        //在IE事件模型中，        //捕获事件是通过调用元素上的setCapture()捕获它们        elementToDrag.setCapture();        elementToDrag.attachEvent(&quot;onmousemove&quot;, moveHandler);        elementToDrag.attachEvent(&quot;onmouseup&quot;, upHandler); //作为mouseup事件看待鼠标捕获的丢失        elementToDrag.attachEvent(&quot;onlosecapture&quot;, upHandler);    }    //我们处理了这个事件，不让任何其他元素看到它    if (event.stopPropagation) event.stopPropagation(); //标准模型    else event.cancelBubble = true; //IE    //现在阻止任何默认操作    if (event.preventDefault) event.preventDefault(); //标准模型    else event.returnValue = false; //IE    /**     * 当元素正在被拖动时， 这就是捕获mousemove事件的处理程序     *它用于移动这个元素      **/    function moveHandler(e) {        if (!e) e = window.event; //IE事件模型        //移动这个元素到当前鼠标位置，        //通过滚动条的位置和初始单击的偏移量来调整        var targetLeft = e.clientX - startX + origX;        var targetTop = e.clientY - startY + origY;        var minLeft = 0;        var minTop = 0;        var maxLeft = (document.documentElement.clientWidth || document.body.clientWidth) - elementToDrag.offsetWidth;        var maxTop = (document.documentElement.clientHeight || document.body.clientHeight) - elementToDrag.offsetHeight;        targetLeft = targetLeft &gt; maxLeft ? maxLeft : (targetLeft &lt; minLeft ? minLeft : targetLeft);        targetTop = targetTop &gt; maxTop ? maxTop : (targetTop &lt; minTop ? minTop : targetTop);        elementToDrag.style.left = targetLeft + &quot;px&quot;;        elementToDrag.style.top = targetTop + &quot;px&quot;;        if (e.stopPropagation) e.stopPropagation(); //标准        else e.cancelBubble = true; //IE    }    /**     *这是捕获在拖动结束时发生的最终mouseup事件的处理程序     **/    function upHandler(e) {        if (!e) e = window.event; //IE事件模型        //注销捕获事件处理程序        if (document.removeEventListener) { //DOM事件模型            document.removeEventListener(&quot;mouseup&quot;, upHandler, true);            document.removeEventListener(&quot;mousemove&quot;, moveHandler, true);        } else if (document.detachEvent) { //IE 5+事件模型            elementToDrag.detachEvent(&quot;onlosecapture&quot;, upHandler);            elementToDrag.detachEvent(&quot;onmouseup&quot;, upHandler);            elementToDrag.detachEvent(&quot;onmousemove&quot;, moveHandler);            elementToDrag.releaseCapture();        }        //并且不让事件进一步传播        if (e.stopPropagation) e.stopPropagation(); //标准模型        else e.cancelBubble = true; //IE    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="在谷歌地图上显示地理位置信息"><a href="#在谷歌地图上显示地理位置信息" class="headerlink" title="在谷歌地图上显示地理位置信息"></a>在谷歌地图上显示地理位置信息</h2><pre><code>//获取当前位置然后通过Google地图显示//如果当前浏览器不支持地理位置API，则抛出一个错误function getmap() { //检查是否支持地理位置API    if (!navigator.geolocation) throw &quot;Geolocation not supported&quot;; //开始请求地理位置信息，    navigator.geolocation.getCurrentPosition(setMapURL);    function setMapURL(pos) { //从参数对象（pos）中获取位置信息        var latitude = pos.coords.latitude; //经度        var longitude = pos.coords.longitude; //纬度        var accuracy = pos.coords.accuracy; //米        var scale = 10; //比例        //构造一个URL，用于跳转到Google地图        var url = &quot;https://www.google.com/maps/@&quot; + latitude + &quot;,&quot; + longitude + &quot;,&quot; + scale + &quot;z&quot;; //设置一个大致的缩放级别        location = url;    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="使用所有地理位置特性"><a href="#使用所有地理位置特性" class="headerlink" title="使用所有地理位置特性"></a>使用所有地理位置特性</h2><pre><code>//异步的获取我的位置，并在指定的元素中展示出来function whereami(elt) { //将此对象作为第三个参数传递给getCurrentPosition()方法    var options = { //设置为true，表示如果可以的话        //获取高精度的位置信息（例如，通过GPS获取）        //但是，要注意的是，这会影响电池寿命        enableHighAccuracy: false, //可以近似：这是默认值        //如果获取缓存过的位置信息就足够的话，可以设置此属性        //默认值为0,表示强制检查新的位置信息        maximumAge: 300000, //5分钟左后        //愿意等待多长时间来获取位置信息？        //默认值为无限长 [2] ，getCurrentPosition()方法永不超时        timeout: 15000 //不要超过15秒    };    if (navigator.geolocation) //如果支持的话，就获取位置信息        navigator.geolocation.getCurrentPosition(success, error, options);    else        elt.innerHTMl = &quot;Geolocation not supported in this browser&quot;; //当获取位置信息失败的时候，会调用此函数    function error(e) { //error对象包含一些数字编码和文本消息，如下所示：        //1:用户不允许分享他/她的位置信息        //2:浏览器无法确定位置        //3:发生超时        elt.innerHTML = &quot;Geolocation error&quot; + e.code + &quot;:&quot; + e.message;    }    //当获取位置信息成功的时候，会调用此函数    function success(pos) { //总是可以获取如下这些字段        //但是要注意的是时间戳信息在outer对象中，而不在inner、coords对象中        var msg = &quot;时间是&quot; +            new Date(pos.timestamp).toLocaleString() + &quot;地理位置是&quot; +            pos.coords.accuracy + &quot;米范围内经度是&quot; +            pos.coords.latitude + &quot;纬度是&quot; +            pos.coords.longitude + &quot;.&quot;; //如果设备还返回了海拔信息，则将其添加进去        if (pos.coords.altitude) {            msg += &quot;海拔是&quot; + pos.coords.altitude + &quot;±&quot; +                pos.coords.altitudeAccuracy + &quot;千米.&quot;;        }        //如果设备还返回了速度和航向信息，也将它们添加进去        if (pos.coords.speed) {            msg += &quot;速度是&quot; +                pos.coords.speed + &quot;m/s方向是&quot; +                pos.coords.heading + &quot;.&quot;;        }        elt.innerHTML = msg; //显示所有的位置信息    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="优雅的图片翻转实现"><a href="#优雅的图片翻转实现" class="headerlink" title="优雅的图片翻转实现"></a>优雅的图片翻转实现</h2><pre><code>/** *优雅的图片翻转实现方式 * *要创建图片翻转效果，将此模块引入到HTML文件中 *然后在任意＜img＞元素上使用data-rollover属性来指定翻转图片的URL即可 *如下所示: * *&lt;img src=&quot;normal_image.png &quot;data-rollover=&quot;rollover_image.png&quot;&gt; * */function changeImage() { //所有处理逻辑都在一个匿名函数中:不定义任何符号    //遍历所有的图片，查找data-rollover属性    for (var i = 0; i &lt; document.images.length; i++) {        var img = document.images[i];        var rollover = img.getAttribute(&quot;data-rollover&quot;);        if (!rollover) continue; //跳过没有data-rollover属性的图片        //确保将翻转的图片缓存起来        (new Image()).src = rollover; //定义一个属性来标识默认的图片URL        img.setAttribute(&quot;data-rollout&quot;, img.src); //注册事件处理函数来创建翻转效果        img.onmouseover = function () {            this.src = this.getAttribute(&quot;data-rollover&quot;);        };        img.onmouseout = function () {            this.src = this.getAttribute(&quot;data-rollout&quot;);        };    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="使用canvas绘制多边形"><a href="#使用canvas绘制多边形" class="headerlink" title="使用canvas绘制多边形"></a>使用canvas绘制多边形</h2><pre><code>//定义一个以(x,y)为中心，半径为r的规则n边形,c可以通过调用画布getContext()方法得到//每个顶点都是均匀分布在圆周上//将第一个顶点放置在最上面，或者指定一定角度//除非最后一个参数是true，否则顺时针旋转function polygon(c, n, x, y, r, angle, counterclockwise) {    angle = angle || 0;    counterclockwise = counterclockwise || false;    c.moveTo(x + r * Math.sin(angle), //从第一个顶点开始一条新的子路径        y - r * Math.cos(angle)); //使用三角法计算位置    var delta = 2 * Math.PI / n; //两个顶点之间的夹角    for (var i = 1; i &lt; n; i++) { //循环剩余的每个顶点        angle += counterclockwise ? -delta : delta; //调整角度        c.lineTo(x + r * Math.sin(angle), //以下个顶点为端点添加线段            y - r * Math.cos(angle));    }    c.closePath(); //将最后一个顶点和起点连接起来}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="使用canvas绘制雪花"><a href="#使用canvas绘制雪花" class="headerlink" title="使用canvas绘制雪花"></a>使用canvas绘制雪花</h2><pre><code>var deg = Math.PI / 180; //用于角度制到弧度制的转换//在画布的上下文c中，以左下角的点(x,y)和边长len，绘制一个n级别的科赫雪花分形function snowflake(c, n, x, y, len) {    c.save(); //保存当前变换    c.translate(x, y); //变换原点为起始点    c.moveTo(0, 0); //从新的原点开始一条新的子路径    leg(n); //绘制雪花的第一条边    c.rotate(-120 * deg); //现在沿着逆时针方向旋转120 o    leg(n); //绘制第二条边    c.rotate(-120 * deg); //再次旋转    leg(n); //画最后一条边    c.closePath(); //闭合子路径    c.restore(); //恢复初始的变换    //绘制n级别的科赫雪花的一条边    //此函数在画完一条边的时候就离开当前点，    //然后通过坐标系变换将当前点又转换成(0,0,)    //这意味着画完一条边之后可以很简单地调用rotate()进行旋转    function leg(n) {        c.save(); //保存当前坐标系变换        if (n == 0) { //不需要递归的情况下:            c.lineTo(len, 0); //就绘制一条水平线段        } else { //递归情况下：绘制4条子边，类似这个样子： - \/ -            c.scale(1 / 3, 1 / 3); //子边长度为原边长的1/3            leg(n - 1); //递归第一条子边            c.rotate(60 * deg); //顺时针旋转60 o            leg(n - 1); //第二条子边            c.rotate(-120 * deg); //逆时针旋转120 o            leg(n - 1); //第三条子边            c.rotate(60 * deg); //通过旋转回到初始状态            leg(n - 1); //最后一条边        }        c.restore(); //恢复坐标系变换        c.translate(len, 0); //但是通过转换使得边的结束点为(0,0)    }}</code></pre><p><a href="https://link.zhihu.com/?target=https%3A//github.com/wuxianqiang/libraries%23readme" target="_blank" rel="noopener">⬆ back to top</a></p><h2 id="在Web-Worker中发起同步XMLHtttpRequest"><a href="#在Web-Worker中发起同步XMLHtttpRequest" class="headerlink" title="在Web Worker中发起同步XMLHtttpRequest"></a>在Web Worker中发起同步XMLHtttpRequest</h2><pre><code>//此文件会通过一个新的Worker()来载入，因此，它是运行在独立的线程中的，//可以放心地使用同步XMLHttpRequest API//消息是URL数组的形式。以字符串形式同步获取每个URL指定的内容，//并将这些字符串数组传递回去。onmessage = function (e) {    var urls = e.data; //输入：要获取的URL    var contents = []; //输出：URL指定的内容    for (var i = 0; i &lt; urls.length; i++) {        var url = urls[i]; //每个URL        var xhr = new XMLHttpRequest(); //开始一个HTTP请求        xhr.open(&quot;GET&quot;, url, false); //false则表示进行同步请求        xhr.send(); //阻塞住，一直到响应完成        if (xhr.status !== 200) //如果请求失败则抛出错误            throw Error(xhr.status + &quot; &quot; + xhr.statusText + &quot;: &quot; + url);        contents.push(xhr.responseText); //否则，存储通过URL获取得到的内容    }    //最后，将这些URL内容以数组的形式传递回主线程    postMessage(contents);}</code></pre><p>善于利用JS中的小技巧，不仅可以使代码更加简洁，而且逼格更高。</p><h2 id="使用-模拟Boolean-函数"><a href="#使用-模拟Boolean-函数" class="headerlink" title="使用!!模拟Boolean()函数"></a>使用!!模拟Boolean()函数</h2><p>原理：逻辑非操作一个数据对象时，会先将数据对象转换为布尔值，然后取反，两个!!重复取反，就实现了转换为布尔值的效果。</p><h2 id="使用一元加-模拟Number-函数"><a href="#使用一元加-模拟Number-函数" class="headerlink" title="使用一元加(+)模拟Number()函数"></a>使用一元加(+)模拟Number()函数</h2><p>原理：对非数值类型的数据使用一元加(+)，会起到与Number()函数相同的效果。</p><p>null转换为0</p><p>undefined转换为NaN</p><p>false转换为0，true转换为1</p><p>对于字符串： </p><p>空字串转换为0</p><p>含有数字或者浮点数或者十六进制格式的数据(11, 0.3, 0xfe等)，转换为相应的数值</p><p>含有其他格式字符，无法转换为数值的字符串，转换为NaN</p><p>对于对象，先调用valueOf()方法，在转换，若结果为NaN，那么再调用toString()方法，之后再转换</p><h2 id="使用逻辑与-amp-amp-进行短路操作"><a href="#使用逻辑与-amp-amp-进行短路操作" class="headerlink" title="使用逻辑与(&amp;&amp;)进行短路操作"></a>使用逻辑与(&amp;&amp;)进行短路操作</h2><pre><code>if(connected){    login();}</code></pre><p>以上代码可以简写为:</p><p><code>connected &amp;&amp; login();</code></p><p>也可用这种方法来检查对象中是否拥有某个属性</p><pre><code>user &amp;&amp; user.name</code></pre><p>原理：逻辑与(&amp;&amp;)会首先对第一个操作数进行求值，只有求值结果为true时才会对第二个操作数求值。connected &amp;&amp; login()中，若判断connected不为true,则不再进行下一步操作。<br>所谓的短路操作即第一个操作数可以决定结果，则不再对第二个操作数进行求值。</p><h2 id="使用逻辑或-设置默认值"><a href="#使用逻辑或-设置默认值" class="headerlink" title="使用逻辑或(||)设置默认值"></a>使用逻辑或(||)设置默认值</h2><p>逻辑或(||)也属于短路操作，即当第一个操作数可以决定结果时，不再对第二个操作数进行求值。利用这个特点，我们可以给赋值语句设置默认值。只有当第一个操作数为null或者undefined时，才会把第二个操作数赋值给目标。</p><pre><code>function User(name, age){    this.name = name || &quot;Liming&quot;;}</code></pre><p>上述代码中，如果函数中没有传入name参数，name的值为undefined，那么就会给this.name赋值为”Liming”。<br>ES6中可以为函数设置默认值，所以这种方法可能要成为过去式，但是其他地方还是很有用的。<br>ES6 写法 简洁了许多</p><pre><code>let User = (name=&quot;Liming&quot;, age) =&gt; { }</code></pre><h2 id="获取数组最后n个元素"><a href="#获取数组最后n个元素" class="headerlink" title="获取数组最后n个元素"></a>获取数组最后n个元素</h2><p>可以使用以下代码获取数组中最后n个元素</p><pre><code>var array = [1, 2, 3, 4, 5, 6];console.log(array.slice(-1));  //[6]console.log(array.slice(-2));  //[5, 6]</code></pre><p>原理:Array.prototype.slice(begin,end)可以用来裁剪数组，第二个参数的默认值是数组的长度值。若值传入一个参数，则会返回从指定索引开始到数组结尾的所有值。<br>而slice()方法还可以接收负值，当传入负值时，会自动加上数组的长度值使其转换为正值，于是便得到了最后的n个值。</p><h2 id="合并大数组"><a href="#合并大数组" class="headerlink" title="合并大数组"></a>合并大数组</h2><p>常用的合并数组的方式是使用Array.concat()函数。该函数会创建一个新数组，将两个数组连接起来存储到新数组中，这会大量消耗内存。可以使用Array.push.apply(arr1, arr2)，它不会创建新数组，而是将第二个数组合并到第一个数组中，以减少内存的消耗。</p><pre><code>var a = [1,2];var b = [3,4];console.log(a.push.apply(a, b));      // [1,2,3,4]//或者Array.prototype.push.apply(a, b);      // a变成了[1,2,3,4]console.log(a); //[1,2,3,4]</code></pre><p>原理: Array.push()是在数组的末尾增加元素，但是如果使用a.push(b)会把整个数组b当作一个元素添加到数组a中。<br>而apply()方法，则允许将某个方法的参数以数组的形式传入，所以起到了将数组b中的元素追加到数组a中的效果。</p><h2 id="NodeList转换为数组"><a href="#NodeList转换为数组" class="headerlink" title="NodeList转换为数组"></a>NodeList转换为数组</h2><p>使用document.querySelectorAll(‘div’)返回的是NodeList对象，虽然它很像数组，但是并不能使用诸如sort()，filter()等方法。你可以将其转换为真正的数组。</p><pre><code>var eles = document.querySelectorAll(&apos;p&apos;);  //NodeListvar arrayElements = [].slice.call(eles);       //转化为数组// 或者var arrayElements = Array.prototype.slice.call(eles);// 或者var arrayElements = Array.from(eles); </code></pre><p>原理:</p><p>[].slice.call(eles):<br>首先创建了一个空数组[]，然后调用他的slice()方法，但是在slice()方法的执行中，把this对象指向了eles,所以会对eles进行裁减，由于对slice()方法没有传入参数，所以相当于slice(0,eles.length),会按照元长度返回一个数组。</p><p>Array.prototype.slice.call(eles): 原理与上面相似，只不过这次没有创建空数组，而是直接使用了原型中的方法 </p>]]></content>
      
      
      
        <tags>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原生 JS 汇总</title>
      <link href="/2015/01/01/%E5%8E%9F%E7%94%9F-JS-%E6%B1%87%E6%80%BB/"/>
      <url>/2015/01/01/%E5%8E%9F%E7%94%9F-JS-%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>JS选取DOM元素的方法 注意：原生JS选取DOM元素比使用jQuery类库选取要快很多</p><pre><code>1、通过ID选取元素 document.getElementById(&apos;myid&apos;); 2、通过CLASS选取元素 document.getElementsByClassName(&apos;myclass&apos;)[0];  3、通过标签选取元素 document.getElementsByTagName(&apos;mydiv&apos;)[0]; 4、通过NAME属性选取元素（常用于表单） document.getElementsByName(&apos;myname&apos;)[0];</code></pre><p>JS修改CSS样式 </p><pre><code>document.getElementById(&apos;myid&apos;).style.display = &apos;none&apos;;</code></pre><p>class 操作：</p><pre><code>JS修改CLASS属性document.getElementById(&apos;myid&apos;).className = &apos;active&apos;;如果有多个CLASS属性，即用空格隔开document.getElementById(&apos;myid&apos;).className = &apos;active div-1&apos;;移除该元素上的所有CLASSdocument.getElementById(&apos;myid&apos;).className = &apos;&apos;;注意：使用classList会优于使用classNamedocument.getElementById(&apos;myid&apos;).classList.item(0);//item为类名的索引document.getElementById(&apos;myid&apos;).classList.length;//只读属性document.getElementById(&apos;myid&apos;).classList.add(&apos;newClass&apos;);//添加classdocument.getElementById(&apos;myid&apos;).classList.remove(&apos;newClass&apos;);//移除classdocument.getElementById(&apos;myid&apos;).classList.toggle(&apos;newClass&apos;);//切换，有则移除，没有则添加document.getElementById(&apos;myid&apos;).classList.contains(&apos;newClass&apos;);//判断是否存在该class</code></pre><p>补充：add和remove方法不允许链式操作，因为返回的都是undefined，其次，也不允许同时添加或删除多个class，可以自行扩展一下</p><pre><code>DOMTokenList.prototype.adds = function(tokens){     tokens.split(&apos; &apos;).forEach(function(token){        this.add(token);     }).bind(this));     return this;  };  var clList = document.body.classList;  clList.adds(&apos;a b c&apos;).toString();  //a b c </code></pre><p>JS修改文本 </p><pre><code>document.getElementById(&apos;myid&apos;).innerHTML = &apos;123&apos;;</code></pre><p>JS创建元素并向其中追加文本</p><pre><code>var newdiv = document.createElement(&apos;div&apos;);var newtext = document.createTextNode(&apos;123&apos;);newdiv.appendChild(newtext);document.body.appendChild(newdiv);</code></pre><p>同理：removeChild()移除节点，并返回节点</p><p>cloneNode()复制节点</p><p>insertBefore()插入节点（父节点内容的最前面）</p><p>注意：insertBefore()有两个参数，第一个是插入的节点，第二个是插入的位置</p><p>例子：</p><pre><code>var list = document.getElementById(&apos;myList&apos;);list.insertBefore(newItem,list.childNodes[1]);//插入新节点newItem到list的第二个子节点</code></pre><p>JS返回所有子节点对象childNodes</p><pre><code>var mylist = document.getElementById(&apos;myid&apos;);for(var i=0,i&lt;mylist.childNodes.length;i++){console.log(mylist.childNodes[i]);}firstChild返回第一个子节点lastChild返回最后一个子节点parentNode返回父节点对象nextSibling返回下一个兄弟节点对象previousSibling返回前一个兄弟节点对象nodeName返回节点的HTML标记名称</code></pre><p>原生JS汇总：</p><pre><code>一、节点1.1 节点属性Node.nodeName   //返回节点名称，只读Node.nodeType   //返回节点类型的常数值，只读Node.nodeValue  //返回Text或Comment节点的文本值，只读Node.textContent  //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI    //返回当前网页的绝对路径Node.ownerDocument  //返回当前节点所在的顶层文档对象，即documentNode.nextSibling  //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling  //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode   //返回当前节点的父节点Node.parentElement  //返回当前节点的父Element节点Node.childNodes   //返回当前节点的所有子节点Node.firstChild  //返回当前节点的第一个子节点Node.lastChild   //返回当前节点的最后一个子节点//parentNode接口Node.children  //返回指定节点的所有Element子节点Node.firstElementChild  //返回当前节点的第一个Element子节点Node.lastElementChild   //返回当前节点的最后一个Element子节点Node.childElementCount  //返回当前节点所有Element子节点的数目。1.2 操作Node.appendChild(node)   //向节点添加最后一个子节点Node.hasChildNodes()   //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true);  // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode)  // 在指定子节点之前插入新的子节点Node.removeChild(node)   //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild)  //替换节点Node.contains(node)  //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node)   //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe)  //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize()   //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove()  //用于删除当前节点Node.before()  //Node.after()Node.replaceWith()1.3 Document节点1.3.1 Document节点的属性document.doctype   //document.documentElement  //返回当前文档的根节点document.defaultView   //返回document对象所在的window对象document.body   //返回当前文档的&lt;body&gt;节点document.head   //返回当前文档的&lt;head&gt;节点document.activeElement  //返回当前文档中获得焦点的那个元素。//节点集合属性document.links  //返回当前文档的所有a元素document.forms  //返回页面中所有表单元素document.images  //返回页面中所有图片元素document.embeds  //返回网页中所有嵌入对象document.scripts  //返回当前文档的所有脚本document.styleSheets  //返回当前网页的所有样式表//文档信息属性document.documentURI  //表示当前文档的网址document.URL  //返回当前文档的网址document.domain  //返回当前文档的域名document.lastModified  //返回当前文档最后修改的时间戳document.location  //返回location对象，提供当前文档的URL信息document.referrer  //返回当前文档的访问来源document.title    //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState  //返回当前文档的状态document.designMode  //控制当前文档是否可编辑，可读写document.compatMode  //返回浏览器处理文档的模式document.cookie   //用来操作Cookie1.3.2 Document节点的方法（1）读写方法document.open()   //用于新建并打开一个文档document.close()   //不安比open方法所新建的文档document.write()   //用于向当前文档写入内容document.writeIn()  //用于向当前文档写入内容，尾部添加换行符。（2）查找节点document.querySelector(selectors)   //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors)  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName)  //返回所有指定HTML标签的元素document.getElementsByClassName(className)   //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）document.getElementById(id)   //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。（3）生成节点document.createElement(tagName)   //用来生成HTML元素节点。document.createTextNode(text)   //用来生成文本节点document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。document.createDocumentFragment()  //生成一个DocumentFragment对象（4）事件方法document.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture)  //注册事件document.removeEventListener(type,listener,capture)  //注销事件document.dispatchEvent(event)  //触发事件（5）其他document.hasFocus()   //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode)  //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep)   //从外部文档拷贝指定节点，插入当前文档。1.4 Element节点1.4.1 Element节点的属性（1）特性属性Element.attributes  //返回当前元素节点的所有属性节点Element.id  //返回指定元素的id属性，可读写Element.tagName  //返回指定元素的大写标签名Element.innerHTML   //返回该元素包含的HTML代码，可读写Element.outerHTML  //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className  //返回当前元素的class属性，可读写Element.classList  //返回当前元素节点的所有class集合Element.dataset   //返回元素节点中所有的data-*属性。（2）尺寸属性Element.clientHeight   //返回元素节点可见部分的高度Element.clientWidth   //返回元素节点可见部分的宽度Element.clientLeft   //返回元素节点左边框的宽度Element.clientTop   //返回元素节点顶部边框的宽度Element.scrollHeight  //返回元素节点的总高度Element.scrollWidth  //返回元素节点的总宽度Element.scrollLeft   //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop   //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight   //返回元素的垂直高度(包含border,padding)Element.offsetWidth    //返回元素的水平宽度(包含border,padding)Element.offsetLeft    //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop   //返回水平位移Element.style  //返回元素节点的行内样式（3）节点相关属性Element.children   //包括当前元素节点的所有子元素Element.childElementCount   //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild  //返回当前节点的第一个Element子节点  Element.lastElementChild   //返回当前节点的最后一个Element子节点  Element.nextElementSibling  //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling  //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent   //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。1.4.2 Element节点的方法（1）位置方法getBoundingClientRect()  // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects()   //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量  var rect = el.getBoundingClientRect()  return {     top: rect.top + document.body.scrollTop,     left: rect.left + document.body.scrollLeft  }（2）属性方法Element.getAttribute()：读取指定属性  Element.setAttribute()：设置指定属性  Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  Element.removeAttribute()：移除指定属性（3）查找方法Element.querySelector()  Element.querySelectorAll()  Element.getElementsByTagName()  Element.getElementsByClassName()（4）事件方法Element.addEventListener()：添加事件的回调函数  Element.removeEventListener()：移除事件监听函数  Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象  var event = window.event||event;    // 事件的目标节点  var target = event.target || event.srcElement;// 事件代理  ul.addEventListener(&apos;click&apos;, function(event) {     if (event.target.tagName.toLowerCase() === &apos;li&apos;) {       console.log(event.target.innerHTML)     }  });（5）其他Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入  Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入Element.remove()  //用于将当前元素节点从DOM中移除Element.focus()   //用于将当前页面的焦点，转移到指定元素上二、CSS操作（1）类名操作//ie8以下Element.className  //获取元素节点的类名Element.className += &apos; &apos; + newClassName  //新增一个类名//判断是否有某个类名function hasClass(element,className){  return new RegExp(className,&apos;gi&apos;).test(element.className);}//移除classfunction removeClass(element,className){  element.className = element.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);}//ie10 element.classList.add(className)  //新增element.classList.remove(className)  //删除element.classList.contains(className)  //是否包含element.classList.toggle(className)  //toggle class（2）style操作element.setAttribute(&apos;style&apos;,&apos;&apos;)element.style.backgroundColor = &apos;red&apos;element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value)  //设置css属性element.style.getPropertyValue(property)  //获取css属性element.style.removeProperty(property)  //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,&apos;:after&apos;)[attrName]三、对象3.1 Object对象（1）生成实例对象var o = new Object()（2）属性Object.prototype   //返回原型对象（3）方法Object.keys(o)   //遍历对象的可枚举属性Object.getOwnPropertyName(o)   //遍历对象不可枚举的属性对象实例的方法valueOf()：返回当前对象对应的值。  toString()：返回当前对象对应的字符串形式。  toLocaleString()：返回当前对象对应的本地字符串形式。  hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：判断某个属性是否可枚举。3.2 Array对象（1）生成实例对象var a = new Array()（2）属性a.length  //长度（3）Array.isArray()Array.isArray(a)   //用来判断一个值是否为数组（4）Array实例的方法[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;a.valueof()   //返回数组本身a.toString()  //返回数组的字符串形式a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop()   //用于删除数组的最后一个元素，并返回该元素join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift()  //用于删除数组的第一个元素，并返回该元素。unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。3.3 Number对象（1）生成对象var n = new Number()（2）Number对象的属性Number.POSITIVE_INFINITY：正的无限，指向Infinity。  Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。  Number.NaN：表示非数值，指向NaN。  Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。  Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。  Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。  Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。（4）Number对象实例的方法toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision()  //用于将一个数转为指定位数的有效数字。3.4 String 对象（1）生成实例对象var s = new String()（2）String对象的属性s.length   //返回字符串的长度（3）方法s.chatAt(index)   //返回指定位置的字符    //&quot;123456&quot;[0] == &quot;1&quot;s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2)  //用于连接两个字符串s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim()  //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase()  //全部转为大写s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。3.5 Math对象（1）属性Math.E：常数e。  Math.LN2：2的自然对数。  Math.LN10：10的自然对数。  Math.LOG2E：以2为底的e的对数。  Math.LOG10E：以10为底的e的对数。  Math.PI：常数Pi。  Math.SQRT1_2：0.5的平方根。  Math.SQRT2：2的平方根。（2）数学方法Math.abs()：返回参数的绝对值  Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整  Math.max(n,n1,...)：可接受多个参数，返回最大值  Math.min(n,n1,..)：可接受多个参数，返回最小值  Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。  Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入  Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。（3）三角函数方法Math.sin()：返回参数的正弦  Math.cos()：返回参数的余弦  Math.tan()：返回参数的正切  Math.asin()：返回参数的反正弦（弧度值）  Math.acos()：返回参数的反余弦（弧度值）  Math.atan()：返回参数的反正切（弧度值）3.6 JSON对象（1）方法JSON.stringify()   //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse()   //用于将JSON字符串转化成对象。3.7 console对象（1）方法console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table()  //可以将复合类型的数据转为表格显示。console.count()  //用于计数，输出它被调用了多少次。console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml()  //用于以目录树的形式，显示DOM节点。console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd()  //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace()  //显示当前执行的代码在堆栈中的调用路径。console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。正则表达式：只允许输入汉字：onkeyup=&quot;value=value.replace(/[^\u4E00-\u9FA5]/g,&apos;&apos;)&quot; 只允许输入数字：onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot;[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</code></pre><p>例子：</p><pre><code>&lt;ul class=”main”&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;        &lt;/ul&gt;请用原生JS实现：        &lt;ul class=”main”&gt;            &lt;div&gt;A&lt;/div&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;div&gt;B&lt;/div&gt;&lt;/ul&gt;&lt;body&gt;        &lt;ul id=&quot;main&quot;&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;        &lt;/ul&gt;        &lt;script type=&quot;text/javascript&quot;&gt;          var main=document.getElementById(&quot;main&quot;);          var DIV=document.createElement(&quot;div&quot;);          DIV.innerText=&quot;B&quot;;          var P=document.createElement(&quot;p&quot;);          P.innerText=&quot;A&quot;;          main.appendChild(DIV);          main.insertBefore(P, main.firstChild);        &lt;/script&gt;    &lt;/body&gt;</code></pre><p>JQuery选择器：</p><pre><code>0、常用选择器$(&apos;#div1&apos;)   //id为div1的节点，如&lt;div id=&apos;div1&apos;&gt;&lt;/div&gt; $(&apos;span&apos;)   //所有的span结点，一个包装集$(&apos;p span&apos;)   //p标签下的所有span节点，后代节点$(&apos;p&gt;span&apos;)   //p标签下的所有span子节点，子代节点$(&apos;.red&apos;)  //使用样式red的节点，如&lt;span class=&quot;red&quot;&gt;&lt;/span&gt;$(&apos;*&apos;)  //所有节点$(&quot;div,span,p.cls&quot;)  //选取所有&lt;div&gt;，&lt;span&gt;和拥有class为cls的&lt;p&gt;标签的一组元素1、基本筛选器$(&apos;span:first&apos;)    //第一个节点$(&apos;span:last&apos;)     //最后一个节点$(&quot;td:even&quot;)     //索引为偶数的节点，从 0 开始$(&quot;td:odd&quot;)      //索引为奇数的节点，从 0 开始$(&quot;td:eq(1)&quot;)    //给定索引值的节点$(&quot;td:gt(0)&quot;)    //大于给定索引值的节点$(&quot;td:lt(2)&quot;)    //小于给定索引值的节点$(&quot;:focus&quot;)      //当前获取焦点的节点$(&quot;:animated&quot;)   //正在执行动画效果的节点2、内容选择器$(&quot;div:contains(&apos;hello&apos;)&quot;)    //包含hello文本的节点$(&quot;td:empty&quot;)    //不包含子节点或者文本的空节点$(&quot;div:has(p)&quot;)  //含有选择器所匹配的节点$(&quot;td:parent&quot;)   //含有子节点或者文本的节点3、表单选择器$(&quot;input:checked&quot;)    //所有选中的节点$(&quot;select option:selected&quot;)    //select中所有选中的option节点$(&quot;:input&quot;)      //匹配所有 input, textarea, select 和 button 节点$(&quot;:text&quot;)       //所有的单行文本框$(&quot;:password&quot;)   //所有密码框$(&quot;:radio&quot;)      //所有单选按钮$(&quot;:checkbox&quot;)   //所有复选框$(&quot;:submit&quot;)     //所有提交按钮$(&quot;:reset&quot;)      //所有重置按钮$(&quot;:button&quot;)     //所有button按钮$(&quot;:file&quot;)       //所有文件域4、筛选与查找$(&quot;p&quot;).eq(0)       //当前操作中第N个jQuery对象,类似索引$(&apos;li&apos;).first()    //第一个节点$(&apos;li&apos;).last()     //最后一个节点$(this).hasClass(&quot;node&quot;)    //节点是否含有某个特定的类,返回布尔值$(&apos;li&apos;).has(&apos;ul&apos;)  //包含特定后代的节点$(&quot;div&quot;).children()      //div中的每个子节点,第一层$(&quot;div&quot;).find(&quot;span&quot;)    //查找div下的所有span节点$(&quot;p&quot;).next()       　　　//紧邻p节点后的一个同辈节点$(&quot;p&quot;).nextAll()         //p节点之后所有的同辈节点$(&quot;#node&quot;).nextUntil(&quot;#node2&quot;)    //id为&quot;#node&quot;节点之后到id为&apos;#node2&apos;之间所有的同辈节点,掐头去尾$(&quot;p&quot;).prev()            //紧邻p节点前的一个同辈节点$(&quot;p&quot;).prevAll()         //p节点之前所有的同辈节点$(&quot;#node&quot;).prevUntil(&quot;#node2&quot;)    //id为&quot;#node&quot;节点之前到id为&apos;#node2&apos;之间所有的同辈节点,掐头去尾$(&quot;p&quot;).parent()          //每个p节点的父节点$(&quot;p&quot;).parents()         //每个p节点的所有祖先节点,body,html$(&quot;#node&quot;).parentsUntil(&quot;#node2&quot;)    //id为&quot;#node&quot;节点到id为&apos;#node2&apos;之间所有的父级节点,掐头去尾$(&quot;div&quot;).siblings()      //所有的同辈节点,不包括自己5、属性操作$(&quot;img&quot;).attr(&quot;src&quot;);    　　　　　　 //返回文档中所有图像的src属性值$(&quot;img&quot;).attr(&quot;src&quot;,&quot;node.jpg&quot;);    //设置所有图像的src属性$(&quot;img&quot;).removeAttr(&quot;src&quot;);    　　　//将文档中图像的src属性删除$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, true);    //选中复选框$(&quot;input[type=&apos;checkbox&apos;]&quot;).prop(&quot;checked&quot;, false);   //不选中复选框$(&quot;img&quot;).removeProp(&quot;src&quot;);    　　 //删除img的src属性6、样式操作$(&quot;p&quot;).addClass(&quot;selected&quot;);    　　//为p节点加上 &apos;selected&apos; 类$(&quot;p&quot;).removeClass(&quot;selected&quot;);    //从p节点中删除 &apos;selected&apos; 类$(&quot;p&quot;).toggleClass(&quot;selected&quot;);    //如果存在就删除,否则就添加HTML代码/文本/值7、内容操作$(&apos;p&apos;).html();    　　　　　　　　　　 //返回p节点的html内容$(&quot;p&quot;).html(&quot;Hello &lt;b&gt;hello&lt;/b&gt;!&quot;);  //设置p节点的html内容$(&apos;p&apos;).text();    　　　　　　　　　　 //返回p节点的文本内容$(&quot;p&quot;).text(&quot;hello&quot;);    　　　　　　　//设置p节点的文本内容$(&quot;input&quot;).val();    　　　　　　　　 //获取文本框中的值$(&quot;input&quot;).val(&quot;hello&quot;);     　　　　 //设置文本框中的内容8、CSS操作$(&quot;p&quot;).css(&quot;color&quot;);          //访问查看p节点的color属性$(&quot;p&quot;).css(&quot;color&quot;,&quot;red&quot;);    //设置p节点的color属性为red$(&quot;p&quot;).css({ &quot;color&quot;: &quot;red&quot;, &quot;background&quot;: &quot;yellow&quot; });    //设置p节点的color为red，background属性为yellow（设置多个属性要用{}字典形式）9、定位与偏移$(&apos;p&apos;).offset()     //节点在当前视口的相对偏移,对象 {top: 5, left: 9}$(&apos;p&apos;).offset().top$(&apos;p&apos;).offset().left$(&quot;p&quot;).position()   //节点相对父节点的偏移,对可见节点有效，Object {top: 5, left: 8}$(window).scrollTop()    //获取滚轮滑的高度$(window).scrollLeft()   //获取滚轮滑的宽度$(window).scrollTop(&apos;25&apos;)    //设置滚轮滑的高度为2510、尺寸$(&quot;p&quot;).height();    //获取p节点的高度$(&quot;p&quot;).width();     //获取p节点的宽度$(&quot;p:first&quot;).innerHeight()    //获取第一个匹配节点内部区域高度(包括补白、不包括边框)$(&quot;p:first&quot;).innerWidth()     //获取第一个匹配节点内部区域宽度(包括补白、不包括边框)$(&quot;p:first&quot;).outerHeight()    //匹配节点外部高度(默认包括补白和边框)$(&quot;p:first&quot;).outerWidth()     //匹配节点外部宽度(默认包括补白和边框)$(&quot;p:first&quot;).outerHeight(true)    //为true时包括边距11、DOM内部插入$(&quot;p&quot;).append(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;);    //每个p节点内后面追加内容$(&quot;p&quot;).appendTo(&quot;div&quot;);    　　　 //p节点追加到div内后$(&quot;p&quot;).prepend(&quot;&lt;b&gt;Hello&lt;/b&gt;&quot;);  //每个p节点内前面追加内容$(&quot;p&quot;).prependTo(&quot;div&quot;);    　   //p节点追加到div内前12、DOM外部插入$(&quot;p&quot;).after(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;);     //每个p节点同级之后插入内容$(&quot;p&quot;).before(&quot;&lt;b&gt;hello&lt;/b&gt;&quot;);    //在每个p节点同级之前插入内容$(&quot;p&quot;).insertAfter(&quot;#node&quot;);     //所有p节点插入到id为node节点的后面$(&quot;p&quot;).insertBefore(&quot;#node&quot;);    //所有p节点插入到id为node节点的前面13、DOM替换$(&quot;p&quot;).replaceWith(&quot;&lt;b&gt;Paragraph. &lt;/b&gt;&quot;);    //将所有匹配的节点替换成指定的HTML或DOM节点$(&quot;&lt;b&gt;Paragraph. &lt;/b&gt;&quot;).replaceAll(&quot;p&quot;);     //用匹配的节点替换掉所有 selector匹配到的节点14、DOM删除$(&quot;p&quot;).empty();     //删除匹配的节点集合中所有的子节点，不包括本身$(&quot;p&quot;).remove();    //删除所有匹配的节点,包括本身$(&quot;p&quot;).detach();    //删除所有匹配的节点(和remove()不同的是:所有绑定的事件、附加的数据会保留下来)15、DOM复制$(&quot;p&quot;).clone()    　　//克隆节点并选中克隆的副本$(&quot;p&quot;).clone(true)   //布尔值指事件处理函数是否会被复制16、DOM加载完成事件$(document).ready(function(){  您的代码...});//缩写$(function($) {  您的代码...});17、绑定事件//bind 为每个匹配节点绑定事件处理函数，绑定多个用{}。$(&quot;p&quot;).bind(&quot;click&quot;, function(){  alert( $(this).text() );});$(&apos;#div1&apos;).bind({    &quot;mouseover&quot;:function () {     $(&apos;#div1&apos;).parent().removeClass(&quot;hide&quot;);     },&quot;mouseout&quot;:function () {     $(&apos;#div1&apos;).parent().addClass(&quot;hide&quot;);}});         $(&quot;p&quot;).one( &quot;click&quot;, function(){})    //事件绑定后只会执行一次$(&quot;p&quot;).unbind( &quot;click&quot; )        //反绑一个事件// 与bind 不同的是当时间发生时才去临时绑定。$(&quot;p&quot;).delegate(&quot;click&quot;,function(){  您的代码});$(&quot;p&quot;).undelegate();    　　　//p节点删除由 delegate() 方法添加的所有事件$(&quot;p&quot;).undelegate(&quot;click&quot;)   //从p节点删除由 delegate() 方法添加的所有click事件$(&quot;p&quot;).click();    　　//单击事件$(&quot;p&quot;).dblclick();    //双击事件$(&quot;input[type=text]&quot;).focus()  //节点获得焦点时,触发 focus 事件$(&quot;input[type=text]&quot;).blur()   //节点失去焦点时,触发 blur事件$(&quot;button&quot;).mousedown()//当按下鼠标时触发事件$(&quot;button&quot;).mouseup()  //节点上放松鼠标按钮时触发事件$(&quot;p&quot;).mousemove()     //当鼠标指针在指定的节点中移动时触发事件$(&quot;p&quot;).mouseover()     //当鼠标指针位于节点上方时触发事件$(&quot;p&quot;).mouseout()    　//当鼠标指针从节点上移开时触发事件$(window).keydown()    //当键盘或按钮被按下时触发事件$(window).keypress()   //当键盘或按钮被按下时触发事件,每输入一个字符都触发一次$(&quot;input&quot;).keyup()     //当按钮被松开时触发事件$(window).scroll()     //当用户滚动时触发事件$(window).resize()     //当调整浏览器窗口的大小时触发事件$(&quot;input[type=&apos;text&apos;]&quot;).change()    //当节点的值发生改变时触发事件$(&quot;input&quot;).select()    //当input 节点中的文本被选择时触发事件$(&quot;form&quot;).submit()     //当提交表单时触发事件$(window).unload()     //用户离开页面时18、事件对象$(&quot;p&quot;).click(function(event){   alert(event.type); //&quot;click&quot;  }); (evnet object)属性方法：event.pageX 　 //事件发生时，鼠标距离网页左上角的水平距离event.pageY 　 //事件发生时，鼠标距离网页左上角的垂直距离event.type 　　//事件的类型event.which 　 //按下了哪一个键event.data 　　//在事件对象上绑定数据，然后传入事件处理函数event.target 　//事件针对的网页节点event.preventDefault() 　//阻止事件的默认行为(比如点击链接，会自动打开新页面)event.stopPropagation()  //停止事件向上层节点冒泡19、动态事件绑定 $(&quot;p&quot;).on(&quot;click&quot;,&apos;span&apos;,function(){alert( $(this).text() );});//当p中增加span时仍然有效20、动画效果$(&quot;p&quot;).show()    　　　　//显示隐藏的匹配节点$(&quot;p&quot;).show(&quot;slow&quot;);    //参数表示速度,(&quot;slow&quot;,&quot;normal&quot;,&quot;fast&quot;),也可为600毫秒$(&quot;p&quot;).hide()    　　　　//隐藏显示的节点$(&quot;p&quot;).toggle();   　　 //切换 显示/隐藏$(&quot;p&quot;).slideDown(&quot;600&quot;);    //用600毫秒时间将段落滑下$(&quot;p&quot;).slideUp(&quot;600&quot;);    　//用600毫秒时间将段落滑上$(&quot;p&quot;).slideToggle(&quot;600&quot;);  //用600毫秒时间将段落滑上，滑下淡入淡出$(&quot;p&quot;).fadeIn(&quot;600&quot;);    　　  //用600毫秒时间将段落淡入$(&quot;p&quot;).fadeOut(&quot;600&quot;);    　　 //用600毫秒时间将段落淡出$(&quot;p&quot;).fadeToggle(&quot;600&quot;);    　//用600毫秒时间将段落淡入,淡出$(&quot;p&quot;).fadeTo(&quot;slow&quot;, 0.6);    //用600毫秒时间将段落的透明度调整到0.621、工具方法$(&quot;#form1&quot;).serialize()    //序列表表格内容为字符串。$(&quot;select, :radio&quot;).serializeArray();  //序列化表单元素为数组返回 JSON 数据结构数据$.trim() 　　//去除字符串两端的空格$.each() 　　//遍历一个数组或对象，for循环$.inArray() //返回一个值在数组中的索引位置，不存在返回-1  $.grep() 　 //返回数组中符合某种标准的节点$.extend({a:1,b:2},{b:3,c:4},{c:5:d:6})  //将多个对象，合并到第一个对象{a:1,b:3,c:5,d:6}$.makeArray() //将对象转化为数组$.type()    //判断对象的类别（函数对象、日期对象、数组对象、正则对象等等$.isArray() //判断某个参数是否为数组$.isEmptyObject() //判断某个对象是否为空(不含有任何属性)$.isFunction()    //判断某个参数是否为函数$.isPlainObject() //判断某个参数是否为用&quot;{}&quot;或&quot;new Object&quot;建立的对象$.support()       //判断浏览器是否支持某个特性22、AJAX//保存数据到服务器，成功时显示信息$.ajax({   type: &quot;POST&quot;,   url: &quot;some.php&quot;,   data: &quot;name=John&amp;location=Boston&quot;,   success: function(msg){     alert( &quot;Data Saved: &quot; + msg );   }});//加载 feeds.html 文件内容。$(&quot;#feeds&quot;).load(&quot;feeds.html&quot;);//请求 test.php 网页，传送2个参数，忽略返回值。$.get(&quot;test.php&quot;, { name: &quot;John&quot;, time: &quot;2pm&quot; } );//从 Flickr JSONP API 载入 4 张最新的关于猫的图片。$.getJSON(&quot;http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&amp;tagmode=any&amp;format=json&amp;jsoncallback=?&quot;, function(data){  $.each(data.items, function(i,item){    $(&quot;&lt;img/&gt;&quot;).attr(&quot;src&quot;, item.media.m).appendTo(&quot;#images&quot;);    if ( i == 3 ) return false;  });});//加载并执行 test.js ，成功后显示信息$.getScript(&quot;test.js&quot;, function(){  alert(&quot;Script loaded and executed.&quot;);});//向页面 test.php 发送数据，并输出结果（HTML 或 XML，取决于所返回的内容）：$.post(&quot;test.php&quot;, { name: &quot;John&quot;, time: &quot;2pm&quot; },   function(data){     alert(&quot;Data Loaded: &quot; + data);   });//AJAX 请求完成时执行函数。 $(&quot;#msg&quot;).ajaxComplete(function(event,request, settings){   $(this).append(&quot;&lt;li&gt;请求完成.&lt;/li&gt;&quot;); });//AJAX 请求失败时显示信息。$(&quot;#msg&quot;).ajaxError(function(event,request, settings){     $(this).append(&quot;&lt;li&gt;出错页面:&quot; + settings.url + &quot;&lt;/li&gt;&quot;);});//AJAX 请求发送前显示信息。 $(&quot;#msg&quot;).ajaxSend(function(evt, request, settings){   $(this).append(&quot;&lt;li&gt;开始请求: &quot; + settings.url + &quot;&lt;/li&gt;&quot;); }); //AJAX 请求开始时显示信息。 $(&quot;#loading&quot;).ajaxStart(function(){   $(this).show(); });//AJAX 请求结束后隐藏信息。 $(&quot;#loading&quot;).ajaxStop(function(){   $(this).hide(); });//当 AJAX 请求成功后显示消息。 $(&quot;#msg&quot;).ajaxSuccess(function(evt, request, settings){   $(this).append(&quot;&lt;li&gt;请求成功!&lt;/li&gt;&quot;); });//请求前过滤$.ajaxPrefilter( function( options, originalOptions, jqXHR ) {    // Modify options, control originalOptions, store jqXHR, etc  }); //设置全局 AJAX 默认选项，设置 AJAX 请求默认地址为 &quot;/xmlhttp/&quot;，禁止触发全局 AJAX 事件，用 POST 代替默认 GET 方法。其后的 AJAX 请求不再设置任何选项参数。$.ajaxSetup({  url: &quot;/xmlhttp/&quot;,  global: false,  type: &quot;POST&quot;});$.ajax({ data: myData });JavaScript中巧用位运算日常前端开发中我们很少用到位运算，容易让人遗忘，让我们一起回顾下一下js中的位运算。位运算详细说明查看JavaScript|MDN下面主要回顾一下一些常用的位运算的巧用。将十进制转化为二进制var number = 3;var result = number.toString(2);var result2 = 14..toString(2); // &quot;1110&quot;我们使用位运算来代替Math.floor()来向下取整var data = 2.2352524535;var result = data | 0; // 2var re2 = ~~data; // 2将颜色从RGA转换为Hex格式var color = {r: 186, g: 218, b: 85};// RGB to HEXvar rgb2hex = function(r, g, b) {    return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).substr(1);}rgb2hex(color.r, color.g, color.b);//&quot;#bada55&quot;区分两个数的大小// variablesvar a = 9285;var b = 3569;// 取大var max = a ^ ((a ^ b) &amp; -(a &lt; b));//9285;// 取小var min =  b ^ ((a ^ b) &amp; -(a &lt; b);//3569交换变量var a = 10;var b = 99;a = (b^=a^=b)^a;console.log(a) // 99console.log(b) // 10判断正负function isPos(n) {  return (n === (n &gt;&gt;&gt; 0)) ? true : false;  }isPos(-1); // falseisPos(1); // true</code></pre><p>常用函数：</p><pre><code>/*========================常用函数========================*//*时间格式化*/Date.prototype.Format = function (fmt) {    var o = {        &quot;M+&quot;: this.getMonth() + 1, /*月份*/        &quot;d+&quot;: this.getDate(), /*日*/        &quot;h+&quot;: this.getHours(), /*小时*/        &quot;m+&quot;: this.getMinutes(), /*分*/        &quot;s+&quot;: this.getSeconds(), /*秒*/        &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), /*季度*/        &quot;S&quot;: this.getMilliseconds() /*毫秒*/    };    if (/(y+)/.test(fmt))        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));    for (var k in o)        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));    return fmt;};/*IE浏览器不支持date(time),所以用此方法转换*/function NewDate(fmt) {    /*首先将日期分隔 ，获取到日期部分 和 时间部分*/    var day = fmt.split(&apos; &apos;);    /*获取日期部分的年月日*/    var days = day[0].split(&apos;-&apos;);    /*获取时间部分的 时分秒*/    var mi = day[day.length - 1].split(&apos;:&apos;);    /*获取当前date类型日期*/    var date = new Date();    /*给date赋值  年月日*/    date.setUTCFullYear(days[0], days[1] - 1, days[2]);    /*给date赋值 时分秒  首先转换utc时区 ：+8*/    date.setUTCHours(mi[0] - 8, mi[1], mi[2]);    return date;}/*为空判断*/function isEmpty(s) {    switch (typeof(s)) {        case &apos;string&apos;:            return !s.length;            break;        case &apos;array&apos;:        case &apos;object&apos;:            for (var i in s) return false;            return true;            break;        case &apos;undefined&apos;:            return true;            break;        default:            return !s;            break;    }}/*数字判断*/function isNumber(s) {    return typeof(s) == &apos;number&apos; ? true : false;}/*整数判断*/function isInt(s) {    var re = /^-?\d*$/;    return re.test(s);}/*正整数判断*/function isUInt(s) {    var re = /^\d*$/;    return re.test(s) &amp;&amp; s &gt;= 0;}/*小数判断*/function isDecimal(s, bit) {    if (!arguments[1]) bit = -1;    if (bit == -1) {        var re = /^-?\d*.?\d*$/;        return re.test(s);    } else {        var re = new RegExp(&apos;^-?\\d*.?\\d{0,&apos; + bit + &apos;}$&apos;);        return re.test(s);    }}/*正小数判断*/function isUDecimal(s, bit) {    if (!arguments[1]) bit = -1;    if (bit == -1) {        var re = /^\d*.?\d*$/;        return re.test(s) &amp;&amp; s &gt;= 0;    } else {        var re = new RegExp(&apos;^\\d*.?\\d{0,&apos; + bit + &apos;}$&apos;);        return re.test(s) &amp;&amp; s &gt;= 0;    }}/*字符串判断*/function isString(s) {    return typeof(s) == &apos;string&apos;;}/*========================/常用函数========================*/js onkeyup replace 自动替换检测浮点数 只能是整数或者小数 多余的就replace 掉 的表单验证function checkFloatNum(obj){    //先把非数字的都替换掉，除了数字和.    obj.value = obj.value.replace(/[^\d.]/g,&quot;&quot;);    //必须保证第一个为数字而不是.    obj.value = obj.value.replace(/^\./g,&quot;&quot;);    //保证只有出现一个.而没有多个.    obj.value = obj.value.replace(/\.{2,}/g,&quot;.&quot;);    //保证.只出现一次，而不能出现两次以上    obj.value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;);}</code></pre><p>解决键盘弹出遮挡：</p><pre><code>// 解决键盘弹出后挡表单的问题        window.addEventListener(&apos;resize&apos;, function() {            if(                document.activeElement.tagName === &apos;INPUT&apos; ||                document.activeElement.tagName === &apos;TEXTAREA&apos;            ) {                window.setTimeout(function() {                    if(&apos;scrollIntoView&apos; in document.activeElement) {                        document.activeElement.scrollIntoView();                    } else {                        document.activeElement.scrollIntoViewIfNeeded();                    }                }, 0);            }        });</code></pre><p>单个for循环实现排序：</p><pre><code>var a = [12, 13, 65, 54, 86, 21, 37, 1, 95, 4];var l=a.length;        for(var i = 0; i &lt; l; i++) {            if(a[i] &gt; a[i + 1]) {                var tem = a[i];                a[i] = a[i + 1];                a[i + 1] = tem;            }            if(i == l - 1) {                i = -1;                l--;            }        }        console.log(a);</code></pre><p>Object.assign实现:</p><pre><code>if (!Object.assign) {    // 定义assign方法  Object.defineProperty(Object, &apos;assign&apos;, {    enumerable: false,    configurable: true,    writable: true,    value: function(target) { // assign方法的第一个参数      &apos;use strict&apos;;      // 第一个参数为空，则抛错      if (target === undefined || target === null) {        throw new TypeError(&apos;Cannot convert first argument to object&apos;);      }      var to = Object(target);      // 遍历剩余所有参数      for (var i = 1; i &lt; arguments.length; i++) {        var nextSource = arguments[i];        // 参数为空，则跳过，继续下一个        if (nextSource === undefined || nextSource === null) {          continue;        }        nextSource = Object(nextSource);        // 获取改参数的所有key值，并遍历        var keysArray = Object.keys(nextSource);        for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {          var nextKey = keysArray[nextIndex];          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);          // 如果不为空且可枚举，则直接浅拷贝赋值          if (desc !== undefined &amp;&amp; desc.enumerable) {            to[nextKey] = nextSource[nextKey];          }        }      }      return to;    }  });}</code></pre><blockquote><p>记录下与Math有关的常用方法，如：求最大值、最小值等，或者是保留几位数啥的</p></blockquote><h1 id="1-数据"><a href="#1-数据" class="headerlink" title="1.数据"></a>1.数据</h1><pre><code>let floatA = 2.325232;let floatB = 2.3456;let temporaryArray = [1, 2, 5, 6, 3];let minusNum = -12;let minusFloat = -12.321;let intA = 10;letmin, max, num;</code></pre><h1 id="2-求最大值、最小值"><a href="#2-求最大值、最小值" class="headerlink" title="2.求最大值、最小值"></a>2.求最大值、最小值</h1><pre><code>{    /* 求最小值 */    min = Math.min(floatA, floatB);    console.log(min);    /* 使用apply来重新绑定this */    min = Math.min.apply(null, temporaryArray);    console.log(min);    /* 使用展开运算符 */    min = Math.min(...temporaryArray);    console.log(min);    /* 求最大值 */    max = Math.max(floatA, floatB);    console.log(max);    /* 使用apply来重新绑定this */    max = Math.max.apply(null, temporaryArray);    console.log(max);    /* 使用展开运算符 */    max = Math.max(...temporaryArray);    console.log(max);}</code></pre><h1 id="3-取整"><a href="#3-取整" class="headerlink" title="3.取整"></a>3.取整</h1><pre><code>{    /* 四舍五入取整:取与参数最接近的整数 */    num = Math.round(floatA);    console.log(num);    num = Math.round(minusFloat);    console.log(num);    /* 向上取整:取大于或等于函数参数，并且与之最接近的整数 */    num = Math.ceil(floatB);    console.log(num);    /* 向下取整:取小于或等于函数参数，并且与之最接近的整数 */    num = Math.floor(floatB);    console.log(num);    /* ceil、floor结合起来，实现一个总是返回数值的整数部分的函数 */    function getInteger(value) {        value = Number(value);        return value &lt; 0 ? Math.ceil(value) : Math.floor(value);    }    console.log(getInteger(-2.3322));}</code></pre><h1 id="4-求绝对值"><a href="#4-求绝对值" class="headerlink" title="4.求绝对值"></a>4.求绝对值</h1><pre><code>{    /* 负整数 */    num = Math.abs(minusNum);    console.log(num);    /* 负浮点数 */    num = Math.abs(minusFloat);    console.log(num);}</code></pre><h1 id="5-次幂"><a href="#5-次幂" class="headerlink" title="5.次幂"></a>5.次幂</h1><pre><code>{    /* 结果是虚数或负数，则该方法将返回 NaN    * 如果由于指数过大而引起浮点溢出，则该方法将返回 Infinity    */    /* 2的3次方 */    num = Math.pow(2, 3);    console.log(num);}</code></pre><h1 id="6-去平方根"><a href="#6-去平方根" class="headerlink" title="6.去平方根"></a>6.去平方根</h1><pre><code>{    /*  求参数的平方根，如果参数小于 0，则返回 NaN */    num = Math.sqrt(9);    console.log(num);}</code></pre><h1 id="7-生成随机数"><a href="#7-生成随机数" class="headerlink" title="7.生成随机数"></a>7.生成随机数</h1><pre><code>{    /* 生成0-1的随机数，大于0小于1 */    num = Math.random();    console.log(num);    /* 生成0-10的随机数 */    num = Math.random() * 10;    console.log(num);    /* 生成任意范围随机数 */    function getRandom(min, max) {        return Math.random() * (max - min) + min;    }    console.log(getRandom(3.5, 6.5));    /* 整数min与整数max生成任意范围整数随机数 */    function getRandomInt(min, max) {        return Math.floor(Math.random() * (max - min + 1)) + min;    }    console.log(getRandomInt(5, 15));}</code></pre><h1 id="8-es6中对Math方法的扩展（部分）"><a href="#8-es6中对Math方法的扩展（部分）" class="headerlink" title="8.es6中对Math方法的扩展（部分）"></a>8.es6中对Math方法的扩展（部分）</h1><pre><code>{    /* 取整(非四舍五入)     * 对于非数值，内部调用 Number 强转为数值     * 对于空值或其他数据，返回NaN     * */    num = Math.trunc(floatA);    console.log(num);    num = Math.trunc(intA);    console.log(num);    num = Math.trunc(&apos;aaa&apos;);    console.log(num);}{    /* 判断一个数是正数、负数或零     * 正数返回+1，负数返回-1，零返回0或-0     * 其他值 NaN     * */    num = Math.sign(2);    console.log(num);    num = Math.sign(0);    console.log(num);    num = Math.sign(-0);    console.log(num);    num = Math.sign(-14);    console.log(num);    num = Math.sign(&apos;ss&apos;);    console.log(num);}{    let a = 2;    a **= 3;    /* 相当于 a*a*a */    console.log(a);}</code></pre><h1 id="9-保留位数操作"><a href="#9-保留位数操作" class="headerlink" title="9.保留位数操作"></a>9.保留位数操作</h1><pre><code>{    /* 四舍五入保留两位小数     * toFixed(num) 方法可把 Number型 四舍五入为指定小数位数的数字     * num规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20     * 有些实现可以支持更大的数值范围,如果省略了该参数，将用 0 代替     * */    num = floatA.toFixed(2);    console.log(num);    let word = 2.5;    num = word.toFixed();    console.log(num);    /* 不四舍五入 */    num = Math.floor(23.365125 * 100) / 100;    console.log(num);}</code></pre><h1 id="10-字符串转数字"><a href="#10-字符串转数字" class="headerlink" title="10.字符串转数字"></a>10.字符串转数字</h1><pre><code> {    /* parseInt(value, radix)    * 用于解析字符串，返回一个整数    * radix表示要解析的数字的基数，该值介于 2 ~ 36 之间    * 如果省略该参数或其值为 0，则数字将以 10 为基础来解析    * 如果它以 “0x” 或 “0X” 开头，将以 16 为基数    * 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。    * */    let temporaryString = &apos;123&apos;;    num = parseInt(temporaryString);    console.log(num);    {        console.log(parseInt(&quot;10&quot;));        //返回 10        console.log(parseInt(&quot;19&quot;,10));        //返回 19 : 10 + 9        console.log(parseInt(&quot;11&quot;,2));        //返回 3 : 2 + 1        console.log(parseInt(&quot;17&quot;,8));        //返回 15 : 8 + 7        console.log(parseInt(&quot;1f&quot;,16));        //返回 31 : 16 + 15        console.log(parseInt(&quot;010&quot;));        //未定：返回 10 或 8    }    /* 常见的parseInt一道题 */    {        console.log([&apos;1&apos;, &apos;2&apos;, &apos;3&apos;].map(parseInt));        /* 返回[1, NaN, NaN]        * map(function(value, index, array) {})        * map方法中的回调函数中的3个参数值，每个值value，索引值index，数组对象array        * 上面的相当于parseInt(&apos;1&apos;, 0)、parseInt(&apos;2&apos;, 1)、parseInt(&apos;3&apos;, 2)        * */    }    /* Number强转 */    num = Number(&apos;12345&apos;);    console.log(num);}</code></pre><h1 id="文件流下载"><a href="#文件流下载" class="headerlink" title="文件流下载"></a>文件流下载</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目中经常会遇到需要导出列表内容，或者下载文件之类的需求。结合各种情况，我总结了前端最常用的三种方法来接受后端传过来的文件流并下载，针对不同的情况可以使用不同的方法。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>针对后端的<code>get</code>请求</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"后端文件下载接口地址"</span> &gt;下载文件&lt;<span class="regexp">/a&gt;</span></span><br></pre></td></tr></table></figure><p>直接用个<code>&lt;a&gt;</code>标签来接受后端的文件流</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>针对后端的<code>post</code>请求<br>利用原生的<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FXMLHttpRequest" target="_blank" rel="noopener"><code>XMLHttpRequest</code></a>方法实现</p><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">functionrequest () &#123;</span><br><span class="line">    <span class="keyword">const</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">'POST'</span>, <span class="string">'&lt;接口地址&gt;'</span>, <span class="literal">true</span>);</span><br><span class="line">    req.responseType = <span class="string">'blob'</span>;</span><br><span class="line">    req.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> data = req.response;</span><br><span class="line">      <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">      <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([data]);</span><br><span class="line">      <span class="keyword">const</span> blobUrl = <span class="built_in">window</span>.URL.createObjectURL(blob);</span><br><span class="line">      download(blobUrl) ;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send(<span class="string">'&lt;请求参数：json字符串&gt;'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">blobUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  a.style.display = <span class="string">'none'</span>;</span><br><span class="line">  a.download = <span class="string">'&lt;文件名&gt;'</span>;</span><br><span class="line">  a.href = blobUrl;</span><br><span class="line">  a.click();</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request();</span><br></pre></td></tr></table></figure><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><p>针对后端的<code>post</code>请求<br>利用原生的<a href="https://link.juejin.im?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FFetch_API" target="_blank" rel="noopener"><code>fetch</code></a>方法实现</p><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">functionrequest() &#123;</span><br><span class="line">  fetch(<span class="string">'&lt;接口地址&gt;'</span>, &#123;</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    body: <span class="string">'&lt;请求参数：json字符串&gt;'</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> res.blob())</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> blobUrl = <span class="built_in">window</span>.URL.createObjectURL(data);</span><br><span class="line">      download(blobUrl);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">blobUrl</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line">  a.style.display = <span class="string">'none'</span>;</span><br><span class="line">  a.download = <span class="string">'&lt;文件名&gt;'</span>;</span><br><span class="line">  a.href = blobUrl;</span><br><span class="line">  a.click();</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果后端提供的下载接口是<code>get</code>类型，可以直接使用方法一，简单又便捷；当然如果想使用方法二、三也是可以的，不过感觉有点舍近求远了。</li><li>如果后端提供的下载接口是<code>post</code>类型，就必须要用方法二或者方法三了。</li></ul><h3 id="方法二和方法三怎么取舍？"><a href="#方法二和方法三怎么取舍？" class="headerlink" title="方法二和方法三怎么取舍？"></a>方法二和方法三怎么取舍？</h3><ul><li>当你的项目里的接口请求全是基于<code>XMLHttpRequest</code>实现的，这时<strong>方法二</strong>就更加适合，只要基于你原来项目中的接口请求工具类加以扩展就行了。</li><li>当你的项目里的接口请求全是基于<code>fetch</code>实现的，这时<strong>方法三</strong>就更加适合，比如我现在的做的一个项目就是基于<code>ant design pro</code>的后台管理系统，它里面的请求类就是基于<code>fetch</code>的，所以我就直接用的<strong>方法三</strong>，只要在它的<code>request.js</code>文件中稍作修改就行。</li><li>我这里讨论的是两种原生的请求方式，如果你项目中引用了第三方请求包来发送请求，比如axios之类的，那就要另当别论了。</li></ul><hr><h1 id="JavaScript骚操作之操作符-JavaScript骚操作之操作符"><a href="#JavaScript骚操作之操作符-JavaScript骚操作之操作符" class="headerlink" title="JavaScript骚操作之操作符  JavaScript骚操作之操作符"></a>JavaScript骚操作之操作符  <a href="https://juejin.im/post/5c15dc47e51d457b00691be5" target="_blank" rel="noopener">JavaScript骚操作之操作符</a></h1><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符 ?:"></a>三目运算符 ?:</h2><p>每到周末我都会问自己，怎么安排？于是我写了个程序跑了一下</p><pre><code>if (hasMoney) {        console.log(&apos;周末嗨翻天&apos;);    } else {        console.log(&apos;周末睡一天&apos;);    }</code></pre><p>看上去没有什么问题，但总感觉代码有点臃肿，能不能稍微简约一点？</p><p>换成三目运算符后</p><pre><code>hasMoney ? console.log(&apos;周末嗨翻天&apos;) : console.log(&apos;周末睡一天&apos;);</code></pre><p>look，当hasMoney为true的时候，嗨翻天，为false的时候的睡一天。这种操作符在我们的根据简单的判断条件赋值的时候非常有用</p><pre><code>let weekendPlan = hasMoney ? &apos;周末嗨翻天&apos; : &apos;周末睡一天&apos;;</code></pre><p>如此，我们的代码就不会充斥着大量的if判断条件句，还能略显骚气。但是，别骚过度了</p><pre><code>val = simpleCondition    ? 1    : simpleConditionAgain    ? 2    : simpleConditionAgainAndAgain    ? 3    : 4;</code></pre><p>上面的例子有点为了装逼而装逼的感觉，在代码可读性方面有点糟糕，即使换成了if条件句也不甚美观；像这种情况，可以使用switch语句或者策略模式的设计思想优化。</p><h2 id="逻辑与操作符-amp-amp"><a href="#逻辑与操作符-amp-amp" class="headerlink" title="逻辑与操作符 &amp;&amp;"></a>逻辑与操作符 &amp;&amp;</h2><p>如果有钱的话，周末就去嗨翻天，但没钱的情况还没有想好要干嘛（虽然没钱的情况干不了什么），常规操作为</p><pre><code>if (hasMoney) {        console.log(&apos;周末嗨翻天&apos;);    }</code></pre><p>这个时候使用三目运算符改写的话</p><pre><code>hasMoney ? console.log(&apos;周末嗨翻天&apos;) : undefined;</code></pre><p>有点奇怪，我们不得不写个undefined去告诉程序判断条件为false的时候应该怎么做。使用逻辑与操作符就可以避免这个问题</p><pre><code>hasMoney &amp;&amp; console.log(&apos;周末嗨翻天&apos;);</code></pre><p>逻辑与操作符会使用Boolean函数判断每一个条件(表达式)是否为true，当所有的判断条件都为true的情况下，就会返回最后的表达式的运算结果；但是如果有判断条件为false的话，就会返回第一个判断条件为false的运算结果</p><pre><code>true &amp;&amp; console.log(&apos;It is true&apos;);                         // It is truetrue &amp;&amp; false &amp;&amp; console.log(&apos;It is true&apos;);                // 返回 falsetrue &amp;&amp; 0 &amp;&amp; console.log(&apos;It is true&apos;);                    // 返回 0true &amp;&amp; undefined == null &amp;&amp; console.log(&apos;It is true&apos;);    // It is true, 表达式undefined == null的运算结果为truetrue &amp;&amp; undefined === null &amp;&amp; console.log(&apos;It is true&apos;);   // 返回 false, 表达式undefined === null的运算结果为false</code></pre><p>所以在react中使用逻辑与操作符渲染元素的时候，一定要注意</p><pre><code>render() {    return (        &lt;Fragment&gt;{            data.length &amp;&amp; data.map(item =&gt; &lt;span&gt;{ item }&lt;/span&gt;)        }&lt;/Fragment&gt;    );}// 当没有数据的时候，页面会渲染出一个0</code></pre><p>上面的例子的本意是当有数据的时候就将数据渲染出来，没有数据的时候，不做任何操作。但是逻辑与操作符会将第一个为false的表达式的运算结果返回，导致返回了个0！</p><h2 id="逻辑或操作符"><a href="#逻辑或操作符" class="headerlink" title="逻辑或操作符 ||"></a>逻辑或操作符 ||</h2><p>说到逻辑与操作符，就不得不提它的好基友：逻辑或操作符。考虑下面的场景</p><pre><code>// 当自身为undefined时，赋值为0，否则还是赋值为自身    val = val !== undefined ? val : 0;</code></pre><p>使用三目运算符去处理上述例子的逻辑时，我们需要显式的判断val是否为空的，然后再决定变量val是否应该等于本身。那么本着能省就省的原则，我们可以使用逻辑或操作符</p><pre><code>val = val || 0;</code></pre><p>逻辑或操作符，其会将第一个表达式的运算结果传入Boolean函数，如果Boolean函数返回true，就会返回这个运算结果；否则将会尝试下一个，直到结束；如果所有的表达式的运算结果对应的布尔值都为false，则返回最后一个表达式的运算结果</p><p>故此操作符在向下兼容、设置函数参数的默认值时非常有用</p><pre><code>// ES5设置函数默认值functiontestFunc(arg1) {        arg1 = arg1 || 1;        // do something else    }    let a = 1,        b = 2,        c = null;    console.log(a || b || c);         // 1console.log(0 || b || c);         // 2console.log(0 || false || c);     // null</code></pre><blockquote><p>note: 故此猜想，if条件句里面使用逻辑或、逻辑与操作符，实际上也只是返回表达式的运算结果，然后再隐式调用了Boolean函数得到一个最终的布尔值</p></blockquote><h2 id="逻辑取反-！"><a href="#逻辑取反-！" class="headerlink" title="逻辑取反 ！"></a>逻辑取反 ！</h2><p>上文说到，有钱的周末可以为所欲为，没钱的周末，估计也就只能选择睡一天了。这种情况下，如果使用hasMoney作为判断标准，我们的代码是这样的</p><pre><code>hasMoney === false &amp;&amp; console.log(&apos;周末睡一天&apos;);</code></pre><p>当hasMoney不是一个布尔值的时候，hasMoney === false语句就会一直返回false，造成有钱的假象。所以我们必须的将hasMoney转换成一个布尔值才能判断，恰好取反操作符可以同时给我们做这两件事</p><pre><code>!hasMoney &amp;&amp; console.log(&apos;周末睡一天&apos;);</code></pre><p>这样就能在没钱的时候睡一天了。</p><p>取反操作符能够将一个非Boolean类型的值转化为Boolean类型的值且取反</p><pre><code>!true &amp;&amp; console.log(&apos;666&apos;);             // 返回false!!true &amp;&amp; console.log(&apos;666&apos;);            // 666{} &amp;&amp; console.log(&apos;666&apos;);                // 报错!{} &amp;&amp; console.log(&apos;666&apos;);               // 返回false!!{} &amp;&amp; console.log(&apos;666&apos;);              // 666</code></pre><h2 id="按位取反操作符"><a href="#按位取反操作符" class="headerlink" title="按位取反操作符 ~"></a>按位取反操作符 ~</h2><p>加入我们需要判断一个数组里面是否存在某个元素，在ES6里面可以使用includes</p><pre><code>let arr = [&apos;we&apos;, &apos;are&apos;, &apos;the&apos;, &apos;BlackGold&apos;, &apos;team&apos;];    arr.includes(&apos;the&apos;) &amp;&amp; console.log(&apos;in&apos;);      // in</code></pre><p>但是这个方法有比较大的限制：没办法传入一个筛选函数。</p><pre><code>let arr = [&apos;we&apos;, &apos;are&apos;, &apos;the&apos;, &apos;BlackGold&apos;, &apos;team&apos;];    arr.includes(element =&gt; element === &apos;the&apos;) &amp;&amp; console.log(&apos;in&apos;);     // 返回false</code></pre><p>这种情况下，我们通常可以使用findIndex方法</p><pre><code>let arr = [&apos;we&apos;, &apos;are&apos;, &apos;the&apos;, &apos;BlackGold&apos;, &apos;team&apos;];    arr.findIndex(element =&gt; element === &apos;the&apos;) !== -1 &amp;&amp; console.log(&apos;in&apos;);      // in</code></pre><p>由于findIndex方法返回的索引是从0开始的，所以我们必须得判断其返回的索引是否不等于-1或者是大于等于0。如果使用按位取反操作符，将不需要显示去判断</p><pre><code>let arr = [&apos;we&apos;, &apos;are&apos;, &apos;the&apos;, &apos;BlackGold&apos;, &apos;team&apos;];    ~arr.findIndex(element =&gt; element === &apos;we&apos;) &amp;&amp; console.log(&apos;in&apos;);      // in    ~arr.findIndex(element =&gt; element === &apos;the&apos;) &amp;&amp; console.log(&apos;in&apos;);      // in</code></pre><p>按位取反操作符，顾名思义，就是将变量的每一个比特位取反：0-&gt;1、1-&gt;0</p><pre><code>console.log(~-1);       // 0 转换为Boolean值即为falseconsole.log(~0);        // -1 转换为Boolean值即为trueconsole.log(~1);        // -2 转换为Boolean值即为true</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>JavaScript骚操作系列主要总结JavaScript一些好用的特性、方法，以供交流学习之用，不喜勿喷。如有错漏，欢迎指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS原生常用API大全</title>
      <link href="/2015/01/01/JS%E5%8E%9F%E7%94%9F%E5%B8%B8%E7%94%A8API%E5%A4%A7%E5%85%A8/"/>
      <url>/2015/01/01/JS%E5%8E%9F%E7%94%9F%E5%B8%B8%E7%94%A8API%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="/2015/01/01/JS原生常用API大全/2_20181206205220.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/3_20181206210151.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;n:1&#125;;</span><br><span class="line">var b=a;</span><br><span class="line">a.x=a.y=a=&#123;n:2&#125;;    //a.x=&#123;n:2&#125;,a.y=&#123;n:2&#125;,此时a还是&#123;n:1&#125;,a=&#123;n:2&#125;</span><br><span class="line">console.log(a);    // &#123;n: 2&#125;</span><br><span class="line">console.log(b);   //&#123;n: 1, y: &#123;…&#125;, x: &#123;…&#125;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="原生JS-API"><a href="#原生JS-API" class="headerlink" title="原生JS API"></a>原生JS API</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br></pre></td><td class="code"><pre><span class="line">一、节点</span><br><span class="line">1.1 节点属性</span><br><span class="line">Node.nodeName   //返回节点名称，只读</span><br><span class="line">Node.nodeType   //返回节点类型的常数值，只读</span><br><span class="line">Node.nodeValue  //返回Text或Comment节点的文本值，只读</span><br><span class="line">Node.textContent  //返回当前节点和它的所有后代节点的文本内容，可读写</span><br><span class="line">Node.baseURI    //返回当前网页的绝对路径</span><br><span class="line"></span><br><span class="line">Node.ownerDocument  //返回当前节点所在的顶层文档对象，即document</span><br><span class="line">Node.nextSibling  //返回紧跟在当前节点后面的第一个兄弟节点</span><br><span class="line">Node.previousSibling  //返回当前节点前面的、距离最近的一个兄弟节点</span><br><span class="line">Node.parentNode   //返回当前节点的父节点</span><br><span class="line">Node.parentElement  //返回当前节点的父Element节点</span><br><span class="line">Node.childNodes   //返回当前节点的所有子节点</span><br><span class="line">Node.firstChild  //返回当前节点的第一个子节点</span><br><span class="line">Node.lastChild   //返回当前节点的最后一个子节点</span><br><span class="line"></span><br><span class="line">//parentNode接口</span><br><span class="line">Node.children  //返回指定节点的所有Element子节点</span><br><span class="line">Node.firstElementChild  //返回当前节点的第一个Element子节点</span><br><span class="line">Node.lastElementChild   //返回当前节点的最后一个Element子节点</span><br><span class="line">Node.childElementCount  //返回当前节点所有Element子节点的数目。</span><br><span class="line">1.2 操作</span><br><span class="line">Node.appendChild(node)   //向节点添加最后一个子节点</span><br><span class="line">Node.hasChildNodes()   //返回布尔值，表示当前节点是否有子节点</span><br><span class="line">Node.cloneNode(true);  // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)</span><br><span class="line">Node.insertBefore(newNode,oldNode)  // 在指定子节点之前插入新的子节点</span><br><span class="line">Node.removeChild(node)   //删除节点，在要删除节点的父节点上操作</span><br><span class="line">Node.replaceChild(newChild,oldChild)  //替换节点</span><br><span class="line">Node.contains(node)  //返回一个布尔值，表示参数节点是否为当前节点的后代节点。</span><br><span class="line">Node.compareDocumentPosition(node)   //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系</span><br><span class="line">Node.isEqualNode(noe)  //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。</span><br><span class="line">Node.normalize()   //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。</span><br><span class="line"></span><br><span class="line">//ChildNode接口</span><br><span class="line">Node.remove()  //用于删除当前节点</span><br><span class="line">Node.before()  //</span><br><span class="line">Node.after()</span><br><span class="line">Node.replaceWith()</span><br><span class="line">1.3 Document节点</span><br><span class="line">1.3.1 Document节点的属性</span><br><span class="line">document.doctype   //</span><br><span class="line">document.documentElement  //返回当前文档的根节点</span><br><span class="line">document.defaultView   //返回document对象所在的window对象</span><br><span class="line">document.body   //返回当前文档的&lt;body&gt;节点</span><br><span class="line">document.head   //返回当前文档的&lt;head&gt;节点</span><br><span class="line">document.activeElement  //返回当前文档中获得焦点的那个元素。</span><br><span class="line"></span><br><span class="line">//节点集合属性</span><br><span class="line">document.links  //返回当前文档的所有a元素</span><br><span class="line">document.forms  //返回页面中所有表单元素</span><br><span class="line">document.images  //返回页面中所有图片元素</span><br><span class="line">document.embeds  //返回网页中所有嵌入对象</span><br><span class="line">document.scripts  //返回当前文档的所有脚本</span><br><span class="line">document.styleSheets  //返回当前网页的所有样式表</span><br><span class="line"></span><br><span class="line">//文档信息属性</span><br><span class="line">document.documentURI  //表示当前文档的网址</span><br><span class="line">document.URL  //返回当前文档的网址</span><br><span class="line">document.domain  //返回当前文档的域名</span><br><span class="line">document.lastModified  //返回当前文档最后修改的时间戳</span><br><span class="line">document.location  //返回location对象，提供当前文档的URL信息</span><br><span class="line">document.referrer  //返回当前文档的访问来源</span><br><span class="line">document.title    //返回当前文档的标题</span><br><span class="line">document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。</span><br><span class="line">document.readyState  //返回当前文档的状态</span><br><span class="line">document.designMode  //控制当前文档是否可编辑，可读写</span><br><span class="line">document.compatMode  //返回浏览器处理文档的模式</span><br><span class="line">document.cookie   //用来操作Cookie</span><br><span class="line">1.3.2 Document节点的方法</span><br><span class="line">（1）读写方法</span><br><span class="line">document.open()   //用于新建并打开一个文档</span><br><span class="line">document.close()   //不安比open方法所新建的文档</span><br><span class="line">document.write()   //用于向当前文档写入内容</span><br><span class="line">document.writeIn()  //用于向当前文档写入内容，尾部添加换行符。</span><br><span class="line">（2）查找节点</span><br><span class="line">document.querySelector(selectors)   //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。</span><br><span class="line">document.querySelectorAll(selectors)  //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。</span><br><span class="line">document.getElementsByTagName(tagName)  //返回所有指定HTML标签的元素</span><br><span class="line">document.getElementsByClassName(className)   //返回包括了所有class名字符合指定条件的元素</span><br><span class="line">document.getElementsByName(name)   //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）</span><br><span class="line">document.getElementById(id)   //返回匹配指定id属性的元素节点。</span><br><span class="line">document.elementFromPoint(x,y)  //返回位于页面指定位置最上层的Element子节点。</span><br><span class="line">（3）生成节点</span><br><span class="line">document.createElement(tagName)   //用来生成HTML元素节点。</span><br><span class="line">document.createTextNode(text)   //用来生成文本节点</span><br><span class="line">document.createAttribute(name)  //生成一个新的属性对象节点，并返回它。</span><br><span class="line">document.createDocumentFragment()  //生成一个DocumentFragment对象</span><br><span class="line">（4）事件方法</span><br><span class="line">document.createEvent(type)   //生成一个事件对象，该对象能被element.dispatchEvent()方法使用</span><br><span class="line">document.addEventListener(type,listener,capture)  //注册事件</span><br><span class="line">document.removeEventListener(type,listener,capture)  //注销事件</span><br><span class="line">document.dispatchEvent(event)  //触发事件</span><br><span class="line">（5）其他</span><br><span class="line">document.hasFocus()   //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。</span><br><span class="line">document.adoptNode(externalNode)  //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。</span><br><span class="line">document.importNode(externalNode, deep)   //从外部文档拷贝指定节点，插入当前文档。</span><br><span class="line">1.4 Element节点</span><br><span class="line">1.4.1 Element节点的属性</span><br><span class="line">（1）特性属性</span><br><span class="line">Element.attributes  //返回当前元素节点的所有属性节点</span><br><span class="line">Element.id  //返回指定元素的id属性，可读写</span><br><span class="line">Element.tagName  //返回指定元素的大写标签名</span><br><span class="line">Element.innerHTML   //返回该元素包含的HTML代码，可读写</span><br><span class="line">Element.outerHTML  //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写</span><br><span class="line">Element.className  //返回当前元素的class属性，可读写</span><br><span class="line">Element.classList  //返回当前元素节点的所有class集合</span><br><span class="line">Element.dataset   //返回元素节点中所有的data-*属性。</span><br><span class="line">（2）尺寸属性</span><br><span class="line">Element.clientHeight   //返回元素节点可见部分的高度</span><br><span class="line">Element.clientWidth   //返回元素节点可见部分的宽度</span><br><span class="line">Element.clientLeft   //返回元素节点左边框的宽度</span><br><span class="line">Element.clientTop   //返回元素节点顶部边框的宽度</span><br><span class="line">Element.scrollHeight  //返回元素节点的总高度</span><br><span class="line">Element.scrollWidth  //返回元素节点的总宽度</span><br><span class="line">Element.scrollLeft   //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置</span><br><span class="line">Element.scrollTop   //返回元素节点的垂直滚动向下滚动的像素数值</span><br><span class="line">Element.offsetHeight   //返回元素的垂直高度(包含border,padding)</span><br><span class="line">Element.offsetWidth    //返回元素的水平宽度(包含border,padding)</span><br><span class="line">Element.offsetLeft    //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移</span><br><span class="line">Element.offsetTop   //返回水平位移</span><br><span class="line">Element.style  //返回元素节点的行内样式</span><br><span class="line">（3）节点相关属性</span><br><span class="line">Element.children   //包括当前元素节点的所有子元素</span><br><span class="line">Element.childElementCount   //返回当前元素节点包含的子HTML元素节点的个数</span><br><span class="line">Element.firstElementChild  //返回当前节点的第一个Element子节点  </span><br><span class="line">Element.lastElementChild   //返回当前节点的最后一个Element子节点  </span><br><span class="line">Element.nextElementSibling  //返回当前元素节点的下一个兄弟HTML元素节点</span><br><span class="line">Element.previousElementSibling  //返回当前元素节点的前一个兄弟HTML节点</span><br><span class="line">Element.offsetParent   //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。</span><br><span class="line">1.4.2 Element节点的方法</span><br><span class="line">（1）位置方法</span><br><span class="line">getBoundingClientRect()  </span><br><span class="line">// getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高</span><br><span class="line">// top 元素上外边界距窗口最上面的距离</span><br><span class="line">// right 元素右外边界距窗口最上面的距离</span><br><span class="line">// bottom 元素下外边界距窗口最上面的距离</span><br><span class="line">// left 元素左外边界距窗口最上面的距离</span><br><span class="line">// width 元素自身宽(包含border,padding) </span><br><span class="line">// height 元素自身高(包含border,padding) </span><br><span class="line"></span><br><span class="line">getClientRects()   //返回当前元素在页面上形参的所有矩形。</span><br><span class="line"></span><br><span class="line">// 元素在页面上的偏移量  </span><br><span class="line">var rect = el.getBoundingClientRect()  </span><br><span class="line">return &#123;   </span><br><span class="line">  top: rect.top + document.body.scrollTop,   </span><br><span class="line">  left: rect.left + document.body.scrollLeft  </span><br><span class="line">&#125;</span><br><span class="line">（2）属性方法</span><br><span class="line">Element.getAttribute()：读取指定属性  </span><br><span class="line">Element.setAttribute()：设置指定属性  </span><br><span class="line">Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性  </span><br><span class="line">Element.removeAttribute()：移除指定属性</span><br><span class="line">（3）查找方法</span><br><span class="line">Element.querySelector()  </span><br><span class="line">Element.querySelectorAll()  </span><br><span class="line">Element.getElementsByTagName()  </span><br><span class="line">Element.getElementsByClassName()</span><br><span class="line">（4）事件方法</span><br><span class="line">Element.addEventListener()：添加事件的回调函数  </span><br><span class="line">Element.removeEventListener()：移除事件监听函数  </span><br><span class="line">Element.dispatchEvent()：触发事件</span><br><span class="line"></span><br><span class="line">//ie8</span><br><span class="line">Element.attachEvent(oneventName,listener)</span><br><span class="line">Element.detachEvent(oneventName,listener)</span><br><span class="line"></span><br><span class="line">// event对象  </span><br><span class="line">var event = window.event||event;    </span><br><span class="line"></span><br><span class="line">// 事件的目标节点  </span><br><span class="line">var target = event.target || event.srcElement;</span><br><span class="line"></span><br><span class="line">// 事件代理  </span><br><span class="line">ul.addEventListener(&apos;click&apos;, function(event) &#123;   </span><br><span class="line">  if (event.target.tagName.toLowerCase() === &apos;li&apos;) &#123;   </span><br><span class="line">    console.log(event.target.innerHTML)   </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;);</span><br><span class="line">（5）其他</span><br><span class="line">Element.scrollIntoView()   //滚动当前元素，进入浏览器的可见区域</span><br><span class="line"></span><br><span class="line">//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。</span><br><span class="line">Element.insertAdjacentHTML(where, htmlString); </span><br><span class="line">Element.insertAdjacentHTML(&apos;beforeBegin&apos;, htmlString); // 在该元素前插入  </span><br><span class="line">Element.insertAdjacentHTML(&apos;afterBegin&apos;, htmlString); // 在该元素第一个子元素前插入 </span><br><span class="line">Element.insertAdjacentHTML(&apos;beforeEnd&apos;, htmlString); // 在该元素最后一个子元素后面插入 </span><br><span class="line">Element.insertAdjacentHTML(&apos;afterEnd&apos;, htmlString); // 在该元素后插入</span><br><span class="line"></span><br><span class="line">Element.remove()  //用于将当前元素节点从DOM中移除</span><br><span class="line">Element.focus()   //用于将当前页面的焦点，转移到指定元素上</span><br><span class="line">二、CSS操作</span><br><span class="line">（1）类名操作</span><br><span class="line">//ie8以下</span><br><span class="line">Element.className  //获取元素节点的类名</span><br><span class="line">Element.className += &apos; &apos; + newClassName  //新增一个类名</span><br><span class="line"></span><br><span class="line">//判断是否有某个类名</span><br><span class="line">function hasClass(element,className)&#123;</span><br><span class="line">  return new RegExp(className,&apos;gi&apos;).test(element.className);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//移除class</span><br><span class="line">function removeClass(element,className)&#123;</span><br><span class="line">  element.className = element.className.replace(new RegExp(&apos;(^|\\b)&apos; + className.split(&apos; &apos;).join(&apos;|&apos;) + &apos;(\\b|$)&apos;, &apos;gi&apos;),&apos;&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//ie10 </span><br><span class="line">element.classList.add(className)  //新增</span><br><span class="line">element.classList.remove(className)  //删除</span><br><span class="line">element.classList.contains(className)  //是否包含</span><br><span class="line">element.classList.toggle(className)  //toggle class</span><br><span class="line">（2）style操作</span><br><span class="line">element.setAttribute(&apos;style&apos;,&apos;&apos;)</span><br><span class="line"></span><br><span class="line">element.style.backgroundColor = &apos;red&apos;</span><br><span class="line"></span><br><span class="line">element.style.cssText //用来读写或删除整个style属性</span><br><span class="line"></span><br><span class="line">element.style.setProperty(propertyName,value)  //设置css属性</span><br><span class="line">element.style.getPropertyValue(property)  //获取css属性</span><br><span class="line">element.style.removeProperty(property)  //删除css属性</span><br><span class="line">操作非内联样式</span><br><span class="line">//ie8</span><br><span class="line">element.currentStyle[attrName]</span><br><span class="line">//ie9+</span><br><span class="line">window.getComputedStyle(el,null)[attrName] </span><br><span class="line">window.getComputedStyle(el,null).getPropertyValue(attrName)</span><br><span class="line">//伪类</span><br><span class="line">window.getComputedStyle(el,&apos;:after&apos;)[attrName]</span><br><span class="line">三、对象</span><br><span class="line">3.1 Object对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var o = new Object()</span><br><span class="line">（2）属性</span><br><span class="line">Object.prototype   //返回原型对象</span><br><span class="line">（3）方法</span><br><span class="line">Object.keys(o)   //遍历对象的可枚举属性</span><br><span class="line">Object.getOwnPropertyName(o)   //遍历对象不可枚举的属性</span><br><span class="line">对象实例的方法</span><br><span class="line">valueOf()：返回当前对象对应的值。  </span><br><span class="line">toString()：返回当前对象对应的字符串形式。  </span><br><span class="line">toLocaleString()：返回当前对象对应的本地字符串形式。  </span><br><span class="line">hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 </span><br><span class="line">isPrototypeOf()：判断当前对象是否为另一个对象的原型。</span><br><span class="line">propertyIsEnumerable()：判断某个属性是否可枚举。</span><br><span class="line">3.2 Array对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var a = new Array()</span><br><span class="line">（2）属性</span><br><span class="line">a.length  //长度</span><br><span class="line">（3）Array.isArray()</span><br><span class="line">Array.isArray(a)   //用来判断一个值是否为数组</span><br><span class="line">（4）Array实例的方法</span><br><span class="line"></span><br><span class="line">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</span><br><span class="line"></span><br><span class="line">a.valueof()   //返回数组本身</span><br><span class="line">a.toString()  //返回数组的字符串形式</span><br><span class="line">a.push(value,vlaue....)   //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。</span><br><span class="line">pop()   //用于删除数组的最后一个元素，并返回该元素</span><br><span class="line">join()  //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。</span><br><span class="line">concat()  //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。</span><br><span class="line">shift()  //用于删除数组的第一个元素，并返回该元素。</span><br><span class="line">unshift(value)  //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。</span><br><span class="line">reverse()   //用于颠倒数组中元素的顺序，返回改变后的数组</span><br><span class="line">slice(start_index, upto_index);   //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。</span><br><span class="line">splice(index, count_to_remove, addElement1, addElement2, ...);   //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</span><br><span class="line">sort()   //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。</span><br><span class="line">map()   //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。</span><br><span class="line">map(elem,index,arr)   //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。</span><br><span class="line">forEach()   //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。</span><br><span class="line">filter()   //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</span><br><span class="line">some()    //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。</span><br><span class="line">every()   //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。</span><br><span class="line">reduce()   //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）</span><br><span class="line">reduceRight()  //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）</span><br><span class="line">indexOf(s)   //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置</span><br><span class="line">lastIndexOf()  //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">3.3 Number对象</span><br><span class="line">（1）生成对象</span><br><span class="line">var n = new Number()</span><br><span class="line">（2）Number对象的属性</span><br><span class="line">Number.POSITIVE_INFINITY：正的无限，指向Infinity。  </span><br><span class="line">Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。  </span><br><span class="line">Number.NaN：表示非数值，指向NaN。  </span><br><span class="line">Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。  </span><br><span class="line">Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。  </span><br><span class="line">Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。  </span><br><span class="line">Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</span><br><span class="line">（4）Number对象实例的方法</span><br><span class="line">toString()   //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。</span><br><span class="line">toFixed()   //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。</span><br><span class="line">toExponential()  //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。</span><br><span class="line">toPrecision()  //用于将一个数转为指定位数的有效数字。</span><br><span class="line">3.4 String 对象</span><br><span class="line">（1）生成实例对象</span><br><span class="line">var s = new String()</span><br><span class="line">（2）String对象的属性</span><br><span class="line">s.length   //返回字符串的长度</span><br><span class="line">（3）方法</span><br><span class="line">s.chatAt(index)   //返回指定位置的字符    //&quot;123456&quot;[0] == &quot;1&quot;</span><br><span class="line">s.fromCharCode()    //该方法的参数是一系列Unicode码点，返回对应的字符串。</span><br><span class="line">s.charCodeAt(index)    //返回给定位置字符的Unicode码点（十进制表示）</span><br><span class="line">s.concat(s2)  //用于连接两个字符串</span><br><span class="line">s.slice(start,end)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。</span><br><span class="line">s.substring(start,end)  //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。</span><br><span class="line">s.substr(start,length)   //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</span><br><span class="line">s.indexOf(s)   //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 </span><br><span class="line">s.lastIndexOf()  //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。</span><br><span class="line">s.trim()  //用于去除字符串两端的空格，返回一个新字符串</span><br><span class="line">s.toLowerCase()  //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。</span><br><span class="line">s.toUpperCase()  //全部转为大写</span><br><span class="line">s.localeCompare(s2)  //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</span><br><span class="line">s.match(regexp)   //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。</span><br><span class="line">s.search()  //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。</span><br><span class="line">s.replace(oldValue,newValue)  //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。</span><br><span class="line">s.split()  //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。</span><br><span class="line">3.5 Math对象</span><br><span class="line">（1）属性</span><br><span class="line">Math.E：常数e。  </span><br><span class="line">Math.LN2：2的自然对数。  </span><br><span class="line">Math.LN10：10的自然对数。  </span><br><span class="line">Math.LOG2E：以2为底的e的对数。  </span><br><span class="line">Math.LOG10E：以10为底的e的对数。  </span><br><span class="line">Math.PI：常数Pi。  </span><br><span class="line">Math.SQRT1_2：0.5的平方根。  </span><br><span class="line">Math.SQRT2：2的平方根。</span><br><span class="line">（2）数学方法</span><br><span class="line">Math.abs()：返回参数的绝对值  </span><br><span class="line">Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 </span><br><span class="line">Math.floor()：向下取整  </span><br><span class="line">Math.max(n,n1,...)：可接受多个参数，返回最大值  </span><br><span class="line">Math.min(n,n1,..)：可接受多个参数，返回最小值  </span><br><span class="line">Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 </span><br><span class="line">Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。  </span><br><span class="line">Math.log()：返回以e为底的自然对数值。</span><br><span class="line">Math.exp()：返回e的指数，也就是常数e的参数次方。</span><br><span class="line">Math.round()：四舍五入  </span><br><span class="line">Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。</span><br><span class="line">（3）三角函数方法</span><br><span class="line">Math.sin()：返回参数的正弦  </span><br><span class="line">Math.cos()：返回参数的余弦  </span><br><span class="line">Math.tan()：返回参数的正切  </span><br><span class="line">Math.asin()：返回参数的反正弦（弧度值）  </span><br><span class="line">Math.acos()：返回参数的反余弦（弧度值）  </span><br><span class="line">Math.atan()：返回参数的反正切（弧度值）</span><br><span class="line">3.6 JSON对象</span><br><span class="line">（1）方法</span><br><span class="line">JSON.stringify()   </span><br><span class="line">//用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。</span><br><span class="line">//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</span><br><span class="line">//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</span><br><span class="line"></span><br><span class="line">JSON.parse()   //用于将JSON字符串转化成对象。</span><br><span class="line">3.7 console对象</span><br><span class="line">（1）方法</span><br><span class="line">console.log(text,text2,...)   //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。</span><br><span class="line">console.info()   //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。</span><br><span class="line">console.debug()  //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。</span><br><span class="line">console.warn()  //输出信息时，在最前面加一个黄色三角，表示警告；</span><br><span class="line">console.error()  //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈</span><br><span class="line">console.table()  //可以将复合类型的数据转为表格显示。</span><br><span class="line">console.count()  //用于计数，输出它被调用了多少次。</span><br><span class="line">console.dir()    //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</span><br><span class="line">console.dirxml()  //用于以目录树的形式，显示DOM节点。</span><br><span class="line">console.assert()  //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</span><br><span class="line"></span><br><span class="line">//这两个方法用于计时，可以算出一个操作所花费的准确时间。</span><br><span class="line">console.time()</span><br><span class="line">console.timeEnd()</span><br><span class="line">//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。</span><br><span class="line"></span><br><span class="line">console.profile()  //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。</span><br><span class="line">console.profileEnd()  //用来结束正在运行的性能测试器。</span><br><span class="line"></span><br><span class="line">console.group()</span><br><span class="line">console.groupend()</span><br><span class="line">//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</span><br><span class="line">console.groupCollapsed()  //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</span><br><span class="line"></span><br><span class="line">console.trace()  //显示当前执行的代码在堆栈中的调用路径。</span><br><span class="line">console.clear()  //用于清除当前控制台的所有输出，将光标回置到第一行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正则表达式：</span><br><span class="line">只允许输入汉字：onkeyup=&quot;value=value.replace(/[^\u4E00-\u9FA5]/g,&apos;&apos;)&quot; </span><br><span class="line">只允许输入数字：onkeyup=&quot;this.value=this.value.replace(/\D/g,&apos;&apos;)&quot;</span><br><span class="line">[1, [2, [3, 4]]].toString() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure><h3 id="setTimeout-fn-0-的作用"><a href="#setTimeout-fn-0-的作用" class="headerlink" title="setTimeout(fn, 0) 的作用"></a>setTimeout(fn, 0) 的作用</h3><blockquote><p>setTimeout（0）单线程和异步队列<br>setTimeout和setInterval是JS内置的两个定时器，使用很简单，但这两个方法背后的原理却不简单。<br>我们知道，JS是单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)，<br>主线程会形成一个全局执行环境，执行环境采用栈的方式将待执行任务按顺序依次来执行。<br>但在浏览器中有一些任务是非常耗时的，比如http请求、定时器、事件回调等，为了保证其他任务的执行效率不被影响，<br>JS在执行环境中维护了一个异步队列(也叫工作线程)，并将这些任务放入队列中进行等待，这些任务的执行时机并不确定，<br>只有当主线程的任务执行完成以后，才会去检查异步队列中的任务是否需要开始执行。这就是为什么setTimeout(fn,0)<br> 始终要等到最后执行的原因。关于单线程和异步队列问题请参考：setTimeout（0）</p></blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(p, c) &#123;</span><br><span class="line">  var c = c || &#123;&#125;;</span><br><span class="line">  for (var i in p) &#123;</span><br><span class="line">    if (typeof p[i] === &apos;object&apos;) &#123;</span><br><span class="line">      c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class="line">      deepCopy(p[i], c[i]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      c[i] = p[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POST和GET的区别，HTTP状态码"><a href="#POST和GET的区别，HTTP状态码" class="headerlink" title="POST和GET的区别，HTTP状态码"></a>POST和GET的区别，HTTP状态码</h3><p><img src="/2015/01/01/JS原生常用API大全/a.webp" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST和GET的区别</span><br><span class="line">GET在浏览器回退时是无害的，而POST会再次提交请求</span><br><span class="line">GET产生的URL地址可以被收藏，而POST不可以</span><br><span class="line">GET请求会被浏览器主动缓存，而POST不会，除非手动设置</span><br><span class="line">GET请求只能进行URL编码，而POST支持多种编码方式</span><br><span class="line">GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留</span><br><span class="line">GET请求在URL中传送的参数是有长度限制的，而POST没有长度限制</span><br><span class="line">对参数的数据类型，GET只能请求ASCII字符，而POST没有限制</span><br><span class="line">GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传敏感信息</span><br><span class="line">GET参数通过URL传递，POST放在Request body中</span><br></pre></td></tr></table></figure></p><h3 id="Post-Get接口傻傻分不清？"><a href="#Post-Get接口傻傻分不清？" class="headerlink" title="Post,Get接口傻傻分不清？"></a><a href="https://juejin.im/post/5c0e610be51d45707261b10a" target="_blank" rel="noopener">Post,Get接口傻傻分不清？</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP状态码</span><br><span class="line">1XX：指示信息-表示请求已接受，继续处理</span><br><span class="line">2XX：成功-表示请求已被成功接收200 OK ：客户端请求成功</span><br><span class="line">206 Partial Content：客户发送一个带有Range头的GET请求，服务器完成了它 播放视频和音频</span><br><span class="line">3XX：重定向-要完成请求必须进行更进一步的操作301 Move Permanently：所请求的页面已经转移至新的URL</span><br><span class="line">302 Found：所请求的页面已经临时转移到新的URL</span><br><span class="line">304 Not Modified：客户端有缓冲的文档并发出一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用</span><br><span class="line">4XX：客户端错误-请求有语法错误或请求无法实现400 Bad Request：客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class="line">403 Forbidden：对被请求页面的访问被禁止</span><br><span class="line">404 Not Found：请求资源不存在</span><br><span class="line">5XX：服务错误-服务器未能实现合法的请求500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</span><br><span class="line">503 Server Unavailable：请求未完成，服务器临时过载或当机，一段事件后恢复正常</span><br></pre></td></tr></table></figure><h3 id="301和302"><a href="#301和302" class="headerlink" title="301和302"></a>301和302</h3><blockquote><font color="#ff0000"><strong> 301与302：二者都是进行重定向，前者为永久重定向，后者为临时重定向。301，302对用户来说没有区别，他们看到效果只是一个跳转，浏览器中旧的URL变成了新的URL。实际工作中，当我们的前一个域名被永久性停止使用，并且不希望用户还能访问以前的域名时，我们会用到301。</strong></font></blockquote><blockquote><font color="#0000ff">301和302状态码都表示重定向，<span style="border-bottom:2px solid red;">就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。</span>他们的不同在于:301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了）， 搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；302表示旧地址A的资源还在（仍然可以访问）， 这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。</font></blockquote><p><strong> 301重定向和302重定向的区别: </strong></p><ul><li>302重定向只是暂时的重定向，搜索引擎会抓取新的内容而保留旧的地址，因为服务器返回302，所以，搜索搜索引擎认为新的网址是暂时的。</li><li>而301重定向是永久的重定向，搜索引擎在抓取新的内容的同时也将旧的网址替换为了重定向之后的网址。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">301适合永久重定向</span><br><span class="line">　　301比较常用的场景是使用域名跳转。</span><br><span class="line">       比如，我们访问 http://www.baidu.com 会跳转到 https://www.baidu.com，</span><br><span class="line">        发送请求之后，就会返回301状态码，</span><br><span class="line">       然后返回一个location，提示新的地址，浏览器就会拿着这个新的地址去访问。 </span><br><span class="line">　　注意： 301请求是可以缓存的， 即通过看status code，可以发现后面写着from cache。</span><br><span class="line">　    或者你把你的网页的名称从php修改为了html，这个过程中，也会发生永久重定向。</span><br><span class="line"></span><br><span class="line">302用来做临时跳转</span><br><span class="line">　　比如未登陆的用户访问用户中心重定向到登录页面。</span><br><span class="line">　　访问404页面会重新定向到首页。</span><br></pre></td></tr></table></figure><p><img src="/2015/01/01/JS原生常用API大全/1_20181206205202.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">301—永久移动。被请求的资源已被永久移动位置； 【永久重定向】</span><br><span class="line">302—请求的资源现在临时从不同的 URI 响应请求；  【临时重定向】</span><br><span class="line">305—使用代理。被请求的资源必须通过指定的代理才能被访问； </span><br><span class="line">307—临时跳转。被请求的资源在临时从不同的URL响应请求； </span><br><span class="line">400—错误请求； </span><br><span class="line">402—需要付款。该状态码是为了将来可能的需求而预留的，用于一些数字货币或者是微支付； </span><br><span class="line">403—禁止访问。服务器已经理解请求，但是拒绝执行它； </span><br><span class="line">404—找不到对象。请求失败，资源不存在； </span><br><span class="line">406—不可接受的。请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体； </span><br><span class="line">408—请求超时； </span><br><span class="line">409—冲突。由于和被请求的资源的当前状态之间存在冲突，请求无法完成； </span><br><span class="line">410—遗失的。被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址； </span><br><span class="line">413—响应实体太大。服务器拒绝处理当前请求，请求超过服务器所能处理和允许的最大值。 </span><br><span class="line">417—期望失败。在请求头 Expect 中指定的预期内容无法被服务器满足； </span><br><span class="line">418—我是一个茶壶。超文本咖啡罐控制协议，但是并没有被实际的HTTP服务器实现； </span><br><span class="line">420—方法失效。 </span><br><span class="line">422—不可处理的实体。请求格式正确，但是由于含有语义错误，无法响应； </span><br><span class="line">500—服务器内部错误。服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理；</span><br></pre></td></tr></table></figure></p><h3 id="JS返回所有子节点对象childNodes"><a href="#JS返回所有子节点对象childNodes" class="headerlink" title="JS返回所有子节点对象childNodes"></a>JS返回所有子节点对象childNodes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var mylist = document.getElementById(&apos;myid&apos;);</span><br><span class="line">for(var i=0,i&lt;mylist.childNodes.length;i++)&#123;</span><br><span class="line">console.log(mylist.childNodes[i]);</span><br><span class="line">&#125;</span><br><span class="line">firstChild返回第一个子节点</span><br><span class="line">lastChild返回最后一个子节点</span><br><span class="line">parentNode返回父节点对象</span><br><span class="line">nextSibling返回下一个兄弟节点对象</span><br><span class="line">previousSibling返回前一个兄弟节点对象</span><br><span class="line">nodeName返回节点的HTML标记名称</span><br></pre></td></tr></table></figure><h3 id="insertBefore-插入节点（父节点内容的最前面）"><a href="#insertBefore-插入节点（父节点内容的最前面）" class="headerlink" title="insertBefore()插入节点（父节点内容的最前面）"></a>insertBefore()插入节点（父节点内容的最前面）</h3><p>注意：insertBefore()有两个参数，第一个是插入的节点，第二个是插入的位置</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var list = document.getElementById(&apos;myList&apos;);</span><br><span class="line">list.insertBefore(newItem,list.childNodes[1]);</span><br><span class="line">//插入新节点newItem到list的第二个子节点</span><br></pre></td></tr></table></figure></p><h3 id="Element-matches-精确匹配"><a href="#Element-matches-精确匹配" class="headerlink" title="Element.matches 精确匹配"></a>Element.matches 精确匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&apos;list&apos;).addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  var event = e || window.event;</span><br><span class="line">  var target = event.target || event.srcElement;</span><br><span class="line">  if (target.matches(&apos;li.class-1&apos;)) &#123;</span><br><span class="line">    console.log(&apos;the content is: &apos;, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="移动端touch事件-区分webkit-和-winphone"><a href="#移动端touch事件-区分webkit-和-winphone" class="headerlink" title="移动端touch事件(区分webkit 和 winphone)"></a>移动端touch事件(区分webkit 和 winphone)</h3><blockquote><p>当用户手指放在移动设备在屏幕上滑动会触发的touch事件,以下支持webkit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">touchstart——当手指触碰屏幕时候发生。不管当前有多少只手指</span><br><span class="line">touchmove——当手指在屏幕上滑动时连续触发。通常我们再滑屏页面，会调用event的preventDefault()可以阻止默认情况的发生：阻止页面滚动</span><br><span class="line">touchend——当手指离开屏幕时触发</span><br><span class="line">touchcancel——系统停止跟踪触摸时候会触发。例如在触摸过程中突然页面alert()一个提示框，此时会触发该事件，这个事件比较少用TouchEvent</span><br><span class="line">touches：屏幕上所有手指的信息</span><br><span class="line">targetTouches：手指在目标区域的手指信息</span><br><span class="line">changedTouches：最近一次触发该事件的手指信息</span><br><span class="line">touchend时，touches与targetTouches信息会被删除，changedTouches保存的最后一次的信息，最好用于计算手指信息参数信息(changedTouches[0])</span><br><span class="line">clientX、clientY在显示区的坐标</span><br><span class="line">target：当前元素</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="全局错误监控"><a href="#全局错误监控" class="headerlink" title="全局错误监控"></a>全局错误监控</h3><p>监听window上的error事件，过滤事件代理的error。</p><h3 id="手动触发一个dom事件，需要3步，如果你对document-createEvent-�不是很熟悉，可以点击查看。"><a href="#手动触发一个dom事件，需要3步，如果你对document-createEvent-�不是很熟悉，可以点击查看。" class="headerlink" title="手动触发一个dom事件，需要3步，如果你对document.createEvent,�不是很熟悉，可以点击查看。"></a>手动触发一个dom事件，需要3步，如果你对document.createEvent,�不是很熟悉，可以点击查看。</h3><p>创建一个事件对象 document.createEvent(event)<br>初始化事件对象 event.initEvent(type, bubbles, true)<br>分发事件 dom.dispatchEvent(event)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Object.preventExtensions(obj)  让一个对象变的不可扩展，也就是永远不能再添加新的属性。</span><br><span class="line">Object.isExtensible(obj) 判断一个对象是否是可扩展的</span><br><span class="line">Object.seal(obj)让一个对象密封(只能读写 不能新增)</span><br><span class="line">Object.isSealed(obj)判断一个对象是否密封</span><br><span class="line">Object.isFrozen(arr)  让一个对象被冻结(只能读)</span><br><span class="line">Object.isFrozen(obj)：判断一个对象是否被冻结</span><br><span class="line">Object.keys(obj) 返回一个由给定对象的所有可枚举自身属性的属性名组成的数组</span><br><span class="line">Object.getOwnPropertyNames(obj)：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组</span><br><span class="line">Object.is(value1, value2)：判断两个值是否是同一个值,Object.is它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</span><br><span class="line">Object.create(proto [, propertiesObject ]) 是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个参数是对象的属性描述符，这个参数是可选的。</span><br><span class="line">Object.assign 把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。【浅复制】</span><br><span class="line">//var copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">Object.defineProperty() 定义单个对象属性或方法(可以设置读写可枚举)</span><br><span class="line">Object.defineProperties() 定义多个对象属性或方法(可以设置读写可枚举)</span><br><span class="line"></span><br><span class="line">Object.assign() //浅拷贝，类似&#123;...obj1,...obj2&#125; 都是浅拷贝</span><br><span class="line">Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）</span><br><span class="line"></span><br><span class="line">var target = &#123; a: 1 &#125;;</span><br><span class="line">var source1 = &#123; b: 2 &#125;;</span><br><span class="line">var source2 = &#123; c: 3 &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target // &#123;a:1, b:2, c:3&#125;</span><br><span class="line"></span><br><span class="line">//如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</span><br><span class="line"></span><br><span class="line">Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</span><br><span class="line"></span><br><span class="line">var obj1 = &#123;a: &#123;b: 1&#125;&#125;;</span><br><span class="line">var obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class="line">obj1.a.b = 2;</span><br><span class="line">obj2.a.b // 2</span><br><span class="line"></span><br><span class="line">对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。</span><br><span class="line">var target = &#123; a: &#123; b: &apos;c&apos;, d: &apos;e&apos; &#125; &#125;</span><br><span class="line">var source = &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line">Object.assign(target, source)</span><br><span class="line">// &#123; a: &#123; b: &apos;hello&apos; &#125; &#125;</span><br><span class="line"></span><br><span class="line">停止jq中的ajax请求用abort()函数  </span><br><span class="line">  </span><br><span class="line">var currentAjax = null;  </span><br><span class="line">functionstartAjax()&#123;  </span><br><span class="line">    //方法就是将XHR对象指向currentAjax，再调用currentAjax的.abort()来中止请求  </span><br><span class="line">    currentAjax = $.ajax(&#123;  </span><br><span class="line">           type:&apos;POST&apos;,  </span><br><span class="line">           beforeSend:function()&#123;&#125;,  </span><br><span class="line">           url:&apos;test.php&apos;,  </span><br><span class="line">           data:&apos;username=xxx&apos;,  </span><br><span class="line">           dataType:&apos;JSON&apos;,  </span><br><span class="line">           error:function()&#123;alert(&apos;error&apos;)&#125;,  </span><br><span class="line">           success:function(data)&#123;alert(data)&#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">functionstopAjax()&#123;  </span><br><span class="line">    //如若上一次AJAX请求未完成，则中止请求  </span><br><span class="line">    if(currentAjax) &#123;currentAjax.abort();&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSONP 超时：</span><br><span class="line"></span><br><span class="line">  设置超时标志位flag=false，当超时后将flag=true;</span><br><span class="line">  异步加载JS文件并执行回调函数：</span><br><span class="line">  </span><br><span class="line">  function loadJS(src, callback)&#123;</span><br><span class="line">    var script = document.createElement(&apos;script&apos;);</span><br><span class="line">    var head = document.getElementsByTagName(&apos;head&apos;)[0];</span><br><span class="line">    var loaded;</span><br><span class="line">    script.src = src;</span><br><span class="line">    if(typeof callback === &apos;function&apos;)&#123;</span><br><span class="line">        script.onload = script.onreadystatechange = function()&#123;</span><br><span class="line">            if(!loaded &amp;&amp; (!script.readyState || /loaded|complete/.test(script.readyState)))&#123;</span><br><span class="line">                script.onload = script.onreadystatechange = null;</span><br><span class="line">                loaded = true;</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    head.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取元素的绝对位置"><a href="#获取元素的绝对位置" class="headerlink" title="获取元素的绝对位置"></a>获取元素的绝对位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function getPosition(node) &#123;</span><br><span class="line">var width = node.offsetWidth; //元素宽度</span><br><span class="line">var height = node.offsetHeight; //元素高度</span><br><span class="line">var left = node.offsetLeft; //获取元素相对于其根元素的left值var left</span><br><span class="line">var top = node.offsetTop; //获取元素相对于其根元素的top值var top</span><br><span class="line">current = node.offsetParent; // 取得元素的offsetParent</span><br><span class="line"></span><br><span class="line">// 一直循环直到根元素　　</span><br><span class="line">while(current != null) &#123;　　</span><br><span class="line">left += current.offsetLeft;　　</span><br><span class="line">top += current.offsetTop;　　</span><br><span class="line">current = current.offsetParent;　　</span><br><span class="line">&#125;</span><br><span class="line">return &#123;</span><br><span class="line">&quot;width&quot;: width,</span><br><span class="line">&quot;height&quot;: height,</span><br><span class="line">&quot;left&quot;: left,</span><br><span class="line">&quot;top&quot;: top</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动画结束时事件"><a href="#动画结束时事件" class="headerlink" title="动画结束时事件"></a>动画结束时事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">o.addEventListener(&quot;webkitAnimationEnd&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画结束&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">-webkit-animation动画有三个事件：</span><br><span class="line">开始事件: webkitAnimationStart</span><br><span class="line">结束事件:  webkitAnimationEnd</span><br><span class="line">重复运动事件: webkitAnimationIteration// 动画开始时事件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o.addEventListener(&quot;webkitAnimationStart&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画开始&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 动画重复运动时事件</span><br><span class="line">o.addEventListener(&quot;webkitAnimationIteration&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画重复运动&quot;);</span><br><span class="line">&#125;)</span><br><span class="line">// 动画结束时事件</span><br><span class="line">o.addEventListener(&quot;webkitAnimationEnd&quot;, function() &#123;</span><br><span class="line">    console.log(&quot;动画结束&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="解决键盘弹出遮挡："><a href="#解决键盘弹出遮挡：" class="headerlink" title="解决键盘弹出遮挡："></a>解决键盘弹出遮挡：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 解决键盘弹出后挡表单的问题</span><br><span class="line">window.addEventListener(&apos;resize&apos;, function() &#123;</span><br><span class="line">if(</span><br><span class="line">document.activeElement.tagName === &apos;INPUT&apos; ||</span><br><span class="line">document.activeElement.tagName === &apos;TEXTAREA&apos;</span><br><span class="line">) &#123;</span><br><span class="line">window.setTimeout(function() &#123;</span><br><span class="line">if(&apos;scrollIntoView&apos; in document.activeElement) &#123;</span><br><span class="line">document.activeElement.scrollIntoView();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">document.activeElement.scrollIntoViewIfNeeded();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 处理iOS 微信客户端6.7.4 键盘收起页面未下移bug</span><br><span class="line"> */</span><br><span class="line">;(/iphone|ipod|ipad/i.test(navigator.appVersion)) &amp;&amp; document.addEventListener(&apos;blur&apos;, (e) =&gt; &#123;</span><br><span class="line">  document.body.scrollIntoView(false)</span><br><span class="line">&#125;, true)</span><br></pre></td></tr></table></figure><h3 id="单个for循环实现排序："><a href="#单个for循环实现排序：" class="headerlink" title="单个for循环实现排序："></a>单个for循环实现排序：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a = [12, 13, 65, 54, 86, 21, 37, 1, 95, 4];</span><br><span class="line">var l=a.length;</span><br><span class="line">for(var i = 0; i &lt; l; i++) &#123;</span><br><span class="line">if(a[i] &gt; a[i + 1]) &#123;</span><br><span class="line">var tem = a[i];</span><br><span class="line">a[i] = a[i + 1];</span><br><span class="line">a[i + 1] = tem;</span><br><span class="line">&#125;</span><br><span class="line">if(i == l - 1) &#123;</span><br><span class="line">i = -1;</span><br><span class="line">l--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure><h3 id="Object-assign实现"><a href="#Object-assign实现" class="headerlink" title="Object.assign实现:"></a>Object.assign实现:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">if (!Object.assign) &#123;</span><br><span class="line">    // 定义assign方法</span><br><span class="line">  Object.defineProperty(Object, &apos;assign&apos;, &#123;</span><br><span class="line">    enumerable: false,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">    value: function(target) &#123; // assign方法的第一个参数</span><br><span class="line">      &apos;use strict&apos;;</span><br><span class="line">      // 第一个参数为空，则抛错</span><br><span class="line">      if (target === undefined || target === null) &#123;</span><br><span class="line">        throw new TypeError(&apos;Cannot convert first argument to object&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var to = Object(target);</span><br><span class="line">      // 遍历剩余所有参数</span><br><span class="line">      for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        var nextSource = arguments[i];</span><br><span class="line">        // 参数为空，则跳过，继续下一个</span><br><span class="line">        if (nextSource === undefined || nextSource === null) &#123;</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        nextSource = Object(nextSource);</span><br><span class="line"></span><br><span class="line">        // 获取改参数的所有key值，并遍历</span><br><span class="line">        var keysArray = Object.keys(nextSource);</span><br><span class="line">        for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) &#123;</span><br><span class="line">          var nextKey = keysArray[nextIndex];</span><br><span class="line">          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);</span><br><span class="line">          // 如果不为空且可枚举，则直接浅拷贝赋值</span><br><span class="line">          if (desc !== undefined &amp;&amp; desc.enumerable) &#123;</span><br><span class="line">            to[nextKey] = nextSource[nextKey];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return to;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript中巧用位运算"><a href="#JavaScript中巧用位运算" class="headerlink" title="JavaScript中巧用位运算"></a>JavaScript中巧用位运算</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">日常前端开发中我们很少用到位运算，容易让人遗忘，让我们一起回顾下一下js中的位运算。</span><br><span class="line">位运算详细说明查看JavaScript|MDN</span><br><span class="line">下面主要回顾一下一些常用的位运算的巧用。</span><br><span class="line">将十进制转化为二进制</span><br><span class="line">var number = 3;</span><br><span class="line">var result = number.toString(2);</span><br><span class="line"></span><br><span class="line">var result2 = 14..toString(2); // &quot;1110&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们使用位运算来代替Math.floor()来向下取整</span><br><span class="line">var data = 2.2352524535;</span><br><span class="line">var result = data | 0; // 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var re2 = ~~data; // 2</span><br></pre></td></tr></table></figure><h3 id="将颜色从RGA转换为Hex格式"><a href="#将颜色从RGA转换为Hex格式" class="headerlink" title="将颜色从RGA转换为Hex格式"></a>将颜色从RGA转换为Hex格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var color = &#123;r: 186, g: 218, b: 85&#125;;</span><br><span class="line"></span><br><span class="line">// RGB to HEX</span><br><span class="line">var rgb2hex = function(r, g, b) &#123;</span><br><span class="line">    return &apos;#&apos; + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).substr(1);</span><br><span class="line">&#125;</span><br><span class="line">rgb2hex(color.r, color.g, color.b);//&quot;#bada55&quot;</span><br></pre></td></tr></table></figure><h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">/*========================常用函数========================*/</span><br><span class="line"></span><br><span class="line">/*时间格式化*/</span><br><span class="line">Date.prototype.Format = function (fmt) &#123;</span><br><span class="line">    var o = &#123;</span><br><span class="line">        &quot;M+&quot;: this.getMonth() + 1, /*月份*/</span><br><span class="line">        &quot;d+&quot;: this.getDate(), /*日*/</span><br><span class="line">        &quot;h+&quot;: this.getHours(), /*小时*/</span><br><span class="line">        &quot;m+&quot;: this.getMinutes(), /*分*/</span><br><span class="line">        &quot;s+&quot;: this.getSeconds(), /*秒*/</span><br><span class="line">        &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), /*季度*/</span><br><span class="line">        &quot;S&quot;: this.getMilliseconds() /*毫秒*/</span><br><span class="line">    &#125;;</span><br><span class="line">    if (/(y+)/.test(fmt))</span><br><span class="line">        fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));</span><br><span class="line">    for (var k in o)</span><br><span class="line">        if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt))</span><br><span class="line">            fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));</span><br><span class="line">    return fmt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/*IE浏览器不支持date(time),所以用此方法转换*/</span><br><span class="line">function NewDate(fmt) &#123;</span><br><span class="line">    /*首先将日期分隔 ，获取到日期部分 和 时间部分*/</span><br><span class="line">    var day = fmt.split(&apos; &apos;);</span><br><span class="line">    /*获取日期部分的年月日*/</span><br><span class="line">    var days = day[0].split(&apos;-&apos;);</span><br><span class="line">    /*获取时间部分的 时分秒*/</span><br><span class="line">    var mi = day[day.length - 1].split(&apos;:&apos;);</span><br><span class="line">    /*获取当前date类型日期*/</span><br><span class="line">    var date = new Date();</span><br><span class="line">    /*给date赋值  年月日*/</span><br><span class="line">    date.setUTCFullYear(days[0], days[1] - 1, days[2]);</span><br><span class="line">    /*给date赋值 时分秒  首先转换utc时区 ：+8*/</span><br><span class="line">    date.setUTCHours(mi[0] - 8, mi[1], mi[2]);</span><br><span class="line">    return date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*为空判断*/</span><br><span class="line">function isEmpty(s) &#123;</span><br><span class="line">    switch (typeof(s)) &#123;</span><br><span class="line">        case &apos;string&apos;:</span><br><span class="line">            return !s.length;</span><br><span class="line">            break;</span><br><span class="line">        case &apos;array&apos;:</span><br><span class="line">        case &apos;object&apos;:</span><br><span class="line">            for (var i in s) return false;</span><br><span class="line">            return true;</span><br><span class="line">            break;</span><br><span class="line">        case &apos;undefined&apos;:</span><br><span class="line">            return true;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return !s;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*数字判断*/</span><br><span class="line">function isNumber(s) &#123;</span><br><span class="line">    return typeof(s) == &apos;number&apos; ? true : false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*整数判断*/</span><br><span class="line">function isInt(s) &#123;</span><br><span class="line">    var re = /^-?\d*$/;</span><br><span class="line">    return re.test(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*正整数判断*/</span><br><span class="line">function isUInt(s) &#123;</span><br><span class="line">    var re = /^\d*$/;</span><br><span class="line">    return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*小数判断*/</span><br><span class="line">function isDecimal(s, bit) &#123;</span><br><span class="line">    if (!arguments[1]) bit = -1;</span><br><span class="line">    if (bit == -1) &#123;</span><br><span class="line">        var re = /^-?\d*.?\d*$/;</span><br><span class="line">        return re.test(s);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var re = new RegExp(&apos;^-?\\d*.?\\d&#123;0,&apos; + bit + &apos;&#125;$&apos;);</span><br><span class="line">        return re.test(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*正小数判断*/</span><br><span class="line">function isUDecimal(s, bit) &#123;</span><br><span class="line">    if (!arguments[1]) bit = -1;</span><br><span class="line">    if (bit == -1) &#123;</span><br><span class="line">        var re = /^\d*.?\d*$/;</span><br><span class="line">        return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        var re = new RegExp(&apos;^\\d*.?\\d&#123;0,&apos; + bit + &apos;&#125;$&apos;);</span><br><span class="line">        return re.test(s) &amp;&amp; s &gt;= 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*字符串判断*/</span><br><span class="line">function isString(s) &#123;</span><br><span class="line">    return typeof(s) == &apos;string&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*========================/常用函数========================*/</span><br><span class="line"></span><br><span class="line">js onkeyup replace 自动替换</span><br><span class="line"></span><br><span class="line">检测浮点数 只能是整数或者小数 </span><br><span class="line">多余的就replace 掉 的表单验证</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function checkFloatNum(obj)</span><br><span class="line">&#123;</span><br><span class="line">    //先把非数字的都替换掉，除了数字和.</span><br><span class="line">    obj.value = obj.value.replace(/[^\d.]/g,&quot;&quot;);</span><br><span class="line">    //必须保证第一个为数字而不是.</span><br><span class="line">    obj.value = obj.value.replace(/^\./g,&quot;&quot;);</span><br><span class="line">    //保证只有出现一个.而没有多个.</span><br><span class="line">    obj.value = obj.value.replace(/\.&#123;2,&#125;/g,&quot;.&quot;);</span><br><span class="line">    //保证.只出现一次，而不能出现两次以上</span><br><span class="line">    obj.value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">;</span><br><span class="line">(function() &#123;</span><br><span class="line"></span><br><span class="line">handleAddListener(&apos;load&apos;, getTiming)</span><br><span class="line"></span><br><span class="line">function handleAddListener(type, fn) &#123;</span><br><span class="line">if(window.addEventListener) &#123;</span><br><span class="line">window.addEventListener(type, fn)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">window.attachEvent(&apos;on&apos; + type, fn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getTiming() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var time = performance.timing;</span><br><span class="line">var timingObj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var loadTime = (time.loadEventEnd - time.loadEventStart) / 1000;</span><br><span class="line"></span><br><span class="line">if(loadTime &lt; 0) &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">getTiming();</span><br><span class="line">&#125;, 200);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timingObj[&apos;重定向时间&apos;] = (time.redirectEnd - time.redirectStart) / 1000;</span><br><span class="line">timingObj[&apos;DNS解析时间&apos;] = (time.domainLookupEnd - time.domainLookupStart) / 1000;</span><br><span class="line">timingObj[&apos;TCP完成握手时间&apos;] = (time.connectEnd - time.connectStart) / 1000;</span><br><span class="line">timingObj[&apos;HTTP请求响应完成时间&apos;] = (time.responseEnd - time.requestStart) / 1000;</span><br><span class="line">timingObj[&apos;DOM开始加载前所花费时间&apos;] = (time.responseEnd - time.navigationStart) / 1000;</span><br><span class="line">timingObj[&apos;DOM加载完成时间&apos;] = (time.domComplete - time.domLoading) / 1000;</span><br><span class="line">timingObj[&apos;DOM结构解析完成时间&apos;] = (time.domInteractive - time.domLoading) / 1000;</span><br><span class="line">timingObj[&apos;脚本加载时间&apos;] = (time.domContentLoadedEventEnd - time.domContentLoadedEventStart) / 1000;</span><br><span class="line">timingObj[&apos;onload事件时间&apos;] = (time.loadEventEnd - time.loadEventStart) / 1000;</span><br><span class="line">timingObj[&apos;页面完全加载时间&apos;] = (timingObj[&apos;重定向时间&apos;] + timingObj[&apos;DNS解析时间&apos;] + timingObj[&apos;TCP完成握手时间&apos;] + timingObj[&apos;HTTP请求响应完成时间&apos;] + timingObj[&apos;DOM结构解析完成时间&apos;] + timingObj[&apos;DOM加载完成时间&apos;]);</span><br><span class="line"></span><br><span class="line">for(item in timingObj) &#123;</span><br><span class="line">console.log(item + &quot;:&quot; + timingObj[item] + &apos;毫秒(ms)&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(performance.timing);</span><br><span class="line"></span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">console.log(timingObj)</span><br><span class="line">console.log(performance.timing);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default class Cookie &#123;</span><br><span class="line">//写cookies</span><br><span class="line">static setCookie = (name, value) =&gt; &#123;</span><br><span class="line">var Days = 30;</span><br><span class="line">var exp = new Date();</span><br><span class="line">exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000);</span><br><span class="line">document.cookie = name + &quot;=&quot; + escape(value) + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">&#125;</span><br><span class="line">//读取cookies </span><br><span class="line">static getCookie = (name) =&gt; &#123;</span><br><span class="line">var arr, reg = new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;);</span><br><span class="line">if(arr = document.cookie.match(reg))</span><br><span class="line">return unescape(arr[2]);</span><br><span class="line">else</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除cookies </span><br><span class="line">static delCookie = (name) =&gt; &#123;</span><br><span class="line">var exp = new Date();</span><br><span class="line">exp.setTime(exp.getTime() - 1);</span><br><span class="line">var cval = getCookie(name);</span><br><span class="line">if(cval != null)</span><br><span class="line">document.cookie = name + &quot;=&quot; + cval + &quot;;expires=&quot; + exp.toGMTString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    function jsonp(objects)&#123;</span><br><span class="line">        objects = objects || &#123;&#125;;</span><br><span class="line">        if(!objects.url || !objects.callback)&#123;</span><br><span class="line">            throw new Error(&apos;参数不合法&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建script标签并插入</span><br><span class="line">        var callbackName =  (&apos;jsonp_&apos; + Math.random()).replace(&quot;.&quot;, &quot;&quot;);//随机生成callbackName</span><br><span class="line"></span><br><span class="line">        var script = document.createElement(&apos;script&apos;);</span><br><span class="line">        var body = document.getElementsByTagName(&apos;body&apos;)[0];</span><br><span class="line">        body.appendChild(script);</span><br><span class="line"></span><br><span class="line">        window[callbackName] = function (json) &#123;</span><br><span class="line">            body.removeChild(script);</span><br><span class="line">            clearTimeout(script.timer);</span><br><span class="line">            window[callbackName] = null;</span><br><span class="line">            objects.callback &amp;&amp; objects.callback(json);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        //发出请求</span><br><span class="line">        script.src = objects.url + callbackName;</span><br><span class="line"></span><br><span class="line">        //响应时间</span><br><span class="line">        if(objects.time)&#123;</span><br><span class="line">            script.timer = setTimeout(function () &#123;</span><br><span class="line">                window[callbackName] = null;</span><br><span class="line">                body.removeChild(script);</span><br><span class="line">                objects.fail &amp;&amp; objects.fail(&apos;超时&apos;);</span><br><span class="line">            &#125;, objects.time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js判断DOM是否包含另一个DOM"><a href="#js判断DOM是否包含另一个DOM" class="headerlink" title="js判断DOM是否包含另一个DOM"></a>js判断DOM是否包含另一个DOM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">.first&#123;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 200px;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br><span class="line">.first-child&#123;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background: green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;first&quot;&gt;</span><br><span class="line">&lt;div class=&quot;first-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;second&quot;&gt;</span><br><span class="line">&lt;div class=&quot;second-child&quot;&gt;</span><br><span class="line">&lt;div class=&quot;second-child-child&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">var first = document.querySelector(&apos;.first&apos;);</span><br><span class="line">var firstchild = document.querySelector(&apos;.first-child&apos;);</span><br><span class="line"></span><br><span class="line">var second = document.querySelector(&apos;.second&apos;);</span><br><span class="line">var secondchild = document.querySelector(&apos;.second-child&apos;);</span><br><span class="line">var secondchildchild = document.querySelector(&apos;.second-child-child&apos;);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function isChildOf(child, parent) &#123;</span><br><span class="line">var parentNode;</span><br><span class="line">if(child &amp;&amp; parent) &#123;</span><br><span class="line">parentNode = child.parentNode;</span><br><span class="line">while(parentNode) &#123;</span><br><span class="line">if(parent === parentNode) &#123;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">parentNode = parentNode.parentNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(isChildOf(firstchild, first));</span><br><span class="line">console.log(isChildOf(secondchild, second));</span><br><span class="line">console.log(isChildOf(secondchildchild, secondchild));</span><br><span class="line">console.log(isChildOf(secondchildchild, second));</span><br><span class="line"></span><br><span class="line">console.log(isChildOf(secondchildchild, first));</span><br><span class="line"></span><br><span class="line">console.log(document.documentElement.contains(document.body));</span><br><span class="line">console.log(second.contains(secondchildchild));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="回到顶部带动画"><a href="#回到顶部带动画" class="headerlink" title="回到顶部带动画"></a>回到顶部带动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">/* 滚动条动画：</span><br><span class="line"> * 移动端:document.body.scrollTop</span><br><span class="line">   PC端：document.documentElement.scrollTop</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //使用:gotoTop(400,callBack)</span><br><span class="line">   gotoTop(durations,  callback = undefined) &#123;</span><br><span class="line">      const doc = document.documentElement</span><br><span class="line">      const scrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)</span><br><span class="line">      for (var i = 60; i &gt;= 0; i--) &#123;</span><br><span class="line">        setTimeout((i =&gt; &#123;</span><br><span class="line">          return () =&gt; &#123;</span><br><span class="line">            doc.scrollTop = scrollTop * i / 60</span><br><span class="line">            if (i === 0 &amp;&amp; typeof callback === &apos;function&apos;) &#123;</span><br><span class="line">              callback()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i), durations * (1 - i / 60))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"> * */</span><br><span class="line">var requestAnimFrame = (function() &#123;</span><br><span class="line">return window.requestAnimationFrame ||</span><br><span class="line">window.webkitRequestAnimationFrame ||</span><br><span class="line">window.mozRequestAnimationFrame ||</span><br><span class="line">function(callback) &#123;</span><br><span class="line">window.setTimeout(callback, 1000 / 60);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)();</span><br><span class="line">var cancelAnimationFrame = (function() &#123;</span><br><span class="line">return window.cancelAnimationFrame ||</span><br><span class="line">window.webkitCancelAnimationFrame ||</span><br><span class="line">window.mozCancelAnimationFrame ||</span><br><span class="line">window.oCancelAnimationFrame ||</span><br><span class="line">function(id) &#123;</span><br><span class="line">window.clearTimeout(id)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// Tween中的方法接受4个参数t,b,c,d 。t为初始时间 b、c、d三个参数（即初始值，变化量，持续时间）。返回值为当前位置</span><br><span class="line">// t =&gt; time(初始记步次数)  b =&gt; begin(初始位置)   c =&gt; change(变化量)   d =&gt; duration(持续次数)</span><br><span class="line"></span><br><span class="line">var tween = &#123;</span><br><span class="line">linear: function(t, b, c, d) &#123;</span><br><span class="line">return c * t / d + b;</span><br><span class="line">&#125;,</span><br><span class="line">easeIn: function(t, b, c, d) &#123;</span><br><span class="line">return c * (t /= d) * t + b;</span><br><span class="line">&#125;,</span><br><span class="line">strongEaseIn: function(t, b, c, d) &#123;</span><br><span class="line">return c * (t /= d) * t * t * t * t + b;</span><br><span class="line">&#125;,</span><br><span class="line">strongEaseOut: function(t, b, c, d) &#123;</span><br><span class="line">return c * ((t = t / d - 1) * t * t * t * t + 1) + b;</span><br><span class="line">&#125;,</span><br><span class="line">sineaseIn: function(t, b, c, d) &#123;</span><br><span class="line">return c * (t /= d) * t * t + b;</span><br><span class="line">&#125;,</span><br><span class="line">sineaseOut: function(t, b, c, d) &#123;</span><br><span class="line">return c * ((t = t / d - 1) * t * t + 1) + b;</span><br><span class="line">&#125;,</span><br><span class="line">easeInOutQuad: function(t, b, c, d) &#123;</span><br><span class="line">t /= d / 2;</span><br><span class="line">if(t &lt; 1) return c / 2 * t * t + b;</span><br><span class="line">t--;</span><br><span class="line">return -c / 2 * (t * (t - 2) - 1) + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var myReq; </span><br><span class="line">export var animatedScrollTo = function(element, to, duration, callback, Bzr = &apos;linear&apos;) &#123;</span><br><span class="line">var start = element.scrollTop,</span><br><span class="line">change = to - start,</span><br><span class="line">animationStart = +new Date();</span><br><span class="line">var animating = true;</span><br><span class="line">var lastpos = null;</span><br><span class="line"></span><br><span class="line">var animateScroll = function() &#123;</span><br><span class="line">if(!animating) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">myReq=requestAnimFrame(animateScroll);</span><br><span class="line">var now = +new Date();</span><br><span class="line">var val = Math.floor(tween[Bzr](now - animationStart, start, change, duration));</span><br><span class="line"></span><br><span class="line">if(lastpos) &#123;</span><br><span class="line">if(lastpos === element.scrollTop) &#123;</span><br><span class="line">lastpos = val;</span><br><span class="line">element.scrollTop = val;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">animating = false;</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">lastpos = val;</span><br><span class="line">element.scrollTop = val;</span><br><span class="line">&#125;</span><br><span class="line">if(now &gt; animationStart + duration) &#123;</span><br><span class="line">element.scrollTop = to;</span><br><span class="line">animating = false;</span><br><span class="line">cancelAnimationFrame(myReq);   //清除定时器动画</span><br><span class="line">callback&amp;&amp;callback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">myReq=requestAnimFrame(animateScroll);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用js唤起Native下的App"><a href="#使用js唤起Native下的App" class="headerlink" title="使用js唤起Native下的App"></a>使用js唤起Native下的App</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 浏览器的相关信息</span><br><span class="line"> */</span><br><span class="line">var Browser = /** @class */ (function() &#123;</span><br><span class="line">function Browser() &#123;&#125;</span><br><span class="line">/**</span><br><span class="line"> * 获取浏览器数据</span><br><span class="line"> */</span><br><span class="line">Browser.getBrowser = function() &#123;</span><br><span class="line">var UA = navigator.userAgent || &apos;&apos;</span><br><span class="line">var isAndroid = (function() &#123;</span><br><span class="line">return UA.match(/Android/i) ? true : false</span><br><span class="line">&#125;)()</span><br><span class="line">var isQQ = (function() &#123;</span><br><span class="line">return /(iPad|iPhone|iPod).*? (IPad)?QQ\/([\d\.]+)/.test(UA) || /\bV1_AND_SQI?_([\d\.]+)(.*? QQ\/([\d\.]+))?/.test(UA)</span><br><span class="line">&#125;)()</span><br><span class="line">var isIOS = (function() &#123;</span><br><span class="line">return UA.match(/iPhone|iPad|iPod/i) ? true : false</span><br><span class="line">&#125;)()</span><br><span class="line">var isSafari = (function() &#123;</span><br><span class="line">return /iPhone|iPad|iPod\/([\w.]+).*(safari).*/i.test(UA)</span><br><span class="line">&#125;)()</span><br><span class="line">var isWx = (function() &#123;</span><br><span class="line">return UA.match(/micromessenger/i) ? true : false</span><br><span class="line">&#125;)()</span><br><span class="line">var isWb = (function() &#123;</span><br><span class="line">return UA.match(/weibo/i) ? true : false</span><br><span class="line">&#125;)()</span><br><span class="line">var isAndroidChrome = (function() &#123;</span><br><span class="line">return(UA.match(/Chrome\/([\d.]+)/) || UA.match(/CriOS\/([\d.]+)/)) &amp;&amp; isAndroid &amp;&amp; !isQQ</span><br><span class="line">&#125;)()</span><br><span class="line">var isQZ = (function() &#123;</span><br><span class="line">return UA.indexOf(&apos;Qzone/&apos;) !== -1</span><br><span class="line">&#125;)()</span><br><span class="line">var browser = &#123;</span><br><span class="line">isAndroid: isAndroid,</span><br><span class="line">isIOS: isIOS,</span><br><span class="line">isSafari: isSafari,</span><br><span class="line">isQQ: isQQ,</span><br><span class="line">isWb: isWb,</span><br><span class="line">isWx: isWx,</span><br><span class="line">isQZ: isQZ,</span><br><span class="line">isAndroidChrome: isAndroidChrome</span><br><span class="line">&#125;</span><br><span class="line">return browser</span><br><span class="line">&#125;</span><br><span class="line">return Browser</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * AppLink:H5唤起APP的所有方法</span><br><span class="line"> */</span><br><span class="line">var AppLink = /** @class */ (function() &#123;</span><br><span class="line">/**</span><br><span class="line"> * 类的contructor方法</span><br><span class="line"> * @param config IAppLink类型的config文件</span><br><span class="line"> */</span><br><span class="line">function AppLink(config) &#123;</span><br><span class="line">/**</span><br><span class="line"> * UA</span><br><span class="line"> */</span><br><span class="line">this.UA = &#123;&#125;</span><br><span class="line">/**</span><br><span class="line"> * 传入的config数据，以接口约束</span><br><span class="line"> */</span><br><span class="line">this.config = &#123;&#125;</span><br><span class="line">this.UA = navigator.userAgent || &apos;&apos;</span><br><span class="line">this.config = config</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 跳转函数</span><br><span class="line"> * @param url 链接</span><br><span class="line"> */</span><br><span class="line">AppLink.prototype.go = function(url) &#123;</span><br><span class="line">window.location.href = url</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 检查是否唤起</span><br><span class="line"> * @param cb 回调函数</span><br><span class="line"> */</span><br><span class="line">AppLink.prototype.checkOpen = function(cb) &#123;</span><br><span class="line">var inter = null</span><br><span class="line">var statue = false</span><br><span class="line">var count = 0</span><br><span class="line">inter = window.setInterval(function() &#123;</span><br><span class="line">count++</span><br><span class="line">statue = document.hidden || document.webkitHidden</span><br><span class="line">if(statue || count &gt; 40) &#123;</span><br><span class="line">cb(statue)</span><br><span class="line">clearInterval(inter)</span><br><span class="line">&#125;</span><br><span class="line">&#125;, 50)</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 外部调用的入口函数</span><br><span class="line"> */</span><br><span class="line">AppLink.prototype.open = function() &#123;</span><br><span class="line">var _this = this</span><br><span class="line">var browser = Browser.getBrowser()</span><br><span class="line">var config = this.config</span><br><span class="line">// 微信直接跳 应用宝</span><br><span class="line">if(browser.isWx) &#123;</span><br><span class="line">this.go(this.config.yyb)</span><br><span class="line">&#125; else if(browser.isQQ) &#123;</span><br><span class="line">if(browser.isIOS) &#123;</span><br><span class="line">// 没有下载</span><br><span class="line">this.checkOpen(function(isSuccess) &#123;</span><br><span class="line">if(!isSuccess) &#123;</span><br><span class="line">_this.go(_this.config.appstore)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">// iOS跳到AppStore</span><br><span class="line">if(browser.isAndroid) &#123;</span><br><span class="line">// 使用scheme唤起</span><br><span class="line">this.tryCallApp(this.config.schema)</span><br><span class="line">// 唤起失败 跳到应用宝</span><br><span class="line">this.checkOpen(function(isSuccess) &#123;</span><br><span class="line">if(!isSuccess) &#123;</span><br><span class="line">_this.go(_this.config.yyb)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if(browser.isWb) &#123;</span><br><span class="line">// 使用scheme唤起</span><br><span class="line">this.tryCallApp(this.config.schema)</span><br><span class="line">// 微博：唤起失败，也不跳转，会有引导功能</span><br><span class="line">&#125; else if(browser.isSafari) &#123;</span><br><span class="line">var version = this.getIOSVersion()</span><br><span class="line">// iOS10以下不支持直接跳转到AppStore，跳到应用宝</span><br><span class="line">if(version &lt; 10) &#123;</span><br><span class="line">this.go(this.config.yyb)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">this.go(this.config.appstore)</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 其他情况，直接跳应用宝</span><br><span class="line">this.go(this.config.yyb)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 下载按钮的url地址</span><br><span class="line"> */</span><br><span class="line">AppLink.prototype.getDownloadUrl = function() &#123;</span><br><span class="line">var browser = Browser.getBrowser()</span><br><span class="line">var config = this.config</span><br><span class="line">var url = &apos;&apos;</span><br><span class="line">if(browser.isQQ) &#123;</span><br><span class="line">if(browser.isIOS) &#123;</span><br><span class="line">url = this.config.appstore</span><br><span class="line">&#125; else &#123;</span><br><span class="line">url = this.config.yyb</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if(browser.isSafari) &#123;</span><br><span class="line">var version = this.getIOSVersion()</span><br><span class="line">if(version &lt; 10) &#123;</span><br><span class="line">url = this.config.yyb</span><br><span class="line">&#125; else &#123;</span><br><span class="line">url = this.config.appstore</span><br><span class="line">&#125;</span><br><span class="line">&#125; else if(browser.isWb) &#123;</span><br><span class="line">url = &apos;&apos;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">url = this.config.yyb</span><br><span class="line">&#125;</span><br><span class="line">return url</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 尝试唤起APP</span><br><span class="line"> * @param scheme 唤起的scheme</span><br><span class="line"> */</span><br><span class="line">AppLink.prototype.tryCallApp = function(scheme) &#123;</span><br><span class="line">var aLink = document.createElement(&apos;a&apos;),</span><br><span class="line">body = document.body</span><br><span class="line">aLink.href = scheme</span><br><span class="line">body.appendChild(aLink)</span><br><span class="line">aLink.click()</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * 判断iOS版本</span><br><span class="line"> */</span><br><span class="line">AppLink.prototype.getIOSVersion = function() &#123;</span><br><span class="line">var ver = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/)</span><br><span class="line">var version = parseInt(ver[1], 10)</span><br><span class="line">return version</span><br><span class="line">&#125;</span><br><span class="line">return AppLink</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function add(...x) &#123;</span><br><span class="line">var sum = x.reduce((a,b)=&gt;a+b,0)</span><br><span class="line">var tmp = function(...y) &#123;</span><br><span class="line">sum =sum+y.reduce((a,b)=&gt;a+b,0)</span><br><span class="line">return tmp;</span><br><span class="line">&#125;;</span><br><span class="line">tmp.toString = function() &#123;</span><br><span class="line">return sum;</span><br><span class="line">&#125;;</span><br><span class="line">return tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(+add(1)(2)(3))   // 6</span><br><span class="line">console.log(+add(1)(2,3))    // 6</span><br><span class="line">console.log(+add(1,2)(3))    // 6</span><br><span class="line">console.log(+add(1)(2)(3,4))   //10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(1)(2)(3).valueOf</span><br><span class="line">//ƒ valueOf() &#123; [native code] &#125;</span><br><span class="line">add(1)(2)(3).valueOf()</span><br><span class="line">//ƒ 6</span><br><span class="line">+add(1)(2)(3).valueOf()</span><br><span class="line">//6</span><br><span class="line">+&quot;&quot;+add(1)(2)(3).valueOf()</span><br><span class="line">//6</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="add-2-3-add-2-3-输出5"><a href="#add-2-3-add-2-3-输出5" class="headerlink" title="add(2)(3)(),add(2,3)()输出5"></a>add(2)(3)(),add(2,3)()输出5</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function sum() &#123;</span><br><span class="line">var cur = Array.prototype.slice.call(arguments).reduce(function(a, b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">function add() &#123;</span><br><span class="line">return arguments.length == 0 ? cur : (cur += Array.prototype.slice.call(arguments).reduce(function(a, b) &#123;</span><br><span class="line">return a + b</span><br><span class="line">&#125;, 0), add);</span><br><span class="line">&#125;;</span><br><span class="line">return arguments.length == 0 ? 0 : add;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="获取CSS样式"><a href="#获取CSS样式" class="headerlink" title="获取CSS样式"></a>获取CSS样式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getStyle(obj, attr) &#123;</span><br><span class="line">if(obj.currentStyle) &#123;</span><br><span class="line">return obj.currentStyle[attr]; //IE678</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return window.getComputedStyle(obj, null)[attr];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">function rgbToRgba(rgbValue) &#123;</span><br><span class="line">const rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);</span><br><span class="line">return rgb ? `rgba($&#123;rgb[1]&#125;,1)` : rgbValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hexToRgba(hexValue) &#123;</span><br><span class="line">const rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;</span><br><span class="line">const hex = hexValue.replace(rgx, (m, r, g, b) =&gt; r + r + g + g + b + b);</span><br><span class="line">const rgb = /^#?([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)([a-f\d]&#123;2&#125;)$/i.exec(hex);</span><br><span class="line">const r = parseInt(rgb[1], 16);</span><br><span class="line">const g = parseInt(rgb[2], 16);</span><br><span class="line">const b = parseInt(rgb[3], 16);</span><br><span class="line">return `rgba($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;,1)`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hslToRgba(hslValue) &#123;</span><br><span class="line">const hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);</span><br><span class="line">const h = parseInt(hsl[1]) / 360;</span><br><span class="line">const s = parseInt(hsl[2]) / 100;</span><br><span class="line">const l = parseInt(hsl[3]) / 100;</span><br><span class="line">const a = hsl[4] || 1;</span><br><span class="line"></span><br><span class="line">function hue2rgb(p, q, t) &#123;</span><br><span class="line">if(t &lt; 0) t += 1;</span><br><span class="line">if(t &gt; 1) t -= 1;</span><br><span class="line">if(t &lt; 1 / 6) return p + (q - p) * 6 * t;</span><br><span class="line">if(t &lt; 1 / 2) return q;</span><br><span class="line">if(t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;</span><br><span class="line">return p;</span><br><span class="line">&#125;</span><br><span class="line">let r, g, b;</span><br><span class="line">if(s == 0) &#123;</span><br><span class="line">r = g = b = l;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">const q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;</span><br><span class="line">const p = 2 * l - q;</span><br><span class="line">r = hue2rgb(p, q, h + 1 / 3);</span><br><span class="line">g = hue2rgb(p, q, h);</span><br><span class="line">b = hue2rgb(p, q, h - 1 / 3);</span><br><span class="line">&#125;</span><br><span class="line">return `rgba($&#123;r * 255&#125;,$&#123;g * 255&#125;,$&#123;b * 255&#125;,$&#123;a&#125;)`;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function colorToRgb(val) &#123;</span><br><span class="line">if(is.rgb(val)) return rgbToRgba(val);</span><br><span class="line">if(is.hex(val)) return hexToRgba(val);</span><br><span class="line">if(is.hsl(val)) return hslToRgba(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="750rem"><a href="#750rem" class="headerlink" title="750rem"></a>750rem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(function(doc, win) &#123;</span><br><span class="line">var docEl = doc.documentElement,</span><br><span class="line">resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos;,</span><br><span class="line">recalc = function() &#123;</span><br><span class="line">var clientWidth = docEl.clientWidth;</span><br><span class="line">if(!clientWidth) return;</span><br><span class="line">if(clientWidth &gt;= 750) &#123;</span><br><span class="line">docEl.style.fontSize = &apos;100px&apos;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">docEl.style.fontSize = 100 * (clientWidth / 750) + &apos;px&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">if(!doc.addEventListener) return;</span><br><span class="line">win.addEventListener(resizeEvt, recalc, false);</span><br><span class="line">doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false);</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static checkType = (str, type) =&gt; &#123;</span><br><span class="line">switch(type) &#123;</span><br><span class="line">case &apos;email&apos;:</span><br><span class="line">return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);</span><br><span class="line">case &apos;phone&apos;:</span><br><span class="line">return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str);</span><br><span class="line">case &apos;tel&apos;:</span><br><span class="line">return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str);</span><br><span class="line">case &apos;number&apos;:</span><br><span class="line">return /^[0-9]$/.test(str);</span><br><span class="line">case &apos;english&apos;:</span><br><span class="line">return /^[a-zA-Z]+$/.test(str);</span><br><span class="line">case &apos;chinese&apos;:</span><br><span class="line">return /^[\u4E00-\u9FA5]+$/.test(str);</span><br><span class="line">case &apos;lower&apos;:</span><br><span class="line">return /^[a-z]+$/.test(str);</span><br><span class="line">case &apos;upper&apos;:</span><br><span class="line">return /^[A-Z]+$/.test(str);</span><br><span class="line">default:</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="navigator帮助类"><a href="#navigator帮助类" class="headerlink" title="navigator帮助类"></a>navigator帮助类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">class navigatorUtil &#123;</span><br><span class="line">/**</span><br><span class="line"> * 头部信息</span><br><span class="line"> * @type &#123;[type]&#125;</span><br><span class="line"> */</span><br><span class="line">static userAgent = navigator.userAgent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否为ipad</span><br><span class="line"> */</span><br><span class="line">static isIPad = () =&gt; &#123;</span><br><span class="line">return(navigatorUtil.userAgent.indexOf(&quot;iPad&quot;) &gt; -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否为iphone</span><br><span class="line"> * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line"> * @return &#123;Boolean&#125;           [description]</span><br><span class="line"> */</span><br><span class="line">static isIPhone = () =&gt; &#123;</span><br><span class="line">return(navigatorUtil.userAgent.indexOf(&quot;iPhone&quot;) &gt; -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否为ios系统</span><br><span class="line"> * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line"> * @return &#123;Boolean&#125;           [description]</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">static isIOS = () =&gt; &#123;</span><br><span class="line">return navigatorUtil.isIPad(navigatorUtil.userAgent) || navigatorUtil.isIPhone(</span><br><span class="line">navigatorUtil.userAgent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 是否为Android系统</span><br><span class="line"> * @param  &#123;[type]&#125;  userAgent [description]</span><br><span class="line"> * @return &#123;Boolean&#125;           [description]</span><br><span class="line"> */</span><br><span class="line">static isAndroid = () =&gt; &#123;</span><br><span class="line">return(navigatorUtil.userAgent.indexOf(&quot;Android&quot;) &gt; -1) ||</span><br><span class="line">(navigatorUtil.userAgent.indexOf(&quot;Linux&quot;) &gt; -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 判断是否为微信</span><br><span class="line"> */</span><br><span class="line">static isWeixin = () =&gt; &#123;</span><br><span class="line">return(navigatorUtil.userAgent.indexOf(&quot;MicroMessenger&quot;) &gt; -1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 获取浏览器类型和版本</span><br><span class="line"> * @return &#123;String&#125; </span><br><span class="line"> */</span><br><span class="line">static getExplore = () =&gt; &#123;</span><br><span class="line">var sys = &#123;&#125;,</span><br><span class="line">ua = navigator.userAgent.toLowerCase(),</span><br><span class="line">s;</span><br><span class="line">(s = ua.match(/rv:([\d.]+)\) like gecko/)) ? sys.ie = s[1]:</span><br><span class="line">(s = ua.match(/msie ([\d\.]+)/)) ? sys.ie = s[1] :</span><br><span class="line">(s = ua.match(/edge\/([\d\.]+)/)) ? sys.edge = s[1] :</span><br><span class="line">(s = ua.match(/firefox\/([\d\.]+)/)) ? sys.firefox = s[1] :</span><br><span class="line">(s = ua.match(/(?:opera|opr).([\d\.]+)/)) ? sys.opera = s[1] :</span><br><span class="line">(s = ua.match(/chrome\/([\d\.]+)/)) ? sys.chrome = s[1] :</span><br><span class="line">(s = ua.match(/version\/([\d\.]+).*safari/)) ? sys.safari = s[1] : 0;</span><br><span class="line">// 根据关系进行判断 if (sys.ie) return (&apos;IE: &apos; + sys.ie)</span><br><span class="line">if(sys.edge) return(&apos;EDGE: &apos; + sys.edge)</span><br><span class="line">if(sys.firefox) return(&apos;Firefox: &apos; + sys.firefox)</span><br><span class="line">if(sys.chrome) return(&apos;Chrome: &apos; + sys.chrome)</span><br><span class="line">if(sys.opera) return(&apos;Opera: &apos; + sys.opera)</span><br><span class="line">if(sys.safari) return(&apos;Safari: &apos; + sys.safari)</span><br><span class="line">return &apos;Unkonwn&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @desc 获取操作系统类型</span><br><span class="line"> * @return &#123;String&#125; </span><br><span class="line"> */</span><br><span class="line">static getOS = () =&gt; &#123;</span><br><span class="line">var userAgent = &apos;navigator&apos; in window &amp;&amp; &apos;userAgent&apos; in navigator &amp;&amp; navigator.userAgent.toLowerCase() || &apos;&apos;;</span><br><span class="line">var vendor = &apos;navigator&apos; in window &amp;&amp; &apos;vendor&apos; in navigator &amp;&amp; navigator.vendor.toLowerCase() || &apos;&apos;;</span><br><span class="line">var appVersion = &apos;navigator&apos; in window &amp;&amp; &apos;appVersion&apos; in navigator &amp;&amp; navigator.appVersion.toLowerCase() || &apos;&apos;;</span><br><span class="line"></span><br><span class="line">if(/mac/i.test(appVersion)) return &apos;MacOSX&apos;</span><br><span class="line">if(/win/i.test(appVersion)) return &apos;windows&apos;</span><br><span class="line">if(/linux/i.test(appVersion)) return &apos;linux&apos;</span><br><span class="line">if(/iphone/i.test(userAgent) || /ipad/i.test(userAgent) || /ipod/i.test(userAgent)) &apos;ios&apos;</span><br><span class="line">if(/android/i.test(userAgent)) return &apos;android&apos;</span><br><span class="line">if(/win/i.test(appVersion) &amp;&amp; /phone/i.test(userAgent)) return &apos;windowsPhone&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//进入全屏模式,  判断各种浏览器，找到正确的方法</span><br><span class="line">static launchFullScreen = (element) =&gt; &#123;</span><br><span class="line">if(element.requestFullscreen) &#123;</span><br><span class="line">element.requestFullscreen();</span><br><span class="line">&#125; else if(element.mozRequestFullScreen) &#123;</span><br><span class="line">element.mozRequestFullScreen();</span><br><span class="line">&#125; else if(element.webkitRequestFullscreen) &#123;</span><br><span class="line">element.webkitRequestFullscreen();</span><br><span class="line">&#125; else if(element.msRequestFullscreen) &#123;</span><br><span class="line">element.msRequestFullscreen();</span><br><span class="line">&#125;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">//退出全屏模式</span><br><span class="line">static exitFullScreen = () =&gt; &#123;</span><br><span class="line">if(document.exitFullscreen) &#123;</span><br><span class="line">document.exitFullscreen();</span><br><span class="line">&#125; else if(document.mozCancelFullScreen) &#123;</span><br><span class="line">document.mozCancelFullScreen();</span><br><span class="line">&#125; else if(document.webkitExitFullscreen) &#123;</span><br><span class="line">document.webkitExitFullscreen();</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line">function Promise(task) &#123;</span><br><span class="line">let self = this; //缓存this</span><br><span class="line">self.status = &apos;pending&apos;; //默认状态为pending</span><br><span class="line">self.value = undefined; //存放着此promise的结果</span><br><span class="line">self.onResolvedCallbacks = []; //存放着所有成功的回调函数</span><br><span class="line">self.onRejectedCallbacks = []; //存放着所有的失败的回调函数</span><br><span class="line"></span><br><span class="line">// 调用resolve方法可以把promise状态变成成功态</span><br><span class="line">function resolve(value) &#123;</span><br><span class="line">if(value instanceof Promise) &#123;</span><br><span class="line">return value.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(function() &#123; // 异步执行所有的回调函数</span><br><span class="line">// 如果当前状态是初始态（pending），则转成成功态</span><br><span class="line">// 此处这个写判断的原因是因为resolved和rejected两个状态只能由pending转化而来，两者不能相互转化</span><br><span class="line">if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">self.value = value;</span><br><span class="line">self.status = &apos;resolved&apos;;</span><br><span class="line">self.onResolvedCallbacks.forEach(item =&gt; item(self.value));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用reject方法可以把当前的promise状态变成失败态</span><br><span class="line">function reject(value) &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">self.value = value;</span><br><span class="line">self.status = &apos;rejected&apos;;</span><br><span class="line">self.onRejectedCallbacks.forEach(item =&gt; item(value));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 立即执行传入的任务</span><br><span class="line">try &#123;</span><br><span class="line">task(resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * resolvePromise函数的目的是与原生Promise相兼容，可以互相调用</span><br><span class="line"> */</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">// 将返回的promise不停的调用执行，直到失败或者返回一个普通的数据类型</span><br><span class="line">if(promise2 === x) &#123;</span><br><span class="line">return reject(new TypeError(&apos;循环引用&apos;));</span><br><span class="line">&#125;</span><br><span class="line">let then, called;</span><br><span class="line"></span><br><span class="line">if(x != null &amp;&amp; ((typeof x == &apos;object&apos; || isFunction(x)))) &#123;</span><br><span class="line">// promise</span><br><span class="line">try &#123;</span><br><span class="line">then = x.then;</span><br><span class="line">if(isFunction(then)) &#123;</span><br><span class="line">then.call(x, function(value) &#123;</span><br><span class="line">if(called) return;</span><br><span class="line">called = true;</span><br><span class="line">resolvePromise(promise2, value, resolve, reject);</span><br><span class="line">&#125;, function(reason) &#123;</span><br><span class="line">if(called) return;</span><br><span class="line">called = true;</span><br><span class="line">reject(reason);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resolve(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">if(called) return;</span><br><span class="line">called = true;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resolve(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * onFulfilled成功的回调，onReject失败的回调</span><br><span class="line"> */</span><br><span class="line">Promise.prototype.then = function(onFulfilled, onRejected) &#123;</span><br><span class="line">let self = this;</span><br><span class="line">// 当调用时没有写函数给它一个默认函数值</span><br><span class="line">onFulfilled = isFunction(onFulfilled) ? onFulfilled : function(value) &#123;</span><br><span class="line">return value</span><br><span class="line">&#125;;</span><br><span class="line">onRejected = isFunction(onRejected) ? onRejected : function(value) &#123;</span><br><span class="line">throw value</span><br><span class="line">&#125;;</span><br><span class="line">let promise2;</span><br><span class="line">if(self.status == &apos;resolved&apos;) &#123;</span><br><span class="line">promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">let x = onFulfilled(self.value);</span><br><span class="line">resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">if(self.status == &apos;rejected&apos;) &#123;</span><br><span class="line">promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">let x = onRejected(self.value);</span><br><span class="line">resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">promise2 = new Promise(function(resolve, reject) &#123;</span><br><span class="line">self.onResolvedCallbacks.push(function(value) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">let x = onFulfilled(value);</span><br><span class="line">resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">self.onRejectedCallbacks.push(function(value) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">let x = onRejected(value);</span><br><span class="line">resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">return promise2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * catch实际上是then的一个简写,成功回调传空值即可</span><br><span class="line"> */</span><br><span class="line">Promise.prototype.catch = function(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Promise.reject(error)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。</span><br><span class="line"> */</span><br><span class="line">Promise.resolve = function(value) &#123;</span><br><span class="line">return new Promise(function(resolve, reject) &#123;</span><br><span class="line">if(typeof value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; isFunction(value.then)) &#123;</span><br><span class="line">value.then();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resolve(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Promise.reject = function(reason) &#123;</span><br><span class="line">return new Promise(function(resolve, reject) &#123;</span><br><span class="line">reject(reason);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * all方法，可以传入多个promise，全部执行完后会将结果以数组的方式返回，如果有一个失败就返回失败</span><br><span class="line"> */</span><br><span class="line">Promise.all = function(promises) &#123;</span><br><span class="line">return new Promise(function(resolve, reject) &#123;</span><br><span class="line">let result = []; // all方法最终返回的结果</span><br><span class="line">let count = 0; // 完成的数量</span><br><span class="line">for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">promises[i].then(function(data) &#123;</span><br><span class="line">result[i] = data;</span><br><span class="line">if(++count == promises.length) &#123;</span><br><span class="line">resolve(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, function(err) &#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * race方法，可以传入多个promise，返回的是第一个执行完的resolve的结果，如果有一个失败就返回失败</span><br><span class="line"> */</span><br><span class="line">Promise.race = function(promises) &#123;</span><br><span class="line">return new Promise(function(resolve, reject) &#123;</span><br><span class="line">for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">promises[i].then(function(data) &#123;</span><br><span class="line">resolve(data);</span><br><span class="line">&#125;, function(err) &#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = function() &#123;</span><br><span class="line">var defer = &#123;&#125;;</span><br><span class="line">defer.promise = new Promise(function(resolve, reject) &#123;</span><br><span class="line">defer.resolve = resolve;</span><br><span class="line">defer.reject = reject;</span><br><span class="line">&#125;)</span><br><span class="line">return defer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一些会多次使用的复用功能函数</span><br><span class="line"> */</span><br><span class="line">function isFunction(obj) &#123;</span><br><span class="line">return typeof obj === &quot;function&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最后可以通过以下命令安装一个promises测试插件，用插件来测试自己实现的promise符不符合规范</span><br><span class="line"> * npm(cnpm) i -g promises-aplus-tests</span><br><span class="line"> * promises-aplus-tests Promise.js</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = Promise;</span><br></pre></td></tr></table></figure><h3 id="ES6-promise"><a href="#ES6-promise" class="headerlink" title="ES6 promise"></a>ES6 promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line">class es6Promise &#123;</span><br><span class="line">constructor(task) &#123;</span><br><span class="line">let self = this; //缓存this</span><br><span class="line">self.status = &apos;pending&apos;; //默认状态为pending</span><br><span class="line">self.value = undefined; //存放着此promise的结果</span><br><span class="line">self.onResolvedCallbacks = []; //存放着所有成功的回调函数</span><br><span class="line">self.onRejectedCallbacks = []; //存放着所有的失败的回调函数</span><br><span class="line"></span><br><span class="line">// 调用resolve方法可以把promise状态变成成功态</span><br><span class="line">function resolve(value) &#123;</span><br><span class="line">if(value instanceof Promise) &#123;</span><br><span class="line">return value.then(resolve, reject)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(() =&gt; &#123; // 异步执行所有的回调函数</span><br><span class="line">// 如果当前状态是初始态（pending），则转成成功态</span><br><span class="line">// 此处这个写判断的原因是因为resolved和rejected两个状态只能由pending转化而来，两者不能相互转化</span><br><span class="line">if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">self.value = value;</span><br><span class="line">self.status = &apos;resolved&apos;;</span><br><span class="line">self.onResolvedCallbacks.forEach(item =&gt; item(self.value));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用reject方法可以把当前的promise状态变成失败态</span><br><span class="line">function reject(value) &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">self.value = value;</span><br><span class="line">self.status = &apos;rejected&apos;;</span><br><span class="line">self.onRejectedCallbacks.forEach(item =&gt; item(value));</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 立即执行传入的任务</span><br><span class="line">try &#123;</span><br><span class="line">task(resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * onFulfilled成功的回调，onReject失败的回调</span><br><span class="line"> * 原型链方法</span><br><span class="line"> */</span><br><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">let self = this;</span><br><span class="line">// 当调用时没有写函数给它一个默认函数值</span><br><span class="line">onFulfilled = isFunction(onFulfilled) ? onFulfilled : value =&gt; value;</span><br><span class="line">onRejected = isFunction(onRejected) ? onRejected : value =&gt; &#123;</span><br><span class="line">throw value</span><br><span class="line">&#125;;</span><br><span class="line">let promise2;</span><br><span class="line">if(self.status == &apos;resolved&apos;) &#123;</span><br><span class="line">promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">let x = onFulfilled(self.value);</span><br><span class="line">resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">if(self.status == &apos;rejected&apos;) &#123;</span><br><span class="line">promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">let x = onRejected(self.value);</span><br><span class="line">resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">if(self.status == &apos;pending&apos;) &#123;</span><br><span class="line">promise2 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">self.onResolvedCallbacks.push(value =&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">let x = onFulfilled(value);</span><br><span class="line">resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">self.onRejectedCallbacks.push(value =&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">let x = onRejected(value);</span><br><span class="line">resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">return promise2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * catch实际上是then的一个简写,成功回调传空值即可</span><br><span class="line"> * 原型链方法</span><br><span class="line"> */</span><br><span class="line">catch(onRejected) &#123;</span><br><span class="line">return this.then(null, onRejected);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Promise.reject(err)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。</span><br><span class="line"> * 静态方法为类自己的方法，不在原型链上</span><br><span class="line"> */</span><br><span class="line">static resolve(value) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">if(typeof value !== null &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; isFunction(value.then)) &#123;</span><br><span class="line">value.then();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resolve(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static reject(err) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * all方法，可以传入多个promise，全部执行完后会将结果以数组的方式返回，如果有一个失败就返回失败</span><br><span class="line"> * 静态方法为类自己的方法，不在原型链上</span><br><span class="line"> */</span><br><span class="line">static all(promises) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">let result = []; // all方法最终返回的结果</span><br><span class="line">let count = 0; // 完成的数量</span><br><span class="line">for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">promises[i].then(data =&gt; &#123;</span><br><span class="line">result[i] = data;</span><br><span class="line">if(++count == promises.length) &#123;</span><br><span class="line">resolve(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * race方法，可以传入多个promise，返回的是第一个执行完的resolve的结果，如果有一个失败就返回失败</span><br><span class="line"> *  静态方法为类自己的方法，不在原型链上</span><br><span class="line"> */</span><br><span class="line">static race(promises) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">for(let i = 0; i &lt; promises.length; i++) &#123;</span><br><span class="line">promises[i].then(data =&gt; &#123;</span><br><span class="line">resolve(data);</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">reject(err);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * resolvePromise函数的目的是与原生Promise相兼容，可以互相调用</span><br><span class="line"> */</span><br><span class="line">function resolvePromise(promise2, x, resolve, reject) &#123;</span><br><span class="line">// 将返回的promise不停的调用执行，直到失败或者返回一个普通的数据类型</span><br><span class="line">if(promise2 === x) &#123;</span><br><span class="line">return reject(new TypeError(&apos;循环引用&apos;));</span><br><span class="line">&#125;</span><br><span class="line">let then;</span><br><span class="line">let called;</span><br><span class="line"></span><br><span class="line">if(x != null &amp;&amp; ((typeof x == &apos;object&apos; || isFunction(x)))) &#123;</span><br><span class="line">// promise</span><br><span class="line">try &#123;</span><br><span class="line">then = x.then;</span><br><span class="line">if(isFunction(then)) &#123;</span><br><span class="line">then.call(x, value =&gt; &#123;</span><br><span class="line">if(called) return;</span><br><span class="line">called = true;</span><br><span class="line">resolvePromise(promise2, value, resolve, reject);</span><br><span class="line">&#125;, reason =&gt; &#123;</span><br><span class="line">if(called) return;</span><br><span class="line">called = true;</span><br><span class="line">reject(reason);</span><br><span class="line">&#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resolve(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch(e) &#123;</span><br><span class="line">if(called) return;</span><br><span class="line">called = true;</span><br><span class="line">reject(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">resolve(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Promise.deferred = Promise.defer = () =&gt; &#123;</span><br><span class="line">const defer = &#123;&#125;;</span><br><span class="line">defer.promise = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">defer.resolve = resolve;</span><br><span class="line">defer.reject = reject;</span><br><span class="line">&#125;)</span><br><span class="line">return defer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一些会多次使用的复用功能函数</span><br><span class="line"> */</span><br><span class="line">function isFunction(obj) &#123;</span><br><span class="line">return typeof obj === &quot;function&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 最后可以通过以下命令安装一个promises测试插件，用插件来测试自己实现的promise符不符合规范</span><br><span class="line"> * npm(cnpm) i -g promises-aplus-tests</span><br><span class="line"> * promises-aplus-tests es6Promise.js</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = es6Promise;</span><br></pre></td></tr></table></figure><h3 id="使用promise手动封装ajax函数"><a href="#使用promise手动封装ajax函数" class="headerlink" title="使用promise手动封装ajax函数"></a>使用promise手动封装ajax函数</h3><blockquote><p>跨浏览器实现Ajax兼容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var createXMLHttpRequest = function () &#123;</span><br><span class="line">  if ( window.XMLHttpRequest ) &#123;</span><br><span class="line">      return new XMLHttpRequest();</span><br><span class="line">  &#125;</span><br><span class="line">  else if ( window.ActiveXObject ) &#123;</span><br><span class="line">      return new ActiveXObject(&apos;Microsoft.XMLHttp&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Ajax的xhr对象有如下常用API</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">onloadstart                     开始send触发</span><br><span class="line">onprogress                      从服务器上下载数据每50ms触发一次,判断进度</span><br><span class="line">onload                          得到响应</span><br><span class="line">onerror                         服务器异常</span><br><span class="line">open                            xhr.open(&apos;GET&apos;, url, true)  请求方式,请求url, true(默认)异步请求 </span><br><span class="line">onloadend                       请求结束，无论成功失败</span><br><span class="line">onreadystatechange              xhr.readyState改变使触发</span><br><span class="line">onabort                         调用xhr.abort时触发</span><br><span class="line">ontimeout                       超时触发</span><br><span class="line">setRequestHeader                设置RequestHeader，eg：xhr.setRequestHeader(&apos;Accept&apos;,&apos;application/json&apos;);</span><br><span class="line">                                xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.getAllResponseHeaders()     返回全部头信息,string</span><br><span class="line">getResponseHeader               获取Response头信息，eg：xhr.getResponseHeader(&apos;date&apos;);</span><br><span class="line">                                xhr.getResponseHeader(&apos;content-type&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>readyState上面都是静态函数。而readyState表示了请求的状态:</p></blockquote><ul><li>value=0,open()方法还未被调用</li><li>value=1,open()调用,send()方法还未被调用</li><li>value=2,send()方法已经被调用，响应头和响应状态已经返回</li><li>value=3,响应体下载中，responseText中已经获取了部分数据</li><li>value=4,请求完成，整个请求过程已经完毕。</li></ul><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function getJSON (url) &#123;</span><br><span class="line">    return new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&apos;GET&apos;, url, true)</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">            //if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304))</span><br><span class="line">            if (xhr.readyState === 4) &#123;</span><br><span class="line">                if (xhr.status === 200) &#123;</span><br><span class="line">                    resolve(this.responseText, this)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    var resJson = &#123; code: this.status, response: this.response &#125;</span><br><span class="line">                    reject(resJson, this)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function postJSON(url, data) &#123;</span><br><span class="line">    return new Promise( (resolve, reject) =&gt; &#123;</span><br><span class="line">        var xhr = new XMLHttpRequest()</span><br><span class="line">        xhr.open(&quot;POST&quot;, url, true)</span><br><span class="line">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">        xhr.onreadystatechange = function () &#123;</span><br><span class="line">             //if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304))</span><br><span class="line">            if (xhr.readyState === 4) &#123;</span><br><span class="line">                if (xhr.status === 200) &#123;</span><br><span class="line">                    resolve(JSON.parse(this.responseText), this)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    var resJson = &#123; code: this.status, response: this.response &#125;</span><br><span class="line">                    reject(resJson, this)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(JSON.stringify(data))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">// ajax函数的默认参数</span><br><span class="line">var ajaxOptions = &#123;</span><br><span class="line">    url: &apos;#&apos;,</span><br><span class="line">    method: &apos;GET&apos;,</span><br><span class="line">    async: true,</span><br><span class="line">    timeout: 0,</span><br><span class="line">    data: null,</span><br><span class="line">    dataType: &apos;text&apos;,</span><br><span class="line">    headers: &#123;&#125;,</span><br><span class="line">    onprogress: function () &#123; &#125;,</span><br><span class="line">    onuploadprogress: function () &#123; &#125;,</span><br><span class="line">    xhr: null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ajax函数，返回一个promise对象</span><br><span class="line"> * @param &#123;Object&#125; optionsOverride 参数设置，支持的参数如下</span><br><span class="line"> *   url:                     url地址，默认&quot;#&quot;</span><br><span class="line"> *   method:                  请求方法，仅支持GET,POST,默认GET</span><br><span class="line"> *   async:                   是否异步，默认true</span><br><span class="line"> *   timeout:                 请求时限，超时将在promise中调用reject函数</span><br><span class="line"> *   data:                    发送的数据，该函数不支持处理数据，将会直接发送</span><br><span class="line"> *   dataType:                接受的数据的类型，默认为text</span><br><span class="line"> *   headers:                 一个对象，包含请求头信息</span><br><span class="line"> *   onprogress:              处理onprogress的函数</span><br><span class="line"> *   ouploadprogress:         处理.upload.onprogress的函数</span><br><span class="line"> *   xhr:                     允许在函数外部创建xhr对象传入，但必须不能是使用过的</span><br><span class="line"> </span><br><span class="line"> * @return &#123;Promise&#125; </span><br><span class="line"> *   该函数注册xhr.onloadend回调函数，判断xhr.status是否属于 [200,300)&amp;&amp;304 ，</span><br><span class="line"> *   如果属于则promise引发resolve状态，允许拿到xhr对象</span><br><span class="line"> *   如果不属于，或已经引发了ontimeout,onabort,则引发reject状态，允许拿到xhr对象</span><br><span class="line"> * </span><br><span class="line"> * 关于reject</span><br><span class="line"> *   返回一个对象，包含</span><br><span class="line"> *     errorType:错误类型，</span><br><span class="line"> *     abort_error:   xhr对象调用abort函数</span><br><span class="line"> *     timeout_error: 请求超时</span><br><span class="line"> *     onerror:       xhr对象触发了onerror事件</span><br><span class="line"> *     send_error:    发送请求出现错误</span><br><span class="line"> *     status_error:  响应状态不属于 [200,300)&amp;&amp;304</span><br><span class="line"> */</span><br><span class="line">function ajax(optionsOverride) &#123;</span><br><span class="line">    // 将传入的参数与默认设置合并</span><br><span class="line">    var options = &#123;&#125;;</span><br><span class="line">    for (var k in ajaxOptions) &#123;</span><br><span class="line">        options[k] = optionsOverride[k] || ajaxOptions[k];</span><br><span class="line">    &#125;</span><br><span class="line">    options.async = options.async === false ? false : true;</span><br><span class="line">    var xhr = options.xhr = options.xhr || new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        xhr.open(options.method, options.url, options.async);</span><br><span class="line">        xhr.timeout = options.timeout;</span><br><span class="line"></span><br><span class="line">        //设置请求头</span><br><span class="line">        for (var k in options.headers) &#123;</span><br><span class="line">            xhr.setRuquestHeader(k, options.headers[k]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 注册xhr对象事件</span><br><span class="line">        xhr.onprogress = options.onprogress;</span><br><span class="line">        xhr.upload.onprogress = options.onuploadprogress;</span><br><span class="line">        xhr.responseType = options.dataType;</span><br><span class="line"></span><br><span class="line">        xhr.onabort = function () &#123;</span><br><span class="line">            reject(new Error(&#123;</span><br><span class="line">                errorType: &apos;abort_error&apos;,</span><br><span class="line">                xhr: xhr</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.ontimeout = function () &#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &apos;timeout_error&apos;,</span><br><span class="line">                xhr: xhr</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onerror = function () &#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &apos;onerror&apos;,</span><br><span class="line">                xhr: xhr</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onloadend = function () &#123;</span><br><span class="line">            if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304)</span><br><span class="line">                resolve(xhr);</span><br><span class="line">            else&#123;</span><br><span class="line">                reject(&#123;</span><br><span class="line">                    errorType: &apos;status_error&apos;,</span><br><span class="line">                    xhr: xhr</span><br><span class="line">                &#125;)</span><br><span class="line">               &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            xhr.send(options.data);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (e) &#123;</span><br><span class="line">            reject(&#123;</span><br><span class="line">                errorType: &apos;send_error&apos;,</span><br><span class="line">                error: e</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找-【二分查找也称折半查找-，时间复杂度：O-log2n-】"><a href="#二分查找-【二分查找也称折半查找-，时间复杂度：O-log2n-】" class="headerlink" title="二分查找  【二分查找也称折半查找 ，时间复杂度：O(log2n)】"></a>二分查找  【二分查找也称折半查找 ，时间复杂度：O(log2n)】</h3><blockquote><p>非递归算法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function binary_search(arr,key)&#123;</span><br><span class="line">  var low=0,</span><br><span class="line">  high=arr.length-1;</span><br><span class="line">  while(low&lt;=high)&#123;</span><br><span class="line">     var mid=parseInt((high+low)/2);</span><br><span class="line">     if(key==arr[mid])&#123;</span><br><span class="line">        return mid;</span><br><span class="line">     &#125;else if(key&gt;arr[mid])&#123;</span><br><span class="line">        low=mid+1;</span><br><span class="line">     &#125;else if(key&lt;arr[mid])&#123;</span><br><span class="line">        high=mid-1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var arr=[1,2,3,4,5,6,7,8,9,10,11,23,44,86];</span><br><span class="line">var result=binary_search(arr,10);</span><br><span class="line">alert(result); // 9 返回目标元素的索引值</span><br></pre></td></tr></table></figure><blockquote><p>递归算法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function binary_search(arr,low,high,key)&#123;</span><br><span class="line">  if(low&gt;high)&#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  var mid=parseInt((high+low)/2);</span><br><span class="line">  if(arr[mid]==key)&#123;</span><br><span class="line">    return mid;</span><br><span class="line">  &#125;else if(arr[mid]&gt;key)&#123;</span><br><span class="line">    high=mid-1;</span><br><span class="line">    return binary_search(arr,low,high,key);</span><br><span class="line">  &#125;else if(arr[mid]&lt;key)&#123;</span><br><span class="line">    low=mid+1;</span><br><span class="line">    return binary_search(arr,low,high,key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var arr=[1,2,3,4,5,6,7,8,9,10,11,23,44,86];</span><br><span class="line">var result=binary_search(arr,0,13,10);</span><br><span class="line">alert(result); // 9 返回目标元素的索引值</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote><p>冒泡排序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">    var len = arr.length;</span><br><span class="line">    for (var i = 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        for (var j = i+1; j &lt; len -1; j++) &#123;</span><br><span class="line">            arr[i] &gt; arr[j] ? [arr[i],arr[j]]= [arr[j],arr[i]]:null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">bubbleSort([1,2,4,7,2,8,0,9,11,32,17])</span><br><span class="line">           [0, 1, 2, 2, 4, 7, 8, 9, 11, 32, 17]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bubble_sort(arr)&#123;</span><br><span class="line">  for(var i=0;i&lt;arr.length-1;i++)&#123;</span><br><span class="line">    for(var j=0;j&lt;arr.length-i-1;j++)&#123;</span><br><span class="line">      if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">        var swap=arr[j];</span><br><span class="line">        arr[j]=arr[j+1];</span><br><span class="line">        arr[j+1]=swap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr=[3,1,5,7,2,4,9,6,10,8];</span><br><span class="line">bubble_sort(arr);</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><blockquote><p>快速排序</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function quick_sort(arr)&#123;</span><br><span class="line">  if(arr.length&lt;=1)&#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  var pivotIndex=Math.floor(arr.length/2);</span><br><span class="line">  var pivot=arr.splice(pivotIndex,1)[0];</span><br><span class="line"></span><br><span class="line">  var left=[];</span><br><span class="line">  var right=[];</span><br><span class="line">  for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    if(arr[i]&lt;pivot)&#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return quick_sort(left).concat([pivot],quick_sort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr=[5,6,2,1,3,8,7,1,2,3,4,7];</span><br><span class="line">console.log(quick_sort(arr));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function qSort(arr) &#123;</span><br><span class="line">      if (arr.length==0) &#123;</span><br><span class="line">          return [];</span><br><span class="line">      &#125;</span><br><span class="line">      var left = [];</span><br><span class="line">      var right = [];</span><br><span class="line">      var pivot = arr[0];</span><br><span class="line">      for (var i =1; i &lt;arr.length; i++) &#123; // 注意这里的起始值，因为有一个作为flag了</span><br><span class="line">         if (arr[i] &lt; pivot) &#123;</span><br><span class="line">               left.push(arr[i]);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              right.push(arr[i]);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return qSort(left).concat(pivot, qSort(right));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="当我们-new-一个类的时候-都发生了什么"><a href="#当我们-new-一个类的时候-都发生了什么" class="headerlink" title="当我们 new 一个类的时候 都发生了什么"></a>当我们 new 一个类的时候 都发生了什么</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * new2 new关键字的代码实现演示</span><br><span class="line"> * @param &#123;function&#125; func 被new的类 (构造函数)</span><br><span class="line"> */</span><br><span class="line">function new2(func) &#123;</span><br><span class="line">    // 创建了一个实例对象 o，并且这个对象__proto__指向func这个类的原型对象 </span><br><span class="line">    let o = Object.create(func.prototype); </span><br><span class="line">    // (在构造函数中this指向当前实例)让这个类作为普通函数值行 并且里面this为实例对象 </span><br><span class="line">    let k = func.call(o);</span><br><span class="line">    // 最后再将实例对象返回 如果你在类中显示指定返回值k，</span><br><span class="line">    // 注意如果返回的是引用类型则将默认返回的实例对象o替代掉</span><br><span class="line">    return typeof k === &apos;object&apos; ? k : o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实验</span><br><span class="line">functionM() &#123; // 即将被new的类</span><br><span class="line">    this.name = &apos;liwenli&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let m = new2(M); // 等价于 new M 这里只是模拟</span><br><span class="line">console.log(m instanceof M); // instanceof 检测实例</span><br><span class="line">console.log(m instanceof Object);</span><br><span class="line">console.log(m.__proto__.constructor === M);</span><br></pre></td></tr></table></figure><h3 id="new操作符的工作原理"><a href="#new操作符的工作原理" class="headerlink" title="new操作符的工作原理"></a>new操作符的工作原理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">废话不多说，直接上代码</span><br><span class="line">var newObj = function(func)&#123;</span><br><span class="line">    var t = &#123;&#125;</span><br><span class="line">    t.prototype = func.prototype</span><br><span class="line">    var o = t</span><br><span class="line">    var k =func.call(o);</span><br><span class="line">    if(typeof k === &apos;object&apos;)&#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var parent1 = newObj(Parent)等价于new操作</span><br><span class="line"></span><br><span class="line">1.一个新对象被创建，它继承自func.prototype。</span><br><span class="line">2.构造函数func 被执行，执行的时候，相应的参数会被传入，同时上下文（this） 会被指定为这个新实例。</span><br><span class="line">3.如果构造函数返回了一个新对象，那么这个对象会取代整个new出来的结果，如果构造函数没有返回对象，</span><br><span class="line">那么new出来的结果为步骤1创建的对象。</span><br></pre></td></tr></table></figure><h3 id="Object-create-兼容实现"><a href="#Object-create-兼容实现" class="headerlink" title="Object.create 兼容实现"></a>Object.create 兼容实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;id: 1&#125;;</span><br><span class="line">        Object._create = (o) =&gt; &#123;</span><br><span class="line">            let Fn = function() &#123;&#125;; // 临时的构造函数</span><br><span class="line">            Fn.prototype = o;</span><br><span class="line">            return new Fn;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let obj2 = Object._create(obj1);</span><br><span class="line">        console.log(obj2.__proto__ === obj1); // true</span><br><span class="line">        console.log(obj2.id); // 1</span><br><span class="line"></span><br><span class="line">        // 原生的Object.create</span><br><span class="line">        let obj3 = Object.create(obj1);</span><br><span class="line">        console.log(obj3.__proto__ === obj1); // true</span><br><span class="line">        console.log(obj3.id); // 1</span><br></pre></td></tr></table></figure><h3 id="curry-将多参数函数转换为接收单一参数的函数"><a href="#curry-将多参数函数转换为接收单一参数的函数" class="headerlink" title="curry 将多参数函数转换为接收单一参数的函数"></a>curry 将多参数函数转换为接收单一参数的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let fn = function(a, b, c) &#123; // 多参数函数</span><br><span class="line">           return a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">        function curry(fn) &#123;</span><br><span class="line">            let args = []; // 收集参数</span><br><span class="line">            let len = fn.length;</span><br><span class="line">            returnfunctionfe() &#123;</span><br><span class="line">                args = args.concat([].slice.call(arguments, 0));</span><br><span class="line">                if (args.length === len) &#123;</span><br><span class="line">                    return fn.apply(null, args);</span><br><span class="line">                &#125;</span><br><span class="line">                return fe;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        console.log(curry(fn)(1)(2)(3)); // 6</span><br></pre></td></tr></table></figure><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><blockquote><p>throttle 策略的电梯。保证如果电梯第一个人进来后，50毫秒后准时运送一次，不等待。如果没有人，则待机。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let throttle = (fn, delay = 50) =&gt; &#123; // 节流 控制执行间隔时间 防止频繁触发 scroll resize mousemove</span><br><span class="line">            let stattime = 0;</span><br><span class="line">            returnfunction (...args) &#123;</span><br><span class="line">                let curTime = new Date();</span><br><span class="line">                if (curTime - stattime &gt;= delay) &#123;</span><br><span class="line">                    fn.apply(this, args);</span><br><span class="line">                    stattime = curTime;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="防抖动"><a href="#防抖动" class="headerlink" title="防抖动"></a>防抖动</h3><blockquote><p>debounce 策略的电梯。如果电梯里有人进来，等待50毫秒。如果又人进来，50毫秒等待重新计时，直到50毫秒超时，开始运送。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let debounce = (fn, time = 50) =&gt; &#123; // 防抖动 控制空闲时间 用户输入频繁</span><br><span class="line">            let timer;</span><br><span class="line">            returnfunction (...args) &#123;</span><br><span class="line">                let that = this;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                timer = setTimeout(fn.bind(that, ...args), time);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="Function的bind实现"><a href="#Function的bind实现" class="headerlink" title="Function的bind实现"></a>Function的bind实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype._bind = function(context) &#123;</span><br><span class="line">    let func = this;</span><br><span class="line">    let params = [].slice.call(arguments, 1);</span><br><span class="line">    returnfunction() &#123;</span><br><span class="line">        params = params.concat([].slice.call(arguments, 0));</span><br><span class="line">        func.apply(context, params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj = &#123;id: 24&#125;</span><br><span class="line"></span><br><span class="line">function fn1(a) &#123;</span><br><span class="line">    console.log(this, arguments);</span><br><span class="line">&#125;</span><br><span class="line">let foo = fn1._bind(obj, obj.id);</span><br></pre></td></tr></table></figure><h3 id="函数组合串联compose（koa-reduce中间件）"><a href="#函数组合串联compose（koa-reduce中间件）" class="headerlink" title="函数组合串联compose（koa reduce中间件）"></a>函数组合串联compose（koa reduce中间件）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 组合串联</span><br><span class="line">let fn1 = (a) =&gt; a + 1;</span><br><span class="line">let fn2 = (b) =&gt; b + 2;</span><br><span class="line">let fn3 = (c) =&gt; c + 3;</span><br><span class="line"></span><br><span class="line">let funs = [fn1, fn2, fn3];</span><br><span class="line"></span><br><span class="line">let compose = (func) =&gt; &#123;</span><br><span class="line">    return arg =&gt; func.reduceRight((composed, fn) =&gt; fn(composed), arg);</span><br><span class="line">&#125;</span><br><span class="line">console.log(compose(funs)(100)); // 相当于fn1(fn2(fn3(100)))</span><br></pre></td></tr></table></figure><h3 id="co函数"><a href="#co函数" class="headerlink" title="co函数"></a>co函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function* fn(a) &#123;</span><br><span class="line">  a = yield a;</span><br><span class="line">  let b = yield 2;</span><br><span class="line">  let c = yield 3;</span><br><span class="line">  return a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function co(fn, ...args) &#123;</span><br><span class="line">  let g = fn(...args);</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    function next(lastValue) &#123;</span><br><span class="line">        let &#123; value, done &#125; = g.next(lastValue);</span><br><span class="line">        if (done) &#123;</span><br><span class="line">          resolve(value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">         if (value instanceof Promise) &#123;</span><br><span class="line">           value.then(next, (val) =&gt; reject(val));</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           next(value)</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">co(fn, 100).then(value =&gt; &#123;</span><br><span class="line">    console.log(value); // 105</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="如何主动中止Promise调用链"><a href="#如何主动中止Promise调用链" class="headerlink" title="如何主动中止Promise调用链"></a>如何主动中止Promise调用链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const p1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123; // 异步操作</span><br><span class="line">      resolve(&apos;start&apos;)</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.then((result) =&gt; &#123;</span><br><span class="line">   console.log(&apos;a&apos;, result); </span><br><span class="line">   return Promise.reject(&apos;中断后续调用&apos;); // 此时rejected的状态将直接跳到catch里，剩下的调用不会再继续</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">   console.log(&apos;b&apos;, result);</span><br><span class="line">&#125;).then(result =&gt; &#123;</span><br><span class="line">   console.log(&apos;c&apos;, result);</span><br><span class="line">&#125;).catch(err =&gt; &#123;</span><br><span class="line">   console.log(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// a start</span><br><span class="line">// 中断后续调用</span><br></pre></td></tr></table></figure><h3 id="window-requestAnimationFrame兼容性处理"><a href="#window-requestAnimationFrame兼容性处理" class="headerlink" title="window.requestAnimationFrame兼容性处理"></a>window.requestAnimationFrame兼容性处理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window._requestAnimationFrame = (function()&#123;</span><br><span class="line">  return  window.requestAnimationFrame       ||</span><br><span class="line">          window.webkitRequestAnimationFrame ||</span><br><span class="line">          window.mozRequestAnimationFrame    ||</span><br><span class="line">          function(callback)&#123;</span><br><span class="line">            window.setTimeout(callback, 1000 / 60);</span><br><span class="line">          &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="字符串是否符合回文规则"><a href="#字符串是否符合回文规则" class="headerlink" title="字符串是否符合回文规则"></a>字符串是否符合回文规则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">let str = &apos;My age is 0, 0 si ega ym.&apos;;</span><br><span class="line"></span><br><span class="line">方法一</span><br><span class="line">function palindrome(params) &#123;</span><br><span class="line">  params = params.replace(/[\W\s_]/ig, &apos;&apos;);</span><br><span class="line"> return params.toLowerCase()  === params.split(&apos;&apos;).reverse().join(&apos;&apos;).toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line">console.log(palindrome(str));</span><br><span class="line"></span><br><span class="line">方法二</span><br><span class="line">function palindrome(params) &#123;</span><br><span class="line">  params = params.replace(/[\W\s_]/ig, &apos;&apos;).toLowerCase();</span><br><span class="line">  for (var i = 0, j = params.length-1; i&lt;j; i++, j--) &#123;</span><br><span class="line">    if (params[i] !== params[j]) &#123;</span><br><span class="line">      returnfalse;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  returntrue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构-将-destructuringArray-1-2-3-4-“-a-b-c-”-gt-a-1-b-2-c-4"><a href="#解构-将-destructuringArray-1-2-3-4-“-a-b-c-”-gt-a-1-b-2-c-4" class="headerlink" title="解构:将 destructuringArray([1, [2, 3], 4], “[a, [b], c]”) =&gt; {a: 1, b: 2, c: 4}"></a>解构:将 destructuringArray([1, [2, 3], 4], “[a, [b], c]”) =&gt; {a: 1, b: 2, c: 4}</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 将 destructuringArray([1, [2, 3], 4], &quot;[a, [b], c]&quot;) =&gt; &#123;a: 1, b: 2, c: 4&#125;</span><br><span class="line">const targetArray = [1, [2, 3], 4];</span><br><span class="line">const formater = &quot;[a, [b], c]&quot;;</span><br><span class="line"></span><br><span class="line">const destructuringArray = (values, keys) =&gt; &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const obj = &#123;&#125;;</span><br><span class="line">    if (typeof keys === &apos;string&apos;) &#123;</span><br><span class="line">      keys = JSON.parse(keys.replace(/\w+/g, &apos;&quot;$&amp;&quot;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const iterate = (values, keys) =&gt;</span><br><span class="line">      keys.forEach((key, i) =&gt; &#123;</span><br><span class="line">        if(Array.isArray(key)) iterate(values[i], key)</span><br><span class="line">        else obj[key] = values[i]</span><br><span class="line">      &#125;)</span><br><span class="line">      </span><br><span class="line">    iterate(values, keys)</span><br><span class="line">    </span><br><span class="line">    return obj;</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.error(e.message);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组展平"><a href="#数组展平" class="headerlink" title="数组展平"></a>数组展平</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">将[[1, 2], 3, [[[4], 5]]] 展平为 [1, 2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">let arr = [[1, 2], 3, [[[4], 5]]]; // 数组展平</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return [].concat(</span><br><span class="line">        ...arr.map(x =&gt; Array.isArray(x) ? flatten(x) : x)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出数组中重复出现过的元素"><a href="#找出数组中重复出现过的元素" class="headerlink" title="找出数组中重复出现过的元素"></a>找出数组中重复出现过的元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 例如：[1，2，4，4，3，3，1，5，3]</span><br><span class="line">// 输出：[1，3，4]</span><br><span class="line">let arr = [1, 2, 4, 4, 3, 3, 1, 5, 3];</span><br><span class="line"></span><br><span class="line">// 方法一</span><br><span class="line">function repeat1(arr)&#123;</span><br><span class="line">var result = [], map = &#123;&#125;;</span><br><span class="line">arr.map(function(num)&#123;</span><br><span class="line">if(map[num] === 1) result.push(num); // 等于1说明之前出现过一次 这次重复出现了</span><br><span class="line">map[num] = (map[num] || 0) + 1; // 微妙之处 开始第一次出现无值 记为 0 + 1 = 1 下一次从1开始累加</span><br><span class="line">&#125;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(repeat1(arr));</span><br><span class="line"></span><br><span class="line">// 方法二</span><br><span class="line"></span><br><span class="line">function repeat(arr) &#123;</span><br><span class="line">    let result = arr.filter((x, i, self) =&gt; &#123;</span><br><span class="line">        return self.indexOf(x) === i &amp;&amp; self.lastIndexOf(x) !== i</span><br><span class="line">    &#125;); // </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(repeat(arr));</span><br></pre></td></tr></table></figure><h3 id="将数组中按照数字重复出现的次数进行排序"><a href="#将数组中按照数字重复出现的次数进行排序" class="headerlink" title="将数组中按照数字重复出现的次数进行排序"></a>将数组中按照数字重复出现的次数进行排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 如果次数相同 则按照值排序 比如  2, 2, 2和 1, 1, 1  应排序为 [1, 1, 1, 2, 2, 2]</span><br><span class="line">// 比如 [1,2,1,2,1,3,4,5,4,5,5,2,2] =&gt; [3, 4, 4, 1, 1, 1, 5, 5, 5, 2, 2, 2, 2]</span><br><span class="line"></span><br><span class="line">let arr = [9, 7, 7, 1, 2, 1, 2, 1, 3, 4, 5, 4, 5, 5, 2, 2];</span><br><span class="line">function sortArray(arr) &#123;</span><br><span class="line">    let obj = &#123;&#125;;</span><br><span class="line">    let newArr = [];</span><br><span class="line">    for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">      let cur = arr[i];</span><br><span class="line">      if(obj[cur])&#123;</span><br><span class="line">        obj[cur].push(cur);</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      obj[cur] = [cur];</span><br><span class="line">    &#125;</span><br><span class="line">    for(let k in obj) &#123;</span><br><span class="line">      if(obj.hasOwnProperty(k)) &#123;</span><br><span class="line">        newArr.push(obj[k])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newArr.sort((a, b) =&gt; &#123;</span><br><span class="line">      if(a.length === b.length)&#123;</span><br><span class="line">        return a[0] - b[0];</span><br><span class="line">      &#125;</span><br><span class="line">        return a.length - b.length;</span><br><span class="line">    &#125;);</span><br><span class="line">    newArr = newArr.reduce((prev, cur) =&gt; prev.concat(cur));</span><br><span class="line">    return newArr;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(sortArray(arr)); // [ 3, 9, 4, 4, 7, 7, 1, 1, 1, 5, 5, 5, 2, 2, 2, 2 ]</span><br></pre></td></tr></table></figure><h3 id="移动端关闭虚拟键盘"><a href="#移动端关闭虚拟键盘" class="headerlink" title="移动端关闭虚拟键盘"></a>移动端关闭虚拟键盘</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.activeElement.blur();</span><br></pre></td></tr></table></figure><h3 id="解决setInterval在浏览器切换中的问题"><a href="#解决setInterval在浏览器切换中的问题" class="headerlink" title="解决setInterval在浏览器切换中的问题"></a>解决setInterval在浏览器切换中的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">document.onvisibilitychange=function()&#123;</span><br><span class="line">  if(document.visibilityState==&quot;visible&quot;)&#123;</span><br><span class="line">      timer=setInterval(slidemove, 1000);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-透传"><a href="#Promise-透传" class="headerlink" title="Promise 透传"></a>Promise 透传</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1).then(2).then((a)=&gt;console.log(a))</span><br><span class="line"> 1</span><br><span class="line">Promise &#123;&lt;resolved&gt;: undefined&#125;</span><br></pre></td></tr></table></figure><h3 id="不用循环，创建一个长度为-100-的数组，并且每个元素的值等于它的下标"><a href="#不用循环，创建一个长度为-100-的数组，并且每个元素的值等于它的下标" class="headerlink" title="不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标"></a>不用循环，创建一个长度为 100 的数组，并且每个元素的值等于它的下标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">es6版：</span><br><span class="line">Array.from(Array(100).keys()) </span><br><span class="line">或者</span><br><span class="line">[...Array(100).keys()]</span><br><span class="line"></span><br><span class="line">Array(100).fill(0).map((t,i)=&gt;i)</span><br></pre></td></tr></table></figure><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</span><br><span class="line"></span><br><span class="line">（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</span><br><span class="line"></span><br><span class="line">（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</span><br><span class="line"></span><br><span class="line">（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</span><br><span class="line"></span><br><span class="line">上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;id:&apos;, this.id);</span><br><span class="line">  &#125;, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var id = 21;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; id: 42 &#125;);</span><br><span class="line">// id: 42</span><br></pre></td></tr></table></figure><h3 id="异步加载的区别"><a href="#异步加载的区别" class="headerlink" title="异步加载的区别"></a>异步加载的区别</h3><ul><li>defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行</li><li>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关<br>async和defer<br><img src="/2015/01/01/JS原生常用API大全/640.webp" alt=""></li></ul><h3 id="html-触底的条件是："><a href="#html-触底的条件是：" class="headerlink" title="html 触底的条件是："></a>html 触底的条件是：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement.scrollHeight ===</span><br><span class="line">document.documentElement.clientHeight + document.documentElement.scrollTop</span><br></pre></td></tr></table></figure><h3 id="雅虎十四条优化"><a href="#雅虎十四条优化" class="headerlink" title="雅虎十四条优化"></a>雅虎十四条优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 尽可能的减少 HTTP 的请求数content</span><br><span class="line">2. 使用 CDN（Content Delivery Network）server</span><br><span class="line">3. 添加 Expires 头(或者 Cache-control )server</span><br><span class="line">4. Gzip 组件server</span><br><span class="line">5. 将 CSS 样式放在页面的上方css</span><br><span class="line">6. 将脚本移动到底部（包括内联的）javascript</span><br><span class="line">7. 避免使用 CSS 中的 Expressionscss</span><br><span class="line">8. 将 JavaScript 和 CSS 独立成外部文件javascript css</span><br><span class="line">9. 减少 DNS 查询content</span><br><span class="line">10. 压缩 JavaScript 和 CSS (包括内联的)javascript css</span><br><span class="line">11. 避免重定向server</span><br><span class="line">12. 移除重复的脚本javascript</span><br><span class="line">13. 配置实体标签（ETags）css</span><br><span class="line">14. 使 AJAX 缓存</span><br><span class="line">15. DNS预读取 &lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://data.dadaabc.com/&quot;&gt;</span><br><span class="line">16. 多域名分发静态资源   同域下浏览器能并发的请求有限，为了增加并发，尤其是一些静态资源上，可以使用多个域名。</span><br><span class="line">17. 最小化重排和重绘</span><br><span class="line">18. 函数防抖和函数节流</span><br></pre></td></tr></table></figure><h3 id="微任务有两种-nextTick和then-那么这两个谁快呢？"><a href="#微任务有两种-nextTick和then-那么这两个谁快呢？" class="headerlink" title="微任务有两种 nextTick和then 那么这两个谁快呢？"></a>微任务有两种 nextTick和then 那么这两个谁快呢？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(&apos;123&apos;).then(res=&gt;&#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br><span class="line"> process.nextTick(() =&gt; console.log(&apos;nextTick&apos;))</span><br><span class="line"> </span><br><span class="line"> //顺序  nextTick 123</span><br><span class="line"> //很明显  nextTick快</span><br></pre></td></tr></table></figure><h3 id="setTimeout第三个参数"><a href="#setTimeout第三个参数" class="headerlink" title="setTimeout第三个参数"></a>setTimeout第三个参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function(...list)&#123;</span><br><span class="line">console.log(list);    //  [1, 2, 3, 4, 5]</span><br><span class="line">&#125;,100,1,2,3,4,5)</span><br></pre></td></tr></table></figure><h3 id="Object和Function之间最让人琢磨不透的"><a href="#Object和Function之间最让人琢磨不透的" class="headerlink" title="Object和Function之间最让人琢磨不透的"></a>Object和Function之间最让人琢磨不透的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object instanceof Object // true</span><br><span class="line">Object instanceof Function // true</span><br><span class="line">Function instanceof Function // true</span><br><span class="line">Function instanceof Object // true</span><br><span class="line"></span><br><span class="line">const o = &#123;&#125;</span><br><span class="line">o instanceof Object //true</span><br><span class="line">o instanceof Function // false</span><br><span class="line"></span><br><span class="line">function F () &#123;&#125;</span><br><span class="line">F instanceof Object //true</span><br><span class="line">F instanceof Function //true</span><br></pre></td></tr></table></figure><h3 id="文件上传进度提示使用Javascript的XMLHttpRequest的progress事件"><a href="#文件上传进度提示使用Javascript的XMLHttpRequest的progress事件" class="headerlink" title="文件上传进度提示使用Javascript的XMLHttpRequest的progress事件"></a>文件上传进度提示使用Javascript的XMLHttpRequest的progress事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">使用Javascript的XMLHttpRequest的progress事件，实现示例代码为：</span><br><span class="line"></span><br><span class="line">var formData = new FormData(); </span><br><span class="line">formData.append(&quot;file&quot;, document.getElementById(&apos;file&apos;).files[0]); </span><br><span class="line">formData.append(&quot;token&quot;, token_value); // 其他参数按这样子加入</span><br><span class="line"></span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;POST&apos;, &apos;/uploadurl&apos;);</span><br><span class="line">// 上传完成后的回调函数</span><br><span class="line">xhr.onload = function () &#123;</span><br><span class="line">  if (xhr.status === 200) &#123;</span><br><span class="line">　　console.log(&apos;上传成功&apos;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  　console.log(&apos;上传出错&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">// 获取上传进度</span><br><span class="line">xhr.upload.onprogress = function (event) &#123;</span><br><span class="line">  if (event.lengthComputable) &#123;</span><br><span class="line">    var percent = Math.floor(event.loaded / event.total * 100) ;</span><br><span class="line">    // 设置进度显示</span><br><span class="line">    $(&quot;#J_upload_progress&quot;).progress(&apos;set progress&apos;, percent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function A(obj) &#123;</span><br><span class="line">obj.s = &quot;哈&quot;</span><br><span class="line">obj = &#123;                     //obj 重新赋值，并且是一个对象，此时obj指向a的指针指向这个赋值对象</span><br><span class="line">&quot;name&quot;: 2,</span><br><span class="line">&quot;city&quot;: &quot;亚洲&quot;</span><br><span class="line">&#125;</span><br><span class="line">return obj</span><br><span class="line">&#125;</span><br><span class="line">var a = &#123;</span><br><span class="line">&quot;name&quot;: 1,</span><br><span class="line">&quot;city&quot;: &quot;中国&quot;</span><br><span class="line">&#125;</span><br><span class="line">var b = A(a);</span><br><span class="line">console.log(b);   //&#123;name: 2, city: &quot;亚洲&quot;&#125;</span><br><span class="line">console.log(a);   //&#123;name: 1, city: &quot;中国&quot;, s: &quot;哈&quot;&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="LESS和SASS"><a href="#LESS和SASS" class="headerlink" title="LESS和SASS"></a>LESS和SASS</h3><table><thead><tr><th>语言</th><th>实现</th><th>特性</th><th>赋值</th><th>缩进</th></tr></thead><tbody><tr><td>Sass</td><td>Ruby</td><td>变量$开头</td><td>$var: value</td><td>不需要</td></tr><tr><td>Less</td><td>JavaSript</td><td>变量@开头</td><td>@var: value</td><td>不需要</td></tr><tr><td>Stylus</td><td>NodeJs</td><td>不能使用@开头</td><td>var:10</td><td>都可以</td></tr></tbody></table><h3 id="创造纯净的对象"><a href="#创造纯净的对象" class="headerlink" title="创造纯净的对象"></a>创造纯净的对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">你可以创造100%纯净的对象，它不会从Object类继承任何方法（例如：构造函数、toString() 等）。</span><br><span class="line"></span><br><span class="line">const pureObject =Object.create(null);</span><br><span class="line">console.log(pureObject);//=&gt; &#123;&#125;</span><br><span class="line">console.log(pureObject.constructor);//=&gt; undefined</span><br><span class="line">console.log(pureObject.toString);//=&gt; undefined</span><br><span class="line">console.log(pureObject.hasOwnProperty);//=&gt; undefined</span><br></pre></td></tr></table></figure><h3 id="将一个任意长的数字变成逗号分割的格式"><a href="#将一个任意长的数字变成逗号分割的格式" class="headerlink" title="将一个任意长的数字变成逗号分割的格式"></a>将一个任意长的数字变成逗号分割的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line"></span><br><span class="line">// 保留三位小数</span><br><span class="line">parseToMoney(1234.56); // return &apos;1,234.56&apos;</span><br><span class="line">parseToMoney(123456789); // return &apos;123,456,789&apos;</span><br><span class="line">parseToMoney(1087654.321); // return &apos;1,087,654.321&apos;</span><br><span class="line">答：</span><br><span class="line"></span><br><span class="line">functionparseToMoney(num) &#123;</span><br><span class="line">  num = parseFloat(num.toFixed(3));</span><br><span class="line">  let [integer, decimal] = String.prototype.split.call(num, &apos;.&apos;);</span><br><span class="line">  integer = integer.replace(/\d(?=(\d&#123;3&#125;)+$)/g, &apos;$&amp;,&apos;);</span><br><span class="line">  return integer + &apos;.&apos; + (decimal ? decimal : &apos;&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检测对象中属性的存在"><a href="#检测对象中属性的存在" class="headerlink" title="检测对象中属性的存在"></a>检测对象中属性的存在</h3><blockquote><p>使用in关键字。</p></blockquote><p>该方法可以判断对象的自有属性和继承来的属性是否存在。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;x:1&#125;;</span><br><span class="line">&quot;x&quot; in o;            //true，自有属性存在</span><br><span class="line">&quot;y&quot; in o;            //false</span><br><span class="line">&quot;toString&quot; in o;     //true，是一个继承属性</span><br></pre></td></tr></table></figure></p><blockquote><p>使用对象的hasOwnProperty()方法。</p></blockquote><p>该方法只能判断自有属性是否存在，对于继承属性会返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;x:1&#125;;</span><br><span class="line">o.hasOwnProperty(&quot;x&quot;);    　　 //true，自有属性中有x</span><br><span class="line">o.hasOwnProperty(&quot;y&quot;);    　　 //false，自有属性中不存在y</span><br><span class="line">o.hasOwnProperty(&quot;toString&quot;); //false，这是一个继承属性，但不是自有属性</span><br></pre></td></tr></table></figure></p><h3 id="n"><a href="#n" class="headerlink" title="n!"></a>n!</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">functionfactorial(number)&#123;</span><br><span class="line">    if(number==1) &#123;</span><br><span class="line">      return number;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">      return number*factorial(number-1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列-1-1-2-3-5-8-13-21-34-55-89-144-…-求第n个数是多少"><a href="#斐波那契数列-1-1-2-3-5-8-13-21-34-55-89-144-…-求第n个数是多少" class="headerlink" title="斐波那契数列:1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, … 求第n个数是多少"></a>斐波那契数列:1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, … 求第n个数是多少</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">functionfibonacci(number) &#123;</span><br><span class="line">     if (number &lt;=2) &#123;</span><br><span class="line">       return1;</span><br><span class="line">     &#125;</span><br><span class="line">     returnfibonacci(number-1) +fibonacci(number -2)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="服务端推送的几种方式"><a href="#服务端推送的几种方式" class="headerlink" title="服务端推送的几种方式"></a>服务端推送的几种方式</h3><p>服务端推送是现今<code>Web</code>开发过程中最常见的需求。例如：</p><ul><li>即时聊天工具</li><li>H5网络游戏</li><li>消息通知</li></ul><p>一般的服务器推送包括：</p><ul><li>最简单的是客户端轮询的方式，在客户端创建一个定时器，每隔一定的时间去请求服务端，每次请求检查状态变化以判断服务端是否有新数据更新。</li><li>基于 AJAX 的长轮询（<code>long-polling</code>）方式，服务器在一段时间后再返回信息；</li><li><code>HTTP Streaming</code>，通过<code>iframe</code>和<code>&lt;script&gt;</code>标签完成数据的传输；</li><li><code>TCP</code>长连接/<code>WebSocket</code>，可以实现服务器主动发送数据至网页端，它和<code>HTTP</code>一样，是一个基于<code>HTTP</code>的应用层协议，跑的是<code>TCP</code>，所以本质上还是个长连接，双向通信，意味着服务器端和客户端可以同时发送并响应请求，而不再像<code>HTTP</code>的请求和响应</li><li><code>SSE: Server-Sent Events</code>，【webpack】这是通过<code>http</code>协议变通实现的，通过服务端向客户端声明，接下来是要发送的是流信息，本质上就是完成一次耗时长的下载。</li></ul><hr><h3 id="JavaScript进阶提高必读"><a href="#JavaScript进阶提高必读" class="headerlink" title="JavaScript进阶提高必读"></a><a href="https://github.com/mqyqingfeng/Blog" target="_blank" rel="noopener">JavaScript进阶提高必读</a></h3><h3 id="JavaScript常用七种继承方案"><a href="#JavaScript常用七种继承方案" class="headerlink" title="JavaScript常用七种继承方案"></a><a href="https://juejin.im/post/5bcb2e295188255c55472db0" target="_blank" rel="noopener">JavaScript常用七种继承方案</a></h3><h3 id="JS-面试原生常用api-方法大全"><a href="#JS-面试原生常用api-方法大全" class="headerlink" title="JS 面试原生常用api 方法大全"></a><a href="https://github.com/libin1991/libin_Blog/issues/476?from=timeline" target="_blank" rel="noopener">JS 面试原生常用api 方法大全</a></h3><h3 id="JS代码手写题"><a href="#JS代码手写题" class="headerlink" title="JS代码手写题"></a><a href="https://github.com/libin1991/libin_Blog/issues/388?from=timeline" target="_blank" rel="noopener">JS代码手写题</a></h3><h3 id="PM2来部署nodejs服务器永久开启"><a href="#PM2来部署nodejs服务器永久开启" class="headerlink" title="PM2来部署nodejs服务器永久开启"></a><a href="https://www.cnblogs.com/lxg0/p/7771229.html?from=timeline" target="_blank" rel="noopener">PM2来部署nodejs服务器永久开启</a></h3><h3 id="JavaScript设计模式"><a href="#JavaScript设计模式" class="headerlink" title="JavaScript设计模式"></a><a href="http://techblog.sishuxuefu.com/" target="_blank" rel="noopener">JavaScript设计模式</a></h3><h3 id="URL-解析"><a href="#URL-解析" class="headerlink" title="URL 解析"></a><a href="https://juejin.im/post/5bce96bff265da0ae801513c" target="_blank" rel="noopener">URL 解析</a></h3><h3 id="JavaScript专题"><a href="#JavaScript专题" class="headerlink" title="JavaScript专题"></a><a href="https://juejin.im/user/58f980918d6d8100587ea7f4/posts" target="_blank" rel="noopener">JavaScript专题</a></h3><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="https://www.cnblogs.com/jiqing9006/category/461295.html" target="_blank" rel="noopener">数据结构</a></h3><h3 id="轻松理解JavaScript原型及原型链"><a href="#轻松理解JavaScript原型及原型链" class="headerlink" title="轻松理解JavaScript原型及原型链"></a><a href="https://juejin.im/post/5be42b34f265da61616e3056" target="_blank" rel="noopener">轻松理解JavaScript原型及原型链</a></h3><h3 id="H5-移动调试全攻略"><a href="#H5-移动调试全攻略" class="headerlink" title="H5 移动调试全攻略"></a><a href="http://jartto.wang/2018/11/01/mobile-debug/" target="_blank" rel="noopener">H5 移动调试全攻略</a></h3><h3 id="JS-面试原生常用api-方法大全-1"><a href="#JS-面试原生常用api-方法大全-1" class="headerlink" title="JS 面试原生常用api 方法大全"></a><a href="https://github.com/libin1991/libin_Blog/issues/476" target="_blank" rel="noopener">JS 面试原生常用api 方法大全</a></h3><h3 id="javascript-原生常用API大全"><a href="#javascript-原生常用API大全" class="headerlink" title="javascript 原生常用API大全"></a><a href="https://github.com/libin1991/libin_Blog/issues/412" target="_blank" rel="noopener">javascript 原生常用API大全</a></h3><hr><p><img src="/2015/01/01/JS原生常用API大全/62002d6d0dab2d26a897d9591bb64efd.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/20181109201728.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201653.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201814.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201821.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201850.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201858.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109201910.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202057.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202113.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202129.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202148.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202207.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202213.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/微信图片_20181109202237.jpg" alt=""></p><h3 id="preload、prefetch"><a href="#preload、prefetch" class="headerlink" title="preload、prefetch"></a>preload、prefetch</h3><p>现在的网络情况虽然很乐观，但是</p><h4 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h4><p>当浏览器碰到 script 脚本的时候：</p><p><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p><p>没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p><p><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></p><p>有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。</p><p><code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code></p><p>有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p><p>然后从实用角度来说呢，首先把所有脚本都丢到 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p><p>接着，我们来看一张图咯：</p><p><img src="/2015/01/01/JS原生常用API大全/640.webp" alt=""></p><p>此图告诉我们以下几个要点：</p><ol><li><p>defer 和 async 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</p></li><li><p>它俩的差别在于脚本下载完之后何时执行，显然 defer 是最接近我们对于应用脚本加载和执行的要求的</p></li><li><p>关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</p></li><li><p>async 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</p></li><li><p>仔细想想，async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，</p></li></ol><h3 id="preload和refetch"><a href="#preload和refetch" class="headerlink" title="preload和refetch"></a>preload和refetch</h3><p><code>preload</code>通常在页面中，我们需要加载一些脚本和样式，而使用 preload 可以对当前页面所需的脚本、样式等资源进行预加载，而无需等到解析到 script 和 link 标签时才进行加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。</p><p>使用方式<br>将 link 标签的 rel 属性的值设为 preload，as 属性的值为资源类型（如脚本为 script，样式表为 style）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> &lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;title&gt;</span><br><span class="line">preload example</span><br><span class="line">&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对 style.css 和 index.js 进行预加载 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;index.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><font color="#dd0000"> <code>prefetch</code>与 <code>preload</code> 一样，都是对资源进行预加载，但是 prefetch 加载的资源一般不是用于当前页面的，即未来很可能用到的这样一些资源，简单点说就是其他页面会用到的资源。当然，prefetch 不会像 preload 一样，在页面渲染的时候加载资源，而是利用浏览器空闲时间来下载。当进入下一页面，就可直接从 disk cache 里面取，既不影响当前页面的渲染，又提高了其他页面加载渲染的速度。</font><p>使用方式<br>同 <code>preload</code> 很相似，无需指定 as 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> &lt;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;title&gt;</span><br><span class="line">preload example</span><br><span class="line">&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对 style.css 和 index.js 进行 preload 预加载 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;index.js&quot; as=&quot;script&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 对资源进行 prefetch 预加载 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;next.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;next.js&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><table><tr><td bgcolor="#FF0000"><font color="#fff"><strong>总结:对当前页面需要的资源，使用 preload 进行预加载，对其它页面需要的资源进行 prefetch 预加载。</strong></font></td></tr></table><h4 id="Subresource和Prerender"><a href="#Subresource和Prerender" class="headerlink" title="Subresource和Prerender"></a>Subresource和Prerender</h4><p><code>subresource</code>可以用来指定资源是最高优先级的。比如，在Chrome和Opera中我们可以加上下面的代码：</p><p><code>&lt;link rel=&quot;subresource&quot; href=&quot;styles.css&quot;&gt;</code></p><blockquote><p>Chromium的文档这么解释：<br>和 “Link rel=prefetch”的语义不同，”Link rel=subresource”是一种新的连接关系。rel=prefetch指定了下载后续页面用到资源的低优先级，而rel=subresource则是指定当前页面资源的提前加载。</p></blockquote><p>所以，如果资源是在当前页面需要，或者马上就会用到，则推荐用subresource，否则还是用prefetch。</p><p><code>prerender</code>是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。</p><p><code>&lt;link rel=&quot;prerender&quot; href=&quot;/thenextpage.html&quot; /&gt;</code></p><blockquote><p>Steve Souders的文章详细解释了这个技术：<br>prerender就像是在后台打开了一个隐藏的tab，会下载所有的资源、创建DOM、渲染页面、执行JS等等。如果用户进入指定的链接，隐藏的这个页面就会进入马上进入用户的视线。Google Search多年前就利用了这个特性实现了Instant Pages功能。微软最近也宣布会让Bing在IE11上用类似prerender的技术。</p></blockquote><h3 id="Axios拦截器"><a href="#Axios拦截器" class="headerlink" title="Axios拦截器"></a>Axios拦截器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">import &#123; throwErr &#125; from &apos;@/utils&apos; //utils 捕捉服务端http状态码的方法</span><br><span class="line">import store from &apos;@/store&apos;   //引入vuex的相关操作</span><br><span class="line">import &#123; Message &#125; from &apos;element-ui&apos; //element Toast的提示</span><br><span class="line">import router from &apos;@/router&apos;</span><br><span class="line"></span><br><span class="line">//过滤请求</span><br><span class="line">axios.interceptors.request.use(config =&gt; &#123;</span><br><span class="line">  //config 为请求的一些配置 例如：请求头 请求时间 Token  可以根据自己的项目需求个性化配置，参考axios的中文说明手册  自己多动动手</span><br><span class="line"> //由于我们项目的后端大大给力，很多东西在服务端帮我们处理好了所以请求阶段只要传好参数就好了</span><br><span class="line">  config.timeout = 10 * 1000 //请求响应时间</span><br><span class="line">  return config</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">  return Promise.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line">// 添加响应拦截器</span><br><span class="line">axios.interceptors.response.use(</span><br><span class="line">  response =&gt; &#123;</span><br><span class="line">    if (response.data.code === 0) &#123;   //服务端定义的响应code码为0时请求成功</span><br><span class="line">      return Promise.resolve(response.data) //使用Promise.resolve 正常响应</span><br><span class="line">    &#125; else if (response.data.code === 1401) &#123; //服务端定义的响应code码为1401时为未登录</span><br><span class="line">      store.dispatch(&apos;setUserInfo&apos;, &#123;&#125;)</span><br><span class="line">      Message(&#123;</span><br><span class="line">        message: &apos;未登录&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">      // router.push(&apos;/login&apos;)</span><br><span class="line">      return Promise.reject(response.data)    //使用Promise.reject 抛出错误和异常</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return Promise.reject(response.data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    if (error &amp;&amp; error.response) &#123;</span><br><span class="line">      let res = &#123;&#125;</span><br><span class="line">      res.code = error.response.status</span><br><span class="line">      res.msg = throwErr(error.response.status, error.response) //throwErr 捕捉服务端的http状态码 定义在utils工具类的方法</span><br><span class="line">      return Promise.reject(res)</span><br><span class="line">    &#125;</span><br><span class="line">    return Promise.reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">export default function request(method, url, data) &#123;  //暴露 request 给我们好API 管理</span><br><span class="line">  method = method.toLocaleLowerCase()   //封装RESTful API的各种请求方式 以 post get delete为例</span><br><span class="line">  if (method === &apos;post&apos;) &#123;</span><br><span class="line">    return axios.post(url, data)    //axios的post 默认转化为json格式</span><br><span class="line">  &#125; else if (method === &apos;get&apos;) &#123;     </span><br><span class="line">    return axios.get(url, &#123;</span><br><span class="line">      params: data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else if (method === &apos;delete&apos;) &#123;</span><br><span class="line">    return axios.delete(url, &#123;</span><br><span class="line">      params: data</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript的值传递和引用传递"><a href="#JavaScript的值传递和引用传递" class="headerlink" title="*JavaScript的值传递和引用传递"></a>*<a href="https://juejin.im/post/5beb934df265da61797460fd" target="_blank" rel="noopener">JavaScript的值传递和引用传递</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function changeAgeAndReference(person) &#123;</span><br><span class="line">    person.age = 25;</span><br><span class="line">    person = &#123;</span><br><span class="line">        name: &apos;John&apos;,</span><br><span class="line">        age: 50</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    return person;</span><br><span class="line">&#125;</span><br><span class="line">var personObj1 = &#123;</span><br><span class="line">    name: &apos;Alex&apos;,</span><br><span class="line">    age: 30</span><br><span class="line">&#125;;</span><br><span class="line">var personObj2 = changeAgeAndReference(personObj1);</span><br><span class="line">console.log(personObj1); // -&gt; &#123;name: &quot;Alex&quot;, age: 25&#125;</span><br><span class="line">console.log(personObj2); // -&gt; &#123;name: &quot;John&quot;, age: 50&#125;</span><br></pre></td></tr></table></figure><h3 id="JSONP-【JSONP百度搜索框】"><a href="#JSONP-【JSONP百度搜索框】" class="headerlink" title="JSONP 【JSONP百度搜索框】"></a>JSONP 【JSONP百度搜索框】</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">ul,</span><br><span class="line">li &#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.search &#123;</span><br><span class="line">display: block;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">height: 22px;</span><br><span class="line">position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.search-out &#123;</span><br><span class="line">position: absolute;</span><br><span class="line">width: 200px;</span><br><span class="line">height: 300px;</span><br><span class="line">z-index: 10;</span><br><span class="line">top: 23px;</span><br><span class="line">color: #7e8c8d;</span><br><span class="line">overflow-x: hidden;</span><br><span class="line">overflow-y: auto;</span><br><span class="line">margin-top: 5px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.search-out ul li &#123;</span><br><span class="line">font-size: 12px;</span><br><span class="line">height: 25px;</span><br><span class="line">/*li溢出省略*/</span><br><span class="line">overflow: hidden;</span><br><span class="line">text-overflow: ellipsis;</span><br><span class="line">white-space: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.search-out ul li:hover &#123;</span><br><span class="line">background-color: #edf0f1;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line"></span><br><span class="line">let input = document.getElementById(&apos;input&apos;),</span><br><span class="line">body = document.getElementsByClassName(&apos;search&apos;)[0],</span><br><span class="line">btn = document.getElementsByTagName(&quot;button&quot;)[0],</span><br><span class="line">ul = document.getElementById(&apos;ul&apos;);</span><br><span class="line">var globalData = [&apos;历史1&apos;, &apos;历史2&apos;]; //globalData数据，存储历史搜索</span><br><span class="line"></span><br><span class="line">input.addEventListener(&apos;focus&apos;, function() &#123;</span><br><span class="line">var htmlText = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; globalData.length; i++) &#123;</span><br><span class="line">htmlText += &apos;&lt;li&gt;&apos; + globalData[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">ul.innerHTML = htmlText;</span><br><span class="line">ul.style.border = &quot;solid 1px #dee6e8&quot;;</span><br><span class="line">ul.style.background = &quot;white&quot;;</span><br><span class="line">&#125;);</span><br><span class="line">btn.addEventListener(&quot;click&quot;, function() &#123; //当点击搜索按钮把输入框数据添加至历史数组</span><br><span class="line">if(input.value) &#123;</span><br><span class="line">globalData.push(input.value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.addEventListener(&apos;blur&apos;, function() &#123; //离开输入框隐藏历史下拉列表</span><br><span class="line">ul.style.border = &quot;&quot;;</span><br><span class="line">ul.style.background = &quot;&quot;;</span><br><span class="line">ul.innerHTML = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//监听input事件</span><br><span class="line">input.addEventListener(&apos;input&apos;, function() &#123;</span><br><span class="line">console.log(input.value)</span><br><span class="line">if(!input.value) &#123;</span><br><span class="line">var htmlText = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">for(var i = 0; i &lt; globalData.length; i++) &#123;</span><br><span class="line">htmlText += &apos;&lt;li&gt;&apos; + globalData[i] + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">ul.innerHTML = htmlText;</span><br><span class="line">ul.style.border = &quot;solid 1px #dee6e8&quot;;</span><br><span class="line">ul.style.background = &quot;white&quot;;</span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var val = encodeURI(input.value);</span><br><span class="line">ul.innerHTML = &apos;&apos;; //清空上一次请求所插入的li</span><br><span class="line">jsonp(&#123;</span><br><span class="line">url: &apos;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&apos; + val + &apos;&amp;cb=&apos;,</span><br><span class="line">time: 3000,</span><br><span class="line">callback: function(json) &#123;</span><br><span class="line">var htmlText = &apos;&apos;;</span><br><span class="line">for(var i = 0; i &lt; json.s.length; i++) &#123;</span><br><span class="line">htmlText += &apos;&lt;li&gt;&apos; + json[&apos;s&apos;][i] + &apos;&lt;/li&gt;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">ul.innerHTML = htmlText;</span><br><span class="line">&#125;,</span><br><span class="line">fail: function(mes) &#123;</span><br><span class="line">alert(mes);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function jsonp(objects) &#123;</span><br><span class="line">objects = objects || &#123;&#125;;</span><br><span class="line">if(!objects.url || !objects.callback) &#123;</span><br><span class="line">throw new Error(&apos;参数不合法&apos;);</span><br><span class="line">&#125;</span><br><span class="line">//创建script标签并插入</span><br><span class="line">var callbackName = (&apos;jsonp_&apos; + Math.random()).replace(&quot;.&quot;, &quot;&quot;); //随机生成callbackName</span><br><span class="line">var script = document.createElement(&apos;script&apos;);</span><br><span class="line">var body = document.getElementsByClassName(&apos;search&apos;)[0];</span><br><span class="line">body.appendChild(script);</span><br><span class="line">window[callbackName] = function(json) &#123;</span><br><span class="line">body.removeChild(script);</span><br><span class="line">clearTimeout(script.timer);</span><br><span class="line">window[callbackName] = null;</span><br><span class="line">objects.callback &amp;&amp; objects.callback(json);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//发出请求</span><br><span class="line">script.src = objects.url + callbackName;</span><br><span class="line"></span><br><span class="line">//响应时间</span><br><span class="line">if(objects.time) &#123;</span><br><span class="line">script.timer = setTimeout(function() &#123;</span><br><span class="line">window[callbackName] = null;</span><br><span class="line">body.removeChild(script);</span><br><span class="line">objects.fail &amp;&amp; objects.fail(&apos;超时&apos;);</span><br><span class="line">&#125;, objects.time);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;search&quot;&gt;</span><br><span class="line">&lt;input id=&quot;input&quot; type=&quot;text&quot; placeholder=&quot;搜索材质&quot;&gt;</span><br><span class="line">&lt;span&gt;</span><br><span class="line">&lt;button&gt;搜索&lt;/button&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;div class=&quot;search-out&quot;&gt;</span><br><span class="line">&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="Math-round-，Math-ceil-，Math-floor-的区别"><a href="#Math-round-，Math-ceil-，Math-floor-的区别" class="headerlink" title="Math.round()，Math.ceil()，Math.floor()的区别"></a>Math.round()，Math.ceil()，Math.floor()的区别</h3><p>1.Math.round()：根据“round”的字面意思“附近、周围”，可以猜测该函数是求一个附近的整数，看下面几个例子就明白。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">小数点后第一位&lt;5</span><br><span class="line">正数：Math.round(11.46)=11</span><br><span class="line">负数：Math.round(-11.46)=-11</span><br><span class="line"> </span><br><span class="line">小数点后第一位&gt;5</span><br><span class="line">正数：Math.round(11.68)=12</span><br><span class="line">负数：Math.round(-11.68)=-12</span><br><span class="line"> </span><br><span class="line">小数点后第一位=5</span><br><span class="line">正数：Math.round(11.5)=12</span><br><span class="line">负数：Math.round(-11.5)=-11</span><br><span class="line">总结：（小数点后第一位）大于五全部加，等于五正数加，小于五全不加。</span><br></pre></td></tr></table></figure></p><p>2.Math.ceil()：根据“ceil”的字面意思“天花板”去理解；<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(11.46)=Math.ceil(11.68)=Math.ceil(11.5)=12</span><br><span class="line">Math.ceil(-11.46)=Math.ceil(-11.68)=Math.ceil(-11.5)=-11</span><br></pre></td></tr></table></figure></p><p>3.Math.floor()：根据“floor”的字面意思“地板”去理解；<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(11.46)=Math.ceil(11.68)=Math.ceil(11.5)=11</span><br><span class="line">Math.ceil(-11.46)=Math.ceil(-11.68)=Math.ceil(-11.5)=-12</span><br></pre></td></tr></table></figure></p><h3 id="Math-random-函数生成n到m间的随机数字"><a href="#Math-random-函数生成n到m间的随机数字" class="headerlink" title="Math.random()函数生成n到m间的随机数字"></a>Math.random()函数生成n到m间的随机数字</h3><p>Math.random()函数返回0和1之间的伪随机数，可能为0，但总是小于1，[0,1)</p><blockquote><p>生成n-m，包含n但不包含m的整数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步算出 m-n的值，假设等于w</span><br><span class="line"></span><br><span class="line">第二步Math.random()*w</span><br><span class="line"></span><br><span class="line">第三步Math.random()*w+n</span><br><span class="line"></span><br><span class="line">第四步parseInt(Math.random()*w+n, 10)</span><br></pre></td></tr></table></figure><blockquote><p>生成n-m，不包含n但包含m的整数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步算出 m-n的值，假设等于w</span><br><span class="line"></span><br><span class="line">第二步Math.random()*w</span><br><span class="line"></span><br><span class="line">第三步Math.random()*w+n</span><br><span class="line"></span><br><span class="line">第四步Math.floor(Math.random()*w+n) + 1</span><br></pre></td></tr></table></figure><blockquote><p>生成n-m，不包含n和m的整数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步算出 m-n-2的值，假设等于w</span><br><span class="line"></span><br><span class="line">第二步Math.random()*w</span><br><span class="line"></span><br><span class="line">第三步Math.random()*w+n +1</span><br><span class="line"></span><br><span class="line">第四步Math.round(Math.random()*w+n+1) 或者 Math.ceil(Math.random()*w+n+1)</span><br></pre></td></tr></table></figure><blockquote><p>生成n-m，包含n和m的随机数：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一步算出 m-n的值，假设等于w</span><br><span class="line"></span><br><span class="line">第二步Math.random()*w</span><br><span class="line"></span><br><span class="line">第三步Math.random()*w+n</span><br><span class="line"></span><br><span class="line">第四步Math.round(Math.random()*w+n) 或者 Math.ceil(Math.random()*w+n)</span><br></pre></td></tr></table></figure><h3 id="ES6事件总线-EventBus"><a href="#ES6事件总线-EventBus" class="headerlink" title="ES6事件总线 EventBus"></a>ES6事件总线 EventBus</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class EventBus &#123;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.events = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on(type, callback, scope, ...args) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            this.events[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        this.events[type].push(&#123;scope: scope, callback: callback, args: args&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off(type, callback, scope) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let numOfCallbacks = this.events[type].length;</span><br><span class="line">        let newArray = [];</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = this.events[type][i];</span><br><span class="line">            if (event.scope == scope &amp;&amp; event.callback == callback) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                newArray.push(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.events[type] = newArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    has(type, callback, scope) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        let numOfCallbacks = this.events[type].length;</span><br><span class="line">        if (callback === undefined &amp;&amp; scope === undefined) &#123;</span><br><span class="line">            return numOfCallbacks &gt; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = this.events[type][i];</span><br><span class="line">            if ((scope ? event.scope == scope : true) &amp;&amp; event.callback == callback) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    emit(type, target, ...args) &#123;</span><br><span class="line">        if (typeof this.events[type] == &quot;undefined&quot;) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        let bag = &#123;</span><br><span class="line">            type: type,</span><br><span class="line">            target: target</span><br><span class="line">        &#125;;</span><br><span class="line">        args = [bag].concat(args);</span><br><span class="line">        let events = this.events[type].slice();</span><br><span class="line">        let numOfCallbacks = events.length;</span><br><span class="line">        for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">            let event = events[i];</span><br><span class="line">            if (event &amp;&amp; event.callback) &#123;</span><br><span class="line">                let concatArgs = args.concat(event.args);</span><br><span class="line">                event.callback.apply(event.scope, concatArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    debug() &#123;</span><br><span class="line">        let str = &quot;&quot;;</span><br><span class="line">        for (let type in this.events) &#123;</span><br><span class="line">            let numOfCallbacks = this.events[type].length;</span><br><span class="line">            for (let i = 0; i &lt; numOfCallbacks; i++) &#123;</span><br><span class="line">                let event = this.events[type][i];</span><br><span class="line">                let className = &quot;Anonymous&quot;;</span><br><span class="line">                if (event.scope) &#123;</span><br><span class="line">                    if (event.scope.constructor.name) &#123;</span><br><span class="line">                        className = event.scope.constructor.name;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                str += `$&#123;className&#125; listening for &quot;$&#123;type&#125;&quot;\n`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default new EventBus();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;EventBus Examples&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;module&quot;&gt;</span><br><span class="line">    import EventBus from &apos;/src/eventbus.js&apos;;</span><br><span class="line">    // Simple example</span><br><span class="line">    &#123;</span><br><span class="line">        function myHandler(event) &#123;</span><br><span class="line">            console.log(&quot;myHandler / type: &quot; + event.type);</span><br><span class="line">        &#125;</span><br><span class="line">        EventBus.on(&quot;my_event&quot;, myHandler);</span><br><span class="line">        EventBus.emit(&quot;my_event&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // Keeping the scope</span><br><span class="line">    &#123;</span><br><span class="line">        class TestClass1 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass1&quot;;</span><br><span class="line">                EventBus.on(&quot;callback_event&quot;, this.callback, this);</span><br><span class="line">            &#125;</span><br><span class="line">            callback(event) &#123;</span><br><span class="line">                console.log(this.className + &quot; / type: &quot; + event.type + &quot; / dispatcher: &quot; + event.target.className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class TestClass2 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass2&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            dispatch() &#123;</span><br><span class="line">                EventBus.emit(&quot;callback_event&quot;, this);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let t1 = new TestClass1();</span><br><span class="line">        let t2 = new TestClass2();</span><br><span class="line">        t2.dispatch();</span><br><span class="line">    &#125;</span><br><span class="line">    // Passing additional parameters</span><br><span class="line">    &#123;</span><br><span class="line">        class TestClass1 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass1&quot;;</span><br><span class="line">                EventBus.on(&quot;custom_event&quot;, this.doSomething, this);</span><br><span class="line">            &#125;</span><br><span class="line">            doSomething(event, param1, param2) &#123;</span><br><span class="line">                console.log(this.className + &quot;.doSomething&quot;);</span><br><span class="line">                console.log(&quot;type=&quot; + event.type);</span><br><span class="line">                console.log(&quot;params=&quot; + param1 + param2);</span><br><span class="line">                console.log(&quot;coming from=&quot; + event.target.className);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        class TestClass2 &#123;</span><br><span class="line">            constructor() &#123;</span><br><span class="line">                this.className = &quot;TestClass2&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            ready() &#123;</span><br><span class="line">                EventBus.emit(&quot;custom_event&quot;, this, &quot;javascript events&quot;, &quot; are really useful&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let t1 = new TestClass1();</span><br><span class="line">        let t2 = new TestClass2();</span><br><span class="line">        t2.ready();</span><br><span class="line">    &#125;</span><br><span class="line">    // Debugging</span><br><span class="line">    console.log(EventBus.debug());</span><br><span class="line">    // Removing a registered handler</span><br><span class="line">    &#123;</span><br><span class="line">        var handler = function() &#123;</span><br><span class="line">            console.log(&apos;example callback&apos;);</span><br><span class="line">        &#125;;</span><br><span class="line">        EventBus.on(&apos;EXAMPLE_EVENT&apos;, handler);</span><br><span class="line">        EventBus.emit(&apos;EXAMPLE_EVENT&apos;);</span><br><span class="line">        EventBus.off(&apos;EXAMPLE_EVENT&apos;, handler);</span><br><span class="line">        // Not emitted because event was removed</span><br><span class="line">        EventBus.emit(&apos;EXAMPLE_EVENT&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="JS全排列-【全排列是一种时间复杂度为：O-n-的算法】"><a href="#JS全排列-【全排列是一种时间复杂度为：O-n-的算法】" class="headerlink" title="JS全排列  【全排列是一种时间复杂度为：O(n!)的算法】"></a>JS全排列  【全排列是一种时间复杂度为：O(n!)的算法】</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//实现两数交换</span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">var tmp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//递归实现数组全排列并打印</span><br><span class="line">function permutation(arr, index) &#123;</span><br><span class="line">if(index == arr.length) &#123; //全排列结束</span><br><span class="line">console.log(arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">for(var i = index; i &lt; arr.length; i++) &#123;</span><br><span class="line">//将第i个元素交换至当前index下标处</span><br><span class="line">swap(arr, index, i);</span><br><span class="line">//以递归的方式对剩下元素进行全排列</span><br><span class="line">permutation(arr, index + 1);</span><br><span class="line">//将第i个元素交换回原处</span><br><span class="line">swap(arr, index, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line">var arr = [1, 2, 3]</span><br><span class="line">permutation(arr, 0);</span><br><span class="line">&#125;</span><br><span class="line">main();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="一年半经验，百度、有赞、阿里面试总结"><a href="#一年半经验，百度、有赞、阿里面试总结" class="headerlink" title="一年半经验，百度、有赞、阿里面试总结"></a><a href="https://juejin.im/post/5befeb5051882511a8527dbe" target="_blank" rel="noopener">一年半经验，百度、有赞、阿里面试总结</a></h3><h3 id="2018-大厂高级前端面试题汇总"><a href="#2018-大厂高级前端面试题汇总" class="headerlink" title="2018 大厂高级前端面试题汇总"></a><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651555265&amp;idx=1&amp;sn=d60e4f4f5a145f8e93187d51fae57a43&amp;chksm=80255200b752db160ff8569d0795b8eaac096b8c62b30b3cf0ff93340c6f6a0b3b172ec308aa&amp;mpshare=1&amp;scene=1&amp;srcid=1118bWRTURLW0bpQa841O5x7#rd" target="_blank" rel="noopener">2018 大厂高级前端面试题汇总</a></h3><h3 id="Google-Chrome可跨域模式"><a href="#Google-Chrome可跨域模式" class="headerlink" title="Google Chrome可跨域模式"></a>Google Chrome可跨域模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -a &apos;Google Chrome&apos; --args --disable-web-security  --user-data-dir</span><br></pre></td></tr></table></figure><h3 id="v-for-循环-index的传值问题"><a href="#v-for-循环-index的传值问题" class="headerlink" title="v-for 循环 index的传值问题"></a>v-for 循环 index的传值问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-submenu :index=&quot;index&quot; v-for=&quot;(item,index) in menuList&quot;&gt;</span><br><span class="line">    &lt;el-menu-item :index=&quot;index&quot; </span><br><span class="line">       v-for=&quot;(subItem,subindex) in item.subMenuList&quot;&gt;</span><br><span class="line">        &#123;&#123;index&#125;&#125;-&#123;&#123;subItem.subMenuName&#125;&#125;&lt;/el-menu-item&gt;</span><br><span class="line">  </span><br><span class="line">&lt;/el-submenu&gt;</span><br></pre></td></tr></table></figure><p>发现子组件获取到的index一直都是undefined。</p><p>修改办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;el-menu-item :index=&quot;&apos;&apos;+index&quot; </span><br><span class="line">     v-for=&quot;(subItem,subindex) in item.subMenuList&quot;&gt;</span><br><span class="line">  &#123;&#123;index&#125;&#125;-&#123;&#123;subItem.subMenuName&#125;&#125;</span><br><span class="line">&lt;/el-menu-item&gt;</span><br></pre></td></tr></table></figure></p><p>将 :index 的制改为’’+index，一定是单引号’’ ，子组件获取的到的就变成字符串”0,””1”…..</p><p>将字符串”0”变成整数   +”0” 即可！</p><h3 id="vue文件的一个小细节"><a href="#vue文件的一个小细节" class="headerlink" title=".vue文件的一个小细节"></a>.vue文件的一个小细节</h3><p>top.vue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;ds&quot;&gt;</span><br><span class="line">&lt;div class=&quot;left&quot;&gt;</span><br><span class="line">&lt;p&gt;SX&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;right&quot;&gt;</span><br><span class="line">&lt;p&gt;SB&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(&quot;-------------------------&quot;);     //只执行一次</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    export default &#123;</span><br><span class="line">        props: [],</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components: &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        created() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            console.log(&quot;$$$$$$$$$$$$$$$$$$$$$$$&quot;)；  //执行多次</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped=&quot;scoped&quot;&gt;</span><br><span class="line">.guize &#123;</span><br><span class="line">box-sizing: border-box;</span><br><span class="line">padding: 0 0.4rem;</span><br><span class="line">margin-top: -0.3rem;</span><br><span class="line">width: 100%;</span><br><span class="line">height: 1.2rem;</span><br><span class="line">font-size: 0.24rem;</span><br><span class="line">color: white;</span><br><span class="line">position: relative;</span><br><span class="line">.left &#123;</span><br><span class="line">color: #abc4ed;</span><br><span class="line">float: left;</span><br><span class="line">transform:scale(0.85);</span><br><span class="line">transform-origin:0 0; </span><br><span class="line">p &#123;</span><br><span class="line">font-size: 0.24rem;</span><br><span class="line">line-height: 2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">float: left;</span><br><span class="line">width: 1.6rem;</span><br><span class="line">height: 0.44rem;</span><br><span class="line">line-height: 0.44rem;</span><br><span class="line">border: 1px solid white;</span><br><span class="line">color: white;</span><br><span class="line">border-radius: 0.24rem;</span><br><span class="line">text-align: center;</span><br><span class="line">position: absolute;</span><br><span class="line">right: 0.4rem;</span><br><span class="line">bottom: 0.04rem;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2015/01/01/JS原生常用API大全/v2-57add9333368254c8b108fdd00160585_hd.jpg" alt=""><br><img src="/2015/01/01/JS原生常用API大全/v2-2ac46bc7c3c82fdde73c1f53cf8e39d5_hd.jpg" alt=""></p><h3 id="由浏览器端判断是否支持WebP格式"><a href="#由浏览器端判断是否支持WebP格式" class="headerlink" title="由浏览器端判断是否支持WebP格式"></a>由浏览器端判断是否支持WebP格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(document.createElement(&apos;canvas&apos;).toDataURL(&apos;image/webp&apos;).indexOf(&apos;data:image/webp&apos;) == 0)&#123;</span><br><span class="line">   //  该浏览器支持WebP格式的图片</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="src转img"><a href="#src转img" class="headerlink" title="src转img"></a>src转img</h3><pre><code>function srctoimg(src){  return new Promise((reslove,reject)=&gt;{    let img = new Image()    img.onload = function(){      reslove(img)    }    img.onerror = function(err) {      reject(err)    }    img.src = src  })}</code></pre><h3 id="img转canvas"><a href="#img转canvas" class="headerlink" title="img转canvas"></a>img转canvas</h3><pre><code>function imgtocanvas(img){  let canvas = document.createElement(&quot;canvas&quot;);  let ctx = canvas.getContext(&apos;2d&apos;)  canvas.width = img.width  canvas.height = img.height  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);  return canvas}</code></pre><h3 id="ImageData转canvas"><a href="#ImageData转canvas" class="headerlink" title="ImageData转canvas"></a>ImageData转canvas</h3><pre><code>function ImageDatetocanvas(imgData){ let canvas = document.createElement(&quot;canvas&quot;); let ctx = canvas.getContext(&apos;2d&apos;) canvas.width = imgData.width canvas.height = imgData.height ctx.putImageData(imgData,canvas.width, canvas.height); return canvas}</code></pre><h3 id="canvas转ImageData"><a href="#canvas转ImageData" class="headerlink" title="canvas转ImageData"></a>canvas转ImageData</h3><pre><code>function canvastoImageDate(canvas){ let ctx = canvas.getContext(&apos;2d&apos;) return ctx.createImageData(canvas.width,canvas.height)}</code></pre><h3 id="canvas像素操作"><a href="#canvas像素操作" class="headerlink" title="canvas像素操作"></a>canvas像素操作</h3><pre><code>function canvaspixel(canvas,deal) {  let ctx = canvas.getContext(&apos;2d&apos;)  var imgData = ctx.createImageData(canvas.width, canvas.height);  for (var i = 0; i &lt; imgData.data.length; i += 4) {    deal(r,g,b,a)  }  ctx.putImageData(imgData, canvas.width, canvas.height);  return canvas}</code></pre><h3 id="canava转DataURL-base64"><a href="#canava转DataURL-base64" class="headerlink" title="canava转DataURL(base64)"></a>canava转DataURL(base64)</h3><pre><code>canvas.toDataURL()</code></pre><h3 id="DataURL-base64-转blob"><a href="#DataURL-base64-转blob" class="headerlink" title="DataURL(base64)转blob"></a>DataURL(base64)转blob</h3><pre><code>function dataURLtoBlob(dataurl) {  var arr = dataurl.split(&apos;,&apos;), mime = arr[0].match(/:(.*?);/)[1],    bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);  while (n--) {    u8arr[n] = bstr.charCodeAt(n);  }  return new Blob([u8arr], { type: mime });}</code></pre><h3 id="file转arrayBuffer"><a href="#file转arrayBuffer" class="headerlink" title="file转arrayBuffer"></a>file转arrayBuffer</h3><pre><code>function filetoblob(file){  return new Promise((resolve, reject) =&gt; {    var reader = new FileReader();    reader.readAsArrayBuffer(file);    reader.onload = function (e) {      resolve(reader.result)    }  })}</code></pre><h3 id="file转blob"><a href="#file转blob" class="headerlink" title="file转blob"></a>file转blob</h3><pre><code>function filetoblob(file){  return new Promise((resolve, reject) =&gt; {    var reader = new FileReader();    reader.readAsArrayBuffer(file);    reader.onload = function (e) {      resolve(new Blob([reader.result],{type:file.type}))    }  })}</code></pre><h3 id="blob-arraybuffer-转file"><a href="#blob-arraybuffer-转file" class="headerlink" title="(blob,arraybuffer)转file"></a>(blob,arraybuffer)转file</h3><pre><code>function blobtofile(blob,name){    return new File([blob], name ,{type:blob.type})}</code></pre><h3 id="file-blob-转DataURL-base64"><a href="#file-blob-转DataURL-base64" class="headerlink" title="file(blob)转DataURL(base64)"></a>file(blob)转DataURL(base64)</h3><pre><code>function filetoblob(file) {  return new Promise((resolve, reject) =&gt; {    var reader = new FileReader();    reader.readAsDataURL(file);    reader.onload = function (e) {      resolve(reader.result)    }    reader.onerror = function (e) {      resolve(reader.result)    }  })}</code></pre><h3 id="dataURL转File"><a href="#dataURL转File" class="headerlink" title="dataURL转File"></a>dataURL转File</h3><pre><code>function dataURLtoFile(dataurl, filename) {    var arr = dataurl.split(&apos;,&apos;), mime = arr[0].match(/:(.*?);/)[1],        bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);    while(n--){        u8arr[n] = bstr.charCodeAt(n);    }    return new File([u8arr], filename, {type:mime});}</code></pre><h3 id="blob转objectURL"><a href="#blob转objectURL" class="headerlink" title="blob转objectURL"></a>blob转objectURL</h3><pre><code>window.URL.createObjectURL(blob)</code></pre><h3 id="objectURL转img"><a href="#objectURL转img" class="headerlink" title="objectURL转img"></a>objectURL转img</h3><pre><code>srctoimg(src)</code></pre><h3 id="objectURL-url-转blob"><a href="#objectURL-url-转blob" class="headerlink" title="objectURL(url)转blob"></a>objectURL(url)转blob</h3><pre><code>functionURLtoblob(){    return new Promise((resolve, reject) =&gt; {      const xhr = new XMLHttpRequest()      xhr.open(&apos;GET&apos;, input)      xhr.responseType = &apos;blob&apos;      xhr.onload = () =&gt; {        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {          resolve(xhr.response)        } else {          reject(xhr.statusText)        }      }      xhr.onerror = () =&gt; reject(xhr.statusText)      xhr.send()    })  }}</code></pre><h3 id="objectURL-url-转arraybuffer，当服务端传递二级制数据时使用"><a href="#objectURL-url-转arraybuffer，当服务端传递二级制数据时使用" class="headerlink" title="objectURL(url)转arraybuffer，当服务端传递二级制数据时使用"></a>objectURL(url)转arraybuffer，当服务端传递二级制数据时使用</h3><pre><code>functionURLtoblob(){    return new Promise((resolve, reject) =&gt; {      const xhr = new XMLHttpRequest()      xhr.open(&apos;GET&apos;, input)      xhr.responseType = &apos;arraybuffer&apos;      xhr.onload = () =&gt; {        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) {          resolve(xhr.response)        } else {          reject(xhr.statusText)        }      }      xhr.onerror = () =&gt; reject(xhr.statusText)      xhr.send()    })  }}</code></pre><h3 id="FormData设置blob"><a href="#FormData设置blob" class="headerlink" title="FormData设置blob"></a>FormData设置blob</h3><pre><code>function appendBlob(blob){ var fd = new FormData(); fd.append(&quot;image&quot;, blob, &quot;image.png&quot;); return fd}</code></pre><h3 id="Uint8ClampedArray-Uint8Array-区别"><a href="#Uint8ClampedArray-Uint8Array-区别" class="headerlink" title="Uint8ClampedArray Uint8Array 区别"></a>Uint8ClampedArray Uint8Array 区别</h3><pre><code>Uint8ClampedArray  1 ,它会将负数归入0，大于255的数归入255，所以取模就不用了。 2 ,小数取整Uint8Array 1,Uint8Array([-23]) 等价于 new Uint8Array([ 233 ])  2,四舍五入在处理0-255无区别</code></pre><h3 id="arraybuffer-视图-Uint8Array、Float64Array等-之slice"><a href="#arraybuffer-视图-Uint8Array、Float64Array等-之slice" class="headerlink" title="arraybuffer,视图(Uint8Array、Float64Array等)之slice"></a>arraybuffer,视图(Uint8Array、Float64Array等)之slice</h3><p>buf返回buf<br>视图返回视图<br>1,分配内存<br>2，拷贝数据</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>1,new ArrayBuffer(40)<br>2,new Uint8Array( [ 1, 2, 3, 4 ] )<br>3,Array.from(uint8Array);</p><h3 id="视图参数"><a href="#视图参数" class="headerlink" title="视图参数"></a>视图参数</h3><p>var v3 = new Int16Array(buf, 2, 2);<br>第一个参数：视图对应的底层ArrayBuffer对象，该参数是必需的。<br>第二个参数：视图开始的字节序号，默认从0开始。<br>第三个参数：视图包含的数据个数，默认直到本段内存区域结束。</p><p>视图.buffer 获取缓冲区</p><h3 id="视图对象DataView"><a href="#视图对象DataView" class="headerlink" title="视图对象DataView"></a>视图对象DataView</h3><pre><code>var buffer = new ArrayBuffer(24);var dv = new DataView(buffer);// 从第1个字节读取一个8位无符号整数var v1 = dv.getUint8(0);// 从第2个字节读取一个16位无符号整数var v2 = dv.getUint16(1); // 从第4个字节读取一个16位无符号整数var v3 = dv.getUint16(3);setInt8：写入1个字节的8位整数。setUint8：写入1个字节的8位无符号整数。setInt16：写入2个字节的16位整数。setUint16：写入2个字节的16位无符号整数。setInt32：写入4个字节的32位整数。setUint32：写入4个字节的32位无符号整数。setFloat32：写入4个字节的32位浮点数。setFloat64：写入8个字节的64位浮点数。// 在第1个字节，以大端字节序写入值为25的32位整数dv.setInt32(0, 25, false); // 在第5个字节，以大端字节序写入值为25的32位整数dv.setInt32(4, 25); // 在第9个字节，以小端字节序写入值为2.5的32位浮点数dv.setFloat32(8, 2.5, true);</code></pre><h3 id="实现atob-string-转-base64-window-atob"><a href="#实现atob-string-转-base64-window-atob" class="headerlink" title="实现atob(string 转 base64) window.atob"></a>实现atob(string 转 base64) window.atob</h3><pre><code>function _atob(s) {  var base64hash = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&apos;;  s = s.replace(/\s|=/g, &apos;&apos;);  var cur,    prev,    mod,    i = 0,    result = [];  while (i &lt; s.length) {    cur = base64hash.indexOf(s.charAt(i));    mod = i % 4;    switch (mod) {      case 0:        //TODO        break;      case 1:        result.push(String.fromCharCode(prev &lt;&lt; 2 | cur &gt;&gt; 4));        break;      case 2:        result.push(String.fromCharCode((prev &amp; 0x0f) &lt;&lt; 4 | cur &gt;&gt; 2));        break;      case 3:        result.push(String.fromCharCode((prev &amp; 3) &lt;&lt; 6 | cur));        break;    }    prev = cur;    i++;  }  return result.join(&apos;&apos;);}</code></pre><h3 id="实现btoa-base64-转-string-window-btoa"><a href="#实现btoa-base64-转-string-window-btoa" class="headerlink" title="实现btoa(base64 转 string) window.btoa"></a>实现btoa(base64 转 string) window.btoa</h3><pre><code>function _btoa(s) {  var base64hash = &apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&apos;;  if (/([^\u0000-\u00ff])/.test(s)) {    throw new Error(&apos;INVALID_CHARACTER_ERR&apos;);  }  var i = 0,    prev,    ascii,    mod,    result = [];  while (i &lt; s.length) {    ascii = s.charCodeAt(i);    mod = i % 3;    switch (mod) {      // 第一个6位只需要让8位二进制右移两位      case 0:        result.push(base64hash.charAt(ascii &gt;&gt; 2));        break;      //第二个6位 = 第一个8位的后两位 + 第二个8位的前4位      case 1:        result.push(base64hash.charAt((prev &amp; 3) &lt;&lt; 4 | (ascii &gt;&gt; 4)));        break;      //第三个6位 = 第二个8位的后4位 + 第三个8位的前2位      //第4个6位 = 第三个8位的后6位      case 2:        result.push(base64hash.charAt((prev &amp; 0x0f) &lt;&lt; 2 | (ascii &gt;&gt; 6)));        result.push(base64hash.charAt(ascii &amp; 0x3f));        break;    }    prev = ascii;    i++;  }  // 循环结束后看mod, 为0 证明需补3个6位，第一个为最后一个8位的最后两位后面补4个0。另外两个6位对应的是异常的“=”；  // mod为1，证明还需补两个6位，一个是最后一个8位的后4位补两个0，另一个对应异常的“=”  if (mod == 0) {    result.push(base64hash.charAt((prev &amp; 3) &lt;&lt; 4));    result.push(&apos;==&apos;);  } elseif (mod == 1) {    result.push(base64hash.charAt((prev &amp; 0x0f) &lt;&lt; 2));    result.push(&apos;=&apos;);  }  return result.join(&apos;&apos;);}</code></pre><h3 id="atob-btoa-不能编码解码中文"><a href="#atob-btoa-不能编码解码中文" class="headerlink" title="atob,btoa 不能编码解码中文"></a>atob,btoa 不能编码解码中文</h3><pre><code>var str = &quot;China，中国&quot;;window.btoa(window.encodeURIComponent(str))//&quot;Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ=&quot;window.decodeURIComponent(window.atob(&apos;Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ=&apos;))//&quot;China，中国&quot;</code></pre><h3 id="编码含义"><a href="#编码含义" class="headerlink" title="编码含义"></a>编码含义</h3><pre><code>1，区分数据部分和参数部分2，解决中文乱码(服务端和客户端编码不一致)escape不编码字符有69个：*，+，-，.，/，@，_，0-9，a-z，A-ZencodeURI不编码字符有82个：!，#，$，&amp;，&apos;，(，)，*，+，,，-，.，/，:，;，=，?，@，_，~，0-9，a-z，A-ZencodeURIComponent不编码字符有71个：!， &apos;，(，)，*，-，.，_，~，0-9，a-z，A-Z</code></pre><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><blockquote><p>JS内存空间分为栈(stack)、堆(heap)、池(一般也会归类为栈中)。 其中栈存放变量，堆存放复杂对象，池存放常量。</p></blockquote><h4 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h4><p> 内存分配 — 内存使用 — 内存回收</p><h4 id="内存回收算法"><a href="#内存回收算法" class="headerlink" title="内存回收算法"></a>内存回收算法</h4><ul><li>引用计数算法</li></ul><p>存在一个致命的问题：循环引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。</p><ul><li>标记清除算法</li></ul><p>标记清除算法将“不再使用的对象”定义为“无法达到的对象”。从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。<br>内存泄漏</p><h4 id="内存泄漏的识别方法"><a href="#内存泄漏的识别方法" class="headerlink" title="内存泄漏的识别方法"></a>内存泄漏的识别方法</h4><ul><li>浏览器方法</li><li>命令行方法</li><li>WeakMap（ES6）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
